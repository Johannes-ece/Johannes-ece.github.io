import {
  EditContext,
  setEditing,
  useEditState
} from "./chunk-ZCWQWUSR.js";
import {
  use_isomorphic_layout_effect_browser_esm_default
} from "./chunk-NLVYSTXD.js";
import {
  _extends,
  _objectWithoutPropertiesLoose
} from "./chunk-5VJ6JMN4.js";
import {
  buildClientSchema,
  buildSchema,
  getIntrospectionQuery,
  isEnumType,
  isInputObjectType,
  isInterfaceType,
  isListType,
  isNonNullType,
  isObjectType,
  isScalarType,
  isUnionType,
  isWrappingType,
  parse,
  print
} from "./chunk-RMYGERCM.js";
import {
  require_react_dom,
  require_scheduler
} from "./chunk-KBB5QSWM.js";
import {
  Editor_default,
  loader_default,
  require_prop_types,
  useMonaco_default
} from "./chunk-TBTOOFFX.js";
import {
  require_object_assign,
  require_react
} from "./chunk-KJ3DELDC.js";
import {
  __commonJS,
  __export,
  __require,
  __toESM
} from "./chunk-OZI5HTJH.js";

// node_modules/direction/index.js
var require_direction = __commonJS({
  "node_modules/direction/index.js"(exports2, module2) {
    "use strict";
    module2.exports = direction;
    var RTL = "֑-߿יִ-﷽ﹰ-ﻼ";
    var LTR = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿";
    var rtl = new RegExp("^[^" + LTR + "]*[" + RTL + "]");
    var ltr = new RegExp("^[^" + RTL + "]*[" + LTR + "]");
    function direction(value) {
      value = String(value || "");
      if (rtl.test(value)) {
        return "rtl";
      }
      if (ltr.test(value)) {
        return "ltr";
      }
      return "neutral";
    }
  }
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS({
  "node_modules/lodash/isObject.js"(exports2, module2) {
    function isObject10(value) {
      var type = typeof value;
      return value != null && (type == "object" || type == "function");
    }
    module2.exports = isObject10;
  }
});

// node_modules/lodash/_freeGlobal.js
var require_freeGlobal = __commonJS({
  "node_modules/lodash/_freeGlobal.js"(exports2, module2) {
    var freeGlobal6 = typeof global == "object" && global && global.Object === Object && global;
    module2.exports = freeGlobal6;
  }
});

// node_modules/lodash/_root.js
var require_root = __commonJS({
  "node_modules/lodash/_root.js"(exports2, module2) {
    var freeGlobal6 = require_freeGlobal();
    var freeSelf6 = typeof self == "object" && self && self.Object === Object && self;
    var root6 = freeGlobal6 || freeSelf6 || Function("return this")();
    module2.exports = root6;
  }
});

// node_modules/lodash/now.js
var require_now = __commonJS({
  "node_modules/lodash/now.js"(exports2, module2) {
    var root6 = require_root();
    var now3 = function() {
      return root6.Date.now();
    };
    module2.exports = now3;
  }
});

// node_modules/lodash/_trimmedEndIndex.js
var require_trimmedEndIndex = __commonJS({
  "node_modules/lodash/_trimmedEndIndex.js"(exports2, module2) {
    var reWhitespace2 = /\s/;
    function trimmedEndIndex2(string2) {
      var index2 = string2.length;
      while (index2-- && reWhitespace2.test(string2.charAt(index2))) {
      }
      return index2;
    }
    module2.exports = trimmedEndIndex2;
  }
});

// node_modules/lodash/_baseTrim.js
var require_baseTrim = __commonJS({
  "node_modules/lodash/_baseTrim.js"(exports2, module2) {
    var trimmedEndIndex2 = require_trimmedEndIndex();
    var reTrimStart2 = /^\s+/;
    function baseTrim2(string2) {
      return string2 ? string2.slice(0, trimmedEndIndex2(string2) + 1).replace(reTrimStart2, "") : string2;
    }
    module2.exports = baseTrim2;
  }
});

// node_modules/lodash/_Symbol.js
var require_Symbol = __commonJS({
  "node_modules/lodash/_Symbol.js"(exports2, module2) {
    var root6 = require_root();
    var Symbol5 = root6.Symbol;
    module2.exports = Symbol5;
  }
});

// node_modules/lodash/_getRawTag.js
var require_getRawTag = __commonJS({
  "node_modules/lodash/_getRawTag.js"(exports2, module2) {
    var Symbol5 = require_Symbol();
    var objectProto20 = Object.prototype;
    var hasOwnProperty17 = objectProto20.hasOwnProperty;
    var nativeObjectToString7 = objectProto20.toString;
    var symToStringTag7 = Symbol5 ? Symbol5.toStringTag : void 0;
    function getRawTag6(value) {
      var isOwn = hasOwnProperty17.call(value, symToStringTag7), tag = value[symToStringTag7];
      try {
        value[symToStringTag7] = void 0;
        var unmasked = true;
      } catch (e9) {
      }
      var result = nativeObjectToString7.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag7] = tag;
        } else {
          delete value[symToStringTag7];
        }
      }
      return result;
    }
    module2.exports = getRawTag6;
  }
});

// node_modules/lodash/_objectToString.js
var require_objectToString = __commonJS({
  "node_modules/lodash/_objectToString.js"(exports2, module2) {
    var objectProto20 = Object.prototype;
    var nativeObjectToString7 = objectProto20.toString;
    function objectToString6(value) {
      return nativeObjectToString7.call(value);
    }
    module2.exports = objectToString6;
  }
});

// node_modules/lodash/_baseGetTag.js
var require_baseGetTag = __commonJS({
  "node_modules/lodash/_baseGetTag.js"(exports2, module2) {
    var Symbol5 = require_Symbol();
    var getRawTag6 = require_getRawTag();
    var objectToString6 = require_objectToString();
    var nullTag6 = "[object Null]";
    var undefinedTag6 = "[object Undefined]";
    var symToStringTag7 = Symbol5 ? Symbol5.toStringTag : void 0;
    function baseGetTag6(value) {
      if (value == null) {
        return value === void 0 ? undefinedTag6 : nullTag6;
      }
      return symToStringTag7 && symToStringTag7 in Object(value) ? getRawTag6(value) : objectToString6(value);
    }
    module2.exports = baseGetTag6;
  }
});

// node_modules/lodash/isObjectLike.js
var require_isObjectLike = __commonJS({
  "node_modules/lodash/isObjectLike.js"(exports2, module2) {
    function isObjectLike6(value) {
      return value != null && typeof value == "object";
    }
    module2.exports = isObjectLike6;
  }
});

// node_modules/lodash/isSymbol.js
var require_isSymbol = __commonJS({
  "node_modules/lodash/isSymbol.js"(exports2, module2) {
    var baseGetTag6 = require_baseGetTag();
    var isObjectLike6 = require_isObjectLike();
    var symbolTag6 = "[object Symbol]";
    function isSymbol3(value) {
      return typeof value == "symbol" || isObjectLike6(value) && baseGetTag6(value) == symbolTag6;
    }
    module2.exports = isSymbol3;
  }
});

// node_modules/lodash/toNumber.js
var require_toNumber = __commonJS({
  "node_modules/lodash/toNumber.js"(exports2, module2) {
    var baseTrim2 = require_baseTrim();
    var isObject10 = require_isObject();
    var isSymbol3 = require_isSymbol();
    var NAN2 = 0 / 0;
    var reIsBadHex2 = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary2 = /^0b[01]+$/i;
    var reIsOctal2 = /^0o[0-7]+$/i;
    var freeParseInt2 = parseInt;
    function toNumber2(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol3(value)) {
        return NAN2;
      }
      if (isObject10(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject10(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = baseTrim2(value);
      var isBinary = reIsBinary2.test(value);
      return isBinary || reIsOctal2.test(value) ? freeParseInt2(value.slice(2), isBinary ? 2 : 8) : reIsBadHex2.test(value) ? NAN2 : +value;
    }
    module2.exports = toNumber2;
  }
});

// node_modules/lodash/debounce.js
var require_debounce = __commonJS({
  "node_modules/lodash/debounce.js"(exports2, module2) {
    var isObject10 = require_isObject();
    var now3 = require_now();
    var toNumber2 = require_toNumber();
    var FUNC_ERROR_TEXT6 = "Expected a function";
    var nativeMax4 = Math.max;
    var nativeMin2 = Math.min;
    function debounce4(func, wait, options) {
      var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT6);
      }
      wait = toNumber2(wait) || 0;
      if (isObject10(options)) {
        leading = !!options.leading;
        maxing = "maxWait" in options;
        maxWait = maxing ? nativeMax4(toNumber2(options.maxWait) || 0, wait) : maxWait;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      function invokeFunc(time) {
        var args = lastArgs, thisArg = lastThis;
        lastArgs = lastThis = void 0;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }
      function leadingEdge(time) {
        lastInvokeTime = time;
        timerId = setTimeout(timerExpired, wait);
        return leading ? invokeFunc(time) : result;
      }
      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
        return maxing ? nativeMin2(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
      }
      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
        return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
      }
      function timerExpired() {
        var time = now3();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        timerId = setTimeout(timerExpired, remainingWait(time));
      }
      function trailingEdge(time) {
        timerId = void 0;
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = void 0;
        return result;
      }
      function cancel() {
        if (timerId !== void 0) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = void 0;
      }
      function flush3() {
        return timerId === void 0 ? result : trailingEdge(now3());
      }
      function debounced() {
        var time = now3(), isInvoking = shouldInvoke(time);
        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;
        if (isInvoking) {
          if (timerId === void 0) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === void 0) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush3;
      return debounced;
    }
    module2.exports = debounce4;
  }
});

// node_modules/lodash/throttle.js
var require_throttle = __commonJS({
  "node_modules/lodash/throttle.js"(exports2, module2) {
    var debounce4 = require_debounce();
    var isObject10 = require_isObject();
    var FUNC_ERROR_TEXT6 = "Expected a function";
    function throttle3(func, wait, options) {
      var leading = true, trailing = true;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT6);
      }
      if (isObject10(options)) {
        leading = "leading" in options ? !!options.leading : leading;
        trailing = "trailing" in options ? !!options.trailing : trailing;
      }
      return debounce4(func, wait, {
        "leading": leading,
        "maxWait": wait,
        "trailing": trailing
      });
    }
    module2.exports = throttle3;
  }
});

// node_modules/slate-react/node_modules/is-hotkey/lib/index.js
var require_lib = __commonJS({
  "node_modules/slate-react/node_modules/is-hotkey/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var IS_MAC = typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
    var MODIFIERS = {
      alt: "altKey",
      control: "ctrlKey",
      meta: "metaKey",
      shift: "shiftKey"
    };
    var ALIASES = {
      add: "+",
      break: "pause",
      cmd: "meta",
      command: "meta",
      ctl: "control",
      ctrl: "control",
      del: "delete",
      down: "arrowdown",
      esc: "escape",
      ins: "insert",
      left: "arrowleft",
      mod: IS_MAC ? "meta" : "control",
      opt: "alt",
      option: "alt",
      return: "enter",
      right: "arrowright",
      space: " ",
      spacebar: " ",
      up: "arrowup",
      win: "meta",
      windows: "meta"
    };
    var CODES = {
      backspace: 8,
      tab: 9,
      enter: 13,
      shift: 16,
      control: 17,
      alt: 18,
      pause: 19,
      capslock: 20,
      escape: 27,
      " ": 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      arrowleft: 37,
      arrowup: 38,
      arrowright: 39,
      arrowdown: 40,
      insert: 45,
      delete: 46,
      meta: 91,
      numlock: 144,
      scrolllock: 145,
      ";": 186,
      "=": 187,
      ",": 188,
      "-": 189,
      ".": 190,
      "/": 191,
      "`": 192,
      "[": 219,
      "\\": 220,
      "]": 221,
      "'": 222
    };
    for (f16 = 1; f16 < 20; f16++) {
      CODES["f" + f16] = 111 + f16;
    }
    var f16;
    function isHotkey14(hotkey, options, event) {
      if (options && !("byKey" in options)) {
        event = options;
        options = null;
      }
      if (!Array.isArray(hotkey)) {
        hotkey = [hotkey];
      }
      var array2 = hotkey.map(function(string2) {
        return parseHotkey(string2, options);
      });
      var check = function check2(e9) {
        return array2.some(function(object2) {
          return compareHotkey(object2, e9);
        });
      };
      var ret = event == null ? check : check(event);
      return ret;
    }
    function isCodeHotkey(hotkey, event) {
      return isHotkey14(hotkey, event);
    }
    function isKeyHotkey2(hotkey, event) {
      return isHotkey14(hotkey, { byKey: true }, event);
    }
    function parseHotkey(hotkey, options) {
      var byKey = options && options.byKey;
      var ret = {};
      hotkey = hotkey.replace("++", "+add");
      var values3 = hotkey.split("+");
      var length = values3.length;
      for (var k3 in MODIFIERS) {
        ret[MODIFIERS[k3]] = false;
      }
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = values3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var value = _step.value;
          var optional = value.endsWith("?") && value.length > 1;
          if (optional) {
            value = value.slice(0, -1);
          }
          var name2 = toKeyName(value);
          var modifier = MODIFIERS[name2];
          if (length === 1 || !modifier) {
            if (byKey) {
              ret.key = name2;
            } else {
              ret.which = toKeyCode(value);
            }
          }
          if (modifier) {
            ret[modifier] = optional ? null : true;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return ret;
    }
    function compareHotkey(object2, event) {
      for (var key in object2) {
        var expected = object2[key];
        var actual = void 0;
        if (expected == null) {
          continue;
        }
        if (key === "key" && event.key != null) {
          actual = event.key.toLowerCase();
        } else if (key === "which") {
          actual = expected === 91 && event.which === 93 ? 91 : event.which;
        } else {
          actual = event[key];
        }
        if (actual == null && expected === false) {
          continue;
        }
        if (actual !== expected) {
          return false;
        }
      }
      return true;
    }
    function toKeyCode(name2) {
      name2 = toKeyName(name2);
      var code = CODES[name2] || name2.toUpperCase().charCodeAt(0);
      return code;
    }
    function toKeyName(name2) {
      name2 = name2.toLowerCase();
      name2 = ALIASES[name2] || name2;
      return name2;
    }
    exports2.default = isHotkey14;
    exports2.isHotkey = isHotkey14;
    exports2.isCodeHotkey = isCodeHotkey;
    exports2.isKeyHotkey = isKeyHotkey2;
    exports2.parseHotkey = parseHotkey;
    exports2.compareHotkey = compareHotkey;
    exports2.toKeyCode = toKeyCode;
    exports2.toKeyName = toKeyName;
  }
});

// node_modules/prismjs/prism.js
var require_prism = __commonJS({
  "node_modules/prismjs/prism.js"(exports2, module2) {
    var _self = typeof window !== "undefined" ? window : typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope ? self : {};
    var Prism2 = function(_self2) {
      var lang2 = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
      var uniqueId = 0;
      var plainTextGrammar = {};
      var _7 = {
        /**
         * By default, Prism will attempt to highlight all code elements (by calling {@link Prism.highlightAll}) on the
         * current page after the page finished loading. This might be a problem if e.g. you wanted to asynchronously load
         * additional languages or plugins yourself.
         *
         * By setting this value to `true`, Prism will not automatically highlight all code elements on the page.
         *
         * You obviously have to change this value before the automatic highlighting started. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.manual = true;
         * // add a new <script> to load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        manual: _self2.Prism && _self2.Prism.manual,
        /**
         * By default, if Prism is in a web worker, it assumes that it is in a worker it created itself, so it uses
         * `addEventListener` to communicate with its parent instance. However, if you're using Prism manually in your
         * own worker, you don't want it to do this.
         *
         * By setting this value to `true`, Prism will not add its own listeners to the worker.
         *
         * You obviously have to change this value before Prism executes. To do this, you can add an
         * empty Prism object into the global scope before loading the Prism script like this:
         *
         * ```js
         * window.Prism = window.Prism || {};
         * Prism.disableWorkerMessageHandler = true;
         * // Load Prism's script
         * ```
         *
         * @default false
         * @type {boolean}
         * @memberof Prism
         * @public
         */
        disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
        /**
         * A namespace for utility methods.
         *
         * All function in this namespace that are not explicitly marked as _public_ are for __internal use only__ and may
         * change or disappear at any time.
         *
         * @namespace
         * @memberof Prism
         */
        util: {
          encode: function encode2(tokens2) {
            if (tokens2 instanceof Token3) {
              return new Token3(tokens2.type, encode2(tokens2.content), tokens2.alias);
            } else if (Array.isArray(tokens2)) {
              return tokens2.map(encode2);
            } else {
              return tokens2.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ");
            }
          },
          /**
           * Returns the name of the type of the given value.
           *
           * @param {any} o
           * @returns {string}
           * @example
           * type(null)      === 'Null'
           * type(undefined) === 'Undefined'
           * type(123)       === 'Number'
           * type('foo')     === 'String'
           * type(true)      === 'Boolean'
           * type([1, 2])    === 'Array'
           * type({})        === 'Object'
           * type(String)    === 'Function'
           * type(/abc+/)    === 'RegExp'
           */
          type: function(o16) {
            return Object.prototype.toString.call(o16).slice(8, -1);
          },
          /**
           * Returns a unique number for the given object. Later calls will still return the same number.
           *
           * @param {Object} obj
           * @returns {number}
           */
          objId: function(obj) {
            if (!obj["__id"]) {
              Object.defineProperty(obj, "__id", { value: ++uniqueId });
            }
            return obj["__id"];
          },
          /**
           * Creates a deep clone of the given object.
           *
           * The main intended use of this function is to clone language definitions.
           *
           * @param {T} o
           * @param {Record<number, any>} [visited]
           * @returns {T}
           * @template T
           */
          clone: function deepClone(o16, visited) {
            visited = visited || {};
            var clone4;
            var id;
            switch (_7.util.type(o16)) {
              case "Object":
                id = _7.util.objId(o16);
                if (visited[id]) {
                  return visited[id];
                }
                clone4 = /** @type {Record<string, any>} */
                {};
                visited[id] = clone4;
                for (var key in o16) {
                  if (o16.hasOwnProperty(key)) {
                    clone4[key] = deepClone(o16[key], visited);
                  }
                }
                return (
                  /** @type {any} */
                  clone4
                );
              case "Array":
                id = _7.util.objId(o16);
                if (visited[id]) {
                  return visited[id];
                }
                clone4 = [];
                visited[id] = clone4;
                /** @type {Array} */
                /** @type {any} */
                o16.forEach(function(v6, i15) {
                  clone4[i15] = deepClone(v6, visited);
                });
                return (
                  /** @type {any} */
                  clone4
                );
              default:
                return o16;
            }
          },
          /**
           * Returns the Prism language of the given element set by a `language-xxxx` or `lang-xxxx` class.
           *
           * If no language is set for the element or the element is `null` or `undefined`, `none` will be returned.
           *
           * @param {Element} element
           * @returns {string}
           */
          getLanguage: function(element) {
            while (element) {
              var m10 = lang2.exec(element.className);
              if (m10) {
                return m10[1].toLowerCase();
              }
              element = element.parentElement;
            }
            return "none";
          },
          /**
           * Sets the Prism `language-xxxx` class of the given element.
           *
           * @param {Element} element
           * @param {string} language
           * @returns {void}
           */
          setLanguage: function(element, language) {
            element.className = element.className.replace(RegExp(lang2, "gi"), "");
            element.classList.add("language-" + language);
          },
          /**
           * Returns the script element that is currently executing.
           *
           * This does __not__ work for line script element.
           *
           * @returns {HTMLScriptElement | null}
           */
          currentScript: function() {
            if (typeof document === "undefined") {
              return null;
            }
            if ("currentScript" in document && 1 < 2) {
              return (
                /** @type {any} */
                document.currentScript
              );
            }
            try {
              throw new Error();
            } catch (err) {
              var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
              if (src) {
                var scripts = document.getElementsByTagName("script");
                for (var i15 in scripts) {
                  if (scripts[i15].src == src) {
                    return scripts[i15];
                  }
                }
              }
              return null;
            }
          },
          /**
           * Returns whether a given class is active for `element`.
           *
           * The class can be activated if `element` or one of its ancestors has the given class and it can be deactivated
           * if `element` or one of its ancestors has the negated version of the given class. The _negated version_ of the
           * given class is just the given class with a `no-` prefix.
           *
           * Whether the class is active is determined by the closest ancestor of `element` (where `element` itself is
           * closest ancestor) that has the given class or the negated version of it. If neither `element` nor any of its
           * ancestors have the given class or the negated version of it, then the default activation will be returned.
           *
           * In the paradoxical situation where the closest ancestor contains __both__ the given class and the negated
           * version of it, the class is considered active.
           *
           * @param {Element} element
           * @param {string} className
           * @param {boolean} [defaultActivation=false]
           * @returns {boolean}
           */
          isActive: function(element, className, defaultActivation) {
            var no2 = "no-" + className;
            while (element) {
              var classList = element.classList;
              if (classList.contains(className)) {
                return true;
              }
              if (classList.contains(no2)) {
                return false;
              }
              element = element.parentElement;
            }
            return !!defaultActivation;
          }
        },
        /**
         * This namespace contains all currently loaded languages and the some helper functions to create and modify languages.
         *
         * @namespace
         * @memberof Prism
         * @public
         */
        languages: {
          /**
           * The grammar for plain, unformatted text.
           */
          plain: plainTextGrammar,
          plaintext: plainTextGrammar,
          text: plainTextGrammar,
          txt: plainTextGrammar,
          /**
           * Creates a deep copy of the language with the given id and appends the given tokens.
           *
           * If a token in `redef` also appears in the copied language, then the existing token in the copied language
           * will be overwritten at its original position.
           *
           * ## Best practices
           *
           * Since the position of overwriting tokens (token in `redef` that overwrite tokens in the copied language)
           * doesn't matter, they can technically be in any order. However, this can be confusing to others that trying to
           * understand the language definition because, normally, the order of tokens matters in Prism grammars.
           *
           * Therefore, it is encouraged to order overwriting tokens according to the positions of the overwritten tokens.
           * Furthermore, all non-overwriting tokens should be placed after the overwriting ones.
           *
           * @param {string} id The id of the language to extend. This has to be a key in `Prism.languages`.
           * @param {Grammar} redef The new tokens to append.
           * @returns {Grammar} The new language created.
           * @public
           * @example
           * Prism.languages['css-with-colors'] = Prism.languages.extend('css', {
           *     // Prism.languages.css already has a 'comment' token, so this token will overwrite CSS' 'comment' token
           *     // at its original position
           *     'comment': { ... },
           *     // CSS doesn't have a 'color' token, so this token will be appended
           *     'color': /\b(?:red|green|blue)\b/
           * });
           */
          extend: function(id, redef) {
            var lang3 = _7.util.clone(_7.languages[id]);
            for (var key in redef) {
              lang3[key] = redef[key];
            }
            return lang3;
          },
          /**
           * Inserts tokens _before_ another token in a language definition or any other grammar.
           *
           * ## Usage
           *
           * This helper method makes it easy to modify existing languages. For example, the CSS language definition
           * not only defines CSS highlighting for CSS documents, but also needs to define highlighting for CSS embedded
           * in HTML through `<style>` elements. To do this, it needs to modify `Prism.languages.markup` and add the
           * appropriate tokens. However, `Prism.languages.markup` is a regular JavaScript object literal, so if you do
           * this:
           *
           * ```js
           * Prism.languages.markup.style = {
           *     // token
           * };
           * ```
           *
           * then the `style` token will be added (and processed) at the end. `insertBefore` allows you to insert tokens
           * before existing tokens. For the CSS example above, you would use it like this:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'cdata', {
           *     'style': {
           *         // token
           *     }
           * });
           * ```
           *
           * ## Special cases
           *
           * If the grammars of `inside` and `insert` have tokens with the same name, the tokens in `inside`'s grammar
           * will be ignored.
           *
           * This behavior can be used to insert tokens after `before`:
           *
           * ```js
           * Prism.languages.insertBefore('markup', 'comment', {
           *     'comment': Prism.languages.markup.comment,
           *     // tokens after 'comment'
           * });
           * ```
           *
           * ## Limitations
           *
           * The main problem `insertBefore` has to solve is iteration order. Since ES2015, the iteration order for object
           * properties is guaranteed to be the insertion order (except for integer keys) but some browsers behave
           * differently when keys are deleted and re-inserted. So `insertBefore` can't be implemented by temporarily
           * deleting properties which is necessary to insert at arbitrary positions.
           *
           * To solve this problem, `insertBefore` doesn't actually insert the given tokens into the target object.
           * Instead, it will create a new object and replace all references to the target object with the new one. This
           * can be done without temporarily deleting properties, so the iteration order is well-defined.
           *
           * However, only references that can be reached from `Prism.languages` or `insert` will be replaced. I.e. if
           * you hold the target object in a variable, then the value of the variable will not change.
           *
           * ```js
           * var oldMarkup = Prism.languages.markup;
           * var newMarkup = Prism.languages.insertBefore('markup', 'comment', { ... });
           *
           * assert(oldMarkup !== Prism.languages.markup);
           * assert(newMarkup === Prism.languages.markup);
           * ```
           *
           * @param {string} inside The property of `root` (e.g. a language id in `Prism.languages`) that contains the
           * object to be modified.
           * @param {string} before The key to insert before.
           * @param {Grammar} insert An object containing the key-value pairs to be inserted.
           * @param {Object<string, any>} [root] The object containing `inside`, i.e. the object that contains the
           * object to be modified.
           *
           * Defaults to `Prism.languages`.
           * @returns {Grammar} The new grammar object.
           * @public
           */
          insertBefore: function(inside, before, insert3, root6) {
            root6 = root6 || /** @type {any} */
            _7.languages;
            var grammar = root6[inside];
            var ret = {};
            for (var token2 in grammar) {
              if (grammar.hasOwnProperty(token2)) {
                if (token2 == before) {
                  for (var newToken in insert3) {
                    if (insert3.hasOwnProperty(newToken)) {
                      ret[newToken] = insert3[newToken];
                    }
                  }
                }
                if (!insert3.hasOwnProperty(token2)) {
                  ret[token2] = grammar[token2];
                }
              }
            }
            var old = root6[inside];
            root6[inside] = ret;
            _7.languages.DFS(_7.languages, function(key, value) {
              if (value === old && key != inside) {
                this[key] = ret;
              }
            });
            return ret;
          },
          // Traverse a language definition with Depth First Search
          DFS: function DFS(o16, callback, type, visited) {
            visited = visited || {};
            var objId = _7.util.objId;
            for (var i15 in o16) {
              if (o16.hasOwnProperty(i15)) {
                callback.call(o16, i15, o16[i15], type || i15);
                var property3 = o16[i15];
                var propertyType = _7.util.type(property3);
                if (propertyType === "Object" && !visited[objId(property3)]) {
                  visited[objId(property3)] = true;
                  DFS(property3, callback, null, visited);
                } else if (propertyType === "Array" && !visited[objId(property3)]) {
                  visited[objId(property3)] = true;
                  DFS(property3, callback, i15, visited);
                }
              }
            }
          }
        },
        plugins: {},
        /**
         * This is the most high-level function in Prism’s API.
         * It fetches all the elements that have a `.language-xxxx` class and then calls {@link Prism.highlightElement} on
         * each one of them.
         *
         * This is equivalent to `Prism.highlightAllUnder(document, async, callback)`.
         *
         * @param {boolean} [async=false] Same as in {@link Prism.highlightAllUnder}.
         * @param {HighlightCallback} [callback] Same as in {@link Prism.highlightAllUnder}.
         * @memberof Prism
         * @public
         */
        highlightAll: function(async, callback) {
          _7.highlightAllUnder(document, async, callback);
        },
        /**
         * Fetches all the descendants of `container` that have a `.language-xxxx` class and then calls
         * {@link Prism.highlightElement} on each one of them.
         *
         * The following hooks will be run:
         * 1. `before-highlightall`
         * 2. `before-all-elements-highlight`
         * 3. All hooks of {@link Prism.highlightElement} for each element.
         *
         * @param {ParentNode} container The root element, whose descendants that have a `.language-xxxx` class will be highlighted.
         * @param {boolean} [async=false] Whether each element is to be highlighted asynchronously using Web Workers.
         * @param {HighlightCallback} [callback] An optional callback to be invoked on each element after its highlighting is done.
         * @memberof Prism
         * @public
         */
        highlightAllUnder: function(container, async, callback) {
          var env = {
            callback,
            container,
            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
          };
          _7.hooks.run("before-highlightall", env);
          env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
          _7.hooks.run("before-all-elements-highlight", env);
          for (var i15 = 0, element; element = env.elements[i15++]; ) {
            _7.highlightElement(element, async === true, env.callback);
          }
        },
        /**
         * Highlights the code inside a single element.
         *
         * The following hooks will be run:
         * 1. `before-sanity-check`
         * 2. `before-highlight`
         * 3. All hooks of {@link Prism.highlight}. These hooks will be run by an asynchronous worker if `async` is `true`.
         * 4. `before-insert`
         * 5. `after-highlight`
         * 6. `complete`
         *
         * Some the above hooks will be skipped if the element doesn't contain any text or there is no grammar loaded for
         * the element's language.
         *
         * @param {Element} element The element containing the code.
         * It must have a class of `language-xxxx` to be processed, where `xxxx` is a valid language identifier.
         * @param {boolean} [async=false] Whether the element is to be highlighted asynchronously using Web Workers
         * to improve performance and avoid blocking the UI when highlighting very large chunks of code. This option is
         * [disabled by default](https://prismjs.com/faq.html#why-is-asynchronous-highlighting-disabled-by-default).
         *
         * Note: All language definitions required to highlight the code must be included in the main `prism.js` file for
         * asynchronous highlighting to work. You can build your own bundle on the
         * [Download page](https://prismjs.com/download.html).
         * @param {HighlightCallback} [callback] An optional callback to be invoked after the highlighting is done.
         * Mostly useful when `async` is `true`, since in that case, the highlighting is done asynchronously.
         * @memberof Prism
         * @public
         */
        highlightElement: function(element, async, callback) {
          var language = _7.util.getLanguage(element);
          var grammar = _7.languages[language];
          _7.util.setLanguage(element, language);
          var parent2 = element.parentElement;
          if (parent2 && parent2.nodeName.toLowerCase() === "pre") {
            _7.util.setLanguage(parent2, language);
          }
          var code = element.textContent;
          var env = {
            element,
            language,
            grammar,
            code
          };
          function insertHighlightedCode(highlightedCode) {
            env.highlightedCode = highlightedCode;
            _7.hooks.run("before-insert", env);
            env.element.innerHTML = env.highlightedCode;
            _7.hooks.run("after-highlight", env);
            _7.hooks.run("complete", env);
            callback && callback.call(env.element);
          }
          _7.hooks.run("before-sanity-check", env);
          parent2 = env.element.parentElement;
          if (parent2 && parent2.nodeName.toLowerCase() === "pre" && !parent2.hasAttribute("tabindex")) {
            parent2.setAttribute("tabindex", "0");
          }
          if (!env.code) {
            _7.hooks.run("complete", env);
            callback && callback.call(env.element);
            return;
          }
          _7.hooks.run("before-highlight", env);
          if (!env.grammar) {
            insertHighlightedCode(_7.util.encode(env.code));
            return;
          }
          if (async && _self2.Worker) {
            var worker = new Worker(_7.filename);
            worker.onmessage = function(evt) {
              insertHighlightedCode(evt.data);
            };
            worker.postMessage(JSON.stringify({
              language: env.language,
              code: env.code,
              immediateClose: true
            }));
          } else {
            insertHighlightedCode(_7.highlight(env.code, env.grammar, env.language));
          }
        },
        /**
         * Low-level function, only use if you know what you’re doing. It accepts a string of text as input
         * and the language definitions to use, and returns a string with the HTML produced.
         *
         * The following hooks will be run:
         * 1. `before-tokenize`
         * 2. `after-tokenize`
         * 3. `wrap`: On each {@link Token}.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @param {string} language The name of the language definition passed to `grammar`.
         * @returns {string} The highlighted HTML.
         * @memberof Prism
         * @public
         * @example
         * Prism.highlight('var foo = true;', Prism.languages.javascript, 'javascript');
         */
        highlight: function(text, grammar, language) {
          var env = {
            code: text,
            grammar,
            language
          };
          _7.hooks.run("before-tokenize", env);
          if (!env.grammar) {
            throw new Error('The language "' + env.language + '" has no grammar.');
          }
          env.tokens = _7.tokenize(env.code, env.grammar);
          _7.hooks.run("after-tokenize", env);
          return Token3.stringify(_7.util.encode(env.tokens), env.language);
        },
        /**
         * This is the heart of Prism, and the most low-level function you can use. It accepts a string of text as input
         * and the language definitions to use, and returns an array with the tokenized code.
         *
         * When the language definition includes nested tokens, the function is called recursively on each of these tokens.
         *
         * This method could be useful in other contexts as well, as a very crude parser.
         *
         * @param {string} text A string with the code to be highlighted.
         * @param {Grammar} grammar An object containing the tokens to use.
         *
         * Usually a language definition like `Prism.languages.markup`.
         * @returns {TokenStream} An array of strings and tokens, a token stream.
         * @memberof Prism
         * @public
         * @example
         * let code = `var foo = 0;`;
         * let tokens = Prism.tokenize(code, Prism.languages.javascript);
         * tokens.forEach(token => {
         *     if (token instanceof Prism.Token && token.type === 'number') {
         *         console.log(`Found numeric literal: ${token.content}`);
         *     }
         * });
         */
        tokenize: function(text, grammar) {
          var rest = grammar.rest;
          if (rest) {
            for (var token2 in rest) {
              grammar[token2] = rest[token2];
            }
            delete grammar.rest;
          }
          var tokenList = new LinkedList();
          addAfter(tokenList, tokenList.head, text);
          matchGrammar(text, tokenList, grammar, tokenList.head, 0);
          return toArray4(tokenList);
        },
        /**
         * @namespace
         * @memberof Prism
         * @public
         */
        hooks: {
          all: {},
          /**
           * Adds the given callback to the list of callbacks for the given hook.
           *
           * The callback will be invoked when the hook it is registered for is run.
           * Hooks are usually directly run by a highlight function but you can also run hooks yourself.
           *
           * One callback function can be registered to multiple hooks and the same hook multiple times.
           *
           * @param {string} name The name of the hook.
           * @param {HookCallback} callback The callback function which is given environment variables.
           * @public
           */
          add: function(name2, callback) {
            var hooks2 = _7.hooks.all;
            hooks2[name2] = hooks2[name2] || [];
            hooks2[name2].push(callback);
          },
          /**
           * Runs a hook invoking all registered callbacks with the given environment variables.
           *
           * Callbacks will be invoked synchronously and in the order in which they were registered.
           *
           * @param {string} name The name of the hook.
           * @param {Object<string, any>} env The environment variables of the hook passed to all callbacks registered.
           * @public
           */
          run: function(name2, env) {
            var callbacks = _7.hooks.all[name2];
            if (!callbacks || !callbacks.length) {
              return;
            }
            for (var i15 = 0, callback; callback = callbacks[i15++]; ) {
              callback(env);
            }
          }
        },
        Token: Token3
      };
      _self2.Prism = _7;
      function Token3(type, content, alias, matchedStr) {
        this.type = type;
        this.content = content;
        this.alias = alias;
        this.length = (matchedStr || "").length | 0;
      }
      Token3.stringify = function stringify(o16, language) {
        if (typeof o16 == "string") {
          return o16;
        }
        if (Array.isArray(o16)) {
          var s20 = "";
          o16.forEach(function(e9) {
            s20 += stringify(e9, language);
          });
          return s20;
        }
        var env = {
          type: o16.type,
          content: stringify(o16.content, language),
          tag: "span",
          classes: ["token", o16.type],
          attributes: {},
          language
        };
        var aliases2 = o16.alias;
        if (aliases2) {
          if (Array.isArray(aliases2)) {
            Array.prototype.push.apply(env.classes, aliases2);
          } else {
            env.classes.push(aliases2);
          }
        }
        _7.hooks.run("wrap", env);
        var attributes = "";
        for (var name2 in env.attributes) {
          attributes += " " + name2 + '="' + (env.attributes[name2] || "").replace(/"/g, "&quot;") + '"';
        }
        return "<" + env.tag + ' class="' + env.classes.join(" ") + '"' + attributes + ">" + env.content + "</" + env.tag + ">";
      };
      function matchPattern(pattern, pos, text, lookbehind) {
        pattern.lastIndex = pos;
        var match5 = pattern.exec(text);
        if (match5 && lookbehind && match5[1]) {
          var lookbehindLength = match5[1].length;
          match5.index += lookbehindLength;
          match5[0] = match5[0].slice(lookbehindLength);
        }
        return match5;
      }
      function matchGrammar(text, tokenList, grammar, startNode, startPos, rematch) {
        for (var token2 in grammar) {
          if (!grammar.hasOwnProperty(token2) || !grammar[token2]) {
            continue;
          }
          var patterns = grammar[token2];
          patterns = Array.isArray(patterns) ? patterns : [patterns];
          for (var j6 = 0; j6 < patterns.length; ++j6) {
            if (rematch && rematch.cause == token2 + "," + j6) {
              return;
            }
            var patternObj = patterns[j6];
            var inside = patternObj.inside;
            var lookbehind = !!patternObj.lookbehind;
            var greedy = !!patternObj.greedy;
            var alias = patternObj.alias;
            if (greedy && !patternObj.pattern.global) {
              var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
              patternObj.pattern = RegExp(patternObj.pattern.source, flags + "g");
            }
            var pattern = patternObj.pattern || patternObj;
            for (var currentNode = startNode.next, pos = startPos; currentNode !== tokenList.tail; pos += currentNode.value.length, currentNode = currentNode.next) {
              if (rematch && pos >= rematch.reach) {
                break;
              }
              var str = currentNode.value;
              if (tokenList.length > text.length) {
                return;
              }
              if (str instanceof Token3) {
                continue;
              }
              var removeCount = 1;
              var match5;
              if (greedy) {
                match5 = matchPattern(pattern, pos, text, lookbehind);
                if (!match5 || match5.index >= text.length) {
                  break;
                }
                var from2 = match5.index;
                var to4 = match5.index + match5[0].length;
                var p12 = pos;
                p12 += currentNode.value.length;
                while (from2 >= p12) {
                  currentNode = currentNode.next;
                  p12 += currentNode.value.length;
                }
                p12 -= currentNode.value.length;
                pos = p12;
                if (currentNode.value instanceof Token3) {
                  continue;
                }
                for (var k3 = currentNode; k3 !== tokenList.tail && (p12 < to4 || typeof k3.value === "string"); k3 = k3.next) {
                  removeCount++;
                  p12 += k3.value.length;
                }
                removeCount--;
                str = text.slice(pos, p12);
                match5.index -= pos;
              } else {
                match5 = matchPattern(pattern, 0, str, lookbehind);
                if (!match5) {
                  continue;
                }
              }
              var from2 = match5.index;
              var matchStr = match5[0];
              var before = str.slice(0, from2);
              var after = str.slice(from2 + matchStr.length);
              var reach2 = pos + str.length;
              if (rematch && reach2 > rematch.reach) {
                rematch.reach = reach2;
              }
              var removeFrom = currentNode.prev;
              if (before) {
                removeFrom = addAfter(tokenList, removeFrom, before);
                pos += before.length;
              }
              removeRange(tokenList, removeFrom, removeCount);
              var wrapped = new Token3(token2, inside ? _7.tokenize(matchStr, inside) : matchStr, alias, matchStr);
              currentNode = addAfter(tokenList, removeFrom, wrapped);
              if (after) {
                addAfter(tokenList, currentNode, after);
              }
              if (removeCount > 1) {
                var nestedRematch = {
                  cause: token2 + "," + j6,
                  reach: reach2
                };
                matchGrammar(text, tokenList, grammar, currentNode.prev, pos, nestedRematch);
                if (rematch && nestedRematch.reach > rematch.reach) {
                  rematch.reach = nestedRematch.reach;
                }
              }
            }
          }
        }
      }
      function LinkedList() {
        var head = { value: null, prev: null, next: null };
        var tail = { value: null, prev: head, next: null };
        head.next = tail;
        this.head = head;
        this.tail = tail;
        this.length = 0;
      }
      function addAfter(list, node, value) {
        var next = node.next;
        var newNode = { value, prev: node, next };
        node.next = newNode;
        next.prev = newNode;
        list.length++;
        return newNode;
      }
      function removeRange(list, node, count2) {
        var next = node.next;
        for (var i15 = 0; i15 < count2 && next !== list.tail; i15++) {
          next = next.next;
        }
        node.next = next;
        next.prev = node;
        list.length -= i15;
      }
      function toArray4(list) {
        var array2 = [];
        var node = list.head.next;
        while (node !== list.tail) {
          array2.push(node.value);
          node = node.next;
        }
        return array2;
      }
      if (!_self2.document) {
        if (!_self2.addEventListener) {
          return _7;
        }
        if (!_7.disableWorkerMessageHandler) {
          _self2.addEventListener("message", function(evt) {
            var message = JSON.parse(evt.data);
            var lang3 = message.language;
            var code = message.code;
            var immediateClose = message.immediateClose;
            _self2.postMessage(_7.highlight(code, _7.languages[lang3], lang3));
            if (immediateClose) {
              _self2.close();
            }
          }, false);
        }
        return _7;
      }
      var script = _7.util.currentScript();
      if (script) {
        _7.filename = script.src;
        if (script.hasAttribute("data-manual")) {
          _7.manual = true;
        }
      }
      function highlightAutomaticallyCallback() {
        if (!_7.manual) {
          _7.highlightAll();
        }
      }
      if (!_7.manual) {
        var readyState = document.readyState;
        if (readyState === "loading" || readyState === "interactive" && script && script.defer) {
          document.addEventListener("DOMContentLoaded", highlightAutomaticallyCallback);
        } else {
          if (window.requestAnimationFrame) {
            window.requestAnimationFrame(highlightAutomaticallyCallback);
          } else {
            window.setTimeout(highlightAutomaticallyCallback, 16);
          }
        }
      }
      return _7;
    }(_self);
    if (typeof module2 !== "undefined" && module2.exports) {
      module2.exports = Prism2;
    }
    if (typeof global !== "undefined") {
      global.Prism = Prism2;
    }
    Prism2.languages.markup = {
      "comment": {
        pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
        greedy: true
      },
      "prolog": {
        pattern: /<\?[\s\S]+?\?>/,
        greedy: true
      },
      "doctype": {
        // https://www.w3.org/TR/xml/#NT-doctypedecl
        pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
        greedy: true,
        inside: {
          "internal-subset": {
            pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
            lookbehind: true,
            greedy: true,
            inside: null
            // see below
          },
          "string": {
            pattern: /"[^"]*"|'[^']*'/,
            greedy: true
          },
          "punctuation": /^<!|>$|[[\]]/,
          "doctype-tag": /^DOCTYPE/i,
          "name": /[^\s<>'"]+/
        }
      },
      "cdata": {
        pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
        greedy: true
      },
      "tag": {
        pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
        greedy: true,
        inside: {
          "tag": {
            pattern: /^<\/?[^\s>\/]+/,
            inside: {
              "punctuation": /^<\/?/,
              "namespace": /^[^\s>\/:]+:/
            }
          },
          "special-attr": [],
          "attr-value": {
            pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
            inside: {
              "punctuation": [
                {
                  pattern: /^=/,
                  alias: "attr-equals"
                },
                {
                  pattern: /^(\s*)["']|["']$/,
                  lookbehind: true
                }
              ]
            }
          },
          "punctuation": /\/?>/,
          "attr-name": {
            pattern: /[^\s>\/]+/,
            inside: {
              "namespace": /^[^\s>\/:]+:/
            }
          }
        }
      },
      "entity": [
        {
          pattern: /&[\da-z]{1,8};/i,
          alias: "named-entity"
        },
        /&#x?[\da-f]{1,8};/i
      ]
    };
    Prism2.languages.markup["tag"].inside["attr-value"].inside["entity"] = Prism2.languages.markup["entity"];
    Prism2.languages.markup["doctype"].inside["internal-subset"].inside = Prism2.languages.markup;
    Prism2.hooks.add("wrap", function(env) {
      if (env.type === "entity") {
        env.attributes["title"] = env.content.replace(/&amp;/, "&");
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addInlined", {
      /**
       * Adds an inlined language to markup.
       *
       * An example of an inlined language is CSS with `<style>` tags.
       *
       * @param {string} tagName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addInlined('style', 'css');
       */
      value: function addInlined(tagName, lang2) {
        var includedCdataInside = {};
        includedCdataInside["language-" + lang2] = {
          pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
          lookbehind: true,
          inside: Prism2.languages[lang2]
        };
        includedCdataInside["cdata"] = /^<!\[CDATA\[|\]\]>$/i;
        var inside = {
          "included-cdata": {
            pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
            inside: includedCdataInside
          }
        };
        inside["language-" + lang2] = {
          pattern: /[\s\S]+/,
          inside: Prism2.languages[lang2]
        };
        var def = {};
        def[tagName] = {
          pattern: RegExp(/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(/__/g, function() {
            return tagName;
          }), "i"),
          lookbehind: true,
          greedy: true,
          inside
        };
        Prism2.languages.insertBefore("markup", "cdata", def);
      }
    });
    Object.defineProperty(Prism2.languages.markup.tag, "addAttribute", {
      /**
       * Adds an pattern to highlight languages embedded in HTML attributes.
       *
       * An example of an inlined language is CSS with `style` attributes.
       *
       * @param {string} attrName The name of the tag that contains the inlined language. This name will be treated as
       * case insensitive.
       * @param {string} lang The language key.
       * @example
       * addAttribute('style', 'css');
       */
      value: function(attrName, lang2) {
        Prism2.languages.markup.tag.inside["special-attr"].push({
          pattern: RegExp(
            /(^|["'\s])/.source + "(?:" + attrName + ")" + /\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
            "i"
          ),
          lookbehind: true,
          inside: {
            "attr-name": /^[^\s=]+/,
            "attr-value": {
              pattern: /=[\s\S]+/,
              inside: {
                "value": {
                  pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
                  lookbehind: true,
                  alias: [lang2, "language-" + lang2],
                  inside: Prism2.languages[lang2]
                },
                "punctuation": [
                  {
                    pattern: /^=/,
                    alias: "attr-equals"
                  },
                  /"|'/
                ]
              }
            }
          }
        });
      }
    });
    Prism2.languages.html = Prism2.languages.markup;
    Prism2.languages.mathml = Prism2.languages.markup;
    Prism2.languages.svg = Prism2.languages.markup;
    Prism2.languages.xml = Prism2.languages.extend("markup", {});
    Prism2.languages.ssml = Prism2.languages.xml;
    Prism2.languages.atom = Prism2.languages.xml;
    Prism2.languages.rss = Prism2.languages.xml;
    (function(Prism3) {
      var string2 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
      Prism3.languages.css = {
        "comment": /\/\*[\s\S]*?\*\//,
        "atrule": {
          pattern: RegExp("@[\\w-](?:" + /[^;{\s"']|\s+(?!\s)/.source + "|" + string2.source + ")*?" + /(?:;|(?=\s*\{))/.source),
          inside: {
            "rule": /^@[\w-]+/,
            "selector-function-argument": {
              pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
              lookbehind: true,
              alias: "selector"
            },
            "keyword": {
              pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
              lookbehind: true
            }
            // See rest below
          }
        },
        "url": {
          // https://drafts.csswg.org/css-values-3/#urls
          pattern: RegExp("\\burl\\((?:" + string2.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
          greedy: true,
          inside: {
            "function": /^url/i,
            "punctuation": /^\(|\)$/,
            "string": {
              pattern: RegExp("^" + string2.source + "$"),
              alias: "url"
            }
          }
        },
        "selector": {
          pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string2.source + ")*(?=\\s*\\{)"),
          lookbehind: true
        },
        "string": {
          pattern: string2,
          greedy: true
        },
        "property": {
          pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
          lookbehind: true
        },
        "important": /!important\b/i,
        "function": {
          pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
          lookbehind: true
        },
        "punctuation": /[(){};:,]/
      };
      Prism3.languages.css["atrule"].inside.rest = Prism3.languages.css;
      var markup = Prism3.languages.markup;
      if (markup) {
        markup.tag.addInlined("style", "css");
        markup.tag.addAttribute("style", "css");
      }
    })(Prism2);
    Prism2.languages.clike = {
      "comment": [
        {
          pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
          lookbehind: true,
          greedy: true
        },
        {
          pattern: /(^|[^\\:])\/\/.*/,
          lookbehind: true,
          greedy: true
        }
      ],
      "string": {
        pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
        greedy: true
      },
      "class-name": {
        pattern: /(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
        lookbehind: true,
        inside: {
          "punctuation": /[.\\]/
        }
      },
      "keyword": /\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
      "boolean": /\b(?:false|true)\b/,
      "function": /\b\w+(?=\()/,
      "number": /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
      "operator": /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
      "punctuation": /[{}[\];(),.:]/
    };
    Prism2.languages.javascript = Prism2.languages.extend("clike", {
      "class-name": [
        Prism2.languages.clike["class-name"],
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
          lookbehind: true
        }
      ],
      "keyword": [
        {
          pattern: /((?:^|\})\s*)catch\b/,
          lookbehind: true
        },
        {
          pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
          lookbehind: true
        }
      ],
      // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
      "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
      "number": {
        pattern: RegExp(
          /(^|[^\w$])/.source + "(?:" + // constant
          (/NaN|Infinity/.source + "|" + // binary integer
          /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
          /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
          /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
          /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
          /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
        ),
        lookbehind: true
      },
      "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
    });
    Prism2.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
    Prism2.languages.insertBefore("javascript", "keyword", {
      "regex": {
        pattern: RegExp(
          // lookbehind
          // eslint-disable-next-line regexp/no-dupe-characters-character-class
          /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
          // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
          // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
          // with the only syntax, so we have to define 2 different regex patterns.
          /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
          /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
          /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
        ),
        lookbehind: true,
        greedy: true,
        inside: {
          "regex-source": {
            pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
            lookbehind: true,
            alias: "language-regex",
            inside: Prism2.languages.regex
          },
          "regex-delimiter": /^\/|\/$/,
          "regex-flags": /^[a-z]+$/
        }
      },
      // This must be declared before keyword because we use "function" inside the look-forward
      "function-variable": {
        pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
        alias: "function"
      },
      "parameter": [
        {
          pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        },
        {
          pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
          lookbehind: true,
          inside: Prism2.languages.javascript
        }
      ],
      "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
    });
    Prism2.languages.insertBefore("javascript", "string", {
      "hashbang": {
        pattern: /^#!.*/,
        greedy: true,
        alias: "comment"
      },
      "template-string": {
        pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
        greedy: true,
        inside: {
          "template-punctuation": {
            pattern: /^`|`$/,
            alias: "string"
          },
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
            lookbehind: true,
            inside: {
              "interpolation-punctuation": {
                pattern: /^\$\{|\}$/,
                alias: "punctuation"
              },
              rest: Prism2.languages.javascript
            }
          },
          "string": /[\s\S]+/
        }
      },
      "string-property": {
        pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
        lookbehind: true,
        greedy: true,
        alias: "property"
      }
    });
    Prism2.languages.insertBefore("javascript", "operator", {
      "literal-property": {
        pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
        lookbehind: true,
        alias: "property"
      }
    });
    if (Prism2.languages.markup) {
      Prism2.languages.markup.tag.addInlined("script", "javascript");
      Prism2.languages.markup.tag.addAttribute(
        /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
        "javascript"
      );
    }
    Prism2.languages.js = Prism2.languages.javascript;
    (function() {
      if (typeof Prism2 === "undefined" || typeof document === "undefined") {
        return;
      }
      if (!Element.prototype.matches) {
        Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
      }
      var LOADING_MESSAGE = "Loading…";
      var FAILURE_MESSAGE = function(status, message) {
        return "✖ Error " + status + " while fetching file: " + message;
      };
      var FAILURE_EMPTY_MESSAGE = "✖ Error: File does not exist or is empty";
      var EXTENSIONS = {
        "js": "javascript",
        "py": "python",
        "rb": "ruby",
        "ps1": "powershell",
        "psm1": "powershell",
        "sh": "bash",
        "bat": "batch",
        "h": "c",
        "tex": "latex"
      };
      var STATUS_ATTR = "data-src-status";
      var STATUS_LOADING = "loading";
      var STATUS_LOADED = "loaded";
      var STATUS_FAILED = "failed";
      var SELECTOR = "pre[data-src]:not([" + STATUS_ATTR + '="' + STATUS_LOADED + '"]):not([' + STATUS_ATTR + '="' + STATUS_LOADING + '"])';
      function loadFile(src, success, error2) {
        var xhr = new XMLHttpRequest();
        xhr.open("GET", src, true);
        xhr.onreadystatechange = function() {
          if (xhr.readyState == 4) {
            if (xhr.status < 400 && xhr.responseText) {
              success(xhr.responseText);
            } else {
              if (xhr.status >= 400) {
                error2(FAILURE_MESSAGE(xhr.status, xhr.statusText));
              } else {
                error2(FAILURE_EMPTY_MESSAGE);
              }
            }
          }
        };
        xhr.send(null);
      }
      function parseRange(range) {
        var m10 = /^\s*(\d+)\s*(?:(,)\s*(?:(\d+)\s*)?)?$/.exec(range || "");
        if (m10) {
          var start3 = Number(m10[1]);
          var comma = m10[2];
          var end2 = m10[3];
          if (!comma) {
            return [start3, start3];
          }
          if (!end2) {
            return [start3, void 0];
          }
          return [start3, Number(end2)];
        }
        return void 0;
      }
      Prism2.hooks.add("before-highlightall", function(env) {
        env.selector += ", " + SELECTOR;
      });
      Prism2.hooks.add("before-sanity-check", function(env) {
        var pre = (
          /** @type {HTMLPreElement} */
          env.element
        );
        if (pre.matches(SELECTOR)) {
          env.code = "";
          pre.setAttribute(STATUS_ATTR, STATUS_LOADING);
          var code = pre.appendChild(document.createElement("CODE"));
          code.textContent = LOADING_MESSAGE;
          var src = pre.getAttribute("data-src");
          var language = env.language;
          if (language === "none") {
            var extension = (/\.(\w+)$/.exec(src) || [, "none"])[1];
            language = EXTENSIONS[extension] || extension;
          }
          Prism2.util.setLanguage(code, language);
          Prism2.util.setLanguage(pre, language);
          var autoloader = Prism2.plugins.autoloader;
          if (autoloader) {
            autoloader.loadLanguages(language);
          }
          loadFile(
            src,
            function(text) {
              pre.setAttribute(STATUS_ATTR, STATUS_LOADED);
              var range = parseRange(pre.getAttribute("data-range"));
              if (range) {
                var lines = text.split(/\r\n?|\n/g);
                var start3 = range[0];
                var end2 = range[1] == null ? lines.length : range[1];
                if (start3 < 0) {
                  start3 += lines.length;
                }
                start3 = Math.max(0, Math.min(start3 - 1, lines.length));
                if (end2 < 0) {
                  end2 += lines.length;
                }
                end2 = Math.max(0, Math.min(end2, lines.length));
                text = lines.slice(start3, end2).join("\n");
                if (!pre.hasAttribute("data-start")) {
                  pre.setAttribute("data-start", String(start3 + 1));
                }
              }
              code.textContent = text;
              Prism2.highlightElement(code);
            },
            function(error2) {
              pre.setAttribute(STATUS_ATTR, STATUS_FAILED);
              code.textContent = error2;
            }
          );
        }
      });
      Prism2.plugins.fileHighlight = {
        /**
         * Executes the File Highlight plugin for all matching `pre` elements under the given container.
         *
         * Note: Elements which are already loaded or currently loading will not be touched by this method.
         *
         * @param {ParentNode} [container=document]
         */
        highlight: function highlight(container) {
          var elements = (container || document).querySelectorAll(SELECTOR);
          for (var i15 = 0, element; element = elements[i15++]; ) {
            Prism2.highlightElement(element);
          }
        }
      };
      var logged = false;
      Prism2.fileHighlight = function() {
        if (!logged) {
          console.warn("Prism.fileHighlight is deprecated. Use `Prism.plugins.fileHighlight.highlight` instead.");
          logged = true;
        }
        Prism2.plugins.fileHighlight.highlight.apply(this, arguments);
      };
    })();
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        var REACT_FRAGMENT_TYPE = 60107;
        var REACT_STRICT_MODE_TYPE = 60108;
        var REACT_PROFILER_TYPE = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        var REACT_SUSPENSE_TYPE = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
          REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
          REACT_PROFILER_TYPE = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        var enableScopeAPI = false;
        function isValidElementType2(type) {
          if (typeof type === "string" || typeof type === "function") {
            return true;
          }
          if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI) {
            return true;
          }
          if (typeof type === "object" && type !== null) {
            if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object2) {
          if (typeof object2 === "object" && object2 !== null) {
            var $$typeof = object2.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object2.type;
                switch (type) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element4 = REACT_ELEMENT_TYPE;
        var ForwardRef2 = REACT_FORWARD_REF_TYPE;
        var Fragment8 = REACT_FRAGMENT_TYPE;
        var Lazy2 = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object2) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object2) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer2(object2) {
          return typeOf(object2) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object2) {
          return typeOf(object2) === REACT_PROVIDER_TYPE;
        }
        function isElement5(object2) {
          return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef2(object2) {
          return typeOf(object2) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object2) {
          return typeOf(object2) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object2) {
          return typeOf(object2) === REACT_LAZY_TYPE;
        }
        function isMemo(object2) {
          return typeOf(object2) === REACT_MEMO_TYPE;
        }
        function isPortal(object2) {
          return typeOf(object2) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object2) {
          return typeOf(object2) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object2) {
          return typeOf(object2) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object2) {
          return typeOf(object2) === REACT_SUSPENSE_TYPE;
        }
        exports2.ContextConsumer = ContextConsumer;
        exports2.ContextProvider = ContextProvider;
        exports2.Element = Element4;
        exports2.ForwardRef = ForwardRef2;
        exports2.Fragment = Fragment8;
        exports2.Lazy = Lazy2;
        exports2.Memo = Memo;
        exports2.Portal = Portal;
        exports2.Profiler = Profiler;
        exports2.StrictMode = StrictMode;
        exports2.Suspense = Suspense;
        exports2.isAsyncMode = isAsyncMode;
        exports2.isConcurrentMode = isConcurrentMode;
        exports2.isContextConsumer = isContextConsumer2;
        exports2.isContextProvider = isContextProvider;
        exports2.isElement = isElement5;
        exports2.isForwardRef = isForwardRef2;
        exports2.isFragment = isFragment;
        exports2.isLazy = isLazy;
        exports2.isMemo = isMemo;
        exports2.isPortal = isPortal;
        exports2.isProfiler = isProfiler;
        exports2.isStrictMode = isStrictMode;
        exports2.isSuspense = isSuspense;
        exports2.isValidElementType = isValidElementType2;
        exports2.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_is_development();
    }
  }
});

// node_modules/papaparse/papaparse.min.js
var require_papaparse_min = __commonJS({
  "node_modules/papaparse/papaparse.min.js"(exports2, module2) {
    !function(e9, t20) {
      "function" == typeof define && define.amd ? define([], t20) : "object" == typeof module2 && "undefined" != typeof exports2 ? module2.exports = t20() : e9.Papa = t20();
    }(exports2, function s20() {
      "use strict";
      var f16 = "undefined" != typeof self ? self : "undefined" != typeof window ? window : void 0 !== f16 ? f16 : {};
      var n12 = !f16.document && !!f16.postMessage, o16 = f16.IS_PAPA_WORKER || false, a13 = {}, u11 = 0, b6 = { parse: function(e9, t20) {
        var r16 = (t20 = t20 || {}).dynamicTyping || false;
        J4(r16) && (t20.dynamicTypingFunction = r16, r16 = {});
        if (t20.dynamicTyping = r16, t20.transform = !!J4(t20.transform) && t20.transform, t20.worker && b6.WORKERS_SUPPORTED) {
          var i15 = function() {
            if (!b6.WORKERS_SUPPORTED)
              return false;
            var e10 = (r17 = f16.URL || f16.webkitURL || null, i16 = s20.toString(), b6.BLOB_URL || (b6.BLOB_URL = r17.createObjectURL(new Blob(["var global = (function() { if (typeof self !== 'undefined') { return self; } if (typeof window !== 'undefined') { return window; } if (typeof global !== 'undefined') { return global; } return {}; })(); global.IS_PAPA_WORKER=true; ", "(", i16, ")();"], { type: "text/javascript" })))), t21 = new f16.Worker(e10);
            var r17, i16;
            return t21.onmessage = _7, t21.id = u11++, a13[t21.id] = t21;
          }();
          return i15.userStep = t20.step, i15.userChunk = t20.chunk, i15.userComplete = t20.complete, i15.userError = t20.error, t20.step = J4(t20.step), t20.chunk = J4(t20.chunk), t20.complete = J4(t20.complete), t20.error = J4(t20.error), delete t20.worker, void i15.postMessage({ input: e9, config: t20, workerId: i15.id });
        }
        var n13 = null;
        b6.NODE_STREAM_INPUT, "string" == typeof e9 ? (e9 = function(e10) {
          if (65279 === e10.charCodeAt(0))
            return e10.slice(1);
          return e10;
        }(e9), n13 = t20.download ? new l14(t20) : new p12(t20)) : true === e9.readable && J4(e9.read) && J4(e9.on) ? n13 = new g6(t20) : (f16.File && e9 instanceof File || e9 instanceof Object) && (n13 = new c16(t20));
        return n13.stream(e9);
      }, unparse: function(e9, t20) {
        var n13 = false, _8 = true, m11 = ",", y10 = "\r\n", s21 = '"', a14 = s21 + s21, r16 = false, i15 = null, o17 = false;
        !function() {
          if ("object" != typeof t20)
            return;
          "string" != typeof t20.delimiter || b6.BAD_DELIMITERS.filter(function(e10) {
            return -1 !== t20.delimiter.indexOf(e10);
          }).length || (m11 = t20.delimiter);
          ("boolean" == typeof t20.quotes || "function" == typeof t20.quotes || Array.isArray(t20.quotes)) && (n13 = t20.quotes);
          "boolean" != typeof t20.skipEmptyLines && "string" != typeof t20.skipEmptyLines || (r16 = t20.skipEmptyLines);
          "string" == typeof t20.newline && (y10 = t20.newline);
          "string" == typeof t20.quoteChar && (s21 = t20.quoteChar);
          "boolean" == typeof t20.header && (_8 = t20.header);
          if (Array.isArray(t20.columns)) {
            if (0 === t20.columns.length)
              throw new Error("Option columns is empty");
            i15 = t20.columns;
          }
          void 0 !== t20.escapeChar && (a14 = t20.escapeChar + s21);
          ("boolean" == typeof t20.escapeFormulae || t20.escapeFormulae instanceof RegExp) && (o17 = t20.escapeFormulae instanceof RegExp ? t20.escapeFormulae : /^[=+\-@\t\r].*$/);
        }();
        var u12 = new RegExp(Q7(s21), "g");
        "string" == typeof e9 && (e9 = JSON.parse(e9));
        if (Array.isArray(e9)) {
          if (!e9.length || Array.isArray(e9[0]))
            return h12(null, e9, r16);
          if ("object" == typeof e9[0])
            return h12(i15 || Object.keys(e9[0]), e9, r16);
        } else if ("object" == typeof e9)
          return "string" == typeof e9.data && (e9.data = JSON.parse(e9.data)), Array.isArray(e9.data) && (e9.fields || (e9.fields = e9.meta && e9.meta.fields || i15), e9.fields || (e9.fields = Array.isArray(e9.data[0]) ? e9.fields : "object" == typeof e9.data[0] ? Object.keys(e9.data[0]) : []), Array.isArray(e9.data[0]) || "object" == typeof e9.data[0] || (e9.data = [e9.data])), h12(e9.fields || [], e9.data || [], r16);
        throw new Error("Unable to serialize unrecognized input");
        function h12(e10, t21, r17) {
          var i16 = "";
          "string" == typeof e10 && (e10 = JSON.parse(e10)), "string" == typeof t21 && (t21 = JSON.parse(t21));
          var n14 = Array.isArray(e10) && 0 < e10.length, s22 = !Array.isArray(t21[0]);
          if (n14 && _8) {
            for (var a15 = 0; a15 < e10.length; a15++)
              0 < a15 && (i16 += m11), i16 += v7(e10[a15], a15);
            0 < t21.length && (i16 += y10);
          }
          for (var o18 = 0; o18 < t21.length; o18++) {
            var u13 = n14 ? e10.length : t21[o18].length, h13 = false, f17 = n14 ? 0 === Object.keys(t21[o18]).length : 0 === t21[o18].length;
            if (r17 && !n14 && (h13 = "greedy" === r17 ? "" === t21[o18].join("").trim() : 1 === t21[o18].length && 0 === t21[o18][0].length), "greedy" === r17 && n14) {
              for (var d18 = [], l15 = 0; l15 < u13; l15++) {
                var c17 = s22 ? e10[l15] : l15;
                d18.push(t21[o18][c17]);
              }
              h13 = "" === d18.join("").trim();
            }
            if (!h13) {
              for (var p13 = 0; p13 < u13; p13++) {
                0 < p13 && !f17 && (i16 += m11);
                var g7 = n14 && s22 ? e10[p13] : p13;
                i16 += v7(t21[o18][g7], p13);
              }
              o18 < t21.length - 1 && (!r17 || 0 < u13 && !f17) && (i16 += y10);
            }
          }
          return i16;
        }
        function v7(e10, t21) {
          if (null == e10)
            return "";
          if (e10.constructor === Date)
            return JSON.stringify(e10).slice(1, 25);
          var r17 = false;
          o17 && "string" == typeof e10 && o17.test(e10) && (e10 = "'" + e10, r17 = true);
          var i16 = e10.toString().replace(u12, a14);
          return (r17 = r17 || true === n13 || "function" == typeof n13 && n13(e10, t21) || Array.isArray(n13) && n13[t21] || function(e11, t22) {
            for (var r18 = 0; r18 < t22.length; r18++)
              if (-1 < e11.indexOf(t22[r18]))
                return true;
            return false;
          }(i16, b6.BAD_DELIMITERS) || -1 < i16.indexOf(m11) || " " === i16.charAt(0) || " " === i16.charAt(i16.length - 1)) ? s21 + i16 + s21 : i16;
        }
      } };
      if (b6.RECORD_SEP = String.fromCharCode(30), b6.UNIT_SEP = String.fromCharCode(31), b6.BYTE_ORDER_MARK = "\uFEFF", b6.BAD_DELIMITERS = ["\r", "\n", '"', b6.BYTE_ORDER_MARK], b6.WORKERS_SUPPORTED = !n12 && !!f16.Worker, b6.NODE_STREAM_INPUT = 1, b6.LocalChunkSize = 10485760, b6.RemoteChunkSize = 5242880, b6.DefaultDelimiter = ",", b6.Parser = E8, b6.ParserHandle = r15, b6.NetworkStreamer = l14, b6.FileStreamer = c16, b6.StringStreamer = p12, b6.ReadableStreamStreamer = g6, f16.jQuery) {
        var d17 = f16.jQuery;
        d17.fn.parse = function(o17) {
          var r16 = o17.config || {}, u12 = [];
          return this.each(function(e10) {
            if (!("INPUT" === d17(this).prop("tagName").toUpperCase() && "file" === d17(this).attr("type").toLowerCase() && f16.FileReader) || !this.files || 0 === this.files.length)
              return true;
            for (var t20 = 0; t20 < this.files.length; t20++)
              u12.push({ file: this.files[t20], inputElem: this, instanceConfig: d17.extend({}, r16) });
          }), e9(), this;
          function e9() {
            if (0 !== u12.length) {
              var e10, t20, r17, i15, n13 = u12[0];
              if (J4(o17.before)) {
                var s21 = o17.before(n13.file, n13.inputElem);
                if ("object" == typeof s21) {
                  if ("abort" === s21.action)
                    return e10 = "AbortError", t20 = n13.file, r17 = n13.inputElem, i15 = s21.reason, void (J4(o17.error) && o17.error({ name: e10 }, t20, r17, i15));
                  if ("skip" === s21.action)
                    return void h12();
                  "object" == typeof s21.config && (n13.instanceConfig = d17.extend(n13.instanceConfig, s21.config));
                } else if ("skip" === s21)
                  return void h12();
              }
              var a14 = n13.instanceConfig.complete;
              n13.instanceConfig.complete = function(e11) {
                J4(a14) && a14(e11, n13.file, n13.inputElem), h12();
              }, b6.parse(n13.file, n13.instanceConfig);
            } else
              J4(o17.complete) && o17.complete();
          }
          function h12() {
            u12.splice(0, 1), e9();
          }
        };
      }
      function h11(e9) {
        this._handle = null, this._finished = false, this._completed = false, this._halted = false, this._input = null, this._baseIndex = 0, this._partialLine = "", this._rowCount = 0, this._start = 0, this._nextChunk = null, this.isFirstChunk = true, this._completeResults = { data: [], errors: [], meta: {} }, function(e10) {
          var t20 = w7(e10);
          t20.chunkSize = parseInt(t20.chunkSize), e10.step || e10.chunk || (t20.chunkSize = null);
          this._handle = new r15(t20), (this._handle.streamer = this)._config = t20;
        }.call(this, e9), this.parseChunk = function(e10, t20) {
          if (this.isFirstChunk && J4(this._config.beforeFirstChunk)) {
            var r16 = this._config.beforeFirstChunk(e10);
            void 0 !== r16 && (e10 = r16);
          }
          this.isFirstChunk = false, this._halted = false;
          var i15 = this._partialLine + e10;
          this._partialLine = "";
          var n13 = this._handle.parse(i15, this._baseIndex, !this._finished);
          if (!this._handle.paused() && !this._handle.aborted()) {
            var s21 = n13.meta.cursor;
            this._finished || (this._partialLine = i15.substring(s21 - this._baseIndex), this._baseIndex = s21), n13 && n13.data && (this._rowCount += n13.data.length);
            var a14 = this._finished || this._config.preview && this._rowCount >= this._config.preview;
            if (o16)
              f16.postMessage({ results: n13, workerId: b6.WORKER_ID, finished: a14 });
            else if (J4(this._config.chunk) && !t20) {
              if (this._config.chunk(n13, this._handle), this._handle.paused() || this._handle.aborted())
                return void (this._halted = true);
              n13 = void 0, this._completeResults = void 0;
            }
            return this._config.step || this._config.chunk || (this._completeResults.data = this._completeResults.data.concat(n13.data), this._completeResults.errors = this._completeResults.errors.concat(n13.errors), this._completeResults.meta = n13.meta), this._completed || !a14 || !J4(this._config.complete) || n13 && n13.meta.aborted || (this._config.complete(this._completeResults, this._input), this._completed = true), a14 || n13 && n13.meta.paused || this._nextChunk(), n13;
          }
          this._halted = true;
        }, this._sendError = function(e10) {
          J4(this._config.error) ? this._config.error(e10) : o16 && this._config.error && f16.postMessage({ workerId: b6.WORKER_ID, error: e10, finished: false });
        };
      }
      function l14(e9) {
        var i15;
        (e9 = e9 || {}).chunkSize || (e9.chunkSize = b6.RemoteChunkSize), h11.call(this, e9), this._nextChunk = n12 ? function() {
          this._readChunk(), this._chunkLoaded();
        } : function() {
          this._readChunk();
        }, this.stream = function(e10) {
          this._input = e10, this._nextChunk();
        }, this._readChunk = function() {
          if (this._finished)
            this._chunkLoaded();
          else {
            if (i15 = new XMLHttpRequest(), this._config.withCredentials && (i15.withCredentials = this._config.withCredentials), n12 || (i15.onload = v6(this._chunkLoaded, this), i15.onerror = v6(this._chunkError, this)), i15.open(this._config.downloadRequestBody ? "POST" : "GET", this._input, !n12), this._config.downloadRequestHeaders) {
              var e10 = this._config.downloadRequestHeaders;
              for (var t20 in e10)
                i15.setRequestHeader(t20, e10[t20]);
            }
            if (this._config.chunkSize) {
              var r16 = this._start + this._config.chunkSize - 1;
              i15.setRequestHeader("Range", "bytes=" + this._start + "-" + r16);
            }
            try {
              i15.send(this._config.downloadRequestBody);
            } catch (e11) {
              this._chunkError(e11.message);
            }
            n12 && 0 === i15.status && this._chunkError();
          }
        }, this._chunkLoaded = function() {
          4 === i15.readyState && (i15.status < 200 || 400 <= i15.status ? this._chunkError() : (this._start += this._config.chunkSize ? this._config.chunkSize : i15.responseText.length, this._finished = !this._config.chunkSize || this._start >= function(e10) {
            var t20 = e10.getResponseHeader("Content-Range");
            if (null === t20)
              return -1;
            return parseInt(t20.substring(t20.lastIndexOf("/") + 1));
          }(i15), this.parseChunk(i15.responseText)));
        }, this._chunkError = function(e10) {
          var t20 = i15.statusText || e10;
          this._sendError(new Error(t20));
        };
      }
      function c16(e9) {
        var i15, n13;
        (e9 = e9 || {}).chunkSize || (e9.chunkSize = b6.LocalChunkSize), h11.call(this, e9);
        var s21 = "undefined" != typeof FileReader;
        this.stream = function(e10) {
          this._input = e10, n13 = e10.slice || e10.webkitSlice || e10.mozSlice, s21 ? ((i15 = new FileReader()).onload = v6(this._chunkLoaded, this), i15.onerror = v6(this._chunkError, this)) : i15 = new FileReaderSync(), this._nextChunk();
        }, this._nextChunk = function() {
          this._finished || this._config.preview && !(this._rowCount < this._config.preview) || this._readChunk();
        }, this._readChunk = function() {
          var e10 = this._input;
          if (this._config.chunkSize) {
            var t20 = Math.min(this._start + this._config.chunkSize, this._input.size);
            e10 = n13.call(e10, this._start, t20);
          }
          var r16 = i15.readAsText(e10, this._config.encoding);
          s21 || this._chunkLoaded({ target: { result: r16 } });
        }, this._chunkLoaded = function(e10) {
          this._start += this._config.chunkSize, this._finished = !this._config.chunkSize || this._start >= this._input.size, this.parseChunk(e10.target.result);
        }, this._chunkError = function() {
          this._sendError(i15.error);
        };
      }
      function p12(e9) {
        var r16;
        h11.call(this, e9 = e9 || {}), this.stream = function(e10) {
          return r16 = e10, this._nextChunk();
        }, this._nextChunk = function() {
          if (!this._finished) {
            var e10, t20 = this._config.chunkSize;
            return t20 ? (e10 = r16.substring(0, t20), r16 = r16.substring(t20)) : (e10 = r16, r16 = ""), this._finished = !r16, this.parseChunk(e10);
          }
        };
      }
      function g6(e9) {
        h11.call(this, e9 = e9 || {});
        var t20 = [], r16 = true, i15 = false;
        this.pause = function() {
          h11.prototype.pause.apply(this, arguments), this._input.pause();
        }, this.resume = function() {
          h11.prototype.resume.apply(this, arguments), this._input.resume();
        }, this.stream = function(e10) {
          this._input = e10, this._input.on("data", this._streamData), this._input.on("end", this._streamEnd), this._input.on("error", this._streamError);
        }, this._checkIsFinished = function() {
          i15 && 1 === t20.length && (this._finished = true);
        }, this._nextChunk = function() {
          this._checkIsFinished(), t20.length ? this.parseChunk(t20.shift()) : r16 = true;
        }, this._streamData = v6(function(e10) {
          try {
            t20.push("string" == typeof e10 ? e10 : e10.toString(this._config.encoding)), r16 && (r16 = false, this._checkIsFinished(), this.parseChunk(t20.shift()));
          } catch (e11) {
            this._streamError(e11);
          }
        }, this), this._streamError = v6(function(e10) {
          this._streamCleanUp(), this._sendError(e10);
        }, this), this._streamEnd = v6(function() {
          this._streamCleanUp(), i15 = true, this._streamData("");
        }, this), this._streamCleanUp = v6(function() {
          this._input.removeListener("data", this._streamData), this._input.removeListener("end", this._streamEnd), this._input.removeListener("error", this._streamError);
        }, this);
      }
      function r15(m11) {
        var a14, o17, u12, i15 = Math.pow(2, 53), n13 = -i15, s21 = /^\s*-?(\d+\.?|\.\d+|\d+\.\d+)([eE][-+]?\d+)?\s*$/, h12 = /^((\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z))|(\d{4}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)))$/, t20 = this, r16 = 0, f17 = 0, d18 = false, e9 = false, l15 = [], c17 = { data: [], errors: [], meta: {} };
        if (J4(m11.step)) {
          var p13 = m11.step;
          m11.step = function(e10) {
            if (c17 = e10, _8())
              g7();
            else {
              if (g7(), 0 === c17.data.length)
                return;
              r16 += e10.data.length, m11.preview && r16 > m11.preview ? o17.abort() : (c17.data = c17.data[0], p13(c17, t20));
            }
          };
        }
        function y10(e10) {
          return "greedy" === m11.skipEmptyLines ? "" === e10.join("").trim() : 1 === e10.length && 0 === e10[0].length;
        }
        function g7() {
          return c17 && u12 && (k3("Delimiter", "UndetectableDelimiter", "Unable to auto-detect delimiting character; defaulted to '" + b6.DefaultDelimiter + "'"), u12 = false), m11.skipEmptyLines && (c17.data = c17.data.filter(function(e10) {
            return !y10(e10);
          })), _8() && function() {
            if (!c17)
              return;
            function e10(e11, t22) {
              J4(m11.transformHeader) && (e11 = m11.transformHeader(e11, t22)), l15.push(e11);
            }
            if (Array.isArray(c17.data[0])) {
              for (var t21 = 0; _8() && t21 < c17.data.length; t21++)
                c17.data[t21].forEach(e10);
              c17.data.splice(0, 1);
            } else
              c17.data.forEach(e10);
          }(), function() {
            if (!c17 || !m11.header && !m11.dynamicTyping && !m11.transform)
              return c17;
            function e10(e11, t22) {
              var r17, i16 = m11.header ? {} : [];
              for (r17 = 0; r17 < e11.length; r17++) {
                var n14 = r17, s22 = e11[r17];
                m11.header && (n14 = r17 >= l15.length ? "__parsed_extra" : l15[r17]), m11.transform && (s22 = m11.transform(s22, n14)), s22 = v7(n14, s22), "__parsed_extra" === n14 ? (i16[n14] = i16[n14] || [], i16[n14].push(s22)) : i16[n14] = s22;
              }
              return m11.header && (r17 > l15.length ? k3("FieldMismatch", "TooManyFields", "Too many fields: expected " + l15.length + " fields but parsed " + r17, f17 + t22) : r17 < l15.length && k3("FieldMismatch", "TooFewFields", "Too few fields: expected " + l15.length + " fields but parsed " + r17, f17 + t22)), i16;
            }
            var t21 = 1;
            !c17.data.length || Array.isArray(c17.data[0]) ? (c17.data = c17.data.map(e10), t21 = c17.data.length) : c17.data = e10(c17.data, 0);
            m11.header && c17.meta && (c17.meta.fields = l15);
            return f17 += t21, c17;
          }();
        }
        function _8() {
          return m11.header && 0 === l15.length;
        }
        function v7(e10, t21) {
          return r17 = e10, m11.dynamicTypingFunction && void 0 === m11.dynamicTyping[r17] && (m11.dynamicTyping[r17] = m11.dynamicTypingFunction(r17)), true === (m11.dynamicTyping[r17] || m11.dynamicTyping) ? "true" === t21 || "TRUE" === t21 || "false" !== t21 && "FALSE" !== t21 && (function(e11) {
            if (s21.test(e11)) {
              var t22 = parseFloat(e11);
              if (n13 < t22 && t22 < i15)
                return true;
            }
            return false;
          }(t21) ? parseFloat(t21) : h12.test(t21) ? new Date(t21) : "" === t21 ? null : t21) : t21;
          var r17;
        }
        function k3(e10, t21, r17, i16) {
          var n14 = { type: e10, code: t21, message: r17 };
          void 0 !== i16 && (n14.row = i16), c17.errors.push(n14);
        }
        this.parse = function(e10, t21, r17) {
          var i16 = m11.quoteChar || '"';
          if (m11.newline || (m11.newline = function(e11, t22) {
            e11 = e11.substring(0, 1048576);
            var r18 = new RegExp(Q7(t22) + "([^]*?)" + Q7(t22), "gm"), i17 = (e11 = e11.replace(r18, "")).split("\r"), n15 = e11.split("\n"), s23 = 1 < n15.length && n15[0].length < i17[0].length;
            if (1 === i17.length || s23)
              return "\n";
            for (var a15 = 0, o18 = 0; o18 < i17.length; o18++)
              "\n" === i17[o18][0] && a15++;
            return a15 >= i17.length / 2 ? "\r\n" : "\r";
          }(e10, i16)), u12 = false, m11.delimiter)
            J4(m11.delimiter) && (m11.delimiter = m11.delimiter(e10), c17.meta.delimiter = m11.delimiter);
          else {
            var n14 = function(e11, t22, r18, i17, n15) {
              var s23, a15, o18, u13;
              n15 = n15 || [",", "	", "|", ";", b6.RECORD_SEP, b6.UNIT_SEP];
              for (var h13 = 0; h13 < n15.length; h13++) {
                var f18 = n15[h13], d19 = 0, l16 = 0, c18 = 0;
                o18 = void 0;
                for (var p14 = new E8({ comments: i17, delimiter: f18, newline: t22, preview: 10 }).parse(e11), g8 = 0; g8 < p14.data.length; g8++)
                  if (r18 && y10(p14.data[g8]))
                    c18++;
                  else {
                    var _9 = p14.data[g8].length;
                    l16 += _9, void 0 !== o18 ? 0 < _9 && (d19 += Math.abs(_9 - o18), o18 = _9) : o18 = _9;
                  }
                0 < p14.data.length && (l16 /= p14.data.length - c18), (void 0 === a15 || d19 <= a15) && (void 0 === u13 || u13 < l16) && 1.99 < l16 && (a15 = d19, s23 = f18, u13 = l16);
              }
              return { successful: !!(m11.delimiter = s23), bestDelimiter: s23 };
            }(e10, m11.newline, m11.skipEmptyLines, m11.comments, m11.delimitersToGuess);
            n14.successful ? m11.delimiter = n14.bestDelimiter : (u12 = true, m11.delimiter = b6.DefaultDelimiter), c17.meta.delimiter = m11.delimiter;
          }
          var s22 = w7(m11);
          return m11.preview && m11.header && s22.preview++, a14 = e10, o17 = new E8(s22), c17 = o17.parse(a14, t21, r17), g7(), d18 ? { meta: { paused: true } } : c17 || { meta: { paused: false } };
        }, this.paused = function() {
          return d18;
        }, this.pause = function() {
          d18 = true, o17.abort(), a14 = J4(m11.chunk) ? "" : a14.substring(o17.getCharIndex());
        }, this.resume = function() {
          t20.streamer._halted ? (d18 = false, t20.streamer.parseChunk(a14, true)) : setTimeout(t20.resume, 3);
        }, this.aborted = function() {
          return e9;
        }, this.abort = function() {
          e9 = true, o17.abort(), c17.meta.aborted = true, J4(m11.complete) && m11.complete(c17), a14 = "";
        };
      }
      function Q7(e9) {
        return e9.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
      function E8(j6) {
        var z7, M10 = (j6 = j6 || {}).delimiter, P6 = j6.newline, U6 = j6.comments, q7 = j6.step, N6 = j6.preview, B5 = j6.fastMode, K4 = z7 = void 0 === j6.quoteChar || null === j6.quoteChar ? '"' : j6.quoteChar;
        if (void 0 !== j6.escapeChar && (K4 = j6.escapeChar), ("string" != typeof M10 || -1 < b6.BAD_DELIMITERS.indexOf(M10)) && (M10 = ","), U6 === M10)
          throw new Error("Comment character same as delimiter");
        true === U6 ? U6 = "#" : ("string" != typeof U6 || -1 < b6.BAD_DELIMITERS.indexOf(U6)) && (U6 = false), "\n" !== P6 && "\r" !== P6 && "\r\n" !== P6 && (P6 = "\n");
        var W2 = 0, H9 = false;
        this.parse = function(i15, t20, r16) {
          if ("string" != typeof i15)
            throw new Error("Input must be a string");
          var n13 = i15.length, e9 = M10.length, s21 = P6.length, a14 = U6.length, o17 = J4(q7), u12 = [], h12 = [], f17 = [], d18 = W2 = 0;
          if (!i15)
            return L6();
          if (j6.header && !t20) {
            var l15 = i15.split(P6)[0].split(M10), c17 = [], p13 = {}, g7 = false;
            for (var _8 in l15) {
              var m11 = l15[_8];
              J4(j6.transformHeader) && (m11 = j6.transformHeader(m11, _8));
              var y10 = m11, v7 = p13[m11] || 0;
              for (0 < v7 && (g7 = true, y10 = m11 + "_" + v7), p13[m11] = v7 + 1; c17.includes(y10); )
                y10 = y10 + "_" + v7;
              c17.push(y10);
            }
            if (g7) {
              var k3 = i15.split(P6);
              k3[0] = c17.join(M10), i15 = k3.join(P6);
            }
          }
          if (B5 || false !== B5 && -1 === i15.indexOf(z7)) {
            for (var b7 = i15.split(P6), E9 = 0; E9 < b7.length; E9++) {
              if (f17 = b7[E9], W2 += f17.length, E9 !== b7.length - 1)
                W2 += P6.length;
              else if (r16)
                return L6();
              if (!U6 || f17.substring(0, a14) !== U6) {
                if (o17) {
                  if (u12 = [], I9(f17.split(M10)), F9(), H9)
                    return L6();
                } else
                  I9(f17.split(M10));
                if (N6 && N6 <= E9)
                  return u12 = u12.slice(0, N6), L6(true);
              }
            }
            return L6();
          }
          for (var w8 = i15.indexOf(M10, W2), R4 = i15.indexOf(P6, W2), C5 = new RegExp(Q7(K4) + Q7(z7), "g"), S11 = i15.indexOf(z7, W2); ; )
            if (i15[W2] !== z7)
              if (U6 && 0 === f17.length && i15.substring(W2, W2 + a14) === U6) {
                if (-1 === R4)
                  return L6();
                W2 = R4 + s21, R4 = i15.indexOf(P6, W2), w8 = i15.indexOf(M10, W2);
              } else if (-1 !== w8 && (w8 < R4 || -1 === R4))
                f17.push(i15.substring(W2, w8)), W2 = w8 + e9, w8 = i15.indexOf(M10, W2);
              else {
                if (-1 === R4)
                  break;
                if (f17.push(i15.substring(W2, R4)), D9(R4 + s21), o17 && (F9(), H9))
                  return L6();
                if (N6 && u12.length >= N6)
                  return L6(true);
              }
            else
              for (S11 = W2, W2++; ; ) {
                if (-1 === (S11 = i15.indexOf(z7, S11 + 1)))
                  return r16 || h12.push({ type: "Quotes", code: "MissingQuotes", message: "Quoted field unterminated", row: u12.length, index: W2 }), T7();
                if (S11 === n13 - 1)
                  return T7(i15.substring(W2, S11).replace(C5, z7));
                if (z7 !== K4 || i15[S11 + 1] !== K4) {
                  if (z7 === K4 || 0 === S11 || i15[S11 - 1] !== K4) {
                    -1 !== w8 && w8 < S11 + 1 && (w8 = i15.indexOf(M10, S11 + 1)), -1 !== R4 && R4 < S11 + 1 && (R4 = i15.indexOf(P6, S11 + 1));
                    var O5 = A8(-1 === R4 ? w8 : Math.min(w8, R4));
                    if (i15.substr(S11 + 1 + O5, e9) === M10) {
                      f17.push(i15.substring(W2, S11).replace(C5, z7)), i15[W2 = S11 + 1 + O5 + e9] !== z7 && (S11 = i15.indexOf(z7, W2)), w8 = i15.indexOf(M10, W2), R4 = i15.indexOf(P6, W2);
                      break;
                    }
                    var x7 = A8(R4);
                    if (i15.substring(S11 + 1 + x7, S11 + 1 + x7 + s21) === P6) {
                      if (f17.push(i15.substring(W2, S11).replace(C5, z7)), D9(S11 + 1 + x7 + s21), w8 = i15.indexOf(M10, W2), S11 = i15.indexOf(z7, W2), o17 && (F9(), H9))
                        return L6();
                      if (N6 && u12.length >= N6)
                        return L6(true);
                      break;
                    }
                    h12.push({ type: "Quotes", code: "InvalidQuotes", message: "Trailing quote on quoted field is malformed", row: u12.length, index: W2 }), S11++;
                  }
                } else
                  S11++;
              }
          return T7();
          function I9(e10) {
            u12.push(e10), d18 = W2;
          }
          function A8(e10) {
            var t21 = 0;
            if (-1 !== e10) {
              var r17 = i15.substring(S11 + 1, e10);
              r17 && "" === r17.trim() && (t21 = r17.length);
            }
            return t21;
          }
          function T7(e10) {
            return r16 || (void 0 === e10 && (e10 = i15.substring(W2)), f17.push(e10), W2 = n13, I9(f17), o17 && F9()), L6();
          }
          function D9(e10) {
            W2 = e10, I9(f17), f17 = [], R4 = i15.indexOf(P6, W2);
          }
          function L6(e10) {
            return { data: u12, errors: h12, meta: { delimiter: M10, linebreak: P6, aborted: H9, truncated: !!e10, cursor: d18 + (t20 || 0) } };
          }
          function F9() {
            q7(L6()), u12 = [], h12 = [];
          }
        }, this.abort = function() {
          H9 = true;
        }, this.getCharIndex = function() {
          return W2;
        };
      }
      function _7(e9) {
        var t20 = e9.data, r16 = a13[t20.workerId], i15 = false;
        if (t20.error)
          r16.userError(t20.error, t20.file);
        else if (t20.results && t20.results.data) {
          var n13 = { abort: function() {
            i15 = true, m10(t20.workerId, { data: [], errors: [], meta: { aborted: true } });
          }, pause: y9, resume: y9 };
          if (J4(r16.userStep)) {
            for (var s21 = 0; s21 < t20.results.data.length && (r16.userStep({ data: t20.results.data[s21], errors: t20.results.errors, meta: t20.results.meta }, n13), !i15); s21++)
              ;
            delete t20.results;
          } else
            J4(r16.userChunk) && (r16.userChunk(t20.results, n13, t20.file), delete t20.results);
        }
        t20.finished && !i15 && m10(t20.workerId, t20.results);
      }
      function m10(e9, t20) {
        var r16 = a13[e9];
        J4(r16.userComplete) && r16.userComplete(t20), r16.terminate(), delete a13[e9];
      }
      function y9() {
        throw new Error("Not implemented.");
      }
      function w7(e9) {
        if ("object" != typeof e9 || null === e9)
          return e9;
        var t20 = Array.isArray(e9) ? [] : {};
        for (var r16 in e9)
          t20[r16] = w7(e9[r16]);
        return t20;
      }
      function v6(e9, t20) {
        return function() {
          e9.apply(t20, arguments);
        };
      }
      function J4(e9) {
        return "function" == typeof e9;
      }
      return o16 && (f16.onmessage = function(e9) {
        var t20 = e9.data;
        void 0 === b6.WORKER_ID && t20 && (b6.WORKER_ID = t20.workerId);
        if ("string" == typeof t20.input)
          f16.postMessage({ workerId: b6.WORKER_ID, results: b6.parse(t20.input, t20.config), finished: true });
        else if (f16.File && t20.input instanceof File || t20.input instanceof Object) {
          var r16 = b6.parse(t20.input, t20.config);
          r16 && f16.postMessage({ workerId: b6.WORKER_ID, results: r16, finished: true });
        }
      }), (l14.prototype = Object.create(h11.prototype)).constructor = l14, (c16.prototype = Object.create(h11.prototype)).constructor = c16, (p12.prototype = Object.create(p12.prototype)).constructor = p12, (g6.prototype = Object.create(h11.prototype)).constructor = g6, b6;
    });
  }
});

// node_modules/react-dom/cjs/react-dom-server.browser.development.js
var require_react_dom_server_browser_development = __commonJS({
  "node_modules/react-dom/cjs/react-dom-server.browser.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var React72 = require_react();
        var _assign = require_object_assign();
        function formatProdErrorMessage(code) {
          var url = "https://reactjs.org/docs/error-decoder.html?invariant=" + code;
          for (var i16 = 1; i16 < arguments.length; i16++) {
            url += "&args[]=" + encodeURIComponent(arguments[i16]);
          }
          return "Minified React error #" + code + "; visit " + url + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        var ReactVersion = "17.0.2";
        var ReactSharedInternals = React72.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
        function warn2(format3) {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format3, args);
          }
        }
        function error2(format3) {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format3, args);
          }
        }
        function printWarning(level, format3, args) {
          {
            var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
            var stack = ReactDebugCurrentFrame2.getStackAddendum();
            if (stack !== "") {
              format3 += "%s";
              args = args.concat([stack]);
            }
            var argsWithFormat = args.map(function(item) {
              return "" + item;
            });
            argsWithFormat.unshift("Warning: " + format3);
            Function.prototype.apply.call(console[level], console, argsWithFormat);
          }
        }
        var REACT_ELEMENT_TYPE = 60103;
        var REACT_PORTAL_TYPE = 60106;
        var REACT_FRAGMENT_TYPE = 60107;
        var REACT_STRICT_MODE_TYPE = 60108;
        var REACT_PROFILER_TYPE = 60114;
        var REACT_PROVIDER_TYPE = 60109;
        var REACT_CONTEXT_TYPE = 60110;
        var REACT_FORWARD_REF_TYPE = 60112;
        var REACT_SUSPENSE_TYPE = 60113;
        var REACT_SUSPENSE_LIST_TYPE = 60120;
        var REACT_MEMO_TYPE = 60115;
        var REACT_LAZY_TYPE = 60116;
        var REACT_BLOCK_TYPE = 60121;
        var REACT_SERVER_BLOCK_TYPE = 60122;
        var REACT_FUNDAMENTAL_TYPE = 60117;
        var REACT_SCOPE_TYPE = 60119;
        var REACT_OPAQUE_ID_TYPE = 60128;
        var REACT_DEBUG_TRACING_MODE_TYPE = 60129;
        var REACT_OFFSCREEN_TYPE = 60130;
        var REACT_LEGACY_HIDDEN_TYPE = 60131;
        if (typeof Symbol === "function" && Symbol.for) {
          var symbolFor = Symbol.for;
          REACT_ELEMENT_TYPE = symbolFor("react.element");
          REACT_PORTAL_TYPE = symbolFor("react.portal");
          REACT_FRAGMENT_TYPE = symbolFor("react.fragment");
          REACT_STRICT_MODE_TYPE = symbolFor("react.strict_mode");
          REACT_PROFILER_TYPE = symbolFor("react.profiler");
          REACT_PROVIDER_TYPE = symbolFor("react.provider");
          REACT_CONTEXT_TYPE = symbolFor("react.context");
          REACT_FORWARD_REF_TYPE = symbolFor("react.forward_ref");
          REACT_SUSPENSE_TYPE = symbolFor("react.suspense");
          REACT_SUSPENSE_LIST_TYPE = symbolFor("react.suspense_list");
          REACT_MEMO_TYPE = symbolFor("react.memo");
          REACT_LAZY_TYPE = symbolFor("react.lazy");
          REACT_BLOCK_TYPE = symbolFor("react.block");
          REACT_SERVER_BLOCK_TYPE = symbolFor("react.server.block");
          REACT_FUNDAMENTAL_TYPE = symbolFor("react.fundamental");
          REACT_SCOPE_TYPE = symbolFor("react.scope");
          REACT_OPAQUE_ID_TYPE = symbolFor("react.opaque.id");
          REACT_DEBUG_TRACING_MODE_TYPE = symbolFor("react.debug_trace_mode");
          REACT_OFFSCREEN_TYPE = symbolFor("react.offscreen");
          REACT_LEGACY_HIDDEN_TYPE = symbolFor("react.legacy_hidden");
        }
        function getWrappedName(outerType, innerType, wrapperName) {
          var functionName = innerType.displayName || innerType.name || "";
          return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
        }
        function getContextName(type) {
          return type.displayName || "Context";
        }
        function getComponentName(type) {
          if (type == null) {
            return null;
          }
          {
            if (typeof type.tag === "number") {
              error2("Received an unexpected object in getComponentName(). This is likely a bug in React. Please file an issue.");
            }
          }
          if (typeof type === "function") {
            return type.displayName || type.name || null;
          }
          if (typeof type === "string") {
            return type;
          }
          switch (type) {
            case REACT_FRAGMENT_TYPE:
              return "Fragment";
            case REACT_PORTAL_TYPE:
              return "Portal";
            case REACT_PROFILER_TYPE:
              return "Profiler";
            case REACT_STRICT_MODE_TYPE:
              return "StrictMode";
            case REACT_SUSPENSE_TYPE:
              return "Suspense";
            case REACT_SUSPENSE_LIST_TYPE:
              return "SuspenseList";
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_CONTEXT_TYPE:
                var context = type;
                return getContextName(context) + ".Consumer";
              case REACT_PROVIDER_TYPE:
                var provider = type;
                return getContextName(provider._context) + ".Provider";
              case REACT_FORWARD_REF_TYPE:
                return getWrappedName(type, type.render, "ForwardRef");
              case REACT_MEMO_TYPE:
                return getComponentName(type.type);
              case REACT_BLOCK_TYPE:
                return getComponentName(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return getComponentName(init(payload));
                } catch (x7) {
                  return null;
                }
              }
            }
          }
          return null;
        }
        var enableSuspenseServerRenderer = false;
        var disabledDepth = 0;
        var prevLog;
        var prevInfo;
        var prevWarn;
        var prevError;
        var prevGroup;
        var prevGroupCollapsed;
        var prevGroupEnd;
        function disabledLog() {
        }
        disabledLog.__reactDisabledLog = true;
        function disableLogs() {
          {
            if (disabledDepth === 0) {
              prevLog = console.log;
              prevInfo = console.info;
              prevWarn = console.warn;
              prevError = console.error;
              prevGroup = console.group;
              prevGroupCollapsed = console.groupCollapsed;
              prevGroupEnd = console.groupEnd;
              var props = {
                configurable: true,
                enumerable: true,
                value: disabledLog,
                writable: true
              };
              Object.defineProperties(console, {
                info: props,
                log: props,
                warn: props,
                error: props,
                group: props,
                groupCollapsed: props,
                groupEnd: props
              });
            }
            disabledDepth++;
          }
        }
        function reenableLogs() {
          {
            disabledDepth--;
            if (disabledDepth === 0) {
              var props = {
                configurable: true,
                enumerable: true,
                writable: true
              };
              Object.defineProperties(console, {
                log: _assign({}, props, {
                  value: prevLog
                }),
                info: _assign({}, props, {
                  value: prevInfo
                }),
                warn: _assign({}, props, {
                  value: prevWarn
                }),
                error: _assign({}, props, {
                  value: prevError
                }),
                group: _assign({}, props, {
                  value: prevGroup
                }),
                groupCollapsed: _assign({}, props, {
                  value: prevGroupCollapsed
                }),
                groupEnd: _assign({}, props, {
                  value: prevGroupEnd
                })
              });
            }
            if (disabledDepth < 0) {
              error2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
            }
          }
        }
        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
        var prefix3;
        function describeBuiltInComponentFrame(name2, source, ownerFn) {
          {
            if (prefix3 === void 0) {
              try {
                throw Error();
              } catch (x7) {
                var match5 = x7.stack.trim().match(/\n( *(at )?)/);
                prefix3 = match5 && match5[1] || "";
              }
            }
            return "\n" + prefix3 + name2;
          }
        }
        var reentry = false;
        var componentFrameCache;
        {
          var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
          componentFrameCache = new PossiblyWeakMap();
        }
        function describeNativeComponentFrame(fn2, construct) {
          if (!fn2 || reentry) {
            return "";
          }
          {
            var frame = componentFrameCache.get(fn2);
            if (frame !== void 0) {
              return frame;
            }
          }
          var control;
          reentry = true;
          var previousPrepareStackTrace = Error.prepareStackTrace;
          Error.prepareStackTrace = void 0;
          var previousDispatcher;
          {
            previousDispatcher = ReactCurrentDispatcher.current;
            ReactCurrentDispatcher.current = null;
            disableLogs();
          }
          try {
            if (construct) {
              var Fake = function() {
                throw Error();
              };
              Object.defineProperty(Fake.prototype, "props", {
                set: function() {
                  throw Error();
                }
              });
              if (typeof Reflect === "object" && Reflect.construct) {
                try {
                  Reflect.construct(Fake, []);
                } catch (x7) {
                  control = x7;
                }
                Reflect.construct(fn2, [], Fake);
              } else {
                try {
                  Fake.call();
                } catch (x7) {
                  control = x7;
                }
                fn2.call(Fake.prototype);
              }
            } else {
              try {
                throw Error();
              } catch (x7) {
                control = x7;
              }
              fn2();
            }
          } catch (sample) {
            if (sample && control && typeof sample.stack === "string") {
              var sampleLines = sample.stack.split("\n");
              var controlLines = control.stack.split("\n");
              var s20 = sampleLines.length - 1;
              var c16 = controlLines.length - 1;
              while (s20 >= 1 && c16 >= 0 && sampleLines[s20] !== controlLines[c16]) {
                c16--;
              }
              for (; s20 >= 1 && c16 >= 0; s20--, c16--) {
                if (sampleLines[s20] !== controlLines[c16]) {
                  if (s20 !== 1 || c16 !== 1) {
                    do {
                      s20--;
                      c16--;
                      if (c16 < 0 || sampleLines[s20] !== controlLines[c16]) {
                        var _frame = "\n" + sampleLines[s20].replace(" at new ", " at ");
                        {
                          if (typeof fn2 === "function") {
                            componentFrameCache.set(fn2, _frame);
                          }
                        }
                        return _frame;
                      }
                    } while (s20 >= 1 && c16 >= 0);
                  }
                  break;
                }
              }
            }
          } finally {
            reentry = false;
            {
              ReactCurrentDispatcher.current = previousDispatcher;
              reenableLogs();
            }
            Error.prepareStackTrace = previousPrepareStackTrace;
          }
          var name2 = fn2 ? fn2.displayName || fn2.name : "";
          var syntheticFrame = name2 ? describeBuiltInComponentFrame(name2) : "";
          {
            if (typeof fn2 === "function") {
              componentFrameCache.set(fn2, syntheticFrame);
            }
          }
          return syntheticFrame;
        }
        function describeFunctionComponentFrame(fn2, source, ownerFn) {
          {
            return describeNativeComponentFrame(fn2, false);
          }
        }
        function shouldConstruct(Component9) {
          var prototype = Component9.prototype;
          return !!(prototype && prototype.isReactComponent);
        }
        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
          if (type == null) {
            return "";
          }
          if (typeof type === "function") {
            {
              return describeNativeComponentFrame(type, shouldConstruct(type));
            }
          }
          if (typeof type === "string") {
            return describeBuiltInComponentFrame(type);
          }
          switch (type) {
            case REACT_SUSPENSE_TYPE:
              return describeBuiltInComponentFrame("Suspense");
            case REACT_SUSPENSE_LIST_TYPE:
              return describeBuiltInComponentFrame("SuspenseList");
          }
          if (typeof type === "object") {
            switch (type.$$typeof) {
              case REACT_FORWARD_REF_TYPE:
                return describeFunctionComponentFrame(type.render);
              case REACT_MEMO_TYPE:
                return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
              case REACT_BLOCK_TYPE:
                return describeFunctionComponentFrame(type._render);
              case REACT_LAZY_TYPE: {
                var lazyComponent = type;
                var payload = lazyComponent._payload;
                var init = lazyComponent._init;
                try {
                  return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
                } catch (x7) {
                }
              }
            }
          }
          return "";
        }
        var loggedTypeFailures = {};
        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
        function setCurrentlyValidatingElement(element) {
          {
            if (element) {
              var owner = element._owner;
              var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
              ReactDebugCurrentFrame.setExtraStackFrame(stack);
            } else {
              ReactDebugCurrentFrame.setExtraStackFrame(null);
            }
          }
        }
        function checkPropTypes(typeSpecs, values3, location, componentName, element) {
          {
            var has4 = Function.call.bind(Object.prototype.hasOwnProperty);
            for (var typeSpecName in typeSpecs) {
              if (has4(typeSpecs, typeSpecName)) {
                var error$1 = void 0;
                try {
                  if (typeof typeSpecs[typeSpecName] !== "function") {
                    var err = Error((componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                    err.name = "Invariant Violation";
                    throw err;
                  }
                  error$1 = typeSpecs[typeSpecName](values3, typeSpecName, componentName, location, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
                } catch (ex) {
                  error$1 = ex;
                }
                if (error$1 && !(error$1 instanceof Error)) {
                  setCurrentlyValidatingElement(element);
                  error2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", componentName || "React class", location, typeSpecName, typeof error$1);
                  setCurrentlyValidatingElement(null);
                }
                if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                  loggedTypeFailures[error$1.message] = true;
                  setCurrentlyValidatingElement(element);
                  error2("Failed %s type: %s", location, error$1.message);
                  setCurrentlyValidatingElement(null);
                }
              }
            }
          }
        }
        var didWarnAboutInvalidateContextType;
        {
          didWarnAboutInvalidateContextType = /* @__PURE__ */ new Set();
        }
        var emptyObject = {};
        {
          Object.freeze(emptyObject);
        }
        function maskContext(type, context) {
          var contextTypes = type.contextTypes;
          if (!contextTypes) {
            return emptyObject;
          }
          var maskedContext = {};
          for (var contextName in contextTypes) {
            maskedContext[contextName] = context[contextName];
          }
          return maskedContext;
        }
        function checkContextTypes(typeSpecs, values3, location) {
          {
            checkPropTypes(typeSpecs, values3, location, "Component");
          }
        }
        function validateContextBounds(context, threadID) {
          for (var i16 = context._threadCount | 0; i16 <= threadID; i16++) {
            context[i16] = context._currentValue2;
            context._threadCount = i16 + 1;
          }
        }
        function processContext(type, context, threadID, isClass) {
          if (isClass) {
            var contextType = type.contextType;
            {
              if ("contextType" in type) {
                var isValid4 = (
                  // Allow null for conditional declaration
                  contextType === null || contextType !== void 0 && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === void 0
                );
                if (!isValid4 && !didWarnAboutInvalidateContextType.has(type)) {
                  didWarnAboutInvalidateContextType.add(type);
                  var addendum = "";
                  if (contextType === void 0) {
                    addendum = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.";
                  } else if (typeof contextType !== "object") {
                    addendum = " However, it is set to a " + typeof contextType + ".";
                  } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                    addendum = " Did you accidentally pass the Context.Provider instead?";
                  } else if (contextType._context !== void 0) {
                    addendum = " Did you accidentally pass the Context.Consumer instead?";
                  } else {
                    addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
                  }
                  error2("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", getComponentName(type) || "Component", addendum);
                }
              }
            }
            if (typeof contextType === "object" && contextType !== null) {
              validateContextBounds(contextType, threadID);
              return contextType[threadID];
            }
            {
              var maskedContext = maskContext(type, context);
              {
                if (type.contextTypes) {
                  checkContextTypes(type.contextTypes, maskedContext, "context");
                }
              }
              return maskedContext;
            }
          } else {
            {
              var _maskedContext = maskContext(type, context);
              {
                if (type.contextTypes) {
                  checkContextTypes(type.contextTypes, _maskedContext, "context");
                }
              }
              return _maskedContext;
            }
          }
        }
        var nextAvailableThreadIDs = new Uint16Array(16);
        for (var i15 = 0; i15 < 15; i15++) {
          nextAvailableThreadIDs[i15] = i15 + 1;
        }
        nextAvailableThreadIDs[15] = 0;
        function growThreadCountAndReturnNextAvailable() {
          var oldArray = nextAvailableThreadIDs;
          var oldSize = oldArray.length;
          var newSize = oldSize * 2;
          if (!(newSize <= 65536)) {
            {
              throw Error("Maximum number of concurrent React renderers exceeded. This can happen if you are not properly destroying the Readable provided by React. Ensure that you call .destroy() on it if you no longer want to read from it, and did not read to the end. If you use .pipe() this should be automatic.");
            }
          }
          var newArray = new Uint16Array(newSize);
          newArray.set(oldArray);
          nextAvailableThreadIDs = newArray;
          nextAvailableThreadIDs[0] = oldSize + 1;
          for (var _i = oldSize; _i < newSize - 1; _i++) {
            nextAvailableThreadIDs[_i] = _i + 1;
          }
          nextAvailableThreadIDs[newSize - 1] = 0;
          return oldSize;
        }
        function allocThreadID() {
          var nextID = nextAvailableThreadIDs[0];
          if (nextID === 0) {
            return growThreadCountAndReturnNextAvailable();
          }
          nextAvailableThreadIDs[0] = nextAvailableThreadIDs[nextID];
          return nextID;
        }
        function freeThreadID(id) {
          nextAvailableThreadIDs[id] = nextAvailableThreadIDs[0];
          nextAvailableThreadIDs[0] = id;
        }
        var RESERVED = 0;
        var STRING = 1;
        var BOOLEANISH_STRING = 2;
        var BOOLEAN = 3;
        var OVERLOADED_BOOLEAN = 4;
        var NUMERIC = 5;
        var POSITIVE_NUMERIC = 6;
        var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
        var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
        var ROOT_ATTRIBUTE_NAME = "data-reactroot";
        var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var hasOwnProperty17 = Object.prototype.hasOwnProperty;
        var illegalAttributeNameCache = {};
        var validatedAttributeNameCache = {};
        function isAttributeNameSafe(attributeName) {
          if (hasOwnProperty17.call(validatedAttributeNameCache, attributeName)) {
            return true;
          }
          if (hasOwnProperty17.call(illegalAttributeNameCache, attributeName)) {
            return false;
          }
          if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
            validatedAttributeNameCache[attributeName] = true;
            return true;
          }
          illegalAttributeNameCache[attributeName] = true;
          {
            error2("Invalid attribute name: `%s`", attributeName);
          }
          return false;
        }
        function shouldIgnoreAttribute(name2, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null) {
            return propertyInfo.type === RESERVED;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (name2.length > 2 && (name2[0] === "o" || name2[0] === "O") && (name2[1] === "n" || name2[1] === "N")) {
            return true;
          }
          return false;
        }
        function shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag) {
          if (propertyInfo !== null && propertyInfo.type === RESERVED) {
            return false;
          }
          switch (typeof value) {
            case "function":
            case "symbol":
              return true;
            case "boolean": {
              if (isCustomComponentTag) {
                return false;
              }
              if (propertyInfo !== null) {
                return !propertyInfo.acceptsBooleans;
              } else {
                var prefix4 = name2.toLowerCase().slice(0, 5);
                return prefix4 !== "data-" && prefix4 !== "aria-";
              }
            }
            default:
              return false;
          }
        }
        function shouldRemoveAttribute(name2, value, propertyInfo, isCustomComponentTag) {
          if (value === null || typeof value === "undefined") {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name2, value, propertyInfo, isCustomComponentTag)) {
            return true;
          }
          if (isCustomComponentTag) {
            return false;
          }
          if (propertyInfo !== null) {
            switch (propertyInfo.type) {
              case BOOLEAN:
                return !value;
              case OVERLOADED_BOOLEAN:
                return value === false;
              case NUMERIC:
                return isNaN(value);
              case POSITIVE_NUMERIC:
                return isNaN(value) || value < 1;
            }
          }
          return false;
        }
        function getPropertyInfo(name2) {
          return properties.hasOwnProperty(name2) ? properties[name2] : null;
        }
        function PropertyInfoRecord(name2, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
          this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
          this.attributeName = attributeName;
          this.attributeNamespace = attributeNamespace;
          this.mustUseProperty = mustUseProperty;
          this.propertyName = name2;
          this.type = type;
          this.sanitizeURL = sanitizeURL2;
          this.removeEmptyString = removeEmptyString;
        }
        var properties = {};
        var reservedProps = [
          "children",
          "dangerouslySetInnerHTML",
          // TODO: This prevents the assignment of defaultValue to regular
          // elements (not just inputs). Now that ReactDOMInput assigns to the
          // defaultValue property -- do we need this?
          "defaultValue",
          "defaultChecked",
          "innerHTML",
          "suppressContentEditableWarning",
          "suppressHydrationWarning",
          "style"
        ];
        reservedProps.forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            RESERVED,
            false,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
          var name2 = _ref[0], attributeName = _ref[1];
          properties[name2] = new PropertyInfoRecord(
            name2,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name2.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            BOOLEANISH_STRING,
            false,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "allowFullScreen",
          "async",
          // Note: there is a special case that prevents it from being written to the DOM
          // on the client side because the browsers are inconsistent. Instead we call focus().
          "autoFocus",
          "autoPlay",
          "controls",
          "default",
          "defer",
          "disabled",
          "disablePictureInPicture",
          "disableRemotePlayback",
          "formNoValidate",
          "hidden",
          "loop",
          "noModule",
          "noValidate",
          "open",
          "playsInline",
          "readOnly",
          "required",
          "reversed",
          "scoped",
          "seamless",
          // Microdata
          "itemScope"
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            BOOLEAN,
            false,
            // mustUseProperty
            name2.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "checked",
          // Note: `option.selected` is not updated if `select.multiple` is
          // disabled with `removeAttribute`. We have special logic for handling this.
          "multiple",
          "muted",
          "selected"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            BOOLEAN,
            true,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "capture",
          "download"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            OVERLOADED_BOOLEAN,
            false,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "cols",
          "rows",
          "size",
          "span"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            POSITIVE_NUMERIC,
            false,
            // mustUseProperty
            name2,
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        ["rowSpan", "start"].forEach(function(name2) {
          properties[name2] = new PropertyInfoRecord(
            name2,
            NUMERIC,
            false,
            // mustUseProperty
            name2.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var CAMELIZE = /[\-\:]([a-z])/g;
        var capitalize3 = function(token2) {
          return token2[1].toUpperCase();
        };
        [
          "accent-height",
          "alignment-baseline",
          "arabic-form",
          "baseline-shift",
          "cap-height",
          "clip-path",
          "clip-rule",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "dominant-baseline",
          "enable-background",
          "fill-opacity",
          "fill-rule",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "glyph-name",
          "glyph-orientation-horizontal",
          "glyph-orientation-vertical",
          "horiz-adv-x",
          "horiz-origin-x",
          "image-rendering",
          "letter-spacing",
          "lighting-color",
          "marker-end",
          "marker-mid",
          "marker-start",
          "overline-position",
          "overline-thickness",
          "paint-order",
          "panose-1",
          "pointer-events",
          "rendering-intent",
          "shape-rendering",
          "stop-color",
          "stop-opacity",
          "strikethrough-position",
          "strikethrough-thickness",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke-width",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "underline-position",
          "underline-thickness",
          "unicode-bidi",
          "unicode-range",
          "units-per-em",
          "v-alphabetic",
          "v-hanging",
          "v-ideographic",
          "v-mathematical",
          "vector-effect",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "word-spacing",
          "writing-mode",
          "xmlns:xlink",
          "x-height"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name2 = attributeName.replace(CAMELIZE, capitalize3);
          properties[name2] = new PropertyInfoRecord(
            name2,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xlink:actuate",
          "xlink:arcrole",
          "xlink:role",
          "xlink:show",
          "xlink:title",
          "xlink:type"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name2 = attributeName.replace(CAMELIZE, capitalize3);
          properties[name2] = new PropertyInfoRecord(
            name2,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/1999/xlink",
            false,
            // sanitizeURL
            false
          );
        });
        [
          "xml:base",
          "xml:lang",
          "xml:space"
          // NOTE: if you add a camelCased prop to this list,
          // you'll need to set attributeName to name.toLowerCase()
          // instead in the assignment below.
        ].forEach(function(attributeName) {
          var name2 = attributeName.replace(CAMELIZE, capitalize3);
          properties[name2] = new PropertyInfoRecord(
            name2,
            STRING,
            false,
            // mustUseProperty
            attributeName,
            "http://www.w3.org/XML/1998/namespace",
            false,
            // sanitizeURL
            false
          );
        });
        ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            false,
            // sanitizeURL
            false
          );
        });
        var xlinkHref = "xlinkHref";
        properties[xlinkHref] = new PropertyInfoRecord(
          "xlinkHref",
          STRING,
          false,
          // mustUseProperty
          "xlink:href",
          "http://www.w3.org/1999/xlink",
          true,
          // sanitizeURL
          false
        );
        ["src", "href", "action", "formAction"].forEach(function(attributeName) {
          properties[attributeName] = new PropertyInfoRecord(
            attributeName,
            STRING,
            false,
            // mustUseProperty
            attributeName.toLowerCase(),
            // attributeName
            null,
            // attributeNamespace
            true,
            // sanitizeURL
            true
          );
        });
        var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
        var didWarn = false;
        function sanitizeURL(url) {
          {
            if (!didWarn && isJavaScriptProtocol.test(url)) {
              didWarn = true;
              error2("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
            }
          }
        }
        var matchHtmlRegExp = /["'&<>]/;
        function escapeHtml2(string2) {
          var str = "" + string2;
          var match5 = matchHtmlRegExp.exec(str);
          if (!match5) {
            return str;
          }
          var escape2;
          var html = "";
          var index2;
          var lastIndex = 0;
          for (index2 = match5.index; index2 < str.length; index2++) {
            switch (str.charCodeAt(index2)) {
              case 34:
                escape2 = "&quot;";
                break;
              case 38:
                escape2 = "&amp;";
                break;
              case 39:
                escape2 = "&#x27;";
                break;
              case 60:
                escape2 = "&lt;";
                break;
              case 62:
                escape2 = "&gt;";
                break;
              default:
                continue;
            }
            if (lastIndex !== index2) {
              html += str.substring(lastIndex, index2);
            }
            lastIndex = index2 + 1;
            html += escape2;
          }
          return lastIndex !== index2 ? html + str.substring(lastIndex, index2) : html;
        }
        function escapeTextForBrowser(text) {
          if (typeof text === "boolean" || typeof text === "number") {
            return "" + text;
          }
          return escapeHtml2(text);
        }
        function quoteAttributeValueForBrowser(value) {
          return '"' + escapeTextForBrowser(value) + '"';
        }
        function createMarkupForRoot() {
          return ROOT_ATTRIBUTE_NAME + '=""';
        }
        function createMarkupForProperty(name2, value) {
          var propertyInfo = getPropertyInfo(name2);
          if (name2 !== "style" && shouldIgnoreAttribute(name2, propertyInfo, false)) {
            return "";
          }
          if (shouldRemoveAttribute(name2, value, propertyInfo, false)) {
            return "";
          }
          if (propertyInfo !== null) {
            var attributeName = propertyInfo.attributeName;
            var type = propertyInfo.type;
            if (type === BOOLEAN || type === OVERLOADED_BOOLEAN && value === true) {
              return attributeName + '=""';
            } else {
              if (propertyInfo.sanitizeURL) {
                value = "" + value;
                sanitizeURL(value);
              }
              return attributeName + "=" + quoteAttributeValueForBrowser(value);
            }
          } else if (isAttributeNameSafe(name2)) {
            return name2 + "=" + quoteAttributeValueForBrowser(value);
          }
          return "";
        }
        function createMarkupForCustomAttribute(name2, value) {
          if (!isAttributeNameSafe(name2) || value == null) {
            return "";
          }
          return name2 + "=" + quoteAttributeValueForBrowser(value);
        }
        function is3(x7, y9) {
          return x7 === y9 && (x7 !== 0 || 1 / x7 === 1 / y9) || x7 !== x7 && y9 !== y9;
        }
        var objectIs = typeof Object.is === "function" ? Object.is : is3;
        var currentlyRenderingComponent = null;
        var firstWorkInProgressHook = null;
        var workInProgressHook = null;
        var isReRender = false;
        var didScheduleRenderPhaseUpdate = false;
        var renderPhaseUpdates = null;
        var numberOfReRenders = 0;
        var RE_RENDER_LIMIT = 25;
        var isInHookUserCodeInDev = false;
        var currentHookNameInDev;
        function resolveCurrentlyRenderingComponent() {
          if (!(currentlyRenderingComponent !== null)) {
            {
              throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
            }
          }
          {
            if (isInHookUserCodeInDev) {
              error2("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
            }
          }
          return currentlyRenderingComponent;
        }
        function areHookInputsEqual(nextDeps, prevDeps) {
          if (prevDeps === null) {
            {
              error2("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", currentHookNameInDev);
            }
            return false;
          }
          {
            if (nextDeps.length !== prevDeps.length) {
              error2("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s", currentHookNameInDev, "[" + nextDeps.join(", ") + "]", "[" + prevDeps.join(", ") + "]");
            }
          }
          for (var i16 = 0; i16 < prevDeps.length && i16 < nextDeps.length; i16++) {
            if (objectIs(nextDeps[i16], prevDeps[i16])) {
              continue;
            }
            return false;
          }
          return true;
        }
        function createHook() {
          if (numberOfReRenders > 0) {
            {
              {
                throw Error("Rendered more hooks than during the previous render");
              }
            }
          }
          return {
            memoizedState: null,
            queue: null,
            next: null
          };
        }
        function createWorkInProgressHook() {
          if (workInProgressHook === null) {
            if (firstWorkInProgressHook === null) {
              isReRender = false;
              firstWorkInProgressHook = workInProgressHook = createHook();
            } else {
              isReRender = true;
              workInProgressHook = firstWorkInProgressHook;
            }
          } else {
            if (workInProgressHook.next === null) {
              isReRender = false;
              workInProgressHook = workInProgressHook.next = createHook();
            } else {
              isReRender = true;
              workInProgressHook = workInProgressHook.next;
            }
          }
          return workInProgressHook;
        }
        function prepareToUseHooks(componentIdentity) {
          currentlyRenderingComponent = componentIdentity;
          {
            isInHookUserCodeInDev = false;
          }
        }
        function finishHooks(Component9, props, children, refOrContext) {
          while (didScheduleRenderPhaseUpdate) {
            didScheduleRenderPhaseUpdate = false;
            numberOfReRenders += 1;
            workInProgressHook = null;
            children = Component9(props, refOrContext);
          }
          resetHooksState();
          return children;
        }
        function resetHooksState() {
          {
            isInHookUserCodeInDev = false;
          }
          currentlyRenderingComponent = null;
          didScheduleRenderPhaseUpdate = false;
          firstWorkInProgressHook = null;
          numberOfReRenders = 0;
          renderPhaseUpdates = null;
          workInProgressHook = null;
        }
        function readContext(context, observedBits) {
          var threadID = currentPartialRenderer.threadID;
          validateContextBounds(context, threadID);
          {
            if (isInHookUserCodeInDev) {
              error2("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
            }
          }
          return context[threadID];
        }
        function useContext15(context, observedBits) {
          {
            currentHookNameInDev = "useContext";
          }
          resolveCurrentlyRenderingComponent();
          var threadID = currentPartialRenderer.threadID;
          validateContextBounds(context, threadID);
          return context[threadID];
        }
        function basicStateReducer(state, action) {
          return typeof action === "function" ? action(state) : action;
        }
        function useState15(initialState2) {
          {
            currentHookNameInDev = "useState";
          }
          return useReducer9(
            basicStateReducer,
            // useReducer has a special case to support lazy useState initializers
            initialState2
          );
        }
        function useReducer9(reducer3, initialArg, init) {
          {
            if (reducer3 !== basicStateReducer) {
              currentHookNameInDev = "useReducer";
            }
          }
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          if (isReRender) {
            var queue = workInProgressHook.queue;
            var dispatch = queue.dispatch;
            if (renderPhaseUpdates !== null) {
              var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
              if (firstRenderPhaseUpdate !== void 0) {
                renderPhaseUpdates.delete(queue);
                var newState = workInProgressHook.memoizedState;
                var update4 = firstRenderPhaseUpdate;
                do {
                  var action = update4.action;
                  {
                    isInHookUserCodeInDev = true;
                  }
                  newState = reducer3(newState, action);
                  {
                    isInHookUserCodeInDev = false;
                  }
                  update4 = update4.next;
                } while (update4 !== null);
                workInProgressHook.memoizedState = newState;
                return [newState, dispatch];
              }
            }
            return [workInProgressHook.memoizedState, dispatch];
          } else {
            {
              isInHookUserCodeInDev = true;
            }
            var initialState2;
            if (reducer3 === basicStateReducer) {
              initialState2 = typeof initialArg === "function" ? initialArg() : initialArg;
            } else {
              initialState2 = init !== void 0 ? init(initialArg) : initialArg;
            }
            {
              isInHookUserCodeInDev = false;
            }
            workInProgressHook.memoizedState = initialState2;
            var _queue = workInProgressHook.queue = {
              last: null,
              dispatch: null
            };
            var _dispatch = _queue.dispatch = dispatchAction.bind(null, currentlyRenderingComponent, _queue);
            return [workInProgressHook.memoizedState, _dispatch];
          }
        }
        function useMemo18(nextCreate, deps) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var nextDeps = deps === void 0 ? null : deps;
          if (workInProgressHook !== null) {
            var prevState = workInProgressHook.memoizedState;
            if (prevState !== null) {
              if (nextDeps !== null) {
                var prevDeps = prevState[1];
                if (areHookInputsEqual(nextDeps, prevDeps)) {
                  return prevState[0];
                }
              }
            }
          }
          {
            isInHookUserCodeInDev = true;
          }
          var nextValue = nextCreate();
          {
            isInHookUserCodeInDev = false;
          }
          workInProgressHook.memoizedState = [nextValue, nextDeps];
          return nextValue;
        }
        function useRef26(initialValue) {
          currentlyRenderingComponent = resolveCurrentlyRenderingComponent();
          workInProgressHook = createWorkInProgressHook();
          var previousRef = workInProgressHook.memoizedState;
          if (previousRef === null) {
            var ref2 = {
              current: initialValue
            };
            {
              Object.seal(ref2);
            }
            workInProgressHook.memoizedState = ref2;
            return ref2;
          } else {
            return previousRef;
          }
        }
        function useLayoutEffect12(create14, inputs) {
          {
            currentHookNameInDev = "useLayoutEffect";
            error2("useLayoutEffect does nothing on the server, because its effect cannot be encoded into the server renderer's output format. This will lead to a mismatch between the initial, non-hydrated UI and the intended UI. To avoid this, useLayoutEffect should only be used in components that render exclusively on the client. See https://reactjs.org/link/uselayouteffect-ssr for common fixes.");
          }
        }
        function dispatchAction(componentIdentity, queue, action) {
          if (!(numberOfReRenders < RE_RENDER_LIMIT)) {
            {
              throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
            }
          }
          if (componentIdentity === currentlyRenderingComponent) {
            didScheduleRenderPhaseUpdate = true;
            var update4 = {
              action,
              next: null
            };
            if (renderPhaseUpdates === null) {
              renderPhaseUpdates = /* @__PURE__ */ new Map();
            }
            var firstRenderPhaseUpdate = renderPhaseUpdates.get(queue);
            if (firstRenderPhaseUpdate === void 0) {
              renderPhaseUpdates.set(queue, update4);
            } else {
              var lastRenderPhaseUpdate = firstRenderPhaseUpdate;
              while (lastRenderPhaseUpdate.next !== null) {
                lastRenderPhaseUpdate = lastRenderPhaseUpdate.next;
              }
              lastRenderPhaseUpdate.next = update4;
            }
          }
        }
        function useCallback19(callback, deps) {
          return useMemo18(function() {
            return callback;
          }, deps);
        }
        function useMutableSource(source, getSnapshot, subscribe) {
          resolveCurrentlyRenderingComponent();
          return getSnapshot(source._source);
        }
        function useDeferredValue(value) {
          resolveCurrentlyRenderingComponent();
          return value;
        }
        function useTransition() {
          resolveCurrentlyRenderingComponent();
          var startTransition = function(callback) {
            callback();
          };
          return [startTransition, false];
        }
        function useOpaqueIdentifier() {
          return (currentPartialRenderer.identifierPrefix || "") + "R:" + (currentPartialRenderer.uniqueID++).toString(36);
        }
        function noop6() {
        }
        var currentPartialRenderer = null;
        function setCurrentPartialRenderer(renderer) {
          currentPartialRenderer = renderer;
        }
        var Dispatcher = {
          readContext,
          useContext: useContext15,
          useMemo: useMemo18,
          useReducer: useReducer9,
          useRef: useRef26,
          useState: useState15,
          useLayoutEffect: useLayoutEffect12,
          useCallback: useCallback19,
          // useImperativeHandle is not run in the server environment
          useImperativeHandle: noop6,
          // Effects are not run in the server environment.
          useEffect: noop6,
          // Debugging effect
          useDebugValue: noop6,
          useDeferredValue,
          useTransition,
          useOpaqueIdentifier,
          // Subscriptions are not setup in a server environment.
          useMutableSource
        };
        var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
        var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
        var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
        var Namespaces = {
          html: HTML_NAMESPACE,
          mathml: MATH_NAMESPACE,
          svg: SVG_NAMESPACE
        };
        function getIntrinsicNamespace(type) {
          switch (type) {
            case "svg":
              return SVG_NAMESPACE;
            case "math":
              return MATH_NAMESPACE;
            default:
              return HTML_NAMESPACE;
          }
        }
        function getChildNamespace(parentNamespace, type) {
          if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
            return getIntrinsicNamespace(type);
          }
          if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
            return HTML_NAMESPACE;
          }
          return parentNamespace;
        }
        var hasReadOnlyValue = {
          button: true,
          checkbox: true,
          image: true,
          hidden: true,
          radio: true,
          reset: true,
          submit: true
        };
        function checkControlledValueProps(tagName, props) {
          {
            if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
              error2("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`.");
            }
            if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
              error2("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
            }
          }
        }
        var omittedCloseTags = {
          area: true,
          base: true,
          br: true,
          col: true,
          embed: true,
          hr: true,
          img: true,
          input: true,
          keygen: true,
          link: true,
          meta: true,
          param: true,
          source: true,
          track: true,
          wbr: true
          // NOTE: menuitem's close tag should be omitted, but that causes problems.
        };
        var voidElementTags = _assign({
          menuitem: true
        }, omittedCloseTags);
        var HTML = "__html";
        function assertValidProps(tag, props) {
          if (!props) {
            return;
          }
          if (voidElementTags[tag]) {
            if (!(props.children == null && props.dangerouslySetInnerHTML == null)) {
              {
                throw Error(tag + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
              }
            }
          }
          if (props.dangerouslySetInnerHTML != null) {
            if (!(props.children == null)) {
              {
                throw Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
              }
            }
            if (!(typeof props.dangerouslySetInnerHTML === "object" && HTML in props.dangerouslySetInnerHTML)) {
              {
                throw Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
              }
            }
          }
          {
            if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
              error2("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional.");
            }
          }
          if (!(props.style == null || typeof props.style === "object")) {
            {
              throw Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
            }
          }
        }
        var isUnitlessNumber = {
          animationIterationCount: true,
          borderImageOutset: true,
          borderImageSlice: true,
          borderImageWidth: true,
          boxFlex: true,
          boxFlexGroup: true,
          boxOrdinalGroup: true,
          columnCount: true,
          columns: true,
          flex: true,
          flexGrow: true,
          flexPositive: true,
          flexShrink: true,
          flexNegative: true,
          flexOrder: true,
          gridArea: true,
          gridRow: true,
          gridRowEnd: true,
          gridRowSpan: true,
          gridRowStart: true,
          gridColumn: true,
          gridColumnEnd: true,
          gridColumnSpan: true,
          gridColumnStart: true,
          fontWeight: true,
          lineClamp: true,
          lineHeight: true,
          opacity: true,
          order: true,
          orphans: true,
          tabSize: true,
          widows: true,
          zIndex: true,
          zoom: true,
          // SVG-related properties
          fillOpacity: true,
          floodOpacity: true,
          stopOpacity: true,
          strokeDasharray: true,
          strokeDashoffset: true,
          strokeMiterlimit: true,
          strokeOpacity: true,
          strokeWidth: true
        };
        function prefixKey(prefix4, key) {
          return prefix4 + key.charAt(0).toUpperCase() + key.substring(1);
        }
        var prefixes2 = ["Webkit", "ms", "Moz", "O"];
        Object.keys(isUnitlessNumber).forEach(function(prop) {
          prefixes2.forEach(function(prefix4) {
            isUnitlessNumber[prefixKey(prefix4, prop)] = isUnitlessNumber[prop];
          });
        });
        function dangerousStyleValue(name2, value, isCustomProperty) {
          var isEmpty2 = value == null || typeof value === "boolean" || value === "";
          if (isEmpty2) {
            return "";
          }
          if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name2) && isUnitlessNumber[name2])) {
            return value + "px";
          }
          return ("" + value).trim();
        }
        var uppercasePattern = /([A-Z])/g;
        var msPattern = /^ms-/;
        function hyphenateStyleName(name2) {
          return name2.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
        }
        function isCustomComponent(tagName, props) {
          if (tagName.indexOf("-") === -1) {
            return typeof props.is === "string";
          }
          switch (tagName) {
            case "annotation-xml":
            case "color-profile":
            case "font-face":
            case "font-face-src":
            case "font-face-uri":
            case "font-face-format":
            case "font-face-name":
            case "missing-glyph":
              return false;
            default:
              return true;
          }
        }
        var warnValidStyle = function() {
        };
        {
          var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
          var msPattern$1 = /^-ms-/;
          var hyphenPattern = /-(.)/g;
          var badStyleValueWithSemicolonPattern = /;\s*$/;
          var warnedStyleNames = {};
          var warnedStyleValues = {};
          var warnedForNaNValue = false;
          var warnedForInfinityValue = false;
          var camelize = function(string2) {
            return string2.replace(hyphenPattern, function(_7, character) {
              return character.toUpperCase();
            });
          };
          var warnHyphenatedStyleName = function(name2) {
            if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
              return;
            }
            warnedStyleNames[name2] = true;
            error2(
              "Unsupported style property %s. Did you mean %s?",
              name2,
              // As Andi Smith suggests
              // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
              // is converted to lowercase `ms`.
              camelize(name2.replace(msPattern$1, "ms-"))
            );
          };
          var warnBadVendoredStyleName = function(name2) {
            if (warnedStyleNames.hasOwnProperty(name2) && warnedStyleNames[name2]) {
              return;
            }
            warnedStyleNames[name2] = true;
            error2("Unsupported vendor-prefixed style property %s. Did you mean %s?", name2, name2.charAt(0).toUpperCase() + name2.slice(1));
          };
          var warnStyleValueWithSemicolon = function(name2, value) {
            if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
              return;
            }
            warnedStyleValues[value] = true;
            error2(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, name2, value.replace(badStyleValueWithSemicolonPattern, ""));
          };
          var warnStyleValueIsNaN = function(name2, value) {
            if (warnedForNaNValue) {
              return;
            }
            warnedForNaNValue = true;
            error2("`NaN` is an invalid value for the `%s` css style property.", name2);
          };
          var warnStyleValueIsInfinity = function(name2, value) {
            if (warnedForInfinityValue) {
              return;
            }
            warnedForInfinityValue = true;
            error2("`Infinity` is an invalid value for the `%s` css style property.", name2);
          };
          warnValidStyle = function(name2, value) {
            if (name2.indexOf("-") > -1) {
              warnHyphenatedStyleName(name2);
            } else if (badVendoredStyleNamePattern.test(name2)) {
              warnBadVendoredStyleName(name2);
            } else if (badStyleValueWithSemicolonPattern.test(value)) {
              warnStyleValueWithSemicolon(name2, value);
            }
            if (typeof value === "number") {
              if (isNaN(value)) {
                warnStyleValueIsNaN(name2, value);
              } else if (!isFinite(value)) {
                warnStyleValueIsInfinity(name2, value);
              }
            }
          };
        }
        var warnValidStyle$1 = warnValidStyle;
        var ariaProperties = {
          "aria-current": 0,
          // state
          "aria-details": 0,
          "aria-disabled": 0,
          // state
          "aria-hidden": 0,
          // state
          "aria-invalid": 0,
          // state
          "aria-keyshortcuts": 0,
          "aria-label": 0,
          "aria-roledescription": 0,
          // Widget Attributes
          "aria-autocomplete": 0,
          "aria-checked": 0,
          "aria-expanded": 0,
          "aria-haspopup": 0,
          "aria-level": 0,
          "aria-modal": 0,
          "aria-multiline": 0,
          "aria-multiselectable": 0,
          "aria-orientation": 0,
          "aria-placeholder": 0,
          "aria-pressed": 0,
          "aria-readonly": 0,
          "aria-required": 0,
          "aria-selected": 0,
          "aria-sort": 0,
          "aria-valuemax": 0,
          "aria-valuemin": 0,
          "aria-valuenow": 0,
          "aria-valuetext": 0,
          // Live Region Attributes
          "aria-atomic": 0,
          "aria-busy": 0,
          "aria-live": 0,
          "aria-relevant": 0,
          // Drag-and-Drop Attributes
          "aria-dropeffect": 0,
          "aria-grabbed": 0,
          // Relationship Attributes
          "aria-activedescendant": 0,
          "aria-colcount": 0,
          "aria-colindex": 0,
          "aria-colspan": 0,
          "aria-controls": 0,
          "aria-describedby": 0,
          "aria-errormessage": 0,
          "aria-flowto": 0,
          "aria-labelledby": 0,
          "aria-owns": 0,
          "aria-posinset": 0,
          "aria-rowcount": 0,
          "aria-rowindex": 0,
          "aria-rowspan": 0,
          "aria-setsize": 0
        };
        var warnedProperties = {};
        var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        var hasOwnProperty$15 = Object.prototype.hasOwnProperty;
        function validateProperty(tagName, name2) {
          {
            if (hasOwnProperty$15.call(warnedProperties, name2) && warnedProperties[name2]) {
              return true;
            }
            if (rARIACamel.test(name2)) {
              var ariaName = "aria-" + name2.slice(4).toLowerCase();
              var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
              if (correctName == null) {
                error2("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name2);
                warnedProperties[name2] = true;
                return true;
              }
              if (name2 !== correctName) {
                error2("Invalid ARIA attribute `%s`. Did you mean `%s`?", name2, correctName);
                warnedProperties[name2] = true;
                return true;
              }
            }
            if (rARIA.test(name2)) {
              var lowerCasedName = name2.toLowerCase();
              var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
              if (standardName == null) {
                warnedProperties[name2] = true;
                return false;
              }
              if (name2 !== standardName) {
                error2("Unknown ARIA attribute `%s`. Did you mean `%s`?", name2, standardName);
                warnedProperties[name2] = true;
                return true;
              }
            }
          }
          return true;
        }
        function warnInvalidARIAProps(type, props) {
          {
            var invalidProps = [];
            for (var key in props) {
              var isValid4 = validateProperty(type, key);
              if (!isValid4) {
                invalidProps.push(key);
              }
            }
            var unknownPropString = invalidProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (invalidProps.length === 1) {
              error2("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            } else if (invalidProps.length > 1) {
              error2("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
            }
          }
        }
        function validateProperties(type, props) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnInvalidARIAProps(type, props);
        }
        var didWarnValueNull = false;
        function validateProperties$1(type, props) {
          {
            if (type !== "input" && type !== "textarea" && type !== "select") {
              return;
            }
            if (props != null && props.value === null && !didWarnValueNull) {
              didWarnValueNull = true;
              if (type === "select" && props.multiple) {
                error2("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", type);
              } else {
                error2("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", type);
              }
            }
          }
        }
        var possibleStandardNames = {
          // HTML
          accept: "accept",
          acceptcharset: "acceptCharset",
          "accept-charset": "acceptCharset",
          accesskey: "accessKey",
          action: "action",
          allowfullscreen: "allowFullScreen",
          alt: "alt",
          as: "as",
          async: "async",
          autocapitalize: "autoCapitalize",
          autocomplete: "autoComplete",
          autocorrect: "autoCorrect",
          autofocus: "autoFocus",
          autoplay: "autoPlay",
          autosave: "autoSave",
          capture: "capture",
          cellpadding: "cellPadding",
          cellspacing: "cellSpacing",
          challenge: "challenge",
          charset: "charSet",
          checked: "checked",
          children: "children",
          cite: "cite",
          class: "className",
          classid: "classID",
          classname: "className",
          cols: "cols",
          colspan: "colSpan",
          content: "content",
          contenteditable: "contentEditable",
          contextmenu: "contextMenu",
          controls: "controls",
          controlslist: "controlsList",
          coords: "coords",
          crossorigin: "crossOrigin",
          dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
          data: "data",
          datetime: "dateTime",
          default: "default",
          defaultchecked: "defaultChecked",
          defaultvalue: "defaultValue",
          defer: "defer",
          dir: "dir",
          disabled: "disabled",
          disablepictureinpicture: "disablePictureInPicture",
          disableremoteplayback: "disableRemotePlayback",
          download: "download",
          draggable: "draggable",
          enctype: "encType",
          enterkeyhint: "enterKeyHint",
          for: "htmlFor",
          form: "form",
          formmethod: "formMethod",
          formaction: "formAction",
          formenctype: "formEncType",
          formnovalidate: "formNoValidate",
          formtarget: "formTarget",
          frameborder: "frameBorder",
          headers: "headers",
          height: "height",
          hidden: "hidden",
          high: "high",
          href: "href",
          hreflang: "hrefLang",
          htmlfor: "htmlFor",
          httpequiv: "httpEquiv",
          "http-equiv": "httpEquiv",
          icon: "icon",
          id: "id",
          innerhtml: "innerHTML",
          inputmode: "inputMode",
          integrity: "integrity",
          is: "is",
          itemid: "itemID",
          itemprop: "itemProp",
          itemref: "itemRef",
          itemscope: "itemScope",
          itemtype: "itemType",
          keyparams: "keyParams",
          keytype: "keyType",
          kind: "kind",
          label: "label",
          lang: "lang",
          list: "list",
          loop: "loop",
          low: "low",
          manifest: "manifest",
          marginwidth: "marginWidth",
          marginheight: "marginHeight",
          max: "max",
          maxlength: "maxLength",
          media: "media",
          mediagroup: "mediaGroup",
          method: "method",
          min: "min",
          minlength: "minLength",
          multiple: "multiple",
          muted: "muted",
          name: "name",
          nomodule: "noModule",
          nonce: "nonce",
          novalidate: "noValidate",
          open: "open",
          optimum: "optimum",
          pattern: "pattern",
          placeholder: "placeholder",
          playsinline: "playsInline",
          poster: "poster",
          preload: "preload",
          profile: "profile",
          radiogroup: "radioGroup",
          readonly: "readOnly",
          referrerpolicy: "referrerPolicy",
          rel: "rel",
          required: "required",
          reversed: "reversed",
          role: "role",
          rows: "rows",
          rowspan: "rowSpan",
          sandbox: "sandbox",
          scope: "scope",
          scoped: "scoped",
          scrolling: "scrolling",
          seamless: "seamless",
          selected: "selected",
          shape: "shape",
          size: "size",
          sizes: "sizes",
          span: "span",
          spellcheck: "spellCheck",
          src: "src",
          srcdoc: "srcDoc",
          srclang: "srcLang",
          srcset: "srcSet",
          start: "start",
          step: "step",
          style: "style",
          summary: "summary",
          tabindex: "tabIndex",
          target: "target",
          title: "title",
          type: "type",
          usemap: "useMap",
          value: "value",
          width: "width",
          wmode: "wmode",
          wrap: "wrap",
          // SVG
          about: "about",
          accentheight: "accentHeight",
          "accent-height": "accentHeight",
          accumulate: "accumulate",
          additive: "additive",
          alignmentbaseline: "alignmentBaseline",
          "alignment-baseline": "alignmentBaseline",
          allowreorder: "allowReorder",
          alphabetic: "alphabetic",
          amplitude: "amplitude",
          arabicform: "arabicForm",
          "arabic-form": "arabicForm",
          ascent: "ascent",
          attributename: "attributeName",
          attributetype: "attributeType",
          autoreverse: "autoReverse",
          azimuth: "azimuth",
          basefrequency: "baseFrequency",
          baselineshift: "baselineShift",
          "baseline-shift": "baselineShift",
          baseprofile: "baseProfile",
          bbox: "bbox",
          begin: "begin",
          bias: "bias",
          by: "by",
          calcmode: "calcMode",
          capheight: "capHeight",
          "cap-height": "capHeight",
          clip: "clip",
          clippath: "clipPath",
          "clip-path": "clipPath",
          clippathunits: "clipPathUnits",
          cliprule: "clipRule",
          "clip-rule": "clipRule",
          color: "color",
          colorinterpolation: "colorInterpolation",
          "color-interpolation": "colorInterpolation",
          colorinterpolationfilters: "colorInterpolationFilters",
          "color-interpolation-filters": "colorInterpolationFilters",
          colorprofile: "colorProfile",
          "color-profile": "colorProfile",
          colorrendering: "colorRendering",
          "color-rendering": "colorRendering",
          contentscripttype: "contentScriptType",
          contentstyletype: "contentStyleType",
          cursor: "cursor",
          cx: "cx",
          cy: "cy",
          d: "d",
          datatype: "datatype",
          decelerate: "decelerate",
          descent: "descent",
          diffuseconstant: "diffuseConstant",
          direction: "direction",
          display: "display",
          divisor: "divisor",
          dominantbaseline: "dominantBaseline",
          "dominant-baseline": "dominantBaseline",
          dur: "dur",
          dx: "dx",
          dy: "dy",
          edgemode: "edgeMode",
          elevation: "elevation",
          enablebackground: "enableBackground",
          "enable-background": "enableBackground",
          end: "end",
          exponent: "exponent",
          externalresourcesrequired: "externalResourcesRequired",
          fill: "fill",
          fillopacity: "fillOpacity",
          "fill-opacity": "fillOpacity",
          fillrule: "fillRule",
          "fill-rule": "fillRule",
          filter: "filter",
          filterres: "filterRes",
          filterunits: "filterUnits",
          floodopacity: "floodOpacity",
          "flood-opacity": "floodOpacity",
          floodcolor: "floodColor",
          "flood-color": "floodColor",
          focusable: "focusable",
          fontfamily: "fontFamily",
          "font-family": "fontFamily",
          fontsize: "fontSize",
          "font-size": "fontSize",
          fontsizeadjust: "fontSizeAdjust",
          "font-size-adjust": "fontSizeAdjust",
          fontstretch: "fontStretch",
          "font-stretch": "fontStretch",
          fontstyle: "fontStyle",
          "font-style": "fontStyle",
          fontvariant: "fontVariant",
          "font-variant": "fontVariant",
          fontweight: "fontWeight",
          "font-weight": "fontWeight",
          format: "format",
          from: "from",
          fx: "fx",
          fy: "fy",
          g1: "g1",
          g2: "g2",
          glyphname: "glyphName",
          "glyph-name": "glyphName",
          glyphorientationhorizontal: "glyphOrientationHorizontal",
          "glyph-orientation-horizontal": "glyphOrientationHorizontal",
          glyphorientationvertical: "glyphOrientationVertical",
          "glyph-orientation-vertical": "glyphOrientationVertical",
          glyphref: "glyphRef",
          gradienttransform: "gradientTransform",
          gradientunits: "gradientUnits",
          hanging: "hanging",
          horizadvx: "horizAdvX",
          "horiz-adv-x": "horizAdvX",
          horizoriginx: "horizOriginX",
          "horiz-origin-x": "horizOriginX",
          ideographic: "ideographic",
          imagerendering: "imageRendering",
          "image-rendering": "imageRendering",
          in2: "in2",
          in: "in",
          inlist: "inlist",
          intercept: "intercept",
          k1: "k1",
          k2: "k2",
          k3: "k3",
          k4: "k4",
          k: "k",
          kernelmatrix: "kernelMatrix",
          kernelunitlength: "kernelUnitLength",
          kerning: "kerning",
          keypoints: "keyPoints",
          keysplines: "keySplines",
          keytimes: "keyTimes",
          lengthadjust: "lengthAdjust",
          letterspacing: "letterSpacing",
          "letter-spacing": "letterSpacing",
          lightingcolor: "lightingColor",
          "lighting-color": "lightingColor",
          limitingconeangle: "limitingConeAngle",
          local: "local",
          markerend: "markerEnd",
          "marker-end": "markerEnd",
          markerheight: "markerHeight",
          markermid: "markerMid",
          "marker-mid": "markerMid",
          markerstart: "markerStart",
          "marker-start": "markerStart",
          markerunits: "markerUnits",
          markerwidth: "markerWidth",
          mask: "mask",
          maskcontentunits: "maskContentUnits",
          maskunits: "maskUnits",
          mathematical: "mathematical",
          mode: "mode",
          numoctaves: "numOctaves",
          offset: "offset",
          opacity: "opacity",
          operator: "operator",
          order: "order",
          orient: "orient",
          orientation: "orientation",
          origin: "origin",
          overflow: "overflow",
          overlineposition: "overlinePosition",
          "overline-position": "overlinePosition",
          overlinethickness: "overlineThickness",
          "overline-thickness": "overlineThickness",
          paintorder: "paintOrder",
          "paint-order": "paintOrder",
          panose1: "panose1",
          "panose-1": "panose1",
          pathlength: "pathLength",
          patterncontentunits: "patternContentUnits",
          patterntransform: "patternTransform",
          patternunits: "patternUnits",
          pointerevents: "pointerEvents",
          "pointer-events": "pointerEvents",
          points: "points",
          pointsatx: "pointsAtX",
          pointsaty: "pointsAtY",
          pointsatz: "pointsAtZ",
          prefix: "prefix",
          preservealpha: "preserveAlpha",
          preserveaspectratio: "preserveAspectRatio",
          primitiveunits: "primitiveUnits",
          property: "property",
          r: "r",
          radius: "radius",
          refx: "refX",
          refy: "refY",
          renderingintent: "renderingIntent",
          "rendering-intent": "renderingIntent",
          repeatcount: "repeatCount",
          repeatdur: "repeatDur",
          requiredextensions: "requiredExtensions",
          requiredfeatures: "requiredFeatures",
          resource: "resource",
          restart: "restart",
          result: "result",
          results: "results",
          rotate: "rotate",
          rx: "rx",
          ry: "ry",
          scale: "scale",
          security: "security",
          seed: "seed",
          shaperendering: "shapeRendering",
          "shape-rendering": "shapeRendering",
          slope: "slope",
          spacing: "spacing",
          specularconstant: "specularConstant",
          specularexponent: "specularExponent",
          speed: "speed",
          spreadmethod: "spreadMethod",
          startoffset: "startOffset",
          stddeviation: "stdDeviation",
          stemh: "stemh",
          stemv: "stemv",
          stitchtiles: "stitchTiles",
          stopcolor: "stopColor",
          "stop-color": "stopColor",
          stopopacity: "stopOpacity",
          "stop-opacity": "stopOpacity",
          strikethroughposition: "strikethroughPosition",
          "strikethrough-position": "strikethroughPosition",
          strikethroughthickness: "strikethroughThickness",
          "strikethrough-thickness": "strikethroughThickness",
          string: "string",
          stroke: "stroke",
          strokedasharray: "strokeDasharray",
          "stroke-dasharray": "strokeDasharray",
          strokedashoffset: "strokeDashoffset",
          "stroke-dashoffset": "strokeDashoffset",
          strokelinecap: "strokeLinecap",
          "stroke-linecap": "strokeLinecap",
          strokelinejoin: "strokeLinejoin",
          "stroke-linejoin": "strokeLinejoin",
          strokemiterlimit: "strokeMiterlimit",
          "stroke-miterlimit": "strokeMiterlimit",
          strokewidth: "strokeWidth",
          "stroke-width": "strokeWidth",
          strokeopacity: "strokeOpacity",
          "stroke-opacity": "strokeOpacity",
          suppresscontenteditablewarning: "suppressContentEditableWarning",
          suppresshydrationwarning: "suppressHydrationWarning",
          surfacescale: "surfaceScale",
          systemlanguage: "systemLanguage",
          tablevalues: "tableValues",
          targetx: "targetX",
          targety: "targetY",
          textanchor: "textAnchor",
          "text-anchor": "textAnchor",
          textdecoration: "textDecoration",
          "text-decoration": "textDecoration",
          textlength: "textLength",
          textrendering: "textRendering",
          "text-rendering": "textRendering",
          to: "to",
          transform: "transform",
          typeof: "typeof",
          u1: "u1",
          u2: "u2",
          underlineposition: "underlinePosition",
          "underline-position": "underlinePosition",
          underlinethickness: "underlineThickness",
          "underline-thickness": "underlineThickness",
          unicode: "unicode",
          unicodebidi: "unicodeBidi",
          "unicode-bidi": "unicodeBidi",
          unicoderange: "unicodeRange",
          "unicode-range": "unicodeRange",
          unitsperem: "unitsPerEm",
          "units-per-em": "unitsPerEm",
          unselectable: "unselectable",
          valphabetic: "vAlphabetic",
          "v-alphabetic": "vAlphabetic",
          values: "values",
          vectoreffect: "vectorEffect",
          "vector-effect": "vectorEffect",
          version: "version",
          vertadvy: "vertAdvY",
          "vert-adv-y": "vertAdvY",
          vertoriginx: "vertOriginX",
          "vert-origin-x": "vertOriginX",
          vertoriginy: "vertOriginY",
          "vert-origin-y": "vertOriginY",
          vhanging: "vHanging",
          "v-hanging": "vHanging",
          videographic: "vIdeographic",
          "v-ideographic": "vIdeographic",
          viewbox: "viewBox",
          viewtarget: "viewTarget",
          visibility: "visibility",
          vmathematical: "vMathematical",
          "v-mathematical": "vMathematical",
          vocab: "vocab",
          widths: "widths",
          wordspacing: "wordSpacing",
          "word-spacing": "wordSpacing",
          writingmode: "writingMode",
          "writing-mode": "writingMode",
          x1: "x1",
          x2: "x2",
          x: "x",
          xchannelselector: "xChannelSelector",
          xheight: "xHeight",
          "x-height": "xHeight",
          xlinkactuate: "xlinkActuate",
          "xlink:actuate": "xlinkActuate",
          xlinkarcrole: "xlinkArcrole",
          "xlink:arcrole": "xlinkArcrole",
          xlinkhref: "xlinkHref",
          "xlink:href": "xlinkHref",
          xlinkrole: "xlinkRole",
          "xlink:role": "xlinkRole",
          xlinkshow: "xlinkShow",
          "xlink:show": "xlinkShow",
          xlinktitle: "xlinkTitle",
          "xlink:title": "xlinkTitle",
          xlinktype: "xlinkType",
          "xlink:type": "xlinkType",
          xmlbase: "xmlBase",
          "xml:base": "xmlBase",
          xmllang: "xmlLang",
          "xml:lang": "xmlLang",
          xmlns: "xmlns",
          "xml:space": "xmlSpace",
          xmlnsxlink: "xmlnsXlink",
          "xmlns:xlink": "xmlnsXlink",
          xmlspace: "xmlSpace",
          y1: "y1",
          y2: "y2",
          y: "y",
          ychannelselector: "yChannelSelector",
          z: "z",
          zoomandpan: "zoomAndPan"
        };
        var validateProperty$1 = function() {
        };
        {
          var warnedProperties$1 = {};
          var _hasOwnProperty = Object.prototype.hasOwnProperty;
          var EVENT_NAME_REGEX = /^on./;
          var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
          var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
          var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
          validateProperty$1 = function(tagName, name2, value, eventRegistry) {
            if (_hasOwnProperty.call(warnedProperties$1, name2) && warnedProperties$1[name2]) {
              return true;
            }
            var lowerCasedName = name2.toLowerCase();
            if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
              error2("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React.");
              warnedProperties$1[name2] = true;
              return true;
            }
            if (eventRegistry != null) {
              var registrationNameDependencies = eventRegistry.registrationNameDependencies, possibleRegistrationNames = eventRegistry.possibleRegistrationNames;
              if (registrationNameDependencies.hasOwnProperty(name2)) {
                return true;
              }
              var registrationName = possibleRegistrationNames.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames[lowerCasedName] : null;
              if (registrationName != null) {
                error2("Invalid event handler property `%s`. Did you mean `%s`?", name2, registrationName);
                warnedProperties$1[name2] = true;
                return true;
              }
              if (EVENT_NAME_REGEX.test(name2)) {
                error2("Unknown event handler property `%s`. It will be ignored.", name2);
                warnedProperties$1[name2] = true;
                return true;
              }
            } else if (EVENT_NAME_REGEX.test(name2)) {
              if (INVALID_EVENT_NAME_REGEX.test(name2)) {
                error2("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", name2);
              }
              warnedProperties$1[name2] = true;
              return true;
            }
            if (rARIA$1.test(name2) || rARIACamel$1.test(name2)) {
              return true;
            }
            if (lowerCasedName === "innerhtml") {
              error2("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`.");
              warnedProperties$1[name2] = true;
              return true;
            }
            if (lowerCasedName === "aria") {
              error2("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead.");
              warnedProperties$1[name2] = true;
              return true;
            }
            if (lowerCasedName === "is" && value !== null && value !== void 0 && typeof value !== "string") {
              error2("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof value);
              warnedProperties$1[name2] = true;
              return true;
            }
            if (typeof value === "number" && isNaN(value)) {
              error2("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", name2);
              warnedProperties$1[name2] = true;
              return true;
            }
            var propertyInfo = getPropertyInfo(name2);
            var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
            if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
              var standardName = possibleStandardNames[lowerCasedName];
              if (standardName !== name2) {
                error2("Invalid DOM property `%s`. Did you mean `%s`?", name2, standardName);
                warnedProperties$1[name2] = true;
                return true;
              }
            } else if (!isReserved && name2 !== lowerCasedName) {
              error2("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", name2, lowerCasedName);
              warnedProperties$1[name2] = true;
              return true;
            }
            if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
              if (value) {
                error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', value, name2, name2, value, name2);
              } else {
                error2('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', value, name2, name2, value, name2, name2, name2);
              }
              warnedProperties$1[name2] = true;
              return true;
            }
            if (isReserved) {
              return true;
            }
            if (shouldRemoveAttributeWithWarning(name2, value, propertyInfo, false)) {
              warnedProperties$1[name2] = true;
              return false;
            }
            if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
              error2("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", value, name2, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name2, value);
              warnedProperties$1[name2] = true;
              return true;
            }
            return true;
          };
        }
        var warnUnknownProperties = function(type, props, eventRegistry) {
          {
            var unknownProps = [];
            for (var key in props) {
              var isValid4 = validateProperty$1(type, key, props[key], eventRegistry);
              if (!isValid4) {
                unknownProps.push(key);
              }
            }
            var unknownPropString = unknownProps.map(function(prop) {
              return "`" + prop + "`";
            }).join(", ");
            if (unknownProps.length === 1) {
              error2("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            } else if (unknownProps.length > 1) {
              error2("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
            }
          }
        };
        function validateProperties$2(type, props, eventRegistry) {
          if (isCustomComponent(type, props)) {
            return;
          }
          warnUnknownProperties(type, props, eventRegistry);
        }
        var toArray4 = React72.Children.toArray;
        var currentDebugStacks = [];
        var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
        var ReactDebugCurrentFrame$1;
        var prevGetCurrentStackImpl = null;
        var getCurrentServerStackImpl = function() {
          return "";
        };
        var describeStackFrame = function(element) {
          return "";
        };
        var validatePropertiesInDevelopment = function(type, props) {
        };
        var pushCurrentDebugStack = function(stack) {
        };
        var pushElementToDebugStack = function(element) {
        };
        var popCurrentDebugStack = function() {
        };
        var hasWarnedAboutUsingContextAsConsumer = false;
        {
          ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
          validatePropertiesInDevelopment = function(type, props) {
            validateProperties(type, props);
            validateProperties$1(type, props);
            validateProperties$2(type, props, null);
          };
          describeStackFrame = function(element) {
            return describeUnknownElementTypeFrameInDEV(element.type, element._source, null);
          };
          pushCurrentDebugStack = function(stack) {
            currentDebugStacks.push(stack);
            if (currentDebugStacks.length === 1) {
              prevGetCurrentStackImpl = ReactDebugCurrentFrame$1.getCurrentStack;
              ReactDebugCurrentFrame$1.getCurrentStack = getCurrentServerStackImpl;
            }
          };
          pushElementToDebugStack = function(element) {
            var stack = currentDebugStacks[currentDebugStacks.length - 1];
            var frame = stack[stack.length - 1];
            frame.debugElementStack.push(element);
          };
          popCurrentDebugStack = function() {
            currentDebugStacks.pop();
            if (currentDebugStacks.length === 0) {
              ReactDebugCurrentFrame$1.getCurrentStack = prevGetCurrentStackImpl;
              prevGetCurrentStackImpl = null;
            }
          };
          getCurrentServerStackImpl = function() {
            if (currentDebugStacks.length === 0) {
              return "";
            }
            var frames = currentDebugStacks[currentDebugStacks.length - 1];
            var stack = "";
            for (var i16 = frames.length - 1; i16 >= 0; i16--) {
              var frame = frames[i16];
              var debugElementStack = frame.debugElementStack;
              for (var ii = debugElementStack.length - 1; ii >= 0; ii--) {
                stack += describeStackFrame(debugElementStack[ii]);
              }
            }
            return stack;
          };
        }
        var didWarnDefaultInputValue = false;
        var didWarnDefaultChecked = false;
        var didWarnDefaultSelectValue = false;
        var didWarnDefaultTextareaValue = false;
        var didWarnInvalidOptionChildren = false;
        var didWarnAboutNoopUpdateForComponent = {};
        var didWarnAboutBadClass = {};
        var didWarnAboutModulePatternComponent = {};
        var didWarnAboutDeprecatedWillMount = {};
        var didWarnAboutUndefinedDerivedState = {};
        var didWarnAboutUninitializedState = {};
        var valuePropNames = ["value", "defaultValue"];
        var newlineEatingTags = {
          listing: true,
          pre: true,
          textarea: true
        };
        var VALID_TAG_REGEX = /^[a-zA-Z][a-zA-Z:_\.\-\d]*$/;
        var validatedTagCache = {};
        function validateDangerousTag(tag) {
          if (!validatedTagCache.hasOwnProperty(tag)) {
            if (!VALID_TAG_REGEX.test(tag)) {
              {
                throw Error("Invalid tag: " + tag);
              }
            }
            validatedTagCache[tag] = true;
          }
        }
        var styleNameCache = {};
        var processStyleName = function(styleName) {
          if (styleNameCache.hasOwnProperty(styleName)) {
            return styleNameCache[styleName];
          }
          var result = hyphenateStyleName(styleName);
          styleNameCache[styleName] = result;
          return result;
        };
        function createMarkupForStyles(styles5) {
          var serialized = "";
          var delimiter = "";
          for (var styleName in styles5) {
            if (!styles5.hasOwnProperty(styleName)) {
              continue;
            }
            var isCustomProperty = styleName.indexOf("--") === 0;
            var styleValue = styles5[styleName];
            {
              if (!isCustomProperty) {
                warnValidStyle$1(styleName, styleValue);
              }
            }
            if (styleValue != null) {
              serialized += delimiter + (isCustomProperty ? styleName : processStyleName(styleName)) + ":";
              serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
              delimiter = ";";
            }
          }
          return serialized || null;
        }
        function warnNoop(publicInstance, callerName) {
          {
            var _constructor = publicInstance.constructor;
            var componentName = _constructor && getComponentName(_constructor) || "ReactClass";
            var warningKey = componentName + "." + callerName;
            if (didWarnAboutNoopUpdateForComponent[warningKey]) {
              return;
            }
            error2("%s(...): Can only update a mounting component. This usually means you called %s() outside componentWillMount() on the server. This is a no-op.\n\nPlease check the code for the %s component.", callerName, callerName, componentName);
            didWarnAboutNoopUpdateForComponent[warningKey] = true;
          }
        }
        function shouldConstruct$1(Component9) {
          return Component9.prototype && Component9.prototype.isReactComponent;
        }
        function getNonChildrenInnerMarkup(props) {
          var innerHTML = props.dangerouslySetInnerHTML;
          if (innerHTML != null) {
            if (innerHTML.__html != null) {
              return innerHTML.__html;
            }
          } else {
            var content = props.children;
            if (typeof content === "string" || typeof content === "number") {
              return escapeTextForBrowser(content);
            }
          }
          return null;
        }
        function flattenTopLevelChildren(children) {
          if (!React72.isValidElement(children)) {
            return toArray4(children);
          }
          var element = children;
          if (element.type !== REACT_FRAGMENT_TYPE) {
            return [element];
          }
          var fragmentChildren = element.props.children;
          if (!React72.isValidElement(fragmentChildren)) {
            return toArray4(fragmentChildren);
          }
          var fragmentChildElement = fragmentChildren;
          return [fragmentChildElement];
        }
        function flattenOptionChildren(children) {
          if (children === void 0 || children === null) {
            return children;
          }
          var content = "";
          React72.Children.forEach(children, function(child) {
            if (child == null) {
              return;
            }
            content += child;
            {
              if (!didWarnInvalidOptionChildren && typeof child !== "string" && typeof child !== "number") {
                didWarnInvalidOptionChildren = true;
                error2("Only strings and numbers are supported as <option> children.");
              }
            }
          });
          return content;
        }
        var hasOwnProperty$25 = Object.prototype.hasOwnProperty;
        var STYLE = "style";
        var RESERVED_PROPS = {
          children: null,
          dangerouslySetInnerHTML: null,
          suppressContentEditableWarning: null,
          suppressHydrationWarning: null
        };
        function createOpenTagMarkup(tagVerbatim, tagLowercase, props, namespace, makeStaticMarkup, isRootElement) {
          var ret = "<" + tagVerbatim;
          var isCustomComponent$1 = isCustomComponent(tagLowercase, props);
          for (var propKey in props) {
            if (!hasOwnProperty$25.call(props, propKey)) {
              continue;
            }
            var propValue = props[propKey];
            if (propValue == null) {
              continue;
            }
            if (propKey === STYLE) {
              propValue = createMarkupForStyles(propValue);
            }
            var markup = null;
            if (isCustomComponent$1) {
              if (!RESERVED_PROPS.hasOwnProperty(propKey)) {
                markup = createMarkupForCustomAttribute(propKey, propValue);
              }
            } else {
              markup = createMarkupForProperty(propKey, propValue);
            }
            if (markup) {
              ret += " " + markup;
            }
          }
          if (makeStaticMarkup) {
            return ret;
          }
          if (isRootElement) {
            ret += " " + createMarkupForRoot();
          }
          return ret;
        }
        function validateRenderResult(child, type) {
          if (child === void 0) {
            {
              {
                throw Error((getComponentName(type) || "Component") + "(...): Nothing was returned from render. This usually means a return statement is missing. Or, to render nothing, return null.");
              }
            }
          }
        }
        function resolve(child, context, threadID) {
          while (React72.isValidElement(child)) {
            var element = child;
            var Component9 = element.type;
            {
              pushElementToDebugStack(element);
            }
            if (typeof Component9 !== "function") {
              break;
            }
            processChild(element, Component9);
          }
          function processChild(element2, Component10) {
            var isClass = shouldConstruct$1(Component10);
            var publicContext = processContext(Component10, context, threadID, isClass);
            var queue = [];
            var replace = false;
            var updater = {
              isMounted: function(publicInstance) {
                return false;
              },
              enqueueForceUpdate: function(publicInstance) {
                if (queue === null) {
                  warnNoop(publicInstance, "forceUpdate");
                  return null;
                }
              },
              enqueueReplaceState: function(publicInstance, completeState) {
                replace = true;
                queue = [completeState];
              },
              enqueueSetState: function(publicInstance, currentPartialState) {
                if (queue === null) {
                  warnNoop(publicInstance, "setState");
                  return null;
                }
                queue.push(currentPartialState);
              }
            };
            var inst;
            if (isClass) {
              inst = new Component10(element2.props, publicContext, updater);
              if (typeof Component10.getDerivedStateFromProps === "function") {
                {
                  if (inst.state === null || inst.state === void 0) {
                    var componentName = getComponentName(Component10) || "Unknown";
                    if (!didWarnAboutUninitializedState[componentName]) {
                      error2("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, inst.state === null ? "null" : "undefined", componentName);
                      didWarnAboutUninitializedState[componentName] = true;
                    }
                  }
                }
                var partialState = Component10.getDerivedStateFromProps.call(null, element2.props, inst.state);
                {
                  if (partialState === void 0) {
                    var _componentName = getComponentName(Component10) || "Unknown";
                    if (!didWarnAboutUndefinedDerivedState[_componentName]) {
                      error2("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", _componentName);
                      didWarnAboutUndefinedDerivedState[_componentName] = true;
                    }
                  }
                }
                if (partialState != null) {
                  inst.state = _assign({}, inst.state, partialState);
                }
              }
            } else {
              {
                if (Component10.prototype && typeof Component10.prototype.render === "function") {
                  var _componentName2 = getComponentName(Component10) || "Unknown";
                  if (!didWarnAboutBadClass[_componentName2]) {
                    error2("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", _componentName2, _componentName2);
                    didWarnAboutBadClass[_componentName2] = true;
                  }
                }
              }
              var componentIdentity = {};
              prepareToUseHooks(componentIdentity);
              inst = Component10(element2.props, publicContext, updater);
              inst = finishHooks(Component10, element2.props, inst, publicContext);
              {
                if (inst != null && inst.render != null) {
                  var _componentName3 = getComponentName(Component10) || "Unknown";
                  if (!didWarnAboutModulePatternComponent[_componentName3]) {
                    error2("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", _componentName3, _componentName3, _componentName3);
                    didWarnAboutModulePatternComponent[_componentName3] = true;
                  }
                }
              }
              if (inst == null || inst.render == null) {
                child = inst;
                validateRenderResult(child, Component10);
                return;
              }
            }
            inst.props = element2.props;
            inst.context = publicContext;
            inst.updater = updater;
            var initialState2 = inst.state;
            if (initialState2 === void 0) {
              inst.state = initialState2 = null;
            }
            if (typeof inst.UNSAFE_componentWillMount === "function" || typeof inst.componentWillMount === "function") {
              if (typeof inst.componentWillMount === "function") {
                {
                  if (inst.componentWillMount.__suppressDeprecationWarning !== true) {
                    var _componentName4 = getComponentName(Component10) || "Unknown";
                    if (!didWarnAboutDeprecatedWillMount[_componentName4]) {
                      warn2(
                        // keep this warning in sync with ReactStrictModeWarning.js
                        "componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code from componentWillMount to componentDidMount (preferred in most cases) or the constructor.\n\nPlease update the following components: %s",
                        _componentName4
                      );
                      didWarnAboutDeprecatedWillMount[_componentName4] = true;
                    }
                  }
                }
                if (typeof Component10.getDerivedStateFromProps !== "function") {
                  inst.componentWillMount();
                }
              }
              if (typeof inst.UNSAFE_componentWillMount === "function" && typeof Component10.getDerivedStateFromProps !== "function") {
                inst.UNSAFE_componentWillMount();
              }
              if (queue.length) {
                var oldQueue = queue;
                var oldReplace = replace;
                queue = null;
                replace = false;
                if (oldReplace && oldQueue.length === 1) {
                  inst.state = oldQueue[0];
                } else {
                  var nextState = oldReplace ? oldQueue[0] : inst.state;
                  var dontMutate = true;
                  for (var i16 = oldReplace ? 1 : 0; i16 < oldQueue.length; i16++) {
                    var partial = oldQueue[i16];
                    var _partialState = typeof partial === "function" ? partial.call(inst, nextState, element2.props, publicContext) : partial;
                    if (_partialState != null) {
                      if (dontMutate) {
                        dontMutate = false;
                        nextState = _assign({}, nextState, _partialState);
                      } else {
                        _assign(nextState, _partialState);
                      }
                    }
                  }
                  inst.state = nextState;
                }
              } else {
                queue = null;
              }
            }
            child = inst.render();
            {
              if (child === void 0 && inst.render._isMockFunction) {
                child = null;
              }
            }
            validateRenderResult(child, Component10);
            var childContext;
            {
              if (typeof inst.getChildContext === "function") {
                var _childContextTypes = Component10.childContextTypes;
                if (typeof _childContextTypes === "object") {
                  childContext = inst.getChildContext();
                  for (var contextKey in childContext) {
                    if (!(contextKey in _childContextTypes)) {
                      {
                        throw Error((getComponentName(Component10) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
                      }
                    }
                  }
                } else {
                  {
                    error2("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", getComponentName(Component10) || "Unknown");
                  }
                }
              }
              if (childContext) {
                context = _assign({}, context, childContext);
              }
            }
          }
          return {
            child,
            context
          };
        }
        var ReactDOMServerRenderer = function() {
          function ReactDOMServerRenderer2(children, makeStaticMarkup, options) {
            var flatChildren = flattenTopLevelChildren(children);
            var topFrame = {
              type: null,
              // Assume all trees start in the HTML namespace (not totally true, but
              // this is what we did historically)
              domNamespace: Namespaces.html,
              children: flatChildren,
              childIndex: 0,
              context: emptyObject,
              footer: ""
            };
            {
              topFrame.debugElementStack = [];
            }
            this.threadID = allocThreadID();
            this.stack = [topFrame];
            this.exhausted = false;
            this.currentSelectValue = null;
            this.previousWasTextNode = false;
            this.makeStaticMarkup = makeStaticMarkup;
            this.suspenseDepth = 0;
            this.contextIndex = -1;
            this.contextStack = [];
            this.contextValueStack = [];
            this.uniqueID = 0;
            this.identifierPrefix = options && options.identifierPrefix || "";
            {
              this.contextProviderStack = [];
            }
          }
          var _proto = ReactDOMServerRenderer2.prototype;
          _proto.destroy = function destroy() {
            if (!this.exhausted) {
              this.exhausted = true;
              this.clearProviders();
              freeThreadID(this.threadID);
            }
          };
          _proto.pushProvider = function pushProvider(provider) {
            var index2 = ++this.contextIndex;
            var context = provider.type._context;
            var threadID = this.threadID;
            validateContextBounds(context, threadID);
            var previousValue = context[threadID];
            this.contextStack[index2] = context;
            this.contextValueStack[index2] = previousValue;
            {
              this.contextProviderStack[index2] = provider;
            }
            context[threadID] = provider.props.value;
          };
          _proto.popProvider = function popProvider(provider) {
            var index2 = this.contextIndex;
            {
              if (index2 < 0 || provider !== this.contextProviderStack[index2]) {
                error2("Unexpected pop.");
              }
            }
            var context = this.contextStack[index2];
            var previousValue = this.contextValueStack[index2];
            this.contextStack[index2] = null;
            this.contextValueStack[index2] = null;
            {
              this.contextProviderStack[index2] = null;
            }
            this.contextIndex--;
            context[this.threadID] = previousValue;
          };
          _proto.clearProviders = function clearProviders() {
            for (var index2 = this.contextIndex; index2 >= 0; index2--) {
              var context = this.contextStack[index2];
              var previousValue = this.contextValueStack[index2];
              context[this.threadID] = previousValue;
            }
          };
          _proto.read = function read(bytes) {
            if (this.exhausted) {
              return null;
            }
            var prevPartialRenderer = currentPartialRenderer;
            setCurrentPartialRenderer(this);
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = Dispatcher;
            try {
              var out = [""];
              var suspended = false;
              while (out[0].length < bytes) {
                if (this.stack.length === 0) {
                  this.exhausted = true;
                  freeThreadID(this.threadID);
                  break;
                }
                var frame = this.stack[this.stack.length - 1];
                if (suspended || frame.childIndex >= frame.children.length) {
                  var footer = frame.footer;
                  if (footer !== "") {
                    this.previousWasTextNode = false;
                  }
                  this.stack.pop();
                  if (frame.type === "select") {
                    this.currentSelectValue = null;
                  } else if (frame.type != null && frame.type.type != null && frame.type.type.$$typeof === REACT_PROVIDER_TYPE) {
                    var provider = frame.type;
                    this.popProvider(provider);
                  } else if (frame.type === REACT_SUSPENSE_TYPE) {
                    this.suspenseDepth--;
                    var buffered = out.pop();
                    if (suspended) {
                      suspended = false;
                      var fallbackFrame = frame.fallbackFrame;
                      if (!fallbackFrame) {
                        {
                          throw Error(true ? "ReactDOMServer did not find an internal fallback frame for Suspense. This is a bug in React. Please file an issue." : formatProdErrorMessage(303));
                        }
                      }
                      this.stack.push(fallbackFrame);
                      out[this.suspenseDepth] += "<!--$!-->";
                      continue;
                    } else {
                      out[this.suspenseDepth] += buffered;
                    }
                  }
                  out[this.suspenseDepth] += footer;
                  continue;
                }
                var child = frame.children[frame.childIndex++];
                var outBuffer = "";
                if (true) {
                  pushCurrentDebugStack(this.stack);
                  frame.debugElementStack.length = 0;
                }
                try {
                  outBuffer += this.render(child, frame.context, frame.domNamespace);
                } catch (err) {
                  if (err != null && typeof err.then === "function") {
                    if (enableSuspenseServerRenderer) {
                      if (!(this.suspenseDepth > 0)) {
                        {
                          throw Error(true ? "A React component suspended while rendering, but no fallback UI was specified.\n\nAdd a <Suspense fallback=...> component higher in the tree to provide a loading indicator or placeholder to display." : formatProdErrorMessage(342));
                        }
                      }
                      suspended = true;
                    } else {
                      if (true) {
                        {
                          throw Error(true ? "ReactDOMServer does not yet support Suspense." : formatProdErrorMessage(294));
                        }
                      }
                    }
                  } else {
                    throw err;
                  }
                } finally {
                  if (true) {
                    popCurrentDebugStack();
                  }
                }
                if (out.length <= this.suspenseDepth) {
                  out.push("");
                }
                out[this.suspenseDepth] += outBuffer;
              }
              return out[0];
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
              setCurrentPartialRenderer(prevPartialRenderer);
              resetHooksState();
            }
          };
          _proto.render = function render3(child, context, parentNamespace) {
            if (typeof child === "string" || typeof child === "number") {
              var text = "" + child;
              if (text === "") {
                return "";
              }
              if (this.makeStaticMarkup) {
                return escapeTextForBrowser(text);
              }
              if (this.previousWasTextNode) {
                return "<!-- -->" + escapeTextForBrowser(text);
              }
              this.previousWasTextNode = true;
              return escapeTextForBrowser(text);
            } else {
              var nextChild;
              var _resolve = resolve(child, context, this.threadID);
              nextChild = _resolve.child;
              context = _resolve.context;
              if (nextChild === null || nextChild === false) {
                return "";
              } else if (!React72.isValidElement(nextChild)) {
                if (nextChild != null && nextChild.$$typeof != null) {
                  var $$typeof = nextChild.$$typeof;
                  if (!($$typeof !== REACT_PORTAL_TYPE)) {
                    {
                      throw Error("Portals are not currently supported by the server renderer. Render them conditionally so that they only appear on the client render.");
                    }
                  }
                  {
                    {
                      throw Error("Unknown element-like object type: " + $$typeof.toString() + ". This is likely a bug in React. Please file an issue.");
                    }
                  }
                }
                var nextChildren = toArray4(nextChild);
                var frame = {
                  type: null,
                  domNamespace: parentNamespace,
                  children: nextChildren,
                  childIndex: 0,
                  context,
                  footer: ""
                };
                {
                  frame.debugElementStack = [];
                }
                this.stack.push(frame);
                return "";
              }
              var nextElement = nextChild;
              var elementType = nextElement.type;
              if (typeof elementType === "string") {
                return this.renderDOM(nextElement, context, parentNamespace);
              }
              switch (elementType) {
                case REACT_LEGACY_HIDDEN_TYPE:
                case REACT_DEBUG_TRACING_MODE_TYPE:
                case REACT_STRICT_MODE_TYPE:
                case REACT_PROFILER_TYPE:
                case REACT_SUSPENSE_LIST_TYPE:
                case REACT_FRAGMENT_TYPE: {
                  var _nextChildren = toArray4(nextChild.props.children);
                  var _frame = {
                    type: null,
                    domNamespace: parentNamespace,
                    children: _nextChildren,
                    childIndex: 0,
                    context,
                    footer: ""
                  };
                  {
                    _frame.debugElementStack = [];
                  }
                  this.stack.push(_frame);
                  return "";
                }
                case REACT_SUSPENSE_TYPE: {
                  {
                    {
                      {
                        throw Error("ReactDOMServer does not yet support Suspense.");
                      }
                    }
                  }
                }
                case REACT_SCOPE_TYPE: {
                  {
                    {
                      throw Error("ReactDOMServer does not yet support scope components.");
                    }
                  }
                }
              }
              if (typeof elementType === "object" && elementType !== null) {
                switch (elementType.$$typeof) {
                  case REACT_FORWARD_REF_TYPE: {
                    var element = nextChild;
                    var _nextChildren5;
                    var componentIdentity = {};
                    prepareToUseHooks(componentIdentity);
                    _nextChildren5 = elementType.render(element.props, element.ref);
                    _nextChildren5 = finishHooks(elementType.render, element.props, _nextChildren5, element.ref);
                    _nextChildren5 = toArray4(_nextChildren5);
                    var _frame5 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren5,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame5.debugElementStack = [];
                    }
                    this.stack.push(_frame5);
                    return "";
                  }
                  case REACT_MEMO_TYPE: {
                    var _element = nextChild;
                    var _nextChildren6 = [React72.createElement(elementType.type, _assign({
                      ref: _element.ref
                    }, _element.props))];
                    var _frame6 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren6,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame6.debugElementStack = [];
                    }
                    this.stack.push(_frame6);
                    return "";
                  }
                  case REACT_PROVIDER_TYPE: {
                    var provider = nextChild;
                    var nextProps = provider.props;
                    var _nextChildren7 = toArray4(nextProps.children);
                    var _frame7 = {
                      type: provider,
                      domNamespace: parentNamespace,
                      children: _nextChildren7,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame7.debugElementStack = [];
                    }
                    this.pushProvider(provider);
                    this.stack.push(_frame7);
                    return "";
                  }
                  case REACT_CONTEXT_TYPE: {
                    var reactContext = nextChild.type;
                    {
                      if (reactContext._context === void 0) {
                        if (reactContext !== reactContext.Consumer) {
                          if (!hasWarnedAboutUsingContextAsConsumer) {
                            hasWarnedAboutUsingContextAsConsumer = true;
                            error2("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?");
                          }
                        }
                      } else {
                        reactContext = reactContext._context;
                      }
                    }
                    var _nextProps = nextChild.props;
                    var threadID = this.threadID;
                    validateContextBounds(reactContext, threadID);
                    var nextValue = reactContext[threadID];
                    var _nextChildren8 = toArray4(_nextProps.children(nextValue));
                    var _frame8 = {
                      type: nextChild,
                      domNamespace: parentNamespace,
                      children: _nextChildren8,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame8.debugElementStack = [];
                    }
                    this.stack.push(_frame8);
                    return "";
                  }
                  case REACT_FUNDAMENTAL_TYPE: {
                    {
                      {
                        throw Error("ReactDOMServer does not yet support the fundamental API.");
                      }
                    }
                  }
                  case REACT_LAZY_TYPE: {
                    var _element2 = nextChild;
                    var lazyComponent = nextChild.type;
                    var payload = lazyComponent._payload;
                    var init = lazyComponent._init;
                    var result = init(payload);
                    var _nextChildren10 = [React72.createElement(result, _assign({
                      ref: _element2.ref
                    }, _element2.props))];
                    var _frame10 = {
                      type: null,
                      domNamespace: parentNamespace,
                      children: _nextChildren10,
                      childIndex: 0,
                      context,
                      footer: ""
                    };
                    {
                      _frame10.debugElementStack = [];
                    }
                    this.stack.push(_frame10);
                    return "";
                  }
                }
              }
              var info = "";
              {
                var owner = nextElement._owner;
                if (elementType === void 0 || typeof elementType === "object" && elementType !== null && Object.keys(elementType).length === 0) {
                  info += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";
                }
                var ownerName = owner ? getComponentName(owner) : null;
                if (ownerName) {
                  info += "\n\nCheck the render method of `" + ownerName + "`.";
                }
              }
              {
                {
                  throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: " + (elementType == null ? elementType : typeof elementType) + "." + info);
                }
              }
            }
          };
          _proto.renderDOM = function renderDOM(element, context, parentNamespace) {
            var tag = element.type.toLowerCase();
            var namespace = parentNamespace;
            if (parentNamespace === Namespaces.html) {
              namespace = getIntrinsicNamespace(tag);
            }
            {
              if (namespace === Namespaces.html) {
                if (tag !== element.type) {
                  error2("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", element.type);
                }
              }
            }
            validateDangerousTag(tag);
            var props = element.props;
            if (tag === "input") {
              {
                checkControlledValueProps("input", props);
                if (props.checked !== void 0 && props.defaultChecked !== void 0 && !didWarnDefaultChecked) {
                  error2("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                  didWarnDefaultChecked = true;
                }
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultInputValue) {
                  error2("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", "A component", props.type);
                  didWarnDefaultInputValue = true;
                }
              }
              props = _assign({
                type: void 0
              }, props, {
                defaultChecked: void 0,
                defaultValue: void 0,
                value: props.value != null ? props.value : props.defaultValue,
                checked: props.checked != null ? props.checked : props.defaultChecked
              });
            } else if (tag === "textarea") {
              {
                checkControlledValueProps("textarea", props);
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultTextareaValue) {
                  error2("Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                  didWarnDefaultTextareaValue = true;
                }
              }
              var initialValue = props.value;
              if (initialValue == null) {
                var defaultValue = props.defaultValue;
                var textareaChildren = props.children;
                if (textareaChildren != null) {
                  {
                    error2("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
                  }
                  if (!(defaultValue == null)) {
                    {
                      throw Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
                    }
                  }
                  if (Array.isArray(textareaChildren)) {
                    if (!(textareaChildren.length <= 1)) {
                      {
                        throw Error("<textarea> can only have at most one child.");
                      }
                    }
                    textareaChildren = textareaChildren[0];
                  }
                  defaultValue = "" + textareaChildren;
                }
                if (defaultValue == null) {
                  defaultValue = "";
                }
                initialValue = defaultValue;
              }
              props = _assign({}, props, {
                value: void 0,
                children: "" + initialValue
              });
            } else if (tag === "select") {
              {
                checkControlledValueProps("select", props);
                for (var i16 = 0; i16 < valuePropNames.length; i16++) {
                  var propName = valuePropNames[i16];
                  if (props[propName] == null) {
                    continue;
                  }
                  var isArray10 = Array.isArray(props[propName]);
                  if (props.multiple && !isArray10) {
                    error2("The `%s` prop supplied to <select> must be an array if `multiple` is true.", propName);
                  } else if (!props.multiple && isArray10) {
                    error2("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.", propName);
                  }
                }
                if (props.value !== void 0 && props.defaultValue !== void 0 && !didWarnDefaultSelectValue) {
                  error2("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components");
                  didWarnDefaultSelectValue = true;
                }
              }
              this.currentSelectValue = props.value != null ? props.value : props.defaultValue;
              props = _assign({}, props, {
                value: void 0
              });
            } else if (tag === "option") {
              var selected = null;
              var selectValue = this.currentSelectValue;
              var optionChildren = flattenOptionChildren(props.children);
              if (selectValue != null) {
                var value;
                if (props.value != null) {
                  value = props.value + "";
                } else {
                  value = optionChildren;
                }
                selected = false;
                if (Array.isArray(selectValue)) {
                  for (var j6 = 0; j6 < selectValue.length; j6++) {
                    if ("" + selectValue[j6] === value) {
                      selected = true;
                      break;
                    }
                  }
                } else {
                  selected = "" + selectValue === value;
                }
                props = _assign({
                  selected: void 0,
                  children: void 0
                }, props, {
                  selected,
                  children: optionChildren
                });
              }
            }
            {
              validatePropertiesInDevelopment(tag, props);
            }
            assertValidProps(tag, props);
            var out = createOpenTagMarkup(element.type, tag, props, namespace, this.makeStaticMarkup, this.stack.length === 1);
            var footer = "";
            if (omittedCloseTags.hasOwnProperty(tag)) {
              out += "/>";
            } else {
              out += ">";
              footer = "</" + element.type + ">";
            }
            var children;
            var innerMarkup = getNonChildrenInnerMarkup(props);
            if (innerMarkup != null) {
              children = [];
              if (newlineEatingTags.hasOwnProperty(tag) && innerMarkup.charAt(0) === "\n") {
                out += "\n";
              }
              out += innerMarkup;
            } else {
              children = toArray4(props.children);
            }
            var frame = {
              domNamespace: getChildNamespace(parentNamespace, element.type),
              type: tag,
              children,
              childIndex: 0,
              context,
              footer
            };
            {
              frame.debugElementStack = [];
            }
            this.stack.push(frame);
            this.previousWasTextNode = false;
            return out;
          };
          return ReactDOMServerRenderer2;
        }();
        function renderToString(element, options) {
          var renderer = new ReactDOMServerRenderer(element, false, options);
          try {
            var markup = renderer.read(Infinity);
            return markup;
          } finally {
            renderer.destroy();
          }
        }
        function renderToStaticMarkup2(element, options) {
          var renderer = new ReactDOMServerRenderer(element, true, options);
          try {
            var markup = renderer.read(Infinity);
            return markup;
          } finally {
            renderer.destroy();
          }
        }
        function renderToNodeStream() {
          {
            {
              throw Error("ReactDOMServer.renderToNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToString() instead.");
            }
          }
        }
        function renderToStaticNodeStream() {
          {
            {
              throw Error("ReactDOMServer.renderToStaticNodeStream(): The streaming API is not available in the browser. Use ReactDOMServer.renderToStaticMarkup() instead.");
            }
          }
        }
        exports2.renderToNodeStream = renderToNodeStream;
        exports2.renderToStaticMarkup = renderToStaticMarkup2;
        exports2.renderToStaticNodeStream = renderToStaticNodeStream;
        exports2.renderToString = renderToString;
        exports2.version = ReactVersion;
      })();
    }
  }
});

// node_modules/react-dom/server.browser.js
var require_server_browser = __commonJS({
  "node_modules/react-dom/server.browser.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_dom_server_browser_development();
    }
  }
});

// node_modules/html-entities/lib/named-references.js
var require_named_references = __commonJS({
  "node_modules/html-entities/lib/named-references.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.bodyRegExps = { xml: /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g, html4: /&(?:nbsp|iexcl|cent|pound|curren|yen|brvbar|sect|uml|copy|ordf|laquo|not|shy|reg|macr|deg|plusmn|sup2|sup3|acute|micro|para|middot|cedil|sup1|ordm|raquo|frac14|frac12|frac34|iquest|Agrave|Aacute|Acirc|Atilde|Auml|Aring|AElig|Ccedil|Egrave|Eacute|Ecirc|Euml|Igrave|Iacute|Icirc|Iuml|ETH|Ntilde|Ograve|Oacute|Ocirc|Otilde|Ouml|times|Oslash|Ugrave|Uacute|Ucirc|Uuml|Yacute|THORN|szlig|agrave|aacute|acirc|atilde|auml|aring|aelig|ccedil|egrave|eacute|ecirc|euml|igrave|iacute|icirc|iuml|eth|ntilde|ograve|oacute|ocirc|otilde|ouml|divide|oslash|ugrave|uacute|ucirc|uuml|yacute|thorn|yuml|quot|amp|lt|gt|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g, html5: /&(?:AElig|AMP|Aacute|Acirc|Agrave|Aring|Atilde|Auml|COPY|Ccedil|ETH|Eacute|Ecirc|Egrave|Euml|GT|Iacute|Icirc|Igrave|Iuml|LT|Ntilde|Oacute|Ocirc|Ograve|Oslash|Otilde|Ouml|QUOT|REG|THORN|Uacute|Ucirc|Ugrave|Uuml|Yacute|aacute|acirc|acute|aelig|agrave|amp|aring|atilde|auml|brvbar|ccedil|cedil|cent|copy|curren|deg|divide|eacute|ecirc|egrave|eth|euml|frac12|frac14|frac34|gt|iacute|icirc|iexcl|igrave|iquest|iuml|laquo|lt|macr|micro|middot|nbsp|not|ntilde|oacute|ocirc|ograve|ordf|ordm|oslash|otilde|ouml|para|plusmn|pound|quot|raquo|reg|sect|shy|sup1|sup2|sup3|szlig|thorn|times|uacute|ucirc|ugrave|uml|uuml|yacute|yen|yuml|#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);?/g };
    exports2.namedReferences = { xml: { entities: { "&lt;": "<", "&gt;": ">", "&quot;": '"', "&apos;": "'", "&amp;": "&" }, characters: { "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&apos;", "&": "&amp;" } }, html4: { entities: { "&apos;": "'", "&nbsp": " ", "&nbsp;": " ", "&iexcl": "¡", "&iexcl;": "¡", "&cent": "¢", "&cent;": "¢", "&pound": "£", "&pound;": "£", "&curren": "¤", "&curren;": "¤", "&yen": "¥", "&yen;": "¥", "&brvbar": "¦", "&brvbar;": "¦", "&sect": "§", "&sect;": "§", "&uml": "¨", "&uml;": "¨", "&copy": "©", "&copy;": "©", "&ordf": "ª", "&ordf;": "ª", "&laquo": "«", "&laquo;": "«", "&not": "¬", "&not;": "¬", "&shy": "­", "&shy;": "­", "&reg": "®", "&reg;": "®", "&macr": "¯", "&macr;": "¯", "&deg": "°", "&deg;": "°", "&plusmn": "±", "&plusmn;": "±", "&sup2": "²", "&sup2;": "²", "&sup3": "³", "&sup3;": "³", "&acute": "´", "&acute;": "´", "&micro": "µ", "&micro;": "µ", "&para": "¶", "&para;": "¶", "&middot": "·", "&middot;": "·", "&cedil": "¸", "&cedil;": "¸", "&sup1": "¹", "&sup1;": "¹", "&ordm": "º", "&ordm;": "º", "&raquo": "»", "&raquo;": "»", "&frac14": "¼", "&frac14;": "¼", "&frac12": "½", "&frac12;": "½", "&frac34": "¾", "&frac34;": "¾", "&iquest": "¿", "&iquest;": "¿", "&Agrave": "À", "&Agrave;": "À", "&Aacute": "Á", "&Aacute;": "Á", "&Acirc": "Â", "&Acirc;": "Â", "&Atilde": "Ã", "&Atilde;": "Ã", "&Auml": "Ä", "&Auml;": "Ä", "&Aring": "Å", "&Aring;": "Å", "&AElig": "Æ", "&AElig;": "Æ", "&Ccedil": "Ç", "&Ccedil;": "Ç", "&Egrave": "È", "&Egrave;": "È", "&Eacute": "É", "&Eacute;": "É", "&Ecirc": "Ê", "&Ecirc;": "Ê", "&Euml": "Ë", "&Euml;": "Ë", "&Igrave": "Ì", "&Igrave;": "Ì", "&Iacute": "Í", "&Iacute;": "Í", "&Icirc": "Î", "&Icirc;": "Î", "&Iuml": "Ï", "&Iuml;": "Ï", "&ETH": "Ð", "&ETH;": "Ð", "&Ntilde": "Ñ", "&Ntilde;": "Ñ", "&Ograve": "Ò", "&Ograve;": "Ò", "&Oacute": "Ó", "&Oacute;": "Ó", "&Ocirc": "Ô", "&Ocirc;": "Ô", "&Otilde": "Õ", "&Otilde;": "Õ", "&Ouml": "Ö", "&Ouml;": "Ö", "&times": "×", "&times;": "×", "&Oslash": "Ø", "&Oslash;": "Ø", "&Ugrave": "Ù", "&Ugrave;": "Ù", "&Uacute": "Ú", "&Uacute;": "Ú", "&Ucirc": "Û", "&Ucirc;": "Û", "&Uuml": "Ü", "&Uuml;": "Ü", "&Yacute": "Ý", "&Yacute;": "Ý", "&THORN": "Þ", "&THORN;": "Þ", "&szlig": "ß", "&szlig;": "ß", "&agrave": "à", "&agrave;": "à", "&aacute": "á", "&aacute;": "á", "&acirc": "â", "&acirc;": "â", "&atilde": "ã", "&atilde;": "ã", "&auml": "ä", "&auml;": "ä", "&aring": "å", "&aring;": "å", "&aelig": "æ", "&aelig;": "æ", "&ccedil": "ç", "&ccedil;": "ç", "&egrave": "è", "&egrave;": "è", "&eacute": "é", "&eacute;": "é", "&ecirc": "ê", "&ecirc;": "ê", "&euml": "ë", "&euml;": "ë", "&igrave": "ì", "&igrave;": "ì", "&iacute": "í", "&iacute;": "í", "&icirc": "î", "&icirc;": "î", "&iuml": "ï", "&iuml;": "ï", "&eth": "ð", "&eth;": "ð", "&ntilde": "ñ", "&ntilde;": "ñ", "&ograve": "ò", "&ograve;": "ò", "&oacute": "ó", "&oacute;": "ó", "&ocirc": "ô", "&ocirc;": "ô", "&otilde": "õ", "&otilde;": "õ", "&ouml": "ö", "&ouml;": "ö", "&divide": "÷", "&divide;": "÷", "&oslash": "ø", "&oslash;": "ø", "&ugrave": "ù", "&ugrave;": "ù", "&uacute": "ú", "&uacute;": "ú", "&ucirc": "û", "&ucirc;": "û", "&uuml": "ü", "&uuml;": "ü", "&yacute": "ý", "&yacute;": "ý", "&thorn": "þ", "&thorn;": "þ", "&yuml": "ÿ", "&yuml;": "ÿ", "&quot": '"', "&quot;": '"', "&amp": "&", "&amp;": "&", "&lt": "<", "&lt;": "<", "&gt": ">", "&gt;": ">", "&OElig;": "Œ", "&oelig;": "œ", "&Scaron;": "Š", "&scaron;": "š", "&Yuml;": "Ÿ", "&circ;": "ˆ", "&tilde;": "˜", "&ensp;": " ", "&emsp;": " ", "&thinsp;": " ", "&zwnj;": "‌", "&zwj;": "‍", "&lrm;": "‎", "&rlm;": "‏", "&ndash;": "–", "&mdash;": "—", "&lsquo;": "‘", "&rsquo;": "’", "&sbquo;": "‚", "&ldquo;": "“", "&rdquo;": "”", "&bdquo;": "„", "&dagger;": "†", "&Dagger;": "‡", "&permil;": "‰", "&lsaquo;": "‹", "&rsaquo;": "›", "&euro;": "€", "&fnof;": "ƒ", "&Alpha;": "Α", "&Beta;": "Β", "&Gamma;": "Γ", "&Delta;": "Δ", "&Epsilon;": "Ε", "&Zeta;": "Ζ", "&Eta;": "Η", "&Theta;": "Θ", "&Iota;": "Ι", "&Kappa;": "Κ", "&Lambda;": "Λ", "&Mu;": "Μ", "&Nu;": "Ν", "&Xi;": "Ξ", "&Omicron;": "Ο", "&Pi;": "Π", "&Rho;": "Ρ", "&Sigma;": "Σ", "&Tau;": "Τ", "&Upsilon;": "Υ", "&Phi;": "Φ", "&Chi;": "Χ", "&Psi;": "Ψ", "&Omega;": "Ω", "&alpha;": "α", "&beta;": "β", "&gamma;": "γ", "&delta;": "δ", "&epsilon;": "ε", "&zeta;": "ζ", "&eta;": "η", "&theta;": "θ", "&iota;": "ι", "&kappa;": "κ", "&lambda;": "λ", "&mu;": "μ", "&nu;": "ν", "&xi;": "ξ", "&omicron;": "ο", "&pi;": "π", "&rho;": "ρ", "&sigmaf;": "ς", "&sigma;": "σ", "&tau;": "τ", "&upsilon;": "υ", "&phi;": "φ", "&chi;": "χ", "&psi;": "ψ", "&omega;": "ω", "&thetasym;": "ϑ", "&upsih;": "ϒ", "&piv;": "ϖ", "&bull;": "•", "&hellip;": "…", "&prime;": "′", "&Prime;": "″", "&oline;": "‾", "&frasl;": "⁄", "&weierp;": "℘", "&image;": "ℑ", "&real;": "ℜ", "&trade;": "™", "&alefsym;": "ℵ", "&larr;": "←", "&uarr;": "↑", "&rarr;": "→", "&darr;": "↓", "&harr;": "↔", "&crarr;": "↵", "&lArr;": "⇐", "&uArr;": "⇑", "&rArr;": "⇒", "&dArr;": "⇓", "&hArr;": "⇔", "&forall;": "∀", "&part;": "∂", "&exist;": "∃", "&empty;": "∅", "&nabla;": "∇", "&isin;": "∈", "&notin;": "∉", "&ni;": "∋", "&prod;": "∏", "&sum;": "∑", "&minus;": "−", "&lowast;": "∗", "&radic;": "√", "&prop;": "∝", "&infin;": "∞", "&ang;": "∠", "&and;": "∧", "&or;": "∨", "&cap;": "∩", "&cup;": "∪", "&int;": "∫", "&there4;": "∴", "&sim;": "∼", "&cong;": "≅", "&asymp;": "≈", "&ne;": "≠", "&equiv;": "≡", "&le;": "≤", "&ge;": "≥", "&sub;": "⊂", "&sup;": "⊃", "&nsub;": "⊄", "&sube;": "⊆", "&supe;": "⊇", "&oplus;": "⊕", "&otimes;": "⊗", "&perp;": "⊥", "&sdot;": "⋅", "&lceil;": "⌈", "&rceil;": "⌉", "&lfloor;": "⌊", "&rfloor;": "⌋", "&lang;": "〈", "&rang;": "〉", "&loz;": "◊", "&spades;": "♠", "&clubs;": "♣", "&hearts;": "♥", "&diams;": "♦" }, characters: { "'": "&apos;", " ": "&nbsp;", "¡": "&iexcl;", "¢": "&cent;", "£": "&pound;", "¤": "&curren;", "¥": "&yen;", "¦": "&brvbar;", "§": "&sect;", "¨": "&uml;", "©": "&copy;", "ª": "&ordf;", "«": "&laquo;", "¬": "&not;", "­": "&shy;", "®": "&reg;", "¯": "&macr;", "°": "&deg;", "±": "&plusmn;", "²": "&sup2;", "³": "&sup3;", "´": "&acute;", "µ": "&micro;", "¶": "&para;", "·": "&middot;", "¸": "&cedil;", "¹": "&sup1;", "º": "&ordm;", "»": "&raquo;", "¼": "&frac14;", "½": "&frac12;", "¾": "&frac34;", "¿": "&iquest;", "À": "&Agrave;", "Á": "&Aacute;", "Â": "&Acirc;", "Ã": "&Atilde;", "Ä": "&Auml;", "Å": "&Aring;", "Æ": "&AElig;", "Ç": "&Ccedil;", "È": "&Egrave;", "É": "&Eacute;", "Ê": "&Ecirc;", "Ë": "&Euml;", "Ì": "&Igrave;", "Í": "&Iacute;", "Î": "&Icirc;", "Ï": "&Iuml;", "Ð": "&ETH;", "Ñ": "&Ntilde;", "Ò": "&Ograve;", "Ó": "&Oacute;", "Ô": "&Ocirc;", "Õ": "&Otilde;", "Ö": "&Ouml;", "×": "&times;", "Ø": "&Oslash;", "Ù": "&Ugrave;", "Ú": "&Uacute;", "Û": "&Ucirc;", "Ü": "&Uuml;", "Ý": "&Yacute;", "Þ": "&THORN;", "ß": "&szlig;", "à": "&agrave;", "á": "&aacute;", "â": "&acirc;", "ã": "&atilde;", "ä": "&auml;", "å": "&aring;", "æ": "&aelig;", "ç": "&ccedil;", "è": "&egrave;", "é": "&eacute;", "ê": "&ecirc;", "ë": "&euml;", "ì": "&igrave;", "í": "&iacute;", "î": "&icirc;", "ï": "&iuml;", "ð": "&eth;", "ñ": "&ntilde;", "ò": "&ograve;", "ó": "&oacute;", "ô": "&ocirc;", "õ": "&otilde;", "ö": "&ouml;", "÷": "&divide;", "ø": "&oslash;", "ù": "&ugrave;", "ú": "&uacute;", "û": "&ucirc;", "ü": "&uuml;", "ý": "&yacute;", "þ": "&thorn;", "ÿ": "&yuml;", '"': "&quot;", "&": "&amp;", "<": "&lt;", ">": "&gt;", "Œ": "&OElig;", "œ": "&oelig;", "Š": "&Scaron;", "š": "&scaron;", "Ÿ": "&Yuml;", "ˆ": "&circ;", "˜": "&tilde;", " ": "&ensp;", " ": "&emsp;", " ": "&thinsp;", "‌": "&zwnj;", "‍": "&zwj;", "‎": "&lrm;", "‏": "&rlm;", "–": "&ndash;", "—": "&mdash;", "‘": "&lsquo;", "’": "&rsquo;", "‚": "&sbquo;", "“": "&ldquo;", "”": "&rdquo;", "„": "&bdquo;", "†": "&dagger;", "‡": "&Dagger;", "‰": "&permil;", "‹": "&lsaquo;", "›": "&rsaquo;", "€": "&euro;", "ƒ": "&fnof;", "Α": "&Alpha;", "Β": "&Beta;", "Γ": "&Gamma;", "Δ": "&Delta;", "Ε": "&Epsilon;", "Ζ": "&Zeta;", "Η": "&Eta;", "Θ": "&Theta;", "Ι": "&Iota;", "Κ": "&Kappa;", "Λ": "&Lambda;", "Μ": "&Mu;", "Ν": "&Nu;", "Ξ": "&Xi;", "Ο": "&Omicron;", "Π": "&Pi;", "Ρ": "&Rho;", "Σ": "&Sigma;", "Τ": "&Tau;", "Υ": "&Upsilon;", "Φ": "&Phi;", "Χ": "&Chi;", "Ψ": "&Psi;", "Ω": "&Omega;", "α": "&alpha;", "β": "&beta;", "γ": "&gamma;", "δ": "&delta;", "ε": "&epsilon;", "ζ": "&zeta;", "η": "&eta;", "θ": "&theta;", "ι": "&iota;", "κ": "&kappa;", "λ": "&lambda;", "μ": "&mu;", "ν": "&nu;", "ξ": "&xi;", "ο": "&omicron;", "π": "&pi;", "ρ": "&rho;", "ς": "&sigmaf;", "σ": "&sigma;", "τ": "&tau;", "υ": "&upsilon;", "φ": "&phi;", "χ": "&chi;", "ψ": "&psi;", "ω": "&omega;", "ϑ": "&thetasym;", "ϒ": "&upsih;", "ϖ": "&piv;", "•": "&bull;", "…": "&hellip;", "′": "&prime;", "″": "&Prime;", "‾": "&oline;", "⁄": "&frasl;", "℘": "&weierp;", "ℑ": "&image;", "ℜ": "&real;", "™": "&trade;", "ℵ": "&alefsym;", "←": "&larr;", "↑": "&uarr;", "→": "&rarr;", "↓": "&darr;", "↔": "&harr;", "↵": "&crarr;", "⇐": "&lArr;", "⇑": "&uArr;", "⇒": "&rArr;", "⇓": "&dArr;", "⇔": "&hArr;", "∀": "&forall;", "∂": "&part;", "∃": "&exist;", "∅": "&empty;", "∇": "&nabla;", "∈": "&isin;", "∉": "&notin;", "∋": "&ni;", "∏": "&prod;", "∑": "&sum;", "−": "&minus;", "∗": "&lowast;", "√": "&radic;", "∝": "&prop;", "∞": "&infin;", "∠": "&ang;", "∧": "&and;", "∨": "&or;", "∩": "&cap;", "∪": "&cup;", "∫": "&int;", "∴": "&there4;", "∼": "&sim;", "≅": "&cong;", "≈": "&asymp;", "≠": "&ne;", "≡": "&equiv;", "≤": "&le;", "≥": "&ge;", "⊂": "&sub;", "⊃": "&sup;", "⊄": "&nsub;", "⊆": "&sube;", "⊇": "&supe;", "⊕": "&oplus;", "⊗": "&otimes;", "⊥": "&perp;", "⋅": "&sdot;", "⌈": "&lceil;", "⌉": "&rceil;", "⌊": "&lfloor;", "⌋": "&rfloor;", "〈": "&lang;", "〉": "&rang;", "◊": "&loz;", "♠": "&spades;", "♣": "&clubs;", "♥": "&hearts;", "♦": "&diams;" } }, html5: { entities: { "&AElig": "Æ", "&AElig;": "Æ", "&AMP": "&", "&AMP;": "&", "&Aacute": "Á", "&Aacute;": "Á", "&Abreve;": "Ă", "&Acirc": "Â", "&Acirc;": "Â", "&Acy;": "А", "&Afr;": "𝔄", "&Agrave": "À", "&Agrave;": "À", "&Alpha;": "Α", "&Amacr;": "Ā", "&And;": "⩓", "&Aogon;": "Ą", "&Aopf;": "𝔸", "&ApplyFunction;": "⁡", "&Aring": "Å", "&Aring;": "Å", "&Ascr;": "𝒜", "&Assign;": "≔", "&Atilde": "Ã", "&Atilde;": "Ã", "&Auml": "Ä", "&Auml;": "Ä", "&Backslash;": "∖", "&Barv;": "⫧", "&Barwed;": "⌆", "&Bcy;": "Б", "&Because;": "∵", "&Bernoullis;": "ℬ", "&Beta;": "Β", "&Bfr;": "𝔅", "&Bopf;": "𝔹", "&Breve;": "˘", "&Bscr;": "ℬ", "&Bumpeq;": "≎", "&CHcy;": "Ч", "&COPY": "©", "&COPY;": "©", "&Cacute;": "Ć", "&Cap;": "⋒", "&CapitalDifferentialD;": "ⅅ", "&Cayleys;": "ℭ", "&Ccaron;": "Č", "&Ccedil": "Ç", "&Ccedil;": "Ç", "&Ccirc;": "Ĉ", "&Cconint;": "∰", "&Cdot;": "Ċ", "&Cedilla;": "¸", "&CenterDot;": "·", "&Cfr;": "ℭ", "&Chi;": "Χ", "&CircleDot;": "⊙", "&CircleMinus;": "⊖", "&CirclePlus;": "⊕", "&CircleTimes;": "⊗", "&ClockwiseContourIntegral;": "∲", "&CloseCurlyDoubleQuote;": "”", "&CloseCurlyQuote;": "’", "&Colon;": "∷", "&Colone;": "⩴", "&Congruent;": "≡", "&Conint;": "∯", "&ContourIntegral;": "∮", "&Copf;": "ℂ", "&Coproduct;": "∐", "&CounterClockwiseContourIntegral;": "∳", "&Cross;": "⨯", "&Cscr;": "𝒞", "&Cup;": "⋓", "&CupCap;": "≍", "&DD;": "ⅅ", "&DDotrahd;": "⤑", "&DJcy;": "Ђ", "&DScy;": "Ѕ", "&DZcy;": "Џ", "&Dagger;": "‡", "&Darr;": "↡", "&Dashv;": "⫤", "&Dcaron;": "Ď", "&Dcy;": "Д", "&Del;": "∇", "&Delta;": "Δ", "&Dfr;": "𝔇", "&DiacriticalAcute;": "´", "&DiacriticalDot;": "˙", "&DiacriticalDoubleAcute;": "˝", "&DiacriticalGrave;": "`", "&DiacriticalTilde;": "˜", "&Diamond;": "⋄", "&DifferentialD;": "ⅆ", "&Dopf;": "𝔻", "&Dot;": "¨", "&DotDot;": "⃜", "&DotEqual;": "≐", "&DoubleContourIntegral;": "∯", "&DoubleDot;": "¨", "&DoubleDownArrow;": "⇓", "&DoubleLeftArrow;": "⇐", "&DoubleLeftRightArrow;": "⇔", "&DoubleLeftTee;": "⫤", "&DoubleLongLeftArrow;": "⟸", "&DoubleLongLeftRightArrow;": "⟺", "&DoubleLongRightArrow;": "⟹", "&DoubleRightArrow;": "⇒", "&DoubleRightTee;": "⊨", "&DoubleUpArrow;": "⇑", "&DoubleUpDownArrow;": "⇕", "&DoubleVerticalBar;": "∥", "&DownArrow;": "↓", "&DownArrowBar;": "⤓", "&DownArrowUpArrow;": "⇵", "&DownBreve;": "̑", "&DownLeftRightVector;": "⥐", "&DownLeftTeeVector;": "⥞", "&DownLeftVector;": "↽", "&DownLeftVectorBar;": "⥖", "&DownRightTeeVector;": "⥟", "&DownRightVector;": "⇁", "&DownRightVectorBar;": "⥗", "&DownTee;": "⊤", "&DownTeeArrow;": "↧", "&Downarrow;": "⇓", "&Dscr;": "𝒟", "&Dstrok;": "Đ", "&ENG;": "Ŋ", "&ETH": "Ð", "&ETH;": "Ð", "&Eacute": "É", "&Eacute;": "É", "&Ecaron;": "Ě", "&Ecirc": "Ê", "&Ecirc;": "Ê", "&Ecy;": "Э", "&Edot;": "Ė", "&Efr;": "𝔈", "&Egrave": "È", "&Egrave;": "È", "&Element;": "∈", "&Emacr;": "Ē", "&EmptySmallSquare;": "◻", "&EmptyVerySmallSquare;": "▫", "&Eogon;": "Ę", "&Eopf;": "𝔼", "&Epsilon;": "Ε", "&Equal;": "⩵", "&EqualTilde;": "≂", "&Equilibrium;": "⇌", "&Escr;": "ℰ", "&Esim;": "⩳", "&Eta;": "Η", "&Euml": "Ë", "&Euml;": "Ë", "&Exists;": "∃", "&ExponentialE;": "ⅇ", "&Fcy;": "Ф", "&Ffr;": "𝔉", "&FilledSmallSquare;": "◼", "&FilledVerySmallSquare;": "▪", "&Fopf;": "𝔽", "&ForAll;": "∀", "&Fouriertrf;": "ℱ", "&Fscr;": "ℱ", "&GJcy;": "Ѓ", "&GT": ">", "&GT;": ">", "&Gamma;": "Γ", "&Gammad;": "Ϝ", "&Gbreve;": "Ğ", "&Gcedil;": "Ģ", "&Gcirc;": "Ĝ", "&Gcy;": "Г", "&Gdot;": "Ġ", "&Gfr;": "𝔊", "&Gg;": "⋙", "&Gopf;": "𝔾", "&GreaterEqual;": "≥", "&GreaterEqualLess;": "⋛", "&GreaterFullEqual;": "≧", "&GreaterGreater;": "⪢", "&GreaterLess;": "≷", "&GreaterSlantEqual;": "⩾", "&GreaterTilde;": "≳", "&Gscr;": "𝒢", "&Gt;": "≫", "&HARDcy;": "Ъ", "&Hacek;": "ˇ", "&Hat;": "^", "&Hcirc;": "Ĥ", "&Hfr;": "ℌ", "&HilbertSpace;": "ℋ", "&Hopf;": "ℍ", "&HorizontalLine;": "─", "&Hscr;": "ℋ", "&Hstrok;": "Ħ", "&HumpDownHump;": "≎", "&HumpEqual;": "≏", "&IEcy;": "Е", "&IJlig;": "Ĳ", "&IOcy;": "Ё", "&Iacute": "Í", "&Iacute;": "Í", "&Icirc": "Î", "&Icirc;": "Î", "&Icy;": "И", "&Idot;": "İ", "&Ifr;": "ℑ", "&Igrave": "Ì", "&Igrave;": "Ì", "&Im;": "ℑ", "&Imacr;": "Ī", "&ImaginaryI;": "ⅈ", "&Implies;": "⇒", "&Int;": "∬", "&Integral;": "∫", "&Intersection;": "⋂", "&InvisibleComma;": "⁣", "&InvisibleTimes;": "⁢", "&Iogon;": "Į", "&Iopf;": "𝕀", "&Iota;": "Ι", "&Iscr;": "ℐ", "&Itilde;": "Ĩ", "&Iukcy;": "І", "&Iuml": "Ï", "&Iuml;": "Ï", "&Jcirc;": "Ĵ", "&Jcy;": "Й", "&Jfr;": "𝔍", "&Jopf;": "𝕁", "&Jscr;": "𝒥", "&Jsercy;": "Ј", "&Jukcy;": "Є", "&KHcy;": "Х", "&KJcy;": "Ќ", "&Kappa;": "Κ", "&Kcedil;": "Ķ", "&Kcy;": "К", "&Kfr;": "𝔎", "&Kopf;": "𝕂", "&Kscr;": "𝒦", "&LJcy;": "Љ", "&LT": "<", "&LT;": "<", "&Lacute;": "Ĺ", "&Lambda;": "Λ", "&Lang;": "⟪", "&Laplacetrf;": "ℒ", "&Larr;": "↞", "&Lcaron;": "Ľ", "&Lcedil;": "Ļ", "&Lcy;": "Л", "&LeftAngleBracket;": "⟨", "&LeftArrow;": "←", "&LeftArrowBar;": "⇤", "&LeftArrowRightArrow;": "⇆", "&LeftCeiling;": "⌈", "&LeftDoubleBracket;": "⟦", "&LeftDownTeeVector;": "⥡", "&LeftDownVector;": "⇃", "&LeftDownVectorBar;": "⥙", "&LeftFloor;": "⌊", "&LeftRightArrow;": "↔", "&LeftRightVector;": "⥎", "&LeftTee;": "⊣", "&LeftTeeArrow;": "↤", "&LeftTeeVector;": "⥚", "&LeftTriangle;": "⊲", "&LeftTriangleBar;": "⧏", "&LeftTriangleEqual;": "⊴", "&LeftUpDownVector;": "⥑", "&LeftUpTeeVector;": "⥠", "&LeftUpVector;": "↿", "&LeftUpVectorBar;": "⥘", "&LeftVector;": "↼", "&LeftVectorBar;": "⥒", "&Leftarrow;": "⇐", "&Leftrightarrow;": "⇔", "&LessEqualGreater;": "⋚", "&LessFullEqual;": "≦", "&LessGreater;": "≶", "&LessLess;": "⪡", "&LessSlantEqual;": "⩽", "&LessTilde;": "≲", "&Lfr;": "𝔏", "&Ll;": "⋘", "&Lleftarrow;": "⇚", "&Lmidot;": "Ŀ", "&LongLeftArrow;": "⟵", "&LongLeftRightArrow;": "⟷", "&LongRightArrow;": "⟶", "&Longleftarrow;": "⟸", "&Longleftrightarrow;": "⟺", "&Longrightarrow;": "⟹", "&Lopf;": "𝕃", "&LowerLeftArrow;": "↙", "&LowerRightArrow;": "↘", "&Lscr;": "ℒ", "&Lsh;": "↰", "&Lstrok;": "Ł", "&Lt;": "≪", "&Map;": "⤅", "&Mcy;": "М", "&MediumSpace;": " ", "&Mellintrf;": "ℳ", "&Mfr;": "𝔐", "&MinusPlus;": "∓", "&Mopf;": "𝕄", "&Mscr;": "ℳ", "&Mu;": "Μ", "&NJcy;": "Њ", "&Nacute;": "Ń", "&Ncaron;": "Ň", "&Ncedil;": "Ņ", "&Ncy;": "Н", "&NegativeMediumSpace;": "​", "&NegativeThickSpace;": "​", "&NegativeThinSpace;": "​", "&NegativeVeryThinSpace;": "​", "&NestedGreaterGreater;": "≫", "&NestedLessLess;": "≪", "&NewLine;": "\n", "&Nfr;": "𝔑", "&NoBreak;": "⁠", "&NonBreakingSpace;": " ", "&Nopf;": "ℕ", "&Not;": "⫬", "&NotCongruent;": "≢", "&NotCupCap;": "≭", "&NotDoubleVerticalBar;": "∦", "&NotElement;": "∉", "&NotEqual;": "≠", "&NotEqualTilde;": "≂̸", "&NotExists;": "∄", "&NotGreater;": "≯", "&NotGreaterEqual;": "≱", "&NotGreaterFullEqual;": "≧̸", "&NotGreaterGreater;": "≫̸", "&NotGreaterLess;": "≹", "&NotGreaterSlantEqual;": "⩾̸", "&NotGreaterTilde;": "≵", "&NotHumpDownHump;": "≎̸", "&NotHumpEqual;": "≏̸", "&NotLeftTriangle;": "⋪", "&NotLeftTriangleBar;": "⧏̸", "&NotLeftTriangleEqual;": "⋬", "&NotLess;": "≮", "&NotLessEqual;": "≰", "&NotLessGreater;": "≸", "&NotLessLess;": "≪̸", "&NotLessSlantEqual;": "⩽̸", "&NotLessTilde;": "≴", "&NotNestedGreaterGreater;": "⪢̸", "&NotNestedLessLess;": "⪡̸", "&NotPrecedes;": "⊀", "&NotPrecedesEqual;": "⪯̸", "&NotPrecedesSlantEqual;": "⋠", "&NotReverseElement;": "∌", "&NotRightTriangle;": "⋫", "&NotRightTriangleBar;": "⧐̸", "&NotRightTriangleEqual;": "⋭", "&NotSquareSubset;": "⊏̸", "&NotSquareSubsetEqual;": "⋢", "&NotSquareSuperset;": "⊐̸", "&NotSquareSupersetEqual;": "⋣", "&NotSubset;": "⊂⃒", "&NotSubsetEqual;": "⊈", "&NotSucceeds;": "⊁", "&NotSucceedsEqual;": "⪰̸", "&NotSucceedsSlantEqual;": "⋡", "&NotSucceedsTilde;": "≿̸", "&NotSuperset;": "⊃⃒", "&NotSupersetEqual;": "⊉", "&NotTilde;": "≁", "&NotTildeEqual;": "≄", "&NotTildeFullEqual;": "≇", "&NotTildeTilde;": "≉", "&NotVerticalBar;": "∤", "&Nscr;": "𝒩", "&Ntilde": "Ñ", "&Ntilde;": "Ñ", "&Nu;": "Ν", "&OElig;": "Œ", "&Oacute": "Ó", "&Oacute;": "Ó", "&Ocirc": "Ô", "&Ocirc;": "Ô", "&Ocy;": "О", "&Odblac;": "Ő", "&Ofr;": "𝔒", "&Ograve": "Ò", "&Ograve;": "Ò", "&Omacr;": "Ō", "&Omega;": "Ω", "&Omicron;": "Ο", "&Oopf;": "𝕆", "&OpenCurlyDoubleQuote;": "“", "&OpenCurlyQuote;": "‘", "&Or;": "⩔", "&Oscr;": "𝒪", "&Oslash": "Ø", "&Oslash;": "Ø", "&Otilde": "Õ", "&Otilde;": "Õ", "&Otimes;": "⨷", "&Ouml": "Ö", "&Ouml;": "Ö", "&OverBar;": "‾", "&OverBrace;": "⏞", "&OverBracket;": "⎴", "&OverParenthesis;": "⏜", "&PartialD;": "∂", "&Pcy;": "П", "&Pfr;": "𝔓", "&Phi;": "Φ", "&Pi;": "Π", "&PlusMinus;": "±", "&Poincareplane;": "ℌ", "&Popf;": "ℙ", "&Pr;": "⪻", "&Precedes;": "≺", "&PrecedesEqual;": "⪯", "&PrecedesSlantEqual;": "≼", "&PrecedesTilde;": "≾", "&Prime;": "″", "&Product;": "∏", "&Proportion;": "∷", "&Proportional;": "∝", "&Pscr;": "𝒫", "&Psi;": "Ψ", "&QUOT": '"', "&QUOT;": '"', "&Qfr;": "𝔔", "&Qopf;": "ℚ", "&Qscr;": "𝒬", "&RBarr;": "⤐", "&REG": "®", "&REG;": "®", "&Racute;": "Ŕ", "&Rang;": "⟫", "&Rarr;": "↠", "&Rarrtl;": "⤖", "&Rcaron;": "Ř", "&Rcedil;": "Ŗ", "&Rcy;": "Р", "&Re;": "ℜ", "&ReverseElement;": "∋", "&ReverseEquilibrium;": "⇋", "&ReverseUpEquilibrium;": "⥯", "&Rfr;": "ℜ", "&Rho;": "Ρ", "&RightAngleBracket;": "⟩", "&RightArrow;": "→", "&RightArrowBar;": "⇥", "&RightArrowLeftArrow;": "⇄", "&RightCeiling;": "⌉", "&RightDoubleBracket;": "⟧", "&RightDownTeeVector;": "⥝", "&RightDownVector;": "⇂", "&RightDownVectorBar;": "⥕", "&RightFloor;": "⌋", "&RightTee;": "⊢", "&RightTeeArrow;": "↦", "&RightTeeVector;": "⥛", "&RightTriangle;": "⊳", "&RightTriangleBar;": "⧐", "&RightTriangleEqual;": "⊵", "&RightUpDownVector;": "⥏", "&RightUpTeeVector;": "⥜", "&RightUpVector;": "↾", "&RightUpVectorBar;": "⥔", "&RightVector;": "⇀", "&RightVectorBar;": "⥓", "&Rightarrow;": "⇒", "&Ropf;": "ℝ", "&RoundImplies;": "⥰", "&Rrightarrow;": "⇛", "&Rscr;": "ℛ", "&Rsh;": "↱", "&RuleDelayed;": "⧴", "&SHCHcy;": "Щ", "&SHcy;": "Ш", "&SOFTcy;": "Ь", "&Sacute;": "Ś", "&Sc;": "⪼", "&Scaron;": "Š", "&Scedil;": "Ş", "&Scirc;": "Ŝ", "&Scy;": "С", "&Sfr;": "𝔖", "&ShortDownArrow;": "↓", "&ShortLeftArrow;": "←", "&ShortRightArrow;": "→", "&ShortUpArrow;": "↑", "&Sigma;": "Σ", "&SmallCircle;": "∘", "&Sopf;": "𝕊", "&Sqrt;": "√", "&Square;": "□", "&SquareIntersection;": "⊓", "&SquareSubset;": "⊏", "&SquareSubsetEqual;": "⊑", "&SquareSuperset;": "⊐", "&SquareSupersetEqual;": "⊒", "&SquareUnion;": "⊔", "&Sscr;": "𝒮", "&Star;": "⋆", "&Sub;": "⋐", "&Subset;": "⋐", "&SubsetEqual;": "⊆", "&Succeeds;": "≻", "&SucceedsEqual;": "⪰", "&SucceedsSlantEqual;": "≽", "&SucceedsTilde;": "≿", "&SuchThat;": "∋", "&Sum;": "∑", "&Sup;": "⋑", "&Superset;": "⊃", "&SupersetEqual;": "⊇", "&Supset;": "⋑", "&THORN": "Þ", "&THORN;": "Þ", "&TRADE;": "™", "&TSHcy;": "Ћ", "&TScy;": "Ц", "&Tab;": "	", "&Tau;": "Τ", "&Tcaron;": "Ť", "&Tcedil;": "Ţ", "&Tcy;": "Т", "&Tfr;": "𝔗", "&Therefore;": "∴", "&Theta;": "Θ", "&ThickSpace;": "  ", "&ThinSpace;": " ", "&Tilde;": "∼", "&TildeEqual;": "≃", "&TildeFullEqual;": "≅", "&TildeTilde;": "≈", "&Topf;": "𝕋", "&TripleDot;": "⃛", "&Tscr;": "𝒯", "&Tstrok;": "Ŧ", "&Uacute": "Ú", "&Uacute;": "Ú", "&Uarr;": "↟", "&Uarrocir;": "⥉", "&Ubrcy;": "Ў", "&Ubreve;": "Ŭ", "&Ucirc": "Û", "&Ucirc;": "Û", "&Ucy;": "У", "&Udblac;": "Ű", "&Ufr;": "𝔘", "&Ugrave": "Ù", "&Ugrave;": "Ù", "&Umacr;": "Ū", "&UnderBar;": "_", "&UnderBrace;": "⏟", "&UnderBracket;": "⎵", "&UnderParenthesis;": "⏝", "&Union;": "⋃", "&UnionPlus;": "⊎", "&Uogon;": "Ų", "&Uopf;": "𝕌", "&UpArrow;": "↑", "&UpArrowBar;": "⤒", "&UpArrowDownArrow;": "⇅", "&UpDownArrow;": "↕", "&UpEquilibrium;": "⥮", "&UpTee;": "⊥", "&UpTeeArrow;": "↥", "&Uparrow;": "⇑", "&Updownarrow;": "⇕", "&UpperLeftArrow;": "↖", "&UpperRightArrow;": "↗", "&Upsi;": "ϒ", "&Upsilon;": "Υ", "&Uring;": "Ů", "&Uscr;": "𝒰", "&Utilde;": "Ũ", "&Uuml": "Ü", "&Uuml;": "Ü", "&VDash;": "⊫", "&Vbar;": "⫫", "&Vcy;": "В", "&Vdash;": "⊩", "&Vdashl;": "⫦", "&Vee;": "⋁", "&Verbar;": "‖", "&Vert;": "‖", "&VerticalBar;": "∣", "&VerticalLine;": "|", "&VerticalSeparator;": "❘", "&VerticalTilde;": "≀", "&VeryThinSpace;": " ", "&Vfr;": "𝔙", "&Vopf;": "𝕍", "&Vscr;": "𝒱", "&Vvdash;": "⊪", "&Wcirc;": "Ŵ", "&Wedge;": "⋀", "&Wfr;": "𝔚", "&Wopf;": "𝕎", "&Wscr;": "𝒲", "&Xfr;": "𝔛", "&Xi;": "Ξ", "&Xopf;": "𝕏", "&Xscr;": "𝒳", "&YAcy;": "Я", "&YIcy;": "Ї", "&YUcy;": "Ю", "&Yacute": "Ý", "&Yacute;": "Ý", "&Ycirc;": "Ŷ", "&Ycy;": "Ы", "&Yfr;": "𝔜", "&Yopf;": "𝕐", "&Yscr;": "𝒴", "&Yuml;": "Ÿ", "&ZHcy;": "Ж", "&Zacute;": "Ź", "&Zcaron;": "Ž", "&Zcy;": "З", "&Zdot;": "Ż", "&ZeroWidthSpace;": "​", "&Zeta;": "Ζ", "&Zfr;": "ℨ", "&Zopf;": "ℤ", "&Zscr;": "𝒵", "&aacute": "á", "&aacute;": "á", "&abreve;": "ă", "&ac;": "∾", "&acE;": "∾̳", "&acd;": "∿", "&acirc": "â", "&acirc;": "â", "&acute": "´", "&acute;": "´", "&acy;": "а", "&aelig": "æ", "&aelig;": "æ", "&af;": "⁡", "&afr;": "𝔞", "&agrave": "à", "&agrave;": "à", "&alefsym;": "ℵ", "&aleph;": "ℵ", "&alpha;": "α", "&amacr;": "ā", "&amalg;": "⨿", "&amp": "&", "&amp;": "&", "&and;": "∧", "&andand;": "⩕", "&andd;": "⩜", "&andslope;": "⩘", "&andv;": "⩚", "&ang;": "∠", "&ange;": "⦤", "&angle;": "∠", "&angmsd;": "∡", "&angmsdaa;": "⦨", "&angmsdab;": "⦩", "&angmsdac;": "⦪", "&angmsdad;": "⦫", "&angmsdae;": "⦬", "&angmsdaf;": "⦭", "&angmsdag;": "⦮", "&angmsdah;": "⦯", "&angrt;": "∟", "&angrtvb;": "⊾", "&angrtvbd;": "⦝", "&angsph;": "∢", "&angst;": "Å", "&angzarr;": "⍼", "&aogon;": "ą", "&aopf;": "𝕒", "&ap;": "≈", "&apE;": "⩰", "&apacir;": "⩯", "&ape;": "≊", "&apid;": "≋", "&apos;": "'", "&approx;": "≈", "&approxeq;": "≊", "&aring": "å", "&aring;": "å", "&ascr;": "𝒶", "&ast;": "*", "&asymp;": "≈", "&asympeq;": "≍", "&atilde": "ã", "&atilde;": "ã", "&auml": "ä", "&auml;": "ä", "&awconint;": "∳", "&awint;": "⨑", "&bNot;": "⫭", "&backcong;": "≌", "&backepsilon;": "϶", "&backprime;": "‵", "&backsim;": "∽", "&backsimeq;": "⋍", "&barvee;": "⊽", "&barwed;": "⌅", "&barwedge;": "⌅", "&bbrk;": "⎵", "&bbrktbrk;": "⎶", "&bcong;": "≌", "&bcy;": "б", "&bdquo;": "„", "&becaus;": "∵", "&because;": "∵", "&bemptyv;": "⦰", "&bepsi;": "϶", "&bernou;": "ℬ", "&beta;": "β", "&beth;": "ℶ", "&between;": "≬", "&bfr;": "𝔟", "&bigcap;": "⋂", "&bigcirc;": "◯", "&bigcup;": "⋃", "&bigodot;": "⨀", "&bigoplus;": "⨁", "&bigotimes;": "⨂", "&bigsqcup;": "⨆", "&bigstar;": "★", "&bigtriangledown;": "▽", "&bigtriangleup;": "△", "&biguplus;": "⨄", "&bigvee;": "⋁", "&bigwedge;": "⋀", "&bkarow;": "⤍", "&blacklozenge;": "⧫", "&blacksquare;": "▪", "&blacktriangle;": "▴", "&blacktriangledown;": "▾", "&blacktriangleleft;": "◂", "&blacktriangleright;": "▸", "&blank;": "␣", "&blk12;": "▒", "&blk14;": "░", "&blk34;": "▓", "&block;": "█", "&bne;": "=⃥", "&bnequiv;": "≡⃥", "&bnot;": "⌐", "&bopf;": "𝕓", "&bot;": "⊥", "&bottom;": "⊥", "&bowtie;": "⋈", "&boxDL;": "╗", "&boxDR;": "╔", "&boxDl;": "╖", "&boxDr;": "╓", "&boxH;": "═", "&boxHD;": "╦", "&boxHU;": "╩", "&boxHd;": "╤", "&boxHu;": "╧", "&boxUL;": "╝", "&boxUR;": "╚", "&boxUl;": "╜", "&boxUr;": "╙", "&boxV;": "║", "&boxVH;": "╬", "&boxVL;": "╣", "&boxVR;": "╠", "&boxVh;": "╫", "&boxVl;": "╢", "&boxVr;": "╟", "&boxbox;": "⧉", "&boxdL;": "╕", "&boxdR;": "╒", "&boxdl;": "┐", "&boxdr;": "┌", "&boxh;": "─", "&boxhD;": "╥", "&boxhU;": "╨", "&boxhd;": "┬", "&boxhu;": "┴", "&boxminus;": "⊟", "&boxplus;": "⊞", "&boxtimes;": "⊠", "&boxuL;": "╛", "&boxuR;": "╘", "&boxul;": "┘", "&boxur;": "└", "&boxv;": "│", "&boxvH;": "╪", "&boxvL;": "╡", "&boxvR;": "╞", "&boxvh;": "┼", "&boxvl;": "┤", "&boxvr;": "├", "&bprime;": "‵", "&breve;": "˘", "&brvbar": "¦", "&brvbar;": "¦", "&bscr;": "𝒷", "&bsemi;": "⁏", "&bsim;": "∽", "&bsime;": "⋍", "&bsol;": "\\", "&bsolb;": "⧅", "&bsolhsub;": "⟈", "&bull;": "•", "&bullet;": "•", "&bump;": "≎", "&bumpE;": "⪮", "&bumpe;": "≏", "&bumpeq;": "≏", "&cacute;": "ć", "&cap;": "∩", "&capand;": "⩄", "&capbrcup;": "⩉", "&capcap;": "⩋", "&capcup;": "⩇", "&capdot;": "⩀", "&caps;": "∩︀", "&caret;": "⁁", "&caron;": "ˇ", "&ccaps;": "⩍", "&ccaron;": "č", "&ccedil": "ç", "&ccedil;": "ç", "&ccirc;": "ĉ", "&ccups;": "⩌", "&ccupssm;": "⩐", "&cdot;": "ċ", "&cedil": "¸", "&cedil;": "¸", "&cemptyv;": "⦲", "&cent": "¢", "&cent;": "¢", "&centerdot;": "·", "&cfr;": "𝔠", "&chcy;": "ч", "&check;": "✓", "&checkmark;": "✓", "&chi;": "χ", "&cir;": "○", "&cirE;": "⧃", "&circ;": "ˆ", "&circeq;": "≗", "&circlearrowleft;": "↺", "&circlearrowright;": "↻", "&circledR;": "®", "&circledS;": "Ⓢ", "&circledast;": "⊛", "&circledcirc;": "⊚", "&circleddash;": "⊝", "&cire;": "≗", "&cirfnint;": "⨐", "&cirmid;": "⫯", "&cirscir;": "⧂", "&clubs;": "♣", "&clubsuit;": "♣", "&colon;": ":", "&colone;": "≔", "&coloneq;": "≔", "&comma;": ",", "&commat;": "@", "&comp;": "∁", "&compfn;": "∘", "&complement;": "∁", "&complexes;": "ℂ", "&cong;": "≅", "&congdot;": "⩭", "&conint;": "∮", "&copf;": "𝕔", "&coprod;": "∐", "&copy": "©", "&copy;": "©", "&copysr;": "℗", "&crarr;": "↵", "&cross;": "✗", "&cscr;": "𝒸", "&csub;": "⫏", "&csube;": "⫑", "&csup;": "⫐", "&csupe;": "⫒", "&ctdot;": "⋯", "&cudarrl;": "⤸", "&cudarrr;": "⤵", "&cuepr;": "⋞", "&cuesc;": "⋟", "&cularr;": "↶", "&cularrp;": "⤽", "&cup;": "∪", "&cupbrcap;": "⩈", "&cupcap;": "⩆", "&cupcup;": "⩊", "&cupdot;": "⊍", "&cupor;": "⩅", "&cups;": "∪︀", "&curarr;": "↷", "&curarrm;": "⤼", "&curlyeqprec;": "⋞", "&curlyeqsucc;": "⋟", "&curlyvee;": "⋎", "&curlywedge;": "⋏", "&curren": "¤", "&curren;": "¤", "&curvearrowleft;": "↶", "&curvearrowright;": "↷", "&cuvee;": "⋎", "&cuwed;": "⋏", "&cwconint;": "∲", "&cwint;": "∱", "&cylcty;": "⌭", "&dArr;": "⇓", "&dHar;": "⥥", "&dagger;": "†", "&daleth;": "ℸ", "&darr;": "↓", "&dash;": "‐", "&dashv;": "⊣", "&dbkarow;": "⤏", "&dblac;": "˝", "&dcaron;": "ď", "&dcy;": "д", "&dd;": "ⅆ", "&ddagger;": "‡", "&ddarr;": "⇊", "&ddotseq;": "⩷", "&deg": "°", "&deg;": "°", "&delta;": "δ", "&demptyv;": "⦱", "&dfisht;": "⥿", "&dfr;": "𝔡", "&dharl;": "⇃", "&dharr;": "⇂", "&diam;": "⋄", "&diamond;": "⋄", "&diamondsuit;": "♦", "&diams;": "♦", "&die;": "¨", "&digamma;": "ϝ", "&disin;": "⋲", "&div;": "÷", "&divide": "÷", "&divide;": "÷", "&divideontimes;": "⋇", "&divonx;": "⋇", "&djcy;": "ђ", "&dlcorn;": "⌞", "&dlcrop;": "⌍", "&dollar;": "$", "&dopf;": "𝕕", "&dot;": "˙", "&doteq;": "≐", "&doteqdot;": "≑", "&dotminus;": "∸", "&dotplus;": "∔", "&dotsquare;": "⊡", "&doublebarwedge;": "⌆", "&downarrow;": "↓", "&downdownarrows;": "⇊", "&downharpoonleft;": "⇃", "&downharpoonright;": "⇂", "&drbkarow;": "⤐", "&drcorn;": "⌟", "&drcrop;": "⌌", "&dscr;": "𝒹", "&dscy;": "ѕ", "&dsol;": "⧶", "&dstrok;": "đ", "&dtdot;": "⋱", "&dtri;": "▿", "&dtrif;": "▾", "&duarr;": "⇵", "&duhar;": "⥯", "&dwangle;": "⦦", "&dzcy;": "џ", "&dzigrarr;": "⟿", "&eDDot;": "⩷", "&eDot;": "≑", "&eacute": "é", "&eacute;": "é", "&easter;": "⩮", "&ecaron;": "ě", "&ecir;": "≖", "&ecirc": "ê", "&ecirc;": "ê", "&ecolon;": "≕", "&ecy;": "э", "&edot;": "ė", "&ee;": "ⅇ", "&efDot;": "≒", "&efr;": "𝔢", "&eg;": "⪚", "&egrave": "è", "&egrave;": "è", "&egs;": "⪖", "&egsdot;": "⪘", "&el;": "⪙", "&elinters;": "⏧", "&ell;": "ℓ", "&els;": "⪕", "&elsdot;": "⪗", "&emacr;": "ē", "&empty;": "∅", "&emptyset;": "∅", "&emptyv;": "∅", "&emsp13;": " ", "&emsp14;": " ", "&emsp;": " ", "&eng;": "ŋ", "&ensp;": " ", "&eogon;": "ę", "&eopf;": "𝕖", "&epar;": "⋕", "&eparsl;": "⧣", "&eplus;": "⩱", "&epsi;": "ε", "&epsilon;": "ε", "&epsiv;": "ϵ", "&eqcirc;": "≖", "&eqcolon;": "≕", "&eqsim;": "≂", "&eqslantgtr;": "⪖", "&eqslantless;": "⪕", "&equals;": "=", "&equest;": "≟", "&equiv;": "≡", "&equivDD;": "⩸", "&eqvparsl;": "⧥", "&erDot;": "≓", "&erarr;": "⥱", "&escr;": "ℯ", "&esdot;": "≐", "&esim;": "≂", "&eta;": "η", "&eth": "ð", "&eth;": "ð", "&euml": "ë", "&euml;": "ë", "&euro;": "€", "&excl;": "!", "&exist;": "∃", "&expectation;": "ℰ", "&exponentiale;": "ⅇ", "&fallingdotseq;": "≒", "&fcy;": "ф", "&female;": "♀", "&ffilig;": "ﬃ", "&fflig;": "ﬀ", "&ffllig;": "ﬄ", "&ffr;": "𝔣", "&filig;": "ﬁ", "&fjlig;": "fj", "&flat;": "♭", "&fllig;": "ﬂ", "&fltns;": "▱", "&fnof;": "ƒ", "&fopf;": "𝕗", "&forall;": "∀", "&fork;": "⋔", "&forkv;": "⫙", "&fpartint;": "⨍", "&frac12": "½", "&frac12;": "½", "&frac13;": "⅓", "&frac14": "¼", "&frac14;": "¼", "&frac15;": "⅕", "&frac16;": "⅙", "&frac18;": "⅛", "&frac23;": "⅔", "&frac25;": "⅖", "&frac34": "¾", "&frac34;": "¾", "&frac35;": "⅗", "&frac38;": "⅜", "&frac45;": "⅘", "&frac56;": "⅚", "&frac58;": "⅝", "&frac78;": "⅞", "&frasl;": "⁄", "&frown;": "⌢", "&fscr;": "𝒻", "&gE;": "≧", "&gEl;": "⪌", "&gacute;": "ǵ", "&gamma;": "γ", "&gammad;": "ϝ", "&gap;": "⪆", "&gbreve;": "ğ", "&gcirc;": "ĝ", "&gcy;": "г", "&gdot;": "ġ", "&ge;": "≥", "&gel;": "⋛", "&geq;": "≥", "&geqq;": "≧", "&geqslant;": "⩾", "&ges;": "⩾", "&gescc;": "⪩", "&gesdot;": "⪀", "&gesdoto;": "⪂", "&gesdotol;": "⪄", "&gesl;": "⋛︀", "&gesles;": "⪔", "&gfr;": "𝔤", "&gg;": "≫", "&ggg;": "⋙", "&gimel;": "ℷ", "&gjcy;": "ѓ", "&gl;": "≷", "&glE;": "⪒", "&gla;": "⪥", "&glj;": "⪤", "&gnE;": "≩", "&gnap;": "⪊", "&gnapprox;": "⪊", "&gne;": "⪈", "&gneq;": "⪈", "&gneqq;": "≩", "&gnsim;": "⋧", "&gopf;": "𝕘", "&grave;": "`", "&gscr;": "ℊ", "&gsim;": "≳", "&gsime;": "⪎", "&gsiml;": "⪐", "&gt": ">", "&gt;": ">", "&gtcc;": "⪧", "&gtcir;": "⩺", "&gtdot;": "⋗", "&gtlPar;": "⦕", "&gtquest;": "⩼", "&gtrapprox;": "⪆", "&gtrarr;": "⥸", "&gtrdot;": "⋗", "&gtreqless;": "⋛", "&gtreqqless;": "⪌", "&gtrless;": "≷", "&gtrsim;": "≳", "&gvertneqq;": "≩︀", "&gvnE;": "≩︀", "&hArr;": "⇔", "&hairsp;": " ", "&half;": "½", "&hamilt;": "ℋ", "&hardcy;": "ъ", "&harr;": "↔", "&harrcir;": "⥈", "&harrw;": "↭", "&hbar;": "ℏ", "&hcirc;": "ĥ", "&hearts;": "♥", "&heartsuit;": "♥", "&hellip;": "…", "&hercon;": "⊹", "&hfr;": "𝔥", "&hksearow;": "⤥", "&hkswarow;": "⤦", "&hoarr;": "⇿", "&homtht;": "∻", "&hookleftarrow;": "↩", "&hookrightarrow;": "↪", "&hopf;": "𝕙", "&horbar;": "―", "&hscr;": "𝒽", "&hslash;": "ℏ", "&hstrok;": "ħ", "&hybull;": "⁃", "&hyphen;": "‐", "&iacute": "í", "&iacute;": "í", "&ic;": "⁣", "&icirc": "î", "&icirc;": "î", "&icy;": "и", "&iecy;": "е", "&iexcl": "¡", "&iexcl;": "¡", "&iff;": "⇔", "&ifr;": "𝔦", "&igrave": "ì", "&igrave;": "ì", "&ii;": "ⅈ", "&iiiint;": "⨌", "&iiint;": "∭", "&iinfin;": "⧜", "&iiota;": "℩", "&ijlig;": "ĳ", "&imacr;": "ī", "&image;": "ℑ", "&imagline;": "ℐ", "&imagpart;": "ℑ", "&imath;": "ı", "&imof;": "⊷", "&imped;": "Ƶ", "&in;": "∈", "&incare;": "℅", "&infin;": "∞", "&infintie;": "⧝", "&inodot;": "ı", "&int;": "∫", "&intcal;": "⊺", "&integers;": "ℤ", "&intercal;": "⊺", "&intlarhk;": "⨗", "&intprod;": "⨼", "&iocy;": "ё", "&iogon;": "į", "&iopf;": "𝕚", "&iota;": "ι", "&iprod;": "⨼", "&iquest": "¿", "&iquest;": "¿", "&iscr;": "𝒾", "&isin;": "∈", "&isinE;": "⋹", "&isindot;": "⋵", "&isins;": "⋴", "&isinsv;": "⋳", "&isinv;": "∈", "&it;": "⁢", "&itilde;": "ĩ", "&iukcy;": "і", "&iuml": "ï", "&iuml;": "ï", "&jcirc;": "ĵ", "&jcy;": "й", "&jfr;": "𝔧", "&jmath;": "ȷ", "&jopf;": "𝕛", "&jscr;": "𝒿", "&jsercy;": "ј", "&jukcy;": "є", "&kappa;": "κ", "&kappav;": "ϰ", "&kcedil;": "ķ", "&kcy;": "к", "&kfr;": "𝔨", "&kgreen;": "ĸ", "&khcy;": "х", "&kjcy;": "ќ", "&kopf;": "𝕜", "&kscr;": "𝓀", "&lAarr;": "⇚", "&lArr;": "⇐", "&lAtail;": "⤛", "&lBarr;": "⤎", "&lE;": "≦", "&lEg;": "⪋", "&lHar;": "⥢", "&lacute;": "ĺ", "&laemptyv;": "⦴", "&lagran;": "ℒ", "&lambda;": "λ", "&lang;": "⟨", "&langd;": "⦑", "&langle;": "⟨", "&lap;": "⪅", "&laquo": "«", "&laquo;": "«", "&larr;": "←", "&larrb;": "⇤", "&larrbfs;": "⤟", "&larrfs;": "⤝", "&larrhk;": "↩", "&larrlp;": "↫", "&larrpl;": "⤹", "&larrsim;": "⥳", "&larrtl;": "↢", "&lat;": "⪫", "&latail;": "⤙", "&late;": "⪭", "&lates;": "⪭︀", "&lbarr;": "⤌", "&lbbrk;": "❲", "&lbrace;": "{", "&lbrack;": "[", "&lbrke;": "⦋", "&lbrksld;": "⦏", "&lbrkslu;": "⦍", "&lcaron;": "ľ", "&lcedil;": "ļ", "&lceil;": "⌈", "&lcub;": "{", "&lcy;": "л", "&ldca;": "⤶", "&ldquo;": "“", "&ldquor;": "„", "&ldrdhar;": "⥧", "&ldrushar;": "⥋", "&ldsh;": "↲", "&le;": "≤", "&leftarrow;": "←", "&leftarrowtail;": "↢", "&leftharpoondown;": "↽", "&leftharpoonup;": "↼", "&leftleftarrows;": "⇇", "&leftrightarrow;": "↔", "&leftrightarrows;": "⇆", "&leftrightharpoons;": "⇋", "&leftrightsquigarrow;": "↭", "&leftthreetimes;": "⋋", "&leg;": "⋚", "&leq;": "≤", "&leqq;": "≦", "&leqslant;": "⩽", "&les;": "⩽", "&lescc;": "⪨", "&lesdot;": "⩿", "&lesdoto;": "⪁", "&lesdotor;": "⪃", "&lesg;": "⋚︀", "&lesges;": "⪓", "&lessapprox;": "⪅", "&lessdot;": "⋖", "&lesseqgtr;": "⋚", "&lesseqqgtr;": "⪋", "&lessgtr;": "≶", "&lesssim;": "≲", "&lfisht;": "⥼", "&lfloor;": "⌊", "&lfr;": "𝔩", "&lg;": "≶", "&lgE;": "⪑", "&lhard;": "↽", "&lharu;": "↼", "&lharul;": "⥪", "&lhblk;": "▄", "&ljcy;": "љ", "&ll;": "≪", "&llarr;": "⇇", "&llcorner;": "⌞", "&llhard;": "⥫", "&lltri;": "◺", "&lmidot;": "ŀ", "&lmoust;": "⎰", "&lmoustache;": "⎰", "&lnE;": "≨", "&lnap;": "⪉", "&lnapprox;": "⪉", "&lne;": "⪇", "&lneq;": "⪇", "&lneqq;": "≨", "&lnsim;": "⋦", "&loang;": "⟬", "&loarr;": "⇽", "&lobrk;": "⟦", "&longleftarrow;": "⟵", "&longleftrightarrow;": "⟷", "&longmapsto;": "⟼", "&longrightarrow;": "⟶", "&looparrowleft;": "↫", "&looparrowright;": "↬", "&lopar;": "⦅", "&lopf;": "𝕝", "&loplus;": "⨭", "&lotimes;": "⨴", "&lowast;": "∗", "&lowbar;": "_", "&loz;": "◊", "&lozenge;": "◊", "&lozf;": "⧫", "&lpar;": "(", "&lparlt;": "⦓", "&lrarr;": "⇆", "&lrcorner;": "⌟", "&lrhar;": "⇋", "&lrhard;": "⥭", "&lrm;": "‎", "&lrtri;": "⊿", "&lsaquo;": "‹", "&lscr;": "𝓁", "&lsh;": "↰", "&lsim;": "≲", "&lsime;": "⪍", "&lsimg;": "⪏", "&lsqb;": "[", "&lsquo;": "‘", "&lsquor;": "‚", "&lstrok;": "ł", "&lt": "<", "&lt;": "<", "&ltcc;": "⪦", "&ltcir;": "⩹", "&ltdot;": "⋖", "&lthree;": "⋋", "&ltimes;": "⋉", "&ltlarr;": "⥶", "&ltquest;": "⩻", "&ltrPar;": "⦖", "&ltri;": "◃", "&ltrie;": "⊴", "&ltrif;": "◂", "&lurdshar;": "⥊", "&luruhar;": "⥦", "&lvertneqq;": "≨︀", "&lvnE;": "≨︀", "&mDDot;": "∺", "&macr": "¯", "&macr;": "¯", "&male;": "♂", "&malt;": "✠", "&maltese;": "✠", "&map;": "↦", "&mapsto;": "↦", "&mapstodown;": "↧", "&mapstoleft;": "↤", "&mapstoup;": "↥", "&marker;": "▮", "&mcomma;": "⨩", "&mcy;": "м", "&mdash;": "—", "&measuredangle;": "∡", "&mfr;": "𝔪", "&mho;": "℧", "&micro": "µ", "&micro;": "µ", "&mid;": "∣", "&midast;": "*", "&midcir;": "⫰", "&middot": "·", "&middot;": "·", "&minus;": "−", "&minusb;": "⊟", "&minusd;": "∸", "&minusdu;": "⨪", "&mlcp;": "⫛", "&mldr;": "…", "&mnplus;": "∓", "&models;": "⊧", "&mopf;": "𝕞", "&mp;": "∓", "&mscr;": "𝓂", "&mstpos;": "∾", "&mu;": "μ", "&multimap;": "⊸", "&mumap;": "⊸", "&nGg;": "⋙̸", "&nGt;": "≫⃒", "&nGtv;": "≫̸", "&nLeftarrow;": "⇍", "&nLeftrightarrow;": "⇎", "&nLl;": "⋘̸", "&nLt;": "≪⃒", "&nLtv;": "≪̸", "&nRightarrow;": "⇏", "&nVDash;": "⊯", "&nVdash;": "⊮", "&nabla;": "∇", "&nacute;": "ń", "&nang;": "∠⃒", "&nap;": "≉", "&napE;": "⩰̸", "&napid;": "≋̸", "&napos;": "ŉ", "&napprox;": "≉", "&natur;": "♮", "&natural;": "♮", "&naturals;": "ℕ", "&nbsp": " ", "&nbsp;": " ", "&nbump;": "≎̸", "&nbumpe;": "≏̸", "&ncap;": "⩃", "&ncaron;": "ň", "&ncedil;": "ņ", "&ncong;": "≇", "&ncongdot;": "⩭̸", "&ncup;": "⩂", "&ncy;": "н", "&ndash;": "–", "&ne;": "≠", "&neArr;": "⇗", "&nearhk;": "⤤", "&nearr;": "↗", "&nearrow;": "↗", "&nedot;": "≐̸", "&nequiv;": "≢", "&nesear;": "⤨", "&nesim;": "≂̸", "&nexist;": "∄", "&nexists;": "∄", "&nfr;": "𝔫", "&ngE;": "≧̸", "&nge;": "≱", "&ngeq;": "≱", "&ngeqq;": "≧̸", "&ngeqslant;": "⩾̸", "&nges;": "⩾̸", "&ngsim;": "≵", "&ngt;": "≯", "&ngtr;": "≯", "&nhArr;": "⇎", "&nharr;": "↮", "&nhpar;": "⫲", "&ni;": "∋", "&nis;": "⋼", "&nisd;": "⋺", "&niv;": "∋", "&njcy;": "њ", "&nlArr;": "⇍", "&nlE;": "≦̸", "&nlarr;": "↚", "&nldr;": "‥", "&nle;": "≰", "&nleftarrow;": "↚", "&nleftrightarrow;": "↮", "&nleq;": "≰", "&nleqq;": "≦̸", "&nleqslant;": "⩽̸", "&nles;": "⩽̸", "&nless;": "≮", "&nlsim;": "≴", "&nlt;": "≮", "&nltri;": "⋪", "&nltrie;": "⋬", "&nmid;": "∤", "&nopf;": "𝕟", "&not": "¬", "&not;": "¬", "&notin;": "∉", "&notinE;": "⋹̸", "&notindot;": "⋵̸", "&notinva;": "∉", "&notinvb;": "⋷", "&notinvc;": "⋶", "&notni;": "∌", "&notniva;": "∌", "&notnivb;": "⋾", "&notnivc;": "⋽", "&npar;": "∦", "&nparallel;": "∦", "&nparsl;": "⫽⃥", "&npart;": "∂̸", "&npolint;": "⨔", "&npr;": "⊀", "&nprcue;": "⋠", "&npre;": "⪯̸", "&nprec;": "⊀", "&npreceq;": "⪯̸", "&nrArr;": "⇏", "&nrarr;": "↛", "&nrarrc;": "⤳̸", "&nrarrw;": "↝̸", "&nrightarrow;": "↛", "&nrtri;": "⋫", "&nrtrie;": "⋭", "&nsc;": "⊁", "&nsccue;": "⋡", "&nsce;": "⪰̸", "&nscr;": "𝓃", "&nshortmid;": "∤", "&nshortparallel;": "∦", "&nsim;": "≁", "&nsime;": "≄", "&nsimeq;": "≄", "&nsmid;": "∤", "&nspar;": "∦", "&nsqsube;": "⋢", "&nsqsupe;": "⋣", "&nsub;": "⊄", "&nsubE;": "⫅̸", "&nsube;": "⊈", "&nsubset;": "⊂⃒", "&nsubseteq;": "⊈", "&nsubseteqq;": "⫅̸", "&nsucc;": "⊁", "&nsucceq;": "⪰̸", "&nsup;": "⊅", "&nsupE;": "⫆̸", "&nsupe;": "⊉", "&nsupset;": "⊃⃒", "&nsupseteq;": "⊉", "&nsupseteqq;": "⫆̸", "&ntgl;": "≹", "&ntilde": "ñ", "&ntilde;": "ñ", "&ntlg;": "≸", "&ntriangleleft;": "⋪", "&ntrianglelefteq;": "⋬", "&ntriangleright;": "⋫", "&ntrianglerighteq;": "⋭", "&nu;": "ν", "&num;": "#", "&numero;": "№", "&numsp;": " ", "&nvDash;": "⊭", "&nvHarr;": "⤄", "&nvap;": "≍⃒", "&nvdash;": "⊬", "&nvge;": "≥⃒", "&nvgt;": ">⃒", "&nvinfin;": "⧞", "&nvlArr;": "⤂", "&nvle;": "≤⃒", "&nvlt;": "<⃒", "&nvltrie;": "⊴⃒", "&nvrArr;": "⤃", "&nvrtrie;": "⊵⃒", "&nvsim;": "∼⃒", "&nwArr;": "⇖", "&nwarhk;": "⤣", "&nwarr;": "↖", "&nwarrow;": "↖", "&nwnear;": "⤧", "&oS;": "Ⓢ", "&oacute": "ó", "&oacute;": "ó", "&oast;": "⊛", "&ocir;": "⊚", "&ocirc": "ô", "&ocirc;": "ô", "&ocy;": "о", "&odash;": "⊝", "&odblac;": "ő", "&odiv;": "⨸", "&odot;": "⊙", "&odsold;": "⦼", "&oelig;": "œ", "&ofcir;": "⦿", "&ofr;": "𝔬", "&ogon;": "˛", "&ograve": "ò", "&ograve;": "ò", "&ogt;": "⧁", "&ohbar;": "⦵", "&ohm;": "Ω", "&oint;": "∮", "&olarr;": "↺", "&olcir;": "⦾", "&olcross;": "⦻", "&oline;": "‾", "&olt;": "⧀", "&omacr;": "ō", "&omega;": "ω", "&omicron;": "ο", "&omid;": "⦶", "&ominus;": "⊖", "&oopf;": "𝕠", "&opar;": "⦷", "&operp;": "⦹", "&oplus;": "⊕", "&or;": "∨", "&orarr;": "↻", "&ord;": "⩝", "&order;": "ℴ", "&orderof;": "ℴ", "&ordf": "ª", "&ordf;": "ª", "&ordm": "º", "&ordm;": "º", "&origof;": "⊶", "&oror;": "⩖", "&orslope;": "⩗", "&orv;": "⩛", "&oscr;": "ℴ", "&oslash": "ø", "&oslash;": "ø", "&osol;": "⊘", "&otilde": "õ", "&otilde;": "õ", "&otimes;": "⊗", "&otimesas;": "⨶", "&ouml": "ö", "&ouml;": "ö", "&ovbar;": "⌽", "&par;": "∥", "&para": "¶", "&para;": "¶", "&parallel;": "∥", "&parsim;": "⫳", "&parsl;": "⫽", "&part;": "∂", "&pcy;": "п", "&percnt;": "%", "&period;": ".", "&permil;": "‰", "&perp;": "⊥", "&pertenk;": "‱", "&pfr;": "𝔭", "&phi;": "φ", "&phiv;": "ϕ", "&phmmat;": "ℳ", "&phone;": "☎", "&pi;": "π", "&pitchfork;": "⋔", "&piv;": "ϖ", "&planck;": "ℏ", "&planckh;": "ℎ", "&plankv;": "ℏ", "&plus;": "+", "&plusacir;": "⨣", "&plusb;": "⊞", "&pluscir;": "⨢", "&plusdo;": "∔", "&plusdu;": "⨥", "&pluse;": "⩲", "&plusmn": "±", "&plusmn;": "±", "&plussim;": "⨦", "&plustwo;": "⨧", "&pm;": "±", "&pointint;": "⨕", "&popf;": "𝕡", "&pound": "£", "&pound;": "£", "&pr;": "≺", "&prE;": "⪳", "&prap;": "⪷", "&prcue;": "≼", "&pre;": "⪯", "&prec;": "≺", "&precapprox;": "⪷", "&preccurlyeq;": "≼", "&preceq;": "⪯", "&precnapprox;": "⪹", "&precneqq;": "⪵", "&precnsim;": "⋨", "&precsim;": "≾", "&prime;": "′", "&primes;": "ℙ", "&prnE;": "⪵", "&prnap;": "⪹", "&prnsim;": "⋨", "&prod;": "∏", "&profalar;": "⌮", "&profline;": "⌒", "&profsurf;": "⌓", "&prop;": "∝", "&propto;": "∝", "&prsim;": "≾", "&prurel;": "⊰", "&pscr;": "𝓅", "&psi;": "ψ", "&puncsp;": " ", "&qfr;": "𝔮", "&qint;": "⨌", "&qopf;": "𝕢", "&qprime;": "⁗", "&qscr;": "𝓆", "&quaternions;": "ℍ", "&quatint;": "⨖", "&quest;": "?", "&questeq;": "≟", "&quot": '"', "&quot;": '"', "&rAarr;": "⇛", "&rArr;": "⇒", "&rAtail;": "⤜", "&rBarr;": "⤏", "&rHar;": "⥤", "&race;": "∽̱", "&racute;": "ŕ", "&radic;": "√", "&raemptyv;": "⦳", "&rang;": "⟩", "&rangd;": "⦒", "&range;": "⦥", "&rangle;": "⟩", "&raquo": "»", "&raquo;": "»", "&rarr;": "→", "&rarrap;": "⥵", "&rarrb;": "⇥", "&rarrbfs;": "⤠", "&rarrc;": "⤳", "&rarrfs;": "⤞", "&rarrhk;": "↪", "&rarrlp;": "↬", "&rarrpl;": "⥅", "&rarrsim;": "⥴", "&rarrtl;": "↣", "&rarrw;": "↝", "&ratail;": "⤚", "&ratio;": "∶", "&rationals;": "ℚ", "&rbarr;": "⤍", "&rbbrk;": "❳", "&rbrace;": "}", "&rbrack;": "]", "&rbrke;": "⦌", "&rbrksld;": "⦎", "&rbrkslu;": "⦐", "&rcaron;": "ř", "&rcedil;": "ŗ", "&rceil;": "⌉", "&rcub;": "}", "&rcy;": "р", "&rdca;": "⤷", "&rdldhar;": "⥩", "&rdquo;": "”", "&rdquor;": "”", "&rdsh;": "↳", "&real;": "ℜ", "&realine;": "ℛ", "&realpart;": "ℜ", "&reals;": "ℝ", "&rect;": "▭", "&reg": "®", "&reg;": "®", "&rfisht;": "⥽", "&rfloor;": "⌋", "&rfr;": "𝔯", "&rhard;": "⇁", "&rharu;": "⇀", "&rharul;": "⥬", "&rho;": "ρ", "&rhov;": "ϱ", "&rightarrow;": "→", "&rightarrowtail;": "↣", "&rightharpoondown;": "⇁", "&rightharpoonup;": "⇀", "&rightleftarrows;": "⇄", "&rightleftharpoons;": "⇌", "&rightrightarrows;": "⇉", "&rightsquigarrow;": "↝", "&rightthreetimes;": "⋌", "&ring;": "˚", "&risingdotseq;": "≓", "&rlarr;": "⇄", "&rlhar;": "⇌", "&rlm;": "‏", "&rmoust;": "⎱", "&rmoustache;": "⎱", "&rnmid;": "⫮", "&roang;": "⟭", "&roarr;": "⇾", "&robrk;": "⟧", "&ropar;": "⦆", "&ropf;": "𝕣", "&roplus;": "⨮", "&rotimes;": "⨵", "&rpar;": ")", "&rpargt;": "⦔", "&rppolint;": "⨒", "&rrarr;": "⇉", "&rsaquo;": "›", "&rscr;": "𝓇", "&rsh;": "↱", "&rsqb;": "]", "&rsquo;": "’", "&rsquor;": "’", "&rthree;": "⋌", "&rtimes;": "⋊", "&rtri;": "▹", "&rtrie;": "⊵", "&rtrif;": "▸", "&rtriltri;": "⧎", "&ruluhar;": "⥨", "&rx;": "℞", "&sacute;": "ś", "&sbquo;": "‚", "&sc;": "≻", "&scE;": "⪴", "&scap;": "⪸", "&scaron;": "š", "&sccue;": "≽", "&sce;": "⪰", "&scedil;": "ş", "&scirc;": "ŝ", "&scnE;": "⪶", "&scnap;": "⪺", "&scnsim;": "⋩", "&scpolint;": "⨓", "&scsim;": "≿", "&scy;": "с", "&sdot;": "⋅", "&sdotb;": "⊡", "&sdote;": "⩦", "&seArr;": "⇘", "&searhk;": "⤥", "&searr;": "↘", "&searrow;": "↘", "&sect": "§", "&sect;": "§", "&semi;": ";", "&seswar;": "⤩", "&setminus;": "∖", "&setmn;": "∖", "&sext;": "✶", "&sfr;": "𝔰", "&sfrown;": "⌢", "&sharp;": "♯", "&shchcy;": "щ", "&shcy;": "ш", "&shortmid;": "∣", "&shortparallel;": "∥", "&shy": "­", "&shy;": "­", "&sigma;": "σ", "&sigmaf;": "ς", "&sigmav;": "ς", "&sim;": "∼", "&simdot;": "⩪", "&sime;": "≃", "&simeq;": "≃", "&simg;": "⪞", "&simgE;": "⪠", "&siml;": "⪝", "&simlE;": "⪟", "&simne;": "≆", "&simplus;": "⨤", "&simrarr;": "⥲", "&slarr;": "←", "&smallsetminus;": "∖", "&smashp;": "⨳", "&smeparsl;": "⧤", "&smid;": "∣", "&smile;": "⌣", "&smt;": "⪪", "&smte;": "⪬", "&smtes;": "⪬︀", "&softcy;": "ь", "&sol;": "/", "&solb;": "⧄", "&solbar;": "⌿", "&sopf;": "𝕤", "&spades;": "♠", "&spadesuit;": "♠", "&spar;": "∥", "&sqcap;": "⊓", "&sqcaps;": "⊓︀", "&sqcup;": "⊔", "&sqcups;": "⊔︀", "&sqsub;": "⊏", "&sqsube;": "⊑", "&sqsubset;": "⊏", "&sqsubseteq;": "⊑", "&sqsup;": "⊐", "&sqsupe;": "⊒", "&sqsupset;": "⊐", "&sqsupseteq;": "⊒", "&squ;": "□", "&square;": "□", "&squarf;": "▪", "&squf;": "▪", "&srarr;": "→", "&sscr;": "𝓈", "&ssetmn;": "∖", "&ssmile;": "⌣", "&sstarf;": "⋆", "&star;": "☆", "&starf;": "★", "&straightepsilon;": "ϵ", "&straightphi;": "ϕ", "&strns;": "¯", "&sub;": "⊂", "&subE;": "⫅", "&subdot;": "⪽", "&sube;": "⊆", "&subedot;": "⫃", "&submult;": "⫁", "&subnE;": "⫋", "&subne;": "⊊", "&subplus;": "⪿", "&subrarr;": "⥹", "&subset;": "⊂", "&subseteq;": "⊆", "&subseteqq;": "⫅", "&subsetneq;": "⊊", "&subsetneqq;": "⫋", "&subsim;": "⫇", "&subsub;": "⫕", "&subsup;": "⫓", "&succ;": "≻", "&succapprox;": "⪸", "&succcurlyeq;": "≽", "&succeq;": "⪰", "&succnapprox;": "⪺", "&succneqq;": "⪶", "&succnsim;": "⋩", "&succsim;": "≿", "&sum;": "∑", "&sung;": "♪", "&sup1": "¹", "&sup1;": "¹", "&sup2": "²", "&sup2;": "²", "&sup3": "³", "&sup3;": "³", "&sup;": "⊃", "&supE;": "⫆", "&supdot;": "⪾", "&supdsub;": "⫘", "&supe;": "⊇", "&supedot;": "⫄", "&suphsol;": "⟉", "&suphsub;": "⫗", "&suplarr;": "⥻", "&supmult;": "⫂", "&supnE;": "⫌", "&supne;": "⊋", "&supplus;": "⫀", "&supset;": "⊃", "&supseteq;": "⊇", "&supseteqq;": "⫆", "&supsetneq;": "⊋", "&supsetneqq;": "⫌", "&supsim;": "⫈", "&supsub;": "⫔", "&supsup;": "⫖", "&swArr;": "⇙", "&swarhk;": "⤦", "&swarr;": "↙", "&swarrow;": "↙", "&swnwar;": "⤪", "&szlig": "ß", "&szlig;": "ß", "&target;": "⌖", "&tau;": "τ", "&tbrk;": "⎴", "&tcaron;": "ť", "&tcedil;": "ţ", "&tcy;": "т", "&tdot;": "⃛", "&telrec;": "⌕", "&tfr;": "𝔱", "&there4;": "∴", "&therefore;": "∴", "&theta;": "θ", "&thetasym;": "ϑ", "&thetav;": "ϑ", "&thickapprox;": "≈", "&thicksim;": "∼", "&thinsp;": " ", "&thkap;": "≈", "&thksim;": "∼", "&thorn": "þ", "&thorn;": "þ", "&tilde;": "˜", "&times": "×", "&times;": "×", "&timesb;": "⊠", "&timesbar;": "⨱", "&timesd;": "⨰", "&tint;": "∭", "&toea;": "⤨", "&top;": "⊤", "&topbot;": "⌶", "&topcir;": "⫱", "&topf;": "𝕥", "&topfork;": "⫚", "&tosa;": "⤩", "&tprime;": "‴", "&trade;": "™", "&triangle;": "▵", "&triangledown;": "▿", "&triangleleft;": "◃", "&trianglelefteq;": "⊴", "&triangleq;": "≜", "&triangleright;": "▹", "&trianglerighteq;": "⊵", "&tridot;": "◬", "&trie;": "≜", "&triminus;": "⨺", "&triplus;": "⨹", "&trisb;": "⧍", "&tritime;": "⨻", "&trpezium;": "⏢", "&tscr;": "𝓉", "&tscy;": "ц", "&tshcy;": "ћ", "&tstrok;": "ŧ", "&twixt;": "≬", "&twoheadleftarrow;": "↞", "&twoheadrightarrow;": "↠", "&uArr;": "⇑", "&uHar;": "⥣", "&uacute": "ú", "&uacute;": "ú", "&uarr;": "↑", "&ubrcy;": "ў", "&ubreve;": "ŭ", "&ucirc": "û", "&ucirc;": "û", "&ucy;": "у", "&udarr;": "⇅", "&udblac;": "ű", "&udhar;": "⥮", "&ufisht;": "⥾", "&ufr;": "𝔲", "&ugrave": "ù", "&ugrave;": "ù", "&uharl;": "↿", "&uharr;": "↾", "&uhblk;": "▀", "&ulcorn;": "⌜", "&ulcorner;": "⌜", "&ulcrop;": "⌏", "&ultri;": "◸", "&umacr;": "ū", "&uml": "¨", "&uml;": "¨", "&uogon;": "ų", "&uopf;": "𝕦", "&uparrow;": "↑", "&updownarrow;": "↕", "&upharpoonleft;": "↿", "&upharpoonright;": "↾", "&uplus;": "⊎", "&upsi;": "υ", "&upsih;": "ϒ", "&upsilon;": "υ", "&upuparrows;": "⇈", "&urcorn;": "⌝", "&urcorner;": "⌝", "&urcrop;": "⌎", "&uring;": "ů", "&urtri;": "◹", "&uscr;": "𝓊", "&utdot;": "⋰", "&utilde;": "ũ", "&utri;": "▵", "&utrif;": "▴", "&uuarr;": "⇈", "&uuml": "ü", "&uuml;": "ü", "&uwangle;": "⦧", "&vArr;": "⇕", "&vBar;": "⫨", "&vBarv;": "⫩", "&vDash;": "⊨", "&vangrt;": "⦜", "&varepsilon;": "ϵ", "&varkappa;": "ϰ", "&varnothing;": "∅", "&varphi;": "ϕ", "&varpi;": "ϖ", "&varpropto;": "∝", "&varr;": "↕", "&varrho;": "ϱ", "&varsigma;": "ς", "&varsubsetneq;": "⊊︀", "&varsubsetneqq;": "⫋︀", "&varsupsetneq;": "⊋︀", "&varsupsetneqq;": "⫌︀", "&vartheta;": "ϑ", "&vartriangleleft;": "⊲", "&vartriangleright;": "⊳", "&vcy;": "в", "&vdash;": "⊢", "&vee;": "∨", "&veebar;": "⊻", "&veeeq;": "≚", "&vellip;": "⋮", "&verbar;": "|", "&vert;": "|", "&vfr;": "𝔳", "&vltri;": "⊲", "&vnsub;": "⊂⃒", "&vnsup;": "⊃⃒", "&vopf;": "𝕧", "&vprop;": "∝", "&vrtri;": "⊳", "&vscr;": "𝓋", "&vsubnE;": "⫋︀", "&vsubne;": "⊊︀", "&vsupnE;": "⫌︀", "&vsupne;": "⊋︀", "&vzigzag;": "⦚", "&wcirc;": "ŵ", "&wedbar;": "⩟", "&wedge;": "∧", "&wedgeq;": "≙", "&weierp;": "℘", "&wfr;": "𝔴", "&wopf;": "𝕨", "&wp;": "℘", "&wr;": "≀", "&wreath;": "≀", "&wscr;": "𝓌", "&xcap;": "⋂", "&xcirc;": "◯", "&xcup;": "⋃", "&xdtri;": "▽", "&xfr;": "𝔵", "&xhArr;": "⟺", "&xharr;": "⟷", "&xi;": "ξ", "&xlArr;": "⟸", "&xlarr;": "⟵", "&xmap;": "⟼", "&xnis;": "⋻", "&xodot;": "⨀", "&xopf;": "𝕩", "&xoplus;": "⨁", "&xotime;": "⨂", "&xrArr;": "⟹", "&xrarr;": "⟶", "&xscr;": "𝓍", "&xsqcup;": "⨆", "&xuplus;": "⨄", "&xutri;": "△", "&xvee;": "⋁", "&xwedge;": "⋀", "&yacute": "ý", "&yacute;": "ý", "&yacy;": "я", "&ycirc;": "ŷ", "&ycy;": "ы", "&yen": "¥", "&yen;": "¥", "&yfr;": "𝔶", "&yicy;": "ї", "&yopf;": "𝕪", "&yscr;": "𝓎", "&yucy;": "ю", "&yuml": "ÿ", "&yuml;": "ÿ", "&zacute;": "ź", "&zcaron;": "ž", "&zcy;": "з", "&zdot;": "ż", "&zeetrf;": "ℨ", "&zeta;": "ζ", "&zfr;": "𝔷", "&zhcy;": "ж", "&zigrarr;": "⇝", "&zopf;": "𝕫", "&zscr;": "𝓏", "&zwj;": "‍", "&zwnj;": "‌" }, characters: { "Æ": "&AElig;", "&": "&amp;", "Á": "&Aacute;", "Ă": "&Abreve;", "Â": "&Acirc;", "А": "&Acy;", "𝔄": "&Afr;", "À": "&Agrave;", "Α": "&Alpha;", "Ā": "&Amacr;", "⩓": "&And;", "Ą": "&Aogon;", "𝔸": "&Aopf;", "⁡": "&af;", "Å": "&angst;", "𝒜": "&Ascr;", "≔": "&coloneq;", "Ã": "&Atilde;", "Ä": "&Auml;", "∖": "&ssetmn;", "⫧": "&Barv;", "⌆": "&doublebarwedge;", "Б": "&Bcy;", "∵": "&because;", "ℬ": "&bernou;", "Β": "&Beta;", "𝔅": "&Bfr;", "𝔹": "&Bopf;", "˘": "&breve;", "≎": "&bump;", "Ч": "&CHcy;", "©": "&copy;", "Ć": "&Cacute;", "⋒": "&Cap;", "ⅅ": "&DD;", "ℭ": "&Cfr;", "Č": "&Ccaron;", "Ç": "&Ccedil;", "Ĉ": "&Ccirc;", "∰": "&Cconint;", "Ċ": "&Cdot;", "¸": "&cedil;", "·": "&middot;", "Χ": "&Chi;", "⊙": "&odot;", "⊖": "&ominus;", "⊕": "&oplus;", "⊗": "&otimes;", "∲": "&cwconint;", "”": "&rdquor;", "’": "&rsquor;", "∷": "&Proportion;", "⩴": "&Colone;", "≡": "&equiv;", "∯": "&DoubleContourIntegral;", "∮": "&oint;", "ℂ": "&complexes;", "∐": "&coprod;", "∳": "&awconint;", "⨯": "&Cross;", "𝒞": "&Cscr;", "⋓": "&Cup;", "≍": "&asympeq;", "⤑": "&DDotrahd;", "Ђ": "&DJcy;", "Ѕ": "&DScy;", "Џ": "&DZcy;", "‡": "&ddagger;", "↡": "&Darr;", "⫤": "&DoubleLeftTee;", "Ď": "&Dcaron;", "Д": "&Dcy;", "∇": "&nabla;", "Δ": "&Delta;", "𝔇": "&Dfr;", "´": "&acute;", "˙": "&dot;", "˝": "&dblac;", "`": "&grave;", "˜": "&tilde;", "⋄": "&diamond;", "ⅆ": "&dd;", "𝔻": "&Dopf;", "¨": "&uml;", "⃜": "&DotDot;", "≐": "&esdot;", "⇓": "&dArr;", "⇐": "&lArr;", "⇔": "&iff;", "⟸": "&xlArr;", "⟺": "&xhArr;", "⟹": "&xrArr;", "⇒": "&rArr;", "⊨": "&vDash;", "⇑": "&uArr;", "⇕": "&vArr;", "∥": "&spar;", "↓": "&downarrow;", "⤓": "&DownArrowBar;", "⇵": "&duarr;", "̑": "&DownBreve;", "⥐": "&DownLeftRightVector;", "⥞": "&DownLeftTeeVector;", "↽": "&lhard;", "⥖": "&DownLeftVectorBar;", "⥟": "&DownRightTeeVector;", "⇁": "&rightharpoondown;", "⥗": "&DownRightVectorBar;", "⊤": "&top;", "↧": "&mapstodown;", "𝒟": "&Dscr;", "Đ": "&Dstrok;", "Ŋ": "&ENG;", "Ð": "&ETH;", "É": "&Eacute;", "Ě": "&Ecaron;", "Ê": "&Ecirc;", "Э": "&Ecy;", "Ė": "&Edot;", "𝔈": "&Efr;", "È": "&Egrave;", "∈": "&isinv;", "Ē": "&Emacr;", "◻": "&EmptySmallSquare;", "▫": "&EmptyVerySmallSquare;", "Ę": "&Eogon;", "𝔼": "&Eopf;", "Ε": "&Epsilon;", "⩵": "&Equal;", "≂": "&esim;", "⇌": "&rlhar;", "ℰ": "&expectation;", "⩳": "&Esim;", "Η": "&Eta;", "Ë": "&Euml;", "∃": "&exist;", "ⅇ": "&exponentiale;", "Ф": "&Fcy;", "𝔉": "&Ffr;", "◼": "&FilledSmallSquare;", "▪": "&squf;", "𝔽": "&Fopf;", "∀": "&forall;", "ℱ": "&Fscr;", "Ѓ": "&GJcy;", ">": "&gt;", "Γ": "&Gamma;", "Ϝ": "&Gammad;", "Ğ": "&Gbreve;", "Ģ": "&Gcedil;", "Ĝ": "&Gcirc;", "Г": "&Gcy;", "Ġ": "&Gdot;", "𝔊": "&Gfr;", "⋙": "&ggg;", "𝔾": "&Gopf;", "≥": "&geq;", "⋛": "&gtreqless;", "≧": "&geqq;", "⪢": "&GreaterGreater;", "≷": "&gtrless;", "⩾": "&ges;", "≳": "&gtrsim;", "𝒢": "&Gscr;", "≫": "&gg;", "Ъ": "&HARDcy;", "ˇ": "&caron;", "^": "&Hat;", "Ĥ": "&Hcirc;", "ℌ": "&Poincareplane;", "ℋ": "&hamilt;", "ℍ": "&quaternions;", "─": "&boxh;", "Ħ": "&Hstrok;", "≏": "&bumpeq;", "Е": "&IEcy;", "Ĳ": "&IJlig;", "Ё": "&IOcy;", "Í": "&Iacute;", "Î": "&Icirc;", "И": "&Icy;", "İ": "&Idot;", "ℑ": "&imagpart;", "Ì": "&Igrave;", "Ī": "&Imacr;", "ⅈ": "&ii;", "∬": "&Int;", "∫": "&int;", "⋂": "&xcap;", "⁣": "&ic;", "⁢": "&it;", "Į": "&Iogon;", "𝕀": "&Iopf;", "Ι": "&Iota;", "ℐ": "&imagline;", "Ĩ": "&Itilde;", "І": "&Iukcy;", "Ï": "&Iuml;", "Ĵ": "&Jcirc;", "Й": "&Jcy;", "𝔍": "&Jfr;", "𝕁": "&Jopf;", "𝒥": "&Jscr;", "Ј": "&Jsercy;", "Є": "&Jukcy;", "Х": "&KHcy;", "Ќ": "&KJcy;", "Κ": "&Kappa;", "Ķ": "&Kcedil;", "К": "&Kcy;", "𝔎": "&Kfr;", "𝕂": "&Kopf;", "𝒦": "&Kscr;", "Љ": "&LJcy;", "<": "&lt;", "Ĺ": "&Lacute;", "Λ": "&Lambda;", "⟪": "&Lang;", "ℒ": "&lagran;", "↞": "&twoheadleftarrow;", "Ľ": "&Lcaron;", "Ļ": "&Lcedil;", "Л": "&Lcy;", "⟨": "&langle;", "←": "&slarr;", "⇤": "&larrb;", "⇆": "&lrarr;", "⌈": "&lceil;", "⟦": "&lobrk;", "⥡": "&LeftDownTeeVector;", "⇃": "&downharpoonleft;", "⥙": "&LeftDownVectorBar;", "⌊": "&lfloor;", "↔": "&leftrightarrow;", "⥎": "&LeftRightVector;", "⊣": "&dashv;", "↤": "&mapstoleft;", "⥚": "&LeftTeeVector;", "⊲": "&vltri;", "⧏": "&LeftTriangleBar;", "⊴": "&trianglelefteq;", "⥑": "&LeftUpDownVector;", "⥠": "&LeftUpTeeVector;", "↿": "&upharpoonleft;", "⥘": "&LeftUpVectorBar;", "↼": "&lharu;", "⥒": "&LeftVectorBar;", "⋚": "&lesseqgtr;", "≦": "&leqq;", "≶": "&lg;", "⪡": "&LessLess;", "⩽": "&les;", "≲": "&lsim;", "𝔏": "&Lfr;", "⋘": "&Ll;", "⇚": "&lAarr;", "Ŀ": "&Lmidot;", "⟵": "&xlarr;", "⟷": "&xharr;", "⟶": "&xrarr;", "𝕃": "&Lopf;", "↙": "&swarrow;", "↘": "&searrow;", "↰": "&lsh;", "Ł": "&Lstrok;", "≪": "&ll;", "⤅": "&Map;", "М": "&Mcy;", " ": "&MediumSpace;", "ℳ": "&phmmat;", "𝔐": "&Mfr;", "∓": "&mp;", "𝕄": "&Mopf;", "Μ": "&Mu;", "Њ": "&NJcy;", "Ń": "&Nacute;", "Ň": "&Ncaron;", "Ņ": "&Ncedil;", "Н": "&Ncy;", "​": "&ZeroWidthSpace;", "\n": "&NewLine;", "𝔑": "&Nfr;", "⁠": "&NoBreak;", " ": "&nbsp;", "ℕ": "&naturals;", "⫬": "&Not;", "≢": "&nequiv;", "≭": "&NotCupCap;", "∦": "&nspar;", "∉": "&notinva;", "≠": "&ne;", "≂̸": "&nesim;", "∄": "&nexists;", "≯": "&ngtr;", "≱": "&ngeq;", "≧̸": "&ngeqq;", "≫̸": "&nGtv;", "≹": "&ntgl;", "⩾̸": "&nges;", "≵": "&ngsim;", "≎̸": "&nbump;", "≏̸": "&nbumpe;", "⋪": "&ntriangleleft;", "⧏̸": "&NotLeftTriangleBar;", "⋬": "&ntrianglelefteq;", "≮": "&nlt;", "≰": "&nleq;", "≸": "&ntlg;", "≪̸": "&nLtv;", "⩽̸": "&nles;", "≴": "&nlsim;", "⪢̸": "&NotNestedGreaterGreater;", "⪡̸": "&NotNestedLessLess;", "⊀": "&nprec;", "⪯̸": "&npreceq;", "⋠": "&nprcue;", "∌": "&notniva;", "⋫": "&ntriangleright;", "⧐̸": "&NotRightTriangleBar;", "⋭": "&ntrianglerighteq;", "⊏̸": "&NotSquareSubset;", "⋢": "&nsqsube;", "⊐̸": "&NotSquareSuperset;", "⋣": "&nsqsupe;", "⊂⃒": "&vnsub;", "⊈": "&nsubseteq;", "⊁": "&nsucc;", "⪰̸": "&nsucceq;", "⋡": "&nsccue;", "≿̸": "&NotSucceedsTilde;", "⊃⃒": "&vnsup;", "⊉": "&nsupseteq;", "≁": "&nsim;", "≄": "&nsimeq;", "≇": "&ncong;", "≉": "&napprox;", "∤": "&nsmid;", "𝒩": "&Nscr;", "Ñ": "&Ntilde;", "Ν": "&Nu;", "Œ": "&OElig;", "Ó": "&Oacute;", "Ô": "&Ocirc;", "О": "&Ocy;", "Ő": "&Odblac;", "𝔒": "&Ofr;", "Ò": "&Ograve;", "Ō": "&Omacr;", "Ω": "&ohm;", "Ο": "&Omicron;", "𝕆": "&Oopf;", "“": "&ldquo;", "‘": "&lsquo;", "⩔": "&Or;", "𝒪": "&Oscr;", "Ø": "&Oslash;", "Õ": "&Otilde;", "⨷": "&Otimes;", "Ö": "&Ouml;", "‾": "&oline;", "⏞": "&OverBrace;", "⎴": "&tbrk;", "⏜": "&OverParenthesis;", "∂": "&part;", "П": "&Pcy;", "𝔓": "&Pfr;", "Φ": "&Phi;", "Π": "&Pi;", "±": "&pm;", "ℙ": "&primes;", "⪻": "&Pr;", "≺": "&prec;", "⪯": "&preceq;", "≼": "&preccurlyeq;", "≾": "&prsim;", "″": "&Prime;", "∏": "&prod;", "∝": "&vprop;", "𝒫": "&Pscr;", "Ψ": "&Psi;", '"': "&quot;", "𝔔": "&Qfr;", "ℚ": "&rationals;", "𝒬": "&Qscr;", "⤐": "&drbkarow;", "®": "&reg;", "Ŕ": "&Racute;", "⟫": "&Rang;", "↠": "&twoheadrightarrow;", "⤖": "&Rarrtl;", "Ř": "&Rcaron;", "Ŗ": "&Rcedil;", "Р": "&Rcy;", "ℜ": "&realpart;", "∋": "&niv;", "⇋": "&lrhar;", "⥯": "&duhar;", "Ρ": "&Rho;", "⟩": "&rangle;", "→": "&srarr;", "⇥": "&rarrb;", "⇄": "&rlarr;", "⌉": "&rceil;", "⟧": "&robrk;", "⥝": "&RightDownTeeVector;", "⇂": "&downharpoonright;", "⥕": "&RightDownVectorBar;", "⌋": "&rfloor;", "⊢": "&vdash;", "↦": "&mapsto;", "⥛": "&RightTeeVector;", "⊳": "&vrtri;", "⧐": "&RightTriangleBar;", "⊵": "&trianglerighteq;", "⥏": "&RightUpDownVector;", "⥜": "&RightUpTeeVector;", "↾": "&upharpoonright;", "⥔": "&RightUpVectorBar;", "⇀": "&rightharpoonup;", "⥓": "&RightVectorBar;", "ℝ": "&reals;", "⥰": "&RoundImplies;", "⇛": "&rAarr;", "ℛ": "&realine;", "↱": "&rsh;", "⧴": "&RuleDelayed;", "Щ": "&SHCHcy;", "Ш": "&SHcy;", "Ь": "&SOFTcy;", "Ś": "&Sacute;", "⪼": "&Sc;", "Š": "&Scaron;", "Ş": "&Scedil;", "Ŝ": "&Scirc;", "С": "&Scy;", "𝔖": "&Sfr;", "↑": "&uparrow;", "Σ": "&Sigma;", "∘": "&compfn;", "𝕊": "&Sopf;", "√": "&radic;", "□": "&square;", "⊓": "&sqcap;", "⊏": "&sqsubset;", "⊑": "&sqsubseteq;", "⊐": "&sqsupset;", "⊒": "&sqsupseteq;", "⊔": "&sqcup;", "𝒮": "&Sscr;", "⋆": "&sstarf;", "⋐": "&Subset;", "⊆": "&subseteq;", "≻": "&succ;", "⪰": "&succeq;", "≽": "&succcurlyeq;", "≿": "&succsim;", "∑": "&sum;", "⋑": "&Supset;", "⊃": "&supset;", "⊇": "&supseteq;", "Þ": "&THORN;", "™": "&trade;", "Ћ": "&TSHcy;", "Ц": "&TScy;", "	": "&Tab;", "Τ": "&Tau;", "Ť": "&Tcaron;", "Ţ": "&Tcedil;", "Т": "&Tcy;", "𝔗": "&Tfr;", "∴": "&therefore;", "Θ": "&Theta;", "  ": "&ThickSpace;", " ": "&thinsp;", "∼": "&thksim;", "≃": "&simeq;", "≅": "&cong;", "≈": "&thkap;", "𝕋": "&Topf;", "⃛": "&tdot;", "𝒯": "&Tscr;", "Ŧ": "&Tstrok;", "Ú": "&Uacute;", "↟": "&Uarr;", "⥉": "&Uarrocir;", "Ў": "&Ubrcy;", "Ŭ": "&Ubreve;", "Û": "&Ucirc;", "У": "&Ucy;", "Ű": "&Udblac;", "𝔘": "&Ufr;", "Ù": "&Ugrave;", "Ū": "&Umacr;", _: "&lowbar;", "⏟": "&UnderBrace;", "⎵": "&bbrk;", "⏝": "&UnderParenthesis;", "⋃": "&xcup;", "⊎": "&uplus;", "Ų": "&Uogon;", "𝕌": "&Uopf;", "⤒": "&UpArrowBar;", "⇅": "&udarr;", "↕": "&varr;", "⥮": "&udhar;", "⊥": "&perp;", "↥": "&mapstoup;", "↖": "&nwarrow;", "↗": "&nearrow;", "ϒ": "&upsih;", "Υ": "&Upsilon;", "Ů": "&Uring;", "𝒰": "&Uscr;", "Ũ": "&Utilde;", "Ü": "&Uuml;", "⊫": "&VDash;", "⫫": "&Vbar;", "В": "&Vcy;", "⊩": "&Vdash;", "⫦": "&Vdashl;", "⋁": "&xvee;", "‖": "&Vert;", "∣": "&smid;", "|": "&vert;", "❘": "&VerticalSeparator;", "≀": "&wreath;", " ": "&hairsp;", "𝔙": "&Vfr;", "𝕍": "&Vopf;", "𝒱": "&Vscr;", "⊪": "&Vvdash;", "Ŵ": "&Wcirc;", "⋀": "&xwedge;", "𝔚": "&Wfr;", "𝕎": "&Wopf;", "𝒲": "&Wscr;", "𝔛": "&Xfr;", "Ξ": "&Xi;", "𝕏": "&Xopf;", "𝒳": "&Xscr;", "Я": "&YAcy;", "Ї": "&YIcy;", "Ю": "&YUcy;", "Ý": "&Yacute;", "Ŷ": "&Ycirc;", "Ы": "&Ycy;", "𝔜": "&Yfr;", "𝕐": "&Yopf;", "𝒴": "&Yscr;", "Ÿ": "&Yuml;", "Ж": "&ZHcy;", "Ź": "&Zacute;", "Ž": "&Zcaron;", "З": "&Zcy;", "Ż": "&Zdot;", "Ζ": "&Zeta;", "ℨ": "&zeetrf;", "ℤ": "&integers;", "𝒵": "&Zscr;", "á": "&aacute;", "ă": "&abreve;", "∾": "&mstpos;", "∾̳": "&acE;", "∿": "&acd;", "â": "&acirc;", "а": "&acy;", "æ": "&aelig;", "𝔞": "&afr;", "à": "&agrave;", "ℵ": "&aleph;", "α": "&alpha;", "ā": "&amacr;", "⨿": "&amalg;", "∧": "&wedge;", "⩕": "&andand;", "⩜": "&andd;", "⩘": "&andslope;", "⩚": "&andv;", "∠": "&angle;", "⦤": "&ange;", "∡": "&measuredangle;", "⦨": "&angmsdaa;", "⦩": "&angmsdab;", "⦪": "&angmsdac;", "⦫": "&angmsdad;", "⦬": "&angmsdae;", "⦭": "&angmsdaf;", "⦮": "&angmsdag;", "⦯": "&angmsdah;", "∟": "&angrt;", "⊾": "&angrtvb;", "⦝": "&angrtvbd;", "∢": "&angsph;", "⍼": "&angzarr;", "ą": "&aogon;", "𝕒": "&aopf;", "⩰": "&apE;", "⩯": "&apacir;", "≊": "&approxeq;", "≋": "&apid;", "'": "&apos;", "å": "&aring;", "𝒶": "&ascr;", "*": "&midast;", "ã": "&atilde;", "ä": "&auml;", "⨑": "&awint;", "⫭": "&bNot;", "≌": "&bcong;", "϶": "&bepsi;", "‵": "&bprime;", "∽": "&bsim;", "⋍": "&bsime;", "⊽": "&barvee;", "⌅": "&barwedge;", "⎶": "&bbrktbrk;", "б": "&bcy;", "„": "&ldquor;", "⦰": "&bemptyv;", "β": "&beta;", "ℶ": "&beth;", "≬": "&twixt;", "𝔟": "&bfr;", "◯": "&xcirc;", "⨀": "&xodot;", "⨁": "&xoplus;", "⨂": "&xotime;", "⨆": "&xsqcup;", "★": "&starf;", "▽": "&xdtri;", "△": "&xutri;", "⨄": "&xuplus;", "⤍": "&rbarr;", "⧫": "&lozf;", "▴": "&utrif;", "▾": "&dtrif;", "◂": "&ltrif;", "▸": "&rtrif;", "␣": "&blank;", "▒": "&blk12;", "░": "&blk14;", "▓": "&blk34;", "█": "&block;", "=⃥": "&bne;", "≡⃥": "&bnequiv;", "⌐": "&bnot;", "𝕓": "&bopf;", "⋈": "&bowtie;", "╗": "&boxDL;", "╔": "&boxDR;", "╖": "&boxDl;", "╓": "&boxDr;", "═": "&boxH;", "╦": "&boxHD;", "╩": "&boxHU;", "╤": "&boxHd;", "╧": "&boxHu;", "╝": "&boxUL;", "╚": "&boxUR;", "╜": "&boxUl;", "╙": "&boxUr;", "║": "&boxV;", "╬": "&boxVH;", "╣": "&boxVL;", "╠": "&boxVR;", "╫": "&boxVh;", "╢": "&boxVl;", "╟": "&boxVr;", "⧉": "&boxbox;", "╕": "&boxdL;", "╒": "&boxdR;", "┐": "&boxdl;", "┌": "&boxdr;", "╥": "&boxhD;", "╨": "&boxhU;", "┬": "&boxhd;", "┴": "&boxhu;", "⊟": "&minusb;", "⊞": "&plusb;", "⊠": "&timesb;", "╛": "&boxuL;", "╘": "&boxuR;", "┘": "&boxul;", "└": "&boxur;", "│": "&boxv;", "╪": "&boxvH;", "╡": "&boxvL;", "╞": "&boxvR;", "┼": "&boxvh;", "┤": "&boxvl;", "├": "&boxvr;", "¦": "&brvbar;", "𝒷": "&bscr;", "⁏": "&bsemi;", "\\": "&bsol;", "⧅": "&bsolb;", "⟈": "&bsolhsub;", "•": "&bullet;", "⪮": "&bumpE;", "ć": "&cacute;", "∩": "&cap;", "⩄": "&capand;", "⩉": "&capbrcup;", "⩋": "&capcap;", "⩇": "&capcup;", "⩀": "&capdot;", "∩︀": "&caps;", "⁁": "&caret;", "⩍": "&ccaps;", "č": "&ccaron;", "ç": "&ccedil;", "ĉ": "&ccirc;", "⩌": "&ccups;", "⩐": "&ccupssm;", "ċ": "&cdot;", "⦲": "&cemptyv;", "¢": "&cent;", "𝔠": "&cfr;", "ч": "&chcy;", "✓": "&checkmark;", "χ": "&chi;", "○": "&cir;", "⧃": "&cirE;", "ˆ": "&circ;", "≗": "&cire;", "↺": "&olarr;", "↻": "&orarr;", "Ⓢ": "&oS;", "⊛": "&oast;", "⊚": "&ocir;", "⊝": "&odash;", "⨐": "&cirfnint;", "⫯": "&cirmid;", "⧂": "&cirscir;", "♣": "&clubsuit;", ":": "&colon;", ",": "&comma;", "@": "&commat;", "∁": "&complement;", "⩭": "&congdot;", "𝕔": "&copf;", "℗": "&copysr;", "↵": "&crarr;", "✗": "&cross;", "𝒸": "&cscr;", "⫏": "&csub;", "⫑": "&csube;", "⫐": "&csup;", "⫒": "&csupe;", "⋯": "&ctdot;", "⤸": "&cudarrl;", "⤵": "&cudarrr;", "⋞": "&curlyeqprec;", "⋟": "&curlyeqsucc;", "↶": "&curvearrowleft;", "⤽": "&cularrp;", "∪": "&cup;", "⩈": "&cupbrcap;", "⩆": "&cupcap;", "⩊": "&cupcup;", "⊍": "&cupdot;", "⩅": "&cupor;", "∪︀": "&cups;", "↷": "&curvearrowright;", "⤼": "&curarrm;", "⋎": "&cuvee;", "⋏": "&cuwed;", "¤": "&curren;", "∱": "&cwint;", "⌭": "&cylcty;", "⥥": "&dHar;", "†": "&dagger;", "ℸ": "&daleth;", "‐": "&hyphen;", "⤏": "&rBarr;", "ď": "&dcaron;", "д": "&dcy;", "⇊": "&downdownarrows;", "⩷": "&eDDot;", "°": "&deg;", "δ": "&delta;", "⦱": "&demptyv;", "⥿": "&dfisht;", "𝔡": "&dfr;", "♦": "&diams;", "ϝ": "&gammad;", "⋲": "&disin;", "÷": "&divide;", "⋇": "&divonx;", "ђ": "&djcy;", "⌞": "&llcorner;", "⌍": "&dlcrop;", $: "&dollar;", "𝕕": "&dopf;", "≑": "&eDot;", "∸": "&minusd;", "∔": "&plusdo;", "⊡": "&sdotb;", "⌟": "&lrcorner;", "⌌": "&drcrop;", "𝒹": "&dscr;", "ѕ": "&dscy;", "⧶": "&dsol;", "đ": "&dstrok;", "⋱": "&dtdot;", "▿": "&triangledown;", "⦦": "&dwangle;", "џ": "&dzcy;", "⟿": "&dzigrarr;", "é": "&eacute;", "⩮": "&easter;", "ě": "&ecaron;", "≖": "&eqcirc;", "ê": "&ecirc;", "≕": "&eqcolon;", "э": "&ecy;", "ė": "&edot;", "≒": "&fallingdotseq;", "𝔢": "&efr;", "⪚": "&eg;", "è": "&egrave;", "⪖": "&eqslantgtr;", "⪘": "&egsdot;", "⪙": "&el;", "⏧": "&elinters;", "ℓ": "&ell;", "⪕": "&eqslantless;", "⪗": "&elsdot;", "ē": "&emacr;", "∅": "&varnothing;", " ": "&emsp13;", " ": "&emsp14;", " ": "&emsp;", "ŋ": "&eng;", " ": "&ensp;", "ę": "&eogon;", "𝕖": "&eopf;", "⋕": "&epar;", "⧣": "&eparsl;", "⩱": "&eplus;", "ε": "&epsilon;", "ϵ": "&varepsilon;", "=": "&equals;", "≟": "&questeq;", "⩸": "&equivDD;", "⧥": "&eqvparsl;", "≓": "&risingdotseq;", "⥱": "&erarr;", "ℯ": "&escr;", "η": "&eta;", "ð": "&eth;", "ë": "&euml;", "€": "&euro;", "!": "&excl;", "ф": "&fcy;", "♀": "&female;", "ﬃ": "&ffilig;", "ﬀ": "&fflig;", "ﬄ": "&ffllig;", "𝔣": "&ffr;", "ﬁ": "&filig;", fj: "&fjlig;", "♭": "&flat;", "ﬂ": "&fllig;", "▱": "&fltns;", "ƒ": "&fnof;", "𝕗": "&fopf;", "⋔": "&pitchfork;", "⫙": "&forkv;", "⨍": "&fpartint;", "½": "&half;", "⅓": "&frac13;", "¼": "&frac14;", "⅕": "&frac15;", "⅙": "&frac16;", "⅛": "&frac18;", "⅔": "&frac23;", "⅖": "&frac25;", "¾": "&frac34;", "⅗": "&frac35;", "⅜": "&frac38;", "⅘": "&frac45;", "⅚": "&frac56;", "⅝": "&frac58;", "⅞": "&frac78;", "⁄": "&frasl;", "⌢": "&sfrown;", "𝒻": "&fscr;", "⪌": "&gtreqqless;", "ǵ": "&gacute;", "γ": "&gamma;", "⪆": "&gtrapprox;", "ğ": "&gbreve;", "ĝ": "&gcirc;", "г": "&gcy;", "ġ": "&gdot;", "⪩": "&gescc;", "⪀": "&gesdot;", "⪂": "&gesdoto;", "⪄": "&gesdotol;", "⋛︀": "&gesl;", "⪔": "&gesles;", "𝔤": "&gfr;", "ℷ": "&gimel;", "ѓ": "&gjcy;", "⪒": "&glE;", "⪥": "&gla;", "⪤": "&glj;", "≩": "&gneqq;", "⪊": "&gnapprox;", "⪈": "&gneq;", "⋧": "&gnsim;", "𝕘": "&gopf;", "ℊ": "&gscr;", "⪎": "&gsime;", "⪐": "&gsiml;", "⪧": "&gtcc;", "⩺": "&gtcir;", "⋗": "&gtrdot;", "⦕": "&gtlPar;", "⩼": "&gtquest;", "⥸": "&gtrarr;", "≩︀": "&gvnE;", "ъ": "&hardcy;", "⥈": "&harrcir;", "↭": "&leftrightsquigarrow;", "ℏ": "&plankv;", "ĥ": "&hcirc;", "♥": "&heartsuit;", "…": "&mldr;", "⊹": "&hercon;", "𝔥": "&hfr;", "⤥": "&searhk;", "⤦": "&swarhk;", "⇿": "&hoarr;", "∻": "&homtht;", "↩": "&larrhk;", "↪": "&rarrhk;", "𝕙": "&hopf;", "―": "&horbar;", "𝒽": "&hscr;", "ħ": "&hstrok;", "⁃": "&hybull;", "í": "&iacute;", "î": "&icirc;", "и": "&icy;", "е": "&iecy;", "¡": "&iexcl;", "𝔦": "&ifr;", "ì": "&igrave;", "⨌": "&qint;", "∭": "&tint;", "⧜": "&iinfin;", "℩": "&iiota;", "ĳ": "&ijlig;", "ī": "&imacr;", "ı": "&inodot;", "⊷": "&imof;", "Ƶ": "&imped;", "℅": "&incare;", "∞": "&infin;", "⧝": "&infintie;", "⊺": "&intercal;", "⨗": "&intlarhk;", "⨼": "&iprod;", "ё": "&iocy;", "į": "&iogon;", "𝕚": "&iopf;", "ι": "&iota;", "¿": "&iquest;", "𝒾": "&iscr;", "⋹": "&isinE;", "⋵": "&isindot;", "⋴": "&isins;", "⋳": "&isinsv;", "ĩ": "&itilde;", "і": "&iukcy;", "ï": "&iuml;", "ĵ": "&jcirc;", "й": "&jcy;", "𝔧": "&jfr;", "ȷ": "&jmath;", "𝕛": "&jopf;", "𝒿": "&jscr;", "ј": "&jsercy;", "є": "&jukcy;", "κ": "&kappa;", "ϰ": "&varkappa;", "ķ": "&kcedil;", "к": "&kcy;", "𝔨": "&kfr;", "ĸ": "&kgreen;", "х": "&khcy;", "ќ": "&kjcy;", "𝕜": "&kopf;", "𝓀": "&kscr;", "⤛": "&lAtail;", "⤎": "&lBarr;", "⪋": "&lesseqqgtr;", "⥢": "&lHar;", "ĺ": "&lacute;", "⦴": "&laemptyv;", "λ": "&lambda;", "⦑": "&langd;", "⪅": "&lessapprox;", "«": "&laquo;", "⤟": "&larrbfs;", "⤝": "&larrfs;", "↫": "&looparrowleft;", "⤹": "&larrpl;", "⥳": "&larrsim;", "↢": "&leftarrowtail;", "⪫": "&lat;", "⤙": "&latail;", "⪭": "&late;", "⪭︀": "&lates;", "⤌": "&lbarr;", "❲": "&lbbrk;", "{": "&lcub;", "[": "&lsqb;", "⦋": "&lbrke;", "⦏": "&lbrksld;", "⦍": "&lbrkslu;", "ľ": "&lcaron;", "ļ": "&lcedil;", "л": "&lcy;", "⤶": "&ldca;", "⥧": "&ldrdhar;", "⥋": "&ldrushar;", "↲": "&ldsh;", "≤": "&leq;", "⇇": "&llarr;", "⋋": "&lthree;", "⪨": "&lescc;", "⩿": "&lesdot;", "⪁": "&lesdoto;", "⪃": "&lesdotor;", "⋚︀": "&lesg;", "⪓": "&lesges;", "⋖": "&ltdot;", "⥼": "&lfisht;", "𝔩": "&lfr;", "⪑": "&lgE;", "⥪": "&lharul;", "▄": "&lhblk;", "љ": "&ljcy;", "⥫": "&llhard;", "◺": "&lltri;", "ŀ": "&lmidot;", "⎰": "&lmoustache;", "≨": "&lneqq;", "⪉": "&lnapprox;", "⪇": "&lneq;", "⋦": "&lnsim;", "⟬": "&loang;", "⇽": "&loarr;", "⟼": "&xmap;", "↬": "&rarrlp;", "⦅": "&lopar;", "𝕝": "&lopf;", "⨭": "&loplus;", "⨴": "&lotimes;", "∗": "&lowast;", "◊": "&lozenge;", "(": "&lpar;", "⦓": "&lparlt;", "⥭": "&lrhard;", "‎": "&lrm;", "⊿": "&lrtri;", "‹": "&lsaquo;", "𝓁": "&lscr;", "⪍": "&lsime;", "⪏": "&lsimg;", "‚": "&sbquo;", "ł": "&lstrok;", "⪦": "&ltcc;", "⩹": "&ltcir;", "⋉": "&ltimes;", "⥶": "&ltlarr;", "⩻": "&ltquest;", "⦖": "&ltrPar;", "◃": "&triangleleft;", "⥊": "&lurdshar;", "⥦": "&luruhar;", "≨︀": "&lvnE;", "∺": "&mDDot;", "¯": "&strns;", "♂": "&male;", "✠": "&maltese;", "▮": "&marker;", "⨩": "&mcomma;", "м": "&mcy;", "—": "&mdash;", "𝔪": "&mfr;", "℧": "&mho;", "µ": "&micro;", "⫰": "&midcir;", "−": "&minus;", "⨪": "&minusdu;", "⫛": "&mlcp;", "⊧": "&models;", "𝕞": "&mopf;", "𝓂": "&mscr;", "μ": "&mu;", "⊸": "&mumap;", "⋙̸": "&nGg;", "≫⃒": "&nGt;", "⇍": "&nlArr;", "⇎": "&nhArr;", "⋘̸": "&nLl;", "≪⃒": "&nLt;", "⇏": "&nrArr;", "⊯": "&nVDash;", "⊮": "&nVdash;", "ń": "&nacute;", "∠⃒": "&nang;", "⩰̸": "&napE;", "≋̸": "&napid;", "ŉ": "&napos;", "♮": "&natural;", "⩃": "&ncap;", "ň": "&ncaron;", "ņ": "&ncedil;", "⩭̸": "&ncongdot;", "⩂": "&ncup;", "н": "&ncy;", "–": "&ndash;", "⇗": "&neArr;", "⤤": "&nearhk;", "≐̸": "&nedot;", "⤨": "&toea;", "𝔫": "&nfr;", "↮": "&nleftrightarrow;", "⫲": "&nhpar;", "⋼": "&nis;", "⋺": "&nisd;", "њ": "&njcy;", "≦̸": "&nleqq;", "↚": "&nleftarrow;", "‥": "&nldr;", "𝕟": "&nopf;", "¬": "&not;", "⋹̸": "&notinE;", "⋵̸": "&notindot;", "⋷": "&notinvb;", "⋶": "&notinvc;", "⋾": "&notnivb;", "⋽": "&notnivc;", "⫽⃥": "&nparsl;", "∂̸": "&npart;", "⨔": "&npolint;", "↛": "&nrightarrow;", "⤳̸": "&nrarrc;", "↝̸": "&nrarrw;", "𝓃": "&nscr;", "⊄": "&nsub;", "⫅̸": "&nsubseteqq;", "⊅": "&nsup;", "⫆̸": "&nsupseteqq;", "ñ": "&ntilde;", "ν": "&nu;", "#": "&num;", "№": "&numero;", " ": "&numsp;", "⊭": "&nvDash;", "⤄": "&nvHarr;", "≍⃒": "&nvap;", "⊬": "&nvdash;", "≥⃒": "&nvge;", ">⃒": "&nvgt;", "⧞": "&nvinfin;", "⤂": "&nvlArr;", "≤⃒": "&nvle;", "<⃒": "&nvlt;", "⊴⃒": "&nvltrie;", "⤃": "&nvrArr;", "⊵⃒": "&nvrtrie;", "∼⃒": "&nvsim;", "⇖": "&nwArr;", "⤣": "&nwarhk;", "⤧": "&nwnear;", "ó": "&oacute;", "ô": "&ocirc;", "о": "&ocy;", "ő": "&odblac;", "⨸": "&odiv;", "⦼": "&odsold;", "œ": "&oelig;", "⦿": "&ofcir;", "𝔬": "&ofr;", "˛": "&ogon;", "ò": "&ograve;", "⧁": "&ogt;", "⦵": "&ohbar;", "⦾": "&olcir;", "⦻": "&olcross;", "⧀": "&olt;", "ō": "&omacr;", "ω": "&omega;", "ο": "&omicron;", "⦶": "&omid;", "𝕠": "&oopf;", "⦷": "&opar;", "⦹": "&operp;", "∨": "&vee;", "⩝": "&ord;", "ℴ": "&oscr;", "ª": "&ordf;", "º": "&ordm;", "⊶": "&origof;", "⩖": "&oror;", "⩗": "&orslope;", "⩛": "&orv;", "ø": "&oslash;", "⊘": "&osol;", "õ": "&otilde;", "⨶": "&otimesas;", "ö": "&ouml;", "⌽": "&ovbar;", "¶": "&para;", "⫳": "&parsim;", "⫽": "&parsl;", "п": "&pcy;", "%": "&percnt;", ".": "&period;", "‰": "&permil;", "‱": "&pertenk;", "𝔭": "&pfr;", "φ": "&phi;", "ϕ": "&varphi;", "☎": "&phone;", "π": "&pi;", "ϖ": "&varpi;", "ℎ": "&planckh;", "+": "&plus;", "⨣": "&plusacir;", "⨢": "&pluscir;", "⨥": "&plusdu;", "⩲": "&pluse;", "⨦": "&plussim;", "⨧": "&plustwo;", "⨕": "&pointint;", "𝕡": "&popf;", "£": "&pound;", "⪳": "&prE;", "⪷": "&precapprox;", "⪹": "&prnap;", "⪵": "&prnE;", "⋨": "&prnsim;", "′": "&prime;", "⌮": "&profalar;", "⌒": "&profline;", "⌓": "&profsurf;", "⊰": "&prurel;", "𝓅": "&pscr;", "ψ": "&psi;", " ": "&puncsp;", "𝔮": "&qfr;", "𝕢": "&qopf;", "⁗": "&qprime;", "𝓆": "&qscr;", "⨖": "&quatint;", "?": "&quest;", "⤜": "&rAtail;", "⥤": "&rHar;", "∽̱": "&race;", "ŕ": "&racute;", "⦳": "&raemptyv;", "⦒": "&rangd;", "⦥": "&range;", "»": "&raquo;", "⥵": "&rarrap;", "⤠": "&rarrbfs;", "⤳": "&rarrc;", "⤞": "&rarrfs;", "⥅": "&rarrpl;", "⥴": "&rarrsim;", "↣": "&rightarrowtail;", "↝": "&rightsquigarrow;", "⤚": "&ratail;", "∶": "&ratio;", "❳": "&rbbrk;", "}": "&rcub;", "]": "&rsqb;", "⦌": "&rbrke;", "⦎": "&rbrksld;", "⦐": "&rbrkslu;", "ř": "&rcaron;", "ŗ": "&rcedil;", "р": "&rcy;", "⤷": "&rdca;", "⥩": "&rdldhar;", "↳": "&rdsh;", "▭": "&rect;", "⥽": "&rfisht;", "𝔯": "&rfr;", "⥬": "&rharul;", "ρ": "&rho;", "ϱ": "&varrho;", "⇉": "&rrarr;", "⋌": "&rthree;", "˚": "&ring;", "‏": "&rlm;", "⎱": "&rmoustache;", "⫮": "&rnmid;", "⟭": "&roang;", "⇾": "&roarr;", "⦆": "&ropar;", "𝕣": "&ropf;", "⨮": "&roplus;", "⨵": "&rotimes;", ")": "&rpar;", "⦔": "&rpargt;", "⨒": "&rppolint;", "›": "&rsaquo;", "𝓇": "&rscr;", "⋊": "&rtimes;", "▹": "&triangleright;", "⧎": "&rtriltri;", "⥨": "&ruluhar;", "℞": "&rx;", "ś": "&sacute;", "⪴": "&scE;", "⪸": "&succapprox;", "š": "&scaron;", "ş": "&scedil;", "ŝ": "&scirc;", "⪶": "&succneqq;", "⪺": "&succnapprox;", "⋩": "&succnsim;", "⨓": "&scpolint;", "с": "&scy;", "⋅": "&sdot;", "⩦": "&sdote;", "⇘": "&seArr;", "§": "&sect;", ";": "&semi;", "⤩": "&tosa;", "✶": "&sext;", "𝔰": "&sfr;", "♯": "&sharp;", "щ": "&shchcy;", "ш": "&shcy;", "­": "&shy;", "σ": "&sigma;", "ς": "&varsigma;", "⩪": "&simdot;", "⪞": "&simg;", "⪠": "&simgE;", "⪝": "&siml;", "⪟": "&simlE;", "≆": "&simne;", "⨤": "&simplus;", "⥲": "&simrarr;", "⨳": "&smashp;", "⧤": "&smeparsl;", "⌣": "&ssmile;", "⪪": "&smt;", "⪬": "&smte;", "⪬︀": "&smtes;", "ь": "&softcy;", "/": "&sol;", "⧄": "&solb;", "⌿": "&solbar;", "𝕤": "&sopf;", "♠": "&spadesuit;", "⊓︀": "&sqcaps;", "⊔︀": "&sqcups;", "𝓈": "&sscr;", "☆": "&star;", "⊂": "&subset;", "⫅": "&subseteqq;", "⪽": "&subdot;", "⫃": "&subedot;", "⫁": "&submult;", "⫋": "&subsetneqq;", "⊊": "&subsetneq;", "⪿": "&subplus;", "⥹": "&subrarr;", "⫇": "&subsim;", "⫕": "&subsub;", "⫓": "&subsup;", "♪": "&sung;", "¹": "&sup1;", "²": "&sup2;", "³": "&sup3;", "⫆": "&supseteqq;", "⪾": "&supdot;", "⫘": "&supdsub;", "⫄": "&supedot;", "⟉": "&suphsol;", "⫗": "&suphsub;", "⥻": "&suplarr;", "⫂": "&supmult;", "⫌": "&supsetneqq;", "⊋": "&supsetneq;", "⫀": "&supplus;", "⫈": "&supsim;", "⫔": "&supsub;", "⫖": "&supsup;", "⇙": "&swArr;", "⤪": "&swnwar;", "ß": "&szlig;", "⌖": "&target;", "τ": "&tau;", "ť": "&tcaron;", "ţ": "&tcedil;", "т": "&tcy;", "⌕": "&telrec;", "𝔱": "&tfr;", "θ": "&theta;", "ϑ": "&vartheta;", "þ": "&thorn;", "×": "&times;", "⨱": "&timesbar;", "⨰": "&timesd;", "⌶": "&topbot;", "⫱": "&topcir;", "𝕥": "&topf;", "⫚": "&topfork;", "‴": "&tprime;", "▵": "&utri;", "≜": "&trie;", "◬": "&tridot;", "⨺": "&triminus;", "⨹": "&triplus;", "⧍": "&trisb;", "⨻": "&tritime;", "⏢": "&trpezium;", "𝓉": "&tscr;", "ц": "&tscy;", "ћ": "&tshcy;", "ŧ": "&tstrok;", "⥣": "&uHar;", "ú": "&uacute;", "ў": "&ubrcy;", "ŭ": "&ubreve;", "û": "&ucirc;", "у": "&ucy;", "ű": "&udblac;", "⥾": "&ufisht;", "𝔲": "&ufr;", "ù": "&ugrave;", "▀": "&uhblk;", "⌜": "&ulcorner;", "⌏": "&ulcrop;", "◸": "&ultri;", "ū": "&umacr;", "ų": "&uogon;", "𝕦": "&uopf;", "υ": "&upsilon;", "⇈": "&uuarr;", "⌝": "&urcorner;", "⌎": "&urcrop;", "ů": "&uring;", "◹": "&urtri;", "𝓊": "&uscr;", "⋰": "&utdot;", "ũ": "&utilde;", "ü": "&uuml;", "⦧": "&uwangle;", "⫨": "&vBar;", "⫩": "&vBarv;", "⦜": "&vangrt;", "⊊︀": "&vsubne;", "⫋︀": "&vsubnE;", "⊋︀": "&vsupne;", "⫌︀": "&vsupnE;", "в": "&vcy;", "⊻": "&veebar;", "≚": "&veeeq;", "⋮": "&vellip;", "𝔳": "&vfr;", "𝕧": "&vopf;", "𝓋": "&vscr;", "⦚": "&vzigzag;", "ŵ": "&wcirc;", "⩟": "&wedbar;", "≙": "&wedgeq;", "℘": "&wp;", "𝔴": "&wfr;", "𝕨": "&wopf;", "𝓌": "&wscr;", "𝔵": "&xfr;", "ξ": "&xi;", "⋻": "&xnis;", "𝕩": "&xopf;", "𝓍": "&xscr;", "ý": "&yacute;", "я": "&yacy;", "ŷ": "&ycirc;", "ы": "&ycy;", "¥": "&yen;", "𝔶": "&yfr;", "ї": "&yicy;", "𝕪": "&yopf;", "𝓎": "&yscr;", "ю": "&yucy;", "ÿ": "&yuml;", "ź": "&zacute;", "ž": "&zcaron;", "з": "&zcy;", "ż": "&zdot;", "ζ": "&zeta;", "𝔷": "&zfr;", "ж": "&zhcy;", "⇝": "&zigrarr;", "𝕫": "&zopf;", "𝓏": "&zscr;", "‍": "&zwj;", "‌": "&zwnj;" } } };
  }
});

// node_modules/html-entities/lib/numeric-unicode-map.js
var require_numeric_unicode_map = __commonJS({
  "node_modules/html-entities/lib/numeric-unicode-map.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.numericUnicodeMap = { 0: 65533, 128: 8364, 130: 8218, 131: 402, 132: 8222, 133: 8230, 134: 8224, 135: 8225, 136: 710, 137: 8240, 138: 352, 139: 8249, 140: 338, 142: 381, 145: 8216, 146: 8217, 147: 8220, 148: 8221, 149: 8226, 150: 8211, 151: 8212, 152: 732, 153: 8482, 154: 353, 155: 8250, 156: 339, 158: 382, 159: 376 };
  }
});

// node_modules/html-entities/lib/surrogate-pairs.js
var require_surrogate_pairs = __commonJS({
  "node_modules/html-entities/lib/surrogate-pairs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.fromCodePoint = String.fromCodePoint || function(astralCodePoint) {
      return String.fromCharCode(Math.floor((astralCodePoint - 65536) / 1024) + 55296, (astralCodePoint - 65536) % 1024 + 56320);
    };
    exports2.getCodePoint = String.prototype.codePointAt ? function(input, position3) {
      return input.codePointAt(position3);
    } : function(input, position3) {
      return (input.charCodeAt(position3) - 55296) * 1024 + input.charCodeAt(position3 + 1) - 56320 + 65536;
    };
    exports2.highSurrogateFrom = 55296;
    exports2.highSurrogateTo = 56319;
  }
});

// node_modules/html-entities/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/html-entities/lib/index.js"(exports2) {
    "use strict";
    var __assign7 = exports2 && exports2.__assign || function() {
      __assign7 = Object.assign || function(t20) {
        for (var s20, i15 = 1, n12 = arguments.length; i15 < n12; i15++) {
          s20 = arguments[i15];
          for (var p12 in s20)
            if (Object.prototype.hasOwnProperty.call(s20, p12))
              t20[p12] = s20[p12];
        }
        return t20;
      };
      return __assign7.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var named_references_1 = require_named_references();
    var numeric_unicode_map_1 = require_numeric_unicode_map();
    var surrogate_pairs_1 = require_surrogate_pairs();
    var allNamedReferences = __assign7(__assign7({}, named_references_1.namedReferences), { all: named_references_1.namedReferences.html5 });
    var encodeRegExps = {
      specialChars: /[<>'"&]/g,
      nonAscii: /(?:[<>'"&\u0080-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
      nonAsciiPrintable: /(?:[<>'"&\x01-\x08\x11-\x15\x17-\x1F\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g,
      extensive: /(?:[\x01-\x0c\x0e-\x1f\x21-\x2c\x2e-\x2f\x3a-\x40\x5b-\x60\x7b-\x7d\x7f-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g
    };
    var defaultEncodeOptions = {
      mode: "specialChars",
      level: "all",
      numeric: "decimal"
    };
    function encode2(text, _a) {
      var _b = _a === void 0 ? defaultEncodeOptions : _a, _c = _b.mode, mode = _c === void 0 ? "specialChars" : _c, _d = _b.numeric, numeric = _d === void 0 ? "decimal" : _d, _e4 = _b.level, level = _e4 === void 0 ? "all" : _e4;
      if (!text) {
        return "";
      }
      var encodeRegExp = encodeRegExps[mode];
      var references = allNamedReferences[level].characters;
      var isHex = numeric === "hexadecimal";
      encodeRegExp.lastIndex = 0;
      var _b = encodeRegExp.exec(text);
      var _c;
      if (_b) {
        _c = "";
        var _d = 0;
        do {
          if (_d !== _b.index) {
            _c += text.substring(_d, _b.index);
          }
          var _e4 = _b[0];
          var result_1 = references[_e4];
          if (!result_1) {
            var code_1 = _e4.length > 1 ? surrogate_pairs_1.getCodePoint(_e4, 0) : _e4.charCodeAt(0);
            result_1 = (isHex ? "&#x" + code_1.toString(16) : "&#" + code_1) + ";";
          }
          _c += result_1;
          _d = _b.index + _e4.length;
        } while (_b = encodeRegExp.exec(text));
        if (_d !== text.length) {
          _c += text.substring(_d);
        }
      } else {
        _c = text;
      }
      return _c;
    }
    exports2.encode = encode2;
    var defaultDecodeOptions = {
      scope: "body",
      level: "all"
    };
    var strict = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+);/g;
    var attribute = /&(?:#\d+|#[xX][\da-fA-F]+|[0-9a-zA-Z]+)[;=]?/g;
    var baseDecodeRegExps = {
      xml: {
        strict,
        attribute,
        body: named_references_1.bodyRegExps.xml
      },
      html4: {
        strict,
        attribute,
        body: named_references_1.bodyRegExps.html4
      },
      html5: {
        strict,
        attribute,
        body: named_references_1.bodyRegExps.html5
      }
    };
    var decodeRegExps = __assign7(__assign7({}, baseDecodeRegExps), { all: baseDecodeRegExps.html5 });
    var fromCharCode = String.fromCharCode;
    var outOfBoundsChar = fromCharCode(65533);
    var defaultDecodeEntityOptions = {
      level: "all"
    };
    function decodeEntity(entity, _a) {
      var _b = (_a === void 0 ? defaultDecodeEntityOptions : _a).level, level = _b === void 0 ? "all" : _b;
      if (!entity) {
        return "";
      }
      var _b = entity;
      var decodeEntityLastChar_1 = entity[entity.length - 1];
      if (false) {
        _b = entity;
      } else if (false) {
        _b = entity;
      } else {
        var decodeResultByReference_1 = allNamedReferences[level].entities[entity];
        if (decodeResultByReference_1) {
          _b = decodeResultByReference_1;
        } else if (entity[0] === "&" && entity[1] === "#") {
          var decodeSecondChar_1 = entity[2];
          var decodeCode_1 = decodeSecondChar_1 == "x" || decodeSecondChar_1 == "X" ? parseInt(entity.substr(3), 16) : parseInt(entity.substr(2));
          _b = decodeCode_1 >= 1114111 ? outOfBoundsChar : decodeCode_1 > 65535 ? surrogate_pairs_1.fromCodePoint(decodeCode_1) : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode_1] || decodeCode_1);
        }
      }
      return _b;
    }
    exports2.decodeEntity = decodeEntity;
    function decode2(text, _a) {
      var decodeSecondChar_1 = _a === void 0 ? defaultDecodeOptions : _a, decodeCode_1 = decodeSecondChar_1.level, level = decodeCode_1 === void 0 ? "all" : decodeCode_1, _b = decodeSecondChar_1.scope, scope = _b === void 0 ? level === "xml" ? "strict" : "body" : _b;
      if (!text) {
        return "";
      }
      var decodeRegExp = decodeRegExps[level][scope];
      var references = allNamedReferences[level].entities;
      var isAttribute = scope === "attribute";
      var isStrict = scope === "strict";
      decodeRegExp.lastIndex = 0;
      var replaceMatch_1 = decodeRegExp.exec(text);
      var replaceResult_1;
      if (replaceMatch_1) {
        replaceResult_1 = "";
        var replaceLastIndex_1 = 0;
        do {
          if (replaceLastIndex_1 !== replaceMatch_1.index) {
            replaceResult_1 += text.substring(replaceLastIndex_1, replaceMatch_1.index);
          }
          var replaceInput_1 = replaceMatch_1[0];
          var decodeResult_1 = replaceInput_1;
          var decodeEntityLastChar_2 = replaceInput_1[replaceInput_1.length - 1];
          if (isAttribute && decodeEntityLastChar_2 === "=") {
            decodeResult_1 = replaceInput_1;
          } else if (isStrict && decodeEntityLastChar_2 !== ";") {
            decodeResult_1 = replaceInput_1;
          } else {
            var decodeResultByReference_2 = references[replaceInput_1];
            if (decodeResultByReference_2) {
              decodeResult_1 = decodeResultByReference_2;
            } else if (replaceInput_1[0] === "&" && replaceInput_1[1] === "#") {
              var decodeSecondChar_2 = replaceInput_1[2];
              var decodeCode_2 = decodeSecondChar_2 == "x" || decodeSecondChar_2 == "X" ? parseInt(replaceInput_1.substr(3), 16) : parseInt(replaceInput_1.substr(2));
              decodeResult_1 = decodeCode_2 >= 1114111 ? outOfBoundsChar : decodeCode_2 > 65535 ? surrogate_pairs_1.fromCodePoint(decodeCode_2) : fromCharCode(numeric_unicode_map_1.numericUnicodeMap[decodeCode_2] || decodeCode_2);
            }
          }
          replaceResult_1 += decodeResult_1;
          replaceLastIndex_1 = replaceMatch_1.index + replaceInput_1.length;
        } while (replaceMatch_1 = decodeRegExp.exec(text));
        if (replaceLastIndex_1 !== text.length) {
          replaceResult_1 += text.substring(replaceLastIndex_1);
        }
      } else {
        replaceResult_1 = text;
      }
      return replaceResult_1;
    }
    exports2.decode = decode2;
  }
});

// node_modules/remark-parse/node_modules/mdast-util-to-string/index.js
var require_mdast_util_to_string = __commonJS({
  "node_modules/remark-parse/node_modules/mdast-util-to-string/index.js"(exports2, module2) {
    "use strict";
    module2.exports = toString7;
    function toString7(node) {
      return node && (node.value || node.alt || node.title || "children" in node && all2(node.children) || "length" in node && all2(node)) || "";
    }
    function all2(values3) {
      var result = [];
      var index2 = -1;
      while (++index2 < values3.length) {
        result[index2] = toString7(values3[index2]);
      }
      return result.join("");
    }
  }
});

// node_modules/micromark/dist/constant/assign.js
var require_assign = __commonJS({
  "node_modules/micromark/dist/constant/assign.js"(exports2, module2) {
    "use strict";
    var assign = Object.assign;
    module2.exports = assign;
  }
});

// node_modules/micromark/dist/constant/has-own-property.js
var require_has_own_property = __commonJS({
  "node_modules/micromark/dist/constant/has-own-property.js"(exports2, module2) {
    "use strict";
    var own = {}.hasOwnProperty;
    module2.exports = own;
  }
});

// node_modules/micromark/dist/util/normalize-identifier.js
var require_normalize_identifier = __commonJS({
  "node_modules/micromark/dist/util/normalize-identifier.js"(exports2, module2) {
    "use strict";
    function normalizeIdentifier(value) {
      return value.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase();
    }
    module2.exports = normalizeIdentifier;
  }
});

// node_modules/micromark/dist/constant/from-char-code.js
var require_from_char_code = __commonJS({
  "node_modules/micromark/dist/constant/from-char-code.js"(exports2, module2) {
    "use strict";
    var fromCharCode = String.fromCharCode;
    module2.exports = fromCharCode;
  }
});

// node_modules/micromark/dist/util/safe-from-int.js
var require_safe_from_int = __commonJS({
  "node_modules/micromark/dist/util/safe-from-int.js"(exports2, module2) {
    "use strict";
    var fromCharCode = require_from_char_code();
    function safeFromInt(value, base) {
      var code = parseInt(value, base);
      if (
        // C0 except for HT, LF, FF, CR, space
        code < 9 || code === 11 || code > 13 && code < 32 || // Control character (DEL) of the basic block and C1 controls.
        code > 126 && code < 160 || // Lone high surrogates and low surrogates.
        code > 55295 && code < 57344 || // Noncharacters.
        code > 64975 && code < 65008 || (code & 65535) === 65535 || (code & 65535) === 65534 || // Out of range
        code > 1114111
      ) {
        return "�";
      }
      return fromCharCode(code);
    }
    module2.exports = safeFromInt;
  }
});

// node_modules/micromark/dist/character/markdown-line-ending.js
var require_markdown_line_ending = __commonJS({
  "node_modules/micromark/dist/character/markdown-line-ending.js"(exports2, module2) {
    "use strict";
    function markdownLineEnding(code) {
      return code < -2;
    }
    module2.exports = markdownLineEnding;
  }
});

// node_modules/micromark/dist/character/markdown-space.js
var require_markdown_space = __commonJS({
  "node_modules/micromark/dist/character/markdown-space.js"(exports2, module2) {
    "use strict";
    function markdownSpace(code) {
      return code === -2 || code === -1 || code === 32;
    }
    module2.exports = markdownSpace;
  }
});

// node_modules/micromark/dist/tokenize/factory-space.js
var require_factory_space = __commonJS({
  "node_modules/micromark/dist/tokenize/factory-space.js"(exports2, module2) {
    "use strict";
    var markdownSpace = require_markdown_space();
    function spaceFactory(effects, ok, type, max4) {
      var limit = max4 ? max4 - 1 : Infinity;
      var size2 = 0;
      return start3;
      function start3(code) {
        if (markdownSpace(code)) {
          effects.enter(type);
          return prefix3(code);
        }
        return ok(code);
      }
      function prefix3(code) {
        if (markdownSpace(code) && size2++ < limit) {
          effects.consume(code);
          return prefix3;
        }
        effects.exit(type);
        return ok(code);
      }
    }
    module2.exports = spaceFactory;
  }
});

// node_modules/micromark/dist/initialize/content.js
var require_content = __commonJS({
  "node_modules/micromark/dist/initialize/content.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var markdownLineEnding = require_markdown_line_ending();
    var factorySpace = require_factory_space();
    var tokenize2 = initializeContent;
    function initializeContent(effects) {
      var contentStart = effects.attempt(
        this.parser.constructs.contentInitial,
        afterContentStartConstruct,
        paragraphInitial
      );
      var previous;
      return contentStart;
      function afterContentStartConstruct(code) {
        if (code === null) {
          effects.consume(code);
          return;
        }
        effects.enter("lineEnding");
        effects.consume(code);
        effects.exit("lineEnding");
        return factorySpace(effects, contentStart, "linePrefix");
      }
      function paragraphInitial(code) {
        effects.enter("paragraph");
        return lineStart(code);
      }
      function lineStart(code) {
        var token2 = effects.enter("chunkText", {
          contentType: "text",
          previous
        });
        if (previous) {
          previous.next = token2;
        }
        previous = token2;
        return data(code);
      }
      function data(code) {
        if (code === null) {
          effects.exit("chunkText");
          effects.exit("paragraph");
          effects.consume(code);
          return;
        }
        if (markdownLineEnding(code)) {
          effects.consume(code);
          effects.exit("chunkText");
          return lineStart;
        }
        effects.consume(code);
        return data;
      }
    }
    exports2.tokenize = tokenize2;
  }
});

// node_modules/micromark/dist/tokenize/partial-blank-line.js
var require_partial_blank_line = __commonJS({
  "node_modules/micromark/dist/tokenize/partial-blank-line.js"(exports2, module2) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var factorySpace = require_factory_space();
    var partialBlankLine = {
      tokenize: tokenizePartialBlankLine,
      partial: true
    };
    function tokenizePartialBlankLine(effects, ok, nok) {
      return factorySpace(effects, afterWhitespace, "linePrefix");
      function afterWhitespace(code) {
        return code === null || markdownLineEnding(code) ? ok(code) : nok(code);
      }
    }
    module2.exports = partialBlankLine;
  }
});

// node_modules/micromark/dist/initialize/document.js
var require_document = __commonJS({
  "node_modules/micromark/dist/initialize/document.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var markdownLineEnding = require_markdown_line_ending();
    var factorySpace = require_factory_space();
    var partialBlankLine = require_partial_blank_line();
    var tokenize2 = initializeDocument;
    var containerConstruct = {
      tokenize: tokenizeContainer
    };
    var lazyFlowConstruct = {
      tokenize: tokenizeLazyFlow
    };
    function initializeDocument(effects) {
      var self2 = this;
      var stack = [];
      var continued = 0;
      var inspectConstruct = {
        tokenize: tokenizeInspect,
        partial: true
      };
      var inspectResult;
      var childFlow;
      var childToken;
      return start3;
      function start3(code) {
        if (continued < stack.length) {
          self2.containerState = stack[continued][1];
          return effects.attempt(
            stack[continued][0].continuation,
            documentContinue,
            documentContinued
          )(code);
        }
        return documentContinued(code);
      }
      function documentContinue(code) {
        continued++;
        return start3(code);
      }
      function documentContinued(code) {
        if (inspectResult && inspectResult.flowContinue) {
          return flowStart(code);
        }
        self2.interrupt = childFlow && childFlow.currentConstruct && childFlow.currentConstruct.interruptible;
        self2.containerState = {};
        return effects.attempt(
          containerConstruct,
          containerContinue,
          flowStart
        )(code);
      }
      function containerContinue(code) {
        stack.push([self2.currentConstruct, self2.containerState]);
        self2.containerState = void 0;
        return documentContinued(code);
      }
      function flowStart(code) {
        if (code === null) {
          exitContainers(0, true);
          effects.consume(code);
          return;
        }
        childFlow = childFlow || self2.parser.flow(self2.now());
        effects.enter("chunkFlow", {
          contentType: "flow",
          previous: childToken,
          _tokenizer: childFlow
        });
        return flowContinue(code);
      }
      function flowContinue(code) {
        if (code === null) {
          continueFlow(effects.exit("chunkFlow"));
          return flowStart(code);
        }
        if (markdownLineEnding(code)) {
          effects.consume(code);
          continueFlow(effects.exit("chunkFlow"));
          return effects.check(inspectConstruct, documentAfterPeek);
        }
        effects.consume(code);
        return flowContinue;
      }
      function documentAfterPeek(code) {
        exitContainers(
          inspectResult.continued,
          inspectResult && inspectResult.flowEnd
        );
        continued = 0;
        return start3(code);
      }
      function continueFlow(token2) {
        if (childToken)
          childToken.next = token2;
        childToken = token2;
        childFlow.lazy = inspectResult && inspectResult.lazy;
        childFlow.defineSkip(token2.start);
        childFlow.write(self2.sliceStream(token2));
      }
      function exitContainers(size2, end2) {
        var index2 = stack.length;
        if (childFlow && end2) {
          childFlow.write([null]);
          childToken = childFlow = void 0;
        }
        while (index2-- > size2) {
          self2.containerState = stack[index2][1];
          stack[index2][0].exit.call(self2, effects);
        }
        stack.length = size2;
      }
      function tokenizeInspect(effects2, ok) {
        var subcontinued = 0;
        inspectResult = {};
        return inspectStart;
        function inspectStart(code) {
          if (subcontinued < stack.length) {
            self2.containerState = stack[subcontinued][1];
            return effects2.attempt(
              stack[subcontinued][0].continuation,
              inspectContinue,
              inspectLess
            )(code);
          }
          if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
            inspectResult.flowContinue = true;
            return inspectDone(code);
          }
          self2.interrupt = childFlow.currentConstruct && childFlow.currentConstruct.interruptible;
          self2.containerState = {};
          return effects2.attempt(
            containerConstruct,
            inspectFlowEnd,
            inspectDone
          )(code);
        }
        function inspectContinue(code) {
          subcontinued++;
          return self2.containerState._closeFlow ? inspectFlowEnd(code) : inspectStart(code);
        }
        function inspectLess(code) {
          if (childFlow.currentConstruct && childFlow.currentConstruct.lazy) {
            self2.containerState = {};
            return effects2.attempt(
              containerConstruct,
              inspectFlowEnd,
              // Maybe flow, or a blank line?
              effects2.attempt(
                lazyFlowConstruct,
                inspectFlowEnd,
                effects2.check(partialBlankLine, inspectFlowEnd, inspectLazy)
              )
            )(code);
          }
          return inspectFlowEnd(code);
        }
        function inspectLazy(code) {
          subcontinued = stack.length;
          inspectResult.lazy = true;
          inspectResult.flowContinue = true;
          return inspectDone(code);
        }
        function inspectFlowEnd(code) {
          inspectResult.flowEnd = true;
          return inspectDone(code);
        }
        function inspectDone(code) {
          inspectResult.continued = subcontinued;
          self2.interrupt = self2.containerState = void 0;
          return ok(code);
        }
      }
    }
    function tokenizeContainer(effects, ok, nok) {
      return factorySpace(
        effects,
        effects.attempt(this.parser.constructs.document, ok, nok),
        "linePrefix",
        this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
      );
    }
    function tokenizeLazyFlow(effects, ok, nok) {
      return factorySpace(
        effects,
        effects.lazy(this.parser.constructs.flow, ok, nok),
        "linePrefix",
        this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
      );
    }
    exports2.tokenize = tokenize2;
  }
});

// node_modules/micromark/dist/util/size-chunks.js
var require_size_chunks = __commonJS({
  "node_modules/micromark/dist/util/size-chunks.js"(exports2, module2) {
    "use strict";
    function sizeChunks(chunks) {
      var index2 = -1;
      var size2 = 0;
      while (++index2 < chunks.length) {
        size2 += typeof chunks[index2] === "string" ? chunks[index2].length : 1;
      }
      return size2;
    }
    module2.exports = sizeChunks;
  }
});

// node_modules/micromark/dist/util/prefix-size.js
var require_prefix_size = __commonJS({
  "node_modules/micromark/dist/util/prefix-size.js"(exports2, module2) {
    "use strict";
    var sizeChunks = require_size_chunks();
    function prefixSize(events, type) {
      var tail = events[events.length - 1];
      if (!tail || tail[1].type !== type)
        return 0;
      return sizeChunks(tail[2].sliceStream(tail[1]));
    }
    module2.exports = prefixSize;
  }
});

// node_modules/micromark/dist/constant/splice.js
var require_splice = __commonJS({
  "node_modules/micromark/dist/constant/splice.js"(exports2, module2) {
    "use strict";
    var splice6 = [].splice;
    module2.exports = splice6;
  }
});

// node_modules/micromark/dist/util/chunked-splice.js
var require_chunked_splice = __commonJS({
  "node_modules/micromark/dist/util/chunked-splice.js"(exports2, module2) {
    "use strict";
    var splice6 = require_splice();
    function chunkedSplice(list, start3, remove3, items) {
      var end2 = list.length;
      var chunkStart = 0;
      var parameters;
      if (start3 < 0) {
        start3 = -start3 > end2 ? 0 : end2 + start3;
      } else {
        start3 = start3 > end2 ? end2 : start3;
      }
      remove3 = remove3 > 0 ? remove3 : 0;
      if (items.length < 1e4) {
        parameters = Array.from(items);
        parameters.unshift(start3, remove3);
        splice6.apply(list, parameters);
      } else {
        if (remove3)
          splice6.apply(list, [start3, remove3]);
        while (chunkStart < items.length) {
          parameters = items.slice(chunkStart, chunkStart + 1e4);
          parameters.unshift(start3, 0);
          splice6.apply(list, parameters);
          chunkStart += 1e4;
          start3 += 1e4;
        }
      }
    }
    module2.exports = chunkedSplice;
  }
});

// node_modules/micromark/dist/util/shallow.js
var require_shallow = __commonJS({
  "node_modules/micromark/dist/util/shallow.js"(exports2, module2) {
    "use strict";
    var assign = require_assign();
    function shallow(object2) {
      return assign({}, object2);
    }
    module2.exports = shallow;
  }
});

// node_modules/micromark/dist/util/subtokenize.js
var require_subtokenize = __commonJS({
  "node_modules/micromark/dist/util/subtokenize.js"(exports2, module2) {
    "use strict";
    var assign = require_assign();
    var chunkedSplice = require_chunked_splice();
    var shallow = require_shallow();
    function subtokenize(events) {
      var jumps = {};
      var index2 = -1;
      var event;
      var lineIndex;
      var otherIndex;
      var otherEvent;
      var parameters;
      var subevents;
      var more;
      while (++index2 < events.length) {
        while (index2 in jumps) {
          index2 = jumps[index2];
        }
        event = events[index2];
        if (index2 && event[1].type === "chunkFlow" && events[index2 - 1][1].type === "listItemPrefix") {
          subevents = event[1]._tokenizer.events;
          otherIndex = 0;
          if (otherIndex < subevents.length && subevents[otherIndex][1].type === "lineEndingBlank") {
            otherIndex += 2;
          }
          if (otherIndex < subevents.length && subevents[otherIndex][1].type === "content") {
            while (++otherIndex < subevents.length) {
              if (subevents[otherIndex][1].type === "content") {
                break;
              }
              if (subevents[otherIndex][1].type === "chunkText") {
                subevents[otherIndex][1].isInFirstContentOfListItem = true;
                otherIndex++;
              }
            }
          }
        }
        if (event[0] === "enter") {
          if (event[1].contentType) {
            assign(jumps, subcontent(events, index2));
            index2 = jumps[index2];
            more = true;
          }
        } else if (event[1]._container || event[1]._movePreviousLineEndings) {
          otherIndex = index2;
          lineIndex = void 0;
          while (otherIndex--) {
            otherEvent = events[otherIndex];
            if (otherEvent[1].type === "lineEnding" || otherEvent[1].type === "lineEndingBlank") {
              if (otherEvent[0] === "enter") {
                if (lineIndex) {
                  events[lineIndex][1].type = "lineEndingBlank";
                }
                otherEvent[1].type = "lineEnding";
                lineIndex = otherIndex;
              }
            } else {
              break;
            }
          }
          if (lineIndex) {
            event[1].end = shallow(events[lineIndex][1].start);
            parameters = events.slice(lineIndex, index2);
            parameters.unshift(event);
            chunkedSplice(events, lineIndex, index2 - lineIndex + 1, parameters);
          }
        }
      }
      return !more;
    }
    function subcontent(events, eventIndex) {
      var token2 = events[eventIndex][1];
      var context = events[eventIndex][2];
      var startPosition = eventIndex - 1;
      var startPositions = [];
      var tokenizer = token2._tokenizer || context.parser[token2.contentType](token2.start);
      var childEvents = tokenizer.events;
      var jumps = [];
      var gaps = {};
      var stream;
      var previous;
      var index2;
      var entered;
      var end2;
      var adjust;
      while (token2) {
        while (events[++startPosition][1] !== token2) {
        }
        startPositions.push(startPosition);
        if (!token2._tokenizer) {
          stream = context.sliceStream(token2);
          if (!token2.next) {
            stream.push(null);
          }
          if (previous) {
            tokenizer.defineSkip(token2.start);
          }
          if (token2.isInFirstContentOfListItem) {
            tokenizer._gfmTasklistFirstContentOfListItem = true;
          }
          tokenizer.write(stream);
          if (token2.isInFirstContentOfListItem) {
            tokenizer._gfmTasklistFirstContentOfListItem = void 0;
          }
        }
        previous = token2;
        token2 = token2.next;
      }
      token2 = previous;
      index2 = childEvents.length;
      while (index2--) {
        if (childEvents[index2][0] === "enter") {
          entered = true;
        } else if (
          // Find a void token that includes a break.
          entered && childEvents[index2][1].type === childEvents[index2 - 1][1].type && childEvents[index2][1].start.line !== childEvents[index2][1].end.line
        ) {
          add4(childEvents.slice(index2 + 1, end2));
          token2._tokenizer = token2.next = void 0;
          token2 = token2.previous;
          end2 = index2 + 1;
        }
      }
      tokenizer.events = token2._tokenizer = token2.next = void 0;
      add4(childEvents.slice(0, end2));
      index2 = -1;
      adjust = 0;
      while (++index2 < jumps.length) {
        gaps[adjust + jumps[index2][0]] = adjust + jumps[index2][1];
        adjust += jumps[index2][1] - jumps[index2][0] - 1;
      }
      return gaps;
      function add4(slice) {
        var start3 = startPositions.pop();
        jumps.unshift([start3, start3 + slice.length - 1]);
        chunkedSplice(events, start3, 2, slice);
      }
    }
    module2.exports = subtokenize;
  }
});

// node_modules/micromark/dist/tokenize/content.js
var require_content2 = __commonJS({
  "node_modules/micromark/dist/tokenize/content.js"(exports2, module2) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var prefixSize = require_prefix_size();
    var subtokenize = require_subtokenize();
    var factorySpace = require_factory_space();
    var content = {
      tokenize: tokenizeContent,
      resolve: resolveContent,
      interruptible: true,
      lazy: true
    };
    var continuationConstruct = {
      tokenize: tokenizeContinuation,
      partial: true
    };
    function resolveContent(events) {
      subtokenize(events);
      return events;
    }
    function tokenizeContent(effects, ok) {
      var previous;
      return start3;
      function start3(code) {
        effects.enter("content");
        previous = effects.enter("chunkContent", {
          contentType: "content"
        });
        return data(code);
      }
      function data(code) {
        if (code === null) {
          return contentEnd(code);
        }
        if (markdownLineEnding(code)) {
          return effects.check(
            continuationConstruct,
            contentContinue,
            contentEnd
          )(code);
        }
        effects.consume(code);
        return data;
      }
      function contentEnd(code) {
        effects.exit("chunkContent");
        effects.exit("content");
        return ok(code);
      }
      function contentContinue(code) {
        effects.consume(code);
        effects.exit("chunkContent");
        previous = previous.next = effects.enter("chunkContent", {
          contentType: "content",
          previous
        });
        return data;
      }
    }
    function tokenizeContinuation(effects, ok, nok) {
      var self2 = this;
      return startLookahead;
      function startLookahead(code) {
        effects.enter("lineEnding");
        effects.consume(code);
        effects.exit("lineEnding");
        return factorySpace(effects, prefixed, "linePrefix");
      }
      function prefixed(code) {
        if (code === null || markdownLineEnding(code)) {
          return nok(code);
        }
        if (self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 || prefixSize(self2.events, "linePrefix") < 4) {
          return effects.interrupt(self2.parser.constructs.flow, nok, ok)(code);
        }
        return ok(code);
      }
    }
    module2.exports = content;
  }
});

// node_modules/micromark/dist/initialize/flow.js
var require_flow = __commonJS({
  "node_modules/micromark/dist/initialize/flow.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var content = require_content2();
    var factorySpace = require_factory_space();
    var partialBlankLine = require_partial_blank_line();
    var tokenize2 = initializeFlow;
    function initializeFlow(effects) {
      var self2 = this;
      var initial = effects.attempt(
        // Try to parse a blank line.
        partialBlankLine,
        atBlankEnding,
        // Try to parse initial flow (essentially, only code).
        effects.attempt(
          this.parser.constructs.flowInitial,
          afterConstruct,
          factorySpace(
            effects,
            effects.attempt(
              this.parser.constructs.flow,
              afterConstruct,
              effects.attempt(content, afterConstruct)
            ),
            "linePrefix"
          )
        )
      );
      return initial;
      function atBlankEnding(code) {
        if (code === null) {
          effects.consume(code);
          return;
        }
        effects.enter("lineEndingBlank");
        effects.consume(code);
        effects.exit("lineEndingBlank");
        self2.currentConstruct = void 0;
        return initial;
      }
      function afterConstruct(code) {
        if (code === null) {
          effects.consume(code);
          return;
        }
        effects.enter("lineEnding");
        effects.consume(code);
        effects.exit("lineEnding");
        self2.currentConstruct = void 0;
        return initial;
      }
    }
    exports2.tokenize = tokenize2;
  }
});

// node_modules/micromark/dist/initialize/text.js
var require_text = __commonJS({
  "node_modules/micromark/dist/initialize/text.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var assign = require_assign();
    var shallow = require_shallow();
    var text = initializeFactory("text");
    var string2 = initializeFactory("string");
    var resolver = {
      resolveAll: createResolver()
    };
    function initializeFactory(field) {
      return {
        tokenize: initializeText,
        resolveAll: createResolver(
          field === "text" ? resolveAllLineSuffixes : void 0
        )
      };
      function initializeText(effects) {
        var self2 = this;
        var constructs = this.parser.constructs[field];
        var text2 = effects.attempt(constructs, start3, notText);
        return start3;
        function start3(code) {
          return atBreak(code) ? text2(code) : notText(code);
        }
        function notText(code) {
          if (code === null) {
            effects.consume(code);
            return;
          }
          effects.enter("data");
          effects.consume(code);
          return data;
        }
        function data(code) {
          if (atBreak(code)) {
            effects.exit("data");
            return text2(code);
          }
          effects.consume(code);
          return data;
        }
        function atBreak(code) {
          var list = constructs[code];
          var index2 = -1;
          if (code === null) {
            return true;
          }
          if (list) {
            while (++index2 < list.length) {
              if (!list[index2].previous || list[index2].previous.call(self2, self2.previous)) {
                return true;
              }
            }
          }
        }
      }
    }
    function createResolver(extraResolver) {
      return resolveAllText;
      function resolveAllText(events, context) {
        var index2 = -1;
        var enter2;
        while (++index2 <= events.length) {
          if (enter2 === void 0) {
            if (events[index2] && events[index2][1].type === "data") {
              enter2 = index2;
              index2++;
            }
          } else if (!events[index2] || events[index2][1].type !== "data") {
            if (index2 !== enter2 + 2) {
              events[enter2][1].end = events[index2 - 1][1].end;
              events.splice(enter2 + 2, index2 - enter2 - 2);
              index2 = enter2 + 2;
            }
            enter2 = void 0;
          }
        }
        return extraResolver ? extraResolver(events, context) : events;
      }
    }
    function resolveAllLineSuffixes(events, context) {
      var eventIndex = -1;
      var chunks;
      var data;
      var chunk;
      var index2;
      var bufferIndex;
      var size2;
      var tabs;
      var token2;
      while (++eventIndex <= events.length) {
        if ((eventIndex === events.length || events[eventIndex][1].type === "lineEnding") && events[eventIndex - 1][1].type === "data") {
          data = events[eventIndex - 1][1];
          chunks = context.sliceStream(data);
          index2 = chunks.length;
          bufferIndex = -1;
          size2 = 0;
          tabs = void 0;
          while (index2--) {
            chunk = chunks[index2];
            if (typeof chunk === "string") {
              bufferIndex = chunk.length;
              while (chunk.charCodeAt(bufferIndex - 1) === 32) {
                size2++;
                bufferIndex--;
              }
              if (bufferIndex)
                break;
              bufferIndex = -1;
            } else if (chunk === -2) {
              tabs = true;
              size2++;
            } else if (chunk === -1)
              ;
            else {
              index2++;
              break;
            }
          }
          if (size2) {
            token2 = {
              type: eventIndex === events.length || tabs || size2 < 2 ? "lineSuffix" : "hardBreakTrailing",
              start: {
                line: data.end.line,
                column: data.end.column - size2,
                offset: data.end.offset - size2,
                _index: data.start._index + index2,
                _bufferIndex: index2 ? bufferIndex : data.start._bufferIndex + bufferIndex
              },
              end: shallow(data.end)
            };
            data.end = shallow(token2.start);
            if (data.start.offset === data.end.offset) {
              assign(data, token2);
            } else {
              events.splice(
                eventIndex,
                0,
                ["enter", token2, context],
                ["exit", token2, context]
              );
              eventIndex += 2;
            }
          }
          eventIndex++;
        }
      }
      return events;
    }
    exports2.resolver = resolver;
    exports2.string = string2;
    exports2.text = text;
  }
});

// node_modules/micromark/dist/util/miniflat.js
var require_miniflat = __commonJS({
  "node_modules/micromark/dist/util/miniflat.js"(exports2, module2) {
    "use strict";
    function miniflat(value) {
      return value === null || value === void 0 ? [] : "length" in value ? value : [value];
    }
    module2.exports = miniflat;
  }
});

// node_modules/micromark/dist/util/combine-extensions.js
var require_combine_extensions = __commonJS({
  "node_modules/micromark/dist/util/combine-extensions.js"(exports2, module2) {
    "use strict";
    var hasOwnProperty17 = require_has_own_property();
    var chunkedSplice = require_chunked_splice();
    var miniflat = require_miniflat();
    function combineExtensions(extensions) {
      var all2 = {};
      var index2 = -1;
      while (++index2 < extensions.length) {
        extension(all2, extensions[index2]);
      }
      return all2;
    }
    function extension(all2, extension2) {
      var hook;
      var left;
      var right;
      var code;
      for (hook in extension2) {
        left = hasOwnProperty17.call(all2, hook) ? all2[hook] : all2[hook] = {};
        right = extension2[hook];
        for (code in right) {
          left[code] = constructs(
            miniflat(right[code]),
            hasOwnProperty17.call(left, code) ? left[code] : []
          );
        }
      }
    }
    function constructs(list, existing) {
      var index2 = -1;
      var before = [];
      while (++index2 < list.length) {
        ;
        (list[index2].add === "after" ? existing : before).push(list[index2]);
      }
      chunkedSplice(existing, 0, 0, before);
      return existing;
    }
    module2.exports = combineExtensions;
  }
});

// node_modules/micromark/dist/util/chunked-push.js
var require_chunked_push = __commonJS({
  "node_modules/micromark/dist/util/chunked-push.js"(exports2, module2) {
    "use strict";
    var chunkedSplice = require_chunked_splice();
    function chunkedPush(list, items) {
      if (list.length) {
        chunkedSplice(list, list.length, 0, items);
        return list;
      }
      return items;
    }
    module2.exports = chunkedPush;
  }
});

// node_modules/micromark/dist/util/resolve-all.js
var require_resolve_all = __commonJS({
  "node_modules/micromark/dist/util/resolve-all.js"(exports2, module2) {
    "use strict";
    function resolveAll(constructs, events, context) {
      var called = [];
      var index2 = -1;
      var resolve;
      while (++index2 < constructs.length) {
        resolve = constructs[index2].resolveAll;
        if (resolve && called.indexOf(resolve) < 0) {
          events = resolve(events, context);
          called.push(resolve);
        }
      }
      return events;
    }
    module2.exports = resolveAll;
  }
});

// node_modules/micromark/dist/util/serialize-chunks.js
var require_serialize_chunks = __commonJS({
  "node_modules/micromark/dist/util/serialize-chunks.js"(exports2, module2) {
    "use strict";
    var fromCharCode = require_from_char_code();
    function serializeChunks(chunks) {
      var index2 = -1;
      var result = [];
      var chunk;
      var value;
      var atTab;
      while (++index2 < chunks.length) {
        chunk = chunks[index2];
        if (typeof chunk === "string") {
          value = chunk;
        } else if (chunk === -5) {
          value = "\r";
        } else if (chunk === -4) {
          value = "\n";
        } else if (chunk === -3) {
          value = "\r\n";
        } else if (chunk === -2) {
          value = "	";
        } else if (chunk === -1) {
          if (atTab)
            continue;
          value = " ";
        } else {
          value = fromCharCode(chunk);
        }
        atTab = chunk === -2;
        result.push(value);
      }
      return result.join("");
    }
    module2.exports = serializeChunks;
  }
});

// node_modules/micromark/dist/util/slice-chunks.js
var require_slice_chunks = __commonJS({
  "node_modules/micromark/dist/util/slice-chunks.js"(exports2, module2) {
    "use strict";
    function sliceChunks(chunks, token2) {
      var startIndex = token2.start._index;
      var startBufferIndex = token2.start._bufferIndex;
      var endIndex = token2.end._index;
      var endBufferIndex = token2.end._bufferIndex;
      var view;
      if (startIndex === endIndex) {
        view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
      } else {
        view = chunks.slice(startIndex, endIndex);
        if (startBufferIndex > -1) {
          view[0] = view[0].slice(startBufferIndex);
        }
        if (endBufferIndex > 0) {
          view.push(chunks[endIndex].slice(0, endBufferIndex));
        }
      }
      return view;
    }
    module2.exports = sliceChunks;
  }
});

// node_modules/micromark/dist/util/create-tokenizer.js
var require_create_tokenizer = __commonJS({
  "node_modules/micromark/dist/util/create-tokenizer.js"(exports2, module2) {
    "use strict";
    var assign = require_assign();
    var markdownLineEnding = require_markdown_line_ending();
    var chunkedPush = require_chunked_push();
    var chunkedSplice = require_chunked_splice();
    var miniflat = require_miniflat();
    var resolveAll = require_resolve_all();
    var serializeChunks = require_serialize_chunks();
    var shallow = require_shallow();
    var sliceChunks = require_slice_chunks();
    function createTokenizer(parser, initialize, from2) {
      var point = from2 ? shallow(from2) : {
        line: 1,
        column: 1,
        offset: 0
      };
      var columnStart = {};
      var resolveAllConstructs = [];
      var chunks = [];
      var stack = [];
      var effects = {
        consume,
        enter: enter2,
        exit,
        attempt: constructFactory(onsuccessfulconstruct),
        check: constructFactory(onsuccessfulcheck),
        interrupt: constructFactory(onsuccessfulcheck, {
          interrupt: true
        }),
        lazy: constructFactory(onsuccessfulcheck, {
          lazy: true
        })
      };
      var context = {
        previous: null,
        events: [],
        parser,
        sliceStream,
        sliceSerialize,
        now: now3,
        defineSkip: skip,
        write
      };
      var state = initialize.tokenize.call(context, effects);
      if (initialize.resolveAll) {
        resolveAllConstructs.push(initialize);
      }
      point._index = 0;
      point._bufferIndex = -1;
      return context;
      function write(slice) {
        chunks = chunkedPush(chunks, slice);
        main();
        if (chunks[chunks.length - 1] !== null) {
          return [];
        }
        addResult(initialize, 0);
        context.events = resolveAll(resolveAllConstructs, context.events, context);
        return context.events;
      }
      function sliceSerialize(token2) {
        return serializeChunks(sliceStream(token2));
      }
      function sliceStream(token2) {
        return sliceChunks(chunks, token2);
      }
      function now3() {
        return shallow(point);
      }
      function skip(value) {
        columnStart[value.line] = value.column;
        accountForPotentialSkip();
      }
      function main() {
        var chunkIndex;
        var chunk;
        while (point._index < chunks.length) {
          chunk = chunks[point._index];
          if (typeof chunk === "string") {
            chunkIndex = point._index;
            if (point._bufferIndex < 0) {
              point._bufferIndex = 0;
            }
            while (point._index === chunkIndex && point._bufferIndex < chunk.length) {
              go(chunk.charCodeAt(point._bufferIndex));
            }
          } else {
            go(chunk);
          }
        }
      }
      function go(code) {
        state = state(code);
      }
      function consume(code) {
        if (markdownLineEnding(code)) {
          point.line++;
          point.column = 1;
          point.offset += code === -3 ? 2 : 1;
          accountForPotentialSkip();
        } else if (code !== -1) {
          point.column++;
          point.offset++;
        }
        if (point._bufferIndex < 0) {
          point._index++;
        } else {
          point._bufferIndex++;
          if (point._bufferIndex === chunks[point._index].length) {
            point._bufferIndex = -1;
            point._index++;
          }
        }
        context.previous = code;
      }
      function enter2(type, fields) {
        var token2 = fields || {};
        token2.type = type;
        token2.start = now3();
        context.events.push(["enter", token2, context]);
        stack.push(token2);
        return token2;
      }
      function exit(type) {
        var token2 = stack.pop();
        token2.end = now3();
        context.events.push(["exit", token2, context]);
        return token2;
      }
      function onsuccessfulconstruct(construct, info) {
        addResult(construct, info.from);
      }
      function onsuccessfulcheck(construct, info) {
        info.restore();
      }
      function constructFactory(onreturn, fields) {
        return hook;
        function hook(constructs, returnState, bogusState) {
          var listOfConstructs;
          var constructIndex;
          var currentConstruct;
          var info;
          return constructs.tokenize || "length" in constructs ? handleListOfConstructs(miniflat(constructs)) : handleMapOfConstructs;
          function handleMapOfConstructs(code) {
            if (code in constructs || null in constructs) {
              return handleListOfConstructs(
                constructs.null ? (
                  /* c8 ignore next */
                  miniflat(constructs[code]).concat(miniflat(constructs.null))
                ) : constructs[code]
              )(code);
            }
            return bogusState(code);
          }
          function handleListOfConstructs(list) {
            listOfConstructs = list;
            constructIndex = 0;
            return handleConstruct(list[constructIndex]);
          }
          function handleConstruct(construct) {
            return start3;
            function start3(code) {
              info = store();
              currentConstruct = construct;
              if (!construct.partial) {
                context.currentConstruct = construct;
              }
              if (construct.name && context.parser.constructs.disable.null.indexOf(construct.name) > -1) {
                return nok();
              }
              return construct.tokenize.call(
                fields ? assign({}, context, fields) : context,
                effects,
                ok,
                nok
              )(code);
            }
          }
          function ok(code) {
            onreturn(currentConstruct, info);
            return returnState;
          }
          function nok(code) {
            info.restore();
            if (++constructIndex < listOfConstructs.length) {
              return handleConstruct(listOfConstructs[constructIndex]);
            }
            return bogusState;
          }
        }
      }
      function addResult(construct, from3) {
        if (construct.resolveAll && resolveAllConstructs.indexOf(construct) < 0) {
          resolveAllConstructs.push(construct);
        }
        if (construct.resolve) {
          chunkedSplice(
            context.events,
            from3,
            context.events.length - from3,
            construct.resolve(context.events.slice(from3), context)
          );
        }
        if (construct.resolveTo) {
          context.events = construct.resolveTo(context.events, context);
        }
      }
      function store() {
        var startPoint = now3();
        var startPrevious = context.previous;
        var startCurrentConstruct = context.currentConstruct;
        var startEventsIndex = context.events.length;
        var startStack = Array.from(stack);
        return {
          restore,
          from: startEventsIndex
        };
        function restore() {
          point = startPoint;
          context.previous = startPrevious;
          context.currentConstruct = startCurrentConstruct;
          context.events.length = startEventsIndex;
          stack = startStack;
          accountForPotentialSkip();
        }
      }
      function accountForPotentialSkip() {
        if (point.line in columnStart && point.column < 2) {
          point.column = columnStart[point.line];
          point.offset += columnStart[point.line] - 1;
        }
      }
    }
    module2.exports = createTokenizer;
  }
});

// node_modules/micromark/dist/character/markdown-line-ending-or-space.js
var require_markdown_line_ending_or_space = __commonJS({
  "node_modules/micromark/dist/character/markdown-line-ending-or-space.js"(exports2, module2) {
    "use strict";
    function markdownLineEndingOrSpace(code) {
      return code < 0 || code === 32;
    }
    module2.exports = markdownLineEndingOrSpace;
  }
});

// node_modules/micromark/dist/constant/unicode-punctuation-regex.js
var require_unicode_punctuation_regex = __commonJS({
  "node_modules/micromark/dist/constant/unicode-punctuation-regex.js"(exports2, module2) {
    "use strict";
    var unicodePunctuation = /[!-\/:-@\[-`\{-~\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
    module2.exports = unicodePunctuation;
  }
});

// node_modules/micromark/dist/util/regex-check.js
var require_regex_check = __commonJS({
  "node_modules/micromark/dist/util/regex-check.js"(exports2, module2) {
    "use strict";
    var fromCharCode = require_from_char_code();
    function regexCheck(regex) {
      return check;
      function check(code) {
        return regex.test(fromCharCode(code));
      }
    }
    module2.exports = regexCheck;
  }
});

// node_modules/micromark/dist/character/unicode-punctuation.js
var require_unicode_punctuation = __commonJS({
  "node_modules/micromark/dist/character/unicode-punctuation.js"(exports2, module2) {
    "use strict";
    var unicodePunctuationRegex = require_unicode_punctuation_regex();
    var regexCheck = require_regex_check();
    var unicodePunctuation = regexCheck(unicodePunctuationRegex);
    module2.exports = unicodePunctuation;
  }
});

// node_modules/micromark/dist/character/unicode-whitespace.js
var require_unicode_whitespace = __commonJS({
  "node_modules/micromark/dist/character/unicode-whitespace.js"(exports2, module2) {
    "use strict";
    var regexCheck = require_regex_check();
    var unicodeWhitespace = regexCheck(/\s/);
    module2.exports = unicodeWhitespace;
  }
});

// node_modules/micromark/dist/util/classify-character.js
var require_classify_character = __commonJS({
  "node_modules/micromark/dist/util/classify-character.js"(exports2, module2) {
    "use strict";
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var unicodePunctuation = require_unicode_punctuation();
    var unicodeWhitespace = require_unicode_whitespace();
    function classifyCharacter(code) {
      if (code === null || markdownLineEndingOrSpace(code) || unicodeWhitespace(code)) {
        return 1;
      }
      if (unicodePunctuation(code)) {
        return 2;
      }
    }
    module2.exports = classifyCharacter;
  }
});

// node_modules/micromark/dist/util/move-point.js
var require_move_point = __commonJS({
  "node_modules/micromark/dist/util/move-point.js"(exports2, module2) {
    "use strict";
    function movePoint(point, offset5) {
      point.column += offset5;
      point.offset += offset5;
      point._bufferIndex += offset5;
      return point;
    }
    module2.exports = movePoint;
  }
});

// node_modules/micromark/dist/tokenize/attention.js
var require_attention = __commonJS({
  "node_modules/micromark/dist/tokenize/attention.js"(exports2, module2) {
    "use strict";
    var chunkedPush = require_chunked_push();
    var chunkedSplice = require_chunked_splice();
    var classifyCharacter = require_classify_character();
    var movePoint = require_move_point();
    var resolveAll = require_resolve_all();
    var shallow = require_shallow();
    var attention = {
      name: "attention",
      tokenize: tokenizeAttention,
      resolveAll: resolveAllAttention
    };
    function resolveAllAttention(events, context) {
      var index2 = -1;
      var open;
      var group;
      var text;
      var openingSequence;
      var closingSequence;
      var use;
      var nextEvents;
      var offset5;
      while (++index2 < events.length) {
        if (events[index2][0] === "enter" && events[index2][1].type === "attentionSequence" && events[index2][1]._close) {
          open = index2;
          while (open--) {
            if (events[open][0] === "exit" && events[open][1].type === "attentionSequence" && events[open][1]._open && // If the markers are the same:
            context.sliceSerialize(events[open][1]).charCodeAt(0) === context.sliceSerialize(events[index2][1]).charCodeAt(0)) {
              if ((events[open][1]._close || events[index2][1]._open) && (events[index2][1].end.offset - events[index2][1].start.offset) % 3 && !((events[open][1].end.offset - events[open][1].start.offset + events[index2][1].end.offset - events[index2][1].start.offset) % 3)) {
                continue;
              }
              use = events[open][1].end.offset - events[open][1].start.offset > 1 && events[index2][1].end.offset - events[index2][1].start.offset > 1 ? 2 : 1;
              openingSequence = {
                type: use > 1 ? "strongSequence" : "emphasisSequence",
                start: movePoint(shallow(events[open][1].end), -use),
                end: shallow(events[open][1].end)
              };
              closingSequence = {
                type: use > 1 ? "strongSequence" : "emphasisSequence",
                start: shallow(events[index2][1].start),
                end: movePoint(shallow(events[index2][1].start), use)
              };
              text = {
                type: use > 1 ? "strongText" : "emphasisText",
                start: shallow(events[open][1].end),
                end: shallow(events[index2][1].start)
              };
              group = {
                type: use > 1 ? "strong" : "emphasis",
                start: shallow(openingSequence.start),
                end: shallow(closingSequence.end)
              };
              events[open][1].end = shallow(openingSequence.start);
              events[index2][1].start = shallow(closingSequence.end);
              nextEvents = [];
              if (events[open][1].end.offset - events[open][1].start.offset) {
                nextEvents = chunkedPush(nextEvents, [
                  ["enter", events[open][1], context],
                  ["exit", events[open][1], context]
                ]);
              }
              nextEvents = chunkedPush(nextEvents, [
                ["enter", group, context],
                ["enter", openingSequence, context],
                ["exit", openingSequence, context],
                ["enter", text, context]
              ]);
              nextEvents = chunkedPush(
                nextEvents,
                resolveAll(
                  context.parser.constructs.insideSpan.null,
                  events.slice(open + 1, index2),
                  context
                )
              );
              nextEvents = chunkedPush(nextEvents, [
                ["exit", text, context],
                ["enter", closingSequence, context],
                ["exit", closingSequence, context],
                ["exit", group, context]
              ]);
              if (events[index2][1].end.offset - events[index2][1].start.offset) {
                offset5 = 2;
                nextEvents = chunkedPush(nextEvents, [
                  ["enter", events[index2][1], context],
                  ["exit", events[index2][1], context]
                ]);
              } else {
                offset5 = 0;
              }
              chunkedSplice(events, open - 1, index2 - open + 3, nextEvents);
              index2 = open + nextEvents.length - offset5 - 2;
              break;
            }
          }
        }
      }
      index2 = -1;
      while (++index2 < events.length) {
        if (events[index2][1].type === "attentionSequence") {
          events[index2][1].type = "data";
        }
      }
      return events;
    }
    function tokenizeAttention(effects, ok) {
      var before = classifyCharacter(this.previous);
      var marker;
      return start3;
      function start3(code) {
        effects.enter("attentionSequence");
        marker = code;
        return sequence(code);
      }
      function sequence(code) {
        var token2;
        var after;
        var open;
        var close2;
        if (code === marker) {
          effects.consume(code);
          return sequence;
        }
        token2 = effects.exit("attentionSequence");
        after = classifyCharacter(code);
        open = !after || after === 2 && before;
        close2 = !before || before === 2 && after;
        token2._open = marker === 42 ? open : open && (before || !close2);
        token2._close = marker === 42 ? close2 : close2 && (after || !open);
        return ok(code);
      }
    }
    module2.exports = attention;
  }
});

// node_modules/micromark/dist/character/ascii-alpha.js
var require_ascii_alpha = __commonJS({
  "node_modules/micromark/dist/character/ascii-alpha.js"(exports2, module2) {
    "use strict";
    var regexCheck = require_regex_check();
    var asciiAlpha = regexCheck(/[A-Za-z]/);
    module2.exports = asciiAlpha;
  }
});

// node_modules/micromark/dist/character/ascii-alphanumeric.js
var require_ascii_alphanumeric = __commonJS({
  "node_modules/micromark/dist/character/ascii-alphanumeric.js"(exports2, module2) {
    "use strict";
    var regexCheck = require_regex_check();
    var asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
    module2.exports = asciiAlphanumeric;
  }
});

// node_modules/micromark/dist/character/ascii-atext.js
var require_ascii_atext = __commonJS({
  "node_modules/micromark/dist/character/ascii-atext.js"(exports2, module2) {
    "use strict";
    var regexCheck = require_regex_check();
    var asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
    module2.exports = asciiAtext;
  }
});

// node_modules/micromark/dist/character/ascii-control.js
var require_ascii_control = __commonJS({
  "node_modules/micromark/dist/character/ascii-control.js"(exports2, module2) {
    "use strict";
    function asciiControl(code) {
      return (
        // Special whitespace codes (which have negative values), C0 and Control
        // character DEL
        code < 32 || code === 127
      );
    }
    module2.exports = asciiControl;
  }
});

// node_modules/micromark/dist/tokenize/autolink.js
var require_autolink = __commonJS({
  "node_modules/micromark/dist/tokenize/autolink.js"(exports2, module2) {
    "use strict";
    var asciiAlpha = require_ascii_alpha();
    var asciiAlphanumeric = require_ascii_alphanumeric();
    var asciiAtext = require_ascii_atext();
    var asciiControl = require_ascii_control();
    var autolink = {
      name: "autolink",
      tokenize: tokenizeAutolink
    };
    function tokenizeAutolink(effects, ok, nok) {
      var size2 = 1;
      return start3;
      function start3(code) {
        effects.enter("autolink");
        effects.enter("autolinkMarker");
        effects.consume(code);
        effects.exit("autolinkMarker");
        effects.enter("autolinkProtocol");
        return open;
      }
      function open(code) {
        if (asciiAlpha(code)) {
          effects.consume(code);
          return schemeOrEmailAtext;
        }
        return asciiAtext(code) ? emailAtext(code) : nok(code);
      }
      function schemeOrEmailAtext(code) {
        return code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code) ? schemeInsideOrEmailAtext(code) : emailAtext(code);
      }
      function schemeInsideOrEmailAtext(code) {
        if (code === 58) {
          effects.consume(code);
          return urlInside;
        }
        if ((code === 43 || code === 45 || code === 46 || asciiAlphanumeric(code)) && size2++ < 32) {
          effects.consume(code);
          return schemeInsideOrEmailAtext;
        }
        return emailAtext(code);
      }
      function urlInside(code) {
        if (code === 62) {
          effects.exit("autolinkProtocol");
          return end2(code);
        }
        if (code === 32 || code === 60 || asciiControl(code)) {
          return nok(code);
        }
        effects.consume(code);
        return urlInside;
      }
      function emailAtext(code) {
        if (code === 64) {
          effects.consume(code);
          size2 = 0;
          return emailAtSignOrDot;
        }
        if (asciiAtext(code)) {
          effects.consume(code);
          return emailAtext;
        }
        return nok(code);
      }
      function emailAtSignOrDot(code) {
        return asciiAlphanumeric(code) ? emailLabel(code) : nok(code);
      }
      function emailLabel(code) {
        if (code === 46) {
          effects.consume(code);
          size2 = 0;
          return emailAtSignOrDot;
        }
        if (code === 62) {
          effects.exit("autolinkProtocol").type = "autolinkEmail";
          return end2(code);
        }
        return emailValue(code);
      }
      function emailValue(code) {
        if ((code === 45 || asciiAlphanumeric(code)) && size2++ < 63) {
          effects.consume(code);
          return code === 45 ? emailValue : emailLabel;
        }
        return nok(code);
      }
      function end2(code) {
        effects.enter("autolinkMarker");
        effects.consume(code);
        effects.exit("autolinkMarker");
        effects.exit("autolink");
        return ok;
      }
    }
    module2.exports = autolink;
  }
});

// node_modules/micromark/dist/tokenize/block-quote.js
var require_block_quote = __commonJS({
  "node_modules/micromark/dist/tokenize/block-quote.js"(exports2, module2) {
    "use strict";
    var markdownSpace = require_markdown_space();
    var factorySpace = require_factory_space();
    var blockQuote = {
      name: "blockQuote",
      tokenize: tokenizeBlockQuoteStart,
      continuation: {
        tokenize: tokenizeBlockQuoteContinuation
      },
      exit
    };
    function tokenizeBlockQuoteStart(effects, ok, nok) {
      var self2 = this;
      return start3;
      function start3(code) {
        if (code === 62) {
          if (!self2.containerState.open) {
            effects.enter("blockQuote", {
              _container: true
            });
            self2.containerState.open = true;
          }
          effects.enter("blockQuotePrefix");
          effects.enter("blockQuoteMarker");
          effects.consume(code);
          effects.exit("blockQuoteMarker");
          return after;
        }
        return nok(code);
      }
      function after(code) {
        if (markdownSpace(code)) {
          effects.enter("blockQuotePrefixWhitespace");
          effects.consume(code);
          effects.exit("blockQuotePrefixWhitespace");
          effects.exit("blockQuotePrefix");
          return ok;
        }
        effects.exit("blockQuotePrefix");
        return ok(code);
      }
    }
    function tokenizeBlockQuoteContinuation(effects, ok, nok) {
      return factorySpace(
        effects,
        effects.attempt(blockQuote, ok, nok),
        "linePrefix",
        this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
      );
    }
    function exit(effects) {
      effects.exit("blockQuote");
    }
    module2.exports = blockQuote;
  }
});

// node_modules/micromark/dist/character/ascii-punctuation.js
var require_ascii_punctuation = __commonJS({
  "node_modules/micromark/dist/character/ascii-punctuation.js"(exports2, module2) {
    "use strict";
    var regexCheck = require_regex_check();
    var asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
    module2.exports = asciiPunctuation;
  }
});

// node_modules/micromark/dist/tokenize/character-escape.js
var require_character_escape = __commonJS({
  "node_modules/micromark/dist/tokenize/character-escape.js"(exports2, module2) {
    "use strict";
    var asciiPunctuation = require_ascii_punctuation();
    var characterEscape = {
      name: "characterEscape",
      tokenize: tokenizeCharacterEscape
    };
    function tokenizeCharacterEscape(effects, ok, nok) {
      return start3;
      function start3(code) {
        effects.enter("characterEscape");
        effects.enter("escapeMarker");
        effects.consume(code);
        effects.exit("escapeMarker");
        return open;
      }
      function open(code) {
        if (asciiPunctuation(code)) {
          effects.enter("characterEscapeValue");
          effects.consume(code);
          effects.exit("characterEscapeValue");
          effects.exit("characterEscape");
          return ok;
        }
        return nok(code);
      }
    }
    module2.exports = characterEscape;
  }
});

// node_modules/micromark/node_modules/parse-entities/decode-entity.browser.js
var require_decode_entity_browser = __commonJS({
  "node_modules/micromark/node_modules/parse-entities/decode-entity.browser.js"(exports2, module2) {
    "use strict";
    var el;
    var semicolon = 59;
    module2.exports = decodeEntity;
    function decodeEntity(characters) {
      var entity = "&" + characters + ";";
      var char;
      el = el || document.createElement("i");
      el.innerHTML = entity;
      char = el.textContent;
      if (char.charCodeAt(char.length - 1) === semicolon && characters !== "semi") {
        return false;
      }
      return char === entity ? false : char;
    }
  }
});

// node_modules/micromark/dist/character/ascii-digit.js
var require_ascii_digit = __commonJS({
  "node_modules/micromark/dist/character/ascii-digit.js"(exports2, module2) {
    "use strict";
    var regexCheck = require_regex_check();
    var asciiDigit = regexCheck(/\d/);
    module2.exports = asciiDigit;
  }
});

// node_modules/micromark/dist/character/ascii-hex-digit.js
var require_ascii_hex_digit = __commonJS({
  "node_modules/micromark/dist/character/ascii-hex-digit.js"(exports2, module2) {
    "use strict";
    var regexCheck = require_regex_check();
    var asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
    module2.exports = asciiHexDigit;
  }
});

// node_modules/micromark/dist/tokenize/character-reference.js
var require_character_reference = __commonJS({
  "node_modules/micromark/dist/tokenize/character-reference.js"(exports2, module2) {
    "use strict";
    var decodeEntity = require_decode_entity_browser();
    var asciiAlphanumeric = require_ascii_alphanumeric();
    var asciiDigit = require_ascii_digit();
    var asciiHexDigit = require_ascii_hex_digit();
    function _interopDefaultLegacy(e9) {
      return e9 && typeof e9 === "object" && "default" in e9 ? e9 : { default: e9 };
    }
    var decodeEntity__default = _interopDefaultLegacy(decodeEntity);
    var characterReference = {
      name: "characterReference",
      tokenize: tokenizeCharacterReference
    };
    function tokenizeCharacterReference(effects, ok, nok) {
      var self2 = this;
      var size2 = 0;
      var max4;
      var test;
      return start3;
      function start3(code) {
        effects.enter("characterReference");
        effects.enter("characterReferenceMarker");
        effects.consume(code);
        effects.exit("characterReferenceMarker");
        return open;
      }
      function open(code) {
        if (code === 35) {
          effects.enter("characterReferenceMarkerNumeric");
          effects.consume(code);
          effects.exit("characterReferenceMarkerNumeric");
          return numeric;
        }
        effects.enter("characterReferenceValue");
        max4 = 31;
        test = asciiAlphanumeric;
        return value(code);
      }
      function numeric(code) {
        if (code === 88 || code === 120) {
          effects.enter("characterReferenceMarkerHexadecimal");
          effects.consume(code);
          effects.exit("characterReferenceMarkerHexadecimal");
          effects.enter("characterReferenceValue");
          max4 = 6;
          test = asciiHexDigit;
          return value;
        }
        effects.enter("characterReferenceValue");
        max4 = 7;
        test = asciiDigit;
        return value(code);
      }
      function value(code) {
        var token2;
        if (code === 59 && size2) {
          token2 = effects.exit("characterReferenceValue");
          if (test === asciiAlphanumeric && !decodeEntity__default["default"](self2.sliceSerialize(token2))) {
            return nok(code);
          }
          effects.enter("characterReferenceMarker");
          effects.consume(code);
          effects.exit("characterReferenceMarker");
          effects.exit("characterReference");
          return ok;
        }
        if (test(code) && size2++ < max4) {
          effects.consume(code);
          return value;
        }
        return nok(code);
      }
    }
    module2.exports = characterReference;
  }
});

// node_modules/micromark/dist/tokenize/code-fenced.js
var require_code_fenced = __commonJS({
  "node_modules/micromark/dist/tokenize/code-fenced.js"(exports2, module2) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var prefixSize = require_prefix_size();
    var factorySpace = require_factory_space();
    var codeFenced = {
      name: "codeFenced",
      tokenize: tokenizeCodeFenced,
      concrete: true
    };
    function tokenizeCodeFenced(effects, ok, nok) {
      var self2 = this;
      var closingFenceConstruct = {
        tokenize: tokenizeClosingFence,
        partial: true
      };
      var initialPrefix = prefixSize(this.events, "linePrefix");
      var sizeOpen = 0;
      var marker;
      return start3;
      function start3(code) {
        effects.enter("codeFenced");
        effects.enter("codeFencedFence");
        effects.enter("codeFencedFenceSequence");
        marker = code;
        return sequenceOpen(code);
      }
      function sequenceOpen(code) {
        if (code === marker) {
          effects.consume(code);
          sizeOpen++;
          return sequenceOpen;
        }
        effects.exit("codeFencedFenceSequence");
        return sizeOpen < 3 ? nok(code) : factorySpace(effects, infoOpen, "whitespace")(code);
      }
      function infoOpen(code) {
        if (code === null || markdownLineEnding(code)) {
          return openAfter(code);
        }
        effects.enter("codeFencedFenceInfo");
        effects.enter("chunkString", {
          contentType: "string"
        });
        return info(code);
      }
      function info(code) {
        if (code === null || markdownLineEndingOrSpace(code)) {
          effects.exit("chunkString");
          effects.exit("codeFencedFenceInfo");
          return factorySpace(effects, infoAfter, "whitespace")(code);
        }
        if (code === 96 && code === marker)
          return nok(code);
        effects.consume(code);
        return info;
      }
      function infoAfter(code) {
        if (code === null || markdownLineEnding(code)) {
          return openAfter(code);
        }
        effects.enter("codeFencedFenceMeta");
        effects.enter("chunkString", {
          contentType: "string"
        });
        return meta(code);
      }
      function meta(code) {
        if (code === null || markdownLineEnding(code)) {
          effects.exit("chunkString");
          effects.exit("codeFencedFenceMeta");
          return openAfter(code);
        }
        if (code === 96 && code === marker)
          return nok(code);
        effects.consume(code);
        return meta;
      }
      function openAfter(code) {
        effects.exit("codeFencedFence");
        return self2.interrupt ? ok(code) : content(code);
      }
      function content(code) {
        if (code === null) {
          return after(code);
        }
        if (markdownLineEnding(code)) {
          effects.enter("lineEnding");
          effects.consume(code);
          effects.exit("lineEnding");
          return effects.attempt(
            closingFenceConstruct,
            after,
            initialPrefix ? factorySpace(effects, content, "linePrefix", initialPrefix + 1) : content
          );
        }
        effects.enter("codeFlowValue");
        return contentContinue(code);
      }
      function contentContinue(code) {
        if (code === null || markdownLineEnding(code)) {
          effects.exit("codeFlowValue");
          return content(code);
        }
        effects.consume(code);
        return contentContinue;
      }
      function after(code) {
        effects.exit("codeFenced");
        return ok(code);
      }
      function tokenizeClosingFence(effects2, ok2, nok2) {
        var size2 = 0;
        return factorySpace(
          effects2,
          closingSequenceStart,
          "linePrefix",
          this.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
        );
        function closingSequenceStart(code) {
          effects2.enter("codeFencedFence");
          effects2.enter("codeFencedFenceSequence");
          return closingSequence(code);
        }
        function closingSequence(code) {
          if (code === marker) {
            effects2.consume(code);
            size2++;
            return closingSequence;
          }
          if (size2 < sizeOpen)
            return nok2(code);
          effects2.exit("codeFencedFenceSequence");
          return factorySpace(effects2, closingSequenceEnd, "whitespace")(code);
        }
        function closingSequenceEnd(code) {
          if (code === null || markdownLineEnding(code)) {
            effects2.exit("codeFencedFence");
            return ok2(code);
          }
          return nok2(code);
        }
      }
    }
    module2.exports = codeFenced;
  }
});

// node_modules/micromark/dist/tokenize/code-indented.js
var require_code_indented = __commonJS({
  "node_modules/micromark/dist/tokenize/code-indented.js"(exports2, module2) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var chunkedSplice = require_chunked_splice();
    var prefixSize = require_prefix_size();
    var factorySpace = require_factory_space();
    var codeIndented = {
      name: "codeIndented",
      tokenize: tokenizeCodeIndented,
      resolve: resolveCodeIndented
    };
    var indentedContentConstruct = {
      tokenize: tokenizeIndentedContent,
      partial: true
    };
    function resolveCodeIndented(events, context) {
      var code = {
        type: "codeIndented",
        start: events[0][1].start,
        end: events[events.length - 1][1].end
      };
      chunkedSplice(events, 0, 0, [["enter", code, context]]);
      chunkedSplice(events, events.length, 0, [["exit", code, context]]);
      return events;
    }
    function tokenizeCodeIndented(effects, ok, nok) {
      return effects.attempt(indentedContentConstruct, afterPrefix, nok);
      function afterPrefix(code) {
        if (code === null) {
          return ok(code);
        }
        if (markdownLineEnding(code)) {
          return effects.attempt(indentedContentConstruct, afterPrefix, ok)(code);
        }
        effects.enter("codeFlowValue");
        return content(code);
      }
      function content(code) {
        if (code === null || markdownLineEnding(code)) {
          effects.exit("codeFlowValue");
          return afterPrefix(code);
        }
        effects.consume(code);
        return content;
      }
    }
    function tokenizeIndentedContent(effects, ok, nok) {
      var self2 = this;
      return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1);
      function afterPrefix(code) {
        if (markdownLineEnding(code)) {
          effects.enter("lineEnding");
          effects.consume(code);
          effects.exit("lineEnding");
          return factorySpace(effects, afterPrefix, "linePrefix", 4 + 1);
        }
        return prefixSize(self2.events, "linePrefix") < 4 ? nok(code) : ok(code);
      }
    }
    module2.exports = codeIndented;
  }
});

// node_modules/micromark/dist/tokenize/code-text.js
var require_code_text = __commonJS({
  "node_modules/micromark/dist/tokenize/code-text.js"(exports2, module2) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var codeText = {
      name: "codeText",
      tokenize: tokenizeCodeText,
      resolve: resolveCodeText,
      previous
    };
    function resolveCodeText(events) {
      var tailExitIndex = events.length - 4;
      var headEnterIndex = 3;
      var index2;
      var enter2;
      if ((events[headEnterIndex][1].type === "lineEnding" || events[headEnterIndex][1].type === "space") && (events[tailExitIndex][1].type === "lineEnding" || events[tailExitIndex][1].type === "space")) {
        index2 = headEnterIndex;
        while (++index2 < tailExitIndex) {
          if (events[index2][1].type === "codeTextData") {
            events[tailExitIndex][1].type = events[headEnterIndex][1].type = "codeTextPadding";
            headEnterIndex += 2;
            tailExitIndex -= 2;
            break;
          }
        }
      }
      index2 = headEnterIndex - 1;
      tailExitIndex++;
      while (++index2 <= tailExitIndex) {
        if (enter2 === void 0) {
          if (index2 !== tailExitIndex && events[index2][1].type !== "lineEnding") {
            enter2 = index2;
          }
        } else if (index2 === tailExitIndex || events[index2][1].type === "lineEnding") {
          events[enter2][1].type = "codeTextData";
          if (index2 !== enter2 + 2) {
            events[enter2][1].end = events[index2 - 1][1].end;
            events.splice(enter2 + 2, index2 - enter2 - 2);
            tailExitIndex -= index2 - enter2 - 2;
            index2 = enter2 + 2;
          }
          enter2 = void 0;
        }
      }
      return events;
    }
    function previous(code) {
      return code !== 96 || this.events[this.events.length - 1][1].type === "characterEscape";
    }
    function tokenizeCodeText(effects, ok, nok) {
      var sizeOpen = 0;
      var size2;
      var token2;
      return start3;
      function start3(code) {
        effects.enter("codeText");
        effects.enter("codeTextSequence");
        return openingSequence(code);
      }
      function openingSequence(code) {
        if (code === 96) {
          effects.consume(code);
          sizeOpen++;
          return openingSequence;
        }
        effects.exit("codeTextSequence");
        return gap(code);
      }
      function gap(code) {
        if (code === null) {
          return nok(code);
        }
        if (code === 96) {
          token2 = effects.enter("codeTextSequence");
          size2 = 0;
          return closingSequence(code);
        }
        if (code === 32) {
          effects.enter("space");
          effects.consume(code);
          effects.exit("space");
          return gap;
        }
        if (markdownLineEnding(code)) {
          effects.enter("lineEnding");
          effects.consume(code);
          effects.exit("lineEnding");
          return gap;
        }
        effects.enter("codeTextData");
        return data(code);
      }
      function data(code) {
        if (code === null || code === 32 || code === 96 || markdownLineEnding(code)) {
          effects.exit("codeTextData");
          return gap(code);
        }
        effects.consume(code);
        return data;
      }
      function closingSequence(code) {
        if (code === 96) {
          effects.consume(code);
          size2++;
          return closingSequence;
        }
        if (size2 === sizeOpen) {
          effects.exit("codeTextSequence");
          effects.exit("codeText");
          return ok(code);
        }
        token2.type = "codeTextData";
        return data(code);
      }
    }
    module2.exports = codeText;
  }
});

// node_modules/micromark/dist/tokenize/factory-destination.js
var require_factory_destination = __commonJS({
  "node_modules/micromark/dist/tokenize/factory-destination.js"(exports2, module2) {
    "use strict";
    var asciiControl = require_ascii_control();
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var markdownLineEnding = require_markdown_line_ending();
    function destinationFactory(effects, ok, nok, type, literalType2, literalMarkerType, rawType, stringType2, max4) {
      var limit = max4 || Infinity;
      var balance = 0;
      return start3;
      function start3(code) {
        if (code === 60) {
          effects.enter(type);
          effects.enter(literalType2);
          effects.enter(literalMarkerType);
          effects.consume(code);
          effects.exit(literalMarkerType);
          return destinationEnclosedBefore;
        }
        if (asciiControl(code) || code === 41) {
          return nok(code);
        }
        effects.enter(type);
        effects.enter(rawType);
        effects.enter(stringType2);
        effects.enter("chunkString", {
          contentType: "string"
        });
        return destinationRaw(code);
      }
      function destinationEnclosedBefore(code) {
        if (code === 62) {
          effects.enter(literalMarkerType);
          effects.consume(code);
          effects.exit(literalMarkerType);
          effects.exit(literalType2);
          effects.exit(type);
          return ok;
        }
        effects.enter(stringType2);
        effects.enter("chunkString", {
          contentType: "string"
        });
        return destinationEnclosed(code);
      }
      function destinationEnclosed(code) {
        if (code === 62) {
          effects.exit("chunkString");
          effects.exit(stringType2);
          return destinationEnclosedBefore(code);
        }
        if (code === null || code === 60 || markdownLineEnding(code)) {
          return nok(code);
        }
        effects.consume(code);
        return code === 92 ? destinationEnclosedEscape : destinationEnclosed;
      }
      function destinationEnclosedEscape(code) {
        if (code === 60 || code === 62 || code === 92) {
          effects.consume(code);
          return destinationEnclosed;
        }
        return destinationEnclosed(code);
      }
      function destinationRaw(code) {
        if (code === 40) {
          if (++balance > limit)
            return nok(code);
          effects.consume(code);
          return destinationRaw;
        }
        if (code === 41) {
          if (!balance--) {
            effects.exit("chunkString");
            effects.exit(stringType2);
            effects.exit(rawType);
            effects.exit(type);
            return ok(code);
          }
          effects.consume(code);
          return destinationRaw;
        }
        if (code === null || markdownLineEndingOrSpace(code)) {
          if (balance)
            return nok(code);
          effects.exit("chunkString");
          effects.exit(stringType2);
          effects.exit(rawType);
          effects.exit(type);
          return ok(code);
        }
        if (asciiControl(code))
          return nok(code);
        effects.consume(code);
        return code === 92 ? destinationRawEscape : destinationRaw;
      }
      function destinationRawEscape(code) {
        if (code === 40 || code === 41 || code === 92) {
          effects.consume(code);
          return destinationRaw;
        }
        return destinationRaw(code);
      }
    }
    module2.exports = destinationFactory;
  }
});

// node_modules/micromark/dist/tokenize/factory-label.js
var require_factory_label = __commonJS({
  "node_modules/micromark/dist/tokenize/factory-label.js"(exports2, module2) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var markdownSpace = require_markdown_space();
    function labelFactory(effects, ok, nok, type, markerType, stringType2) {
      var self2 = this;
      var size2 = 0;
      var data;
      return start3;
      function start3(code) {
        effects.enter(type);
        effects.enter(markerType);
        effects.consume(code);
        effects.exit(markerType);
        effects.enter(stringType2);
        return atBreak;
      }
      function atBreak(code) {
        if (code === null || code === 91 || code === 93 && !data || /* c8 ignore next */
        code === 94 && /* c8 ignore next */
        !size2 && /* c8 ignore next */
        "_hiddenFootnoteSupport" in self2.parser.constructs || size2 > 999) {
          return nok(code);
        }
        if (code === 93) {
          effects.exit(stringType2);
          effects.enter(markerType);
          effects.consume(code);
          effects.exit(markerType);
          effects.exit(type);
          return ok;
        }
        if (markdownLineEnding(code)) {
          effects.enter("lineEnding");
          effects.consume(code);
          effects.exit("lineEnding");
          return atBreak;
        }
        effects.enter("chunkString", {
          contentType: "string"
        });
        return label(code);
      }
      function label(code) {
        if (code === null || code === 91 || code === 93 || markdownLineEnding(code) || size2++ > 999) {
          effects.exit("chunkString");
          return atBreak(code);
        }
        effects.consume(code);
        data = data || !markdownSpace(code);
        return code === 92 ? labelEscape : label;
      }
      function labelEscape(code) {
        if (code === 91 || code === 92 || code === 93) {
          effects.consume(code);
          size2++;
          return label;
        }
        return label(code);
      }
    }
    module2.exports = labelFactory;
  }
});

// node_modules/micromark/dist/tokenize/factory-whitespace.js
var require_factory_whitespace = __commonJS({
  "node_modules/micromark/dist/tokenize/factory-whitespace.js"(exports2, module2) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var markdownSpace = require_markdown_space();
    var factorySpace = require_factory_space();
    function whitespaceFactory(effects, ok) {
      var seen;
      return start3;
      function start3(code) {
        if (markdownLineEnding(code)) {
          effects.enter("lineEnding");
          effects.consume(code);
          effects.exit("lineEnding");
          seen = true;
          return start3;
        }
        if (markdownSpace(code)) {
          return factorySpace(
            effects,
            start3,
            seen ? "linePrefix" : "lineSuffix"
          )(code);
        }
        return ok(code);
      }
    }
    module2.exports = whitespaceFactory;
  }
});

// node_modules/micromark/dist/tokenize/factory-title.js
var require_factory_title = __commonJS({
  "node_modules/micromark/dist/tokenize/factory-title.js"(exports2, module2) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var factorySpace = require_factory_space();
    function titleFactory(effects, ok, nok, type, markerType, stringType2) {
      var marker;
      return start3;
      function start3(code) {
        effects.enter(type);
        effects.enter(markerType);
        effects.consume(code);
        effects.exit(markerType);
        marker = code === 40 ? 41 : code;
        return atFirstTitleBreak;
      }
      function atFirstTitleBreak(code) {
        if (code === marker) {
          effects.enter(markerType);
          effects.consume(code);
          effects.exit(markerType);
          effects.exit(type);
          return ok;
        }
        effects.enter(stringType2);
        return atTitleBreak(code);
      }
      function atTitleBreak(code) {
        if (code === marker) {
          effects.exit(stringType2);
          return atFirstTitleBreak(marker);
        }
        if (code === null) {
          return nok(code);
        }
        if (markdownLineEnding(code)) {
          effects.enter("lineEnding");
          effects.consume(code);
          effects.exit("lineEnding");
          return factorySpace(effects, atTitleBreak, "linePrefix");
        }
        effects.enter("chunkString", {
          contentType: "string"
        });
        return title(code);
      }
      function title(code) {
        if (code === marker || code === null || markdownLineEnding(code)) {
          effects.exit("chunkString");
          return atTitleBreak(code);
        }
        effects.consume(code);
        return code === 92 ? titleEscape : title;
      }
      function titleEscape(code) {
        if (code === marker || code === 92) {
          effects.consume(code);
          return title;
        }
        return title(code);
      }
    }
    module2.exports = titleFactory;
  }
});

// node_modules/micromark/dist/tokenize/definition.js
var require_definition = __commonJS({
  "node_modules/micromark/dist/tokenize/definition.js"(exports2, module2) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var normalizeIdentifier = require_normalize_identifier();
    var factoryDestination = require_factory_destination();
    var factoryLabel = require_factory_label();
    var factorySpace = require_factory_space();
    var factoryWhitespace = require_factory_whitespace();
    var factoryTitle = require_factory_title();
    var definition = {
      name: "definition",
      tokenize: tokenizeDefinition
    };
    var titleConstruct = {
      tokenize: tokenizeTitle,
      partial: true
    };
    function tokenizeDefinition(effects, ok, nok) {
      var self2 = this;
      var identifier;
      return start3;
      function start3(code) {
        effects.enter("definition");
        return factoryLabel.call(
          self2,
          effects,
          labelAfter,
          nok,
          "definitionLabel",
          "definitionLabelMarker",
          "definitionLabelString"
        )(code);
      }
      function labelAfter(code) {
        identifier = normalizeIdentifier(
          self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
        );
        if (code === 58) {
          effects.enter("definitionMarker");
          effects.consume(code);
          effects.exit("definitionMarker");
          return factoryWhitespace(
            effects,
            factoryDestination(
              effects,
              effects.attempt(
                titleConstruct,
                factorySpace(effects, after, "whitespace"),
                factorySpace(effects, after, "whitespace")
              ),
              nok,
              "definitionDestination",
              "definitionDestinationLiteral",
              "definitionDestinationLiteralMarker",
              "definitionDestinationRaw",
              "definitionDestinationString"
            )
          );
        }
        return nok(code);
      }
      function after(code) {
        if (code === null || markdownLineEnding(code)) {
          effects.exit("definition");
          if (self2.parser.defined.indexOf(identifier) < 0) {
            self2.parser.defined.push(identifier);
          }
          return ok(code);
        }
        return nok(code);
      }
    }
    function tokenizeTitle(effects, ok, nok) {
      return start3;
      function start3(code) {
        return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, before)(code) : nok(code);
      }
      function before(code) {
        if (code === 34 || code === 39 || code === 40) {
          return factoryTitle(
            effects,
            factorySpace(effects, after, "whitespace"),
            nok,
            "definitionTitle",
            "definitionTitleMarker",
            "definitionTitleString"
          )(code);
        }
        return nok(code);
      }
      function after(code) {
        return code === null || markdownLineEnding(code) ? ok(code) : nok(code);
      }
    }
    module2.exports = definition;
  }
});

// node_modules/micromark/dist/tokenize/hard-break-escape.js
var require_hard_break_escape = __commonJS({
  "node_modules/micromark/dist/tokenize/hard-break-escape.js"(exports2, module2) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var hardBreakEscape = {
      name: "hardBreakEscape",
      tokenize: tokenizeHardBreakEscape
    };
    function tokenizeHardBreakEscape(effects, ok, nok) {
      return start3;
      function start3(code) {
        effects.enter("hardBreakEscape");
        effects.enter("escapeMarker");
        effects.consume(code);
        return open;
      }
      function open(code) {
        if (markdownLineEnding(code)) {
          effects.exit("escapeMarker");
          effects.exit("hardBreakEscape");
          return ok(code);
        }
        return nok(code);
      }
    }
    module2.exports = hardBreakEscape;
  }
});

// node_modules/micromark/dist/tokenize/heading-atx.js
var require_heading_atx = __commonJS({
  "node_modules/micromark/dist/tokenize/heading-atx.js"(exports2, module2) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var markdownSpace = require_markdown_space();
    var chunkedSplice = require_chunked_splice();
    var factorySpace = require_factory_space();
    var headingAtx = {
      name: "headingAtx",
      tokenize: tokenizeHeadingAtx,
      resolve: resolveHeadingAtx
    };
    function resolveHeadingAtx(events, context) {
      var contentEnd = events.length - 2;
      var contentStart = 3;
      var content;
      var text;
      if (events[contentStart][1].type === "whitespace") {
        contentStart += 2;
      }
      if (contentEnd - 2 > contentStart && events[contentEnd][1].type === "whitespace") {
        contentEnd -= 2;
      }
      if (events[contentEnd][1].type === "atxHeadingSequence" && (contentStart === contentEnd - 1 || contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === "whitespace")) {
        contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
      }
      if (contentEnd > contentStart) {
        content = {
          type: "atxHeadingText",
          start: events[contentStart][1].start,
          end: events[contentEnd][1].end
        };
        text = {
          type: "chunkText",
          start: events[contentStart][1].start,
          end: events[contentEnd][1].end,
          contentType: "text"
        };
        chunkedSplice(events, contentStart, contentEnd - contentStart + 1, [
          ["enter", content, context],
          ["enter", text, context],
          ["exit", text, context],
          ["exit", content, context]
        ]);
      }
      return events;
    }
    function tokenizeHeadingAtx(effects, ok, nok) {
      var self2 = this;
      var size2 = 0;
      return start3;
      function start3(code) {
        effects.enter("atxHeading");
        effects.enter("atxHeadingSequence");
        return fenceOpenInside(code);
      }
      function fenceOpenInside(code) {
        if (code === 35 && size2++ < 6) {
          effects.consume(code);
          return fenceOpenInside;
        }
        if (code === null || markdownLineEndingOrSpace(code)) {
          effects.exit("atxHeadingSequence");
          return self2.interrupt ? ok(code) : headingBreak(code);
        }
        return nok(code);
      }
      function headingBreak(code) {
        if (code === 35) {
          effects.enter("atxHeadingSequence");
          return sequence(code);
        }
        if (code === null || markdownLineEnding(code)) {
          effects.exit("atxHeading");
          return ok(code);
        }
        if (markdownSpace(code)) {
          return factorySpace(effects, headingBreak, "whitespace")(code);
        }
        effects.enter("atxHeadingText");
        return data(code);
      }
      function sequence(code) {
        if (code === 35) {
          effects.consume(code);
          return sequence;
        }
        effects.exit("atxHeadingSequence");
        return headingBreak(code);
      }
      function data(code) {
        if (code === null || code === 35 || markdownLineEndingOrSpace(code)) {
          effects.exit("atxHeadingText");
          return headingBreak(code);
        }
        effects.consume(code);
        return data;
      }
    }
    module2.exports = headingAtx;
  }
});

// node_modules/micromark/dist/constant/html-block-names.js
var require_html_block_names = __commonJS({
  "node_modules/micromark/dist/constant/html-block-names.js"(exports2, module2) {
    "use strict";
    var basics = [
      "address",
      "article",
      "aside",
      "base",
      "basefont",
      "blockquote",
      "body",
      "caption",
      "center",
      "col",
      "colgroup",
      "dd",
      "details",
      "dialog",
      "dir",
      "div",
      "dl",
      "dt",
      "fieldset",
      "figcaption",
      "figure",
      "footer",
      "form",
      "frame",
      "frameset",
      "h1",
      "h2",
      "h3",
      "h4",
      "h5",
      "h6",
      "head",
      "header",
      "hr",
      "html",
      "iframe",
      "legend",
      "li",
      "link",
      "main",
      "menu",
      "menuitem",
      "nav",
      "noframes",
      "ol",
      "optgroup",
      "option",
      "p",
      "param",
      "section",
      "source",
      "summary",
      "table",
      "tbody",
      "td",
      "tfoot",
      "th",
      "thead",
      "title",
      "tr",
      "track",
      "ul"
    ];
    module2.exports = basics;
  }
});

// node_modules/micromark/dist/constant/html-raw-names.js
var require_html_raw_names = __commonJS({
  "node_modules/micromark/dist/constant/html-raw-names.js"(exports2, module2) {
    "use strict";
    var raws = ["pre", "script", "style", "textarea"];
    module2.exports = raws;
  }
});

// node_modules/micromark/dist/tokenize/html-flow.js
var require_html_flow = __commonJS({
  "node_modules/micromark/dist/tokenize/html-flow.js"(exports2, module2) {
    "use strict";
    var asciiAlpha = require_ascii_alpha();
    var asciiAlphanumeric = require_ascii_alphanumeric();
    var markdownLineEnding = require_markdown_line_ending();
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var markdownSpace = require_markdown_space();
    var fromCharCode = require_from_char_code();
    var htmlBlockNames = require_html_block_names();
    var htmlRawNames = require_html_raw_names();
    var partialBlankLine = require_partial_blank_line();
    var htmlFlow = {
      name: "htmlFlow",
      tokenize: tokenizeHtmlFlow,
      resolveTo: resolveToHtmlFlow,
      concrete: true
    };
    var nextBlankConstruct = {
      tokenize: tokenizeNextBlank,
      partial: true
    };
    function resolveToHtmlFlow(events) {
      var index2 = events.length;
      while (index2--) {
        if (events[index2][0] === "enter" && events[index2][1].type === "htmlFlow") {
          break;
        }
      }
      if (index2 > 1 && events[index2 - 2][1].type === "linePrefix") {
        events[index2][1].start = events[index2 - 2][1].start;
        events[index2 + 1][1].start = events[index2 - 2][1].start;
        events.splice(index2 - 2, 2);
      }
      return events;
    }
    function tokenizeHtmlFlow(effects, ok, nok) {
      var self2 = this;
      var kind;
      var startTag;
      var buffer;
      var index2;
      var marker;
      return start3;
      function start3(code) {
        effects.enter("htmlFlow");
        effects.enter("htmlFlowData");
        effects.consume(code);
        return open;
      }
      function open(code) {
        if (code === 33) {
          effects.consume(code);
          return declarationStart;
        }
        if (code === 47) {
          effects.consume(code);
          return tagCloseStart;
        }
        if (code === 63) {
          effects.consume(code);
          kind = 3;
          return self2.interrupt ? ok : continuationDeclarationInside;
        }
        if (asciiAlpha(code)) {
          effects.consume(code);
          buffer = fromCharCode(code);
          startTag = true;
          return tagName;
        }
        return nok(code);
      }
      function declarationStart(code) {
        if (code === 45) {
          effects.consume(code);
          kind = 2;
          return commentOpenInside;
        }
        if (code === 91) {
          effects.consume(code);
          kind = 5;
          buffer = "CDATA[";
          index2 = 0;
          return cdataOpenInside;
        }
        if (asciiAlpha(code)) {
          effects.consume(code);
          kind = 4;
          return self2.interrupt ? ok : continuationDeclarationInside;
        }
        return nok(code);
      }
      function commentOpenInside(code) {
        if (code === 45) {
          effects.consume(code);
          return self2.interrupt ? ok : continuationDeclarationInside;
        }
        return nok(code);
      }
      function cdataOpenInside(code) {
        if (code === buffer.charCodeAt(index2++)) {
          effects.consume(code);
          return index2 === buffer.length ? self2.interrupt ? ok : continuation : cdataOpenInside;
        }
        return nok(code);
      }
      function tagCloseStart(code) {
        if (asciiAlpha(code)) {
          effects.consume(code);
          buffer = fromCharCode(code);
          return tagName;
        }
        return nok(code);
      }
      function tagName(code) {
        if (code === null || code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
          if (code !== 47 && startTag && htmlRawNames.indexOf(buffer.toLowerCase()) > -1) {
            kind = 1;
            return self2.interrupt ? ok(code) : continuation(code);
          }
          if (htmlBlockNames.indexOf(buffer.toLowerCase()) > -1) {
            kind = 6;
            if (code === 47) {
              effects.consume(code);
              return basicSelfClosing;
            }
            return self2.interrupt ? ok(code) : continuation(code);
          }
          kind = 7;
          return self2.interrupt ? nok(code) : startTag ? completeAttributeNameBefore(code) : completeClosingTagAfter(code);
        }
        if (code === 45 || asciiAlphanumeric(code)) {
          effects.consume(code);
          buffer += fromCharCode(code);
          return tagName;
        }
        return nok(code);
      }
      function basicSelfClosing(code) {
        if (code === 62) {
          effects.consume(code);
          return self2.interrupt ? ok : continuation;
        }
        return nok(code);
      }
      function completeClosingTagAfter(code) {
        if (markdownSpace(code)) {
          effects.consume(code);
          return completeClosingTagAfter;
        }
        return completeEnd(code);
      }
      function completeAttributeNameBefore(code) {
        if (code === 47) {
          effects.consume(code);
          return completeEnd;
        }
        if (code === 58 || code === 95 || asciiAlpha(code)) {
          effects.consume(code);
          return completeAttributeName;
        }
        if (markdownSpace(code)) {
          effects.consume(code);
          return completeAttributeNameBefore;
        }
        return completeEnd(code);
      }
      function completeAttributeName(code) {
        if (code === 45 || code === 46 || code === 58 || code === 95 || asciiAlphanumeric(code)) {
          effects.consume(code);
          return completeAttributeName;
        }
        return completeAttributeNameAfter(code);
      }
      function completeAttributeNameAfter(code) {
        if (code === 61) {
          effects.consume(code);
          return completeAttributeValueBefore;
        }
        if (markdownSpace(code)) {
          effects.consume(code);
          return completeAttributeNameAfter;
        }
        return completeAttributeNameBefore(code);
      }
      function completeAttributeValueBefore(code) {
        if (code === null || code === 60 || code === 61 || code === 62 || code === 96) {
          return nok(code);
        }
        if (code === 34 || code === 39) {
          effects.consume(code);
          marker = code;
          return completeAttributeValueQuoted;
        }
        if (markdownSpace(code)) {
          effects.consume(code);
          return completeAttributeValueBefore;
        }
        marker = void 0;
        return completeAttributeValueUnquoted(code);
      }
      function completeAttributeValueQuoted(code) {
        if (code === marker) {
          effects.consume(code);
          return completeAttributeValueQuotedAfter;
        }
        if (code === null || markdownLineEnding(code)) {
          return nok(code);
        }
        effects.consume(code);
        return completeAttributeValueQuoted;
      }
      function completeAttributeValueUnquoted(code) {
        if (code === null || code === 34 || code === 39 || code === 60 || code === 61 || code === 62 || code === 96 || markdownLineEndingOrSpace(code)) {
          return completeAttributeNameAfter(code);
        }
        effects.consume(code);
        return completeAttributeValueUnquoted;
      }
      function completeAttributeValueQuotedAfter(code) {
        if (code === 47 || code === 62 || markdownSpace(code)) {
          return completeAttributeNameBefore(code);
        }
        return nok(code);
      }
      function completeEnd(code) {
        if (code === 62) {
          effects.consume(code);
          return completeAfter;
        }
        return nok(code);
      }
      function completeAfter(code) {
        if (markdownSpace(code)) {
          effects.consume(code);
          return completeAfter;
        }
        return code === null || markdownLineEnding(code) ? continuation(code) : nok(code);
      }
      function continuation(code) {
        if (code === 45 && kind === 2) {
          effects.consume(code);
          return continuationCommentInside;
        }
        if (code === 60 && kind === 1) {
          effects.consume(code);
          return continuationRawTagOpen;
        }
        if (code === 62 && kind === 4) {
          effects.consume(code);
          return continuationClose;
        }
        if (code === 63 && kind === 3) {
          effects.consume(code);
          return continuationDeclarationInside;
        }
        if (code === 93 && kind === 5) {
          effects.consume(code);
          return continuationCharacterDataInside;
        }
        if (markdownLineEnding(code) && (kind === 6 || kind === 7)) {
          return effects.check(
            nextBlankConstruct,
            continuationClose,
            continuationAtLineEnding
          )(code);
        }
        if (code === null || markdownLineEnding(code)) {
          return continuationAtLineEnding(code);
        }
        effects.consume(code);
        return continuation;
      }
      function continuationAtLineEnding(code) {
        effects.exit("htmlFlowData");
        return htmlContinueStart(code);
      }
      function htmlContinueStart(code) {
        if (code === null) {
          return done(code);
        }
        if (markdownLineEnding(code)) {
          effects.enter("lineEnding");
          effects.consume(code);
          effects.exit("lineEnding");
          return htmlContinueStart;
        }
        effects.enter("htmlFlowData");
        return continuation(code);
      }
      function continuationCommentInside(code) {
        if (code === 45) {
          effects.consume(code);
          return continuationDeclarationInside;
        }
        return continuation(code);
      }
      function continuationRawTagOpen(code) {
        if (code === 47) {
          effects.consume(code);
          buffer = "";
          return continuationRawEndTag;
        }
        return continuation(code);
      }
      function continuationRawEndTag(code) {
        if (code === 62 && htmlRawNames.indexOf(buffer.toLowerCase()) > -1) {
          effects.consume(code);
          return continuationClose;
        }
        if (asciiAlpha(code) && buffer.length < 8) {
          effects.consume(code);
          buffer += fromCharCode(code);
          return continuationRawEndTag;
        }
        return continuation(code);
      }
      function continuationCharacterDataInside(code) {
        if (code === 93) {
          effects.consume(code);
          return continuationDeclarationInside;
        }
        return continuation(code);
      }
      function continuationDeclarationInside(code) {
        if (code === 62) {
          effects.consume(code);
          return continuationClose;
        }
        return continuation(code);
      }
      function continuationClose(code) {
        if (code === null || markdownLineEnding(code)) {
          effects.exit("htmlFlowData");
          return done(code);
        }
        effects.consume(code);
        return continuationClose;
      }
      function done(code) {
        effects.exit("htmlFlow");
        return ok(code);
      }
    }
    function tokenizeNextBlank(effects, ok, nok) {
      return start3;
      function start3(code) {
        effects.exit("htmlFlowData");
        effects.enter("lineEndingBlank");
        effects.consume(code);
        effects.exit("lineEndingBlank");
        return effects.attempt(partialBlankLine, ok, nok);
      }
    }
    module2.exports = htmlFlow;
  }
});

// node_modules/micromark/dist/tokenize/html-text.js
var require_html_text = __commonJS({
  "node_modules/micromark/dist/tokenize/html-text.js"(exports2, module2) {
    "use strict";
    var asciiAlpha = require_ascii_alpha();
    var asciiAlphanumeric = require_ascii_alphanumeric();
    var markdownLineEnding = require_markdown_line_ending();
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var markdownSpace = require_markdown_space();
    var factorySpace = require_factory_space();
    var htmlText = {
      name: "htmlText",
      tokenize: tokenizeHtmlText
    };
    function tokenizeHtmlText(effects, ok, nok) {
      var self2 = this;
      var marker;
      var buffer;
      var index2;
      var returnState;
      return start3;
      function start3(code) {
        effects.enter("htmlText");
        effects.enter("htmlTextData");
        effects.consume(code);
        return open;
      }
      function open(code) {
        if (code === 33) {
          effects.consume(code);
          return declarationOpen;
        }
        if (code === 47) {
          effects.consume(code);
          return tagCloseStart;
        }
        if (code === 63) {
          effects.consume(code);
          return instruction;
        }
        if (asciiAlpha(code)) {
          effects.consume(code);
          return tagOpen;
        }
        return nok(code);
      }
      function declarationOpen(code) {
        if (code === 45) {
          effects.consume(code);
          return commentOpen;
        }
        if (code === 91) {
          effects.consume(code);
          buffer = "CDATA[";
          index2 = 0;
          return cdataOpen;
        }
        if (asciiAlpha(code)) {
          effects.consume(code);
          return declaration;
        }
        return nok(code);
      }
      function commentOpen(code) {
        if (code === 45) {
          effects.consume(code);
          return commentStart;
        }
        return nok(code);
      }
      function commentStart(code) {
        if (code === null || code === 62) {
          return nok(code);
        }
        if (code === 45) {
          effects.consume(code);
          return commentStartDash;
        }
        return comment(code);
      }
      function commentStartDash(code) {
        if (code === null || code === 62) {
          return nok(code);
        }
        return comment(code);
      }
      function comment(code) {
        if (code === null) {
          return nok(code);
        }
        if (code === 45) {
          effects.consume(code);
          return commentClose;
        }
        if (markdownLineEnding(code)) {
          returnState = comment;
          return atLineEnding(code);
        }
        effects.consume(code);
        return comment;
      }
      function commentClose(code) {
        if (code === 45) {
          effects.consume(code);
          return end2;
        }
        return comment(code);
      }
      function cdataOpen(code) {
        if (code === buffer.charCodeAt(index2++)) {
          effects.consume(code);
          return index2 === buffer.length ? cdata : cdataOpen;
        }
        return nok(code);
      }
      function cdata(code) {
        if (code === null) {
          return nok(code);
        }
        if (code === 93) {
          effects.consume(code);
          return cdataClose;
        }
        if (markdownLineEnding(code)) {
          returnState = cdata;
          return atLineEnding(code);
        }
        effects.consume(code);
        return cdata;
      }
      function cdataClose(code) {
        if (code === 93) {
          effects.consume(code);
          return cdataEnd;
        }
        return cdata(code);
      }
      function cdataEnd(code) {
        if (code === 62) {
          return end2(code);
        }
        if (code === 93) {
          effects.consume(code);
          return cdataEnd;
        }
        return cdata(code);
      }
      function declaration(code) {
        if (code === null || code === 62) {
          return end2(code);
        }
        if (markdownLineEnding(code)) {
          returnState = declaration;
          return atLineEnding(code);
        }
        effects.consume(code);
        return declaration;
      }
      function instruction(code) {
        if (code === null) {
          return nok(code);
        }
        if (code === 63) {
          effects.consume(code);
          return instructionClose;
        }
        if (markdownLineEnding(code)) {
          returnState = instruction;
          return atLineEnding(code);
        }
        effects.consume(code);
        return instruction;
      }
      function instructionClose(code) {
        return code === 62 ? end2(code) : instruction(code);
      }
      function tagCloseStart(code) {
        if (asciiAlpha(code)) {
          effects.consume(code);
          return tagClose;
        }
        return nok(code);
      }
      function tagClose(code) {
        if (code === 45 || asciiAlphanumeric(code)) {
          effects.consume(code);
          return tagClose;
        }
        return tagCloseBetween(code);
      }
      function tagCloseBetween(code) {
        if (markdownLineEnding(code)) {
          returnState = tagCloseBetween;
          return atLineEnding(code);
        }
        if (markdownSpace(code)) {
          effects.consume(code);
          return tagCloseBetween;
        }
        return end2(code);
      }
      function tagOpen(code) {
        if (code === 45 || asciiAlphanumeric(code)) {
          effects.consume(code);
          return tagOpen;
        }
        if (code === 47 || code === 62 || markdownLineEndingOrSpace(code)) {
          return tagOpenBetween(code);
        }
        return nok(code);
      }
      function tagOpenBetween(code) {
        if (code === 47) {
          effects.consume(code);
          return end2;
        }
        if (code === 58 || code === 95 || asciiAlpha(code)) {
          effects.consume(code);
          return tagOpenAttributeName;
        }
        if (markdownLineEnding(code)) {
          returnState = tagOpenBetween;
          return atLineEnding(code);
        }
        if (markdownSpace(code)) {
          effects.consume(code);
          return tagOpenBetween;
        }
        return end2(code);
      }
      function tagOpenAttributeName(code) {
        if (code === 45 || code === 46 || code === 58 || code === 95 || asciiAlphanumeric(code)) {
          effects.consume(code);
          return tagOpenAttributeName;
        }
        return tagOpenAttributeNameAfter(code);
      }
      function tagOpenAttributeNameAfter(code) {
        if (code === 61) {
          effects.consume(code);
          return tagOpenAttributeValueBefore;
        }
        if (markdownLineEnding(code)) {
          returnState = tagOpenAttributeNameAfter;
          return atLineEnding(code);
        }
        if (markdownSpace(code)) {
          effects.consume(code);
          return tagOpenAttributeNameAfter;
        }
        return tagOpenBetween(code);
      }
      function tagOpenAttributeValueBefore(code) {
        if (code === null || code === 60 || code === 61 || code === 62 || code === 96) {
          return nok(code);
        }
        if (code === 34 || code === 39) {
          effects.consume(code);
          marker = code;
          return tagOpenAttributeValueQuoted;
        }
        if (markdownLineEnding(code)) {
          returnState = tagOpenAttributeValueBefore;
          return atLineEnding(code);
        }
        if (markdownSpace(code)) {
          effects.consume(code);
          return tagOpenAttributeValueBefore;
        }
        effects.consume(code);
        marker = void 0;
        return tagOpenAttributeValueUnquoted;
      }
      function tagOpenAttributeValueQuoted(code) {
        if (code === marker) {
          effects.consume(code);
          return tagOpenAttributeValueQuotedAfter;
        }
        if (code === null) {
          return nok(code);
        }
        if (markdownLineEnding(code)) {
          returnState = tagOpenAttributeValueQuoted;
          return atLineEnding(code);
        }
        effects.consume(code);
        return tagOpenAttributeValueQuoted;
      }
      function tagOpenAttributeValueQuotedAfter(code) {
        if (code === 62 || code === 47 || markdownLineEndingOrSpace(code)) {
          return tagOpenBetween(code);
        }
        return nok(code);
      }
      function tagOpenAttributeValueUnquoted(code) {
        if (code === null || code === 34 || code === 39 || code === 60 || code === 61 || code === 96) {
          return nok(code);
        }
        if (code === 62 || markdownLineEndingOrSpace(code)) {
          return tagOpenBetween(code);
        }
        effects.consume(code);
        return tagOpenAttributeValueUnquoted;
      }
      function atLineEnding(code) {
        effects.exit("htmlTextData");
        effects.enter("lineEnding");
        effects.consume(code);
        effects.exit("lineEnding");
        return factorySpace(
          effects,
          afterPrefix,
          "linePrefix",
          self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
        );
      }
      function afterPrefix(code) {
        effects.enter("htmlTextData");
        return returnState(code);
      }
      function end2(code) {
        if (code === 62) {
          effects.consume(code);
          effects.exit("htmlTextData");
          effects.exit("htmlText");
          return ok;
        }
        return nok(code);
      }
    }
    module2.exports = htmlText;
  }
});

// node_modules/micromark/dist/tokenize/label-end.js
var require_label_end = __commonJS({
  "node_modules/micromark/dist/tokenize/label-end.js"(exports2, module2) {
    "use strict";
    var markdownLineEndingOrSpace = require_markdown_line_ending_or_space();
    var chunkedPush = require_chunked_push();
    var chunkedSplice = require_chunked_splice();
    var normalizeIdentifier = require_normalize_identifier();
    var resolveAll = require_resolve_all();
    var shallow = require_shallow();
    var factoryDestination = require_factory_destination();
    var factoryLabel = require_factory_label();
    var factoryTitle = require_factory_title();
    var factoryWhitespace = require_factory_whitespace();
    var labelEnd = {
      name: "labelEnd",
      tokenize: tokenizeLabelEnd,
      resolveTo: resolveToLabelEnd,
      resolveAll: resolveAllLabelEnd
    };
    var resourceConstruct = {
      tokenize: tokenizeResource
    };
    var fullReferenceConstruct = {
      tokenize: tokenizeFullReference
    };
    var collapsedReferenceConstruct = {
      tokenize: tokenizeCollapsedReference
    };
    function resolveAllLabelEnd(events) {
      var index2 = -1;
      var token2;
      while (++index2 < events.length) {
        token2 = events[index2][1];
        if (!token2._used && (token2.type === "labelImage" || token2.type === "labelLink" || token2.type === "labelEnd")) {
          events.splice(index2 + 1, token2.type === "labelImage" ? 4 : 2);
          token2.type = "data";
          index2++;
        }
      }
      return events;
    }
    function resolveToLabelEnd(events, context) {
      var index2 = events.length;
      var offset5 = 0;
      var group;
      var label;
      var text;
      var token2;
      var open;
      var close2;
      var media;
      while (index2--) {
        token2 = events[index2][1];
        if (open) {
          if (token2.type === "link" || token2.type === "labelLink" && token2._inactive) {
            break;
          }
          if (events[index2][0] === "enter" && token2.type === "labelLink") {
            token2._inactive = true;
          }
        } else if (close2) {
          if (events[index2][0] === "enter" && (token2.type === "labelImage" || token2.type === "labelLink") && !token2._balanced) {
            open = index2;
            if (token2.type !== "labelLink") {
              offset5 = 2;
              break;
            }
          }
        } else if (token2.type === "labelEnd") {
          close2 = index2;
        }
      }
      group = {
        type: events[open][1].type === "labelLink" ? "link" : "image",
        start: shallow(events[open][1].start),
        end: shallow(events[events.length - 1][1].end)
      };
      label = {
        type: "label",
        start: shallow(events[open][1].start),
        end: shallow(events[close2][1].end)
      };
      text = {
        type: "labelText",
        start: shallow(events[open + offset5 + 2][1].end),
        end: shallow(events[close2 - 2][1].start)
      };
      media = [
        ["enter", group, context],
        ["enter", label, context]
      ];
      media = chunkedPush(media, events.slice(open + 1, open + offset5 + 3));
      media = chunkedPush(media, [["enter", text, context]]);
      media = chunkedPush(
        media,
        resolveAll(
          context.parser.constructs.insideSpan.null,
          events.slice(open + offset5 + 4, close2 - 3),
          context
        )
      );
      media = chunkedPush(media, [
        ["exit", text, context],
        events[close2 - 2],
        events[close2 - 1],
        ["exit", label, context]
      ]);
      media = chunkedPush(media, events.slice(close2 + 1));
      media = chunkedPush(media, [["exit", group, context]]);
      chunkedSplice(events, open, events.length, media);
      return events;
    }
    function tokenizeLabelEnd(effects, ok, nok) {
      var self2 = this;
      var index2 = self2.events.length;
      var labelStart;
      var defined;
      while (index2--) {
        if ((self2.events[index2][1].type === "labelImage" || self2.events[index2][1].type === "labelLink") && !self2.events[index2][1]._balanced) {
          labelStart = self2.events[index2][1];
          break;
        }
      }
      return start3;
      function start3(code) {
        if (!labelStart) {
          return nok(code);
        }
        if (labelStart._inactive)
          return balanced(code);
        defined = self2.parser.defined.indexOf(
          normalizeIdentifier(
            self2.sliceSerialize({
              start: labelStart.end,
              end: self2.now()
            })
          )
        ) > -1;
        effects.enter("labelEnd");
        effects.enter("labelMarker");
        effects.consume(code);
        effects.exit("labelMarker");
        effects.exit("labelEnd");
        return afterLabelEnd;
      }
      function afterLabelEnd(code) {
        if (code === 40) {
          return effects.attempt(
            resourceConstruct,
            ok,
            defined ? ok : balanced
          )(code);
        }
        if (code === 91) {
          return effects.attempt(
            fullReferenceConstruct,
            ok,
            defined ? effects.attempt(collapsedReferenceConstruct, ok, balanced) : balanced
          )(code);
        }
        return defined ? ok(code) : balanced(code);
      }
      function balanced(code) {
        labelStart._balanced = true;
        return nok(code);
      }
    }
    function tokenizeResource(effects, ok, nok) {
      return start3;
      function start3(code) {
        effects.enter("resource");
        effects.enter("resourceMarker");
        effects.consume(code);
        effects.exit("resourceMarker");
        return factoryWhitespace(effects, open);
      }
      function open(code) {
        if (code === 41) {
          return end2(code);
        }
        return factoryDestination(
          effects,
          destinationAfter,
          nok,
          "resourceDestination",
          "resourceDestinationLiteral",
          "resourceDestinationLiteralMarker",
          "resourceDestinationRaw",
          "resourceDestinationString",
          3
        )(code);
      }
      function destinationAfter(code) {
        return markdownLineEndingOrSpace(code) ? factoryWhitespace(effects, between)(code) : end2(code);
      }
      function between(code) {
        if (code === 34 || code === 39 || code === 40) {
          return factoryTitle(
            effects,
            factoryWhitespace(effects, end2),
            nok,
            "resourceTitle",
            "resourceTitleMarker",
            "resourceTitleString"
          )(code);
        }
        return end2(code);
      }
      function end2(code) {
        if (code === 41) {
          effects.enter("resourceMarker");
          effects.consume(code);
          effects.exit("resourceMarker");
          effects.exit("resource");
          return ok;
        }
        return nok(code);
      }
    }
    function tokenizeFullReference(effects, ok, nok) {
      var self2 = this;
      return start3;
      function start3(code) {
        return factoryLabel.call(
          self2,
          effects,
          afterLabel,
          nok,
          "reference",
          "referenceMarker",
          "referenceString"
        )(code);
      }
      function afterLabel(code) {
        return self2.parser.defined.indexOf(
          normalizeIdentifier(
            self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
          )
        ) < 0 ? nok(code) : ok(code);
      }
    }
    function tokenizeCollapsedReference(effects, ok, nok) {
      return start3;
      function start3(code) {
        effects.enter("reference");
        effects.enter("referenceMarker");
        effects.consume(code);
        effects.exit("referenceMarker");
        return open;
      }
      function open(code) {
        if (code === 93) {
          effects.enter("referenceMarker");
          effects.consume(code);
          effects.exit("referenceMarker");
          effects.exit("reference");
          return ok;
        }
        return nok(code);
      }
    }
    module2.exports = labelEnd;
  }
});

// node_modules/micromark/dist/tokenize/label-start-image.js
var require_label_start_image = __commonJS({
  "node_modules/micromark/dist/tokenize/label-start-image.js"(exports2, module2) {
    "use strict";
    var labelEnd = require_label_end();
    var labelStartImage = {
      name: "labelStartImage",
      tokenize: tokenizeLabelStartImage,
      resolveAll: labelEnd.resolveAll
    };
    function tokenizeLabelStartImage(effects, ok, nok) {
      var self2 = this;
      return start3;
      function start3(code) {
        effects.enter("labelImage");
        effects.enter("labelImageMarker");
        effects.consume(code);
        effects.exit("labelImageMarker");
        return open;
      }
      function open(code) {
        if (code === 91) {
          effects.enter("labelMarker");
          effects.consume(code);
          effects.exit("labelMarker");
          effects.exit("labelImage");
          return after;
        }
        return nok(code);
      }
      function after(code) {
        return code === 94 && /* c8 ignore next */
        "_hiddenFootnoteSupport" in self2.parser.constructs ? (
          /* c8 ignore next */
          nok(code)
        ) : ok(code);
      }
    }
    module2.exports = labelStartImage;
  }
});

// node_modules/micromark/dist/tokenize/label-start-link.js
var require_label_start_link = __commonJS({
  "node_modules/micromark/dist/tokenize/label-start-link.js"(exports2, module2) {
    "use strict";
    var labelEnd = require_label_end();
    var labelStartLink = {
      name: "labelStartLink",
      tokenize: tokenizeLabelStartLink,
      resolveAll: labelEnd.resolveAll
    };
    function tokenizeLabelStartLink(effects, ok, nok) {
      var self2 = this;
      return start3;
      function start3(code) {
        effects.enter("labelLink");
        effects.enter("labelMarker");
        effects.consume(code);
        effects.exit("labelMarker");
        effects.exit("labelLink");
        return after;
      }
      function after(code) {
        return code === 94 && /* c8 ignore next */
        "_hiddenFootnoteSupport" in self2.parser.constructs ? (
          /* c8 ignore next */
          nok(code)
        ) : ok(code);
      }
    }
    module2.exports = labelStartLink;
  }
});

// node_modules/micromark/dist/tokenize/line-ending.js
var require_line_ending = __commonJS({
  "node_modules/micromark/dist/tokenize/line-ending.js"(exports2, module2) {
    "use strict";
    var factorySpace = require_factory_space();
    var lineEnding = {
      name: "lineEnding",
      tokenize: tokenizeLineEnding
    };
    function tokenizeLineEnding(effects, ok) {
      return start3;
      function start3(code) {
        effects.enter("lineEnding");
        effects.consume(code);
        effects.exit("lineEnding");
        return factorySpace(effects, ok, "linePrefix");
      }
    }
    module2.exports = lineEnding;
  }
});

// node_modules/micromark/dist/tokenize/thematic-break.js
var require_thematic_break = __commonJS({
  "node_modules/micromark/dist/tokenize/thematic-break.js"(exports2, module2) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var markdownSpace = require_markdown_space();
    var factorySpace = require_factory_space();
    var thematicBreak = {
      name: "thematicBreak",
      tokenize: tokenizeThematicBreak
    };
    function tokenizeThematicBreak(effects, ok, nok) {
      var size2 = 0;
      var marker;
      return start3;
      function start3(code) {
        effects.enter("thematicBreak");
        marker = code;
        return atBreak(code);
      }
      function atBreak(code) {
        if (code === marker) {
          effects.enter("thematicBreakSequence");
          return sequence(code);
        }
        if (markdownSpace(code)) {
          return factorySpace(effects, atBreak, "whitespace")(code);
        }
        if (size2 < 3 || code !== null && !markdownLineEnding(code)) {
          return nok(code);
        }
        effects.exit("thematicBreak");
        return ok(code);
      }
      function sequence(code) {
        if (code === marker) {
          effects.consume(code);
          size2++;
          return sequence;
        }
        effects.exit("thematicBreakSequence");
        return atBreak(code);
      }
    }
    module2.exports = thematicBreak;
  }
});

// node_modules/micromark/dist/tokenize/list.js
var require_list = __commonJS({
  "node_modules/micromark/dist/tokenize/list.js"(exports2, module2) {
    "use strict";
    var asciiDigit = require_ascii_digit();
    var markdownSpace = require_markdown_space();
    var prefixSize = require_prefix_size();
    var sizeChunks = require_size_chunks();
    var factorySpace = require_factory_space();
    var partialBlankLine = require_partial_blank_line();
    var thematicBreak = require_thematic_break();
    var list = {
      name: "list",
      tokenize: tokenizeListStart,
      continuation: {
        tokenize: tokenizeListContinuation
      },
      exit: tokenizeListEnd
    };
    var listItemPrefixWhitespaceConstruct = {
      tokenize: tokenizeListItemPrefixWhitespace,
      partial: true
    };
    var indentConstruct = {
      tokenize: tokenizeIndent,
      partial: true
    };
    function tokenizeListStart(effects, ok, nok) {
      var self2 = this;
      var initialSize = prefixSize(self2.events, "linePrefix");
      var size2 = 0;
      return start3;
      function start3(code) {
        var kind = self2.containerState.type || (code === 42 || code === 43 || code === 45 ? "listUnordered" : "listOrdered");
        if (kind === "listUnordered" ? !self2.containerState.marker || code === self2.containerState.marker : asciiDigit(code)) {
          if (!self2.containerState.type) {
            self2.containerState.type = kind;
            effects.enter(kind, {
              _container: true
            });
          }
          if (kind === "listUnordered") {
            effects.enter("listItemPrefix");
            return code === 42 || code === 45 ? effects.check(thematicBreak, nok, atMarker)(code) : atMarker(code);
          }
          if (!self2.interrupt || code === 49) {
            effects.enter("listItemPrefix");
            effects.enter("listItemValue");
            return inside(code);
          }
        }
        return nok(code);
      }
      function inside(code) {
        if (asciiDigit(code) && ++size2 < 10) {
          effects.consume(code);
          return inside;
        }
        if ((!self2.interrupt || size2 < 2) && (self2.containerState.marker ? code === self2.containerState.marker : code === 41 || code === 46)) {
          effects.exit("listItemValue");
          return atMarker(code);
        }
        return nok(code);
      }
      function atMarker(code) {
        effects.enter("listItemMarker");
        effects.consume(code);
        effects.exit("listItemMarker");
        self2.containerState.marker = self2.containerState.marker || code;
        return effects.check(
          partialBlankLine,
          // Can’t be empty when interrupting.
          self2.interrupt ? nok : onBlank,
          effects.attempt(
            listItemPrefixWhitespaceConstruct,
            endOfPrefix,
            otherPrefix
          )
        );
      }
      function onBlank(code) {
        self2.containerState.initialBlankLine = true;
        initialSize++;
        return endOfPrefix(code);
      }
      function otherPrefix(code) {
        if (markdownSpace(code)) {
          effects.enter("listItemPrefixWhitespace");
          effects.consume(code);
          effects.exit("listItemPrefixWhitespace");
          return endOfPrefix;
        }
        return nok(code);
      }
      function endOfPrefix(code) {
        self2.containerState.size = initialSize + sizeChunks(self2.sliceStream(effects.exit("listItemPrefix")));
        return ok(code);
      }
    }
    function tokenizeListContinuation(effects, ok, nok) {
      var self2 = this;
      self2.containerState._closeFlow = void 0;
      return effects.check(partialBlankLine, onBlank, notBlank);
      function onBlank(code) {
        self2.containerState.furtherBlankLines = self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
        return factorySpace(
          effects,
          ok,
          "listItemIndent",
          self2.containerState.size + 1
        )(code);
      }
      function notBlank(code) {
        if (self2.containerState.furtherBlankLines || !markdownSpace(code)) {
          self2.containerState.furtherBlankLines = self2.containerState.initialBlankLine = void 0;
          return notInCurrentItem(code);
        }
        self2.containerState.furtherBlankLines = self2.containerState.initialBlankLine = void 0;
        return effects.attempt(indentConstruct, ok, notInCurrentItem)(code);
      }
      function notInCurrentItem(code) {
        self2.containerState._closeFlow = true;
        self2.interrupt = void 0;
        return factorySpace(
          effects,
          effects.attempt(list, ok, nok),
          "linePrefix",
          self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4
        )(code);
      }
    }
    function tokenizeIndent(effects, ok, nok) {
      var self2 = this;
      return factorySpace(
        effects,
        afterPrefix,
        "listItemIndent",
        self2.containerState.size + 1
      );
      function afterPrefix(code) {
        return prefixSize(self2.events, "listItemIndent") === self2.containerState.size ? ok(code) : nok(code);
      }
    }
    function tokenizeListEnd(effects) {
      effects.exit(this.containerState.type);
    }
    function tokenizeListItemPrefixWhitespace(effects, ok, nok) {
      var self2 = this;
      return factorySpace(
        effects,
        afterPrefix,
        "listItemPrefixWhitespace",
        self2.parser.constructs.disable.null.indexOf("codeIndented") > -1 ? void 0 : 4 + 1
      );
      function afterPrefix(code) {
        return markdownSpace(code) || !prefixSize(self2.events, "listItemPrefixWhitespace") ? nok(code) : ok(code);
      }
    }
    module2.exports = list;
  }
});

// node_modules/micromark/dist/tokenize/setext-underline.js
var require_setext_underline = __commonJS({
  "node_modules/micromark/dist/tokenize/setext-underline.js"(exports2, module2) {
    "use strict";
    var markdownLineEnding = require_markdown_line_ending();
    var shallow = require_shallow();
    var factorySpace = require_factory_space();
    var setextUnderline = {
      name: "setextUnderline",
      tokenize: tokenizeSetextUnderline,
      resolveTo: resolveToSetextUnderline
    };
    function resolveToSetextUnderline(events, context) {
      var index2 = events.length;
      var content;
      var text;
      var definition;
      var heading;
      while (index2--) {
        if (events[index2][0] === "enter") {
          if (events[index2][1].type === "content") {
            content = index2;
            break;
          }
          if (events[index2][1].type === "paragraph") {
            text = index2;
          }
        } else {
          if (events[index2][1].type === "content") {
            events.splice(index2, 1);
          }
          if (!definition && events[index2][1].type === "definition") {
            definition = index2;
          }
        }
      }
      heading = {
        type: "setextHeading",
        start: shallow(events[text][1].start),
        end: shallow(events[events.length - 1][1].end)
      };
      events[text][1].type = "setextHeadingText";
      if (definition) {
        events.splice(text, 0, ["enter", heading, context]);
        events.splice(definition + 1, 0, ["exit", events[content][1], context]);
        events[content][1].end = shallow(events[definition][1].end);
      } else {
        events[content][1] = heading;
      }
      events.push(["exit", heading, context]);
      return events;
    }
    function tokenizeSetextUnderline(effects, ok, nok) {
      var self2 = this;
      var index2 = self2.events.length;
      var marker;
      var paragraph;
      while (index2--) {
        if (self2.events[index2][1].type !== "lineEnding" && self2.events[index2][1].type !== "linePrefix" && self2.events[index2][1].type !== "content") {
          paragraph = self2.events[index2][1].type === "paragraph";
          break;
        }
      }
      return start3;
      function start3(code) {
        if (!self2.lazy && (self2.interrupt || paragraph)) {
          effects.enter("setextHeadingLine");
          effects.enter("setextHeadingLineSequence");
          marker = code;
          return closingSequence(code);
        }
        return nok(code);
      }
      function closingSequence(code) {
        if (code === marker) {
          effects.consume(code);
          return closingSequence;
        }
        effects.exit("setextHeadingLineSequence");
        return factorySpace(effects, closingSequenceEnd, "lineSuffix")(code);
      }
      function closingSequenceEnd(code) {
        if (code === null || markdownLineEnding(code)) {
          effects.exit("setextHeadingLine");
          return ok(code);
        }
        return nok(code);
      }
    }
    module2.exports = setextUnderline;
  }
});

// node_modules/micromark/dist/constructs.js
var require_constructs = __commonJS({
  "node_modules/micromark/dist/constructs.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var text$1 = require_text();
    var attention = require_attention();
    var autolink = require_autolink();
    var blockQuote = require_block_quote();
    var characterEscape = require_character_escape();
    var characterReference = require_character_reference();
    var codeFenced = require_code_fenced();
    var codeIndented = require_code_indented();
    var codeText = require_code_text();
    var definition = require_definition();
    var hardBreakEscape = require_hard_break_escape();
    var headingAtx = require_heading_atx();
    var htmlFlow = require_html_flow();
    var htmlText = require_html_text();
    var labelEnd = require_label_end();
    var labelStartImage = require_label_start_image();
    var labelStartLink = require_label_start_link();
    var lineEnding = require_line_ending();
    var list = require_list();
    var setextUnderline = require_setext_underline();
    var thematicBreak = require_thematic_break();
    var document2 = {
      42: list,
      // Asterisk
      43: list,
      // Plus sign
      45: list,
      // Dash
      48: list,
      // 0
      49: list,
      // 1
      50: list,
      // 2
      51: list,
      // 3
      52: list,
      // 4
      53: list,
      // 5
      54: list,
      // 6
      55: list,
      // 7
      56: list,
      // 8
      57: list,
      // 9
      62: blockQuote
      // Greater than
    };
    var contentInitial = {
      91: definition
      // Left square bracket
    };
    var flowInitial = {
      "-2": codeIndented,
      // Horizontal tab
      "-1": codeIndented,
      // Virtual space
      32: codeIndented
      // Space
    };
    var flow = {
      35: headingAtx,
      // Number sign
      42: thematicBreak,
      // Asterisk
      45: [setextUnderline, thematicBreak],
      // Dash
      60: htmlFlow,
      // Less than
      61: setextUnderline,
      // Equals to
      95: thematicBreak,
      // Underscore
      96: codeFenced,
      // Grave accent
      126: codeFenced
      // Tilde
    };
    var string2 = {
      38: characterReference,
      // Ampersand
      92: characterEscape
      // Backslash
    };
    var text = {
      "-5": lineEnding,
      // Carriage return
      "-4": lineEnding,
      // Line feed
      "-3": lineEnding,
      // Carriage return + line feed
      33: labelStartImage,
      // Exclamation mark
      38: characterReference,
      // Ampersand
      42: attention,
      // Asterisk
      60: [autolink, htmlText],
      // Less than
      91: labelStartLink,
      // Left square bracket
      92: [hardBreakEscape, characterEscape],
      // Backslash
      93: labelEnd,
      // Right square bracket
      95: attention,
      // Underscore
      96: codeText
      // Grave accent
    };
    var insideSpan = {
      null: [attention, text$1.resolver]
    };
    var disable = {
      null: []
    };
    exports2.contentInitial = contentInitial;
    exports2.disable = disable;
    exports2.document = document2;
    exports2.flow = flow;
    exports2.flowInitial = flowInitial;
    exports2.insideSpan = insideSpan;
    exports2.string = string2;
    exports2.text = text;
  }
});

// node_modules/micromark/dist/parse.js
var require_parse = __commonJS({
  "node_modules/micromark/dist/parse.js"(exports2, module2) {
    "use strict";
    var content = require_content();
    var document2 = require_document();
    var flow = require_flow();
    var text = require_text();
    var combineExtensions = require_combine_extensions();
    var createTokenizer = require_create_tokenizer();
    var miniflat = require_miniflat();
    var constructs = require_constructs();
    function parse6(options) {
      var settings = options || {};
      var parser = {
        defined: [],
        constructs: combineExtensions(
          [constructs].concat(miniflat(settings.extensions))
        ),
        content: create14(content),
        document: create14(document2),
        flow: create14(flow),
        string: create14(text.string),
        text: create14(text.text)
      };
      return parser;
      function create14(initializer) {
        return creator;
        function creator(from2) {
          return createTokenizer(parser, initializer, from2);
        }
      }
    }
    module2.exports = parse6;
  }
});

// node_modules/micromark/dist/preprocess.js
var require_preprocess = __commonJS({
  "node_modules/micromark/dist/preprocess.js"(exports2, module2) {
    "use strict";
    var search = /[\0\t\n\r]/g;
    function preprocess() {
      var start3 = true;
      var column = 1;
      var buffer = "";
      var atCarriageReturn;
      return preprocessor;
      function preprocessor(value, encoding, end2) {
        var chunks = [];
        var match5;
        var next;
        var startPosition;
        var endPosition;
        var code;
        value = buffer + value.toString(encoding);
        startPosition = 0;
        buffer = "";
        if (start3) {
          if (value.charCodeAt(0) === 65279) {
            startPosition++;
          }
          start3 = void 0;
        }
        while (startPosition < value.length) {
          search.lastIndex = startPosition;
          match5 = search.exec(value);
          endPosition = match5 ? match5.index : value.length;
          code = value.charCodeAt(endPosition);
          if (!match5) {
            buffer = value.slice(startPosition);
            break;
          }
          if (code === 10 && startPosition === endPosition && atCarriageReturn) {
            chunks.push(-3);
            atCarriageReturn = void 0;
          } else {
            if (atCarriageReturn) {
              chunks.push(-5);
              atCarriageReturn = void 0;
            }
            if (startPosition < endPosition) {
              chunks.push(value.slice(startPosition, endPosition));
              column += endPosition - startPosition;
            }
            if (code === 0) {
              chunks.push(65533);
              column++;
            } else if (code === 9) {
              next = Math.ceil(column / 4) * 4;
              chunks.push(-2);
              while (column++ < next)
                chunks.push(-1);
            } else if (code === 10) {
              chunks.push(-4);
              column = 1;
            } else {
              atCarriageReturn = true;
              column = 1;
            }
          }
          startPosition = endPosition + 1;
        }
        if (end2) {
          if (atCarriageReturn)
            chunks.push(-5);
          if (buffer)
            chunks.push(buffer);
          chunks.push(null);
        }
        return chunks;
      }
    }
    module2.exports = preprocess;
  }
});

// node_modules/micromark/dist/postprocess.js
var require_postprocess = __commonJS({
  "node_modules/micromark/dist/postprocess.js"(exports2, module2) {
    "use strict";
    var subtokenize = require_subtokenize();
    function postprocess(events) {
      while (!subtokenize(events)) {
      }
      return events;
    }
    module2.exports = postprocess;
  }
});

// node_modules/remark-parse/node_modules/parse-entities/decode-entity.browser.js
var require_decode_entity_browser2 = __commonJS({
  "node_modules/remark-parse/node_modules/parse-entities/decode-entity.browser.js"(exports2, module2) {
    "use strict";
    var el;
    var semicolon = 59;
    module2.exports = decodeEntity;
    function decodeEntity(characters) {
      var entity = "&" + characters + ";";
      var char;
      el = el || document.createElement("i");
      el.innerHTML = entity;
      char = el.textContent;
      if (char.charCodeAt(char.length - 1) === semicolon && characters !== "semi") {
        return false;
      }
      return char === entity ? false : char;
    }
  }
});

// node_modules/remark-parse/node_modules/unist-util-stringify-position/index.js
var require_unist_util_stringify_position = __commonJS({
  "node_modules/remark-parse/node_modules/unist-util-stringify-position/index.js"(exports2, module2) {
    "use strict";
    var own = {}.hasOwnProperty;
    module2.exports = stringify;
    function stringify(value) {
      if (!value || typeof value !== "object") {
        return "";
      }
      if (own.call(value, "position") || own.call(value, "type")) {
        return position3(value.position);
      }
      if (own.call(value, "start") || own.call(value, "end")) {
        return position3(value);
      }
      if (own.call(value, "line") || own.call(value, "column")) {
        return point(value);
      }
      return "";
    }
    function point(point2) {
      if (!point2 || typeof point2 !== "object") {
        point2 = {};
      }
      return index2(point2.line) + ":" + index2(point2.column);
    }
    function position3(pos) {
      if (!pos || typeof pos !== "object") {
        pos = {};
      }
      return point(pos.start) + "-" + point(pos.end);
    }
    function index2(value) {
      return value && typeof value === "number" ? value : 1;
    }
  }
});

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/dist/index.js
var require_dist = __commonJS({
  "node_modules/remark-parse/node_modules/mdast-util-from-markdown/dist/index.js"(exports2, module2) {
    "use strict";
    module2.exports = fromMarkdown;
    var toString7 = require_mdast_util_to_string();
    var assign = require_assign();
    var own = require_has_own_property();
    var normalizeIdentifier = require_normalize_identifier();
    var safeFromInt = require_safe_from_int();
    var parser = require_parse();
    var preprocessor = require_preprocess();
    var postprocess = require_postprocess();
    var decode2 = require_decode_entity_browser2();
    var stringifyPosition = require_unist_util_stringify_position();
    function fromMarkdown(value, encoding, options) {
      if (typeof encoding !== "string") {
        options = encoding;
        encoding = void 0;
      }
      return compiler(options)(
        postprocess(
          parser(options).document().write(preprocessor()(value, encoding, true))
        )
      );
    }
    function compiler(options) {
      var settings = options || {};
      var config2 = configure(
        {
          transforms: [],
          canContainEols: [
            "emphasis",
            "fragment",
            "heading",
            "paragraph",
            "strong"
          ],
          enter: {
            autolink: opener(link),
            autolinkProtocol: onenterdata,
            autolinkEmail: onenterdata,
            atxHeading: opener(heading),
            blockQuote: opener(blockQuote),
            characterEscape: onenterdata,
            characterReference: onenterdata,
            codeFenced: opener(codeFlow),
            codeFencedFenceInfo: buffer,
            codeFencedFenceMeta: buffer,
            codeIndented: opener(codeFlow, buffer),
            codeText: opener(codeText, buffer),
            codeTextData: onenterdata,
            data: onenterdata,
            codeFlowValue: onenterdata,
            definition: opener(definition),
            definitionDestinationString: buffer,
            definitionLabelString: buffer,
            definitionTitleString: buffer,
            emphasis: opener(emphasis),
            hardBreakEscape: opener(hardBreak),
            hardBreakTrailing: opener(hardBreak),
            htmlFlow: opener(html, buffer),
            htmlFlowData: onenterdata,
            htmlText: opener(html, buffer),
            htmlTextData: onenterdata,
            image: opener(image),
            label: buffer,
            link: opener(link),
            listItem: opener(listItem),
            listItemValue: onenterlistitemvalue,
            listOrdered: opener(list, onenterlistordered),
            listUnordered: opener(list),
            paragraph: opener(paragraph),
            reference: onenterreference,
            referenceString: buffer,
            resourceDestinationString: buffer,
            resourceTitleString: buffer,
            setextHeading: opener(heading),
            strong: opener(strong),
            thematicBreak: opener(thematicBreak)
          },
          exit: {
            atxHeading: closer(),
            atxHeadingSequence: onexitatxheadingsequence,
            autolink: closer(),
            autolinkEmail: onexitautolinkemail,
            autolinkProtocol: onexitautolinkprotocol,
            blockQuote: closer(),
            characterEscapeValue: onexitdata,
            characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
            characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
            characterReferenceValue: onexitcharacterreferencevalue,
            codeFenced: closer(onexitcodefenced),
            codeFencedFence: onexitcodefencedfence,
            codeFencedFenceInfo: onexitcodefencedfenceinfo,
            codeFencedFenceMeta: onexitcodefencedfencemeta,
            codeFlowValue: onexitdata,
            codeIndented: closer(onexitcodeindented),
            codeText: closer(onexitcodetext),
            codeTextData: onexitdata,
            data: onexitdata,
            definition: closer(),
            definitionDestinationString: onexitdefinitiondestinationstring,
            definitionLabelString: onexitdefinitionlabelstring,
            definitionTitleString: onexitdefinitiontitlestring,
            emphasis: closer(),
            hardBreakEscape: closer(onexithardbreak),
            hardBreakTrailing: closer(onexithardbreak),
            htmlFlow: closer(onexithtmlflow),
            htmlFlowData: onexitdata,
            htmlText: closer(onexithtmltext),
            htmlTextData: onexitdata,
            image: closer(onexitimage),
            label: onexitlabel,
            labelText: onexitlabeltext,
            lineEnding: onexitlineending,
            link: closer(onexitlink),
            listItem: closer(),
            listOrdered: closer(),
            listUnordered: closer(),
            paragraph: closer(),
            referenceString: onexitreferencestring,
            resourceDestinationString: onexitresourcedestinationstring,
            resourceTitleString: onexitresourcetitlestring,
            resource: onexitresource,
            setextHeading: closer(onexitsetextheading),
            setextHeadingLineSequence: onexitsetextheadinglinesequence,
            setextHeadingText: onexitsetextheadingtext,
            strong: closer(),
            thematicBreak: closer()
          }
        },
        settings.mdastExtensions || []
      );
      var data = {};
      return compile;
      function compile(events) {
        var tree = { type: "root", children: [] };
        var stack = [tree];
        var tokenStack = [];
        var listStack = [];
        var index2 = -1;
        var handler;
        var listStart;
        var context = {
          stack,
          tokenStack,
          config: config2,
          enter: enter2,
          exit,
          buffer,
          resume,
          setData,
          getData
        };
        while (++index2 < events.length) {
          if (events[index2][1].type === "listOrdered" || events[index2][1].type === "listUnordered") {
            if (events[index2][0] === "enter") {
              listStack.push(index2);
            } else {
              listStart = listStack.pop(index2);
              index2 = prepareList(events, listStart, index2);
            }
          }
        }
        index2 = -1;
        while (++index2 < events.length) {
          handler = config2[events[index2][0]];
          if (own.call(handler, events[index2][1].type)) {
            handler[events[index2][1].type].call(
              assign({ sliceSerialize: events[index2][2].sliceSerialize }, context),
              events[index2][1]
            );
          }
        }
        if (tokenStack.length) {
          throw new Error(
            "Cannot close document, a token (`" + tokenStack[tokenStack.length - 1].type + "`, " + stringifyPosition({
              start: tokenStack[tokenStack.length - 1].start,
              end: tokenStack[tokenStack.length - 1].end
            }) + ") is still open"
          );
        }
        tree.position = {
          start: point(
            events.length ? events[0][1].start : { line: 1, column: 1, offset: 0 }
          ),
          end: point(
            events.length ? events[events.length - 2][1].end : { line: 1, column: 1, offset: 0 }
          )
        };
        index2 = -1;
        while (++index2 < config2.transforms.length) {
          tree = config2.transforms[index2](tree) || tree;
        }
        return tree;
      }
      function prepareList(events, start3, length) {
        var index2 = start3 - 1;
        var containerBalance = -1;
        var listSpread = false;
        var listItem2;
        var tailIndex;
        var lineIndex;
        var tailEvent;
        var event;
        var firstBlankLineIndex;
        var atMarker;
        while (++index2 <= length) {
          event = events[index2];
          if (event[1].type === "listUnordered" || event[1].type === "listOrdered" || event[1].type === "blockQuote") {
            if (event[0] === "enter") {
              containerBalance++;
            } else {
              containerBalance--;
            }
            atMarker = void 0;
          } else if (event[1].type === "lineEndingBlank") {
            if (event[0] === "enter") {
              if (listItem2 && !atMarker && !containerBalance && !firstBlankLineIndex) {
                firstBlankLineIndex = index2;
              }
              atMarker = void 0;
            }
          } else if (event[1].type === "linePrefix" || event[1].type === "listItemValue" || event[1].type === "listItemMarker" || event[1].type === "listItemPrefix" || event[1].type === "listItemPrefixWhitespace") {
          } else {
            atMarker = void 0;
          }
          if (!containerBalance && event[0] === "enter" && event[1].type === "listItemPrefix" || containerBalance === -1 && event[0] === "exit" && (event[1].type === "listUnordered" || event[1].type === "listOrdered")) {
            if (listItem2) {
              tailIndex = index2;
              lineIndex = void 0;
              while (tailIndex--) {
                tailEvent = events[tailIndex];
                if (tailEvent[1].type === "lineEnding" || tailEvent[1].type === "lineEndingBlank") {
                  if (tailEvent[0] === "exit")
                    continue;
                  if (lineIndex) {
                    events[lineIndex][1].type = "lineEndingBlank";
                    listSpread = true;
                  }
                  tailEvent[1].type = "lineEnding";
                  lineIndex = tailIndex;
                } else if (tailEvent[1].type === "linePrefix" || tailEvent[1].type === "blockQuotePrefix" || tailEvent[1].type === "blockQuotePrefixWhitespace" || tailEvent[1].type === "blockQuoteMarker" || tailEvent[1].type === "listItemIndent") {
                } else {
                  break;
                }
              }
              if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
                listItem2._spread = true;
              }
              listItem2.end = point(
                lineIndex ? events[lineIndex][1].start : event[1].end
              );
              events.splice(lineIndex || index2, 0, ["exit", listItem2, event[2]]);
              index2++;
              length++;
            }
            if (event[1].type === "listItemPrefix") {
              listItem2 = {
                type: "listItem",
                _spread: false,
                start: point(event[1].start)
              };
              events.splice(index2, 0, ["enter", listItem2, event[2]]);
              index2++;
              length++;
              firstBlankLineIndex = void 0;
              atMarker = true;
            }
          }
        }
        events[start3][1]._spread = listSpread;
        return length;
      }
      function setData(key, value) {
        data[key] = value;
      }
      function getData(key) {
        return data[key];
      }
      function point(d17) {
        return { line: d17.line, column: d17.column, offset: d17.offset };
      }
      function opener(create14, and) {
        return open;
        function open(token2) {
          enter2.call(this, create14(token2), token2);
          if (and)
            and.call(this, token2);
        }
      }
      function buffer() {
        this.stack.push({ type: "fragment", children: [] });
      }
      function enter2(node, token2) {
        this.stack[this.stack.length - 1].children.push(node);
        this.stack.push(node);
        this.tokenStack.push(token2);
        node.position = { start: point(token2.start) };
        return node;
      }
      function closer(and) {
        return close2;
        function close2(token2) {
          if (and)
            and.call(this, token2);
          exit.call(this, token2);
        }
      }
      function exit(token2) {
        var node = this.stack.pop();
        var open = this.tokenStack.pop();
        if (!open) {
          throw new Error(
            "Cannot close `" + token2.type + "` (" + stringifyPosition({ start: token2.start, end: token2.end }) + "): it’s not open"
          );
        } else if (open.type !== token2.type) {
          throw new Error(
            "Cannot close `" + token2.type + "` (" + stringifyPosition({ start: token2.start, end: token2.end }) + "): a different token (`" + open.type + "`, " + stringifyPosition({ start: open.start, end: open.end }) + ") is open"
          );
        }
        node.position.end = point(token2.end);
        return node;
      }
      function resume() {
        return toString7(this.stack.pop());
      }
      function onenterlistordered() {
        setData("expectingFirstListItemValue", true);
      }
      function onenterlistitemvalue(token2) {
        if (getData("expectingFirstListItemValue")) {
          this.stack[this.stack.length - 2].start = parseInt(
            this.sliceSerialize(token2),
            10
          );
          setData("expectingFirstListItemValue");
        }
      }
      function onexitcodefencedfenceinfo() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].lang = data2;
      }
      function onexitcodefencedfencemeta() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].meta = data2;
      }
      function onexitcodefencedfence() {
        if (getData("flowCodeInside"))
          return;
        this.buffer();
        setData("flowCodeInside", true);
      }
      function onexitcodefenced() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].value = data2.replace(
          /^(\r?\n|\r)|(\r?\n|\r)$/g,
          ""
        );
        setData("flowCodeInside");
      }
      function onexitcodeindented() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].value = data2;
      }
      function onexitdefinitionlabelstring(token2) {
        var label = this.resume();
        this.stack[this.stack.length - 1].label = label;
        this.stack[this.stack.length - 1].identifier = normalizeIdentifier(
          this.sliceSerialize(token2)
        ).toLowerCase();
      }
      function onexitdefinitiontitlestring() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].title = data2;
      }
      function onexitdefinitiondestinationstring() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].url = data2;
      }
      function onexitatxheadingsequence(token2) {
        if (!this.stack[this.stack.length - 1].depth) {
          this.stack[this.stack.length - 1].depth = this.sliceSerialize(
            token2
          ).length;
        }
      }
      function onexitsetextheadingtext() {
        setData("setextHeadingSlurpLineEnding", true);
      }
      function onexitsetextheadinglinesequence(token2) {
        this.stack[this.stack.length - 1].depth = this.sliceSerialize(token2).charCodeAt(0) === 61 ? 1 : 2;
      }
      function onexitsetextheading() {
        setData("setextHeadingSlurpLineEnding");
      }
      function onenterdata(token2) {
        var siblings = this.stack[this.stack.length - 1].children;
        var tail = siblings[siblings.length - 1];
        if (!tail || tail.type !== "text") {
          tail = text();
          tail.position = { start: point(token2.start) };
          this.stack[this.stack.length - 1].children.push(tail);
        }
        this.stack.push(tail);
      }
      function onexitdata(token2) {
        var tail = this.stack.pop();
        tail.value += this.sliceSerialize(token2);
        tail.position.end = point(token2.end);
      }
      function onexitlineending(token2) {
        var context = this.stack[this.stack.length - 1];
        if (getData("atHardBreak")) {
          context.children[context.children.length - 1].position.end = point(
            token2.end
          );
          setData("atHardBreak");
          return;
        }
        if (!getData("setextHeadingSlurpLineEnding") && config2.canContainEols.indexOf(context.type) > -1) {
          onenterdata.call(this, token2);
          onexitdata.call(this, token2);
        }
      }
      function onexithardbreak() {
        setData("atHardBreak", true);
      }
      function onexithtmlflow() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].value = data2;
      }
      function onexithtmltext() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].value = data2;
      }
      function onexitcodetext() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].value = data2;
      }
      function onexitlink() {
        var context = this.stack[this.stack.length - 1];
        if (getData("inReference")) {
          context.type += "Reference";
          context.referenceType = getData("referenceType") || "shortcut";
          delete context.url;
          delete context.title;
        } else {
          delete context.identifier;
          delete context.label;
          delete context.referenceType;
        }
        setData("referenceType");
      }
      function onexitimage() {
        var context = this.stack[this.stack.length - 1];
        if (getData("inReference")) {
          context.type += "Reference";
          context.referenceType = getData("referenceType") || "shortcut";
          delete context.url;
          delete context.title;
        } else {
          delete context.identifier;
          delete context.label;
          delete context.referenceType;
        }
        setData("referenceType");
      }
      function onexitlabeltext(token2) {
        this.stack[this.stack.length - 2].identifier = normalizeIdentifier(
          this.sliceSerialize(token2)
        ).toLowerCase();
      }
      function onexitlabel() {
        var fragment = this.stack[this.stack.length - 1];
        var value = this.resume();
        this.stack[this.stack.length - 1].label = value;
        setData("inReference", true);
        if (this.stack[this.stack.length - 1].type === "link") {
          this.stack[this.stack.length - 1].children = fragment.children;
        } else {
          this.stack[this.stack.length - 1].alt = value;
        }
      }
      function onexitresourcedestinationstring() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].url = data2;
      }
      function onexitresourcetitlestring() {
        var data2 = this.resume();
        this.stack[this.stack.length - 1].title = data2;
      }
      function onexitresource() {
        setData("inReference");
      }
      function onenterreference() {
        setData("referenceType", "collapsed");
      }
      function onexitreferencestring(token2) {
        var label = this.resume();
        this.stack[this.stack.length - 1].label = label;
        this.stack[this.stack.length - 1].identifier = normalizeIdentifier(
          this.sliceSerialize(token2)
        ).toLowerCase();
        setData("referenceType", "full");
      }
      function onexitcharacterreferencemarker(token2) {
        setData("characterReferenceType", token2.type);
      }
      function onexitcharacterreferencevalue(token2) {
        var data2 = this.sliceSerialize(token2);
        var type = getData("characterReferenceType");
        var value;
        var tail;
        if (type) {
          value = safeFromInt(
            data2,
            type === "characterReferenceMarkerNumeric" ? 10 : 16
          );
          setData("characterReferenceType");
        } else {
          value = decode2(data2);
        }
        tail = this.stack.pop();
        tail.value += value;
        tail.position.end = point(token2.end);
      }
      function onexitautolinkprotocol(token2) {
        onexitdata.call(this, token2);
        this.stack[this.stack.length - 1].url = this.sliceSerialize(token2);
      }
      function onexitautolinkemail(token2) {
        onexitdata.call(this, token2);
        this.stack[this.stack.length - 1].url = "mailto:" + this.sliceSerialize(token2);
      }
      function blockQuote() {
        return { type: "blockquote", children: [] };
      }
      function codeFlow() {
        return { type: "code", lang: null, meta: null, value: "" };
      }
      function codeText() {
        return { type: "inlineCode", value: "" };
      }
      function definition() {
        return {
          type: "definition",
          identifier: "",
          label: null,
          title: null,
          url: ""
        };
      }
      function emphasis() {
        return { type: "emphasis", children: [] };
      }
      function heading() {
        return { type: "heading", depth: void 0, children: [] };
      }
      function hardBreak() {
        return { type: "break" };
      }
      function html() {
        return { type: "html", value: "" };
      }
      function image() {
        return { type: "image", title: null, url: "", alt: null };
      }
      function link() {
        return { type: "link", title: null, url: "", children: [] };
      }
      function list(token2) {
        return {
          type: "list",
          ordered: token2.type === "listOrdered",
          start: null,
          spread: token2._spread,
          children: []
        };
      }
      function listItem(token2) {
        return {
          type: "listItem",
          spread: token2._spread,
          checked: null,
          children: []
        };
      }
      function paragraph() {
        return { type: "paragraph", children: [] };
      }
      function strong() {
        return { type: "strong", children: [] };
      }
      function text() {
        return { type: "text", value: "" };
      }
      function thematicBreak() {
        return { type: "thematicBreak" };
      }
    }
    function configure(config2, extensions) {
      var index2 = -1;
      while (++index2 < extensions.length) {
        extension(config2, extensions[index2]);
      }
      return config2;
    }
    function extension(config2, extension2) {
      var key;
      var left;
      for (key in extension2) {
        left = own.call(config2, key) ? config2[key] : config2[key] = {};
        if (key === "canContainEols" || key === "transforms") {
          config2[key] = [].concat(left, extension2[key]);
        } else {
          Object.assign(left, extension2[key]);
        }
      }
    }
  }
});

// node_modules/remark-parse/node_modules/mdast-util-from-markdown/index.js
var require_mdast_util_from_markdown = __commonJS({
  "node_modules/remark-parse/node_modules/mdast-util-from-markdown/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_dist();
  }
});

// node_modules/remark-parse/index.js
var require_remark_parse = __commonJS({
  "node_modules/remark-parse/index.js"(exports2, module2) {
    "use strict";
    module2.exports = parse6;
    var fromMarkdown = require_mdast_util_from_markdown();
    function parse6(options) {
      var self2 = this;
      this.Parser = parse7;
      function parse7(doc) {
        return fromMarkdown(
          doc,
          Object.assign({}, self2.data("settings"), options, {
            // Note: these options are not in the readme.
            // The goal is for them to be set by plugins on `data` instead of being
            // passed by users.
            extensions: self2.data("micromarkExtensions") || [],
            mdastExtensions: self2.data("fromMarkdownExtensions") || []
          })
        );
      }
    }
  }
});

// node_modules/escape-html/index.js
var require_escape_html = __commonJS({
  "node_modules/escape-html/index.js"(exports2, module2) {
    "use strict";
    var matchHtmlRegExp = /["'&<>]/;
    module2.exports = escapeHtml2;
    function escapeHtml2(string2) {
      var str = "" + string2;
      var match5 = matchHtmlRegExp.exec(str);
      if (!match5) {
        return str;
      }
      var escape2;
      var html = "";
      var index2 = 0;
      var lastIndex = 0;
      for (index2 = match5.index; index2 < str.length; index2++) {
        switch (str.charCodeAt(index2)) {
          case 34:
            escape2 = "&quot;";
            break;
          case 38:
            escape2 = "&amp;";
            break;
          case 39:
            escape2 = "&#39;";
            break;
          case 60:
            escape2 = "&lt;";
            break;
          case 62:
            escape2 = "&gt;";
            break;
          default:
            continue;
        }
        if (lastIndex !== index2) {
          html += str.substring(lastIndex, index2);
        }
        lastIndex = index2 + 1;
        html += escape2;
      }
      return lastIndex !== index2 ? html + str.substring(lastIndex, index2) : html;
    }
  }
});

// node_modules/@udecode/plate-serializer-md/node_modules/bail/index.js
var require_bail = __commonJS({
  "node_modules/@udecode/plate-serializer-md/node_modules/bail/index.js"(exports2, module2) {
    "use strict";
    module2.exports = bail;
    function bail(err) {
      if (err) {
        throw err;
      }
    }
  }
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
  "node_modules/is-buffer/index.js"(exports2, module2) {
    module2.exports = function isBuffer2(obj) {
      return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
    };
  }
});

// node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/extend/index.js"(exports2, module2) {
    "use strict";
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty6 = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray10 = function isArray11(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    };
    var isPlainObject7 = function isPlainObject8(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    };
    var setProperty = function setProperty2(target, options) {
      if (defineProperty6 && options.name === "__proto__") {
        defineProperty6(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    };
    var getProperty = function getProperty2(obj, name2) {
      if (name2 === "__proto__") {
        if (!hasOwn.call(obj, name2)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name2).value;
        }
      }
      return obj[name2];
    };
    module2.exports = function extend2() {
      var options, name2, src, copy, copyIsArray, clone4;
      var target = arguments[0];
      var i15 = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i15 = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i15 < length; ++i15) {
        options = arguments[i15];
        if (options != null) {
          for (name2 in options) {
            src = getProperty(target, name2);
            copy = getProperty(options, name2);
            if (target !== copy) {
              if (deep && copy && (isPlainObject7(copy) || (copyIsArray = isArray10(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone4 = src && isArray10(src) ? src : [];
                } else {
                  clone4 = src && isPlainObject7(src) ? src : {};
                }
                setProperty(target, { name: name2, newValue: extend2(deep, clone4, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name: name2, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    };
  }
});

// node_modules/@udecode/plate-serializer-md/node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS({
  "node_modules/@udecode/plate-serializer-md/node_modules/is-plain-obj/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (value) => {
      if (Object.prototype.toString.call(value) !== "[object Object]") {
        return false;
      }
      const prototype = Object.getPrototypeOf(value);
      return prototype === null || prototype === Object.prototype;
    };
  }
});

// node_modules/@udecode/plate-serializer-md/node_modules/trough/wrap.js
var require_wrap = __commonJS({
  "node_modules/@udecode/plate-serializer-md/node_modules/trough/wrap.js"(exports2, module2) {
    "use strict";
    var slice = [].slice;
    module2.exports = wrap;
    function wrap(fn2, callback) {
      var invoked;
      return wrapped;
      function wrapped() {
        var params = slice.call(arguments, 0);
        var callback2 = fn2.length > params.length;
        var result;
        if (callback2) {
          params.push(done);
        }
        try {
          result = fn2.apply(null, params);
        } catch (error2) {
          if (callback2 && invoked) {
            throw error2;
          }
          return done(error2);
        }
        if (!callback2) {
          if (result && typeof result.then === "function") {
            result.then(then, done);
          } else if (result instanceof Error) {
            done(result);
          } else {
            then(result);
          }
        }
      }
      function done() {
        if (!invoked) {
          invoked = true;
          callback.apply(null, arguments);
        }
      }
      function then(value) {
        done(null, value);
      }
    }
  }
});

// node_modules/@udecode/plate-serializer-md/node_modules/trough/index.js
var require_trough = __commonJS({
  "node_modules/@udecode/plate-serializer-md/node_modules/trough/index.js"(exports2, module2) {
    "use strict";
    var wrap = require_wrap();
    module2.exports = trough;
    trough.wrap = wrap;
    var slice = [].slice;
    function trough() {
      var fns = [];
      var middleware = {};
      middleware.run = run;
      middleware.use = use;
      return middleware;
      function run() {
        var index2 = -1;
        var input = slice.call(arguments, 0, -1);
        var done = arguments[arguments.length - 1];
        if (typeof done !== "function") {
          throw new Error("Expected function as last argument, not " + done);
        }
        next.apply(null, [null].concat(input));
        function next(err) {
          var fn2 = fns[++index2];
          var params = slice.call(arguments, 0);
          var values3 = params.slice(1);
          var length = input.length;
          var pos = -1;
          if (err) {
            done(err);
            return;
          }
          while (++pos < length) {
            if (values3[pos] === null || values3[pos] === void 0) {
              values3[pos] = input[pos];
            }
          }
          input = values3;
          if (fn2) {
            wrap(fn2, next).apply(null, input);
          } else {
            done.apply(null, [null].concat(input));
          }
        }
      }
      function use(fn2) {
        if (typeof fn2 !== "function") {
          throw new Error("Expected `fn` to be a function, not " + fn2);
        }
        fns.push(fn2);
        return middleware;
      }
    }
  }
});

// node_modules/@udecode/plate-serializer-md/node_modules/unist-util-stringify-position/index.js
var require_unist_util_stringify_position2 = __commonJS({
  "node_modules/@udecode/plate-serializer-md/node_modules/unist-util-stringify-position/index.js"(exports2, module2) {
    "use strict";
    var own = {}.hasOwnProperty;
    module2.exports = stringify;
    function stringify(value) {
      if (!value || typeof value !== "object") {
        return "";
      }
      if (own.call(value, "position") || own.call(value, "type")) {
        return position3(value.position);
      }
      if (own.call(value, "start") || own.call(value, "end")) {
        return position3(value);
      }
      if (own.call(value, "line") || own.call(value, "column")) {
        return point(value);
      }
      return "";
    }
    function point(point2) {
      if (!point2 || typeof point2 !== "object") {
        point2 = {};
      }
      return index2(point2.line) + ":" + index2(point2.column);
    }
    function position3(pos) {
      if (!pos || typeof pos !== "object") {
        pos = {};
      }
      return point(pos.start) + "-" + point(pos.end);
    }
    function index2(value) {
      return value && typeof value === "number" ? value : 1;
    }
  }
});

// node_modules/@udecode/plate-serializer-md/node_modules/vfile-message/index.js
var require_vfile_message = __commonJS({
  "node_modules/@udecode/plate-serializer-md/node_modules/vfile-message/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_unist_util_stringify_position2();
    module2.exports = VMessage;
    function VMessagePrototype() {
    }
    VMessagePrototype.prototype = Error.prototype;
    VMessage.prototype = new VMessagePrototype();
    var proto2 = VMessage.prototype;
    proto2.file = "";
    proto2.name = "";
    proto2.reason = "";
    proto2.message = "";
    proto2.stack = "";
    proto2.fatal = null;
    proto2.column = null;
    proto2.line = null;
    function VMessage(reason, position3, origin2) {
      var parts;
      var range;
      var location;
      if (typeof position3 === "string") {
        origin2 = position3;
        position3 = null;
      }
      parts = parseOrigin(origin2);
      range = stringify(position3) || "1:1";
      location = {
        start: { line: null, column: null },
        end: { line: null, column: null }
      };
      if (position3 && position3.position) {
        position3 = position3.position;
      }
      if (position3) {
        if (position3.start) {
          location = position3;
          position3 = position3.start;
        } else {
          location.start = position3;
        }
      }
      if (reason.stack) {
        this.stack = reason.stack;
        reason = reason.message;
      }
      this.message = reason;
      this.name = range;
      this.reason = reason;
      this.line = position3 ? position3.line : null;
      this.column = position3 ? position3.column : null;
      this.location = location;
      this.source = parts[0];
      this.ruleId = parts[1];
    }
    function parseOrigin(origin2) {
      var result = [null, null];
      var index2;
      if (typeof origin2 === "string") {
        index2 = origin2.indexOf(":");
        if (index2 === -1) {
          result[1] = origin2;
        } else {
          result[0] = origin2.slice(0, index2);
          result[1] = origin2.slice(index2 + 1);
        }
      }
      return result;
    }
  }
});

// node_modules/@udecode/plate-serializer-md/node_modules/vfile/lib/minpath.browser.js
var require_minpath_browser = __commonJS({
  "node_modules/@udecode/plate-serializer-md/node_modules/vfile/lib/minpath.browser.js"(exports2) {
    "use strict";
    exports2.basename = basename;
    exports2.dirname = dirname2;
    exports2.extname = extname;
    exports2.join = join2;
    exports2.sep = "/";
    function basename(path, ext) {
      var start3 = 0;
      var end2 = -1;
      var index2;
      var firstNonSlashEnd;
      var seenNonSlash;
      var extIndex;
      if (ext !== void 0 && typeof ext !== "string") {
        throw new TypeError('"ext" argument must be a string');
      }
      assertPath(path);
      index2 = path.length;
      if (ext === void 0 || !ext.length || ext.length > path.length) {
        while (index2--) {
          if (path.charCodeAt(index2) === 47) {
            if (seenNonSlash) {
              start3 = index2 + 1;
              break;
            }
          } else if (end2 < 0) {
            seenNonSlash = true;
            end2 = index2 + 1;
          }
        }
        return end2 < 0 ? "" : path.slice(start3, end2);
      }
      if (ext === path) {
        return "";
      }
      firstNonSlashEnd = -1;
      extIndex = ext.length - 1;
      while (index2--) {
        if (path.charCodeAt(index2) === 47) {
          if (seenNonSlash) {
            start3 = index2 + 1;
            break;
          }
        } else {
          if (firstNonSlashEnd < 0) {
            seenNonSlash = true;
            firstNonSlashEnd = index2 + 1;
          }
          if (extIndex > -1) {
            if (path.charCodeAt(index2) === ext.charCodeAt(extIndex--)) {
              if (extIndex < 0) {
                end2 = index2;
              }
            } else {
              extIndex = -1;
              end2 = firstNonSlashEnd;
            }
          }
        }
      }
      if (start3 === end2) {
        end2 = firstNonSlashEnd;
      } else if (end2 < 0) {
        end2 = path.length;
      }
      return path.slice(start3, end2);
    }
    function dirname2(path) {
      var end2;
      var unmatchedSlash;
      var index2;
      assertPath(path);
      if (!path.length) {
        return ".";
      }
      end2 = -1;
      index2 = path.length;
      while (--index2) {
        if (path.charCodeAt(index2) === 47) {
          if (unmatchedSlash) {
            end2 = index2;
            break;
          }
        } else if (!unmatchedSlash) {
          unmatchedSlash = true;
        }
      }
      return end2 < 0 ? path.charCodeAt(0) === 47 ? "/" : "." : end2 === 1 && path.charCodeAt(0) === 47 ? "//" : path.slice(0, end2);
    }
    function extname(path) {
      var startDot = -1;
      var startPart = 0;
      var end2 = -1;
      var preDotState = 0;
      var unmatchedSlash;
      var code;
      var index2;
      assertPath(path);
      index2 = path.length;
      while (index2--) {
        code = path.charCodeAt(index2);
        if (code === 47) {
          if (unmatchedSlash) {
            startPart = index2 + 1;
            break;
          }
          continue;
        }
        if (end2 < 0) {
          unmatchedSlash = true;
          end2 = index2 + 1;
        }
        if (code === 46) {
          if (startDot < 0) {
            startDot = index2;
          } else if (preDotState !== 1) {
            preDotState = 1;
          }
        } else if (startDot > -1) {
          preDotState = -1;
        }
      }
      if (startDot < 0 || end2 < 0 || // We saw a non-dot character immediately before the dot.
      preDotState === 0 || // The (right-most) trimmed path component is exactly `..`.
      preDotState === 1 && startDot === end2 - 1 && startDot === startPart + 1) {
        return "";
      }
      return path.slice(startDot, end2);
    }
    function join2() {
      var index2 = -1;
      var joined;
      while (++index2 < arguments.length) {
        assertPath(arguments[index2]);
        if (arguments[index2]) {
          joined = joined === void 0 ? arguments[index2] : joined + "/" + arguments[index2];
        }
      }
      return joined === void 0 ? "." : normalize4(joined);
    }
    function normalize4(path) {
      var absolute;
      var value;
      assertPath(path);
      absolute = path.charCodeAt(0) === 47;
      value = normalizeString(path, !absolute);
      if (!value.length && !absolute) {
        value = ".";
      }
      if (value.length && path.charCodeAt(path.length - 1) === 47) {
        value += "/";
      }
      return absolute ? "/" + value : value;
    }
    function normalizeString(path, allowAboveRoot) {
      var result = "";
      var lastSegmentLength = 0;
      var lastSlash = -1;
      var dots = 0;
      var index2 = -1;
      var code;
      var lastSlashIndex;
      while (++index2 <= path.length) {
        if (index2 < path.length) {
          code = path.charCodeAt(index2);
        } else if (code === 47) {
          break;
        } else {
          code = 47;
        }
        if (code === 47) {
          if (lastSlash === index2 - 1 || dots === 1) {
          } else if (lastSlash !== index2 - 1 && dots === 2) {
            if (result.length < 2 || lastSegmentLength !== 2 || result.charCodeAt(result.length - 1) !== 46 || result.charCodeAt(result.length - 2) !== 46) {
              if (result.length > 2) {
                lastSlashIndex = result.lastIndexOf("/");
                if (lastSlashIndex !== result.length - 1) {
                  if (lastSlashIndex < 0) {
                    result = "";
                    lastSegmentLength = 0;
                  } else {
                    result = result.slice(0, lastSlashIndex);
                    lastSegmentLength = result.length - 1 - result.lastIndexOf("/");
                  }
                  lastSlash = index2;
                  dots = 0;
                  continue;
                }
              } else if (result.length) {
                result = "";
                lastSegmentLength = 0;
                lastSlash = index2;
                dots = 0;
                continue;
              }
            }
            if (allowAboveRoot) {
              result = result.length ? result + "/.." : "..";
              lastSegmentLength = 2;
            }
          } else {
            if (result.length) {
              result += "/" + path.slice(lastSlash + 1, index2);
            } else {
              result = path.slice(lastSlash + 1, index2);
            }
            lastSegmentLength = index2 - lastSlash - 1;
          }
          lastSlash = index2;
          dots = 0;
        } else if (code === 46 && dots > -1) {
          dots++;
        } else {
          dots = -1;
        }
      }
      return result;
    }
    function assertPath(path) {
      if (typeof path !== "string") {
        throw new TypeError(
          "Path must be a string. Received " + JSON.stringify(path)
        );
      }
    }
  }
});

// node_modules/@udecode/plate-serializer-md/node_modules/vfile/lib/minproc.browser.js
var require_minproc_browser = __commonJS({
  "node_modules/@udecode/plate-serializer-md/node_modules/vfile/lib/minproc.browser.js"(exports2) {
    "use strict";
    exports2.cwd = cwd;
    function cwd() {
      return "/";
    }
  }
});

// node_modules/@udecode/plate-serializer-md/node_modules/vfile/lib/core.js
var require_core = __commonJS({
  "node_modules/@udecode/plate-serializer-md/node_modules/vfile/lib/core.js"(exports2, module2) {
    "use strict";
    var p12 = require_minpath_browser();
    var proc = require_minproc_browser();
    var buffer = require_is_buffer();
    module2.exports = VFile;
    var own = {}.hasOwnProperty;
    var order = ["history", "path", "basename", "stem", "extname", "dirname"];
    VFile.prototype.toString = toString7;
    Object.defineProperty(VFile.prototype, "path", { get: getPath2, set: setPath });
    Object.defineProperty(VFile.prototype, "dirname", {
      get: getDirname,
      set: setDirname
    });
    Object.defineProperty(VFile.prototype, "basename", {
      get: getBasename,
      set: setBasename
    });
    Object.defineProperty(VFile.prototype, "extname", {
      get: getExtname,
      set: setExtname
    });
    Object.defineProperty(VFile.prototype, "stem", { get: getStem, set: setStem });
    function VFile(options) {
      var prop;
      var index2;
      if (!options) {
        options = {};
      } else if (typeof options === "string" || buffer(options)) {
        options = { contents: options };
      } else if ("message" in options && "messages" in options) {
        return options;
      }
      if (!(this instanceof VFile)) {
        return new VFile(options);
      }
      this.data = {};
      this.messages = [];
      this.history = [];
      this.cwd = proc.cwd();
      index2 = -1;
      while (++index2 < order.length) {
        prop = order[index2];
        if (own.call(options, prop)) {
          this[prop] = options[prop];
        }
      }
      for (prop in options) {
        if (order.indexOf(prop) < 0) {
          this[prop] = options[prop];
        }
      }
    }
    function getPath2() {
      return this.history[this.history.length - 1];
    }
    function setPath(path) {
      assertNonEmpty(path, "path");
      if (this.path !== path) {
        this.history.push(path);
      }
    }
    function getDirname() {
      return typeof this.path === "string" ? p12.dirname(this.path) : void 0;
    }
    function setDirname(dirname2) {
      assertPath(this.path, "dirname");
      this.path = p12.join(dirname2 || "", this.basename);
    }
    function getBasename() {
      return typeof this.path === "string" ? p12.basename(this.path) : void 0;
    }
    function setBasename(basename) {
      assertNonEmpty(basename, "basename");
      assertPart(basename, "basename");
      this.path = p12.join(this.dirname || "", basename);
    }
    function getExtname() {
      return typeof this.path === "string" ? p12.extname(this.path) : void 0;
    }
    function setExtname(extname) {
      assertPart(extname, "extname");
      assertPath(this.path, "extname");
      if (extname) {
        if (extname.charCodeAt(0) !== 46) {
          throw new Error("`extname` must start with `.`");
        }
        if (extname.indexOf(".", 1) > -1) {
          throw new Error("`extname` cannot contain multiple dots");
        }
      }
      this.path = p12.join(this.dirname, this.stem + (extname || ""));
    }
    function getStem() {
      return typeof this.path === "string" ? p12.basename(this.path, this.extname) : void 0;
    }
    function setStem(stem) {
      assertNonEmpty(stem, "stem");
      assertPart(stem, "stem");
      this.path = p12.join(this.dirname || "", stem + (this.extname || ""));
    }
    function toString7(encoding) {
      return (this.contents || "").toString(encoding);
    }
    function assertPart(part, name2) {
      if (part && part.indexOf(p12.sep) > -1) {
        throw new Error(
          "`" + name2 + "` cannot be a path: did not expect `" + p12.sep + "`"
        );
      }
    }
    function assertNonEmpty(part, name2) {
      if (!part) {
        throw new Error("`" + name2 + "` cannot be empty");
      }
    }
    function assertPath(path, name2) {
      if (!path) {
        throw new Error("Setting `" + name2 + "` requires `path` to be set too");
      }
    }
  }
});

// node_modules/@udecode/plate-serializer-md/node_modules/vfile/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/@udecode/plate-serializer-md/node_modules/vfile/lib/index.js"(exports2, module2) {
    "use strict";
    var VMessage = require_vfile_message();
    var VFile = require_core();
    module2.exports = VFile;
    VFile.prototype.message = message;
    VFile.prototype.info = info;
    VFile.prototype.fail = fail;
    function message(reason, position3, origin2) {
      var message2 = new VMessage(reason, position3, origin2);
      if (this.path) {
        message2.name = this.path + ":" + message2.name;
        message2.file = this.path;
      }
      message2.fatal = false;
      this.messages.push(message2);
      return message2;
    }
    function fail() {
      var message2 = this.message.apply(this, arguments);
      message2.fatal = true;
      throw message2;
    }
    function info() {
      var message2 = this.message.apply(this, arguments);
      message2.fatal = null;
      return message2;
    }
  }
});

// node_modules/@udecode/plate-serializer-md/node_modules/vfile/index.js
var require_vfile = __commonJS({
  "node_modules/@udecode/plate-serializer-md/node_modules/vfile/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_lib3();
  }
});

// node_modules/@udecode/plate-serializer-md/node_modules/unified/index.js
var require_unified = __commonJS({
  "node_modules/@udecode/plate-serializer-md/node_modules/unified/index.js"(exports2, module2) {
    "use strict";
    var bail = require_bail();
    var buffer = require_is_buffer();
    var extend2 = require_extend();
    var plain = require_is_plain_obj();
    var trough = require_trough();
    var vfile = require_vfile();
    module2.exports = unified2().freeze();
    var slice = [].slice;
    var own = {}.hasOwnProperty;
    var pipeline = trough().use(pipelineParse).use(pipelineRun).use(pipelineStringify);
    function pipelineParse(p12, ctx) {
      ctx.tree = p12.parse(ctx.file);
    }
    function pipelineRun(p12, ctx, next) {
      p12.run(ctx.tree, ctx.file, done);
      function done(error2, tree, file) {
        if (error2) {
          next(error2);
        } else {
          ctx.tree = tree;
          ctx.file = file;
          next();
        }
      }
    }
    function pipelineStringify(p12, ctx) {
      var result = p12.stringify(ctx.tree, ctx.file);
      if (result === void 0 || result === null) {
      } else if (typeof result === "string" || buffer(result)) {
        if ("value" in ctx.file) {
          ctx.file.value = result;
        }
        ctx.file.contents = result;
      } else {
        ctx.file.result = result;
      }
    }
    function unified2() {
      var attachers = [];
      var transformers = trough();
      var namespace = {};
      var freezeIndex = -1;
      var frozen;
      processor.data = data;
      processor.freeze = freeze;
      processor.attachers = attachers;
      processor.use = use;
      processor.parse = parse6;
      processor.stringify = stringify;
      processor.run = run;
      processor.runSync = runSync;
      processor.process = process2;
      processor.processSync = processSync;
      return processor;
      function processor() {
        var destination = unified2();
        var index2 = -1;
        while (++index2 < attachers.length) {
          destination.use.apply(null, attachers[index2]);
        }
        destination.data(extend2(true, {}, namespace));
        return destination;
      }
      function freeze() {
        var values3;
        var transformer;
        if (frozen) {
          return processor;
        }
        while (++freezeIndex < attachers.length) {
          values3 = attachers[freezeIndex];
          if (values3[1] === false) {
            continue;
          }
          if (values3[1] === true) {
            values3[1] = void 0;
          }
          transformer = values3[0].apply(processor, values3.slice(1));
          if (typeof transformer === "function") {
            transformers.use(transformer);
          }
        }
        frozen = true;
        freezeIndex = Infinity;
        return processor;
      }
      function data(key, value) {
        if (typeof key === "string") {
          if (arguments.length === 2) {
            assertUnfrozen("data", frozen);
            namespace[key] = value;
            return processor;
          }
          return own.call(namespace, key) && namespace[key] || null;
        }
        if (key) {
          assertUnfrozen("data", frozen);
          namespace = key;
          return processor;
        }
        return namespace;
      }
      function use(value) {
        var settings;
        assertUnfrozen("use", frozen);
        if (value === null || value === void 0) {
        } else if (typeof value === "function") {
          addPlugin.apply(null, arguments);
        } else if (typeof value === "object") {
          if ("length" in value) {
            addList(value);
          } else {
            addPreset(value);
          }
        } else {
          throw new Error("Expected usable value, not `" + value + "`");
        }
        if (settings) {
          namespace.settings = extend2(namespace.settings || {}, settings);
        }
        return processor;
        function addPreset(result) {
          addList(result.plugins);
          if (result.settings) {
            settings = extend2(settings || {}, result.settings);
          }
        }
        function add4(value2) {
          if (typeof value2 === "function") {
            addPlugin(value2);
          } else if (typeof value2 === "object") {
            if ("length" in value2) {
              addPlugin.apply(null, value2);
            } else {
              addPreset(value2);
            }
          } else {
            throw new Error("Expected usable value, not `" + value2 + "`");
          }
        }
        function addList(plugins2) {
          var index2 = -1;
          if (plugins2 === null || plugins2 === void 0) {
          } else if (typeof plugins2 === "object" && "length" in plugins2) {
            while (++index2 < plugins2.length) {
              add4(plugins2[index2]);
            }
          } else {
            throw new Error("Expected a list of plugins, not `" + plugins2 + "`");
          }
        }
        function addPlugin(plugin, value2) {
          var entry = find2(plugin);
          if (entry) {
            if (plain(entry[1]) && plain(value2)) {
              value2 = extend2(true, entry[1], value2);
            }
            entry[1] = value2;
          } else {
            attachers.push(slice.call(arguments));
          }
        }
      }
      function find2(plugin) {
        var index2 = -1;
        while (++index2 < attachers.length) {
          if (attachers[index2][0] === plugin) {
            return attachers[index2];
          }
        }
      }
      function parse6(doc) {
        var file = vfile(doc);
        var Parser2;
        freeze();
        Parser2 = processor.Parser;
        assertParser("parse", Parser2);
        if (newable(Parser2, "parse")) {
          return new Parser2(String(file), file).parse();
        }
        return Parser2(String(file), file);
      }
      function run(node, file, cb) {
        assertNode(node);
        freeze();
        if (!cb && typeof file === "function") {
          cb = file;
          file = null;
        }
        if (!cb) {
          return new Promise(executor);
        }
        executor(null, cb);
        function executor(resolve, reject) {
          transformers.run(node, vfile(file), done);
          function done(error2, tree, file2) {
            tree = tree || node;
            if (error2) {
              reject(error2);
            } else if (resolve) {
              resolve(tree);
            } else {
              cb(null, tree, file2);
            }
          }
        }
      }
      function runSync(node, file) {
        var result;
        var complete;
        run(node, file, done);
        assertDone("runSync", "run", complete);
        return result;
        function done(error2, tree) {
          complete = true;
          result = tree;
          bail(error2);
        }
      }
      function stringify(node, doc) {
        var file = vfile(doc);
        var Compiler;
        freeze();
        Compiler = processor.Compiler;
        assertCompiler("stringify", Compiler);
        assertNode(node);
        if (newable(Compiler, "compile")) {
          return new Compiler(node, file).compile();
        }
        return Compiler(node, file);
      }
      function process2(doc, cb) {
        freeze();
        assertParser("process", processor.Parser);
        assertCompiler("process", processor.Compiler);
        if (!cb) {
          return new Promise(executor);
        }
        executor(null, cb);
        function executor(resolve, reject) {
          var file = vfile(doc);
          pipeline.run(processor, { file }, done);
          function done(error2) {
            if (error2) {
              reject(error2);
            } else if (resolve) {
              resolve(file);
            } else {
              cb(null, file);
            }
          }
        }
      }
      function processSync(doc) {
        var file;
        var complete;
        freeze();
        assertParser("processSync", processor.Parser);
        assertCompiler("processSync", processor.Compiler);
        file = vfile(doc);
        process2(file, done);
        assertDone("processSync", "process", complete);
        return file;
        function done(error2) {
          complete = true;
          bail(error2);
        }
      }
    }
    function newable(value, name2) {
      return typeof value === "function" && value.prototype && // A function with keys in its prototype is probably a constructor.
      // Classes’ prototype methods are not enumerable, so we check if some value
      // exists in the prototype.
      (keys6(value.prototype) || name2 in value.prototype);
    }
    function keys6(value) {
      var key;
      for (key in value) {
        return true;
      }
      return false;
    }
    function assertParser(name2, Parser2) {
      if (typeof Parser2 !== "function") {
        throw new Error("Cannot `" + name2 + "` without `Parser`");
      }
    }
    function assertCompiler(name2, Compiler) {
      if (typeof Compiler !== "function") {
        throw new Error("Cannot `" + name2 + "` without `Compiler`");
      }
    }
    function assertUnfrozen(name2, frozen) {
      if (frozen) {
        throw new Error(
          "Cannot invoke `" + name2 + "` on a frozen processor.\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`."
        );
      }
    }
    function assertNode(node) {
      if (!node || typeof node.type !== "string") {
        throw new Error("Expected node, got `" + node + "`");
      }
    }
    function assertDone(name2, asyncName, complete) {
      if (!complete) {
        throw new Error(
          "`" + name2 + "` finished async. Use `" + asyncName + "` instead"
        );
      }
    }
  }
});

// node_modules/@tinacms/toolkit/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development2 = __commonJS({
  "node_modules/@tinacms/toolkit/node_modules/react-is/cjs/react-is.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType2(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object2) {
          if (typeof object2 === "object" && object2 !== null) {
            var $$typeof = object2.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object2.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element4 = REACT_ELEMENT_TYPE;
        var ForwardRef2 = REACT_FORWARD_REF_TYPE;
        var Fragment8 = REACT_FRAGMENT_TYPE;
        var Lazy2 = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object2) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object2) || typeOf(object2) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object2) {
          return typeOf(object2) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer2(object2) {
          return typeOf(object2) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object2) {
          return typeOf(object2) === REACT_PROVIDER_TYPE;
        }
        function isElement5(object2) {
          return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef2(object2) {
          return typeOf(object2) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object2) {
          return typeOf(object2) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object2) {
          return typeOf(object2) === REACT_LAZY_TYPE;
        }
        function isMemo(object2) {
          return typeOf(object2) === REACT_MEMO_TYPE;
        }
        function isPortal(object2) {
          return typeOf(object2) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object2) {
          return typeOf(object2) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object2) {
          return typeOf(object2) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object2) {
          return typeOf(object2) === REACT_SUSPENSE_TYPE;
        }
        exports2.AsyncMode = AsyncMode;
        exports2.ConcurrentMode = ConcurrentMode;
        exports2.ContextConsumer = ContextConsumer;
        exports2.ContextProvider = ContextProvider;
        exports2.Element = Element4;
        exports2.ForwardRef = ForwardRef2;
        exports2.Fragment = Fragment8;
        exports2.Lazy = Lazy2;
        exports2.Memo = Memo;
        exports2.Portal = Portal;
        exports2.Profiler = Profiler;
        exports2.StrictMode = StrictMode;
        exports2.Suspense = Suspense;
        exports2.isAsyncMode = isAsyncMode;
        exports2.isConcurrentMode = isConcurrentMode;
        exports2.isContextConsumer = isContextConsumer2;
        exports2.isContextProvider = isContextProvider;
        exports2.isElement = isElement5;
        exports2.isForwardRef = isForwardRef2;
        exports2.isFragment = isFragment;
        exports2.isLazy = isLazy;
        exports2.isMemo = isMemo;
        exports2.isPortal = isPortal;
        exports2.isProfiler = isProfiler;
        exports2.isStrictMode = isStrictMode;
        exports2.isSuspense = isSuspense;
        exports2.isValidElementType = isValidElementType2;
        exports2.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/@tinacms/toolkit/node_modules/react-is/index.js
var require_react_is2 = __commonJS({
  "node_modules/@tinacms/toolkit/node_modules/react-is/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_is_development2();
    }
  }
});

// node_modules/@tinacms/toolkit/node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/@tinacms/toolkit/node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports2, module2) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module2.exports = ReactPropTypesSecret;
  }
});

// node_modules/@tinacms/toolkit/node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/@tinacms/toolkit/node_modules/prop-types/checkPropTypes.js"(exports2, module2) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has4 = Function.call.bind(Object.prototype.hasOwnProperty);
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x7) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has4;
    function checkPropTypes(typeSpecs, values3, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has4(typeSpecs, typeSpecName)) {
            var error2;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`."
                );
                err.name = "Invariant Violation";
                throw err;
              }
              error2 = typeSpecs[typeSpecName](values3, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error2 = ex;
            }
            if (error2 && !(error2 instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error2 + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error2 instanceof Error && !(error2.message in loggedTypeFailures)) {
              loggedTypeFailures[error2.message] = true;
              var stack = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error2.message + (stack != null ? stack : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module2.exports = checkPropTypes;
  }
});

// node_modules/@tinacms/toolkit/node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/@tinacms/toolkit/node_modules/prop-types/factoryWithTypeCheckers.js"(exports2, module2) {
    "use strict";
    var ReactIs = require_react_is2();
    var assign = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var checkPropTypes = require_checkPropTypes();
    var has4 = Function.call.bind(Object.prototype.hasOwnProperty);
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x7) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module2.exports = function(isValidElement4, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is3(x7, y9) {
        if (x7 === y9) {
          return x7 !== 0 || 1 / x7 === 1 / y9;
        } else {
          return x7 !== x7 && y9 !== y9;
        }
      }
      function PropTypeError(message) {
        this.message = message;
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate3) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err.name = "Invariant Violation";
              throw err;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate3(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate3(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate3(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i15 = 0; i15 < propValue.length; i15++) {
            var error2 = typeChecker(propValue, i15, componentName, location, propFullName + "[" + i15 + "]", ReactPropTypesSecret);
            if (error2 instanceof Error) {
              return error2;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createElementTypeChecker() {
        function validate3(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement4(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createElementTypeTypeChecker() {
        function validate3(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate3(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate3(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i15 = 0; i15 < expectedValues.length; i15++) {
            if (is3(propValue, expectedValues[i15])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate3);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate3(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has4(propValue, key)) {
              var error2 = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error2 instanceof Error) {
                return error2;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i15 = 0; i15 < arrayOfTypeCheckers.length; i15++) {
          var checker = arrayOfTypeCheckers[i15];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i15 + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate3(props, propName, componentName, location, propFullName) {
          for (var i16 = 0; i16 < arrayOfTypeCheckers.length; i16++) {
            var checker2 = arrayOfTypeCheckers[i16];
            if (checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
              return null;
            }
          }
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`."));
        }
        return createChainableTypeChecker(validate3);
      }
      function createNodeChecker() {
        function validate3(props, propName, componentName, location, propFullName) {
          if (!isNode2(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate3(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (!checker) {
              continue;
            }
            var error2 = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error2) {
              return error2;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate3(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error2 = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error2) {
              return error2;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate3);
      }
      function isNode2(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode2);
            }
            if (propValue === null || isValidElement4(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode2(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode2(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol3(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol3(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/@tinacms/toolkit/node_modules/prop-types/index.js
var require_prop_types2 = __commonJS({
  "node_modules/@tinacms/toolkit/node_modules/prop-types/index.js"(exports2, module2) {
    if (true) {
      ReactIs = require_react_is2();
      throwOnDirectAccess = true;
      module2.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module2.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development3 = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js"(exports2) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType2(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object2) {
          if (typeof object2 === "object" && object2 !== null) {
            var $$typeof = object2.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object2.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element4 = REACT_ELEMENT_TYPE;
        var ForwardRef2 = REACT_FORWARD_REF_TYPE;
        var Fragment8 = REACT_FRAGMENT_TYPE;
        var Lazy2 = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object2) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object2) || typeOf(object2) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object2) {
          return typeOf(object2) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer2(object2) {
          return typeOf(object2) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object2) {
          return typeOf(object2) === REACT_PROVIDER_TYPE;
        }
        function isElement5(object2) {
          return typeof object2 === "object" && object2 !== null && object2.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef2(object2) {
          return typeOf(object2) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object2) {
          return typeOf(object2) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object2) {
          return typeOf(object2) === REACT_LAZY_TYPE;
        }
        function isMemo(object2) {
          return typeOf(object2) === REACT_MEMO_TYPE;
        }
        function isPortal(object2) {
          return typeOf(object2) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object2) {
          return typeOf(object2) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object2) {
          return typeOf(object2) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object2) {
          return typeOf(object2) === REACT_SUSPENSE_TYPE;
        }
        exports2.AsyncMode = AsyncMode;
        exports2.ConcurrentMode = ConcurrentMode;
        exports2.ContextConsumer = ContextConsumer;
        exports2.ContextProvider = ContextProvider;
        exports2.Element = Element4;
        exports2.ForwardRef = ForwardRef2;
        exports2.Fragment = Fragment8;
        exports2.Lazy = Lazy2;
        exports2.Memo = Memo;
        exports2.Portal = Portal;
        exports2.Profiler = Profiler;
        exports2.StrictMode = StrictMode;
        exports2.Suspense = Suspense;
        exports2.isAsyncMode = isAsyncMode;
        exports2.isConcurrentMode = isConcurrentMode;
        exports2.isContextConsumer = isContextConsumer2;
        exports2.isContextProvider = isContextProvider;
        exports2.isElement = isElement5;
        exports2.isForwardRef = isForwardRef2;
        exports2.isFragment = isFragment;
        exports2.isLazy = isLazy;
        exports2.isMemo = isMemo;
        exports2.isPortal = isPortal;
        exports2.isProfiler = isProfiler;
        exports2.isStrictMode = isStrictMode;
        exports2.isSuspense = isSuspense;
        exports2.isValidElementType = isValidElementType2;
        exports2.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/hoist-non-react-statics/node_modules/react-is/index.js
var require_react_is3 = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(exports2, module2) {
    "use strict";
    if (false) {
      module2.exports = null;
    } else {
      module2.exports = require_react_is_development3();
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports2, module2) {
    "use strict";
    var reactIs = require_react_is3();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty6 = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys6 = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys6 = keys6.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i15 = 0; i15 < keys6.length; ++i15) {
          var key = keys6[i15];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty6(targetComponent, key, descriptor);
            } catch (e9) {
            }
          }
        }
      }
      return targetComponent;
    }
    module2.exports = hoistNonReactStatics;
  }
});

// node_modules/is-hotkey/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/is-hotkey/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var IS_MAC = typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
    var MODIFIERS = {
      alt: "altKey",
      control: "ctrlKey",
      meta: "metaKey",
      shift: "shiftKey"
    };
    var ALIASES = {
      add: "+",
      break: "pause",
      cmd: "meta",
      command: "meta",
      ctl: "control",
      ctrl: "control",
      del: "delete",
      down: "arrowdown",
      esc: "escape",
      ins: "insert",
      left: "arrowleft",
      mod: IS_MAC ? "meta" : "control",
      opt: "alt",
      option: "alt",
      return: "enter",
      right: "arrowright",
      space: " ",
      spacebar: " ",
      up: "arrowup",
      win: "meta",
      windows: "meta"
    };
    var CODES = {
      backspace: 8,
      tab: 9,
      enter: 13,
      shift: 16,
      control: 17,
      alt: 18,
      pause: 19,
      capslock: 20,
      escape: 27,
      " ": 32,
      pageup: 33,
      pagedown: 34,
      end: 35,
      home: 36,
      arrowleft: 37,
      arrowup: 38,
      arrowright: 39,
      arrowdown: 40,
      insert: 45,
      delete: 46,
      meta: 91,
      numlock: 144,
      scrolllock: 145,
      ";": 186,
      "=": 187,
      ",": 188,
      "-": 189,
      ".": 190,
      "/": 191,
      "`": 192,
      "[": 219,
      "\\": 220,
      "]": 221,
      "'": 222
    };
    for (f16 = 1; f16 < 20; f16++) {
      CODES["f" + f16] = 111 + f16;
    }
    var f16;
    function isHotkey14(hotkey, options, event) {
      if (options && !("byKey" in options)) {
        event = options;
        options = null;
      }
      if (!Array.isArray(hotkey)) {
        hotkey = [hotkey];
      }
      var array2 = hotkey.map(function(string2) {
        return parseHotkey(string2, options);
      });
      var check = function check2(e9) {
        return array2.some(function(object2) {
          return compareHotkey(object2, e9);
        });
      };
      var ret = event == null ? check : check(event);
      return ret;
    }
    function isCodeHotkey(hotkey, event) {
      return isHotkey14(hotkey, event);
    }
    function isKeyHotkey2(hotkey, event) {
      return isHotkey14(hotkey, { byKey: true }, event);
    }
    function parseHotkey(hotkey, options) {
      var byKey = options && options.byKey;
      var ret = {};
      hotkey = hotkey.replace("++", "+add");
      var values3 = hotkey.split("+");
      var length = values3.length;
      for (var k3 in MODIFIERS) {
        ret[MODIFIERS[k3]] = false;
      }
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = void 0;
      try {
        for (var _iterator = values3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var value = _step.value;
          var optional = value.endsWith("?") && value.length > 1;
          if (optional) {
            value = value.slice(0, -1);
          }
          var name2 = toKeyName(value);
          var modifier = MODIFIERS[name2];
          if (value.length > 1 && !modifier && !ALIASES[value] && !CODES[name2]) {
            throw new TypeError('Unknown modifier: "' + value + '"');
          }
          if (length === 1 || !modifier) {
            if (byKey) {
              ret.key = name2;
            } else {
              ret.which = toKeyCode(value);
            }
          }
          if (modifier) {
            ret[modifier] = optional ? null : true;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }
      return ret;
    }
    function compareHotkey(object2, event) {
      for (var key in object2) {
        var expected = object2[key];
        var actual = void 0;
        if (expected == null) {
          continue;
        }
        if (key === "key" && event.key != null) {
          actual = event.key.toLowerCase();
        } else if (key === "which") {
          actual = expected === 91 && event.which === 93 ? 91 : event.which;
        } else {
          actual = event[key];
        }
        if (actual == null && expected === false) {
          continue;
        }
        if (actual !== expected) {
          return false;
        }
      }
      return true;
    }
    function toKeyCode(name2) {
      name2 = toKeyName(name2);
      var code = CODES[name2] || name2.toUpperCase().charCodeAt(0);
      return code;
    }
    function toKeyName(name2) {
      name2 = name2.toLowerCase();
      name2 = ALIASES[name2] || name2;
      return name2;
    }
    exports2.default = isHotkey14;
    exports2.isHotkey = isHotkey14;
    exports2.isCodeHotkey = isCodeHotkey;
    exports2.isKeyHotkey = isKeyHotkey2;
    exports2.parseHotkey = parseHotkey;
    exports2.compareHotkey = compareHotkey;
    exports2.toKeyCode = toKeyCode;
    exports2.toKeyName = toKeyName;
  }
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS({
  "node_modules/lodash/isArray.js"(exports2, module2) {
    var isArray10 = Array.isArray;
    module2.exports = isArray10;
  }
});

// node_modules/lodash/isString.js
var require_isString = __commonJS({
  "node_modules/lodash/isString.js"(exports2, module2) {
    var baseGetTag6 = require_baseGetTag();
    var isArray10 = require_isArray();
    var isObjectLike6 = require_isObjectLike();
    var stringTag6 = "[object String]";
    function isString2(value) {
      return typeof value == "string" || !isArray10(value) && isObjectLike6(value) && baseGetTag6(value) == stringTag6;
    }
    module2.exports = isString2;
  }
});

// node_modules/lodash/_createBaseFor.js
var require_createBaseFor = __commonJS({
  "node_modules/lodash/_createBaseFor.js"(exports2, module2) {
    function createBaseFor4(fromRight) {
      return function(object2, iteratee, keysFunc) {
        var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
        while (length--) {
          var key = props[fromRight ? length : ++index2];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object2;
      };
    }
    module2.exports = createBaseFor4;
  }
});

// node_modules/lodash/_baseFor.js
var require_baseFor = __commonJS({
  "node_modules/lodash/_baseFor.js"(exports2, module2) {
    var createBaseFor4 = require_createBaseFor();
    var baseFor4 = createBaseFor4();
    module2.exports = baseFor4;
  }
});

// node_modules/lodash/_baseTimes.js
var require_baseTimes = __commonJS({
  "node_modules/lodash/_baseTimes.js"(exports2, module2) {
    function baseTimes5(n12, iteratee) {
      var index2 = -1, result = Array(n12);
      while (++index2 < n12) {
        result[index2] = iteratee(index2);
      }
      return result;
    }
    module2.exports = baseTimes5;
  }
});

// node_modules/lodash/_baseIsArguments.js
var require_baseIsArguments = __commonJS({
  "node_modules/lodash/_baseIsArguments.js"(exports2, module2) {
    var baseGetTag6 = require_baseGetTag();
    var isObjectLike6 = require_isObjectLike();
    var argsTag7 = "[object Arguments]";
    function baseIsArguments6(value) {
      return isObjectLike6(value) && baseGetTag6(value) == argsTag7;
    }
    module2.exports = baseIsArguments6;
  }
});

// node_modules/lodash/isArguments.js
var require_isArguments = __commonJS({
  "node_modules/lodash/isArguments.js"(exports2, module2) {
    var baseIsArguments6 = require_baseIsArguments();
    var isObjectLike6 = require_isObjectLike();
    var objectProto20 = Object.prototype;
    var hasOwnProperty17 = objectProto20.hasOwnProperty;
    var propertyIsEnumerable7 = objectProto20.propertyIsEnumerable;
    var isArguments6 = baseIsArguments6(function() {
      return arguments;
    }()) ? baseIsArguments6 : function(value) {
      return isObjectLike6(value) && hasOwnProperty17.call(value, "callee") && !propertyIsEnumerable7.call(value, "callee");
    };
    module2.exports = isArguments6;
  }
});

// node_modules/lodash/stubFalse.js
var require_stubFalse = __commonJS({
  "node_modules/lodash/stubFalse.js"(exports2, module2) {
    function stubFalse6() {
      return false;
    }
    module2.exports = stubFalse6;
  }
});

// node_modules/lodash/isBuffer.js
var require_isBuffer = __commonJS({
  "node_modules/lodash/isBuffer.js"(exports2, module2) {
    var root6 = require_root();
    var stubFalse6 = require_stubFalse();
    var freeExports4 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule4 = freeExports4 && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
    var Buffer3 = moduleExports4 ? root6.Buffer : void 0;
    var nativeIsBuffer2 = Buffer3 ? Buffer3.isBuffer : void 0;
    var isBuffer2 = nativeIsBuffer2 || stubFalse6;
    module2.exports = isBuffer2;
  }
});

// node_modules/lodash/_isIndex.js
var require_isIndex = __commonJS({
  "node_modules/lodash/_isIndex.js"(exports2, module2) {
    var MAX_SAFE_INTEGER7 = 9007199254740991;
    var reIsUint5 = /^(?:0|[1-9]\d*)$/;
    function isIndex5(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER7 : length;
      return !!length && (type == "number" || type != "symbol" && reIsUint5.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    module2.exports = isIndex5;
  }
});

// node_modules/lodash/isLength.js
var require_isLength = __commonJS({
  "node_modules/lodash/isLength.js"(exports2, module2) {
    var MAX_SAFE_INTEGER7 = 9007199254740991;
    function isLength6(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER7;
    }
    module2.exports = isLength6;
  }
});

// node_modules/lodash/_baseIsTypedArray.js
var require_baseIsTypedArray = __commonJS({
  "node_modules/lodash/_baseIsTypedArray.js"(exports2, module2) {
    var baseGetTag6 = require_baseGetTag();
    var isLength6 = require_isLength();
    var isObjectLike6 = require_isObjectLike();
    var argsTag7 = "[object Arguments]";
    var arrayTag6 = "[object Array]";
    var boolTag6 = "[object Boolean]";
    var dateTag6 = "[object Date]";
    var errorTag6 = "[object Error]";
    var funcTag7 = "[object Function]";
    var mapTag8 = "[object Map]";
    var numberTag6 = "[object Number]";
    var objectTag8 = "[object Object]";
    var regexpTag6 = "[object RegExp]";
    var setTag8 = "[object Set]";
    var stringTag6 = "[object String]";
    var weakMapTag7 = "[object WeakMap]";
    var arrayBufferTag6 = "[object ArrayBuffer]";
    var dataViewTag8 = "[object DataView]";
    var float32Tag6 = "[object Float32Array]";
    var float64Tag6 = "[object Float64Array]";
    var int8Tag6 = "[object Int8Array]";
    var int16Tag6 = "[object Int16Array]";
    var int32Tag6 = "[object Int32Array]";
    var uint8Tag6 = "[object Uint8Array]";
    var uint8ClampedTag6 = "[object Uint8ClampedArray]";
    var uint16Tag6 = "[object Uint16Array]";
    var uint32Tag6 = "[object Uint32Array]";
    var typedArrayTags6 = {};
    typedArrayTags6[float32Tag6] = typedArrayTags6[float64Tag6] = typedArrayTags6[int8Tag6] = typedArrayTags6[int16Tag6] = typedArrayTags6[int32Tag6] = typedArrayTags6[uint8Tag6] = typedArrayTags6[uint8ClampedTag6] = typedArrayTags6[uint16Tag6] = typedArrayTags6[uint32Tag6] = true;
    typedArrayTags6[argsTag7] = typedArrayTags6[arrayTag6] = typedArrayTags6[arrayBufferTag6] = typedArrayTags6[boolTag6] = typedArrayTags6[dataViewTag8] = typedArrayTags6[dateTag6] = typedArrayTags6[errorTag6] = typedArrayTags6[funcTag7] = typedArrayTags6[mapTag8] = typedArrayTags6[numberTag6] = typedArrayTags6[objectTag8] = typedArrayTags6[regexpTag6] = typedArrayTags6[setTag8] = typedArrayTags6[stringTag6] = typedArrayTags6[weakMapTag7] = false;
    function baseIsTypedArray6(value) {
      return isObjectLike6(value) && isLength6(value.length) && !!typedArrayTags6[baseGetTag6(value)];
    }
    module2.exports = baseIsTypedArray6;
  }
});

// node_modules/lodash/_baseUnary.js
var require_baseUnary = __commonJS({
  "node_modules/lodash/_baseUnary.js"(exports2, module2) {
    function baseUnary6(func) {
      return function(value) {
        return func(value);
      };
    }
    module2.exports = baseUnary6;
  }
});

// node_modules/lodash/_nodeUtil.js
var require_nodeUtil = __commonJS({
  "node_modules/lodash/_nodeUtil.js"(exports2, module2) {
    var freeGlobal6 = require_freeGlobal();
    var freeExports4 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule4 = freeExports4 && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
    var freeProcess2 = moduleExports4 && freeGlobal6.process;
    var nodeUtil2 = function() {
      try {
        var types = freeModule4 && freeModule4.require && freeModule4.require("util").types;
        if (types) {
          return types;
        }
        return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
      } catch (e9) {
      }
    }();
    module2.exports = nodeUtil2;
  }
});

// node_modules/lodash/isTypedArray.js
var require_isTypedArray = __commonJS({
  "node_modules/lodash/isTypedArray.js"(exports2, module2) {
    var baseIsTypedArray6 = require_baseIsTypedArray();
    var baseUnary6 = require_baseUnary();
    var nodeUtil2 = require_nodeUtil();
    var nodeIsTypedArray6 = nodeUtil2 && nodeUtil2.isTypedArray;
    var isTypedArray6 = nodeIsTypedArray6 ? baseUnary6(nodeIsTypedArray6) : baseIsTypedArray6;
    module2.exports = isTypedArray6;
  }
});

// node_modules/lodash/_arrayLikeKeys.js
var require_arrayLikeKeys = __commonJS({
  "node_modules/lodash/_arrayLikeKeys.js"(exports2, module2) {
    var baseTimes5 = require_baseTimes();
    var isArguments6 = require_isArguments();
    var isArray10 = require_isArray();
    var isBuffer2 = require_isBuffer();
    var isIndex5 = require_isIndex();
    var isTypedArray6 = require_isTypedArray();
    var objectProto20 = Object.prototype;
    var hasOwnProperty17 = objectProto20.hasOwnProperty;
    function arrayLikeKeys5(value, inherited) {
      var isArr = isArray10(value), isArg = !isArr && isArguments6(value), isBuff = !isArr && !isArg && isBuffer2(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray6(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes5(value.length, String) : [], length = result.length;
      for (var key in value) {
        if ((inherited || hasOwnProperty17.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
        (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
        isIndex5(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = arrayLikeKeys5;
  }
});

// node_modules/lodash/_isPrototype.js
var require_isPrototype = __commonJS({
  "node_modules/lodash/_isPrototype.js"(exports2, module2) {
    var objectProto20 = Object.prototype;
    function isPrototype5(value) {
      var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto20;
      return value === proto2;
    }
    module2.exports = isPrototype5;
  }
});

// node_modules/lodash/_overArg.js
var require_overArg = __commonJS({
  "node_modules/lodash/_overArg.js"(exports2, module2) {
    function overArg6(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    module2.exports = overArg6;
  }
});

// node_modules/lodash/_nativeKeys.js
var require_nativeKeys = __commonJS({
  "node_modules/lodash/_nativeKeys.js"(exports2, module2) {
    var overArg6 = require_overArg();
    var nativeKeys6 = overArg6(Object.keys, Object);
    module2.exports = nativeKeys6;
  }
});

// node_modules/lodash/_baseKeys.js
var require_baseKeys = __commonJS({
  "node_modules/lodash/_baseKeys.js"(exports2, module2) {
    var isPrototype5 = require_isPrototype();
    var nativeKeys6 = require_nativeKeys();
    var objectProto20 = Object.prototype;
    var hasOwnProperty17 = objectProto20.hasOwnProperty;
    function baseKeys5(object2) {
      if (!isPrototype5(object2)) {
        return nativeKeys6(object2);
      }
      var result = [];
      for (var key in Object(object2)) {
        if (hasOwnProperty17.call(object2, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeys5;
  }
});

// node_modules/lodash/isFunction.js
var require_isFunction = __commonJS({
  "node_modules/lodash/isFunction.js"(exports2, module2) {
    var baseGetTag6 = require_baseGetTag();
    var isObject10 = require_isObject();
    var asyncTag6 = "[object AsyncFunction]";
    var funcTag7 = "[object Function]";
    var genTag6 = "[object GeneratorFunction]";
    var proxyTag6 = "[object Proxy]";
    function isFunction7(value) {
      if (!isObject10(value)) {
        return false;
      }
      var tag = baseGetTag6(value);
      return tag == funcTag7 || tag == genTag6 || tag == asyncTag6 || tag == proxyTag6;
    }
    module2.exports = isFunction7;
  }
});

// node_modules/lodash/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/lodash/isArrayLike.js"(exports2, module2) {
    var isFunction7 = require_isFunction();
    var isLength6 = require_isLength();
    function isArrayLike5(value) {
      return value != null && isLength6(value.length) && !isFunction7(value);
    }
    module2.exports = isArrayLike5;
  }
});

// node_modules/lodash/keys.js
var require_keys = __commonJS({
  "node_modules/lodash/keys.js"(exports2, module2) {
    var arrayLikeKeys5 = require_arrayLikeKeys();
    var baseKeys5 = require_baseKeys();
    var isArrayLike5 = require_isArrayLike();
    function keys6(object2) {
      return isArrayLike5(object2) ? arrayLikeKeys5(object2) : baseKeys5(object2);
    }
    module2.exports = keys6;
  }
});

// node_modules/lodash/_baseForOwn.js
var require_baseForOwn = __commonJS({
  "node_modules/lodash/_baseForOwn.js"(exports2, module2) {
    var baseFor4 = require_baseFor();
    var keys6 = require_keys();
    function baseForOwn3(object2, iteratee) {
      return object2 && baseFor4(object2, iteratee, keys6);
    }
    module2.exports = baseForOwn3;
  }
});

// node_modules/lodash/identity.js
var require_identity = __commonJS({
  "node_modules/lodash/identity.js"(exports2, module2) {
    function identity3(value) {
      return value;
    }
    module2.exports = identity3;
  }
});

// node_modules/lodash/_castFunction.js
var require_castFunction = __commonJS({
  "node_modules/lodash/_castFunction.js"(exports2, module2) {
    var identity3 = require_identity();
    function castFunction2(value) {
      return typeof value == "function" ? value : identity3;
    }
    module2.exports = castFunction2;
  }
});

// node_modules/lodash/forOwn.js
var require_forOwn = __commonJS({
  "node_modules/lodash/forOwn.js"(exports2, module2) {
    var baseForOwn3 = require_baseForOwn();
    var castFunction2 = require_castFunction();
    function forOwn(object2, iteratee) {
      return object2 && baseForOwn3(object2, castFunction2(iteratee));
    }
    module2.exports = forOwn;
  }
});

// node_modules/lodash/_getPrototype.js
var require_getPrototype = __commonJS({
  "node_modules/lodash/_getPrototype.js"(exports2, module2) {
    var overArg6 = require_overArg();
    var getPrototype5 = overArg6(Object.getPrototypeOf, Object);
    module2.exports = getPrototype5;
  }
});

// node_modules/lodash/isPlainObject.js
var require_isPlainObject = __commonJS({
  "node_modules/lodash/isPlainObject.js"(exports2, module2) {
    var baseGetTag6 = require_baseGetTag();
    var getPrototype5 = require_getPrototype();
    var isObjectLike6 = require_isObjectLike();
    var objectTag8 = "[object Object]";
    var funcProto8 = Function.prototype;
    var objectProto20 = Object.prototype;
    var funcToString8 = funcProto8.toString;
    var hasOwnProperty17 = objectProto20.hasOwnProperty;
    var objectCtorString3 = funcToString8.call(Object);
    function isPlainObject7(value) {
      if (!isObjectLike6(value) || baseGetTag6(value) != objectTag8) {
        return false;
      }
      var proto2 = getPrototype5(value);
      if (proto2 === null) {
        return true;
      }
      var Ctor = hasOwnProperty17.call(proto2, "constructor") && proto2.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString8.call(Ctor) == objectCtorString3;
    }
    module2.exports = isPlainObject7;
  }
});

// node_modules/lodash/_arrayMap.js
var require_arrayMap = __commonJS({
  "node_modules/lodash/_arrayMap.js"(exports2, module2) {
    function arrayMap3(array2, iteratee) {
      var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
      while (++index2 < length) {
        result[index2] = iteratee(array2[index2], index2, array2);
      }
      return result;
    }
    module2.exports = arrayMap3;
  }
});

// node_modules/lodash/_listCacheClear.js
var require_listCacheClear = __commonJS({
  "node_modules/lodash/_listCacheClear.js"(exports2, module2) {
    function listCacheClear6() {
      this.__data__ = [];
      this.size = 0;
    }
    module2.exports = listCacheClear6;
  }
});

// node_modules/lodash/eq.js
var require_eq = __commonJS({
  "node_modules/lodash/eq.js"(exports2, module2) {
    function eq6(value, other) {
      return value === other || value !== value && other !== other;
    }
    module2.exports = eq6;
  }
});

// node_modules/lodash/_assocIndexOf.js
var require_assocIndexOf = __commonJS({
  "node_modules/lodash/_assocIndexOf.js"(exports2, module2) {
    var eq6 = require_eq();
    function assocIndexOf6(array2, key) {
      var length = array2.length;
      while (length--) {
        if (eq6(array2[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    module2.exports = assocIndexOf6;
  }
});

// node_modules/lodash/_listCacheDelete.js
var require_listCacheDelete = __commonJS({
  "node_modules/lodash/_listCacheDelete.js"(exports2, module2) {
    var assocIndexOf6 = require_assocIndexOf();
    var arrayProto6 = Array.prototype;
    var splice6 = arrayProto6.splice;
    function listCacheDelete6(key) {
      var data = this.__data__, index2 = assocIndexOf6(data, key);
      if (index2 < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index2 == lastIndex) {
        data.pop();
      } else {
        splice6.call(data, index2, 1);
      }
      --this.size;
      return true;
    }
    module2.exports = listCacheDelete6;
  }
});

// node_modules/lodash/_listCacheGet.js
var require_listCacheGet = __commonJS({
  "node_modules/lodash/_listCacheGet.js"(exports2, module2) {
    var assocIndexOf6 = require_assocIndexOf();
    function listCacheGet6(key) {
      var data = this.__data__, index2 = assocIndexOf6(data, key);
      return index2 < 0 ? void 0 : data[index2][1];
    }
    module2.exports = listCacheGet6;
  }
});

// node_modules/lodash/_listCacheHas.js
var require_listCacheHas = __commonJS({
  "node_modules/lodash/_listCacheHas.js"(exports2, module2) {
    var assocIndexOf6 = require_assocIndexOf();
    function listCacheHas6(key) {
      return assocIndexOf6(this.__data__, key) > -1;
    }
    module2.exports = listCacheHas6;
  }
});

// node_modules/lodash/_listCacheSet.js
var require_listCacheSet = __commonJS({
  "node_modules/lodash/_listCacheSet.js"(exports2, module2) {
    var assocIndexOf6 = require_assocIndexOf();
    function listCacheSet6(key, value) {
      var data = this.__data__, index2 = assocIndexOf6(data, key);
      if (index2 < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index2][1] = value;
      }
      return this;
    }
    module2.exports = listCacheSet6;
  }
});

// node_modules/lodash/_ListCache.js
var require_ListCache = __commonJS({
  "node_modules/lodash/_ListCache.js"(exports2, module2) {
    var listCacheClear6 = require_listCacheClear();
    var listCacheDelete6 = require_listCacheDelete();
    var listCacheGet6 = require_listCacheGet();
    var listCacheHas6 = require_listCacheHas();
    var listCacheSet6 = require_listCacheSet();
    function ListCache6(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    ListCache6.prototype.clear = listCacheClear6;
    ListCache6.prototype["delete"] = listCacheDelete6;
    ListCache6.prototype.get = listCacheGet6;
    ListCache6.prototype.has = listCacheHas6;
    ListCache6.prototype.set = listCacheSet6;
    module2.exports = ListCache6;
  }
});

// node_modules/lodash/_stackClear.js
var require_stackClear = __commonJS({
  "node_modules/lodash/_stackClear.js"(exports2, module2) {
    var ListCache6 = require_ListCache();
    function stackClear6() {
      this.__data__ = new ListCache6();
      this.size = 0;
    }
    module2.exports = stackClear6;
  }
});

// node_modules/lodash/_stackDelete.js
var require_stackDelete = __commonJS({
  "node_modules/lodash/_stackDelete.js"(exports2, module2) {
    function stackDelete6(key) {
      var data = this.__data__, result = data["delete"](key);
      this.size = data.size;
      return result;
    }
    module2.exports = stackDelete6;
  }
});

// node_modules/lodash/_stackGet.js
var require_stackGet = __commonJS({
  "node_modules/lodash/_stackGet.js"(exports2, module2) {
    function stackGet6(key) {
      return this.__data__.get(key);
    }
    module2.exports = stackGet6;
  }
});

// node_modules/lodash/_stackHas.js
var require_stackHas = __commonJS({
  "node_modules/lodash/_stackHas.js"(exports2, module2) {
    function stackHas6(key) {
      return this.__data__.has(key);
    }
    module2.exports = stackHas6;
  }
});

// node_modules/lodash/_coreJsData.js
var require_coreJsData = __commonJS({
  "node_modules/lodash/_coreJsData.js"(exports2, module2) {
    var root6 = require_root();
    var coreJsData6 = root6["__core-js_shared__"];
    module2.exports = coreJsData6;
  }
});

// node_modules/lodash/_isMasked.js
var require_isMasked = __commonJS({
  "node_modules/lodash/_isMasked.js"(exports2, module2) {
    var coreJsData6 = require_coreJsData();
    var maskSrcKey6 = function() {
      var uid2 = /[^.]+$/.exec(coreJsData6 && coreJsData6.keys && coreJsData6.keys.IE_PROTO || "");
      return uid2 ? "Symbol(src)_1." + uid2 : "";
    }();
    function isMasked6(func) {
      return !!maskSrcKey6 && maskSrcKey6 in func;
    }
    module2.exports = isMasked6;
  }
});

// node_modules/lodash/_toSource.js
var require_toSource = __commonJS({
  "node_modules/lodash/_toSource.js"(exports2, module2) {
    var funcProto8 = Function.prototype;
    var funcToString8 = funcProto8.toString;
    function toSource6(func) {
      if (func != null) {
        try {
          return funcToString8.call(func);
        } catch (e9) {
        }
        try {
          return func + "";
        } catch (e9) {
        }
      }
      return "";
    }
    module2.exports = toSource6;
  }
});

// node_modules/lodash/_baseIsNative.js
var require_baseIsNative = __commonJS({
  "node_modules/lodash/_baseIsNative.js"(exports2, module2) {
    var isFunction7 = require_isFunction();
    var isMasked6 = require_isMasked();
    var isObject10 = require_isObject();
    var toSource6 = require_toSource();
    var reRegExpChar6 = /[\\^$.*+?()[\]{}|]/g;
    var reIsHostCtor6 = /^\[object .+?Constructor\]$/;
    var funcProto8 = Function.prototype;
    var objectProto20 = Object.prototype;
    var funcToString8 = funcProto8.toString;
    var hasOwnProperty17 = objectProto20.hasOwnProperty;
    var reIsNative6 = RegExp(
      "^" + funcToString8.call(hasOwnProperty17).replace(reRegExpChar6, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    function baseIsNative6(value) {
      if (!isObject10(value) || isMasked6(value)) {
        return false;
      }
      var pattern = isFunction7(value) ? reIsNative6 : reIsHostCtor6;
      return pattern.test(toSource6(value));
    }
    module2.exports = baseIsNative6;
  }
});

// node_modules/lodash/_getValue.js
var require_getValue = __commonJS({
  "node_modules/lodash/_getValue.js"(exports2, module2) {
    function getValue9(object2, key) {
      return object2 == null ? void 0 : object2[key];
    }
    module2.exports = getValue9;
  }
});

// node_modules/lodash/_getNative.js
var require_getNative = __commonJS({
  "node_modules/lodash/_getNative.js"(exports2, module2) {
    var baseIsNative6 = require_baseIsNative();
    var getValue9 = require_getValue();
    function getNative6(object2, key) {
      var value = getValue9(object2, key);
      return baseIsNative6(value) ? value : void 0;
    }
    module2.exports = getNative6;
  }
});

// node_modules/lodash/_Map.js
var require_Map = __commonJS({
  "node_modules/lodash/_Map.js"(exports2, module2) {
    var getNative6 = require_getNative();
    var root6 = require_root();
    var Map7 = getNative6(root6, "Map");
    module2.exports = Map7;
  }
});

// node_modules/lodash/_nativeCreate.js
var require_nativeCreate = __commonJS({
  "node_modules/lodash/_nativeCreate.js"(exports2, module2) {
    var getNative6 = require_getNative();
    var nativeCreate6 = getNative6(Object, "create");
    module2.exports = nativeCreate6;
  }
});

// node_modules/lodash/_hashClear.js
var require_hashClear = __commonJS({
  "node_modules/lodash/_hashClear.js"(exports2, module2) {
    var nativeCreate6 = require_nativeCreate();
    function hashClear6() {
      this.__data__ = nativeCreate6 ? nativeCreate6(null) : {};
      this.size = 0;
    }
    module2.exports = hashClear6;
  }
});

// node_modules/lodash/_hashDelete.js
var require_hashDelete = __commonJS({
  "node_modules/lodash/_hashDelete.js"(exports2, module2) {
    function hashDelete6(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = hashDelete6;
  }
});

// node_modules/lodash/_hashGet.js
var require_hashGet = __commonJS({
  "node_modules/lodash/_hashGet.js"(exports2, module2) {
    var nativeCreate6 = require_nativeCreate();
    var HASH_UNDEFINED8 = "__lodash_hash_undefined__";
    var objectProto20 = Object.prototype;
    var hasOwnProperty17 = objectProto20.hasOwnProperty;
    function hashGet6(key) {
      var data = this.__data__;
      if (nativeCreate6) {
        var result = data[key];
        return result === HASH_UNDEFINED8 ? void 0 : result;
      }
      return hasOwnProperty17.call(data, key) ? data[key] : void 0;
    }
    module2.exports = hashGet6;
  }
});

// node_modules/lodash/_hashHas.js
var require_hashHas = __commonJS({
  "node_modules/lodash/_hashHas.js"(exports2, module2) {
    var nativeCreate6 = require_nativeCreate();
    var objectProto20 = Object.prototype;
    var hasOwnProperty17 = objectProto20.hasOwnProperty;
    function hashHas6(key) {
      var data = this.__data__;
      return nativeCreate6 ? data[key] !== void 0 : hasOwnProperty17.call(data, key);
    }
    module2.exports = hashHas6;
  }
});

// node_modules/lodash/_hashSet.js
var require_hashSet = __commonJS({
  "node_modules/lodash/_hashSet.js"(exports2, module2) {
    var nativeCreate6 = require_nativeCreate();
    var HASH_UNDEFINED8 = "__lodash_hash_undefined__";
    function hashSet6(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = nativeCreate6 && value === void 0 ? HASH_UNDEFINED8 : value;
      return this;
    }
    module2.exports = hashSet6;
  }
});

// node_modules/lodash/_Hash.js
var require_Hash = __commonJS({
  "node_modules/lodash/_Hash.js"(exports2, module2) {
    var hashClear6 = require_hashClear();
    var hashDelete6 = require_hashDelete();
    var hashGet6 = require_hashGet();
    var hashHas6 = require_hashHas();
    var hashSet6 = require_hashSet();
    function Hash6(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    Hash6.prototype.clear = hashClear6;
    Hash6.prototype["delete"] = hashDelete6;
    Hash6.prototype.get = hashGet6;
    Hash6.prototype.has = hashHas6;
    Hash6.prototype.set = hashSet6;
    module2.exports = Hash6;
  }
});

// node_modules/lodash/_mapCacheClear.js
var require_mapCacheClear = __commonJS({
  "node_modules/lodash/_mapCacheClear.js"(exports2, module2) {
    var Hash6 = require_Hash();
    var ListCache6 = require_ListCache();
    var Map7 = require_Map();
    function mapCacheClear6() {
      this.size = 0;
      this.__data__ = {
        "hash": new Hash6(),
        "map": new (Map7 || ListCache6)(),
        "string": new Hash6()
      };
    }
    module2.exports = mapCacheClear6;
  }
});

// node_modules/lodash/_isKeyable.js
var require_isKeyable = __commonJS({
  "node_modules/lodash/_isKeyable.js"(exports2, module2) {
    function isKeyable6(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    module2.exports = isKeyable6;
  }
});

// node_modules/lodash/_getMapData.js
var require_getMapData = __commonJS({
  "node_modules/lodash/_getMapData.js"(exports2, module2) {
    var isKeyable6 = require_isKeyable();
    function getMapData6(map5, key) {
      var data = map5.__data__;
      return isKeyable6(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    module2.exports = getMapData6;
  }
});

// node_modules/lodash/_mapCacheDelete.js
var require_mapCacheDelete = __commonJS({
  "node_modules/lodash/_mapCacheDelete.js"(exports2, module2) {
    var getMapData6 = require_getMapData();
    function mapCacheDelete6(key) {
      var result = getMapData6(this, key)["delete"](key);
      this.size -= result ? 1 : 0;
      return result;
    }
    module2.exports = mapCacheDelete6;
  }
});

// node_modules/lodash/_mapCacheGet.js
var require_mapCacheGet = __commonJS({
  "node_modules/lodash/_mapCacheGet.js"(exports2, module2) {
    var getMapData6 = require_getMapData();
    function mapCacheGet6(key) {
      return getMapData6(this, key).get(key);
    }
    module2.exports = mapCacheGet6;
  }
});

// node_modules/lodash/_mapCacheHas.js
var require_mapCacheHas = __commonJS({
  "node_modules/lodash/_mapCacheHas.js"(exports2, module2) {
    var getMapData6 = require_getMapData();
    function mapCacheHas6(key) {
      return getMapData6(this, key).has(key);
    }
    module2.exports = mapCacheHas6;
  }
});

// node_modules/lodash/_mapCacheSet.js
var require_mapCacheSet = __commonJS({
  "node_modules/lodash/_mapCacheSet.js"(exports2, module2) {
    var getMapData6 = require_getMapData();
    function mapCacheSet6(key, value) {
      var data = getMapData6(this, key), size2 = data.size;
      data.set(key, value);
      this.size += data.size == size2 ? 0 : 1;
      return this;
    }
    module2.exports = mapCacheSet6;
  }
});

// node_modules/lodash/_MapCache.js
var require_MapCache = __commonJS({
  "node_modules/lodash/_MapCache.js"(exports2, module2) {
    var mapCacheClear6 = require_mapCacheClear();
    var mapCacheDelete6 = require_mapCacheDelete();
    var mapCacheGet6 = require_mapCacheGet();
    var mapCacheHas6 = require_mapCacheHas();
    var mapCacheSet6 = require_mapCacheSet();
    function MapCache6(entries) {
      var index2 = -1, length = entries == null ? 0 : entries.length;
      this.clear();
      while (++index2 < length) {
        var entry = entries[index2];
        this.set(entry[0], entry[1]);
      }
    }
    MapCache6.prototype.clear = mapCacheClear6;
    MapCache6.prototype["delete"] = mapCacheDelete6;
    MapCache6.prototype.get = mapCacheGet6;
    MapCache6.prototype.has = mapCacheHas6;
    MapCache6.prototype.set = mapCacheSet6;
    module2.exports = MapCache6;
  }
});

// node_modules/lodash/_stackSet.js
var require_stackSet = __commonJS({
  "node_modules/lodash/_stackSet.js"(exports2, module2) {
    var ListCache6 = require_ListCache();
    var Map7 = require_Map();
    var MapCache6 = require_MapCache();
    var LARGE_ARRAY_SIZE6 = 200;
    function stackSet6(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache6) {
        var pairs = data.__data__;
        if (!Map7 || pairs.length < LARGE_ARRAY_SIZE6 - 1) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache6(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }
    module2.exports = stackSet6;
  }
});

// node_modules/lodash/_Stack.js
var require_Stack = __commonJS({
  "node_modules/lodash/_Stack.js"(exports2, module2) {
    var ListCache6 = require_ListCache();
    var stackClear6 = require_stackClear();
    var stackDelete6 = require_stackDelete();
    var stackGet6 = require_stackGet();
    var stackHas6 = require_stackHas();
    var stackSet6 = require_stackSet();
    function Stack6(entries) {
      var data = this.__data__ = new ListCache6(entries);
      this.size = data.size;
    }
    Stack6.prototype.clear = stackClear6;
    Stack6.prototype["delete"] = stackDelete6;
    Stack6.prototype.get = stackGet6;
    Stack6.prototype.has = stackHas6;
    Stack6.prototype.set = stackSet6;
    module2.exports = Stack6;
  }
});

// node_modules/lodash/_setCacheAdd.js
var require_setCacheAdd = __commonJS({
  "node_modules/lodash/_setCacheAdd.js"(exports2, module2) {
    var HASH_UNDEFINED8 = "__lodash_hash_undefined__";
    function setCacheAdd4(value) {
      this.__data__.set(value, HASH_UNDEFINED8);
      return this;
    }
    module2.exports = setCacheAdd4;
  }
});

// node_modules/lodash/_setCacheHas.js
var require_setCacheHas = __commonJS({
  "node_modules/lodash/_setCacheHas.js"(exports2, module2) {
    function setCacheHas4(value) {
      return this.__data__.has(value);
    }
    module2.exports = setCacheHas4;
  }
});

// node_modules/lodash/_SetCache.js
var require_SetCache = __commonJS({
  "node_modules/lodash/_SetCache.js"(exports2, module2) {
    var MapCache6 = require_MapCache();
    var setCacheAdd4 = require_setCacheAdd();
    var setCacheHas4 = require_setCacheHas();
    function SetCache4(values3) {
      var index2 = -1, length = values3 == null ? 0 : values3.length;
      this.__data__ = new MapCache6();
      while (++index2 < length) {
        this.add(values3[index2]);
      }
    }
    SetCache4.prototype.add = SetCache4.prototype.push = setCacheAdd4;
    SetCache4.prototype.has = setCacheHas4;
    module2.exports = SetCache4;
  }
});

// node_modules/lodash/_arraySome.js
var require_arraySome = __commonJS({
  "node_modules/lodash/_arraySome.js"(exports2, module2) {
    function arraySome3(array2, predicate) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      while (++index2 < length) {
        if (predicate(array2[index2], index2, array2)) {
          return true;
        }
      }
      return false;
    }
    module2.exports = arraySome3;
  }
});

// node_modules/lodash/_cacheHas.js
var require_cacheHas = __commonJS({
  "node_modules/lodash/_cacheHas.js"(exports2, module2) {
    function cacheHas3(cache, key) {
      return cache.has(key);
    }
    module2.exports = cacheHas3;
  }
});

// node_modules/lodash/_equalArrays.js
var require_equalArrays = __commonJS({
  "node_modules/lodash/_equalArrays.js"(exports2, module2) {
    var SetCache4 = require_SetCache();
    var arraySome3 = require_arraySome();
    var cacheHas3 = require_cacheHas();
    var COMPARE_PARTIAL_FLAG8 = 1;
    var COMPARE_UNORDERED_FLAG6 = 2;
    function equalArrays3(array2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG8, arrLength = array2.length, othLength = other.length;
      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      var arrStacked = stack.get(array2);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array2;
      }
      var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG6 ? new SetCache4() : void 0;
      stack.set(array2, other);
      stack.set(other, array2);
      while (++index2 < arrLength) {
        var arrValue = array2[index2], othValue = other[index2];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
        }
        if (compared !== void 0) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        if (seen) {
          if (!arraySome3(other, function(othValue2, othIndex) {
            if (!cacheHas3(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
            result = false;
            break;
          }
        } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
          result = false;
          break;
        }
      }
      stack["delete"](array2);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalArrays3;
  }
});

// node_modules/lodash/_Uint8Array.js
var require_Uint8Array = __commonJS({
  "node_modules/lodash/_Uint8Array.js"(exports2, module2) {
    var root6 = require_root();
    var Uint8Array7 = root6.Uint8Array;
    module2.exports = Uint8Array7;
  }
});

// node_modules/lodash/_mapToArray.js
var require_mapToArray = __commonJS({
  "node_modules/lodash/_mapToArray.js"(exports2, module2) {
    function mapToArray3(map5) {
      var index2 = -1, result = Array(map5.size);
      map5.forEach(function(value, key) {
        result[++index2] = [key, value];
      });
      return result;
    }
    module2.exports = mapToArray3;
  }
});

// node_modules/lodash/_setToArray.js
var require_setToArray = __commonJS({
  "node_modules/lodash/_setToArray.js"(exports2, module2) {
    function setToArray3(set3) {
      var index2 = -1, result = Array(set3.size);
      set3.forEach(function(value) {
        result[++index2] = value;
      });
      return result;
    }
    module2.exports = setToArray3;
  }
});

// node_modules/lodash/_equalByTag.js
var require_equalByTag = __commonJS({
  "node_modules/lodash/_equalByTag.js"(exports2, module2) {
    var Symbol5 = require_Symbol();
    var Uint8Array7 = require_Uint8Array();
    var eq6 = require_eq();
    var equalArrays3 = require_equalArrays();
    var mapToArray3 = require_mapToArray();
    var setToArray3 = require_setToArray();
    var COMPARE_PARTIAL_FLAG8 = 1;
    var COMPARE_UNORDERED_FLAG6 = 2;
    var boolTag6 = "[object Boolean]";
    var dateTag6 = "[object Date]";
    var errorTag6 = "[object Error]";
    var mapTag8 = "[object Map]";
    var numberTag6 = "[object Number]";
    var regexpTag6 = "[object RegExp]";
    var setTag8 = "[object Set]";
    var stringTag6 = "[object String]";
    var symbolTag6 = "[object Symbol]";
    var arrayBufferTag6 = "[object ArrayBuffer]";
    var dataViewTag8 = "[object DataView]";
    var symbolProto7 = Symbol5 ? Symbol5.prototype : void 0;
    var symbolValueOf6 = symbolProto7 ? symbolProto7.valueOf : void 0;
    function equalByTag3(object2, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag8:
          if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
            return false;
          }
          object2 = object2.buffer;
          other = other.buffer;
        case arrayBufferTag6:
          if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array7(object2), new Uint8Array7(other))) {
            return false;
          }
          return true;
        case boolTag6:
        case dateTag6:
        case numberTag6:
          return eq6(+object2, +other);
        case errorTag6:
          return object2.name == other.name && object2.message == other.message;
        case regexpTag6:
        case stringTag6:
          return object2 == other + "";
        case mapTag8:
          var convert = mapToArray3;
        case setTag8:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG8;
          convert || (convert = setToArray3);
          if (object2.size != other.size && !isPartial) {
            return false;
          }
          var stacked = stack.get(object2);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG6;
          stack.set(object2, other);
          var result = equalArrays3(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
          stack["delete"](object2);
          return result;
        case symbolTag6:
          if (symbolValueOf6) {
            return symbolValueOf6.call(object2) == symbolValueOf6.call(other);
          }
      }
      return false;
    }
    module2.exports = equalByTag3;
  }
});

// node_modules/lodash/_arrayPush.js
var require_arrayPush = __commonJS({
  "node_modules/lodash/_arrayPush.js"(exports2, module2) {
    function arrayPush5(array2, values3) {
      var index2 = -1, length = values3.length, offset5 = array2.length;
      while (++index2 < length) {
        array2[offset5 + index2] = values3[index2];
      }
      return array2;
    }
    module2.exports = arrayPush5;
  }
});

// node_modules/lodash/_baseGetAllKeys.js
var require_baseGetAllKeys = __commonJS({
  "node_modules/lodash/_baseGetAllKeys.js"(exports2, module2) {
    var arrayPush5 = require_arrayPush();
    var isArray10 = require_isArray();
    function baseGetAllKeys5(object2, keysFunc, symbolsFunc) {
      var result = keysFunc(object2);
      return isArray10(object2) ? result : arrayPush5(result, symbolsFunc(object2));
    }
    module2.exports = baseGetAllKeys5;
  }
});

// node_modules/lodash/_arrayFilter.js
var require_arrayFilter = __commonJS({
  "node_modules/lodash/_arrayFilter.js"(exports2, module2) {
    function arrayFilter5(array2, predicate) {
      var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
      while (++index2 < length) {
        var value = array2[index2];
        if (predicate(value, index2, array2)) {
          result[resIndex++] = value;
        }
      }
      return result;
    }
    module2.exports = arrayFilter5;
  }
});

// node_modules/lodash/stubArray.js
var require_stubArray = __commonJS({
  "node_modules/lodash/stubArray.js"(exports2, module2) {
    function stubArray5() {
      return [];
    }
    module2.exports = stubArray5;
  }
});

// node_modules/lodash/_getSymbols.js
var require_getSymbols = __commonJS({
  "node_modules/lodash/_getSymbols.js"(exports2, module2) {
    var arrayFilter5 = require_arrayFilter();
    var stubArray5 = require_stubArray();
    var objectProto20 = Object.prototype;
    var propertyIsEnumerable7 = objectProto20.propertyIsEnumerable;
    var nativeGetSymbols5 = Object.getOwnPropertySymbols;
    var getSymbols5 = !nativeGetSymbols5 ? stubArray5 : function(object2) {
      if (object2 == null) {
        return [];
      }
      object2 = Object(object2);
      return arrayFilter5(nativeGetSymbols5(object2), function(symbol) {
        return propertyIsEnumerable7.call(object2, symbol);
      });
    };
    module2.exports = getSymbols5;
  }
});

// node_modules/lodash/_getAllKeys.js
var require_getAllKeys = __commonJS({
  "node_modules/lodash/_getAllKeys.js"(exports2, module2) {
    var baseGetAllKeys5 = require_baseGetAllKeys();
    var getSymbols5 = require_getSymbols();
    var keys6 = require_keys();
    function getAllKeys5(object2) {
      return baseGetAllKeys5(object2, keys6, getSymbols5);
    }
    module2.exports = getAllKeys5;
  }
});

// node_modules/lodash/_equalObjects.js
var require_equalObjects = __commonJS({
  "node_modules/lodash/_equalObjects.js"(exports2, module2) {
    var getAllKeys5 = require_getAllKeys();
    var COMPARE_PARTIAL_FLAG8 = 1;
    var objectProto20 = Object.prototype;
    var hasOwnProperty17 = objectProto20.hasOwnProperty;
    function equalObjects3(object2, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG8, objProps = getAllKeys5(object2), objLength = objProps.length, othProps = getAllKeys5(other), othLength = othProps.length;
      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index2 = objLength;
      while (index2--) {
        var key = objProps[index2];
        if (!(isPartial ? key in other : hasOwnProperty17.call(other, key))) {
          return false;
        }
      }
      var objStacked = stack.get(object2);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object2;
      }
      var result = true;
      stack.set(object2, other);
      stack.set(other, object2);
      var skipCtor = isPartial;
      while (++index2 < objLength) {
        key = objProps[index2];
        var objValue = object2[key], othValue = other[key];
        if (customizer) {
          var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
        }
        if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == "constructor");
      }
      if (result && !skipCtor) {
        var objCtor = object2.constructor, othCtor = other.constructor;
        if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack["delete"](object2);
      stack["delete"](other);
      return result;
    }
    module2.exports = equalObjects3;
  }
});

// node_modules/lodash/_DataView.js
var require_DataView = __commonJS({
  "node_modules/lodash/_DataView.js"(exports2, module2) {
    var getNative6 = require_getNative();
    var root6 = require_root();
    var DataView6 = getNative6(root6, "DataView");
    module2.exports = DataView6;
  }
});

// node_modules/lodash/_Promise.js
var require_Promise = __commonJS({
  "node_modules/lodash/_Promise.js"(exports2, module2) {
    var getNative6 = require_getNative();
    var root6 = require_root();
    var Promise3 = getNative6(root6, "Promise");
    module2.exports = Promise3;
  }
});

// node_modules/lodash/_Set.js
var require_Set = __commonJS({
  "node_modules/lodash/_Set.js"(exports2, module2) {
    var getNative6 = require_getNative();
    var root6 = require_root();
    var Set7 = getNative6(root6, "Set");
    module2.exports = Set7;
  }
});

// node_modules/lodash/_WeakMap.js
var require_WeakMap = __commonJS({
  "node_modules/lodash/_WeakMap.js"(exports2, module2) {
    var getNative6 = require_getNative();
    var root6 = require_root();
    var WeakMap6 = getNative6(root6, "WeakMap");
    module2.exports = WeakMap6;
  }
});

// node_modules/lodash/_getTag.js
var require_getTag = __commonJS({
  "node_modules/lodash/_getTag.js"(exports2, module2) {
    var DataView6 = require_DataView();
    var Map7 = require_Map();
    var Promise3 = require_Promise();
    var Set7 = require_Set();
    var WeakMap6 = require_WeakMap();
    var baseGetTag6 = require_baseGetTag();
    var toSource6 = require_toSource();
    var mapTag8 = "[object Map]";
    var objectTag8 = "[object Object]";
    var promiseTag6 = "[object Promise]";
    var setTag8 = "[object Set]";
    var weakMapTag7 = "[object WeakMap]";
    var dataViewTag8 = "[object DataView]";
    var dataViewCtorString6 = toSource6(DataView6);
    var mapCtorString6 = toSource6(Map7);
    var promiseCtorString6 = toSource6(Promise3);
    var setCtorString6 = toSource6(Set7);
    var weakMapCtorString6 = toSource6(WeakMap6);
    var getTag6 = baseGetTag6;
    if (DataView6 && getTag6(new DataView6(new ArrayBuffer(1))) != dataViewTag8 || Map7 && getTag6(new Map7()) != mapTag8 || Promise3 && getTag6(Promise3.resolve()) != promiseTag6 || Set7 && getTag6(new Set7()) != setTag8 || WeakMap6 && getTag6(new WeakMap6()) != weakMapTag7) {
      getTag6 = function(value) {
        var result = baseGetTag6(value), Ctor = result == objectTag8 ? value.constructor : void 0, ctorString = Ctor ? toSource6(Ctor) : "";
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString6:
              return dataViewTag8;
            case mapCtorString6:
              return mapTag8;
            case promiseCtorString6:
              return promiseTag6;
            case setCtorString6:
              return setTag8;
            case weakMapCtorString6:
              return weakMapTag7;
          }
        }
        return result;
      };
    }
    module2.exports = getTag6;
  }
});

// node_modules/lodash/_baseIsEqualDeep.js
var require_baseIsEqualDeep = __commonJS({
  "node_modules/lodash/_baseIsEqualDeep.js"(exports2, module2) {
    var Stack6 = require_Stack();
    var equalArrays3 = require_equalArrays();
    var equalByTag3 = require_equalByTag();
    var equalObjects3 = require_equalObjects();
    var getTag6 = require_getTag();
    var isArray10 = require_isArray();
    var isBuffer2 = require_isBuffer();
    var isTypedArray6 = require_isTypedArray();
    var COMPARE_PARTIAL_FLAG8 = 1;
    var argsTag7 = "[object Arguments]";
    var arrayTag6 = "[object Array]";
    var objectTag8 = "[object Object]";
    var objectProto20 = Object.prototype;
    var hasOwnProperty17 = objectProto20.hasOwnProperty;
    function baseIsEqualDeep3(object2, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray10(object2), othIsArr = isArray10(other), objTag = objIsArr ? arrayTag6 : getTag6(object2), othTag = othIsArr ? arrayTag6 : getTag6(other);
      objTag = objTag == argsTag7 ? objectTag8 : objTag;
      othTag = othTag == argsTag7 ? objectTag8 : othTag;
      var objIsObj = objTag == objectTag8, othIsObj = othTag == objectTag8, isSameTag = objTag == othTag;
      if (isSameTag && isBuffer2(object2)) {
        if (!isBuffer2(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack6());
        return objIsArr || isTypedArray6(object2) ? equalArrays3(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag3(object2, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG8)) {
        var objIsWrapped = objIsObj && hasOwnProperty17.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty17.call(other, "__wrapped__");
        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
          stack || (stack = new Stack6());
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack6());
      return equalObjects3(object2, other, bitmask, customizer, equalFunc, stack);
    }
    module2.exports = baseIsEqualDeep3;
  }
});

// node_modules/lodash/_baseIsEqual.js
var require_baseIsEqual = __commonJS({
  "node_modules/lodash/_baseIsEqual.js"(exports2, module2) {
    var baseIsEqualDeep3 = require_baseIsEqualDeep();
    var isObjectLike6 = require_isObjectLike();
    function baseIsEqual3(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || !isObjectLike6(value) && !isObjectLike6(other)) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep3(value, other, bitmask, customizer, baseIsEqual3, stack);
    }
    module2.exports = baseIsEqual3;
  }
});

// node_modules/lodash/_baseIsMatch.js
var require_baseIsMatch = __commonJS({
  "node_modules/lodash/_baseIsMatch.js"(exports2, module2) {
    var Stack6 = require_Stack();
    var baseIsEqual3 = require_baseIsEqual();
    var COMPARE_PARTIAL_FLAG8 = 1;
    var COMPARE_UNORDERED_FLAG6 = 2;
    function baseIsMatch3(object2, source, matchData, customizer) {
      var index2 = matchData.length, length = index2, noCustomizer = !customizer;
      if (object2 == null) {
        return !length;
      }
      object2 = Object(object2);
      while (index2--) {
        var data = matchData[index2];
        if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
          return false;
        }
      }
      while (++index2 < length) {
        data = matchData[index2];
        var key = data[0], objValue = object2[key], srcValue = data[1];
        if (noCustomizer && data[2]) {
          if (objValue === void 0 && !(key in object2)) {
            return false;
          }
        } else {
          var stack = new Stack6();
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object2, source, stack);
          }
          if (!(result === void 0 ? baseIsEqual3(srcValue, objValue, COMPARE_PARTIAL_FLAG8 | COMPARE_UNORDERED_FLAG6, customizer, stack) : result)) {
            return false;
          }
        }
      }
      return true;
    }
    module2.exports = baseIsMatch3;
  }
});

// node_modules/lodash/_isStrictComparable.js
var require_isStrictComparable = __commonJS({
  "node_modules/lodash/_isStrictComparable.js"(exports2, module2) {
    var isObject10 = require_isObject();
    function isStrictComparable3(value) {
      return value === value && !isObject10(value);
    }
    module2.exports = isStrictComparable3;
  }
});

// node_modules/lodash/_getMatchData.js
var require_getMatchData = __commonJS({
  "node_modules/lodash/_getMatchData.js"(exports2, module2) {
    var isStrictComparable3 = require_isStrictComparable();
    var keys6 = require_keys();
    function getMatchData3(object2) {
      var result = keys6(object2), length = result.length;
      while (length--) {
        var key = result[length], value = object2[key];
        result[length] = [key, value, isStrictComparable3(value)];
      }
      return result;
    }
    module2.exports = getMatchData3;
  }
});

// node_modules/lodash/_matchesStrictComparable.js
var require_matchesStrictComparable = __commonJS({
  "node_modules/lodash/_matchesStrictComparable.js"(exports2, module2) {
    function matchesStrictComparable3(key, srcValue) {
      return function(object2) {
        if (object2 == null) {
          return false;
        }
        return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
      };
    }
    module2.exports = matchesStrictComparable3;
  }
});

// node_modules/lodash/_baseMatches.js
var require_baseMatches = __commonJS({
  "node_modules/lodash/_baseMatches.js"(exports2, module2) {
    var baseIsMatch3 = require_baseIsMatch();
    var getMatchData3 = require_getMatchData();
    var matchesStrictComparable3 = require_matchesStrictComparable();
    function baseMatches3(source) {
      var matchData = getMatchData3(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable3(matchData[0][0], matchData[0][1]);
      }
      return function(object2) {
        return object2 === source || baseIsMatch3(object2, source, matchData);
      };
    }
    module2.exports = baseMatches3;
  }
});

// node_modules/lodash/_isKey.js
var require_isKey = __commonJS({
  "node_modules/lodash/_isKey.js"(exports2, module2) {
    var isArray10 = require_isArray();
    var isSymbol3 = require_isSymbol();
    var reIsDeepProp3 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
    var reIsPlainProp3 = /^\w*$/;
    function isKey3(value, object2) {
      if (isArray10(value)) {
        return false;
      }
      var type = typeof value;
      if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol3(value)) {
        return true;
      }
      return reIsPlainProp3.test(value) || !reIsDeepProp3.test(value) || object2 != null && value in Object(object2);
    }
    module2.exports = isKey3;
  }
});

// node_modules/lodash/memoize.js
var require_memoize = __commonJS({
  "node_modules/lodash/memoize.js"(exports2, module2) {
    var MapCache6 = require_MapCache();
    var FUNC_ERROR_TEXT6 = "Expected a function";
    function memoize6(func, resolver) {
      if (typeof func != "function" || resolver != null && typeof resolver != "function") {
        throw new TypeError(FUNC_ERROR_TEXT6);
      }
      var memoized = function() {
        var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize6.Cache || MapCache6)();
      return memoized;
    }
    memoize6.Cache = MapCache6;
    module2.exports = memoize6;
  }
});

// node_modules/lodash/_memoizeCapped.js
var require_memoizeCapped = __commonJS({
  "node_modules/lodash/_memoizeCapped.js"(exports2, module2) {
    var memoize6 = require_memoize();
    var MAX_MEMOIZE_SIZE4 = 500;
    function memoizeCapped4(func) {
      var result = memoize6(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE4) {
          cache.clear();
        }
        return key;
      });
      var cache = result.cache;
      return result;
    }
    module2.exports = memoizeCapped4;
  }
});

// node_modules/lodash/_stringToPath.js
var require_stringToPath = __commonJS({
  "node_modules/lodash/_stringToPath.js"(exports2, module2) {
    var memoizeCapped4 = require_memoizeCapped();
    var rePropName5 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
    var reEscapeChar5 = /\\(\\)?/g;
    var stringToPath6 = memoizeCapped4(function(string2) {
      var result = [];
      if (string2.charCodeAt(0) === 46) {
        result.push("");
      }
      string2.replace(rePropName5, function(match5, number2, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar5, "$1") : number2 || match5);
      });
      return result;
    });
    module2.exports = stringToPath6;
  }
});

// node_modules/lodash/_baseToString.js
var require_baseToString = __commonJS({
  "node_modules/lodash/_baseToString.js"(exports2, module2) {
    var Symbol5 = require_Symbol();
    var arrayMap3 = require_arrayMap();
    var isArray10 = require_isArray();
    var isSymbol3 = require_isSymbol();
    var INFINITY5 = 1 / 0;
    var symbolProto7 = Symbol5 ? Symbol5.prototype : void 0;
    var symbolToString5 = symbolProto7 ? symbolProto7.toString : void 0;
    function baseToString3(value) {
      if (typeof value == "string") {
        return value;
      }
      if (isArray10(value)) {
        return arrayMap3(value, baseToString3) + "";
      }
      if (isSymbol3(value)) {
        return symbolToString5 ? symbolToString5.call(value) : "";
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY5 ? "-0" : result;
    }
    module2.exports = baseToString3;
  }
});

// node_modules/lodash/toString.js
var require_toString = __commonJS({
  "node_modules/lodash/toString.js"(exports2, module2) {
    var baseToString3 = require_baseToString();
    function toString7(value) {
      return value == null ? "" : baseToString3(value);
    }
    module2.exports = toString7;
  }
});

// node_modules/lodash/_castPath.js
var require_castPath = __commonJS({
  "node_modules/lodash/_castPath.js"(exports2, module2) {
    var isArray10 = require_isArray();
    var isKey3 = require_isKey();
    var stringToPath6 = require_stringToPath();
    var toString7 = require_toString();
    function castPath3(value, object2) {
      if (isArray10(value)) {
        return value;
      }
      return isKey3(value, object2) ? [value] : stringToPath6(toString7(value));
    }
    module2.exports = castPath3;
  }
});

// node_modules/lodash/_toKey.js
var require_toKey = __commonJS({
  "node_modules/lodash/_toKey.js"(exports2, module2) {
    var isSymbol3 = require_isSymbol();
    var INFINITY5 = 1 / 0;
    function toKey3(value) {
      if (typeof value == "string" || isSymbol3(value)) {
        return value;
      }
      var result = value + "";
      return result == "0" && 1 / value == -INFINITY5 ? "-0" : result;
    }
    module2.exports = toKey3;
  }
});

// node_modules/lodash/_baseGet.js
var require_baseGet = __commonJS({
  "node_modules/lodash/_baseGet.js"(exports2, module2) {
    var castPath3 = require_castPath();
    var toKey3 = require_toKey();
    function baseGet3(object2, path) {
      path = castPath3(path, object2);
      var index2 = 0, length = path.length;
      while (object2 != null && index2 < length) {
        object2 = object2[toKey3(path[index2++])];
      }
      return index2 && index2 == length ? object2 : void 0;
    }
    module2.exports = baseGet3;
  }
});

// node_modules/lodash/get.js
var require_get = __commonJS({
  "node_modules/lodash/get.js"(exports2, module2) {
    var baseGet3 = require_baseGet();
    function get8(object2, path, defaultValue) {
      var result = object2 == null ? void 0 : baseGet3(object2, path);
      return result === void 0 ? defaultValue : result;
    }
    module2.exports = get8;
  }
});

// node_modules/lodash/_baseHasIn.js
var require_baseHasIn = __commonJS({
  "node_modules/lodash/_baseHasIn.js"(exports2, module2) {
    function baseHasIn3(object2, key) {
      return object2 != null && key in Object(object2);
    }
    module2.exports = baseHasIn3;
  }
});

// node_modules/lodash/_hasPath.js
var require_hasPath = __commonJS({
  "node_modules/lodash/_hasPath.js"(exports2, module2) {
    var castPath3 = require_castPath();
    var isArguments6 = require_isArguments();
    var isArray10 = require_isArray();
    var isIndex5 = require_isIndex();
    var isLength6 = require_isLength();
    var toKey3 = require_toKey();
    function hasPath3(object2, path, hasFunc) {
      path = castPath3(path, object2);
      var index2 = -1, length = path.length, result = false;
      while (++index2 < length) {
        var key = toKey3(path[index2]);
        if (!(result = object2 != null && hasFunc(object2, key))) {
          break;
        }
        object2 = object2[key];
      }
      if (result || ++index2 != length) {
        return result;
      }
      length = object2 == null ? 0 : object2.length;
      return !!length && isLength6(length) && isIndex5(key, length) && (isArray10(object2) || isArguments6(object2));
    }
    module2.exports = hasPath3;
  }
});

// node_modules/lodash/hasIn.js
var require_hasIn = __commonJS({
  "node_modules/lodash/hasIn.js"(exports2, module2) {
    var baseHasIn3 = require_baseHasIn();
    var hasPath3 = require_hasPath();
    function hasIn3(object2, path) {
      return object2 != null && hasPath3(object2, path, baseHasIn3);
    }
    module2.exports = hasIn3;
  }
});

// node_modules/lodash/_baseMatchesProperty.js
var require_baseMatchesProperty = __commonJS({
  "node_modules/lodash/_baseMatchesProperty.js"(exports2, module2) {
    var baseIsEqual3 = require_baseIsEqual();
    var get8 = require_get();
    var hasIn3 = require_hasIn();
    var isKey3 = require_isKey();
    var isStrictComparable3 = require_isStrictComparable();
    var matchesStrictComparable3 = require_matchesStrictComparable();
    var toKey3 = require_toKey();
    var COMPARE_PARTIAL_FLAG8 = 1;
    var COMPARE_UNORDERED_FLAG6 = 2;
    function baseMatchesProperty3(path, srcValue) {
      if (isKey3(path) && isStrictComparable3(srcValue)) {
        return matchesStrictComparable3(toKey3(path), srcValue);
      }
      return function(object2) {
        var objValue = get8(object2, path);
        return objValue === void 0 && objValue === srcValue ? hasIn3(object2, path) : baseIsEqual3(srcValue, objValue, COMPARE_PARTIAL_FLAG8 | COMPARE_UNORDERED_FLAG6);
      };
    }
    module2.exports = baseMatchesProperty3;
  }
});

// node_modules/lodash/_baseProperty.js
var require_baseProperty = __commonJS({
  "node_modules/lodash/_baseProperty.js"(exports2, module2) {
    function baseProperty3(key) {
      return function(object2) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    module2.exports = baseProperty3;
  }
});

// node_modules/lodash/_basePropertyDeep.js
var require_basePropertyDeep = __commonJS({
  "node_modules/lodash/_basePropertyDeep.js"(exports2, module2) {
    var baseGet3 = require_baseGet();
    function basePropertyDeep3(path) {
      return function(object2) {
        return baseGet3(object2, path);
      };
    }
    module2.exports = basePropertyDeep3;
  }
});

// node_modules/lodash/property.js
var require_property = __commonJS({
  "node_modules/lodash/property.js"(exports2, module2) {
    var baseProperty3 = require_baseProperty();
    var basePropertyDeep3 = require_basePropertyDeep();
    var isKey3 = require_isKey();
    var toKey3 = require_toKey();
    function property3(path) {
      return isKey3(path) ? baseProperty3(toKey3(path)) : basePropertyDeep3(path);
    }
    module2.exports = property3;
  }
});

// node_modules/lodash/_baseIteratee.js
var require_baseIteratee = __commonJS({
  "node_modules/lodash/_baseIteratee.js"(exports2, module2) {
    var baseMatches3 = require_baseMatches();
    var baseMatchesProperty3 = require_baseMatchesProperty();
    var identity3 = require_identity();
    var isArray10 = require_isArray();
    var property3 = require_property();
    function baseIteratee3(value) {
      if (typeof value == "function") {
        return value;
      }
      if (value == null) {
        return identity3;
      }
      if (typeof value == "object") {
        return isArray10(value) ? baseMatchesProperty3(value[0], value[1]) : baseMatches3(value);
      }
      return property3(value);
    }
    module2.exports = baseIteratee3;
  }
});

// node_modules/lodash/_createBaseEach.js
var require_createBaseEach = __commonJS({
  "node_modules/lodash/_createBaseEach.js"(exports2, module2) {
    var isArrayLike5 = require_isArrayLike();
    function createBaseEach3(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike5(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
        while (fromRight ? index2-- : ++index2 < length) {
          if (iteratee(iterable[index2], index2, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }
    module2.exports = createBaseEach3;
  }
});

// node_modules/lodash/_baseEach.js
var require_baseEach = __commonJS({
  "node_modules/lodash/_baseEach.js"(exports2, module2) {
    var baseForOwn3 = require_baseForOwn();
    var createBaseEach3 = require_createBaseEach();
    var baseEach3 = createBaseEach3(baseForOwn3);
    module2.exports = baseEach3;
  }
});

// node_modules/lodash/_baseMap.js
var require_baseMap = __commonJS({
  "node_modules/lodash/_baseMap.js"(exports2, module2) {
    var baseEach3 = require_baseEach();
    var isArrayLike5 = require_isArrayLike();
    function baseMap3(collection, iteratee) {
      var index2 = -1, result = isArrayLike5(collection) ? Array(collection.length) : [];
      baseEach3(collection, function(value, key, collection2) {
        result[++index2] = iteratee(value, key, collection2);
      });
      return result;
    }
    module2.exports = baseMap3;
  }
});

// node_modules/lodash/map.js
var require_map = __commonJS({
  "node_modules/lodash/map.js"(exports2, module2) {
    var arrayMap3 = require_arrayMap();
    var baseIteratee3 = require_baseIteratee();
    var baseMap3 = require_baseMap();
    var isArray10 = require_isArray();
    function map5(collection, iteratee) {
      var func = isArray10(collection) ? arrayMap3 : baseMap3;
      return func(collection, baseIteratee3(iteratee, 3));
    }
    module2.exports = map5;
  }
});

// node_modules/reactcss/lib/flattenNames.js
var require_flattenNames = __commonJS({
  "node_modules/reactcss/lib/flattenNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.flattenNames = void 0;
    var _isString2 = require_isString();
    var _isString3 = _interopRequireDefault(_isString2);
    var _forOwn2 = require_forOwn();
    var _forOwn3 = _interopRequireDefault(_forOwn2);
    var _isPlainObject2 = require_isPlainObject();
    var _isPlainObject3 = _interopRequireDefault(_isPlainObject2);
    var _map2 = require_map();
    var _map3 = _interopRequireDefault(_map2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var flattenNames = exports2.flattenNames = function flattenNames2() {
      var things = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
      var names2 = [];
      (0, _map3.default)(things, function(thing) {
        if (Array.isArray(thing)) {
          flattenNames2(thing).map(function(name2) {
            return names2.push(name2);
          });
        } else if ((0, _isPlainObject3.default)(thing)) {
          (0, _forOwn3.default)(thing, function(value, key) {
            value === true && names2.push(key);
            names2.push(key + "-" + value);
          });
        } else if ((0, _isString3.default)(thing)) {
          names2.push(thing);
        }
      });
      return names2;
    };
    exports2.default = flattenNames;
  }
});

// node_modules/lodash/_arrayEach.js
var require_arrayEach = __commonJS({
  "node_modules/lodash/_arrayEach.js"(exports2, module2) {
    function arrayEach5(array2, iteratee) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      while (++index2 < length) {
        if (iteratee(array2[index2], index2, array2) === false) {
          break;
        }
      }
      return array2;
    }
    module2.exports = arrayEach5;
  }
});

// node_modules/lodash/_defineProperty.js
var require_defineProperty = __commonJS({
  "node_modules/lodash/_defineProperty.js"(exports2, module2) {
    var getNative6 = require_getNative();
    var defineProperty6 = function() {
      try {
        var func = getNative6(Object, "defineProperty");
        func({}, "", {});
        return func;
      } catch (e9) {
      }
    }();
    module2.exports = defineProperty6;
  }
});

// node_modules/lodash/_baseAssignValue.js
var require_baseAssignValue = __commonJS({
  "node_modules/lodash/_baseAssignValue.js"(exports2, module2) {
    var defineProperty6 = require_defineProperty();
    function baseAssignValue5(object2, key, value) {
      if (key == "__proto__" && defineProperty6) {
        defineProperty6(object2, key, {
          "configurable": true,
          "enumerable": true,
          "value": value,
          "writable": true
        });
      } else {
        object2[key] = value;
      }
    }
    module2.exports = baseAssignValue5;
  }
});

// node_modules/lodash/_assignValue.js
var require_assignValue = __commonJS({
  "node_modules/lodash/_assignValue.js"(exports2, module2) {
    var baseAssignValue5 = require_baseAssignValue();
    var eq6 = require_eq();
    var objectProto20 = Object.prototype;
    var hasOwnProperty17 = objectProto20.hasOwnProperty;
    function assignValue5(object2, key, value) {
      var objValue = object2[key];
      if (!(hasOwnProperty17.call(object2, key) && eq6(objValue, value)) || value === void 0 && !(key in object2)) {
        baseAssignValue5(object2, key, value);
      }
    }
    module2.exports = assignValue5;
  }
});

// node_modules/lodash/_copyObject.js
var require_copyObject = __commonJS({
  "node_modules/lodash/_copyObject.js"(exports2, module2) {
    var assignValue5 = require_assignValue();
    var baseAssignValue5 = require_baseAssignValue();
    function copyObject5(source, props, object2, customizer) {
      var isNew = !object2;
      object2 || (object2 = {});
      var index2 = -1, length = props.length;
      while (++index2 < length) {
        var key = props[index2];
        var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
        if (newValue === void 0) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue5(object2, key, newValue);
        } else {
          assignValue5(object2, key, newValue);
        }
      }
      return object2;
    }
    module2.exports = copyObject5;
  }
});

// node_modules/lodash/_baseAssign.js
var require_baseAssign = __commonJS({
  "node_modules/lodash/_baseAssign.js"(exports2, module2) {
    var copyObject5 = require_copyObject();
    var keys6 = require_keys();
    function baseAssign4(object2, source) {
      return object2 && copyObject5(source, keys6(source), object2);
    }
    module2.exports = baseAssign4;
  }
});

// node_modules/lodash/_nativeKeysIn.js
var require_nativeKeysIn = __commonJS({
  "node_modules/lodash/_nativeKeysIn.js"(exports2, module2) {
    function nativeKeysIn5(object2) {
      var result = [];
      if (object2 != null) {
        for (var key in Object(object2)) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = nativeKeysIn5;
  }
});

// node_modules/lodash/_baseKeysIn.js
var require_baseKeysIn = __commonJS({
  "node_modules/lodash/_baseKeysIn.js"(exports2, module2) {
    var isObject10 = require_isObject();
    var isPrototype5 = require_isPrototype();
    var nativeKeysIn5 = require_nativeKeysIn();
    var objectProto20 = Object.prototype;
    var hasOwnProperty17 = objectProto20.hasOwnProperty;
    function baseKeysIn5(object2) {
      if (!isObject10(object2)) {
        return nativeKeysIn5(object2);
      }
      var isProto = isPrototype5(object2), result = [];
      for (var key in object2) {
        if (!(key == "constructor" && (isProto || !hasOwnProperty17.call(object2, key)))) {
          result.push(key);
        }
      }
      return result;
    }
    module2.exports = baseKeysIn5;
  }
});

// node_modules/lodash/keysIn.js
var require_keysIn = __commonJS({
  "node_modules/lodash/keysIn.js"(exports2, module2) {
    var arrayLikeKeys5 = require_arrayLikeKeys();
    var baseKeysIn5 = require_baseKeysIn();
    var isArrayLike5 = require_isArrayLike();
    function keysIn5(object2) {
      return isArrayLike5(object2) ? arrayLikeKeys5(object2, true) : baseKeysIn5(object2);
    }
    module2.exports = keysIn5;
  }
});

// node_modules/lodash/_baseAssignIn.js
var require_baseAssignIn = __commonJS({
  "node_modules/lodash/_baseAssignIn.js"(exports2, module2) {
    var copyObject5 = require_copyObject();
    var keysIn5 = require_keysIn();
    function baseAssignIn4(object2, source) {
      return object2 && copyObject5(source, keysIn5(source), object2);
    }
    module2.exports = baseAssignIn4;
  }
});

// node_modules/lodash/_cloneBuffer.js
var require_cloneBuffer = __commonJS({
  "node_modules/lodash/_cloneBuffer.js"(exports2, module2) {
    var root6 = require_root();
    var freeExports4 = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule4 = freeExports4 && typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
    var Buffer3 = moduleExports4 ? root6.Buffer : void 0;
    var allocUnsafe2 = Buffer3 ? Buffer3.allocUnsafe : void 0;
    function cloneBuffer2(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length, result = allocUnsafe2 ? allocUnsafe2(length) : new buffer.constructor(length);
      buffer.copy(result);
      return result;
    }
    module2.exports = cloneBuffer2;
  }
});

// node_modules/lodash/_copyArray.js
var require_copyArray = __commonJS({
  "node_modules/lodash/_copyArray.js"(exports2, module2) {
    function copyArray5(source, array2) {
      var index2 = -1, length = source.length;
      array2 || (array2 = Array(length));
      while (++index2 < length) {
        array2[index2] = source[index2];
      }
      return array2;
    }
    module2.exports = copyArray5;
  }
});

// node_modules/lodash/_copySymbols.js
var require_copySymbols = __commonJS({
  "node_modules/lodash/_copySymbols.js"(exports2, module2) {
    var copyObject5 = require_copyObject();
    var getSymbols5 = require_getSymbols();
    function copySymbols4(source, object2) {
      return copyObject5(source, getSymbols5(source), object2);
    }
    module2.exports = copySymbols4;
  }
});

// node_modules/lodash/_getSymbolsIn.js
var require_getSymbolsIn = __commonJS({
  "node_modules/lodash/_getSymbolsIn.js"(exports2, module2) {
    var arrayPush5 = require_arrayPush();
    var getPrototype5 = require_getPrototype();
    var getSymbols5 = require_getSymbols();
    var stubArray5 = require_stubArray();
    var nativeGetSymbols5 = Object.getOwnPropertySymbols;
    var getSymbolsIn4 = !nativeGetSymbols5 ? stubArray5 : function(object2) {
      var result = [];
      while (object2) {
        arrayPush5(result, getSymbols5(object2));
        object2 = getPrototype5(object2);
      }
      return result;
    };
    module2.exports = getSymbolsIn4;
  }
});

// node_modules/lodash/_copySymbolsIn.js
var require_copySymbolsIn = __commonJS({
  "node_modules/lodash/_copySymbolsIn.js"(exports2, module2) {
    var copyObject5 = require_copyObject();
    var getSymbolsIn4 = require_getSymbolsIn();
    function copySymbolsIn4(source, object2) {
      return copyObject5(source, getSymbolsIn4(source), object2);
    }
    module2.exports = copySymbolsIn4;
  }
});

// node_modules/lodash/_getAllKeysIn.js
var require_getAllKeysIn = __commonJS({
  "node_modules/lodash/_getAllKeysIn.js"(exports2, module2) {
    var baseGetAllKeys5 = require_baseGetAllKeys();
    var getSymbolsIn4 = require_getSymbolsIn();
    var keysIn5 = require_keysIn();
    function getAllKeysIn4(object2) {
      return baseGetAllKeys5(object2, keysIn5, getSymbolsIn4);
    }
    module2.exports = getAllKeysIn4;
  }
});

// node_modules/lodash/_initCloneArray.js
var require_initCloneArray = __commonJS({
  "node_modules/lodash/_initCloneArray.js"(exports2, module2) {
    var objectProto20 = Object.prototype;
    var hasOwnProperty17 = objectProto20.hasOwnProperty;
    function initCloneArray4(array2) {
      var length = array2.length, result = new array2.constructor(length);
      if (length && typeof array2[0] == "string" && hasOwnProperty17.call(array2, "index")) {
        result.index = array2.index;
        result.input = array2.input;
      }
      return result;
    }
    module2.exports = initCloneArray4;
  }
});

// node_modules/lodash/_cloneArrayBuffer.js
var require_cloneArrayBuffer = __commonJS({
  "node_modules/lodash/_cloneArrayBuffer.js"(exports2, module2) {
    var Uint8Array7 = require_Uint8Array();
    function cloneArrayBuffer5(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array7(result).set(new Uint8Array7(arrayBuffer));
      return result;
    }
    module2.exports = cloneArrayBuffer5;
  }
});

// node_modules/lodash/_cloneDataView.js
var require_cloneDataView = __commonJS({
  "node_modules/lodash/_cloneDataView.js"(exports2, module2) {
    var cloneArrayBuffer5 = require_cloneArrayBuffer();
    function cloneDataView4(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer5(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    module2.exports = cloneDataView4;
  }
});

// node_modules/lodash/_cloneRegExp.js
var require_cloneRegExp = __commonJS({
  "node_modules/lodash/_cloneRegExp.js"(exports2, module2) {
    var reFlags4 = /\w*$/;
    function cloneRegExp4(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags4.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    module2.exports = cloneRegExp4;
  }
});

// node_modules/lodash/_cloneSymbol.js
var require_cloneSymbol = __commonJS({
  "node_modules/lodash/_cloneSymbol.js"(exports2, module2) {
    var Symbol5 = require_Symbol();
    var symbolProto7 = Symbol5 ? Symbol5.prototype : void 0;
    var symbolValueOf6 = symbolProto7 ? symbolProto7.valueOf : void 0;
    function cloneSymbol4(symbol) {
      return symbolValueOf6 ? Object(symbolValueOf6.call(symbol)) : {};
    }
    module2.exports = cloneSymbol4;
  }
});

// node_modules/lodash/_cloneTypedArray.js
var require_cloneTypedArray = __commonJS({
  "node_modules/lodash/_cloneTypedArray.js"(exports2, module2) {
    var cloneArrayBuffer5 = require_cloneArrayBuffer();
    function cloneTypedArray5(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer5(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    module2.exports = cloneTypedArray5;
  }
});

// node_modules/lodash/_initCloneByTag.js
var require_initCloneByTag = __commonJS({
  "node_modules/lodash/_initCloneByTag.js"(exports2, module2) {
    var cloneArrayBuffer5 = require_cloneArrayBuffer();
    var cloneDataView4 = require_cloneDataView();
    var cloneRegExp4 = require_cloneRegExp();
    var cloneSymbol4 = require_cloneSymbol();
    var cloneTypedArray5 = require_cloneTypedArray();
    var boolTag6 = "[object Boolean]";
    var dateTag6 = "[object Date]";
    var mapTag8 = "[object Map]";
    var numberTag6 = "[object Number]";
    var regexpTag6 = "[object RegExp]";
    var setTag8 = "[object Set]";
    var stringTag6 = "[object String]";
    var symbolTag6 = "[object Symbol]";
    var arrayBufferTag6 = "[object ArrayBuffer]";
    var dataViewTag8 = "[object DataView]";
    var float32Tag6 = "[object Float32Array]";
    var float64Tag6 = "[object Float64Array]";
    var int8Tag6 = "[object Int8Array]";
    var int16Tag6 = "[object Int16Array]";
    var int32Tag6 = "[object Int32Array]";
    var uint8Tag6 = "[object Uint8Array]";
    var uint8ClampedTag6 = "[object Uint8ClampedArray]";
    var uint16Tag6 = "[object Uint16Array]";
    var uint32Tag6 = "[object Uint32Array]";
    function initCloneByTag4(object2, tag, isDeep) {
      var Ctor = object2.constructor;
      switch (tag) {
        case arrayBufferTag6:
          return cloneArrayBuffer5(object2);
        case boolTag6:
        case dateTag6:
          return new Ctor(+object2);
        case dataViewTag8:
          return cloneDataView4(object2, isDeep);
        case float32Tag6:
        case float64Tag6:
        case int8Tag6:
        case int16Tag6:
        case int32Tag6:
        case uint8Tag6:
        case uint8ClampedTag6:
        case uint16Tag6:
        case uint32Tag6:
          return cloneTypedArray5(object2, isDeep);
        case mapTag8:
          return new Ctor();
        case numberTag6:
        case stringTag6:
          return new Ctor(object2);
        case regexpTag6:
          return cloneRegExp4(object2);
        case setTag8:
          return new Ctor();
        case symbolTag6:
          return cloneSymbol4(object2);
      }
    }
    module2.exports = initCloneByTag4;
  }
});

// node_modules/lodash/_baseCreate.js
var require_baseCreate = __commonJS({
  "node_modules/lodash/_baseCreate.js"(exports2, module2) {
    var isObject10 = require_isObject();
    var objectCreate5 = Object.create;
    var baseCreate5 = function() {
      function object2() {
      }
      return function(proto2) {
        if (!isObject10(proto2)) {
          return {};
        }
        if (objectCreate5) {
          return objectCreate5(proto2);
        }
        object2.prototype = proto2;
        var result = new object2();
        object2.prototype = void 0;
        return result;
      };
    }();
    module2.exports = baseCreate5;
  }
});

// node_modules/lodash/_initCloneObject.js
var require_initCloneObject = __commonJS({
  "node_modules/lodash/_initCloneObject.js"(exports2, module2) {
    var baseCreate5 = require_baseCreate();
    var getPrototype5 = require_getPrototype();
    var isPrototype5 = require_isPrototype();
    function initCloneObject5(object2) {
      return typeof object2.constructor == "function" && !isPrototype5(object2) ? baseCreate5(getPrototype5(object2)) : {};
    }
    module2.exports = initCloneObject5;
  }
});

// node_modules/lodash/_baseIsMap.js
var require_baseIsMap = __commonJS({
  "node_modules/lodash/_baseIsMap.js"(exports2, module2) {
    var getTag6 = require_getTag();
    var isObjectLike6 = require_isObjectLike();
    var mapTag8 = "[object Map]";
    function baseIsMap4(value) {
      return isObjectLike6(value) && getTag6(value) == mapTag8;
    }
    module2.exports = baseIsMap4;
  }
});

// node_modules/lodash/isMap.js
var require_isMap = __commonJS({
  "node_modules/lodash/isMap.js"(exports2, module2) {
    var baseIsMap4 = require_baseIsMap();
    var baseUnary6 = require_baseUnary();
    var nodeUtil2 = require_nodeUtil();
    var nodeIsMap4 = nodeUtil2 && nodeUtil2.isMap;
    var isMap4 = nodeIsMap4 ? baseUnary6(nodeIsMap4) : baseIsMap4;
    module2.exports = isMap4;
  }
});

// node_modules/lodash/_baseIsSet.js
var require_baseIsSet = __commonJS({
  "node_modules/lodash/_baseIsSet.js"(exports2, module2) {
    var getTag6 = require_getTag();
    var isObjectLike6 = require_isObjectLike();
    var setTag8 = "[object Set]";
    function baseIsSet4(value) {
      return isObjectLike6(value) && getTag6(value) == setTag8;
    }
    module2.exports = baseIsSet4;
  }
});

// node_modules/lodash/isSet.js
var require_isSet = __commonJS({
  "node_modules/lodash/isSet.js"(exports2, module2) {
    var baseIsSet4 = require_baseIsSet();
    var baseUnary6 = require_baseUnary();
    var nodeUtil2 = require_nodeUtil();
    var nodeIsSet4 = nodeUtil2 && nodeUtil2.isSet;
    var isSet4 = nodeIsSet4 ? baseUnary6(nodeIsSet4) : baseIsSet4;
    module2.exports = isSet4;
  }
});

// node_modules/lodash/_baseClone.js
var require_baseClone = __commonJS({
  "node_modules/lodash/_baseClone.js"(exports2, module2) {
    var Stack6 = require_Stack();
    var arrayEach5 = require_arrayEach();
    var assignValue5 = require_assignValue();
    var baseAssign4 = require_baseAssign();
    var baseAssignIn4 = require_baseAssignIn();
    var cloneBuffer2 = require_cloneBuffer();
    var copyArray5 = require_copyArray();
    var copySymbols4 = require_copySymbols();
    var copySymbolsIn4 = require_copySymbolsIn();
    var getAllKeys5 = require_getAllKeys();
    var getAllKeysIn4 = require_getAllKeysIn();
    var getTag6 = require_getTag();
    var initCloneArray4 = require_initCloneArray();
    var initCloneByTag4 = require_initCloneByTag();
    var initCloneObject5 = require_initCloneObject();
    var isArray10 = require_isArray();
    var isBuffer2 = require_isBuffer();
    var isMap4 = require_isMap();
    var isObject10 = require_isObject();
    var isSet4 = require_isSet();
    var keys6 = require_keys();
    var keysIn5 = require_keysIn();
    var CLONE_DEEP_FLAG4 = 1;
    var CLONE_FLAT_FLAG4 = 2;
    var CLONE_SYMBOLS_FLAG4 = 4;
    var argsTag7 = "[object Arguments]";
    var arrayTag6 = "[object Array]";
    var boolTag6 = "[object Boolean]";
    var dateTag6 = "[object Date]";
    var errorTag6 = "[object Error]";
    var funcTag7 = "[object Function]";
    var genTag6 = "[object GeneratorFunction]";
    var mapTag8 = "[object Map]";
    var numberTag6 = "[object Number]";
    var objectTag8 = "[object Object]";
    var regexpTag6 = "[object RegExp]";
    var setTag8 = "[object Set]";
    var stringTag6 = "[object String]";
    var symbolTag6 = "[object Symbol]";
    var weakMapTag7 = "[object WeakMap]";
    var arrayBufferTag6 = "[object ArrayBuffer]";
    var dataViewTag8 = "[object DataView]";
    var float32Tag6 = "[object Float32Array]";
    var float64Tag6 = "[object Float64Array]";
    var int8Tag6 = "[object Int8Array]";
    var int16Tag6 = "[object Int16Array]";
    var int32Tag6 = "[object Int32Array]";
    var uint8Tag6 = "[object Uint8Array]";
    var uint8ClampedTag6 = "[object Uint8ClampedArray]";
    var uint16Tag6 = "[object Uint16Array]";
    var uint32Tag6 = "[object Uint32Array]";
    var cloneableTags4 = {};
    cloneableTags4[argsTag7] = cloneableTags4[arrayTag6] = cloneableTags4[arrayBufferTag6] = cloneableTags4[dataViewTag8] = cloneableTags4[boolTag6] = cloneableTags4[dateTag6] = cloneableTags4[float32Tag6] = cloneableTags4[float64Tag6] = cloneableTags4[int8Tag6] = cloneableTags4[int16Tag6] = cloneableTags4[int32Tag6] = cloneableTags4[mapTag8] = cloneableTags4[numberTag6] = cloneableTags4[objectTag8] = cloneableTags4[regexpTag6] = cloneableTags4[setTag8] = cloneableTags4[stringTag6] = cloneableTags4[symbolTag6] = cloneableTags4[uint8Tag6] = cloneableTags4[uint8ClampedTag6] = cloneableTags4[uint16Tag6] = cloneableTags4[uint32Tag6] = true;
    cloneableTags4[errorTag6] = cloneableTags4[funcTag7] = cloneableTags4[weakMapTag7] = false;
    function baseClone5(value, bitmask, customizer, key, object2, stack) {
      var result, isDeep = bitmask & CLONE_DEEP_FLAG4, isFlat = bitmask & CLONE_FLAT_FLAG4, isFull = bitmask & CLONE_SYMBOLS_FLAG4;
      if (customizer) {
        result = object2 ? customizer(value, key, object2, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject10(value)) {
        return value;
      }
      var isArr = isArray10(value);
      if (isArr) {
        result = initCloneArray4(value);
        if (!isDeep) {
          return copyArray5(value, result);
        }
      } else {
        var tag = getTag6(value), isFunc = tag == funcTag7 || tag == genTag6;
        if (isBuffer2(value)) {
          return cloneBuffer2(value, isDeep);
        }
        if (tag == objectTag8 || tag == argsTag7 || isFunc && !object2) {
          result = isFlat || isFunc ? {} : initCloneObject5(value);
          if (!isDeep) {
            return isFlat ? copySymbolsIn4(value, baseAssignIn4(result, value)) : copySymbols4(value, baseAssign4(result, value));
          }
        } else {
          if (!cloneableTags4[tag]) {
            return object2 ? value : {};
          }
          result = initCloneByTag4(value, tag, isDeep);
        }
      }
      stack || (stack = new Stack6());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (isSet4(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone5(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap4(value)) {
        value.forEach(function(subValue, key2) {
          result.set(key2, baseClone5(subValue, bitmask, customizer, key2, value, stack));
        });
      }
      var keysFunc = isFull ? isFlat ? getAllKeysIn4 : getAllKeys5 : isFlat ? keysIn5 : keys6;
      var props = isArr ? void 0 : keysFunc(value);
      arrayEach5(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue5(result, key2, baseClone5(subValue, bitmask, customizer, key2, value, stack));
      });
      return result;
    }
    module2.exports = baseClone5;
  }
});

// node_modules/lodash/cloneDeep.js
var require_cloneDeep = __commonJS({
  "node_modules/lodash/cloneDeep.js"(exports2, module2) {
    var baseClone5 = require_baseClone();
    var CLONE_DEEP_FLAG4 = 1;
    var CLONE_SYMBOLS_FLAG4 = 4;
    function cloneDeep4(value) {
      return baseClone5(value, CLONE_DEEP_FLAG4 | CLONE_SYMBOLS_FLAG4);
    }
    module2.exports = cloneDeep4;
  }
});

// node_modules/reactcss/lib/mergeClasses.js
var require_mergeClasses = __commonJS({
  "node_modules/reactcss/lib/mergeClasses.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.mergeClasses = void 0;
    var _forOwn2 = require_forOwn();
    var _forOwn3 = _interopRequireDefault(_forOwn2);
    var _cloneDeep2 = require_cloneDeep();
    var _cloneDeep3 = _interopRequireDefault(_cloneDeep2);
    var _extends24 = Object.assign || function(target) {
      for (var i15 = 1; i15 < arguments.length; i15++) {
        var source = arguments[i15];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var mergeClasses = exports2.mergeClasses = function mergeClasses2(classes) {
      var activeNames = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
      var styles5 = classes.default && (0, _cloneDeep3.default)(classes.default) || {};
      activeNames.map(function(name2) {
        var toMerge = classes[name2];
        if (toMerge) {
          (0, _forOwn3.default)(toMerge, function(value, key) {
            if (!styles5[key]) {
              styles5[key] = {};
            }
            styles5[key] = _extends24({}, styles5[key], toMerge[key]);
          });
        }
        return name2;
      });
      return styles5;
    };
    exports2.default = mergeClasses;
  }
});

// node_modules/reactcss/lib/autoprefix.js
var require_autoprefix = __commonJS({
  "node_modules/reactcss/lib/autoprefix.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.autoprefix = void 0;
    var _forOwn2 = require_forOwn();
    var _forOwn3 = _interopRequireDefault(_forOwn2);
    var _extends24 = Object.assign || function(target) {
      for (var i15 = 1; i15 < arguments.length; i15++) {
        var source = arguments[i15];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var transforms2 = {
      borderRadius: function borderRadius(value) {
        return {
          msBorderRadius: value,
          MozBorderRadius: value,
          OBorderRadius: value,
          WebkitBorderRadius: value,
          borderRadius: value
        };
      },
      boxShadow: function boxShadow(value) {
        return {
          msBoxShadow: value,
          MozBoxShadow: value,
          OBoxShadow: value,
          WebkitBoxShadow: value,
          boxShadow: value
        };
      },
      userSelect: function userSelect(value) {
        return {
          WebkitTouchCallout: value,
          KhtmlUserSelect: value,
          MozUserSelect: value,
          msUserSelect: value,
          WebkitUserSelect: value,
          userSelect: value
        };
      },
      flex: function flex(value) {
        return {
          WebkitBoxFlex: value,
          MozBoxFlex: value,
          WebkitFlex: value,
          msFlex: value,
          flex: value
        };
      },
      flexBasis: function flexBasis(value) {
        return {
          WebkitFlexBasis: value,
          flexBasis: value
        };
      },
      justifyContent: function justifyContent(value) {
        return {
          WebkitJustifyContent: value,
          justifyContent: value
        };
      },
      transition: function transition(value) {
        return {
          msTransition: value,
          MozTransition: value,
          OTransition: value,
          WebkitTransition: value,
          transition: value
        };
      },
      transform: function transform(value) {
        return {
          msTransform: value,
          MozTransform: value,
          OTransform: value,
          WebkitTransform: value,
          transform: value
        };
      },
      absolute: function absolute(value) {
        var direction = value && value.split(" ");
        return {
          position: "absolute",
          top: direction && direction[0],
          right: direction && direction[1],
          bottom: direction && direction[2],
          left: direction && direction[3]
        };
      },
      extend: function extend2(name2, otherElementStyles) {
        var otherStyle = otherElementStyles[name2];
        if (otherStyle) {
          return otherStyle;
        }
        return {
          "extend": name2
        };
      }
    };
    var autoprefix = exports2.autoprefix = function autoprefix2(elements) {
      var prefixed = {};
      (0, _forOwn3.default)(elements, function(styles5, element) {
        var expanded = {};
        (0, _forOwn3.default)(styles5, function(value, key) {
          var transform = transforms2[key];
          if (transform) {
            expanded = _extends24({}, expanded, transform(value));
          } else {
            expanded[key] = value;
          }
        });
        prefixed[element] = expanded;
      });
      return prefixed;
    };
    exports2.default = autoprefix;
  }
});

// node_modules/reactcss/lib/components/hover.js
var require_hover = __commonJS({
  "node_modules/reactcss/lib/components/hover.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.hover = void 0;
    var _extends24 = Object.assign || function(target) {
      for (var i15 = 1; i15 < arguments.length; i15++) {
        var source = arguments[i15];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _react = require_react();
    var _react2 = _interopRequireDefault(_react);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck9(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn9(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits9(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var hover = exports2.hover = function hover2(Component9) {
      var Span2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
      return function(_React$Component) {
        _inherits9(Hover, _React$Component);
        function Hover() {
          var _ref;
          var _temp, _this, _ret;
          _classCallCheck9(this, Hover);
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return _ret = (_temp = (_this = _possibleConstructorReturn9(this, (_ref = Hover.__proto__ || Object.getPrototypeOf(Hover)).call.apply(_ref, [this].concat(args))), _this), _this.state = { hover: false }, _this.handleMouseOver = function() {
            return _this.setState({ hover: true });
          }, _this.handleMouseOut = function() {
            return _this.setState({ hover: false });
          }, _this.render = function() {
            return _react2.default.createElement(
              Span2,
              { onMouseOver: _this.handleMouseOver, onMouseOut: _this.handleMouseOut },
              _react2.default.createElement(Component9, _extends24({}, _this.props, _this.state))
            );
          }, _temp), _possibleConstructorReturn9(_this, _ret);
        }
        return Hover;
      }(_react2.default.Component);
    };
    exports2.default = hover;
  }
});

// node_modules/reactcss/lib/components/active.js
var require_active = __commonJS({
  "node_modules/reactcss/lib/components/active.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.active = void 0;
    var _extends24 = Object.assign || function(target) {
      for (var i15 = 1; i15 < arguments.length; i15++) {
        var source = arguments[i15];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _react = require_react();
    var _react2 = _interopRequireDefault(_react);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _classCallCheck9(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _possibleConstructorReturn9(self2, call) {
      if (!self2) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return call && (typeof call === "object" || typeof call === "function") ? call : self2;
    }
    function _inherits9(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
      if (superClass)
        Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }
    var active = exports2.active = function active2(Component9) {
      var Span2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
      return function(_React$Component) {
        _inherits9(Active, _React$Component);
        function Active() {
          var _ref;
          var _temp, _this, _ret;
          _classCallCheck9(this, Active);
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return _ret = (_temp = (_this = _possibleConstructorReturn9(this, (_ref = Active.__proto__ || Object.getPrototypeOf(Active)).call.apply(_ref, [this].concat(args))), _this), _this.state = { active: false }, _this.handleMouseDown = function() {
            return _this.setState({ active: true });
          }, _this.handleMouseUp = function() {
            return _this.setState({ active: false });
          }, _this.render = function() {
            return _react2.default.createElement(
              Span2,
              { onMouseDown: _this.handleMouseDown, onMouseUp: _this.handleMouseUp },
              _react2.default.createElement(Component9, _extends24({}, _this.props, _this.state))
            );
          }, _temp), _possibleConstructorReturn9(_this, _ret);
        }
        return Active;
      }(_react2.default.Component);
    };
    exports2.default = active;
  }
});

// node_modules/reactcss/lib/loop.js
var require_loop = __commonJS({
  "node_modules/reactcss/lib/loop.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var loopable = function loopable2(i15, length) {
      var props = {};
      var setProp = function setProp2(name2) {
        var value = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
        props[name2] = value;
      };
      i15 === 0 && setProp("first-child");
      i15 === length - 1 && setProp("last-child");
      (i15 === 0 || i15 % 2 === 0) && setProp("even");
      Math.abs(i15 % 2) === 1 && setProp("odd");
      setProp("nth-child", i15);
      return props;
    };
    exports2.default = loopable;
  }
});

// node_modules/reactcss/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/reactcss/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ReactCSS = exports2.loop = exports2.handleActive = exports2.handleHover = exports2.hover = void 0;
    var _flattenNames = require_flattenNames();
    var _flattenNames2 = _interopRequireDefault(_flattenNames);
    var _mergeClasses = require_mergeClasses();
    var _mergeClasses2 = _interopRequireDefault(_mergeClasses);
    var _autoprefix = require_autoprefix();
    var _autoprefix2 = _interopRequireDefault(_autoprefix);
    var _hover2 = require_hover();
    var _hover3 = _interopRequireDefault(_hover2);
    var _active = require_active();
    var _active2 = _interopRequireDefault(_active);
    var _loop2 = require_loop();
    var _loop3 = _interopRequireDefault(_loop2);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    exports2.hover = _hover3.default;
    exports2.handleHover = _hover3.default;
    exports2.handleActive = _active2.default;
    exports2.loop = _loop3.default;
    var ReactCSS = exports2.ReactCSS = function ReactCSS2(classes) {
      for (var _len = arguments.length, activations = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        activations[_key - 1] = arguments[_key];
      }
      var activeNames = (0, _flattenNames2.default)(activations);
      var merged = (0, _mergeClasses2.default)(classes, activeNames);
      return (0, _autoprefix2.default)(merged);
    };
    exports2.default = ReactCSS;
  }
});

// node_modules/@icons/material/UnfoldMoreHorizontalIcon.js
var require_UnfoldMoreHorizontalIcon = __commonJS({
  "node_modules/@icons/material/UnfoldMoreHorizontalIcon.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _extends24 = Object.assign || function(target) {
      for (var i15 = 1; i15 < arguments.length; i15++) {
        var source = arguments[i15];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _react = require_react();
    var _react2 = _interopRequireDefault(_react);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _objectWithoutProperties4(obj, keys6) {
      var target = {};
      for (var i15 in obj) {
        if (keys6.indexOf(i15) >= 0)
          continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i15))
          continue;
        target[i15] = obj[i15];
      }
      return target;
    }
    var DEFAULT_SIZE3 = 24;
    exports2.default = function(_ref) {
      var _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "currentColor" : _ref$fill, _ref$width = _ref.width, width = _ref$width === void 0 ? DEFAULT_SIZE3 : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? DEFAULT_SIZE3 : _ref$height, _ref$style = _ref.style, style2 = _ref$style === void 0 ? {} : _ref$style, props = _objectWithoutProperties4(_ref, ["fill", "width", "height", "style"]);
      return _react2.default.createElement(
        "svg",
        _extends24({
          viewBox: "0 0 " + DEFAULT_SIZE3 + " " + DEFAULT_SIZE3,
          style: _extends24({ fill, width, height }, style2)
        }, props),
        _react2.default.createElement("path", { d: "M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z" })
      );
    };
  }
});

// node_modules/@icons/material/CheckIcon.js
var require_CheckIcon = __commonJS({
  "node_modules/@icons/material/CheckIcon.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _extends24 = Object.assign || function(target) {
      for (var i15 = 1; i15 < arguments.length; i15++) {
        var source = arguments[i15];
        for (var key in source) {
          if (Object.prototype.hasOwnProperty.call(source, key)) {
            target[key] = source[key];
          }
        }
      }
      return target;
    };
    var _react = require_react();
    var _react2 = _interopRequireDefault(_react);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _objectWithoutProperties4(obj, keys6) {
      var target = {};
      for (var i15 in obj) {
        if (keys6.indexOf(i15) >= 0)
          continue;
        if (!Object.prototype.hasOwnProperty.call(obj, i15))
          continue;
        target[i15] = obj[i15];
      }
      return target;
    }
    var DEFAULT_SIZE3 = 24;
    exports2.default = function(_ref) {
      var _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "currentColor" : _ref$fill, _ref$width = _ref.width, width = _ref$width === void 0 ? DEFAULT_SIZE3 : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? DEFAULT_SIZE3 : _ref$height, _ref$style = _ref.style, style2 = _ref$style === void 0 ? {} : _ref$style, props = _objectWithoutProperties4(_ref, ["fill", "width", "height", "style"]);
      return _react2.default.createElement(
        "svg",
        _extends24({
          viewBox: "0 0 " + DEFAULT_SIZE3 + " " + DEFAULT_SIZE3,
          style: _extends24({ fill, width, height }, style2)
        }, props),
        _react2.default.createElement("path", { d: "M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z" })
      );
    };
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [240, 248, 255],
      "antiquewhite": [250, 235, 215],
      "aqua": [0, 255, 255],
      "aquamarine": [127, 255, 212],
      "azure": [240, 255, 255],
      "beige": [245, 245, 220],
      "bisque": [255, 228, 196],
      "black": [0, 0, 0],
      "blanchedalmond": [255, 235, 205],
      "blue": [0, 0, 255],
      "blueviolet": [138, 43, 226],
      "brown": [165, 42, 42],
      "burlywood": [222, 184, 135],
      "cadetblue": [95, 158, 160],
      "chartreuse": [127, 255, 0],
      "chocolate": [210, 105, 30],
      "coral": [255, 127, 80],
      "cornflowerblue": [100, 149, 237],
      "cornsilk": [255, 248, 220],
      "crimson": [220, 20, 60],
      "cyan": [0, 255, 255],
      "darkblue": [0, 0, 139],
      "darkcyan": [0, 139, 139],
      "darkgoldenrod": [184, 134, 11],
      "darkgray": [169, 169, 169],
      "darkgreen": [0, 100, 0],
      "darkgrey": [169, 169, 169],
      "darkkhaki": [189, 183, 107],
      "darkmagenta": [139, 0, 139],
      "darkolivegreen": [85, 107, 47],
      "darkorange": [255, 140, 0],
      "darkorchid": [153, 50, 204],
      "darkred": [139, 0, 0],
      "darksalmon": [233, 150, 122],
      "darkseagreen": [143, 188, 143],
      "darkslateblue": [72, 61, 139],
      "darkslategray": [47, 79, 79],
      "darkslategrey": [47, 79, 79],
      "darkturquoise": [0, 206, 209],
      "darkviolet": [148, 0, 211],
      "deeppink": [255, 20, 147],
      "deepskyblue": [0, 191, 255],
      "dimgray": [105, 105, 105],
      "dimgrey": [105, 105, 105],
      "dodgerblue": [30, 144, 255],
      "firebrick": [178, 34, 34],
      "floralwhite": [255, 250, 240],
      "forestgreen": [34, 139, 34],
      "fuchsia": [255, 0, 255],
      "gainsboro": [220, 220, 220],
      "ghostwhite": [248, 248, 255],
      "gold": [255, 215, 0],
      "goldenrod": [218, 165, 32],
      "gray": [128, 128, 128],
      "green": [0, 128, 0],
      "greenyellow": [173, 255, 47],
      "grey": [128, 128, 128],
      "honeydew": [240, 255, 240],
      "hotpink": [255, 105, 180],
      "indianred": [205, 92, 92],
      "indigo": [75, 0, 130],
      "ivory": [255, 255, 240],
      "khaki": [240, 230, 140],
      "lavender": [230, 230, 250],
      "lavenderblush": [255, 240, 245],
      "lawngreen": [124, 252, 0],
      "lemonchiffon": [255, 250, 205],
      "lightblue": [173, 216, 230],
      "lightcoral": [240, 128, 128],
      "lightcyan": [224, 255, 255],
      "lightgoldenrodyellow": [250, 250, 210],
      "lightgray": [211, 211, 211],
      "lightgreen": [144, 238, 144],
      "lightgrey": [211, 211, 211],
      "lightpink": [255, 182, 193],
      "lightsalmon": [255, 160, 122],
      "lightseagreen": [32, 178, 170],
      "lightskyblue": [135, 206, 250],
      "lightslategray": [119, 136, 153],
      "lightslategrey": [119, 136, 153],
      "lightsteelblue": [176, 196, 222],
      "lightyellow": [255, 255, 224],
      "lime": [0, 255, 0],
      "limegreen": [50, 205, 50],
      "linen": [250, 240, 230],
      "magenta": [255, 0, 255],
      "maroon": [128, 0, 0],
      "mediumaquamarine": [102, 205, 170],
      "mediumblue": [0, 0, 205],
      "mediumorchid": [186, 85, 211],
      "mediumpurple": [147, 112, 219],
      "mediumseagreen": [60, 179, 113],
      "mediumslateblue": [123, 104, 238],
      "mediumspringgreen": [0, 250, 154],
      "mediumturquoise": [72, 209, 204],
      "mediumvioletred": [199, 21, 133],
      "midnightblue": [25, 25, 112],
      "mintcream": [245, 255, 250],
      "mistyrose": [255, 228, 225],
      "moccasin": [255, 228, 181],
      "navajowhite": [255, 222, 173],
      "navy": [0, 0, 128],
      "oldlace": [253, 245, 230],
      "olive": [128, 128, 0],
      "olivedrab": [107, 142, 35],
      "orange": [255, 165, 0],
      "orangered": [255, 69, 0],
      "orchid": [218, 112, 214],
      "palegoldenrod": [238, 232, 170],
      "palegreen": [152, 251, 152],
      "paleturquoise": [175, 238, 238],
      "palevioletred": [219, 112, 147],
      "papayawhip": [255, 239, 213],
      "peachpuff": [255, 218, 185],
      "peru": [205, 133, 63],
      "pink": [255, 192, 203],
      "plum": [221, 160, 221],
      "powderblue": [176, 224, 230],
      "purple": [128, 0, 128],
      "rebeccapurple": [102, 51, 153],
      "red": [255, 0, 0],
      "rosybrown": [188, 143, 143],
      "royalblue": [65, 105, 225],
      "saddlebrown": [139, 69, 19],
      "salmon": [250, 128, 114],
      "sandybrown": [244, 164, 96],
      "seagreen": [46, 139, 87],
      "seashell": [255, 245, 238],
      "sienna": [160, 82, 45],
      "silver": [192, 192, 192],
      "skyblue": [135, 206, 235],
      "slateblue": [106, 90, 205],
      "slategray": [112, 128, 144],
      "slategrey": [112, 128, 144],
      "snow": [255, 250, 250],
      "springgreen": [0, 255, 127],
      "steelblue": [70, 130, 180],
      "tan": [210, 180, 140],
      "teal": [0, 128, 128],
      "thistle": [216, 191, 216],
      "tomato": [255, 99, 71],
      "turquoise": [64, 224, 208],
      "violet": [238, 130, 238],
      "wheat": [245, 222, 179],
      "white": [255, 255, 255],
      "whitesmoke": [245, 245, 245],
      "yellow": [255, 255, 0],
      "yellowgreen": [154, 205, 50]
    };
  }
});

// node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/is-arrayish/index.js"(exports2, module2) {
    module2.exports = function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    };
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports2, module2) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat3 = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle = module2.exports = function swizzle2(args) {
      var results = [];
      for (var i15 = 0, len = args.length; i15 < len; i15++) {
        var arg = args[i15];
        if (isArrayish(arg)) {
          results = concat3.call(results, slice.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    };
    swizzle.wrap = function(fn2) {
      return function() {
        return fn2(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports2, module2) {
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty17 = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name2 in colorNames) {
      if (hasOwnProperty17.call(colorNames, name2)) {
        reverseNames[colorNames[name2]] = name2;
      }
    }
    var name2;
    var cs = module2.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string2) {
      var prefix3 = string2.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix3) {
        case "hsl":
          val = cs.get.hsl(string2);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string2);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string2);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return { model, value: val };
    };
    cs.get.rgb = function(string2) {
      if (!string2) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [0, 0, 0, 1];
      var match5;
      var i15;
      var hexAlpha;
      if (match5 = string2.match(hex)) {
        hexAlpha = match5[2];
        match5 = match5[1];
        for (i15 = 0; i15 < 3; i15++) {
          var i22 = i15 * 2;
          rgb[i15] = parseInt(match5.slice(i22, i22 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match5 = string2.match(abbr)) {
        match5 = match5[1];
        hexAlpha = match5[3];
        for (i15 = 0; i15 < 3; i15++) {
          rgb[i15] = parseInt(match5[i15] + match5[i15], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match5 = string2.match(rgba)) {
        for (i15 = 0; i15 < 3; i15++) {
          rgb[i15] = parseInt(match5[i15 + 1], 0);
        }
        if (match5[4]) {
          if (match5[5]) {
            rgb[3] = parseFloat(match5[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match5[4]);
          }
        }
      } else if (match5 = string2.match(per)) {
        for (i15 = 0; i15 < 3; i15++) {
          rgb[i15] = Math.round(parseFloat(match5[i15 + 1]) * 2.55);
        }
        if (match5[4]) {
          if (match5[5]) {
            rgb[3] = parseFloat(match5[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match5[4]);
          }
        }
      } else if (match5 = string2.match(keyword)) {
        if (match5[1] === "transparent") {
          return [0, 0, 0, 0];
        }
        if (!hasOwnProperty17.call(colorNames, match5[1])) {
          return null;
        }
        rgb = colorNames[match5[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i15 = 0; i15 < 3; i15++) {
        rgb[i15] = clamp3(rgb[i15], 0, 255);
      }
      rgb[3] = clamp3(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string2) {
      if (!string2) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match5 = string2.match(hsl);
      if (match5) {
        var alpha = parseFloat(match5[4]);
        var h11 = (parseFloat(match5[1]) % 360 + 360) % 360;
        var s20 = clamp3(parseFloat(match5[2]), 0, 100);
        var l14 = clamp3(parseFloat(match5[3]), 0, 100);
        var a13 = clamp3(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h11, s20, l14, a13];
      }
      return null;
    };
    cs.get.hwb = function(string2) {
      if (!string2) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match5 = string2.match(hwb);
      if (match5) {
        var alpha = parseFloat(match5[4]);
        var h11 = (parseFloat(match5[1]) % 360 + 360) % 360;
        var w7 = clamp3(parseFloat(match5[2]), 0, 100);
        var b6 = clamp3(parseFloat(match5[3]), 0, 100);
        var a13 = clamp3(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [h11, w7, b6, a13];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r15 = Math.round(rgba[0] / 255 * 100);
      var g6 = Math.round(rgba[1] / 255 * 100);
      var b6 = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r15 + "%, " + g6 + "%, " + b6 + "%)" : "rgba(" + r15 + "%, " + g6 + "%, " + b6 + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a13 = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a13 = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a13 + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp3(num, min4, max4) {
      return Math.min(Math.max(min4, num), max4);
    }
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
  }
});

// node_modules/attr-accept/dist/es/index.js
var require_es = __commonJS({
  "node_modules/attr-accept/dist/es/index.js"(exports2) {
    "use strict";
    exports2.__esModule = true;
    exports2.default = function(file, acceptedFiles) {
      if (file && acceptedFiles) {
        var acceptedFilesArray = Array.isArray(acceptedFiles) ? acceptedFiles : acceptedFiles.split(",");
        var fileName = file.name || "";
        var mimeType = (file.type || "").toLowerCase();
        var baseMimeType = mimeType.replace(/\/.*$/, "");
        return acceptedFilesArray.some(function(type) {
          var validType = type.trim().toLowerCase();
          if (validType.charAt(0) === ".") {
            return fileName.toLowerCase().endsWith(validType);
          } else if (validType.endsWith("/*")) {
            return baseMimeType === validType.replace(/\/.*$/, "");
          }
          return mimeType === validType;
        });
      }
      return true;
    };
  }
});

// browser-external:util
var require_util = __commonJS({
  "browser-external:util"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_7, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "util" has been externalized for browser compatibility. Cannot access "util.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/braces/lib/utils.js
var require_utils = __commonJS({
  "node_modules/braces/lib/utils.js"(exports2) {
    "use strict";
    exports2.isInteger = (num) => {
      if (typeof num === "number") {
        return Number.isInteger(num);
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isInteger(Number(num));
      }
      return false;
    };
    exports2.find = (node, type) => node.nodes.find((node2) => node2.type === type);
    exports2.exceedsLimit = (min4, max4, step = 1, limit) => {
      if (limit === false)
        return false;
      if (!exports2.isInteger(min4) || !exports2.isInteger(max4))
        return false;
      return (Number(max4) - Number(min4)) / Number(step) >= limit;
    };
    exports2.escapeNode = (block, n12 = 0, type) => {
      let node = block.nodes[n12];
      if (!node)
        return;
      if (type && node.type === type || node.type === "open" || node.type === "close") {
        if (node.escaped !== true) {
          node.value = "\\" + node.value;
          node.escaped = true;
        }
      }
    };
    exports2.encloseBrace = (node) => {
      if (node.type !== "brace")
        return false;
      if (node.commas >> 0 + node.ranges >> 0 === 0) {
        node.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isInvalidBrace = (block) => {
      if (block.type !== "brace")
        return false;
      if (block.invalid === true || block.dollar)
        return true;
      if (block.commas >> 0 + block.ranges >> 0 === 0) {
        block.invalid = true;
        return true;
      }
      if (block.open !== true || block.close !== true) {
        block.invalid = true;
        return true;
      }
      return false;
    };
    exports2.isOpenOrClose = (node) => {
      if (node.type === "open" || node.type === "close") {
        return true;
      }
      return node.open === true || node.close === true;
    };
    exports2.reduce = (nodes) => nodes.reduce((acc, node) => {
      if (node.type === "text")
        acc.push(node.value);
      if (node.type === "range")
        node.type = "text";
      return acc;
    }, []);
    exports2.flatten = (...args) => {
      const result = [];
      const flat = (arr) => {
        for (let i15 = 0; i15 < arr.length; i15++) {
          let ele = arr[i15];
          Array.isArray(ele) ? flat(ele, result) : ele !== void 0 && result.push(ele);
        }
        return result;
      };
      flat(args);
      return result;
    };
  }
});

// node_modules/braces/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/braces/lib/stringify.js"(exports2, module2) {
    "use strict";
    var utils = require_utils();
    module2.exports = (ast, options = {}) => {
      let stringify = (node, parent2 = {}) => {
        let invalidBlock = options.escapeInvalid && utils.isInvalidBrace(parent2);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let output = "";
        if (node.value) {
          if ((invalidBlock || invalidNode) && utils.isOpenOrClose(node)) {
            return "\\" + node.value;
          }
          return node.value;
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += stringify(child);
          }
        }
        return output;
      };
      return stringify(ast);
    };
  }
});

// node_modules/to-regex-range/node_modules/is-number/index.js
var require_is_number = __commonJS({
  "node_modules/to-regex-range/node_modules/is-number/index.js"(exports2, module2) {
    "use strict";
    module2.exports = function(num) {
      if (typeof num === "number") {
        return num - num === 0;
      }
      if (typeof num === "string" && num.trim() !== "") {
        return Number.isFinite ? Number.isFinite(+num) : isFinite(+num);
      }
      return false;
    };
  }
});

// node_modules/to-regex-range/index.js
var require_to_regex_range = __commonJS({
  "node_modules/to-regex-range/index.js"(exports2, module2) {
    "use strict";
    var isNumber2 = require_is_number();
    var toRegexRange = (min4, max4, options) => {
      if (isNumber2(min4) === false) {
        throw new TypeError("toRegexRange: expected the first argument to be a number");
      }
      if (max4 === void 0 || min4 === max4) {
        return String(min4);
      }
      if (isNumber2(max4) === false) {
        throw new TypeError("toRegexRange: expected the second argument to be a number.");
      }
      let opts = { relaxZeros: true, ...options };
      if (typeof opts.strictZeros === "boolean") {
        opts.relaxZeros = opts.strictZeros === false;
      }
      let relax = String(opts.relaxZeros);
      let shorthand = String(opts.shorthand);
      let capture = String(opts.capture);
      let wrap = String(opts.wrap);
      let cacheKey = min4 + ":" + max4 + "=" + relax + shorthand + capture + wrap;
      if (toRegexRange.cache.hasOwnProperty(cacheKey)) {
        return toRegexRange.cache[cacheKey].result;
      }
      let a13 = Math.min(min4, max4);
      let b6 = Math.max(min4, max4);
      if (Math.abs(a13 - b6) === 1) {
        let result = min4 + "|" + max4;
        if (opts.capture) {
          return `(${result})`;
        }
        if (opts.wrap === false) {
          return result;
        }
        return `(?:${result})`;
      }
      let isPadded = hasPadding(min4) || hasPadding(max4);
      let state = { min: min4, max: max4, a: a13, b: b6 };
      let positives = [];
      let negatives = [];
      if (isPadded) {
        state.isPadded = isPadded;
        state.maxLen = String(state.max).length;
      }
      if (a13 < 0) {
        let newMin = b6 < 0 ? Math.abs(b6) : 1;
        negatives = splitToPatterns(newMin, Math.abs(a13), state, opts);
        a13 = state.a = 0;
      }
      if (b6 >= 0) {
        positives = splitToPatterns(a13, b6, state, opts);
      }
      state.negatives = negatives;
      state.positives = positives;
      state.result = collatePatterns(negatives, positives, opts);
      if (opts.capture === true) {
        state.result = `(${state.result})`;
      } else if (opts.wrap !== false && positives.length + negatives.length > 1) {
        state.result = `(?:${state.result})`;
      }
      toRegexRange.cache[cacheKey] = state;
      return state.result;
    };
    function collatePatterns(neg, pos, options) {
      let onlyNegative = filterPatterns(neg, pos, "-", false, options) || [];
      let onlyPositive = filterPatterns(pos, neg, "", false, options) || [];
      let intersected = filterPatterns(neg, pos, "-?", true, options) || [];
      let subpatterns = onlyNegative.concat(intersected).concat(onlyPositive);
      return subpatterns.join("|");
    }
    function splitToRanges(min4, max4) {
      let nines = 1;
      let zeros = 1;
      let stop = countNines(min4, nines);
      let stops = /* @__PURE__ */ new Set([max4]);
      while (min4 <= stop && stop <= max4) {
        stops.add(stop);
        nines += 1;
        stop = countNines(min4, nines);
      }
      stop = countZeros(max4 + 1, zeros) - 1;
      while (min4 < stop && stop <= max4) {
        stops.add(stop);
        zeros += 1;
        stop = countZeros(max4 + 1, zeros) - 1;
      }
      stops = [...stops];
      stops.sort(compare);
      return stops;
    }
    function rangeToPattern(start3, stop, options) {
      if (start3 === stop) {
        return { pattern: start3, count: [], digits: 0 };
      }
      let zipped = zip(start3, stop);
      let digits = zipped.length;
      let pattern = "";
      let count2 = 0;
      for (let i15 = 0; i15 < digits; i15++) {
        let [startDigit, stopDigit] = zipped[i15];
        if (startDigit === stopDigit) {
          pattern += startDigit;
        } else if (startDigit !== "0" || stopDigit !== "9") {
          pattern += toCharacterClass(startDigit, stopDigit, options);
        } else {
          count2++;
        }
      }
      if (count2) {
        pattern += options.shorthand === true ? "\\d" : "[0-9]";
      }
      return { pattern, count: [count2], digits };
    }
    function splitToPatterns(min4, max4, tok, options) {
      let ranges = splitToRanges(min4, max4);
      let tokens2 = [];
      let start3 = min4;
      let prev;
      for (let i15 = 0; i15 < ranges.length; i15++) {
        let max5 = ranges[i15];
        let obj = rangeToPattern(String(start3), String(max5), options);
        let zeros = "";
        if (!tok.isPadded && prev && prev.pattern === obj.pattern) {
          if (prev.count.length > 1) {
            prev.count.pop();
          }
          prev.count.push(obj.count[0]);
          prev.string = prev.pattern + toQuantifier(prev.count);
          start3 = max5 + 1;
          continue;
        }
        if (tok.isPadded) {
          zeros = padZeros(max5, tok, options);
        }
        obj.string = zeros + obj.pattern + toQuantifier(obj.count);
        tokens2.push(obj);
        start3 = max5 + 1;
        prev = obj;
      }
      return tokens2;
    }
    function filterPatterns(arr, comparison, prefix3, intersection, options) {
      let result = [];
      for (let ele of arr) {
        let { string: string2 } = ele;
        if (!intersection && !contains2(comparison, "string", string2)) {
          result.push(prefix3 + string2);
        }
        if (intersection && contains2(comparison, "string", string2)) {
          result.push(prefix3 + string2);
        }
      }
      return result;
    }
    function zip(a13, b6) {
      let arr = [];
      for (let i15 = 0; i15 < a13.length; i15++)
        arr.push([a13[i15], b6[i15]]);
      return arr;
    }
    function compare(a13, b6) {
      return a13 > b6 ? 1 : b6 > a13 ? -1 : 0;
    }
    function contains2(arr, key, val) {
      return arr.some((ele) => ele[key] === val);
    }
    function countNines(min4, len) {
      return Number(String(min4).slice(0, -len) + "9".repeat(len));
    }
    function countZeros(integer, zeros) {
      return integer - integer % Math.pow(10, zeros);
    }
    function toQuantifier(digits) {
      let [start3 = 0, stop = ""] = digits;
      if (stop || start3 > 1) {
        return `{${start3 + (stop ? "," + stop : "")}}`;
      }
      return "";
    }
    function toCharacterClass(a13, b6, options) {
      return `[${a13}${b6 - a13 === 1 ? "" : "-"}${b6}]`;
    }
    function hasPadding(str) {
      return /^-?(0+)\d/.test(str);
    }
    function padZeros(value, tok, options) {
      if (!tok.isPadded) {
        return value;
      }
      let diff3 = Math.abs(tok.maxLen - String(value).length);
      let relax = options.relaxZeros !== false;
      switch (diff3) {
        case 0:
          return "";
        case 1:
          return relax ? "0?" : "0";
        case 2:
          return relax ? "0{0,2}" : "00";
        default: {
          return relax ? `0{0,${diff3}}` : `0{${diff3}}`;
        }
      }
    }
    toRegexRange.cache = {};
    toRegexRange.clearCache = () => toRegexRange.cache = {};
    module2.exports = toRegexRange;
  }
});

// node_modules/fill-range/index.js
var require_fill_range = __commonJS({
  "node_modules/fill-range/index.js"(exports2, module2) {
    "use strict";
    var util2 = require_util();
    var toRegexRange = require_to_regex_range();
    var isObject10 = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    var transform = (toNumber2) => {
      return (value) => toNumber2 === true ? Number(value) : String(value);
    };
    var isValidValue = (value) => {
      return typeof value === "number" || typeof value === "string" && value !== "";
    };
    var isNumber2 = (num) => Number.isInteger(+num);
    var zeros = (input) => {
      let value = `${input}`;
      let index2 = -1;
      if (value[0] === "-")
        value = value.slice(1);
      if (value === "0")
        return false;
      while (value[++index2] === "0")
        ;
      return index2 > 0;
    };
    var stringify = (start3, end2, options) => {
      if (typeof start3 === "string" || typeof end2 === "string") {
        return true;
      }
      return options.stringify === true;
    };
    var pad3 = (input, maxLength, toNumber2) => {
      if (maxLength > 0) {
        let dash = input[0] === "-" ? "-" : "";
        if (dash)
          input = input.slice(1);
        input = dash + input.padStart(dash ? maxLength - 1 : maxLength, "0");
      }
      if (toNumber2 === false) {
        return String(input);
      }
      return input;
    };
    var toMaxLen = (input, maxLength) => {
      let negative = input[0] === "-" ? "-" : "";
      if (negative) {
        input = input.slice(1);
        maxLength--;
      }
      while (input.length < maxLength)
        input = "0" + input;
      return negative ? "-" + input : input;
    };
    var toSequence = (parts, options) => {
      parts.negatives.sort((a13, b6) => a13 < b6 ? -1 : a13 > b6 ? 1 : 0);
      parts.positives.sort((a13, b6) => a13 < b6 ? -1 : a13 > b6 ? 1 : 0);
      let prefix3 = options.capture ? "" : "?:";
      let positives = "";
      let negatives = "";
      let result;
      if (parts.positives.length) {
        positives = parts.positives.join("|");
      }
      if (parts.negatives.length) {
        negatives = `-(${prefix3}${parts.negatives.join("|")})`;
      }
      if (positives && negatives) {
        result = `${positives}|${negatives}`;
      } else {
        result = positives || negatives;
      }
      if (options.wrap) {
        return `(${prefix3}${result})`;
      }
      return result;
    };
    var toRange = (a13, b6, isNumbers, options) => {
      if (isNumbers) {
        return toRegexRange(a13, b6, { wrap: false, ...options });
      }
      let start3 = String.fromCharCode(a13);
      if (a13 === b6)
        return start3;
      let stop = String.fromCharCode(b6);
      return `[${start3}-${stop}]`;
    };
    var toRegex = (start3, end2, options) => {
      if (Array.isArray(start3)) {
        let wrap = options.wrap === true;
        let prefix3 = options.capture ? "" : "?:";
        return wrap ? `(${prefix3}${start3.join("|")})` : start3.join("|");
      }
      return toRegexRange(start3, end2, options);
    };
    var rangeError = (...args) => {
      return new RangeError("Invalid range arguments: " + util2.inspect(...args));
    };
    var invalidRange = (start3, end2, options) => {
      if (options.strictRanges === true)
        throw rangeError([start3, end2]);
      return [];
    };
    var invalidStep = (step, options) => {
      if (options.strictRanges === true) {
        throw new TypeError(`Expected step "${step}" to be a number`);
      }
      return [];
    };
    var fillNumbers = (start3, end2, step = 1, options = {}) => {
      let a13 = Number(start3);
      let b6 = Number(end2);
      if (!Number.isInteger(a13) || !Number.isInteger(b6)) {
        if (options.strictRanges === true)
          throw rangeError([start3, end2]);
        return [];
      }
      if (a13 === 0)
        a13 = 0;
      if (b6 === 0)
        b6 = 0;
      let descending = a13 > b6;
      let startString = String(start3);
      let endString = String(end2);
      let stepString = String(step);
      step = Math.max(Math.abs(step), 1);
      let padded = zeros(startString) || zeros(endString) || zeros(stepString);
      let maxLen = padded ? Math.max(startString.length, endString.length, stepString.length) : 0;
      let toNumber2 = padded === false && stringify(start3, end2, options) === false;
      let format3 = options.transform || transform(toNumber2);
      if (options.toRegex && step === 1) {
        return toRange(toMaxLen(start3, maxLen), toMaxLen(end2, maxLen), true, options);
      }
      let parts = { negatives: [], positives: [] };
      let push3 = (num) => parts[num < 0 ? "negatives" : "positives"].push(Math.abs(num));
      let range = [];
      let index2 = 0;
      while (descending ? a13 >= b6 : a13 <= b6) {
        if (options.toRegex === true && step > 1) {
          push3(a13);
        } else {
          range.push(pad3(format3(a13, index2), maxLen, toNumber2));
        }
        a13 = descending ? a13 - step : a13 + step;
        index2++;
      }
      if (options.toRegex === true) {
        return step > 1 ? toSequence(parts, options) : toRegex(range, null, { wrap: false, ...options });
      }
      return range;
    };
    var fillLetters = (start3, end2, step = 1, options = {}) => {
      if (!isNumber2(start3) && start3.length > 1 || !isNumber2(end2) && end2.length > 1) {
        return invalidRange(start3, end2, options);
      }
      let format3 = options.transform || ((val) => String.fromCharCode(val));
      let a13 = `${start3}`.charCodeAt(0);
      let b6 = `${end2}`.charCodeAt(0);
      let descending = a13 > b6;
      let min4 = Math.min(a13, b6);
      let max4 = Math.max(a13, b6);
      if (options.toRegex && step === 1) {
        return toRange(min4, max4, false, options);
      }
      let range = [];
      let index2 = 0;
      while (descending ? a13 >= b6 : a13 <= b6) {
        range.push(format3(a13, index2));
        a13 = descending ? a13 - step : a13 + step;
        index2++;
      }
      if (options.toRegex === true) {
        return toRegex(range, null, { wrap: false, options });
      }
      return range;
    };
    var fill = (start3, end2, step, options = {}) => {
      if (end2 == null && isValidValue(start3)) {
        return [start3];
      }
      if (!isValidValue(start3) || !isValidValue(end2)) {
        return invalidRange(start3, end2, options);
      }
      if (typeof step === "function") {
        return fill(start3, end2, 1, { transform: step });
      }
      if (isObject10(step)) {
        return fill(start3, end2, 0, step);
      }
      let opts = { ...options };
      if (opts.capture === true)
        opts.wrap = true;
      step = step || opts.step || 1;
      if (!isNumber2(step)) {
        if (step != null && !isObject10(step))
          return invalidStep(step, opts);
        return fill(start3, end2, 1, step);
      }
      if (isNumber2(start3) && isNumber2(end2)) {
        return fillNumbers(start3, end2, step, opts);
      }
      return fillLetters(start3, end2, Math.max(Math.abs(step), 1), opts);
    };
    module2.exports = fill;
  }
});

// node_modules/braces/lib/compile.js
var require_compile = __commonJS({
  "node_modules/braces/lib/compile.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var utils = require_utils();
    var compile = (ast, options = {}) => {
      let walk = (node, parent2 = {}) => {
        let invalidBlock = utils.isInvalidBrace(parent2);
        let invalidNode = node.invalid === true && options.escapeInvalid === true;
        let invalid = invalidBlock === true || invalidNode === true;
        let prefix3 = options.escapeInvalid === true ? "\\" : "";
        let output = "";
        if (node.isOpen === true) {
          return prefix3 + node.value;
        }
        if (node.isClose === true) {
          return prefix3 + node.value;
        }
        if (node.type === "open") {
          return invalid ? prefix3 + node.value : "(";
        }
        if (node.type === "close") {
          return invalid ? prefix3 + node.value : ")";
        }
        if (node.type === "comma") {
          return node.prev.type === "comma" ? "" : invalid ? node.value : "|";
        }
        if (node.value) {
          return node.value;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          let range = fill(...args, { ...options, wrap: false, toRegex: true });
          if (range.length !== 0) {
            return args.length > 1 && range.length > 1 ? `(${range})` : range;
          }
        }
        if (node.nodes) {
          for (let child of node.nodes) {
            output += walk(child, node);
          }
        }
        return output;
      };
      return walk(ast);
    };
    module2.exports = compile;
  }
});

// node_modules/braces/lib/expand.js
var require_expand = __commonJS({
  "node_modules/braces/lib/expand.js"(exports2, module2) {
    "use strict";
    var fill = require_fill_range();
    var stringify = require_stringify();
    var utils = require_utils();
    var append = (queue = "", stash = "", enclose = false) => {
      let result = [];
      queue = [].concat(queue);
      stash = [].concat(stash);
      if (!stash.length)
        return queue;
      if (!queue.length) {
        return enclose ? utils.flatten(stash).map((ele) => `{${ele}}`) : stash;
      }
      for (let item of queue) {
        if (Array.isArray(item)) {
          for (let value of item) {
            result.push(append(value, stash, enclose));
          }
        } else {
          for (let ele of stash) {
            if (enclose === true && typeof ele === "string")
              ele = `{${ele}}`;
            result.push(Array.isArray(ele) ? append(item, ele, enclose) : item + ele);
          }
        }
      }
      return utils.flatten(result);
    };
    var expand3 = (ast, options = {}) => {
      let rangeLimit = options.rangeLimit === void 0 ? 1e3 : options.rangeLimit;
      let walk = (node, parent2 = {}) => {
        node.queue = [];
        let p12 = parent2;
        let q7 = parent2.queue;
        while (p12.type !== "brace" && p12.type !== "root" && p12.parent) {
          p12 = p12.parent;
          q7 = p12.queue;
        }
        if (node.invalid || node.dollar) {
          q7.push(append(q7.pop(), stringify(node, options)));
          return;
        }
        if (node.type === "brace" && node.invalid !== true && node.nodes.length === 2) {
          q7.push(append(q7.pop(), ["{}"]));
          return;
        }
        if (node.nodes && node.ranges > 0) {
          let args = utils.reduce(node.nodes);
          if (utils.exceedsLimit(...args, options.step, rangeLimit)) {
            throw new RangeError("expanded array length exceeds range limit. Use options.rangeLimit to increase or disable the limit.");
          }
          let range = fill(...args, options);
          if (range.length === 0) {
            range = stringify(node, options);
          }
          q7.push(append(q7.pop(), range));
          node.nodes = [];
          return;
        }
        let enclose = utils.encloseBrace(node);
        let queue = node.queue;
        let block = node;
        while (block.type !== "brace" && block.type !== "root" && block.parent) {
          block = block.parent;
          queue = block.queue;
        }
        for (let i15 = 0; i15 < node.nodes.length; i15++) {
          let child = node.nodes[i15];
          if (child.type === "comma" && node.type === "brace") {
            if (i15 === 1)
              queue.push("");
            queue.push("");
            continue;
          }
          if (child.type === "close") {
            q7.push(append(q7.pop(), queue, enclose));
            continue;
          }
          if (child.value && child.type !== "open") {
            queue.push(append(queue.pop(), child.value));
            continue;
          }
          if (child.nodes) {
            walk(child, node);
          }
        }
        return queue;
      };
      return utils.flatten(walk(ast));
    };
    module2.exports = expand3;
  }
});

// node_modules/braces/lib/constants.js
var require_constants = __commonJS({
  "node_modules/braces/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      // Digits
      CHAR_0: "0",
      /* 0 */
      CHAR_9: "9",
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: "A",
      /* A */
      CHAR_LOWERCASE_A: "a",
      /* a */
      CHAR_UPPERCASE_Z: "Z",
      /* Z */
      CHAR_LOWERCASE_Z: "z",
      /* z */
      CHAR_LEFT_PARENTHESES: "(",
      /* ( */
      CHAR_RIGHT_PARENTHESES: ")",
      /* ) */
      CHAR_ASTERISK: "*",
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: "&",
      /* & */
      CHAR_AT: "@",
      /* @ */
      CHAR_BACKSLASH: "\\",
      /* \ */
      CHAR_BACKTICK: "`",
      /* ` */
      CHAR_CARRIAGE_RETURN: "\r",
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: "^",
      /* ^ */
      CHAR_COLON: ":",
      /* : */
      CHAR_COMMA: ",",
      /* , */
      CHAR_DOLLAR: "$",
      /* . */
      CHAR_DOT: ".",
      /* . */
      CHAR_DOUBLE_QUOTE: '"',
      /* " */
      CHAR_EQUAL: "=",
      /* = */
      CHAR_EXCLAMATION_MARK: "!",
      /* ! */
      CHAR_FORM_FEED: "\f",
      /* \f */
      CHAR_FORWARD_SLASH: "/",
      /* / */
      CHAR_HASH: "#",
      /* # */
      CHAR_HYPHEN_MINUS: "-",
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: "<",
      /* < */
      CHAR_LEFT_CURLY_BRACE: "{",
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: "[",
      /* [ */
      CHAR_LINE_FEED: "\n",
      /* \n */
      CHAR_NO_BREAK_SPACE: " ",
      /* \u00A0 */
      CHAR_PERCENT: "%",
      /* % */
      CHAR_PLUS: "+",
      /* + */
      CHAR_QUESTION_MARK: "?",
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: ">",
      /* > */
      CHAR_RIGHT_CURLY_BRACE: "}",
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: "]",
      /* ] */
      CHAR_SEMICOLON: ";",
      /* ; */
      CHAR_SINGLE_QUOTE: "'",
      /* ' */
      CHAR_SPACE: " ",
      /*   */
      CHAR_TAB: "	",
      /* \t */
      CHAR_UNDERSCORE: "_",
      /* _ */
      CHAR_VERTICAL_LINE: "|",
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF"
      /* \uFEFF */
    };
  }
});

// node_modules/braces/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/braces/lib/parse.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify();
    var {
      MAX_LENGTH,
      CHAR_BACKSLASH,
      /* \ */
      CHAR_BACKTICK,
      /* ` */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_RIGHT_SQUARE_BRACKET,
      /* ] */
      CHAR_DOUBLE_QUOTE,
      /* " */
      CHAR_SINGLE_QUOTE,
      /* ' */
      CHAR_NO_BREAK_SPACE,
      CHAR_ZERO_WIDTH_NOBREAK_SPACE
    } = require_constants();
    var parse6 = (input, options = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      let opts = options || {};
      let max4 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      if (input.length > max4) {
        throw new SyntaxError(`Input length (${input.length}), exceeds max characters (${max4})`);
      }
      let ast = { type: "root", input, nodes: [] };
      let stack = [ast];
      let block = ast;
      let prev = ast;
      let brackets = 0;
      let length = input.length;
      let index2 = 0;
      let depth = 0;
      let value;
      let memo2 = {};
      const advance = () => input[index2++];
      const push3 = (node) => {
        if (node.type === "text" && prev.type === "dot") {
          prev.type = "text";
        }
        if (prev && prev.type === "text" && node.type === "text") {
          prev.value += node.value;
          return;
        }
        block.nodes.push(node);
        node.parent = block;
        node.prev = prev;
        prev = node;
        return node;
      };
      push3({ type: "bos" });
      while (index2 < length) {
        block = stack[stack.length - 1];
        value = advance();
        if (value === CHAR_ZERO_WIDTH_NOBREAK_SPACE || value === CHAR_NO_BREAK_SPACE) {
          continue;
        }
        if (value === CHAR_BACKSLASH) {
          push3({ type: "text", value: (options.keepEscaping ? value : "") + advance() });
          continue;
        }
        if (value === CHAR_RIGHT_SQUARE_BRACKET) {
          push3({ type: "text", value: "\\" + value });
          continue;
        }
        if (value === CHAR_LEFT_SQUARE_BRACKET) {
          brackets++;
          let closed = true;
          let next;
          while (index2 < length && (next = advance())) {
            value += next;
            if (next === CHAR_LEFT_SQUARE_BRACKET) {
              brackets++;
              continue;
            }
            if (next === CHAR_BACKSLASH) {
              value += advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              brackets--;
              if (brackets === 0) {
                break;
              }
            }
          }
          push3({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_PARENTHESES) {
          block = push3({ type: "paren", nodes: [] });
          stack.push(block);
          push3({ type: "text", value });
          continue;
        }
        if (value === CHAR_RIGHT_PARENTHESES) {
          if (block.type !== "paren") {
            push3({ type: "text", value });
            continue;
          }
          block = stack.pop();
          push3({ type: "text", value });
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_DOUBLE_QUOTE || value === CHAR_SINGLE_QUOTE || value === CHAR_BACKTICK) {
          let open = value;
          let next;
          if (options.keepQuotes !== true) {
            value = "";
          }
          while (index2 < length && (next = advance())) {
            if (next === CHAR_BACKSLASH) {
              value += next + advance();
              continue;
            }
            if (next === open) {
              if (options.keepQuotes === true)
                value += next;
              break;
            }
            value += next;
          }
          push3({ type: "text", value });
          continue;
        }
        if (value === CHAR_LEFT_CURLY_BRACE) {
          depth++;
          let dollar = prev.value && prev.value.slice(-1) === "$" || block.dollar === true;
          let brace = {
            type: "brace",
            open: true,
            close: false,
            dollar,
            depth,
            commas: 0,
            ranges: 0,
            nodes: []
          };
          block = push3(brace);
          stack.push(block);
          push3({ type: "open", value });
          continue;
        }
        if (value === CHAR_RIGHT_CURLY_BRACE) {
          if (block.type !== "brace") {
            push3({ type: "text", value });
            continue;
          }
          let type = "close";
          block = stack.pop();
          block.close = true;
          push3({ type, value });
          depth--;
          block = stack[stack.length - 1];
          continue;
        }
        if (value === CHAR_COMMA && depth > 0) {
          if (block.ranges > 0) {
            block.ranges = 0;
            let open = block.nodes.shift();
            block.nodes = [open, { type: "text", value: stringify(block) }];
          }
          push3({ type: "comma", value });
          block.commas++;
          continue;
        }
        if (value === CHAR_DOT && depth > 0 && block.commas === 0) {
          let siblings = block.nodes;
          if (depth === 0 || siblings.length === 0) {
            push3({ type: "text", value });
            continue;
          }
          if (prev.type === "dot") {
            block.range = [];
            prev.value += value;
            prev.type = "range";
            if (block.nodes.length !== 3 && block.nodes.length !== 5) {
              block.invalid = true;
              block.ranges = 0;
              prev.type = "text";
              continue;
            }
            block.ranges++;
            block.args = [];
            continue;
          }
          if (prev.type === "range") {
            siblings.pop();
            let before = siblings[siblings.length - 1];
            before.value += prev.value + value;
            prev = before;
            block.ranges--;
            continue;
          }
          push3({ type: "dot", value });
          continue;
        }
        push3({ type: "text", value });
      }
      do {
        block = stack.pop();
        if (block.type !== "root") {
          block.nodes.forEach((node) => {
            if (!node.nodes) {
              if (node.type === "open")
                node.isOpen = true;
              if (node.type === "close")
                node.isClose = true;
              if (!node.nodes)
                node.type = "text";
              node.invalid = true;
            }
          });
          let parent2 = stack[stack.length - 1];
          let index3 = parent2.nodes.indexOf(block);
          parent2.nodes.splice(index3, 1, ...block.nodes);
        }
      } while (stack.length > 0);
      push3({ type: "eos" });
      return ast;
    };
    module2.exports = parse6;
  }
});

// node_modules/braces/index.js
var require_braces = __commonJS({
  "node_modules/braces/index.js"(exports2, module2) {
    "use strict";
    var stringify = require_stringify();
    var compile = require_compile();
    var expand3 = require_expand();
    var parse6 = require_parse2();
    var braces = (input, options = {}) => {
      let output = [];
      if (Array.isArray(input)) {
        for (let pattern of input) {
          let result = braces.create(pattern, options);
          if (Array.isArray(result)) {
            output.push(...result);
          } else {
            output.push(result);
          }
        }
      } else {
        output = [].concat(braces.create(input, options));
      }
      if (options && options.expand === true && options.nodupes === true) {
        output = [...new Set(output)];
      }
      return output;
    };
    braces.parse = (input, options = {}) => parse6(input, options);
    braces.stringify = (input, options = {}) => {
      if (typeof input === "string") {
        return stringify(braces.parse(input, options), options);
      }
      return stringify(input, options);
    };
    braces.compile = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      return compile(input, options);
    };
    braces.expand = (input, options = {}) => {
      if (typeof input === "string") {
        input = braces.parse(input, options);
      }
      let result = expand3(input, options);
      if (options.noempty === true) {
        result = result.filter(Boolean);
      }
      if (options.nodupes === true) {
        result = [...new Set(result)];
      }
      return result;
    };
    braces.create = (input, options = {}) => {
      if (input === "" || input.length < 3) {
        return [input];
      }
      return options.expand !== true ? braces.compile(input, options) : braces.expand(input, options);
    };
    module2.exports = braces;
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports2, module2) {
    module2.exports = Object.create(new Proxy({}, {
      get(_7, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/picomatch/lib/constants.js
var require_constants2 = __commonJS({
  "node_modules/picomatch/lib/constants.js"(exports2, module2) {
    "use strict";
    var path = require_path();
    var WIN_SLASH = "\\\\/";
    var WIN_NO_SLASH = `[^${WIN_SLASH}]`;
    var DOT_LITERAL = "\\.";
    var PLUS_LITERAL = "\\+";
    var QMARK_LITERAL = "\\?";
    var SLASH_LITERAL = "\\/";
    var ONE_CHAR = "(?=.)";
    var QMARK = "[^/]";
    var END_ANCHOR = `(?:${SLASH_LITERAL}|$)`;
    var START_ANCHOR = `(?:^|${SLASH_LITERAL})`;
    var DOTS_SLASH = `${DOT_LITERAL}{1,2}${END_ANCHOR}`;
    var NO_DOT = `(?!${DOT_LITERAL})`;
    var NO_DOTS = `(?!${START_ANCHOR}${DOTS_SLASH})`;
    var NO_DOT_SLASH = `(?!${DOT_LITERAL}{0,1}${END_ANCHOR})`;
    var NO_DOTS_SLASH = `(?!${DOTS_SLASH})`;
    var QMARK_NO_DOT = `[^.${SLASH_LITERAL}]`;
    var STAR = `${QMARK}*?`;
    var POSIX_CHARS = {
      DOT_LITERAL,
      PLUS_LITERAL,
      QMARK_LITERAL,
      SLASH_LITERAL,
      ONE_CHAR,
      QMARK,
      END_ANCHOR,
      DOTS_SLASH,
      NO_DOT,
      NO_DOTS,
      NO_DOT_SLASH,
      NO_DOTS_SLASH,
      QMARK_NO_DOT,
      STAR,
      START_ANCHOR
    };
    var WINDOWS_CHARS = {
      ...POSIX_CHARS,
      SLASH_LITERAL: `[${WIN_SLASH}]`,
      QMARK: WIN_NO_SLASH,
      STAR: `${WIN_NO_SLASH}*?`,
      DOTS_SLASH: `${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$)`,
      NO_DOT: `(?!${DOT_LITERAL})`,
      NO_DOTS: `(?!(?:^|[${WIN_SLASH}])${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      NO_DOT_SLASH: `(?!${DOT_LITERAL}{0,1}(?:[${WIN_SLASH}]|$))`,
      NO_DOTS_SLASH: `(?!${DOT_LITERAL}{1,2}(?:[${WIN_SLASH}]|$))`,
      QMARK_NO_DOT: `[^.${WIN_SLASH}]`,
      START_ANCHOR: `(?:^|[${WIN_SLASH}])`,
      END_ANCHOR: `(?:[${WIN_SLASH}]|$)`
    };
    var POSIX_REGEX_SOURCE = {
      alnum: "a-zA-Z0-9",
      alpha: "a-zA-Z",
      ascii: "\\x00-\\x7F",
      blank: " \\t",
      cntrl: "\\x00-\\x1F\\x7F",
      digit: "0-9",
      graph: "\\x21-\\x7E",
      lower: "a-z",
      print: "\\x20-\\x7E ",
      punct: "\\-!\"#$%&'()\\*+,./:;<=>?@[\\]^_`{|}~",
      space: " \\t\\r\\n\\v\\f",
      upper: "A-Z",
      word: "A-Za-z0-9_",
      xdigit: "A-Fa-f0-9"
    };
    module2.exports = {
      MAX_LENGTH: 1024 * 64,
      POSIX_REGEX_SOURCE,
      // regular expressions
      REGEX_BACKSLASH: /\\(?![*+?^${}(|)[\]])/g,
      REGEX_NON_SPECIAL_CHARS: /^[^@![\].,$*+?^{}()|\\/]+/,
      REGEX_SPECIAL_CHARS: /[-*+?.^${}(|)[\]]/,
      REGEX_SPECIAL_CHARS_BACKREF: /(\\?)((\W)(\3*))/g,
      REGEX_SPECIAL_CHARS_GLOBAL: /([-*+?.^${}(|)[\]])/g,
      REGEX_REMOVE_BACKSLASH: /(?:\[.*?[^\\]\]|\\(?=.))/g,
      // Replace globs with equivalent patterns to reduce parsing time.
      REPLACEMENTS: {
        "***": "*",
        "**/**": "**",
        "**/**/**": "**"
      },
      // Digits
      CHAR_0: 48,
      /* 0 */
      CHAR_9: 57,
      /* 9 */
      // Alphabet chars.
      CHAR_UPPERCASE_A: 65,
      /* A */
      CHAR_LOWERCASE_A: 97,
      /* a */
      CHAR_UPPERCASE_Z: 90,
      /* Z */
      CHAR_LOWERCASE_Z: 122,
      /* z */
      CHAR_LEFT_PARENTHESES: 40,
      /* ( */
      CHAR_RIGHT_PARENTHESES: 41,
      /* ) */
      CHAR_ASTERISK: 42,
      /* * */
      // Non-alphabetic chars.
      CHAR_AMPERSAND: 38,
      /* & */
      CHAR_AT: 64,
      /* @ */
      CHAR_BACKWARD_SLASH: 92,
      /* \ */
      CHAR_CARRIAGE_RETURN: 13,
      /* \r */
      CHAR_CIRCUMFLEX_ACCENT: 94,
      /* ^ */
      CHAR_COLON: 58,
      /* : */
      CHAR_COMMA: 44,
      /* , */
      CHAR_DOT: 46,
      /* . */
      CHAR_DOUBLE_QUOTE: 34,
      /* " */
      CHAR_EQUAL: 61,
      /* = */
      CHAR_EXCLAMATION_MARK: 33,
      /* ! */
      CHAR_FORM_FEED: 12,
      /* \f */
      CHAR_FORWARD_SLASH: 47,
      /* / */
      CHAR_GRAVE_ACCENT: 96,
      /* ` */
      CHAR_HASH: 35,
      /* # */
      CHAR_HYPHEN_MINUS: 45,
      /* - */
      CHAR_LEFT_ANGLE_BRACKET: 60,
      /* < */
      CHAR_LEFT_CURLY_BRACE: 123,
      /* { */
      CHAR_LEFT_SQUARE_BRACKET: 91,
      /* [ */
      CHAR_LINE_FEED: 10,
      /* \n */
      CHAR_NO_BREAK_SPACE: 160,
      /* \u00A0 */
      CHAR_PERCENT: 37,
      /* % */
      CHAR_PLUS: 43,
      /* + */
      CHAR_QUESTION_MARK: 63,
      /* ? */
      CHAR_RIGHT_ANGLE_BRACKET: 62,
      /* > */
      CHAR_RIGHT_CURLY_BRACE: 125,
      /* } */
      CHAR_RIGHT_SQUARE_BRACKET: 93,
      /* ] */
      CHAR_SEMICOLON: 59,
      /* ; */
      CHAR_SINGLE_QUOTE: 39,
      /* ' */
      CHAR_SPACE: 32,
      /*   */
      CHAR_TAB: 9,
      /* \t */
      CHAR_UNDERSCORE: 95,
      /* _ */
      CHAR_VERTICAL_LINE: 124,
      /* | */
      CHAR_ZERO_WIDTH_NOBREAK_SPACE: 65279,
      /* \uFEFF */
      SEP: path.sep,
      /**
       * Create EXTGLOB_CHARS
       */
      extglobChars(chars) {
        return {
          "!": { type: "negate", open: "(?:(?!(?:", close: `))${chars.STAR})` },
          "?": { type: "qmark", open: "(?:", close: ")?" },
          "+": { type: "plus", open: "(?:", close: ")+" },
          "*": { type: "star", open: "(?:", close: ")*" },
          "@": { type: "at", open: "(?:", close: ")" }
        };
      },
      /**
       * Create GLOB_CHARS
       */
      globChars(win32) {
        return win32 === true ? WINDOWS_CHARS : POSIX_CHARS;
      }
    };
  }
});

// node_modules/picomatch/lib/utils.js
var require_utils2 = __commonJS({
  "node_modules/picomatch/lib/utils.js"(exports2) {
    "use strict";
    var path = require_path();
    var win32 = process.platform === "win32";
    var {
      REGEX_BACKSLASH,
      REGEX_REMOVE_BACKSLASH,
      REGEX_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_GLOBAL
    } = require_constants2();
    exports2.isObject = (val) => val !== null && typeof val === "object" && !Array.isArray(val);
    exports2.hasRegexChars = (str) => REGEX_SPECIAL_CHARS.test(str);
    exports2.isRegexChar = (str) => str.length === 1 && exports2.hasRegexChars(str);
    exports2.escapeRegex = (str) => str.replace(REGEX_SPECIAL_CHARS_GLOBAL, "\\$1");
    exports2.toPosixSlashes = (str) => str.replace(REGEX_BACKSLASH, "/");
    exports2.removeBackslashes = (str) => {
      return str.replace(REGEX_REMOVE_BACKSLASH, (match5) => {
        return match5 === "\\" ? "" : match5;
      });
    };
    exports2.supportsLookbehinds = () => {
      const segs = process.version.slice(1).split(".").map(Number);
      if (segs.length === 3 && segs[0] >= 9 || segs[0] === 8 && segs[1] >= 10) {
        return true;
      }
      return false;
    };
    exports2.isWindows = (options) => {
      if (options && typeof options.windows === "boolean") {
        return options.windows;
      }
      return win32 === true || path.sep === "\\";
    };
    exports2.escapeLast = (input, char, lastIdx) => {
      const idx = input.lastIndexOf(char, lastIdx);
      if (idx === -1)
        return input;
      if (input[idx - 1] === "\\")
        return exports2.escapeLast(input, char, idx - 1);
      return `${input.slice(0, idx)}\\${input.slice(idx)}`;
    };
    exports2.removePrefix = (input, state = {}) => {
      let output = input;
      if (output.startsWith("./")) {
        output = output.slice(2);
        state.prefix = "./";
      }
      return output;
    };
    exports2.wrapOutput = (input, state = {}, options = {}) => {
      const prepend = options.contains ? "" : "^";
      const append = options.contains ? "" : "$";
      let output = `${prepend}(?:${input})${append}`;
      if (state.negated === true) {
        output = `(?:^(?!${output}).*$)`;
      }
      return output;
    };
  }
});

// node_modules/picomatch/lib/scan.js
var require_scan = __commonJS({
  "node_modules/picomatch/lib/scan.js"(exports2, module2) {
    "use strict";
    var utils = require_utils2();
    var {
      CHAR_ASTERISK,
      /* * */
      CHAR_AT,
      /* @ */
      CHAR_BACKWARD_SLASH,
      /* \ */
      CHAR_COMMA,
      /* , */
      CHAR_DOT,
      /* . */
      CHAR_EXCLAMATION_MARK,
      /* ! */
      CHAR_FORWARD_SLASH,
      /* / */
      CHAR_LEFT_CURLY_BRACE,
      /* { */
      CHAR_LEFT_PARENTHESES,
      /* ( */
      CHAR_LEFT_SQUARE_BRACKET,
      /* [ */
      CHAR_PLUS,
      /* + */
      CHAR_QUESTION_MARK,
      /* ? */
      CHAR_RIGHT_CURLY_BRACE,
      /* } */
      CHAR_RIGHT_PARENTHESES,
      /* ) */
      CHAR_RIGHT_SQUARE_BRACKET
      /* ] */
    } = require_constants2();
    var isPathSeparator = (code) => {
      return code === CHAR_FORWARD_SLASH || code === CHAR_BACKWARD_SLASH;
    };
    var depth = (token2) => {
      if (token2.isPrefix !== true) {
        token2.depth = token2.isGlobstar ? Infinity : 1;
      }
    };
    var scan = (input, options) => {
      const opts = options || {};
      const length = input.length - 1;
      const scanToEnd = opts.parts === true || opts.scanToEnd === true;
      const slashes = [];
      const tokens2 = [];
      const parts = [];
      let str = input;
      let index2 = -1;
      let start3 = 0;
      let lastIndex = 0;
      let isBrace = false;
      let isBracket = false;
      let isGlob = false;
      let isExtglob = false;
      let isGlobstar = false;
      let braceEscaped = false;
      let backslashes = false;
      let negated = false;
      let negatedExtglob = false;
      let finished = false;
      let braces = 0;
      let prev;
      let code;
      let token2 = { value: "", depth: 0, isGlob: false };
      const eos = () => index2 >= length;
      const peek = () => str.charCodeAt(index2 + 1);
      const advance = () => {
        prev = code;
        return str.charCodeAt(++index2);
      };
      while (index2 < length) {
        code = advance();
        let next;
        if (code === CHAR_BACKWARD_SLASH) {
          backslashes = token2.backslashes = true;
          code = advance();
          if (code === CHAR_LEFT_CURLY_BRACE) {
            braceEscaped = true;
          }
          continue;
        }
        if (braceEscaped === true || code === CHAR_LEFT_CURLY_BRACE) {
          braces++;
          while (eos() !== true && (code = advance())) {
            if (code === CHAR_BACKWARD_SLASH) {
              backslashes = token2.backslashes = true;
              advance();
              continue;
            }
            if (code === CHAR_LEFT_CURLY_BRACE) {
              braces++;
              continue;
            }
            if (braceEscaped !== true && code === CHAR_DOT && (code = advance()) === CHAR_DOT) {
              isBrace = token2.isBrace = true;
              isGlob = token2.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (braceEscaped !== true && code === CHAR_COMMA) {
              isBrace = token2.isBrace = true;
              isGlob = token2.isGlob = true;
              finished = true;
              if (scanToEnd === true) {
                continue;
              }
              break;
            }
            if (code === CHAR_RIGHT_CURLY_BRACE) {
              braces--;
              if (braces === 0) {
                braceEscaped = false;
                isBrace = token2.isBrace = true;
                finished = true;
                break;
              }
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_FORWARD_SLASH) {
          slashes.push(index2);
          tokens2.push(token2);
          token2 = { value: "", depth: 0, isGlob: false };
          if (finished === true)
            continue;
          if (prev === CHAR_DOT && index2 === start3 + 1) {
            start3 += 2;
            continue;
          }
          lastIndex = index2 + 1;
          continue;
        }
        if (opts.noext !== true) {
          const isExtglobChar = code === CHAR_PLUS || code === CHAR_AT || code === CHAR_ASTERISK || code === CHAR_QUESTION_MARK || code === CHAR_EXCLAMATION_MARK;
          if (isExtglobChar === true && peek() === CHAR_LEFT_PARENTHESES) {
            isGlob = token2.isGlob = true;
            isExtglob = token2.isExtglob = true;
            finished = true;
            if (code === CHAR_EXCLAMATION_MARK && index2 === start3) {
              negatedExtglob = true;
            }
            if (scanToEnd === true) {
              while (eos() !== true && (code = advance())) {
                if (code === CHAR_BACKWARD_SLASH) {
                  backslashes = token2.backslashes = true;
                  code = advance();
                  continue;
                }
                if (code === CHAR_RIGHT_PARENTHESES) {
                  isGlob = token2.isGlob = true;
                  finished = true;
                  break;
                }
              }
              continue;
            }
            break;
          }
        }
        if (code === CHAR_ASTERISK) {
          if (prev === CHAR_ASTERISK)
            isGlobstar = token2.isGlobstar = true;
          isGlob = token2.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_QUESTION_MARK) {
          isGlob = token2.isGlob = true;
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (code === CHAR_LEFT_SQUARE_BRACKET) {
          while (eos() !== true && (next = advance())) {
            if (next === CHAR_BACKWARD_SLASH) {
              backslashes = token2.backslashes = true;
              advance();
              continue;
            }
            if (next === CHAR_RIGHT_SQUARE_BRACKET) {
              isBracket = token2.isBracket = true;
              isGlob = token2.isGlob = true;
              finished = true;
              break;
            }
          }
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
        if (opts.nonegate !== true && code === CHAR_EXCLAMATION_MARK && index2 === start3) {
          negated = token2.negated = true;
          start3++;
          continue;
        }
        if (opts.noparen !== true && code === CHAR_LEFT_PARENTHESES) {
          isGlob = token2.isGlob = true;
          if (scanToEnd === true) {
            while (eos() !== true && (code = advance())) {
              if (code === CHAR_LEFT_PARENTHESES) {
                backslashes = token2.backslashes = true;
                code = advance();
                continue;
              }
              if (code === CHAR_RIGHT_PARENTHESES) {
                finished = true;
                break;
              }
            }
            continue;
          }
          break;
        }
        if (isGlob === true) {
          finished = true;
          if (scanToEnd === true) {
            continue;
          }
          break;
        }
      }
      if (opts.noext === true) {
        isExtglob = false;
        isGlob = false;
      }
      let base = str;
      let prefix3 = "";
      let glob = "";
      if (start3 > 0) {
        prefix3 = str.slice(0, start3);
        str = str.slice(start3);
        lastIndex -= start3;
      }
      if (base && isGlob === true && lastIndex > 0) {
        base = str.slice(0, lastIndex);
        glob = str.slice(lastIndex);
      } else if (isGlob === true) {
        base = "";
        glob = str;
      } else {
        base = str;
      }
      if (base && base !== "" && base !== "/" && base !== str) {
        if (isPathSeparator(base.charCodeAt(base.length - 1))) {
          base = base.slice(0, -1);
        }
      }
      if (opts.unescape === true) {
        if (glob)
          glob = utils.removeBackslashes(glob);
        if (base && backslashes === true) {
          base = utils.removeBackslashes(base);
        }
      }
      const state = {
        prefix: prefix3,
        input,
        start: start3,
        base,
        glob,
        isBrace,
        isBracket,
        isGlob,
        isExtglob,
        isGlobstar,
        negated,
        negatedExtglob
      };
      if (opts.tokens === true) {
        state.maxDepth = 0;
        if (!isPathSeparator(code)) {
          tokens2.push(token2);
        }
        state.tokens = tokens2;
      }
      if (opts.parts === true || opts.tokens === true) {
        let prevIndex;
        for (let idx = 0; idx < slashes.length; idx++) {
          const n12 = prevIndex ? prevIndex + 1 : start3;
          const i15 = slashes[idx];
          const value = input.slice(n12, i15);
          if (opts.tokens) {
            if (idx === 0 && start3 !== 0) {
              tokens2[idx].isPrefix = true;
              tokens2[idx].value = prefix3;
            } else {
              tokens2[idx].value = value;
            }
            depth(tokens2[idx]);
            state.maxDepth += tokens2[idx].depth;
          }
          if (idx !== 0 || value !== "") {
            parts.push(value);
          }
          prevIndex = i15;
        }
        if (prevIndex && prevIndex + 1 < input.length) {
          const value = input.slice(prevIndex + 1);
          parts.push(value);
          if (opts.tokens) {
            tokens2[tokens2.length - 1].value = value;
            depth(tokens2[tokens2.length - 1]);
            state.maxDepth += tokens2[tokens2.length - 1].depth;
          }
        }
        state.slashes = slashes;
        state.parts = parts;
      }
      return state;
    };
    module2.exports = scan;
  }
});

// node_modules/picomatch/lib/parse.js
var require_parse3 = __commonJS({
  "node_modules/picomatch/lib/parse.js"(exports2, module2) {
    "use strict";
    var constants = require_constants2();
    var utils = require_utils2();
    var {
      MAX_LENGTH,
      POSIX_REGEX_SOURCE,
      REGEX_NON_SPECIAL_CHARS,
      REGEX_SPECIAL_CHARS_BACKREF,
      REPLACEMENTS
    } = constants;
    var expandRange = (args, options) => {
      if (typeof options.expandRange === "function") {
        return options.expandRange(...args, options);
      }
      args.sort();
      const value = `[${args.join("-")}]`;
      try {
        new RegExp(value);
      } catch (ex) {
        return args.map((v6) => utils.escapeRegex(v6)).join("..");
      }
      return value;
    };
    var syntaxError = (type, char) => {
      return `Missing ${type}: "${char}" - use "\\\\${char}" to match literal characters`;
    };
    var parse6 = (input, options) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected a string");
      }
      input = REPLACEMENTS[input] || input;
      const opts = { ...options };
      const max4 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      let len = input.length;
      if (len > max4) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max4}`);
      }
      const bos = { type: "bos", value: "", output: opts.prepend || "" };
      const tokens2 = [bos];
      const capture = opts.capture ? "" : "?:";
      const win32 = utils.isWindows(options);
      const PLATFORM_CHARS = constants.globChars(win32);
      const EXTGLOB_CHARS = constants.extglobChars(PLATFORM_CHARS);
      const {
        DOT_LITERAL,
        PLUS_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOT_SLASH,
        NO_DOTS_SLASH,
        QMARK,
        QMARK_NO_DOT,
        STAR,
        START_ANCHOR
      } = PLATFORM_CHARS;
      const globstar = (opts2) => {
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const nodot = opts.dot ? "" : NO_DOT;
      const qmarkNoDot = opts.dot ? QMARK : QMARK_NO_DOT;
      let star = opts.bash === true ? globstar(opts) : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      if (typeof opts.noext === "boolean") {
        opts.noextglob = opts.noext;
      }
      const state = {
        input,
        index: -1,
        start: 0,
        dot: opts.dot === true,
        consumed: "",
        output: "",
        prefix: "",
        backtrack: false,
        negated: false,
        brackets: 0,
        braces: 0,
        parens: 0,
        quotes: 0,
        globstar: false,
        tokens: tokens2
      };
      input = utils.removePrefix(input, state);
      len = input.length;
      const extglobs = [];
      const braces = [];
      const stack = [];
      let prev = bos;
      let value;
      const eos = () => state.index === len - 1;
      const peek = state.peek = (n12 = 1) => input[state.index + n12];
      const advance = state.advance = () => input[++state.index] || "";
      const remaining = () => input.slice(state.index + 1);
      const consume = (value2 = "", num = 0) => {
        state.consumed += value2;
        state.index += num;
      };
      const append = (token2) => {
        state.output += token2.output != null ? token2.output : token2.value;
        consume(token2.value);
      };
      const negate3 = () => {
        let count2 = 1;
        while (peek() === "!" && (peek(2) !== "(" || peek(3) === "?")) {
          advance();
          state.start++;
          count2++;
        }
        if (count2 % 2 === 0) {
          return false;
        }
        state.negated = true;
        state.start++;
        return true;
      };
      const increment = (type) => {
        state[type]++;
        stack.push(type);
      };
      const decrement = (type) => {
        state[type]--;
        stack.pop();
      };
      const push3 = (tok) => {
        if (prev.type === "globstar") {
          const isBrace = state.braces > 0 && (tok.type === "comma" || tok.type === "brace");
          const isExtglob = tok.extglob === true || extglobs.length && (tok.type === "pipe" || tok.type === "paren");
          if (tok.type !== "slash" && tok.type !== "paren" && !isBrace && !isExtglob) {
            state.output = state.output.slice(0, -prev.output.length);
            prev.type = "star";
            prev.value = "*";
            prev.output = star;
            state.output += prev.output;
          }
        }
        if (extglobs.length && tok.type !== "paren") {
          extglobs[extglobs.length - 1].inner += tok.value;
        }
        if (tok.value || tok.output)
          append(tok);
        if (prev && prev.type === "text" && tok.type === "text") {
          prev.value += tok.value;
          prev.output = (prev.output || "") + tok.value;
          return;
        }
        tok.prev = prev;
        tokens2.push(tok);
        prev = tok;
      };
      const extglobOpen = (type, value2) => {
        const token2 = { ...EXTGLOB_CHARS[value2], conditions: 1, inner: "" };
        token2.prev = prev;
        token2.parens = state.parens;
        token2.output = state.output;
        const output = (opts.capture ? "(" : "") + token2.open;
        increment("parens");
        push3({ type, value: value2, output: state.output ? "" : ONE_CHAR });
        push3({ type: "paren", extglob: true, value: advance(), output });
        extglobs.push(token2);
      };
      const extglobClose = (token2) => {
        let output = token2.close + (opts.capture ? ")" : "");
        let rest;
        if (token2.type === "negate") {
          let extglobStar = star;
          if (token2.inner && token2.inner.length > 1 && token2.inner.includes("/")) {
            extglobStar = globstar(opts);
          }
          if (extglobStar !== star || eos() || /^\)+$/.test(remaining())) {
            output = token2.close = `)$))${extglobStar}`;
          }
          if (token2.inner.includes("*") && (rest = remaining()) && /^\.[^\\/.]+$/.test(rest)) {
            const expression = parse6(rest, { ...options, fastpaths: false }).output;
            output = token2.close = `)${expression})${extglobStar})`;
          }
          if (token2.prev.type === "bos") {
            state.negatedExtglob = true;
          }
        }
        push3({ type: "paren", extglob: true, value, output });
        decrement("parens");
      };
      if (opts.fastpaths !== false && !/(^[*!]|[/()[\]{}"])/.test(input)) {
        let backslashes = false;
        let output = input.replace(REGEX_SPECIAL_CHARS_BACKREF, (m10, esc, chars, first, rest, index2) => {
          if (first === "\\") {
            backslashes = true;
            return m10;
          }
          if (first === "?") {
            if (esc) {
              return esc + first + (rest ? QMARK.repeat(rest.length) : "");
            }
            if (index2 === 0) {
              return qmarkNoDot + (rest ? QMARK.repeat(rest.length) : "");
            }
            return QMARK.repeat(chars.length);
          }
          if (first === ".") {
            return DOT_LITERAL.repeat(chars.length);
          }
          if (first === "*") {
            if (esc) {
              return esc + first + (rest ? star : "");
            }
            return star;
          }
          return esc ? m10 : `\\${m10}`;
        });
        if (backslashes === true) {
          if (opts.unescape === true) {
            output = output.replace(/\\/g, "");
          } else {
            output = output.replace(/\\+/g, (m10) => {
              return m10.length % 2 === 0 ? "\\\\" : m10 ? "\\" : "";
            });
          }
        }
        if (output === input && opts.contains === true) {
          state.output = input;
          return state;
        }
        state.output = utils.wrapOutput(output, state, options);
        return state;
      }
      while (!eos()) {
        value = advance();
        if (value === "\0") {
          continue;
        }
        if (value === "\\") {
          const next = peek();
          if (next === "/" && opts.bash !== true) {
            continue;
          }
          if (next === "." || next === ";") {
            continue;
          }
          if (!next) {
            value += "\\";
            push3({ type: "text", value });
            continue;
          }
          const match5 = /^\\+/.exec(remaining());
          let slashes = 0;
          if (match5 && match5[0].length > 2) {
            slashes = match5[0].length;
            state.index += slashes;
            if (slashes % 2 !== 0) {
              value += "\\";
            }
          }
          if (opts.unescape === true) {
            value = advance();
          } else {
            value += advance();
          }
          if (state.brackets === 0) {
            push3({ type: "text", value });
            continue;
          }
        }
        if (state.brackets > 0 && (value !== "]" || prev.value === "[" || prev.value === "[^")) {
          if (opts.posix !== false && value === ":") {
            const inner = prev.value.slice(1);
            if (inner.includes("[")) {
              prev.posix = true;
              if (inner.includes(":")) {
                const idx = prev.value.lastIndexOf("[");
                const pre = prev.value.slice(0, idx);
                const rest2 = prev.value.slice(idx + 2);
                const posix = POSIX_REGEX_SOURCE[rest2];
                if (posix) {
                  prev.value = pre + posix;
                  state.backtrack = true;
                  advance();
                  if (!bos.output && tokens2.indexOf(prev) === 1) {
                    bos.output = ONE_CHAR;
                  }
                  continue;
                }
              }
            }
          }
          if (value === "[" && peek() !== ":" || value === "-" && peek() === "]") {
            value = `\\${value}`;
          }
          if (value === "]" && (prev.value === "[" || prev.value === "[^")) {
            value = `\\${value}`;
          }
          if (opts.posix === true && value === "!" && prev.value === "[") {
            value = "^";
          }
          prev.value += value;
          append({ value });
          continue;
        }
        if (state.quotes === 1 && value !== '"') {
          value = utils.escapeRegex(value);
          prev.value += value;
          append({ value });
          continue;
        }
        if (value === '"') {
          state.quotes = state.quotes === 1 ? 0 : 1;
          if (opts.keepQuotes === true) {
            push3({ type: "text", value });
          }
          continue;
        }
        if (value === "(") {
          increment("parens");
          push3({ type: "paren", value });
          continue;
        }
        if (value === ")") {
          if (state.parens === 0 && opts.strictBrackets === true) {
            throw new SyntaxError(syntaxError("opening", "("));
          }
          const extglob = extglobs[extglobs.length - 1];
          if (extglob && state.parens === extglob.parens + 1) {
            extglobClose(extglobs.pop());
            continue;
          }
          push3({ type: "paren", value, output: state.parens ? ")" : "\\)" });
          decrement("parens");
          continue;
        }
        if (value === "[") {
          if (opts.nobracket === true || !remaining().includes("]")) {
            if (opts.nobracket !== true && opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("closing", "]"));
            }
            value = `\\${value}`;
          } else {
            increment("brackets");
          }
          push3({ type: "bracket", value });
          continue;
        }
        if (value === "]") {
          if (opts.nobracket === true || prev && prev.type === "bracket" && prev.value.length === 1) {
            push3({ type: "text", value, output: `\\${value}` });
            continue;
          }
          if (state.brackets === 0) {
            if (opts.strictBrackets === true) {
              throw new SyntaxError(syntaxError("opening", "["));
            }
            push3({ type: "text", value, output: `\\${value}` });
            continue;
          }
          decrement("brackets");
          const prevValue = prev.value.slice(1);
          if (prev.posix !== true && prevValue[0] === "^" && !prevValue.includes("/")) {
            value = `/${value}`;
          }
          prev.value += value;
          append({ value });
          if (opts.literalBrackets === false || utils.hasRegexChars(prevValue)) {
            continue;
          }
          const escaped = utils.escapeRegex(prev.value);
          state.output = state.output.slice(0, -prev.value.length);
          if (opts.literalBrackets === true) {
            state.output += escaped;
            prev.value = escaped;
            continue;
          }
          prev.value = `(${capture}${escaped}|${prev.value})`;
          state.output += prev.value;
          continue;
        }
        if (value === "{" && opts.nobrace !== true) {
          increment("braces");
          const open = {
            type: "brace",
            value,
            output: "(",
            outputIndex: state.output.length,
            tokensIndex: state.tokens.length
          };
          braces.push(open);
          push3(open);
          continue;
        }
        if (value === "}") {
          const brace = braces[braces.length - 1];
          if (opts.nobrace === true || !brace) {
            push3({ type: "text", value, output: value });
            continue;
          }
          let output = ")";
          if (brace.dots === true) {
            const arr = tokens2.slice();
            const range = [];
            for (let i15 = arr.length - 1; i15 >= 0; i15--) {
              tokens2.pop();
              if (arr[i15].type === "brace") {
                break;
              }
              if (arr[i15].type !== "dots") {
                range.unshift(arr[i15].value);
              }
            }
            output = expandRange(range, opts);
            state.backtrack = true;
          }
          if (brace.comma !== true && brace.dots !== true) {
            const out = state.output.slice(0, brace.outputIndex);
            const toks = state.tokens.slice(brace.tokensIndex);
            brace.value = brace.output = "\\{";
            value = output = "\\}";
            state.output = out;
            for (const t20 of toks) {
              state.output += t20.output || t20.value;
            }
          }
          push3({ type: "brace", value, output });
          decrement("braces");
          braces.pop();
          continue;
        }
        if (value === "|") {
          if (extglobs.length > 0) {
            extglobs[extglobs.length - 1].conditions++;
          }
          push3({ type: "text", value });
          continue;
        }
        if (value === ",") {
          let output = value;
          const brace = braces[braces.length - 1];
          if (brace && stack[stack.length - 1] === "braces") {
            brace.comma = true;
            output = "|";
          }
          push3({ type: "comma", value, output });
          continue;
        }
        if (value === "/") {
          if (prev.type === "dot" && state.index === state.start + 1) {
            state.start = state.index + 1;
            state.consumed = "";
            state.output = "";
            tokens2.pop();
            prev = bos;
            continue;
          }
          push3({ type: "slash", value, output: SLASH_LITERAL });
          continue;
        }
        if (value === ".") {
          if (state.braces > 0 && prev.type === "dot") {
            if (prev.value === ".")
              prev.output = DOT_LITERAL;
            const brace = braces[braces.length - 1];
            prev.type = "dots";
            prev.output += value;
            prev.value += value;
            brace.dots = true;
            continue;
          }
          if (state.braces + state.parens === 0 && prev.type !== "bos" && prev.type !== "slash") {
            push3({ type: "text", value, output: DOT_LITERAL });
            continue;
          }
          push3({ type: "dot", value, output: DOT_LITERAL });
          continue;
        }
        if (value === "?") {
          const isGroup = prev && prev.value === "(";
          if (!isGroup && opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("qmark", value);
            continue;
          }
          if (prev && prev.type === "paren") {
            const next = peek();
            let output = value;
            if (next === "<" && !utils.supportsLookbehinds()) {
              throw new Error("Node.js v10 or higher is required for regex lookbehinds");
            }
            if (prev.value === "(" && !/[!=<:]/.test(next) || next === "<" && !/<([!=]|\w+>)/.test(remaining())) {
              output = `\\${value}`;
            }
            push3({ type: "text", value, output });
            continue;
          }
          if (opts.dot !== true && (prev.type === "slash" || prev.type === "bos")) {
            push3({ type: "qmark", value, output: QMARK_NO_DOT });
            continue;
          }
          push3({ type: "qmark", value, output: QMARK });
          continue;
        }
        if (value === "!") {
          if (opts.noextglob !== true && peek() === "(") {
            if (peek(2) !== "?" || !/[!=<:]/.test(peek(3))) {
              extglobOpen("negate", value);
              continue;
            }
          }
          if (opts.nonegate !== true && state.index === 0) {
            negate3();
            continue;
          }
        }
        if (value === "+") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            extglobOpen("plus", value);
            continue;
          }
          if (prev && prev.value === "(" || opts.regex === false) {
            push3({ type: "plus", value, output: PLUS_LITERAL });
            continue;
          }
          if (prev && (prev.type === "bracket" || prev.type === "paren" || prev.type === "brace") || state.parens > 0) {
            push3({ type: "plus", value });
            continue;
          }
          push3({ type: "plus", value: PLUS_LITERAL });
          continue;
        }
        if (value === "@") {
          if (opts.noextglob !== true && peek() === "(" && peek(2) !== "?") {
            push3({ type: "at", extglob: true, value, output: "" });
            continue;
          }
          push3({ type: "text", value });
          continue;
        }
        if (value !== "*") {
          if (value === "$" || value === "^") {
            value = `\\${value}`;
          }
          const match5 = REGEX_NON_SPECIAL_CHARS.exec(remaining());
          if (match5) {
            value += match5[0];
            state.index += match5[0].length;
          }
          push3({ type: "text", value });
          continue;
        }
        if (prev && (prev.type === "globstar" || prev.star === true)) {
          prev.type = "star";
          prev.star = true;
          prev.value += value;
          prev.output = star;
          state.backtrack = true;
          state.globstar = true;
          consume(value);
          continue;
        }
        let rest = remaining();
        if (opts.noextglob !== true && /^\([^?]/.test(rest)) {
          extglobOpen("star", value);
          continue;
        }
        if (prev.type === "star") {
          if (opts.noglobstar === true) {
            consume(value);
            continue;
          }
          const prior = prev.prev;
          const before = prior.prev;
          const isStart = prior.type === "slash" || prior.type === "bos";
          const afterStar = before && (before.type === "star" || before.type === "globstar");
          if (opts.bash === true && (!isStart || rest[0] && rest[0] !== "/")) {
            push3({ type: "star", value, output: "" });
            continue;
          }
          const isBrace = state.braces > 0 && (prior.type === "comma" || prior.type === "brace");
          const isExtglob = extglobs.length && (prior.type === "pipe" || prior.type === "paren");
          if (!isStart && prior.type !== "paren" && !isBrace && !isExtglob) {
            push3({ type: "star", value, output: "" });
            continue;
          }
          while (rest.slice(0, 3) === "/**") {
            const after = input[state.index + 4];
            if (after && after !== "/") {
              break;
            }
            rest = rest.slice(3);
            consume("/**", 3);
          }
          if (prior.type === "bos" && eos()) {
            prev.type = "globstar";
            prev.value += value;
            prev.output = globstar(opts);
            state.output = prev.output;
            state.globstar = true;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && !afterStar && eos()) {
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = globstar(opts) + (opts.strictSlashes ? ")" : "|$)");
            prev.value += value;
            state.globstar = true;
            state.output += prior.output + prev.output;
            consume(value);
            continue;
          }
          if (prior.type === "slash" && prior.prev.type !== "bos" && rest[0] === "/") {
            const end2 = rest[1] !== void 0 ? "|$" : "";
            state.output = state.output.slice(0, -(prior.output + prev.output).length);
            prior.output = `(?:${prior.output}`;
            prev.type = "globstar";
            prev.output = `${globstar(opts)}${SLASH_LITERAL}|${SLASH_LITERAL}${end2})`;
            prev.value += value;
            state.output += prior.output + prev.output;
            state.globstar = true;
            consume(value + advance());
            push3({ type: "slash", value: "/", output: "" });
            continue;
          }
          if (prior.type === "bos" && rest[0] === "/") {
            prev.type = "globstar";
            prev.value += value;
            prev.output = `(?:^|${SLASH_LITERAL}|${globstar(opts)}${SLASH_LITERAL})`;
            state.output = prev.output;
            state.globstar = true;
            consume(value + advance());
            push3({ type: "slash", value: "/", output: "" });
            continue;
          }
          state.output = state.output.slice(0, -prev.output.length);
          prev.type = "globstar";
          prev.output = globstar(opts);
          prev.value += value;
          state.output += prev.output;
          state.globstar = true;
          consume(value);
          continue;
        }
        const token2 = { type: "star", value, output: star };
        if (opts.bash === true) {
          token2.output = ".*?";
          if (prev.type === "bos" || prev.type === "slash") {
            token2.output = nodot + token2.output;
          }
          push3(token2);
          continue;
        }
        if (prev && (prev.type === "bracket" || prev.type === "paren") && opts.regex === true) {
          token2.output = value;
          push3(token2);
          continue;
        }
        if (state.index === state.start || prev.type === "slash" || prev.type === "dot") {
          if (prev.type === "dot") {
            state.output += NO_DOT_SLASH;
            prev.output += NO_DOT_SLASH;
          } else if (opts.dot === true) {
            state.output += NO_DOTS_SLASH;
            prev.output += NO_DOTS_SLASH;
          } else {
            state.output += nodot;
            prev.output += nodot;
          }
          if (peek() !== "*") {
            state.output += ONE_CHAR;
            prev.output += ONE_CHAR;
          }
        }
        push3(token2);
      }
      while (state.brackets > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "]"));
        state.output = utils.escapeLast(state.output, "[");
        decrement("brackets");
      }
      while (state.parens > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", ")"));
        state.output = utils.escapeLast(state.output, "(");
        decrement("parens");
      }
      while (state.braces > 0) {
        if (opts.strictBrackets === true)
          throw new SyntaxError(syntaxError("closing", "}"));
        state.output = utils.escapeLast(state.output, "{");
        decrement("braces");
      }
      if (opts.strictSlashes !== true && (prev.type === "star" || prev.type === "bracket")) {
        push3({ type: "maybe_slash", value: "", output: `${SLASH_LITERAL}?` });
      }
      if (state.backtrack === true) {
        state.output = "";
        for (const token2 of state.tokens) {
          state.output += token2.output != null ? token2.output : token2.value;
          if (token2.suffix) {
            state.output += token2.suffix;
          }
        }
      }
      return state;
    };
    parse6.fastpaths = (input, options) => {
      const opts = { ...options };
      const max4 = typeof opts.maxLength === "number" ? Math.min(MAX_LENGTH, opts.maxLength) : MAX_LENGTH;
      const len = input.length;
      if (len > max4) {
        throw new SyntaxError(`Input length: ${len}, exceeds maximum allowed length: ${max4}`);
      }
      input = REPLACEMENTS[input] || input;
      const win32 = utils.isWindows(options);
      const {
        DOT_LITERAL,
        SLASH_LITERAL,
        ONE_CHAR,
        DOTS_SLASH,
        NO_DOT,
        NO_DOTS,
        NO_DOTS_SLASH,
        STAR,
        START_ANCHOR
      } = constants.globChars(win32);
      const nodot = opts.dot ? NO_DOTS : NO_DOT;
      const slashDot = opts.dot ? NO_DOTS_SLASH : NO_DOT;
      const capture = opts.capture ? "" : "?:";
      const state = { negated: false, prefix: "" };
      let star = opts.bash === true ? ".*?" : STAR;
      if (opts.capture) {
        star = `(${star})`;
      }
      const globstar = (opts2) => {
        if (opts2.noglobstar === true)
          return star;
        return `(${capture}(?:(?!${START_ANCHOR}${opts2.dot ? DOTS_SLASH : DOT_LITERAL}).)*?)`;
      };
      const create14 = (str) => {
        switch (str) {
          case "*":
            return `${nodot}${ONE_CHAR}${star}`;
          case ".*":
            return `${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*.*":
            return `${nodot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "*/*":
            return `${nodot}${star}${SLASH_LITERAL}${ONE_CHAR}${slashDot}${star}`;
          case "**":
            return nodot + globstar(opts);
          case "**/*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${ONE_CHAR}${star}`;
          case "**/*.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${slashDot}${star}${DOT_LITERAL}${ONE_CHAR}${star}`;
          case "**/.*":
            return `(?:${nodot}${globstar(opts)}${SLASH_LITERAL})?${DOT_LITERAL}${ONE_CHAR}${star}`;
          default: {
            const match5 = /^(.*?)\.(\w+)$/.exec(str);
            if (!match5)
              return;
            const source2 = create14(match5[1]);
            if (!source2)
              return;
            return source2 + DOT_LITERAL + match5[2];
          }
        }
      };
      const output = utils.removePrefix(input, state);
      let source = create14(output);
      if (source && opts.strictSlashes !== true) {
        source += `${SLASH_LITERAL}?`;
      }
      return source;
    };
    module2.exports = parse6;
  }
});

// node_modules/picomatch/lib/picomatch.js
var require_picomatch = __commonJS({
  "node_modules/picomatch/lib/picomatch.js"(exports2, module2) {
    "use strict";
    var path = require_path();
    var scan = require_scan();
    var parse6 = require_parse3();
    var utils = require_utils2();
    var constants = require_constants2();
    var isObject10 = (val) => val && typeof val === "object" && !Array.isArray(val);
    var picomatch = (glob, options, returnState = false) => {
      if (Array.isArray(glob)) {
        const fns = glob.map((input) => picomatch(input, options, returnState));
        const arrayMatcher = (str) => {
          for (const isMatch of fns) {
            const state2 = isMatch(str);
            if (state2)
              return state2;
          }
          return false;
        };
        return arrayMatcher;
      }
      const isState = isObject10(glob) && glob.tokens && glob.input;
      if (glob === "" || typeof glob !== "string" && !isState) {
        throw new TypeError("Expected pattern to be a non-empty string");
      }
      const opts = options || {};
      const posix = utils.isWindows(options);
      const regex = isState ? picomatch.compileRe(glob, options) : picomatch.makeRe(glob, options, false, true);
      const state = regex.state;
      delete regex.state;
      let isIgnored = () => false;
      if (opts.ignore) {
        const ignoreOpts = { ...options, ignore: null, onMatch: null, onResult: null };
        isIgnored = picomatch(opts.ignore, ignoreOpts, returnState);
      }
      const matcher = (input, returnObject = false) => {
        const { isMatch, match: match5, output } = picomatch.test(input, regex, options, { glob, posix });
        const result = { glob, state, regex, posix, input, output, match: match5, isMatch };
        if (typeof opts.onResult === "function") {
          opts.onResult(result);
        }
        if (isMatch === false) {
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (isIgnored(input)) {
          if (typeof opts.onIgnore === "function") {
            opts.onIgnore(result);
          }
          result.isMatch = false;
          return returnObject ? result : false;
        }
        if (typeof opts.onMatch === "function") {
          opts.onMatch(result);
        }
        return returnObject ? result : true;
      };
      if (returnState) {
        matcher.state = state;
      }
      return matcher;
    };
    picomatch.test = (input, regex, options, { glob, posix } = {}) => {
      if (typeof input !== "string") {
        throw new TypeError("Expected input to be a string");
      }
      if (input === "") {
        return { isMatch: false, output: "" };
      }
      const opts = options || {};
      const format3 = opts.format || (posix ? utils.toPosixSlashes : null);
      let match5 = input === glob;
      let output = match5 && format3 ? format3(input) : input;
      if (match5 === false) {
        output = format3 ? format3(input) : input;
        match5 = output === glob;
      }
      if (match5 === false || opts.capture === true) {
        if (opts.matchBase === true || opts.basename === true) {
          match5 = picomatch.matchBase(input, regex, options, posix);
        } else {
          match5 = regex.exec(output);
        }
      }
      return { isMatch: Boolean(match5), match: match5, output };
    };
    picomatch.matchBase = (input, glob, options, posix = utils.isWindows(options)) => {
      const regex = glob instanceof RegExp ? glob : picomatch.makeRe(glob, options);
      return regex.test(path.basename(input));
    };
    picomatch.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    picomatch.parse = (pattern, options) => {
      if (Array.isArray(pattern))
        return pattern.map((p12) => picomatch.parse(p12, options));
      return parse6(pattern, { ...options, fastpaths: false });
    };
    picomatch.scan = (input, options) => scan(input, options);
    picomatch.compileRe = (state, options, returnOutput = false, returnState = false) => {
      if (returnOutput === true) {
        return state.output;
      }
      const opts = options || {};
      const prepend = opts.contains ? "" : "^";
      const append = opts.contains ? "" : "$";
      let source = `${prepend}(?:${state.output})${append}`;
      if (state && state.negated === true) {
        source = `^(?!${source}).*$`;
      }
      const regex = picomatch.toRegex(source, options);
      if (returnState === true) {
        regex.state = state;
      }
      return regex;
    };
    picomatch.makeRe = (input, options = {}, returnOutput = false, returnState = false) => {
      if (!input || typeof input !== "string") {
        throw new TypeError("Expected a non-empty string");
      }
      let parsed = { negated: false, fastpaths: true };
      if (options.fastpaths !== false && (input[0] === "." || input[0] === "*")) {
        parsed.output = parse6.fastpaths(input, options);
      }
      if (!parsed.output) {
        parsed = parse6(input, options);
      }
      return picomatch.compileRe(parsed, options, returnOutput, returnState);
    };
    picomatch.toRegex = (source, options) => {
      try {
        const opts = options || {};
        return new RegExp(source, opts.flags || (opts.nocase ? "i" : ""));
      } catch (err) {
        if (options && options.debug === true)
          throw err;
        return /$^/;
      }
    };
    picomatch.constants = constants;
    module2.exports = picomatch;
  }
});

// node_modules/picomatch/index.js
var require_picomatch2 = __commonJS({
  "node_modules/picomatch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_picomatch();
  }
});

// node_modules/micromatch/index.js
var require_micromatch = __commonJS({
  "node_modules/micromatch/index.js"(exports2, module2) {
    "use strict";
    var util2 = require_util();
    var braces = require_braces();
    var picomatch = require_picomatch2();
    var utils = require_utils2();
    var isEmptyString = (val) => val === "" || val === "./";
    var micromatch2 = (list, patterns, options) => {
      patterns = [].concat(patterns);
      list = [].concat(list);
      let omit2 = /* @__PURE__ */ new Set();
      let keep = /* @__PURE__ */ new Set();
      let items = /* @__PURE__ */ new Set();
      let negatives = 0;
      let onResult = (state) => {
        items.add(state.output);
        if (options && options.onResult) {
          options.onResult(state);
        }
      };
      for (let i15 = 0; i15 < patterns.length; i15++) {
        let isMatch = picomatch(String(patterns[i15]), { ...options, onResult }, true);
        let negated = isMatch.state.negated || isMatch.state.negatedExtglob;
        if (negated)
          negatives++;
        for (let item of list) {
          let matched = isMatch(item, true);
          let match5 = negated ? !matched.isMatch : matched.isMatch;
          if (!match5)
            continue;
          if (negated) {
            omit2.add(matched.output);
          } else {
            omit2.delete(matched.output);
            keep.add(matched.output);
          }
        }
      }
      let result = negatives === patterns.length ? [...items] : [...keep];
      let matches = result.filter((item) => !omit2.has(item));
      if (options && matches.length === 0) {
        if (options.failglob === true) {
          throw new Error(`No matches found for "${patterns.join(", ")}"`);
        }
        if (options.nonull === true || options.nullglob === true) {
          return options.unescape ? patterns.map((p12) => p12.replace(/\\/g, "")) : patterns;
        }
      }
      return matches;
    };
    micromatch2.match = micromatch2;
    micromatch2.matcher = (pattern, options) => picomatch(pattern, options);
    micromatch2.isMatch = (str, patterns, options) => picomatch(patterns, options)(str);
    micromatch2.any = micromatch2.isMatch;
    micromatch2.not = (list, patterns, options = {}) => {
      patterns = [].concat(patterns).map(String);
      let result = /* @__PURE__ */ new Set();
      let items = [];
      let onResult = (state) => {
        if (options.onResult)
          options.onResult(state);
        items.push(state.output);
      };
      let matches = new Set(micromatch2(list, patterns, { ...options, onResult }));
      for (let item of items) {
        if (!matches.has(item)) {
          result.add(item);
        }
      }
      return [...result];
    };
    micromatch2.contains = (str, pattern, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util2.inspect(str)}"`);
      }
      if (Array.isArray(pattern)) {
        return pattern.some((p12) => micromatch2.contains(str, p12, options));
      }
      if (typeof pattern === "string") {
        if (isEmptyString(str) || isEmptyString(pattern)) {
          return false;
        }
        if (str.includes(pattern) || str.startsWith("./") && str.slice(2).includes(pattern)) {
          return true;
        }
      }
      return micromatch2.isMatch(str, pattern, { ...options, contains: true });
    };
    micromatch2.matchKeys = (obj, patterns, options) => {
      if (!utils.isObject(obj)) {
        throw new TypeError("Expected the first argument to be an object");
      }
      let keys6 = micromatch2(Object.keys(obj), patterns, options);
      let res = {};
      for (let key of keys6)
        res[key] = obj[key];
      return res;
    };
    micromatch2.some = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (items.some((item) => isMatch(item))) {
          return true;
        }
      }
      return false;
    };
    micromatch2.every = (list, patterns, options) => {
      let items = [].concat(list);
      for (let pattern of [].concat(patterns)) {
        let isMatch = picomatch(String(pattern), options);
        if (!items.every((item) => isMatch(item))) {
          return false;
        }
      }
      return true;
    };
    micromatch2.all = (str, patterns, options) => {
      if (typeof str !== "string") {
        throw new TypeError(`Expected a string: "${util2.inspect(str)}"`);
      }
      return [].concat(patterns).every((p12) => picomatch(p12, options)(str));
    };
    micromatch2.capture = (glob, input, options) => {
      let posix = utils.isWindows(options);
      let regex = picomatch.makeRe(String(glob), { ...options, capture: true });
      let match5 = regex.exec(posix ? utils.toPosixSlashes(input) : input);
      if (match5) {
        return match5.slice(1).map((v6) => v6 === void 0 ? "" : v6);
      }
    };
    micromatch2.makeRe = (...args) => picomatch.makeRe(...args);
    micromatch2.scan = (...args) => picomatch.scan(...args);
    micromatch2.parse = (patterns, options) => {
      let res = [];
      for (let pattern of [].concat(patterns || [])) {
        for (let str of braces(String(pattern), options)) {
          res.push(picomatch.parse(str, options));
        }
      }
      return res;
    };
    micromatch2.braces = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      if (options && options.nobrace === true || !/\{.*\}/.test(pattern)) {
        return [pattern];
      }
      return braces(pattern, options);
    };
    micromatch2.braceExpand = (pattern, options) => {
      if (typeof pattern !== "string")
        throw new TypeError("Expected a string");
      return micromatch2.braces(pattern, { ...options, expand: true });
    };
    module2.exports = micromatch2;
  }
});

// node_modules/lodash/_baseHas.js
var require_baseHas = __commonJS({
  "node_modules/lodash/_baseHas.js"(exports2, module2) {
    var objectProto20 = Object.prototype;
    var hasOwnProperty17 = objectProto20.hasOwnProperty;
    function baseHas(object2, key) {
      return object2 != null && hasOwnProperty17.call(object2, key);
    }
    module2.exports = baseHas;
  }
});

// node_modules/lodash/has.js
var require_has = __commonJS({
  "node_modules/lodash/has.js"(exports2, module2) {
    var baseHas = require_baseHas();
    var hasPath3 = require_hasPath();
    function has4(object2, path) {
      return object2 != null && hasPath3(object2, path, baseHas);
    }
    module2.exports = has4;
  }
});

// node_modules/lodash/mapValues.js
var require_mapValues = __commonJS({
  "node_modules/lodash/mapValues.js"(exports2, module2) {
    var baseAssignValue5 = require_baseAssignValue();
    var baseForOwn3 = require_baseForOwn();
    var baseIteratee3 = require_baseIteratee();
    function mapValues3(object2, iteratee) {
      var result = {};
      iteratee = baseIteratee3(iteratee, 3);
      baseForOwn3(object2, function(value, key, object3) {
        baseAssignValue5(result, key, iteratee(value, key, object3));
      });
      return result;
    }
    module2.exports = mapValues3;
  }
});

// node_modules/property-expr/index.js
var require_property_expr = __commonJS({
  "node_modules/property-expr/index.js"(exports2, module2) {
    "use strict";
    function Cache(maxSize) {
      this._maxSize = maxSize;
      this.clear();
    }
    Cache.prototype.clear = function() {
      this._size = 0;
      this._values = /* @__PURE__ */ Object.create(null);
    };
    Cache.prototype.get = function(key) {
      return this._values[key];
    };
    Cache.prototype.set = function(key, value) {
      this._size >= this._maxSize && this.clear();
      if (!(key in this._values))
        this._size++;
      return this._values[key] = value;
    };
    var SPLIT_REGEX = /[^.^\]^[]+|(?=\[\]|\.\.)/g;
    var DIGIT_REGEX = /^\d+$/;
    var LEAD_DIGIT_REGEX = /^\d/;
    var SPEC_CHAR_REGEX = /[~`!#$%\^&*+=\-\[\]\\';,/{}|\\":<>\?]/g;
    var CLEAN_QUOTES_REGEX = /^\s*(['"]?)(.*?)(\1)\s*$/;
    var MAX_CACHE_SIZE = 512;
    var pathCache = new Cache(MAX_CACHE_SIZE);
    var setCache = new Cache(MAX_CACHE_SIZE);
    var getCache = new Cache(MAX_CACHE_SIZE);
    module2.exports = {
      Cache,
      split: split2,
      normalizePath: normalizePath2,
      setter: function(path) {
        var parts = normalizePath2(path);
        return setCache.get(path) || setCache.set(path, function setter(obj, value) {
          var index2 = 0;
          var len = parts.length;
          var data = obj;
          while (index2 < len - 1) {
            var part = parts[index2];
            if (part === "__proto__" || part === "constructor" || part === "prototype") {
              return obj;
            }
            data = data[parts[index2++]];
          }
          data[parts[index2]] = value;
        });
      },
      getter: function(path, safe) {
        var parts = normalizePath2(path);
        return getCache.get(path) || getCache.set(path, function getter3(data) {
          var index2 = 0, len = parts.length;
          while (index2 < len) {
            if (data != null || !safe)
              data = data[parts[index2++]];
            else
              return;
          }
          return data;
        });
      },
      join: function(segments) {
        return segments.reduce(function(path, part) {
          return path + (isQuoted(part) || DIGIT_REGEX.test(part) ? "[" + part + "]" : (path ? "." : "") + part);
        }, "");
      },
      forEach: function(path, cb, thisArg) {
        forEach3(Array.isArray(path) ? path : split2(path), cb, thisArg);
      }
    };
    function normalizePath2(path) {
      return pathCache.get(path) || pathCache.set(
        path,
        split2(path).map(function(part) {
          return part.replace(CLEAN_QUOTES_REGEX, "$2");
        })
      );
    }
    function split2(path) {
      return path.match(SPLIT_REGEX) || [""];
    }
    function forEach3(parts, iter, thisArg) {
      var len = parts.length, part, idx, isArray10, isBracket;
      for (idx = 0; idx < len; idx++) {
        part = parts[idx];
        if (part) {
          if (shouldBeQuoted(part)) {
            part = '"' + part + '"';
          }
          isBracket = isQuoted(part);
          isArray10 = !isBracket && /^\d+$/.test(part);
          iter.call(thisArg, part, isBracket, isArray10, idx, parts);
        }
      }
    }
    function isQuoted(str) {
      return typeof str === "string" && str && ["'", '"'].indexOf(str.charAt(0)) !== -1;
    }
    function hasLeadingNumber(part) {
      return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);
    }
    function hasSpecialChars(part) {
      return SPEC_CHAR_REGEX.test(part);
    }
    function shouldBeQuoted(part) {
      return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));
    }
  }
});

// node_modules/lodash/_arrayReduce.js
var require_arrayReduce = __commonJS({
  "node_modules/lodash/_arrayReduce.js"(exports2, module2) {
    function arrayReduce(array2, iteratee, accumulator, initAccum) {
      var index2 = -1, length = array2 == null ? 0 : array2.length;
      if (initAccum && length) {
        accumulator = array2[++index2];
      }
      while (++index2 < length) {
        accumulator = iteratee(accumulator, array2[index2], index2, array2);
      }
      return accumulator;
    }
    module2.exports = arrayReduce;
  }
});

// node_modules/lodash/_basePropertyOf.js
var require_basePropertyOf = __commonJS({
  "node_modules/lodash/_basePropertyOf.js"(exports2, module2) {
    function basePropertyOf(object2) {
      return function(key) {
        return object2 == null ? void 0 : object2[key];
      };
    }
    module2.exports = basePropertyOf;
  }
});

// node_modules/lodash/_deburrLetter.js
var require_deburrLetter = __commonJS({
  "node_modules/lodash/_deburrLetter.js"(exports2, module2) {
    var basePropertyOf = require_basePropertyOf();
    var deburredLetters = {
      // Latin-1 Supplement block.
      "À": "A",
      "Á": "A",
      "Â": "A",
      "Ã": "A",
      "Ä": "A",
      "Å": "A",
      "à": "a",
      "á": "a",
      "â": "a",
      "ã": "a",
      "ä": "a",
      "å": "a",
      "Ç": "C",
      "ç": "c",
      "Ð": "D",
      "ð": "d",
      "È": "E",
      "É": "E",
      "Ê": "E",
      "Ë": "E",
      "è": "e",
      "é": "e",
      "ê": "e",
      "ë": "e",
      "Ì": "I",
      "Í": "I",
      "Î": "I",
      "Ï": "I",
      "ì": "i",
      "í": "i",
      "î": "i",
      "ï": "i",
      "Ñ": "N",
      "ñ": "n",
      "Ò": "O",
      "Ó": "O",
      "Ô": "O",
      "Õ": "O",
      "Ö": "O",
      "Ø": "O",
      "ò": "o",
      "ó": "o",
      "ô": "o",
      "õ": "o",
      "ö": "o",
      "ø": "o",
      "Ù": "U",
      "Ú": "U",
      "Û": "U",
      "Ü": "U",
      "ù": "u",
      "ú": "u",
      "û": "u",
      "ü": "u",
      "Ý": "Y",
      "ý": "y",
      "ÿ": "y",
      "Æ": "Ae",
      "æ": "ae",
      "Þ": "Th",
      "þ": "th",
      "ß": "ss",
      // Latin Extended-A block.
      "Ā": "A",
      "Ă": "A",
      "Ą": "A",
      "ā": "a",
      "ă": "a",
      "ą": "a",
      "Ć": "C",
      "Ĉ": "C",
      "Ċ": "C",
      "Č": "C",
      "ć": "c",
      "ĉ": "c",
      "ċ": "c",
      "č": "c",
      "Ď": "D",
      "Đ": "D",
      "ď": "d",
      "đ": "d",
      "Ē": "E",
      "Ĕ": "E",
      "Ė": "E",
      "Ę": "E",
      "Ě": "E",
      "ē": "e",
      "ĕ": "e",
      "ė": "e",
      "ę": "e",
      "ě": "e",
      "Ĝ": "G",
      "Ğ": "G",
      "Ġ": "G",
      "Ģ": "G",
      "ĝ": "g",
      "ğ": "g",
      "ġ": "g",
      "ģ": "g",
      "Ĥ": "H",
      "Ħ": "H",
      "ĥ": "h",
      "ħ": "h",
      "Ĩ": "I",
      "Ī": "I",
      "Ĭ": "I",
      "Į": "I",
      "İ": "I",
      "ĩ": "i",
      "ī": "i",
      "ĭ": "i",
      "į": "i",
      "ı": "i",
      "Ĵ": "J",
      "ĵ": "j",
      "Ķ": "K",
      "ķ": "k",
      "ĸ": "k",
      "Ĺ": "L",
      "Ļ": "L",
      "Ľ": "L",
      "Ŀ": "L",
      "Ł": "L",
      "ĺ": "l",
      "ļ": "l",
      "ľ": "l",
      "ŀ": "l",
      "ł": "l",
      "Ń": "N",
      "Ņ": "N",
      "Ň": "N",
      "Ŋ": "N",
      "ń": "n",
      "ņ": "n",
      "ň": "n",
      "ŋ": "n",
      "Ō": "O",
      "Ŏ": "O",
      "Ő": "O",
      "ō": "o",
      "ŏ": "o",
      "ő": "o",
      "Ŕ": "R",
      "Ŗ": "R",
      "Ř": "R",
      "ŕ": "r",
      "ŗ": "r",
      "ř": "r",
      "Ś": "S",
      "Ŝ": "S",
      "Ş": "S",
      "Š": "S",
      "ś": "s",
      "ŝ": "s",
      "ş": "s",
      "š": "s",
      "Ţ": "T",
      "Ť": "T",
      "Ŧ": "T",
      "ţ": "t",
      "ť": "t",
      "ŧ": "t",
      "Ũ": "U",
      "Ū": "U",
      "Ŭ": "U",
      "Ů": "U",
      "Ű": "U",
      "Ų": "U",
      "ũ": "u",
      "ū": "u",
      "ŭ": "u",
      "ů": "u",
      "ű": "u",
      "ų": "u",
      "Ŵ": "W",
      "ŵ": "w",
      "Ŷ": "Y",
      "ŷ": "y",
      "Ÿ": "Y",
      "Ź": "Z",
      "Ż": "Z",
      "Ž": "Z",
      "ź": "z",
      "ż": "z",
      "ž": "z",
      "Ĳ": "IJ",
      "ĳ": "ij",
      "Œ": "Oe",
      "œ": "oe",
      "ŉ": "'n",
      "ſ": "s"
    };
    var deburrLetter = basePropertyOf(deburredLetters);
    module2.exports = deburrLetter;
  }
});

// node_modules/lodash/deburr.js
var require_deburr = __commonJS({
  "node_modules/lodash/deburr.js"(exports2, module2) {
    var deburrLetter = require_deburrLetter();
    var toString7 = require_toString();
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsCombo = "[" + rsComboRange + "]";
    var reComboMark = RegExp(rsCombo, "g");
    function deburr(string2) {
      string2 = toString7(string2);
      return string2 && string2.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    module2.exports = deburr;
  }
});

// node_modules/lodash/_asciiWords.js
var require_asciiWords = __commonJS({
  "node_modules/lodash/_asciiWords.js"(exports2, module2) {
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    function asciiWords(string2) {
      return string2.match(reAsciiWord) || [];
    }
    module2.exports = asciiWords;
  }
});

// node_modules/lodash/_hasUnicodeWord.js
var require_hasUnicodeWord = __commonJS({
  "node_modules/lodash/_hasUnicodeWord.js"(exports2, module2) {
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    function hasUnicodeWord(string2) {
      return reHasUnicodeWord.test(string2);
    }
    module2.exports = hasUnicodeWord;
  }
});

// node_modules/lodash/_unicodeWords.js
var require_unicodeWords = __commonJS({
  "node_modules/lodash/_unicodeWords.js"(exports2, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['’]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])";
    var rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq;
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
      rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
      rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
      rsUpper + "+" + rsOptContrUpper,
      rsOrdUpper,
      rsOrdLower,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    function unicodeWords(string2) {
      return string2.match(reUnicodeWord) || [];
    }
    module2.exports = unicodeWords;
  }
});

// node_modules/lodash/words.js
var require_words = __commonJS({
  "node_modules/lodash/words.js"(exports2, module2) {
    var asciiWords = require_asciiWords();
    var hasUnicodeWord = require_hasUnicodeWord();
    var toString7 = require_toString();
    var unicodeWords = require_unicodeWords();
    function words(string2, pattern, guard) {
      string2 = toString7(string2);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string2) ? unicodeWords(string2) : asciiWords(string2);
      }
      return string2.match(pattern) || [];
    }
    module2.exports = words;
  }
});

// node_modules/lodash/_createCompounder.js
var require_createCompounder = __commonJS({
  "node_modules/lodash/_createCompounder.js"(exports2, module2) {
    var arrayReduce = require_arrayReduce();
    var deburr = require_deburr();
    var words = require_words();
    var rsApos = "['’]";
    var reApos = RegExp(rsApos, "g");
    function createCompounder(callback) {
      return function(string2) {
        return arrayReduce(words(deburr(string2).replace(reApos, "")), callback, "");
      };
    }
    module2.exports = createCompounder;
  }
});

// node_modules/lodash/snakeCase.js
var require_snakeCase = __commonJS({
  "node_modules/lodash/snakeCase.js"(exports2, module2) {
    var createCompounder = require_createCompounder();
    var snakeCase2 = createCompounder(function(result, word, index2) {
      return result + (index2 ? "_" : "") + word.toLowerCase();
    });
    module2.exports = snakeCase2;
  }
});

// node_modules/lodash/_baseSlice.js
var require_baseSlice = __commonJS({
  "node_modules/lodash/_baseSlice.js"(exports2, module2) {
    function baseSlice2(array2, start3, end2) {
      var index2 = -1, length = array2.length;
      if (start3 < 0) {
        start3 = -start3 > length ? 0 : length + start3;
      }
      end2 = end2 > length ? length : end2;
      if (end2 < 0) {
        end2 += length;
      }
      length = start3 > end2 ? 0 : end2 - start3 >>> 0;
      start3 >>>= 0;
      var result = Array(length);
      while (++index2 < length) {
        result[index2] = array2[index2 + start3];
      }
      return result;
    }
    module2.exports = baseSlice2;
  }
});

// node_modules/lodash/_castSlice.js
var require_castSlice = __commonJS({
  "node_modules/lodash/_castSlice.js"(exports2, module2) {
    var baseSlice2 = require_baseSlice();
    function castSlice(array2, start3, end2) {
      var length = array2.length;
      end2 = end2 === void 0 ? length : end2;
      return !start3 && end2 >= length ? array2 : baseSlice2(array2, start3, end2);
    }
    module2.exports = castSlice;
  }
});

// node_modules/lodash/_hasUnicode.js
var require_hasUnicode = __commonJS({
  "node_modules/lodash/_hasUnicode.js"(exports2, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsZWJ = "\\u200d";
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
    function hasUnicode(string2) {
      return reHasUnicode.test(string2);
    }
    module2.exports = hasUnicode;
  }
});

// node_modules/lodash/_asciiToArray.js
var require_asciiToArray = __commonJS({
  "node_modules/lodash/_asciiToArray.js"(exports2, module2) {
    function asciiToArray(string2) {
      return string2.split("");
    }
    module2.exports = asciiToArray;
  }
});

// node_modules/lodash/_unicodeToArray.js
var require_unicodeToArray = __commonJS({
  "node_modules/lodash/_unicodeToArray.js"(exports2, module2) {
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f";
    var reComboHalfMarksRange = "\\ufe20-\\ufe2f";
    var rsComboSymbolsRange = "\\u20d0-\\u20ff";
    var rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange;
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsCombo = "[" + rsComboRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsZWJ = "\\u200d";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    function unicodeToArray(string2) {
      return string2.match(reUnicode) || [];
    }
    module2.exports = unicodeToArray;
  }
});

// node_modules/lodash/_stringToArray.js
var require_stringToArray = __commonJS({
  "node_modules/lodash/_stringToArray.js"(exports2, module2) {
    var asciiToArray = require_asciiToArray();
    var hasUnicode = require_hasUnicode();
    var unicodeToArray = require_unicodeToArray();
    function stringToArray(string2) {
      return hasUnicode(string2) ? unicodeToArray(string2) : asciiToArray(string2);
    }
    module2.exports = stringToArray;
  }
});

// node_modules/lodash/_createCaseFirst.js
var require_createCaseFirst = __commonJS({
  "node_modules/lodash/_createCaseFirst.js"(exports2, module2) {
    var castSlice = require_castSlice();
    var hasUnicode = require_hasUnicode();
    var stringToArray = require_stringToArray();
    var toString7 = require_toString();
    function createCaseFirst(methodName) {
      return function(string2) {
        string2 = toString7(string2);
        var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
        var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    module2.exports = createCaseFirst;
  }
});

// node_modules/lodash/upperFirst.js
var require_upperFirst = __commonJS({
  "node_modules/lodash/upperFirst.js"(exports2, module2) {
    var createCaseFirst = require_createCaseFirst();
    var upperFirst = createCaseFirst("toUpperCase");
    module2.exports = upperFirst;
  }
});

// node_modules/lodash/capitalize.js
var require_capitalize = __commonJS({
  "node_modules/lodash/capitalize.js"(exports2, module2) {
    var toString7 = require_toString();
    var upperFirst = require_upperFirst();
    function capitalize3(string2) {
      return upperFirst(toString7(string2).toLowerCase());
    }
    module2.exports = capitalize3;
  }
});

// node_modules/lodash/camelCase.js
var require_camelCase = __commonJS({
  "node_modules/lodash/camelCase.js"(exports2, module2) {
    var capitalize3 = require_capitalize();
    var createCompounder = require_createCompounder();
    var camelCase2 = createCompounder(function(result, word, index2) {
      word = word.toLowerCase();
      return result + (index2 ? capitalize3(word) : word);
    });
    module2.exports = camelCase2;
  }
});

// node_modules/lodash/mapKeys.js
var require_mapKeys = __commonJS({
  "node_modules/lodash/mapKeys.js"(exports2, module2) {
    var baseAssignValue5 = require_baseAssignValue();
    var baseForOwn3 = require_baseForOwn();
    var baseIteratee3 = require_baseIteratee();
    function mapKeys2(object2, iteratee) {
      var result = {};
      iteratee = baseIteratee3(iteratee, 3);
      baseForOwn3(object2, function(value, key, object3) {
        baseAssignValue5(result, iteratee(value, key, object3), value);
      });
      return result;
    }
    module2.exports = mapKeys2;
  }
});

// node_modules/toposort/index.js
var require_toposort = __commonJS({
  "node_modules/toposort/index.js"(exports2, module2) {
    module2.exports = function(edges) {
      return toposort2(uniqueNodes(edges), edges);
    };
    module2.exports.array = toposort2;
    function toposort2(nodes, edges) {
      var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i15 = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);
      edges.forEach(function(edge) {
        if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {
          throw new Error("Unknown node. There is an unknown node in the supplied edges.");
        }
      });
      while (i15--) {
        if (!visited[i15])
          visit2(nodes[i15], i15, /* @__PURE__ */ new Set());
      }
      return sorted;
      function visit2(node, i16, predecessors) {
        if (predecessors.has(node)) {
          var nodeRep;
          try {
            nodeRep = ", node was:" + JSON.stringify(node);
          } catch (e9) {
            nodeRep = "";
          }
          throw new Error("Cyclic dependency" + nodeRep);
        }
        if (!nodesHash.has(node)) {
          throw new Error("Found unknown node. Make sure to provided all involved nodes. Unknown node: " + JSON.stringify(node));
        }
        if (visited[i16])
          return;
        visited[i16] = true;
        var outgoing = outgoingEdges.get(node) || /* @__PURE__ */ new Set();
        outgoing = Array.from(outgoing);
        if (i16 = outgoing.length) {
          predecessors.add(node);
          do {
            var child = outgoing[--i16];
            visit2(child, nodesHash.get(child), predecessors);
          } while (i16);
          predecessors.delete(node);
        }
        sorted[--cursor] = node;
      }
    }
    function uniqueNodes(arr) {
      var res = /* @__PURE__ */ new Set();
      for (var i15 = 0, len = arr.length; i15 < len; i15++) {
        var edge = arr[i15];
        res.add(edge[0]);
        res.add(edge[1]);
      }
      return Array.from(res);
    }
    function makeOutgoingEdges(arr) {
      var edges = /* @__PURE__ */ new Map();
      for (var i15 = 0, len = arr.length; i15 < len; i15++) {
        var edge = arr[i15];
        if (!edges.has(edge[0]))
          edges.set(edge[0], /* @__PURE__ */ new Set());
        if (!edges.has(edge[1]))
          edges.set(edge[1], /* @__PURE__ */ new Set());
        edges.get(edge[0]).add(edge[1]);
      }
      return edges;
    }
    function makeNodesHash(arr) {
      var res = /* @__PURE__ */ new Map();
      for (var i15 = 0, len = arr.length; i15 < len; i15++) {
        res.set(arr[i15], i15);
      }
      return res;
    }
  }
});

// node_modules/url-pattern/lib/url-pattern.js
var require_url_pattern = __commonJS({
  "node_modules/url-pattern/lib/url-pattern.js"(exports2, module2) {
    var slice = [].slice;
    (function(root6, factory) {
      if ("function" === typeof define && define.amd != null) {
        return define([], factory);
      } else if (typeof exports2 !== "undefined" && exports2 !== null) {
        return module2.exports = factory();
      } else {
        return root6.UrlPattern = factory();
      }
    })(exports2, function() {
      var P6, UrlPattern2, astNodeContainsSegmentsForProvidedParams, astNodeToNames, astNodeToRegexString, baseAstNodeToRegexString, concatMap, defaultOptions, escapeForRegex, getParam, keysAndValuesToObject, newParser, regexGroupCount, stringConcatMap, stringify;
      escapeForRegex = function(string2) {
        return string2.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
      };
      concatMap = function(array2, f16) {
        var i15, length, results;
        results = [];
        i15 = -1;
        length = array2.length;
        while (++i15 < length) {
          results = results.concat(f16(array2[i15]));
        }
        return results;
      };
      stringConcatMap = function(array2, f16) {
        var i15, length, result;
        result = "";
        i15 = -1;
        length = array2.length;
        while (++i15 < length) {
          result += f16(array2[i15]);
        }
        return result;
      };
      regexGroupCount = function(regex) {
        return new RegExp(regex.toString() + "|").exec("").length - 1;
      };
      keysAndValuesToObject = function(keys6, values3) {
        var i15, key, length, object2, value;
        object2 = {};
        i15 = -1;
        length = keys6.length;
        while (++i15 < length) {
          key = keys6[i15];
          value = values3[i15];
          if (value == null) {
            continue;
          }
          if (object2[key] != null) {
            if (!Array.isArray(object2[key])) {
              object2[key] = [object2[key]];
            }
            object2[key].push(value);
          } else {
            object2[key] = value;
          }
        }
        return object2;
      };
      P6 = {};
      P6.Result = function(value, rest) {
        this.value = value;
        this.rest = rest;
      };
      P6.Tagged = function(tag, value) {
        this.tag = tag;
        this.value = value;
      };
      P6.tag = function(tag, parser) {
        return function(input) {
          var result, tagged;
          result = parser(input);
          if (result == null) {
            return;
          }
          tagged = new P6.Tagged(tag, result.value);
          return new P6.Result(tagged, result.rest);
        };
      };
      P6.regex = function(regex) {
        return function(input) {
          var matches, result;
          matches = regex.exec(input);
          if (matches == null) {
            return;
          }
          result = matches[0];
          return new P6.Result(result, input.slice(result.length));
        };
      };
      P6.sequence = function() {
        var parsers;
        parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return function(input) {
          var i15, length, parser, rest, result, values3;
          i15 = -1;
          length = parsers.length;
          values3 = [];
          rest = input;
          while (++i15 < length) {
            parser = parsers[i15];
            result = parser(rest);
            if (result == null) {
              return;
            }
            values3.push(result.value);
            rest = result.rest;
          }
          return new P6.Result(values3, rest);
        };
      };
      P6.pick = function() {
        var indexes, parsers;
        indexes = arguments[0], parsers = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        return function(input) {
          var array2, result;
          result = P6.sequence.apply(P6, parsers)(input);
          if (result == null) {
            return;
          }
          array2 = result.value;
          result.value = array2[indexes];
          return result;
        };
      };
      P6.string = function(string2) {
        var length;
        length = string2.length;
        return function(input) {
          if (input.slice(0, length) === string2) {
            return new P6.Result(string2, input.slice(length));
          }
        };
      };
      P6.lazy = function(fn2) {
        var cached;
        cached = null;
        return function(input) {
          if (cached == null) {
            cached = fn2();
          }
          return cached(input);
        };
      };
      P6.baseMany = function(parser, end2, stringResult, atLeastOneResultRequired, input) {
        var endResult, parserResult, rest, results;
        rest = input;
        results = stringResult ? "" : [];
        while (true) {
          if (end2 != null) {
            endResult = end2(rest);
            if (endResult != null) {
              break;
            }
          }
          parserResult = parser(rest);
          if (parserResult == null) {
            break;
          }
          if (stringResult) {
            results += parserResult.value;
          } else {
            results.push(parserResult.value);
          }
          rest = parserResult.rest;
        }
        if (atLeastOneResultRequired && results.length === 0) {
          return;
        }
        return new P6.Result(results, rest);
      };
      P6.many1 = function(parser) {
        return function(input) {
          return P6.baseMany(parser, null, false, true, input);
        };
      };
      P6.concatMany1Till = function(parser, end2) {
        return function(input) {
          return P6.baseMany(parser, end2, true, true, input);
        };
      };
      P6.firstChoice = function() {
        var parsers;
        parsers = 1 <= arguments.length ? slice.call(arguments, 0) : [];
        return function(input) {
          var i15, length, parser, result;
          i15 = -1;
          length = parsers.length;
          while (++i15 < length) {
            parser = parsers[i15];
            result = parser(input);
            if (result != null) {
              return result;
            }
          }
        };
      };
      newParser = function(options) {
        var U6;
        U6 = {};
        U6.wildcard = P6.tag("wildcard", P6.string(options.wildcardChar));
        U6.optional = P6.tag("optional", P6.pick(1, P6.string(options.optionalSegmentStartChar), P6.lazy(function() {
          return U6.pattern;
        }), P6.string(options.optionalSegmentEndChar)));
        U6.name = P6.regex(new RegExp("^[" + options.segmentNameCharset + "]+"));
        U6.named = P6.tag("named", P6.pick(1, P6.string(options.segmentNameStartChar), P6.lazy(function() {
          return U6.name;
        })));
        U6.escapedChar = P6.pick(1, P6.string(options.escapeChar), P6.regex(/^./));
        U6["static"] = P6.tag("static", P6.concatMany1Till(P6.firstChoice(P6.lazy(function() {
          return U6.escapedChar;
        }), P6.regex(/^./)), P6.firstChoice(P6.string(options.segmentNameStartChar), P6.string(options.optionalSegmentStartChar), P6.string(options.optionalSegmentEndChar), U6.wildcard)));
        U6.token = P6.lazy(function() {
          return P6.firstChoice(U6.wildcard, U6.optional, U6.named, U6["static"]);
        });
        U6.pattern = P6.many1(P6.lazy(function() {
          return U6.token;
        }));
        return U6;
      };
      defaultOptions = {
        escapeChar: "\\",
        segmentNameStartChar: ":",
        segmentValueCharset: "a-zA-Z0-9-_~ %",
        segmentNameCharset: "a-zA-Z0-9",
        optionalSegmentStartChar: "(",
        optionalSegmentEndChar: ")",
        wildcardChar: "*"
      };
      baseAstNodeToRegexString = function(astNode, segmentValueCharset) {
        if (Array.isArray(astNode)) {
          return stringConcatMap(astNode, function(node) {
            return baseAstNodeToRegexString(node, segmentValueCharset);
          });
        }
        switch (astNode.tag) {
          case "wildcard":
            return "(.*?)";
          case "named":
            return "([" + segmentValueCharset + "]+)";
          case "static":
            return escapeForRegex(astNode.value);
          case "optional":
            return "(?:" + baseAstNodeToRegexString(astNode.value, segmentValueCharset) + ")?";
        }
      };
      astNodeToRegexString = function(astNode, segmentValueCharset) {
        if (segmentValueCharset == null) {
          segmentValueCharset = defaultOptions.segmentValueCharset;
        }
        return "^" + baseAstNodeToRegexString(astNode, segmentValueCharset) + "$";
      };
      astNodeToNames = function(astNode) {
        if (Array.isArray(astNode)) {
          return concatMap(astNode, astNodeToNames);
        }
        switch (astNode.tag) {
          case "wildcard":
            return ["_"];
          case "named":
            return [astNode.value];
          case "static":
            return [];
          case "optional":
            return astNodeToNames(astNode.value);
        }
      };
      getParam = function(params, key, nextIndexes, sideEffects) {
        var index2, maxIndex, result, value;
        if (sideEffects == null) {
          sideEffects = false;
        }
        value = params[key];
        if (value == null) {
          if (sideEffects) {
            throw new Error("no values provided for key `" + key + "`");
          } else {
            return;
          }
        }
        index2 = nextIndexes[key] || 0;
        maxIndex = Array.isArray(value) ? value.length - 1 : 0;
        if (index2 > maxIndex) {
          if (sideEffects) {
            throw new Error("too few values provided for key `" + key + "`");
          } else {
            return;
          }
        }
        result = Array.isArray(value) ? value[index2] : value;
        if (sideEffects) {
          nextIndexes[key] = index2 + 1;
        }
        return result;
      };
      astNodeContainsSegmentsForProvidedParams = function(astNode, params, nextIndexes) {
        var i15, length;
        if (Array.isArray(astNode)) {
          i15 = -1;
          length = astNode.length;
          while (++i15 < length) {
            if (astNodeContainsSegmentsForProvidedParams(astNode[i15], params, nextIndexes)) {
              return true;
            }
          }
          return false;
        }
        switch (astNode.tag) {
          case "wildcard":
            return getParam(params, "_", nextIndexes, false) != null;
          case "named":
            return getParam(params, astNode.value, nextIndexes, false) != null;
          case "static":
            return false;
          case "optional":
            return astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes);
        }
      };
      stringify = function(astNode, params, nextIndexes) {
        if (Array.isArray(astNode)) {
          return stringConcatMap(astNode, function(node) {
            return stringify(node, params, nextIndexes);
          });
        }
        switch (astNode.tag) {
          case "wildcard":
            return getParam(params, "_", nextIndexes, true);
          case "named":
            return getParam(params, astNode.value, nextIndexes, true);
          case "static":
            return astNode.value;
          case "optional":
            if (astNodeContainsSegmentsForProvidedParams(astNode.value, params, nextIndexes)) {
              return stringify(astNode.value, params, nextIndexes);
            } else {
              return "";
            }
        }
      };
      UrlPattern2 = function(arg1, arg2) {
        var groupCount, options, parsed, parser, withoutWhitespace;
        if (arg1 instanceof UrlPattern2) {
          this.isRegex = arg1.isRegex;
          this.regex = arg1.regex;
          this.ast = arg1.ast;
          this.names = arg1.names;
          return;
        }
        this.isRegex = arg1 instanceof RegExp;
        if (!("string" === typeof arg1 || this.isRegex)) {
          throw new TypeError("argument must be a regex or a string");
        }
        if (this.isRegex) {
          this.regex = arg1;
          if (arg2 != null) {
            if (!Array.isArray(arg2)) {
              throw new Error("if first argument is a regex the second argument may be an array of group names but you provided something else");
            }
            groupCount = regexGroupCount(this.regex);
            if (arg2.length !== groupCount) {
              throw new Error("regex contains " + groupCount + " groups but array of group names contains " + arg2.length);
            }
            this.names = arg2;
          }
          return;
        }
        if (arg1 === "") {
          throw new Error("argument must not be the empty string");
        }
        withoutWhitespace = arg1.replace(/\s+/g, "");
        if (withoutWhitespace !== arg1) {
          throw new Error("argument must not contain whitespace");
        }
        options = {
          escapeChar: (arg2 != null ? arg2.escapeChar : void 0) || defaultOptions.escapeChar,
          segmentNameStartChar: (arg2 != null ? arg2.segmentNameStartChar : void 0) || defaultOptions.segmentNameStartChar,
          segmentNameCharset: (arg2 != null ? arg2.segmentNameCharset : void 0) || defaultOptions.segmentNameCharset,
          segmentValueCharset: (arg2 != null ? arg2.segmentValueCharset : void 0) || defaultOptions.segmentValueCharset,
          optionalSegmentStartChar: (arg2 != null ? arg2.optionalSegmentStartChar : void 0) || defaultOptions.optionalSegmentStartChar,
          optionalSegmentEndChar: (arg2 != null ? arg2.optionalSegmentEndChar : void 0) || defaultOptions.optionalSegmentEndChar,
          wildcardChar: (arg2 != null ? arg2.wildcardChar : void 0) || defaultOptions.wildcardChar
        };
        parser = newParser(options);
        parsed = parser.pattern(arg1);
        if (parsed == null) {
          throw new Error("couldn't parse pattern");
        }
        if (parsed.rest !== "") {
          throw new Error("could only partially parse pattern");
        }
        this.ast = parsed.value;
        this.regex = new RegExp(astNodeToRegexString(this.ast, options.segmentValueCharset));
        this.names = astNodeToNames(this.ast);
      };
      UrlPattern2.prototype.match = function(url) {
        var groups, match5;
        match5 = this.regex.exec(url);
        if (match5 == null) {
          return null;
        }
        groups = match5.slice(1);
        if (this.names) {
          return keysAndValuesToObject(this.names, groups);
        } else {
          return groups;
        }
      };
      UrlPattern2.prototype.stringify = function(params) {
        if (params == null) {
          params = {};
        }
        if (this.isRegex) {
          throw new Error("can't stringify patterns generated from a regex");
        }
        if (params !== Object(params)) {
          throw new Error("argument must be an object or undefined");
        }
        return stringify(this.ast, params, {});
      };
      UrlPattern2.escapeForRegex = escapeForRegex;
      UrlPattern2.concatMap = concatMap;
      UrlPattern2.stringConcatMap = stringConcatMap;
      UrlPattern2.regexGroupCount = regexGroupCount;
      UrlPattern2.keysAndValuesToObject = keysAndValuesToObject;
      UrlPattern2.P = P6;
      UrlPattern2.newParser = newParser;
      UrlPattern2.defaultOptions = defaultOptions;
      UrlPattern2.astNodeToRegexString = astNodeToRegexString;
      UrlPattern2.astNodeToNames = astNodeToNames;
      UrlPattern2.getParam = getParam;
      UrlPattern2.astNodeContainsSegmentsForProvidedParams = astNodeContainsSegmentsForProvidedParams;
      UrlPattern2.stringify = stringify;
      return UrlPattern2;
    });
  }
});

// (disabled):node_modules/object-inspect/util.inspect
var require_util2 = __commonJS({
  "(disabled):node_modules/object-inspect/util.inspect"() {
  }
});

// node_modules/object-inspect/index.js
var require_object_inspect = __commonJS({
  "node_modules/object-inspect/index.js"(exports2, module2) {
    var hasMap = typeof Map === "function" && Map.prototype;
    var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
    var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
    var mapForEach = hasMap && Map.prototype.forEach;
    var hasSet = typeof Set === "function" && Set.prototype;
    var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
    var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
    var setForEach = hasSet && Set.prototype.forEach;
    var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
    var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
    var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
    var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
    var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
    var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
    var booleanValueOf = Boolean.prototype.valueOf;
    var objectToString6 = Object.prototype.toString;
    var functionToString = Function.prototype.toString;
    var $match = String.prototype.match;
    var $slice = String.prototype.slice;
    var $replace = String.prototype.replace;
    var $toUpperCase = String.prototype.toUpperCase;
    var $toLowerCase = String.prototype.toLowerCase;
    var $test = RegExp.prototype.test;
    var $concat = Array.prototype.concat;
    var $join = Array.prototype.join;
    var $arrSlice = Array.prototype.slice;
    var $floor = Math.floor;
    var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
    var gOPS = Object.getOwnPropertySymbols;
    var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
    var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
    var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
    var isEnumerable = Object.prototype.propertyIsEnumerable;
    var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O5) {
      return O5.__proto__;
    } : null);
    function addNumericSeparator(num, str) {
      if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str)) {
        return str;
      }
      var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
      if (typeof num === "number") {
        var int = num < 0 ? -$floor(-num) : $floor(num);
        if (int !== num) {
          var intStr = String(int);
          var dec = $slice.call(str, intStr.length + 1);
          return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
        }
      }
      return $replace.call(str, sepRegex, "$&_");
    }
    var utilInspect = require_util2();
    var inspectCustom = utilInspect.custom;
    var inspectSymbol = isSymbol3(inspectCustom) ? inspectCustom : null;
    module2.exports = function inspect_(obj, options, depth, seen) {
      var opts = options || {};
      if (has4(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
      }
      if (has4(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
      }
      var customInspect = has4(opts, "customInspect") ? opts.customInspect : true;
      if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
      }
      if (has4(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
      }
      if (has4(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
      }
      var numericSeparator = opts.numericSeparator;
      if (typeof obj === "undefined") {
        return "undefined";
      }
      if (obj === null) {
        return "null";
      }
      if (typeof obj === "boolean") {
        return obj ? "true" : "false";
      }
      if (typeof obj === "string") {
        return inspectString(obj, opts);
      }
      if (typeof obj === "number") {
        if (obj === 0) {
          return Infinity / obj > 0 ? "0" : "-0";
        }
        var str = String(obj);
        return numericSeparator ? addNumericSeparator(obj, str) : str;
      }
      if (typeof obj === "bigint") {
        var bigIntStr = String(obj) + "n";
        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
      }
      var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
      if (typeof depth === "undefined") {
        depth = 0;
      }
      if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
        return isArray10(obj) ? "[Array]" : "[Object]";
      }
      var indent2 = getIndent(opts, depth);
      if (typeof seen === "undefined") {
        seen = [];
      } else if (indexOf2(seen, obj) >= 0) {
        return "[Circular]";
      }
      function inspect3(value, from2, noIndent) {
        if (from2) {
          seen = $arrSlice.call(seen);
          seen.push(from2);
        }
        if (noIndent) {
          var newOpts = {
            depth: opts.depth
          };
          if (has4(opts, "quoteStyle")) {
            newOpts.quoteStyle = opts.quoteStyle;
          }
          return inspect_(value, newOpts, depth + 1, seen);
        }
        return inspect_(value, opts, depth + 1, seen);
      }
      if (typeof obj === "function" && !isRegExp(obj)) {
        var name2 = nameOf(obj);
        var keys6 = arrObjKeys(obj, inspect3);
        return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys6.length > 0 ? " { " + $join.call(keys6, ", ") + " }" : "");
      }
      if (isSymbol3(obj)) {
        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
        return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
      }
      if (isElement5(obj)) {
        var s20 = "<" + $toLowerCase.call(String(obj.nodeName));
        var attrs = obj.attributes || [];
        for (var i15 = 0; i15 < attrs.length; i15++) {
          s20 += " " + attrs[i15].name + "=" + wrapQuotes(quote(attrs[i15].value), "double", opts);
        }
        s20 += ">";
        if (obj.childNodes && obj.childNodes.length) {
          s20 += "...";
        }
        s20 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
        return s20;
      }
      if (isArray10(obj)) {
        if (obj.length === 0) {
          return "[]";
        }
        var xs = arrObjKeys(obj, inspect3);
        if (indent2 && !singleLineValues(xs)) {
          return "[" + indentedJoin(xs, indent2) + "]";
        }
        return "[ " + $join.call(xs, ", ") + " ]";
      }
      if (isError2(obj)) {
        var parts = arrObjKeys(obj, inspect3);
        if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
          return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect3(obj.cause), parts), ", ") + " }";
        }
        if (parts.length === 0) {
          return "[" + String(obj) + "]";
        }
        return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
      }
      if (typeof obj === "object" && customInspect) {
        if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
          return utilInspect(obj, { depth: maxDepth - depth });
        } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
          return obj.inspect();
        }
      }
      if (isMap4(obj)) {
        var mapParts = [];
        if (mapForEach) {
          mapForEach.call(obj, function(value, key) {
            mapParts.push(inspect3(key, obj, true) + " => " + inspect3(value, obj));
          });
        }
        return collectionOf("Map", mapSize.call(obj), mapParts, indent2);
      }
      if (isSet4(obj)) {
        var setParts = [];
        if (setForEach) {
          setForEach.call(obj, function(value) {
            setParts.push(inspect3(value, obj));
          });
        }
        return collectionOf("Set", setSize.call(obj), setParts, indent2);
      }
      if (isWeakMap(obj)) {
        return weakCollectionOf("WeakMap");
      }
      if (isWeakSet(obj)) {
        return weakCollectionOf("WeakSet");
      }
      if (isWeakRef(obj)) {
        return weakCollectionOf("WeakRef");
      }
      if (isNumber2(obj)) {
        return markBoxed(inspect3(Number(obj)));
      }
      if (isBigInt(obj)) {
        return markBoxed(inspect3(bigIntValueOf.call(obj)));
      }
      if (isBoolean2(obj)) {
        return markBoxed(booleanValueOf.call(obj));
      }
      if (isString2(obj)) {
        return markBoxed(inspect3(String(obj)));
      }
      if (!isDate4(obj) && !isRegExp(obj)) {
        var ys = arrObjKeys(obj, inspect3);
        var isPlainObject7 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
        var protoTag = obj instanceof Object ? "" : "null prototype";
        var stringTag6 = !isPlainObject7 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
        var constructorTag = isPlainObject7 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
        var tag = constructorTag + (stringTag6 || protoTag ? "[" + $join.call($concat.call([], stringTag6 || [], protoTag || []), ": ") + "] " : "");
        if (ys.length === 0) {
          return tag + "{}";
        }
        if (indent2) {
          return tag + "{" + indentedJoin(ys, indent2) + "}";
        }
        return tag + "{ " + $join.call(ys, ", ") + " }";
      }
      return String(obj);
    };
    function wrapQuotes(s20, defaultStyle, opts) {
      var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
      return quoteChar + s20 + quoteChar;
    }
    function quote(s20) {
      return $replace.call(String(s20), /"/g, "&quot;");
    }
    function isArray10(obj) {
      return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isDate4(obj) {
      return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isRegExp(obj) {
      return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isError2(obj) {
      return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isString2(obj) {
      return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isNumber2(obj) {
      return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isBoolean2(obj) {
      return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
    }
    function isSymbol3(obj) {
      if (hasShammedSymbols) {
        return obj && typeof obj === "object" && obj instanceof Symbol;
      }
      if (typeof obj === "symbol") {
        return true;
      }
      if (!obj || typeof obj !== "object" || !symToString) {
        return false;
      }
      try {
        symToString.call(obj);
        return true;
      } catch (e9) {
      }
      return false;
    }
    function isBigInt(obj) {
      if (!obj || typeof obj !== "object" || !bigIntValueOf) {
        return false;
      }
      try {
        bigIntValueOf.call(obj);
        return true;
      } catch (e9) {
      }
      return false;
    }
    var hasOwn = Object.prototype.hasOwnProperty || function(key) {
      return key in this;
    };
    function has4(obj, key) {
      return hasOwn.call(obj, key);
    }
    function toStr(obj) {
      return objectToString6.call(obj);
    }
    function nameOf(f16) {
      if (f16.name) {
        return f16.name;
      }
      var m10 = $match.call(functionToString.call(f16), /^function\s*([\w$]+)/);
      if (m10) {
        return m10[1];
      }
      return null;
    }
    function indexOf2(xs, x7) {
      if (xs.indexOf) {
        return xs.indexOf(x7);
      }
      for (var i15 = 0, l14 = xs.length; i15 < l14; i15++) {
        if (xs[i15] === x7) {
          return i15;
        }
      }
      return -1;
    }
    function isMap4(x7) {
      if (!mapSize || !x7 || typeof x7 !== "object") {
        return false;
      }
      try {
        mapSize.call(x7);
        try {
          setSize.call(x7);
        } catch (s20) {
          return true;
        }
        return x7 instanceof Map;
      } catch (e9) {
      }
      return false;
    }
    function isWeakMap(x7) {
      if (!weakMapHas || !x7 || typeof x7 !== "object") {
        return false;
      }
      try {
        weakMapHas.call(x7, weakMapHas);
        try {
          weakSetHas.call(x7, weakSetHas);
        } catch (s20) {
          return true;
        }
        return x7 instanceof WeakMap;
      } catch (e9) {
      }
      return false;
    }
    function isWeakRef(x7) {
      if (!weakRefDeref || !x7 || typeof x7 !== "object") {
        return false;
      }
      try {
        weakRefDeref.call(x7);
        return true;
      } catch (e9) {
      }
      return false;
    }
    function isSet4(x7) {
      if (!setSize || !x7 || typeof x7 !== "object") {
        return false;
      }
      try {
        setSize.call(x7);
        try {
          mapSize.call(x7);
        } catch (m10) {
          return true;
        }
        return x7 instanceof Set;
      } catch (e9) {
      }
      return false;
    }
    function isWeakSet(x7) {
      if (!weakSetHas || !x7 || typeof x7 !== "object") {
        return false;
      }
      try {
        weakSetHas.call(x7, weakSetHas);
        try {
          weakMapHas.call(x7, weakMapHas);
        } catch (s20) {
          return true;
        }
        return x7 instanceof WeakSet;
      } catch (e9) {
      }
      return false;
    }
    function isElement5(x7) {
      if (!x7 || typeof x7 !== "object") {
        return false;
      }
      if (typeof HTMLElement !== "undefined" && x7 instanceof HTMLElement) {
        return true;
      }
      return typeof x7.nodeName === "string" && typeof x7.getAttribute === "function";
    }
    function inspectString(str, opts) {
      if (str.length > opts.maxStringLength) {
        var remaining = str.length - opts.maxStringLength;
        var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;
      }
      var s20 = $replace.call($replace.call(str, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
      return wrapQuotes(s20, "single", opts);
    }
    function lowbyte(c16) {
      var n12 = c16.charCodeAt(0);
      var x7 = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
      }[n12];
      if (x7) {
        return "\\" + x7;
      }
      return "\\x" + (n12 < 16 ? "0" : "") + $toUpperCase.call(n12.toString(16));
    }
    function markBoxed(str) {
      return "Object(" + str + ")";
    }
    function weakCollectionOf(type) {
      return type + " { ? }";
    }
    function collectionOf(type, size2, entries, indent2) {
      var joinedEntries = indent2 ? indentedJoin(entries, indent2) : $join.call(entries, ", ");
      return type + " (" + size2 + ") {" + joinedEntries + "}";
    }
    function singleLineValues(xs) {
      for (var i15 = 0; i15 < xs.length; i15++) {
        if (indexOf2(xs[i15], "\n") >= 0) {
          return false;
        }
      }
      return true;
    }
    function getIndent(opts, depth) {
      var baseIndent;
      if (opts.indent === "	") {
        baseIndent = "	";
      } else if (typeof opts.indent === "number" && opts.indent > 0) {
        baseIndent = $join.call(Array(opts.indent + 1), " ");
      } else {
        return null;
      }
      return {
        base: baseIndent,
        prev: $join.call(Array(depth + 1), baseIndent)
      };
    }
    function indentedJoin(xs, indent2) {
      if (xs.length === 0) {
        return "";
      }
      var lineJoiner = "\n" + indent2.prev + indent2.base;
      return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent2.prev;
    }
    function arrObjKeys(obj, inspect3) {
      var isArr = isArray10(obj);
      var xs = [];
      if (isArr) {
        xs.length = obj.length;
        for (var i15 = 0; i15 < obj.length; i15++) {
          xs[i15] = has4(obj, i15) ? inspect3(obj[i15], obj) : "";
        }
      }
      var syms = typeof gOPS === "function" ? gOPS(obj) : [];
      var symMap;
      if (hasShammedSymbols) {
        symMap = {};
        for (var k3 = 0; k3 < syms.length; k3++) {
          symMap["$" + syms[k3]] = syms[k3];
        }
      }
      for (var key in obj) {
        if (!has4(obj, key)) {
          continue;
        }
        if (isArr && String(Number(key)) === key && key < obj.length) {
          continue;
        }
        if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
          continue;
        } else if ($test.call(/[^\w$]/, key)) {
          xs.push(inspect3(key, obj) + ": " + inspect3(obj[key], obj));
        } else {
          xs.push(key + ": " + inspect3(obj[key], obj));
        }
      }
      if (typeof gOPS === "function") {
        for (var j6 = 0; j6 < syms.length; j6++) {
          if (isEnumerable.call(obj, syms[j6])) {
            xs.push("[" + inspect3(syms[j6]) + "]: " + inspect3(obj[syms[j6]], obj));
          }
        }
      }
      return xs;
    }
  }
});

// node_modules/dependency-graph/lib/dep_graph.js
var require_dep_graph = __commonJS({
  "node_modules/dependency-graph/lib/dep_graph.js"(exports2) {
    function createDFS(edges, leavesOnly, result, circular) {
      var visited = {};
      return function(start3) {
        if (visited[start3]) {
          return;
        }
        var inCurrentPath = {};
        var currentPath = [];
        var todo = [];
        todo.push({ node: start3, processed: false });
        while (todo.length > 0) {
          var current = todo[todo.length - 1];
          var processed = current.processed;
          var node = current.node;
          if (!processed) {
            if (visited[node]) {
              todo.pop();
              continue;
            } else if (inCurrentPath[node]) {
              if (circular) {
                todo.pop();
                continue;
              }
              currentPath.push(node);
              throw new DepGraphCycleError(currentPath);
            }
            inCurrentPath[node] = true;
            currentPath.push(node);
            var nodeEdges = edges[node];
            for (var i15 = nodeEdges.length - 1; i15 >= 0; i15--) {
              todo.push({ node: nodeEdges[i15], processed: false });
            }
            current.processed = true;
          } else {
            todo.pop();
            currentPath.pop();
            inCurrentPath[node] = false;
            visited[node] = true;
            if (!leavesOnly || edges[node].length === 0) {
              result.push(node);
            }
          }
        }
      };
    }
    var DepGraph2 = exports2.DepGraph = function DepGraph3(opts) {
      this.nodes = {};
      this.outgoingEdges = {};
      this.incomingEdges = {};
      this.circular = opts && !!opts.circular;
    };
    DepGraph2.prototype = {
      /**
       * The number of nodes in the graph.
       */
      size: function() {
        return Object.keys(this.nodes).length;
      },
      /**
       * Add a node to the dependency graph. If a node already exists, this method will do nothing.
       */
      addNode: function(node, data) {
        if (!this.hasNode(node)) {
          if (arguments.length === 2) {
            this.nodes[node] = data;
          } else {
            this.nodes[node] = node;
          }
          this.outgoingEdges[node] = [];
          this.incomingEdges[node] = [];
        }
      },
      /**
       * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.
       */
      removeNode: function(node) {
        if (this.hasNode(node)) {
          delete this.nodes[node];
          delete this.outgoingEdges[node];
          delete this.incomingEdges[node];
          [this.incomingEdges, this.outgoingEdges].forEach(function(edgeList) {
            Object.keys(edgeList).forEach(function(key) {
              var idx = edgeList[key].indexOf(node);
              if (idx >= 0) {
                edgeList[key].splice(idx, 1);
              }
            }, this);
          });
        }
      },
      /**
       * Check if a node exists in the graph
       */
      hasNode: function(node) {
        return this.nodes.hasOwnProperty(node);
      },
      /**
       * Get the data associated with a node name
       */
      getNodeData: function(node) {
        if (this.hasNode(node)) {
          return this.nodes[node];
        } else {
          throw new Error("Node does not exist: " + node);
        }
      },
      /**
       * Set the associated data for a given node name. If the node does not exist, this method will throw an error
       */
      setNodeData: function(node, data) {
        if (this.hasNode(node)) {
          this.nodes[node] = data;
        } else {
          throw new Error("Node does not exist: " + node);
        }
      },
      /**
       * Add a dependency between two nodes. If either of the nodes does not exist,
       * an Error will be thrown.
       */
      addDependency: function(from2, to4) {
        if (!this.hasNode(from2)) {
          throw new Error("Node does not exist: " + from2);
        }
        if (!this.hasNode(to4)) {
          throw new Error("Node does not exist: " + to4);
        }
        if (this.outgoingEdges[from2].indexOf(to4) === -1) {
          this.outgoingEdges[from2].push(to4);
        }
        if (this.incomingEdges[to4].indexOf(from2) === -1) {
          this.incomingEdges[to4].push(from2);
        }
        return true;
      },
      /**
       * Remove a dependency between two nodes.
       */
      removeDependency: function(from2, to4) {
        var idx;
        if (this.hasNode(from2)) {
          idx = this.outgoingEdges[from2].indexOf(to4);
          if (idx >= 0) {
            this.outgoingEdges[from2].splice(idx, 1);
          }
        }
        if (this.hasNode(to4)) {
          idx = this.incomingEdges[to4].indexOf(from2);
          if (idx >= 0) {
            this.incomingEdges[to4].splice(idx, 1);
          }
        }
      },
      /**
       * Return a clone of the dependency graph. If any custom data is attached
       * to the nodes, it will only be shallow copied.
       */
      clone: function() {
        var source = this;
        var result = new DepGraph2();
        var keys6 = Object.keys(source.nodes);
        keys6.forEach(function(n12) {
          result.nodes[n12] = source.nodes[n12];
          result.outgoingEdges[n12] = source.outgoingEdges[n12].slice(0);
          result.incomingEdges[n12] = source.incomingEdges[n12].slice(0);
        });
        return result;
      },
      /**
       * Get an array containing the direct dependencies of the specified node.
       *
       * Throws an Error if the specified node does not exist.
       */
      directDependenciesOf: function(node) {
        if (this.hasNode(node)) {
          return this.outgoingEdges[node].slice(0);
        } else {
          throw new Error("Node does not exist: " + node);
        }
      },
      /**
       * Get an array containing the nodes that directly depend on the specified node.
       *
       * Throws an Error if the specified node does not exist.
       */
      directDependantsOf: function(node) {
        if (this.hasNode(node)) {
          return this.incomingEdges[node].slice(0);
        } else {
          throw new Error("Node does not exist: " + node);
        }
      },
      /**
       * Get an array containing the nodes that the specified node depends on (transitively).
       *
       * Throws an Error if the graph has a cycle, or the specified node does not exist.
       *
       * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned
       * in the array.
       */
      dependenciesOf: function(node, leavesOnly) {
        if (this.hasNode(node)) {
          var result = [];
          var DFS = createDFS(
            this.outgoingEdges,
            leavesOnly,
            result,
            this.circular
          );
          DFS(node);
          var idx = result.indexOf(node);
          if (idx >= 0) {
            result.splice(idx, 1);
          }
          return result;
        } else {
          throw new Error("Node does not exist: " + node);
        }
      },
      /**
       * get an array containing the nodes that depend on the specified node (transitively).
       *
       * Throws an Error if the graph has a cycle, or the specified node does not exist.
       *
       * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.
       */
      dependantsOf: function(node, leavesOnly) {
        if (this.hasNode(node)) {
          var result = [];
          var DFS = createDFS(
            this.incomingEdges,
            leavesOnly,
            result,
            this.circular
          );
          DFS(node);
          var idx = result.indexOf(node);
          if (idx >= 0) {
            result.splice(idx, 1);
          }
          return result;
        } else {
          throw new Error("Node does not exist: " + node);
        }
      },
      /**
       * Construct the overall processing order for the dependency graph.
       *
       * Throws an Error if the graph has a cycle.
       *
       * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.
       */
      overallOrder: function(leavesOnly) {
        var self2 = this;
        var result = [];
        var keys6 = Object.keys(this.nodes);
        if (keys6.length === 0) {
          return result;
        } else {
          if (!this.circular) {
            var CycleDFS = createDFS(this.outgoingEdges, false, [], this.circular);
            keys6.forEach(function(n12) {
              CycleDFS(n12);
            });
          }
          var DFS = createDFS(
            this.outgoingEdges,
            leavesOnly,
            result,
            this.circular
          );
          keys6.filter(function(node) {
            return self2.incomingEdges[node].length === 0;
          }).forEach(function(n12) {
            DFS(n12);
          });
          if (this.circular) {
            keys6.filter(function(node) {
              return result.indexOf(node) === -1;
            }).forEach(function(n12) {
              DFS(n12);
            });
          }
          return result;
        }
      },
      /**
       * Get an array of nodes that have no dependants (i.e. nothing depends on them).
       */
      entryNodes: function() {
        var self2 = this;
        return Object.keys(this.nodes).filter(function(node) {
          return self2.incomingEdges[node].length === 0;
        });
      }
    };
    DepGraph2.prototype.directDependentsOf = DepGraph2.prototype.directDependantsOf;
    DepGraph2.prototype.dependentsOf = DepGraph2.prototype.dependantsOf;
    var DepGraphCycleError = exports2.DepGraphCycleError = function(cyclePath) {
      var message = "Dependency Cycle Found: " + cyclePath.join(" -> ");
      var instance = new Error(message);
      instance.cyclePath = cyclePath;
      Object.setPrototypeOf(instance, Object.getPrototypeOf(this));
      if (Error.captureStackTrace) {
        Error.captureStackTrace(instance, DepGraphCycleError);
      }
      return instance;
    };
    DepGraphCycleError.prototype = Object.create(Error.prototype, {
      constructor: {
        value: Error,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    Object.setPrototypeOf(DepGraphCycleError, Error);
  }
});

// node_modules/graphql/jsutils/isObjectLike.js
var require_isObjectLike2 = __commonJS({
  "node_modules/graphql/jsutils/isObjectLike.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isObjectLike6;
    function _typeof3(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof3 = function _typeof4(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof3 = function _typeof4(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof3(obj);
    }
    function isObjectLike6(value) {
      return _typeof3(value) == "object" && value !== null;
    }
  }
});

// node_modules/graphql/polyfills/symbols.js
var require_symbols = __commonJS({
  "node_modules/graphql/polyfills/symbols.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SYMBOL_TO_STRING_TAG = exports2.SYMBOL_ASYNC_ITERATOR = exports2.SYMBOL_ITERATOR = void 0;
    var SYMBOL_ITERATOR = typeof Symbol === "function" && Symbol.iterator != null ? Symbol.iterator : "@@iterator";
    exports2.SYMBOL_ITERATOR = SYMBOL_ITERATOR;
    var SYMBOL_ASYNC_ITERATOR = typeof Symbol === "function" && Symbol.asyncIterator != null ? Symbol.asyncIterator : "@@asyncIterator";
    exports2.SYMBOL_ASYNC_ITERATOR = SYMBOL_ASYNC_ITERATOR;
    var SYMBOL_TO_STRING_TAG = typeof Symbol === "function" && Symbol.toStringTag != null ? Symbol.toStringTag : "@@toStringTag";
    exports2.SYMBOL_TO_STRING_TAG = SYMBOL_TO_STRING_TAG;
  }
});

// node_modules/graphql/language/location.js
var require_location = __commonJS({
  "node_modules/graphql/language/location.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getLocation = getLocation;
    function getLocation(source, position3) {
      var lineRegexp = /\r\n|[\n\r]/g;
      var line = 1;
      var column = position3 + 1;
      var match5;
      while ((match5 = lineRegexp.exec(source.body)) && match5.index < position3) {
        line += 1;
        column = position3 + 1 - (match5.index + match5[0].length);
      }
      return {
        line,
        column
      };
    }
  }
});

// node_modules/graphql/language/printLocation.js
var require_printLocation = __commonJS({
  "node_modules/graphql/language/printLocation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printLocation = printLocation;
    exports2.printSourceLocation = printSourceLocation;
    var _location = require_location();
    function printLocation(location) {
      return printSourceLocation(location.source, (0, _location.getLocation)(location.source, location.start));
    }
    function printSourceLocation(source, sourceLocation) {
      var firstLineColumnOffset = source.locationOffset.column - 1;
      var body = whitespace(firstLineColumnOffset) + source.body;
      var lineIndex = sourceLocation.line - 1;
      var lineOffset = source.locationOffset.line - 1;
      var lineNum = sourceLocation.line + lineOffset;
      var columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
      var columnNum = sourceLocation.column + columnOffset;
      var locationStr = "".concat(source.name, ":").concat(lineNum, ":").concat(columnNum, "\n");
      var lines = body.split(/\r\n|[\n\r]/g);
      var locationLine = lines[lineIndex];
      if (locationLine.length > 120) {
        var subLineIndex = Math.floor(columnNum / 80);
        var subLineColumnNum = columnNum % 80;
        var subLines = [];
        for (var i15 = 0; i15 < locationLine.length; i15 += 80) {
          subLines.push(locationLine.slice(i15, i15 + 80));
        }
        return locationStr + printPrefixedLines([["".concat(lineNum), subLines[0]]].concat(subLines.slice(1, subLineIndex + 1).map(function(subLine) {
          return ["", subLine];
        }), [[" ", whitespace(subLineColumnNum - 1) + "^"], ["", subLines[subLineIndex + 1]]]));
      }
      return locationStr + printPrefixedLines([
        // Lines specified like this: ["prefix", "string"],
        ["".concat(lineNum - 1), lines[lineIndex - 1]],
        ["".concat(lineNum), locationLine],
        ["", whitespace(columnNum - 1) + "^"],
        ["".concat(lineNum + 1), lines[lineIndex + 1]]
      ]);
    }
    function printPrefixedLines(lines) {
      var existingLines = lines.filter(function(_ref) {
        var _7 = _ref[0], line = _ref[1];
        return line !== void 0;
      });
      var padLen = Math.max.apply(Math, existingLines.map(function(_ref2) {
        var prefix3 = _ref2[0];
        return prefix3.length;
      }));
      return existingLines.map(function(_ref3) {
        var prefix3 = _ref3[0], line = _ref3[1];
        return leftPad(padLen, prefix3) + (line ? " | " + line : " |");
      }).join("\n");
    }
    function whitespace(len) {
      return Array(len + 1).join(" ");
    }
    function leftPad(len, str) {
      return whitespace(len - str.length) + str;
    }
  }
});

// node_modules/graphql/error/GraphQLError.js
var require_GraphQLError = __commonJS({
  "node_modules/graphql/error/GraphQLError.js"(exports2) {
    "use strict";
    function _typeof3(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof3 = function _typeof4(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof3 = function _typeof4(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof3(obj);
    }
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.printError = printError;
    exports2.GraphQLError = void 0;
    var _isObjectLike = _interopRequireDefault(require_isObjectLike2());
    var _symbols = require_symbols();
    var _location = require_location();
    var _printLocation = require_printLocation();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function ownKeys7(object2, enumerableOnly) {
      var keys6 = Object.keys(object2);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object2);
        if (enumerableOnly)
          symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
          });
        keys6.push.apply(keys6, symbols);
      }
      return keys6;
    }
    function _objectSpread6(target) {
      for (var i15 = 1; i15 < arguments.length; i15++) {
        var source = arguments[i15] != null ? arguments[i15] : {};
        if (i15 % 2) {
          ownKeys7(Object(source), true).forEach(function(key) {
            _defineProperty10(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys7(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    function _defineProperty10(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
      } else {
        obj[key] = value;
      }
      return obj;
    }
    function _classCallCheck9(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    function _defineProperties(target, props) {
      for (var i15 = 0; i15 < props.length; i15++) {
        var descriptor = props[i15];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass9(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    function _inherits9(subClass, superClass) {
      if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
      }
      subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
      if (superClass)
        _setPrototypeOf3(subClass, superClass);
    }
    function _createSuper(Derived) {
      var hasNativeReflectConstruct = _isNativeReflectConstruct();
      return function _createSuperInternal() {
        var Super = _getPrototypeOf(Derived), result;
        if (hasNativeReflectConstruct) {
          var NewTarget = _getPrototypeOf(this).constructor;
          result = Reflect.construct(Super, arguments, NewTarget);
        } else {
          result = Super.apply(this, arguments);
        }
        return _possibleConstructorReturn9(this, result);
      };
    }
    function _possibleConstructorReturn9(self2, call) {
      if (call && (_typeof3(call) === "object" || typeof call === "function")) {
        return call;
      }
      return _assertThisInitialized2(self2);
    }
    function _assertThisInitialized2(self2) {
      if (self2 === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      }
      return self2;
    }
    function _wrapNativeSuper(Class) {
      var _cache = typeof Map === "function" ? /* @__PURE__ */ new Map() : void 0;
      _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
        if (Class2 === null || !_isNativeFunction(Class2))
          return Class2;
        if (typeof Class2 !== "function") {
          throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
          if (_cache.has(Class2))
            return _cache.get(Class2);
          _cache.set(Class2, Wrapper2);
        }
        function Wrapper2() {
          return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
        }
        Wrapper2.prototype = Object.create(Class2.prototype, { constructor: { value: Wrapper2, enumerable: false, writable: true, configurable: true } });
        return _setPrototypeOf3(Wrapper2, Class2);
      };
      return _wrapNativeSuper(Class);
    }
    function _construct(Parent, args, Class) {
      if (_isNativeReflectConstruct()) {
        _construct = Reflect.construct;
      } else {
        _construct = function _construct2(Parent2, args2, Class2) {
          var a13 = [null];
          a13.push.apply(a13, args2);
          var Constructor = Function.bind.apply(Parent2, a13);
          var instance = new Constructor();
          if (Class2)
            _setPrototypeOf3(instance, Class2.prototype);
          return instance;
        };
      }
      return _construct.apply(null, arguments);
    }
    function _isNativeReflectConstruct() {
      if (typeof Reflect === "undefined" || !Reflect.construct)
        return false;
      if (Reflect.construct.sham)
        return false;
      if (typeof Proxy === "function")
        return true;
      try {
        Date.prototype.toString.call(Reflect.construct(Date, [], function() {
        }));
        return true;
      } catch (e9) {
        return false;
      }
    }
    function _isNativeFunction(fn2) {
      return Function.toString.call(fn2).indexOf("[native code]") !== -1;
    }
    function _setPrototypeOf3(o16, p12) {
      _setPrototypeOf3 = Object.setPrototypeOf || function _setPrototypeOf4(o17, p13) {
        o17.__proto__ = p13;
        return o17;
      };
      return _setPrototypeOf3(o16, p12);
    }
    function _getPrototypeOf(o16) {
      _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o17) {
        return o17.__proto__ || Object.getPrototypeOf(o17);
      };
      return _getPrototypeOf(o16);
    }
    var GraphQLError2 = function(_Error) {
      _inherits9(GraphQLError3, _Error);
      var _super = _createSuper(GraphQLError3);
      function GraphQLError3(message, nodes, source, positions, path, originalError, extensions) {
        var _nodeLocations, _nodeLocations2, _nodeLocations3;
        var _this;
        _classCallCheck9(this, GraphQLError3);
        _this = _super.call(this, message);
        _this.name = "GraphQLError";
        _this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
        _this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0);
        var nodeLocations = [];
        for (var _i2 = 0, _ref3 = (_this$nodes = _this.nodes) !== null && _this$nodes !== void 0 ? _this$nodes : []; _i2 < _ref3.length; _i2++) {
          var _this$nodes;
          var _ref4 = _ref3[_i2];
          var loc = _ref4.loc;
          if (loc != null) {
            nodeLocations.push(loc);
          }
        }
        nodeLocations = undefinedIfEmpty(nodeLocations);
        _this.source = source !== null && source !== void 0 ? source : (_nodeLocations = nodeLocations) === null || _nodeLocations === void 0 ? void 0 : _nodeLocations[0].source;
        _this.positions = positions !== null && positions !== void 0 ? positions : (_nodeLocations2 = nodeLocations) === null || _nodeLocations2 === void 0 ? void 0 : _nodeLocations2.map(function(loc2) {
          return loc2.start;
        });
        _this.locations = positions && source ? positions.map(function(pos) {
          return (0, _location.getLocation)(source, pos);
        }) : (_nodeLocations3 = nodeLocations) === null || _nodeLocations3 === void 0 ? void 0 : _nodeLocations3.map(function(loc2) {
          return (0, _location.getLocation)(loc2.source, loc2.start);
        });
        _this.path = path !== null && path !== void 0 ? path : void 0;
        var originalExtensions = originalError === null || originalError === void 0 ? void 0 : originalError.extensions;
        if (extensions == null && (0, _isObjectLike.default)(originalExtensions)) {
          _this.extensions = _objectSpread6({}, originalExtensions);
        } else {
          _this.extensions = extensions !== null && extensions !== void 0 ? extensions : {};
        }
        Object.defineProperties(_assertThisInitialized2(_this), {
          message: {
            enumerable: true
          },
          locations: {
            enumerable: _this.locations != null
          },
          path: {
            enumerable: _this.path != null
          },
          extensions: {
            enumerable: _this.extensions != null && Object.keys(_this.extensions).length > 0
          },
          name: {
            enumerable: false
          },
          nodes: {
            enumerable: false
          },
          source: {
            enumerable: false
          },
          positions: {
            enumerable: false
          },
          originalError: {
            enumerable: false
          }
        });
        if (originalError !== null && originalError !== void 0 && originalError.stack) {
          Object.defineProperty(_assertThisInitialized2(_this), "stack", {
            value: originalError.stack,
            writable: true,
            configurable: true
          });
          return _possibleConstructorReturn9(_this);
        }
        if (Error.captureStackTrace) {
          Error.captureStackTrace(_assertThisInitialized2(_this), GraphQLError3);
        } else {
          Object.defineProperty(_assertThisInitialized2(_this), "stack", {
            value: Error().stack,
            writable: true,
            configurable: true
          });
        }
        return _this;
      }
      _createClass9(GraphQLError3, [{
        key: "toString",
        value: function toString7() {
          return printError(this);
        }
        // FIXME: workaround to not break chai comparisons, should be remove in v16
        // $FlowFixMe[unsupported-syntax] Flow doesn't support computed properties yet
      }, {
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get8() {
          return "Object";
        }
      }]);
      return GraphQLError3;
    }(_wrapNativeSuper(Error));
    exports2.GraphQLError = GraphQLError2;
    function undefinedIfEmpty(array2) {
      return array2 === void 0 || array2.length === 0 ? void 0 : array2;
    }
    function printError(error2) {
      var output = error2.message;
      if (error2.nodes) {
        for (var _i4 = 0, _error$nodes2 = error2.nodes; _i4 < _error$nodes2.length; _i4++) {
          var node = _error$nodes2[_i4];
          if (node.loc) {
            output += "\n\n" + (0, _printLocation.printLocation)(node.loc);
          }
        }
      } else if (error2.source && error2.locations) {
        for (var _i6 = 0, _error$locations2 = error2.locations; _i6 < _error$locations2.length; _i6++) {
          var location = _error$locations2[_i6];
          output += "\n\n" + (0, _printLocation.printSourceLocation)(error2.source, location);
        }
      }
      return output;
    }
  }
});

// node_modules/graphql/error/syntaxError.js
var require_syntaxError = __commonJS({
  "node_modules/graphql/error/syntaxError.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.syntaxError = syntaxError;
    var _GraphQLError = require_GraphQLError();
    function syntaxError(source, position3, description) {
      return new _GraphQLError.GraphQLError("Syntax Error: ".concat(description), void 0, source, [position3]);
    }
  }
});

// node_modules/graphql/language/kinds.js
var require_kinds = __commonJS({
  "node_modules/graphql/language/kinds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Kind = void 0;
    var Kind2 = Object.freeze({
      // Name
      NAME: "Name",
      // Document
      DOCUMENT: "Document",
      OPERATION_DEFINITION: "OperationDefinition",
      VARIABLE_DEFINITION: "VariableDefinition",
      SELECTION_SET: "SelectionSet",
      FIELD: "Field",
      ARGUMENT: "Argument",
      // Fragments
      FRAGMENT_SPREAD: "FragmentSpread",
      INLINE_FRAGMENT: "InlineFragment",
      FRAGMENT_DEFINITION: "FragmentDefinition",
      // Values
      VARIABLE: "Variable",
      INT: "IntValue",
      FLOAT: "FloatValue",
      STRING: "StringValue",
      BOOLEAN: "BooleanValue",
      NULL: "NullValue",
      ENUM: "EnumValue",
      LIST: "ListValue",
      OBJECT: "ObjectValue",
      OBJECT_FIELD: "ObjectField",
      // Directives
      DIRECTIVE: "Directive",
      // Types
      NAMED_TYPE: "NamedType",
      LIST_TYPE: "ListType",
      NON_NULL_TYPE: "NonNullType",
      // Type System Definitions
      SCHEMA_DEFINITION: "SchemaDefinition",
      OPERATION_TYPE_DEFINITION: "OperationTypeDefinition",
      // Type Definitions
      SCALAR_TYPE_DEFINITION: "ScalarTypeDefinition",
      OBJECT_TYPE_DEFINITION: "ObjectTypeDefinition",
      FIELD_DEFINITION: "FieldDefinition",
      INPUT_VALUE_DEFINITION: "InputValueDefinition",
      INTERFACE_TYPE_DEFINITION: "InterfaceTypeDefinition",
      UNION_TYPE_DEFINITION: "UnionTypeDefinition",
      ENUM_TYPE_DEFINITION: "EnumTypeDefinition",
      ENUM_VALUE_DEFINITION: "EnumValueDefinition",
      INPUT_OBJECT_TYPE_DEFINITION: "InputObjectTypeDefinition",
      // Directive Definitions
      DIRECTIVE_DEFINITION: "DirectiveDefinition",
      // Type System Extensions
      SCHEMA_EXTENSION: "SchemaExtension",
      // Type Extensions
      SCALAR_TYPE_EXTENSION: "ScalarTypeExtension",
      OBJECT_TYPE_EXTENSION: "ObjectTypeExtension",
      INTERFACE_TYPE_EXTENSION: "InterfaceTypeExtension",
      UNION_TYPE_EXTENSION: "UnionTypeExtension",
      ENUM_TYPE_EXTENSION: "EnumTypeExtension",
      INPUT_OBJECT_TYPE_EXTENSION: "InputObjectTypeExtension"
    });
    exports2.Kind = Kind2;
  }
});

// node_modules/graphql/jsutils/invariant.js
var require_invariant = __commonJS({
  "node_modules/graphql/jsutils/invariant.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = invariant4;
    function invariant4(condition, message) {
      var booleanCondition = Boolean(condition);
      if (!booleanCondition) {
        throw new Error(message != null ? message : "Unexpected invariant triggered.");
      }
    }
  }
});

// node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js
var require_nodejsCustomInspectSymbol = __commonJS({
  "node_modules/graphql/jsutils/nodejsCustomInspectSymbol.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var nodejsCustomInspectSymbol = typeof Symbol === "function" && typeof Symbol.for === "function" ? Symbol.for("nodejs.util.inspect.custom") : void 0;
    var _default = nodejsCustomInspectSymbol;
    exports2.default = _default;
  }
});

// node_modules/graphql/jsutils/defineInspect.js
var require_defineInspect = __commonJS({
  "node_modules/graphql/jsutils/defineInspect.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = defineInspect;
    var _invariant = _interopRequireDefault(require_invariant());
    var _nodejsCustomInspectSymbol = _interopRequireDefault(require_nodejsCustomInspectSymbol());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function defineInspect(classObject) {
      var fn2 = classObject.prototype.toJSON;
      typeof fn2 === "function" || (0, _invariant.default)(0);
      classObject.prototype.inspect = fn2;
      if (_nodejsCustomInspectSymbol.default) {
        classObject.prototype[_nodejsCustomInspectSymbol.default] = fn2;
      }
    }
  }
});

// node_modules/graphql/language/ast.js
var require_ast = __commonJS({
  "node_modules/graphql/language/ast.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isNode = isNode2;
    exports2.Token = exports2.Location = void 0;
    var _defineInspect = _interopRequireDefault(require_defineInspect());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    var Location = function() {
      function Location2(startToken, endToken, source) {
        this.start = startToken.start;
        this.end = endToken.end;
        this.startToken = startToken;
        this.endToken = endToken;
        this.source = source;
      }
      var _proto = Location2.prototype;
      _proto.toJSON = function toJSON2() {
        return {
          start: this.start,
          end: this.end
        };
      };
      return Location2;
    }();
    exports2.Location = Location;
    (0, _defineInspect.default)(Location);
    var Token3 = function() {
      function Token4(kind, start3, end2, line, column, prev, value) {
        this.kind = kind;
        this.start = start3;
        this.end = end2;
        this.line = line;
        this.column = column;
        this.value = value;
        this.prev = prev;
        this.next = null;
      }
      var _proto2 = Token4.prototype;
      _proto2.toJSON = function toJSON2() {
        return {
          kind: this.kind,
          value: this.value,
          line: this.line,
          column: this.column
        };
      };
      return Token4;
    }();
    exports2.Token = Token3;
    (0, _defineInspect.default)(Token3);
    function isNode2(maybeNode) {
      return maybeNode != null && typeof maybeNode.kind === "string";
    }
  }
});

// node_modules/graphql/language/tokenKind.js
var require_tokenKind = __commonJS({
  "node_modules/graphql/language/tokenKind.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.TokenKind = void 0;
    var TokenKind2 = Object.freeze({
      SOF: "<SOF>",
      EOF: "<EOF>",
      BANG: "!",
      DOLLAR: "$",
      AMP: "&",
      PAREN_L: "(",
      PAREN_R: ")",
      SPREAD: "...",
      COLON: ":",
      EQUALS: "=",
      AT: "@",
      BRACKET_L: "[",
      BRACKET_R: "]",
      BRACE_L: "{",
      PIPE: "|",
      BRACE_R: "}",
      NAME: "Name",
      INT: "Int",
      FLOAT: "Float",
      STRING: "String",
      BLOCK_STRING: "BlockString",
      COMMENT: "Comment"
    });
    exports2.TokenKind = TokenKind2;
  }
});

// node_modules/graphql/jsutils/inspect.js
var require_inspect = __commonJS({
  "node_modules/graphql/jsutils/inspect.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = inspect3;
    var _nodejsCustomInspectSymbol = _interopRequireDefault(require_nodejsCustomInspectSymbol());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof3(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof3 = function _typeof4(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof3 = function _typeof4(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof3(obj);
    }
    var MAX_ARRAY_LENGTH = 10;
    var MAX_RECURSIVE_DEPTH = 2;
    function inspect3(value) {
      return formatValue(value, []);
    }
    function formatValue(value, seenValues) {
      switch (_typeof3(value)) {
        case "string":
          return JSON.stringify(value);
        case "function":
          return value.name ? "[function ".concat(value.name, "]") : "[function]";
        case "object":
          if (value === null) {
            return "null";
          }
          return formatObjectValue(value, seenValues);
        default:
          return String(value);
      }
    }
    function formatObjectValue(value, previouslySeenValues) {
      if (previouslySeenValues.indexOf(value) !== -1) {
        return "[Circular]";
      }
      var seenValues = [].concat(previouslySeenValues, [value]);
      var customInspectFn = getCustomFn(value);
      if (customInspectFn !== void 0) {
        var customValue = customInspectFn.call(value);
        if (customValue !== value) {
          return typeof customValue === "string" ? customValue : formatValue(customValue, seenValues);
        }
      } else if (Array.isArray(value)) {
        return formatArray(value, seenValues);
      }
      return formatObject(value, seenValues);
    }
    function formatObject(object2, seenValues) {
      var keys6 = Object.keys(object2);
      if (keys6.length === 0) {
        return "{}";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[" + getObjectTag(object2) + "]";
      }
      var properties = keys6.map(function(key) {
        var value = formatValue(object2[key], seenValues);
        return key + ": " + value;
      });
      return "{ " + properties.join(", ") + " }";
    }
    function formatArray(array2, seenValues) {
      if (array2.length === 0) {
        return "[]";
      }
      if (seenValues.length > MAX_RECURSIVE_DEPTH) {
        return "[Array]";
      }
      var len = Math.min(MAX_ARRAY_LENGTH, array2.length);
      var remaining = array2.length - len;
      var items = [];
      for (var i15 = 0; i15 < len; ++i15) {
        items.push(formatValue(array2[i15], seenValues));
      }
      if (remaining === 1) {
        items.push("... 1 more item");
      } else if (remaining > 1) {
        items.push("... ".concat(remaining, " more items"));
      }
      return "[" + items.join(", ") + "]";
    }
    function getCustomFn(object2) {
      var customInspectFn = object2[String(_nodejsCustomInspectSymbol.default)];
      if (typeof customInspectFn === "function") {
        return customInspectFn;
      }
      if (typeof object2.inspect === "function") {
        return object2.inspect;
      }
    }
    function getObjectTag(object2) {
      var tag = Object.prototype.toString.call(object2).replace(/^\[object /, "").replace(/]$/, "");
      if (tag === "Object" && typeof object2.constructor === "function") {
        var name2 = object2.constructor.name;
        if (typeof name2 === "string" && name2 !== "") {
          return name2;
        }
      }
      return tag;
    }
  }
});

// node_modules/graphql/jsutils/devAssert.js
var require_devAssert = __commonJS({
  "node_modules/graphql/jsutils/devAssert.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = devAssert;
    function devAssert(condition, message) {
      var booleanCondition = Boolean(condition);
      if (!booleanCondition) {
        throw new Error(message);
      }
    }
  }
});

// node_modules/graphql/jsutils/instanceOf.js
var require_instanceOf = __commonJS({
  "node_modules/graphql/jsutils/instanceOf.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = void 0;
    var _inspect = _interopRequireDefault(require_inspect());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _typeof3(obj) {
      "@babel/helpers - typeof";
      if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
        _typeof3 = function _typeof4(obj2) {
          return typeof obj2;
        };
      } else {
        _typeof3 = function _typeof4(obj2) {
          return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
        };
      }
      return _typeof3(obj);
    }
    var _default = false ? (
      // istanbul ignore next (See: 'https://github.com/graphql/graphql-js/issues/2317')
      // eslint-disable-next-line no-shadow
      function instanceOf(value, constructor) {
        return value instanceof constructor;
      }
    ) : (
      // eslint-disable-next-line no-shadow
      function instanceOf(value, constructor) {
        if (value instanceof constructor) {
          return true;
        }
        if (_typeof3(value) === "object" && value !== null) {
          var _value$constructor;
          var className = constructor.prototype[Symbol.toStringTag];
          var valueClassName = (
            // We still need to support constructor's name to detect conflicts with older versions of this library.
            Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
          );
          if (className === valueClassName) {
            var stringifiedValue = (0, _inspect.default)(value);
            throw new Error("Cannot use ".concat(className, ' "').concat(stringifiedValue, '" from another module or realm.\n\nEnsure that there is only one instance of "graphql" in the node_modules\ndirectory. If different versions of "graphql" are the dependencies of other\nrelied on modules, use "resolutions" to ensure only one version is installed.\n\nhttps://yarnpkg.com/en/docs/selective-version-resolutions\n\nDuplicate "graphql" modules cannot be used at the same time since different\nversions may have different capabilities and behavior. The data from one\nversion used in the function from another could produce confusing and\nspurious results.'));
          }
        }
        return false;
      }
    );
    exports2.default = _default;
  }
});

// node_modules/graphql/language/source.js
var require_source = __commonJS({
  "node_modules/graphql/language/source.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isSource = isSource;
    exports2.Source = void 0;
    var _symbols = require_symbols();
    var _inspect = _interopRequireDefault(require_inspect());
    var _devAssert = _interopRequireDefault(require_devAssert());
    var _instanceOf = _interopRequireDefault(require_instanceOf());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _defineProperties(target, props) {
      for (var i15 = 0; i15 < props.length; i15++) {
        var descriptor = props[i15];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }
    function _createClass9(Constructor, protoProps, staticProps) {
      if (protoProps)
        _defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        _defineProperties(Constructor, staticProps);
      return Constructor;
    }
    var Source = function() {
      function Source2(body) {
        var name2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "GraphQL request";
        var locationOffset = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
          line: 1,
          column: 1
        };
        typeof body === "string" || (0, _devAssert.default)(0, "Body must be a string. Received: ".concat((0, _inspect.default)(body), "."));
        this.body = body;
        this.name = name2;
        this.locationOffset = locationOffset;
        this.locationOffset.line > 0 || (0, _devAssert.default)(0, "line in locationOffset is 1-indexed and must be positive.");
        this.locationOffset.column > 0 || (0, _devAssert.default)(0, "column in locationOffset is 1-indexed and must be positive.");
      }
      _createClass9(Source2, [{
        key: _symbols.SYMBOL_TO_STRING_TAG,
        get: function get8() {
          return "Source";
        }
      }]);
      return Source2;
    }();
    exports2.Source = Source;
    function isSource(source) {
      return (0, _instanceOf.default)(source, Source);
    }
  }
});

// node_modules/graphql/language/directiveLocation.js
var require_directiveLocation = __commonJS({
  "node_modules/graphql/language/directiveLocation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DirectiveLocation = void 0;
    var DirectiveLocation = Object.freeze({
      // Request Definitions
      QUERY: "QUERY",
      MUTATION: "MUTATION",
      SUBSCRIPTION: "SUBSCRIPTION",
      FIELD: "FIELD",
      FRAGMENT_DEFINITION: "FRAGMENT_DEFINITION",
      FRAGMENT_SPREAD: "FRAGMENT_SPREAD",
      INLINE_FRAGMENT: "INLINE_FRAGMENT",
      VARIABLE_DEFINITION: "VARIABLE_DEFINITION",
      // Type System Definitions
      SCHEMA: "SCHEMA",
      SCALAR: "SCALAR",
      OBJECT: "OBJECT",
      FIELD_DEFINITION: "FIELD_DEFINITION",
      ARGUMENT_DEFINITION: "ARGUMENT_DEFINITION",
      INTERFACE: "INTERFACE",
      UNION: "UNION",
      ENUM: "ENUM",
      ENUM_VALUE: "ENUM_VALUE",
      INPUT_OBJECT: "INPUT_OBJECT",
      INPUT_FIELD_DEFINITION: "INPUT_FIELD_DEFINITION"
    });
    exports2.DirectiveLocation = DirectiveLocation;
  }
});

// node_modules/graphql/language/blockString.js
var require_blockString = __commonJS({
  "node_modules/graphql/language/blockString.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.dedentBlockStringValue = dedentBlockStringValue;
    exports2.getBlockStringIndentation = getBlockStringIndentation;
    exports2.printBlockString = printBlockString;
    function dedentBlockStringValue(rawString) {
      var lines = rawString.split(/\r\n|[\n\r]/g);
      var commonIndent = getBlockStringIndentation(rawString);
      if (commonIndent !== 0) {
        for (var i15 = 1; i15 < lines.length; i15++) {
          lines[i15] = lines[i15].slice(commonIndent);
        }
      }
      var startLine = 0;
      while (startLine < lines.length && isBlank(lines[startLine])) {
        ++startLine;
      }
      var endLine = lines.length;
      while (endLine > startLine && isBlank(lines[endLine - 1])) {
        --endLine;
      }
      return lines.slice(startLine, endLine).join("\n");
    }
    function isBlank(str) {
      for (var i15 = 0; i15 < str.length; ++i15) {
        if (str[i15] !== " " && str[i15] !== "	") {
          return false;
        }
      }
      return true;
    }
    function getBlockStringIndentation(value) {
      var _commonIndent;
      var isFirstLine = true;
      var isEmptyLine = true;
      var indent2 = 0;
      var commonIndent = null;
      for (var i15 = 0; i15 < value.length; ++i15) {
        switch (value.charCodeAt(i15)) {
          case 13:
            if (value.charCodeAt(i15 + 1) === 10) {
              ++i15;
            }
          case 10:
            isFirstLine = false;
            isEmptyLine = true;
            indent2 = 0;
            break;
          case 9:
          case 32:
            ++indent2;
            break;
          default:
            if (isEmptyLine && !isFirstLine && (commonIndent === null || indent2 < commonIndent)) {
              commonIndent = indent2;
            }
            isEmptyLine = false;
        }
      }
      return (_commonIndent = commonIndent) !== null && _commonIndent !== void 0 ? _commonIndent : 0;
    }
    function printBlockString(value) {
      var indentation = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
      var preferMultipleLines = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
      var isSingleLine = value.indexOf("\n") === -1;
      var hasLeadingSpace = value[0] === " " || value[0] === "	";
      var hasTrailingQuote = value[value.length - 1] === '"';
      var hasTrailingSlash = value[value.length - 1] === "\\";
      var printAsMultipleLines = !isSingleLine || hasTrailingQuote || hasTrailingSlash || preferMultipleLines;
      var result = "";
      if (printAsMultipleLines && !(isSingleLine && hasLeadingSpace)) {
        result += "\n" + indentation;
      }
      result += indentation ? value.replace(/\n/g, "\n" + indentation) : value;
      if (printAsMultipleLines) {
        result += "\n";
      }
      return '"""' + result.replace(/"""/g, '\\"""') + '"""';
    }
  }
});

// node_modules/graphql/language/lexer.js
var require_lexer = __commonJS({
  "node_modules/graphql/language/lexer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isPunctuatorTokenKind = isPunctuatorTokenKind;
    exports2.Lexer = void 0;
    var _syntaxError = require_syntaxError();
    var _ast = require_ast();
    var _tokenKind = require_tokenKind();
    var _blockString = require_blockString();
    var Lexer = function() {
      function Lexer2(source) {
        var startOfFileToken = new _ast.Token(_tokenKind.TokenKind.SOF, 0, 0, 0, 0, null);
        this.source = source;
        this.lastToken = startOfFileToken;
        this.token = startOfFileToken;
        this.line = 1;
        this.lineStart = 0;
      }
      var _proto = Lexer2.prototype;
      _proto.advance = function advance() {
        this.lastToken = this.token;
        var token2 = this.token = this.lookahead();
        return token2;
      };
      _proto.lookahead = function lookahead() {
        var token2 = this.token;
        if (token2.kind !== _tokenKind.TokenKind.EOF) {
          do {
            var _token$next;
            token2 = (_token$next = token2.next) !== null && _token$next !== void 0 ? _token$next : token2.next = readToken(this, token2);
          } while (token2.kind === _tokenKind.TokenKind.COMMENT);
        }
        return token2;
      };
      return Lexer2;
    }();
    exports2.Lexer = Lexer;
    function isPunctuatorTokenKind(kind) {
      return kind === _tokenKind.TokenKind.BANG || kind === _tokenKind.TokenKind.DOLLAR || kind === _tokenKind.TokenKind.AMP || kind === _tokenKind.TokenKind.PAREN_L || kind === _tokenKind.TokenKind.PAREN_R || kind === _tokenKind.TokenKind.SPREAD || kind === _tokenKind.TokenKind.COLON || kind === _tokenKind.TokenKind.EQUALS || kind === _tokenKind.TokenKind.AT || kind === _tokenKind.TokenKind.BRACKET_L || kind === _tokenKind.TokenKind.BRACKET_R || kind === _tokenKind.TokenKind.BRACE_L || kind === _tokenKind.TokenKind.PIPE || kind === _tokenKind.TokenKind.BRACE_R;
    }
    function printCharCode(code) {
      return (
        // NaN/undefined represents access beyond the end of the file.
        isNaN(code) ? _tokenKind.TokenKind.EOF : (
          // Trust JSON for ASCII.
          code < 127 ? JSON.stringify(String.fromCharCode(code)) : (
            // Otherwise print the escaped form.
            '"\\u'.concat(("00" + code.toString(16).toUpperCase()).slice(-4), '"')
          )
        )
      );
    }
    function readToken(lexer, prev) {
      var source = lexer.source;
      var body = source.body;
      var bodyLength = body.length;
      var pos = prev.end;
      while (pos < bodyLength) {
        var code = body.charCodeAt(pos);
        var _line = lexer.line;
        var _col = 1 + pos - lexer.lineStart;
        switch (code) {
          case 65279:
          case 9:
          case 32:
          case 44:
            ++pos;
            continue;
          case 10:
            ++pos;
            ++lexer.line;
            lexer.lineStart = pos;
            continue;
          case 13:
            if (body.charCodeAt(pos + 1) === 10) {
              pos += 2;
            } else {
              ++pos;
            }
            ++lexer.line;
            lexer.lineStart = pos;
            continue;
          case 33:
            return new _ast.Token(_tokenKind.TokenKind.BANG, pos, pos + 1, _line, _col, prev);
          case 35:
            return readComment(source, pos, _line, _col, prev);
          case 36:
            return new _ast.Token(_tokenKind.TokenKind.DOLLAR, pos, pos + 1, _line, _col, prev);
          case 38:
            return new _ast.Token(_tokenKind.TokenKind.AMP, pos, pos + 1, _line, _col, prev);
          case 40:
            return new _ast.Token(_tokenKind.TokenKind.PAREN_L, pos, pos + 1, _line, _col, prev);
          case 41:
            return new _ast.Token(_tokenKind.TokenKind.PAREN_R, pos, pos + 1, _line, _col, prev);
          case 46:
            if (body.charCodeAt(pos + 1) === 46 && body.charCodeAt(pos + 2) === 46) {
              return new _ast.Token(_tokenKind.TokenKind.SPREAD, pos, pos + 3, _line, _col, prev);
            }
            break;
          case 58:
            return new _ast.Token(_tokenKind.TokenKind.COLON, pos, pos + 1, _line, _col, prev);
          case 61:
            return new _ast.Token(_tokenKind.TokenKind.EQUALS, pos, pos + 1, _line, _col, prev);
          case 64:
            return new _ast.Token(_tokenKind.TokenKind.AT, pos, pos + 1, _line, _col, prev);
          case 91:
            return new _ast.Token(_tokenKind.TokenKind.BRACKET_L, pos, pos + 1, _line, _col, prev);
          case 93:
            return new _ast.Token(_tokenKind.TokenKind.BRACKET_R, pos, pos + 1, _line, _col, prev);
          case 123:
            return new _ast.Token(_tokenKind.TokenKind.BRACE_L, pos, pos + 1, _line, _col, prev);
          case 124:
            return new _ast.Token(_tokenKind.TokenKind.PIPE, pos, pos + 1, _line, _col, prev);
          case 125:
            return new _ast.Token(_tokenKind.TokenKind.BRACE_R, pos, pos + 1, _line, _col, prev);
          case 34:
            if (body.charCodeAt(pos + 1) === 34 && body.charCodeAt(pos + 2) === 34) {
              return readBlockString(source, pos, _line, _col, prev, lexer);
            }
            return readString(source, pos, _line, _col, prev);
          case 45:
          case 48:
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            return readNumber(source, pos, code, _line, _col, prev);
          case 65:
          case 66:
          case 67:
          case 68:
          case 69:
          case 70:
          case 71:
          case 72:
          case 73:
          case 74:
          case 75:
          case 76:
          case 77:
          case 78:
          case 79:
          case 80:
          case 81:
          case 82:
          case 83:
          case 84:
          case 85:
          case 86:
          case 87:
          case 88:
          case 89:
          case 90:
          case 95:
          case 97:
          case 98:
          case 99:
          case 100:
          case 101:
          case 102:
          case 103:
          case 104:
          case 105:
          case 106:
          case 107:
          case 108:
          case 109:
          case 110:
          case 111:
          case 112:
          case 113:
          case 114:
          case 115:
          case 116:
          case 117:
          case 118:
          case 119:
          case 120:
          case 121:
          case 122:
            return readName(source, pos, _line, _col, prev);
        }
        throw (0, _syntaxError.syntaxError)(source, pos, unexpectedCharacterMessage(code));
      }
      var line = lexer.line;
      var col = 1 + pos - lexer.lineStart;
      return new _ast.Token(_tokenKind.TokenKind.EOF, bodyLength, bodyLength, line, col, prev);
    }
    function unexpectedCharacterMessage(code) {
      if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
        return "Cannot contain the invalid character ".concat(printCharCode(code), ".");
      }
      if (code === 39) {
        return `Unexpected single quote character ('), did you mean to use a double quote (")?`;
      }
      return "Cannot parse the unexpected character ".concat(printCharCode(code), ".");
    }
    function readComment(source, start3, line, col, prev) {
      var body = source.body;
      var code;
      var position3 = start3;
      do {
        code = body.charCodeAt(++position3);
      } while (!isNaN(code) && // SourceCharacter but not LineTerminator
      (code > 31 || code === 9));
      return new _ast.Token(_tokenKind.TokenKind.COMMENT, start3, position3, line, col, prev, body.slice(start3 + 1, position3));
    }
    function readNumber(source, start3, firstCode, line, col, prev) {
      var body = source.body;
      var code = firstCode;
      var position3 = start3;
      var isFloat = false;
      if (code === 45) {
        code = body.charCodeAt(++position3);
      }
      if (code === 48) {
        code = body.charCodeAt(++position3);
        if (code >= 48 && code <= 57) {
          throw (0, _syntaxError.syntaxError)(source, position3, "Invalid number, unexpected digit after 0: ".concat(printCharCode(code), "."));
        }
      } else {
        position3 = readDigits(source, position3, code);
        code = body.charCodeAt(position3);
      }
      if (code === 46) {
        isFloat = true;
        code = body.charCodeAt(++position3);
        position3 = readDigits(source, position3, code);
        code = body.charCodeAt(position3);
      }
      if (code === 69 || code === 101) {
        isFloat = true;
        code = body.charCodeAt(++position3);
        if (code === 43 || code === 45) {
          code = body.charCodeAt(++position3);
        }
        position3 = readDigits(source, position3, code);
        code = body.charCodeAt(position3);
      }
      if (code === 46 || isNameStart(code)) {
        throw (0, _syntaxError.syntaxError)(source, position3, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
      }
      return new _ast.Token(isFloat ? _tokenKind.TokenKind.FLOAT : _tokenKind.TokenKind.INT, start3, position3, line, col, prev, body.slice(start3, position3));
    }
    function readDigits(source, start3, firstCode) {
      var body = source.body;
      var position3 = start3;
      var code = firstCode;
      if (code >= 48 && code <= 57) {
        do {
          code = body.charCodeAt(++position3);
        } while (code >= 48 && code <= 57);
        return position3;
      }
      throw (0, _syntaxError.syntaxError)(source, position3, "Invalid number, expected digit but got: ".concat(printCharCode(code), "."));
    }
    function readString(source, start3, line, col, prev) {
      var body = source.body;
      var position3 = start3 + 1;
      var chunkStart = position3;
      var code = 0;
      var value = "";
      while (position3 < body.length && !isNaN(code = body.charCodeAt(position3)) && // not LineTerminator
      code !== 10 && code !== 13) {
        if (code === 34) {
          value += body.slice(chunkStart, position3);
          return new _ast.Token(_tokenKind.TokenKind.STRING, start3, position3 + 1, line, col, prev, value);
        }
        if (code < 32 && code !== 9) {
          throw (0, _syntaxError.syntaxError)(source, position3, "Invalid character within String: ".concat(printCharCode(code), "."));
        }
        ++position3;
        if (code === 92) {
          value += body.slice(chunkStart, position3 - 1);
          code = body.charCodeAt(position3);
          switch (code) {
            case 34:
              value += '"';
              break;
            case 47:
              value += "/";
              break;
            case 92:
              value += "\\";
              break;
            case 98:
              value += "\b";
              break;
            case 102:
              value += "\f";
              break;
            case 110:
              value += "\n";
              break;
            case 114:
              value += "\r";
              break;
            case 116:
              value += "	";
              break;
            case 117: {
              var charCode = uniCharCode(body.charCodeAt(position3 + 1), body.charCodeAt(position3 + 2), body.charCodeAt(position3 + 3), body.charCodeAt(position3 + 4));
              if (charCode < 0) {
                var invalidSequence = body.slice(position3 + 1, position3 + 5);
                throw (0, _syntaxError.syntaxError)(source, position3, "Invalid character escape sequence: \\u".concat(invalidSequence, "."));
              }
              value += String.fromCharCode(charCode);
              position3 += 4;
              break;
            }
            default:
              throw (0, _syntaxError.syntaxError)(source, position3, "Invalid character escape sequence: \\".concat(String.fromCharCode(code), "."));
          }
          ++position3;
          chunkStart = position3;
        }
      }
      throw (0, _syntaxError.syntaxError)(source, position3, "Unterminated string.");
    }
    function readBlockString(source, start3, line, col, prev, lexer) {
      var body = source.body;
      var position3 = start3 + 3;
      var chunkStart = position3;
      var code = 0;
      var rawValue = "";
      while (position3 < body.length && !isNaN(code = body.charCodeAt(position3))) {
        if (code === 34 && body.charCodeAt(position3 + 1) === 34 && body.charCodeAt(position3 + 2) === 34) {
          rawValue += body.slice(chunkStart, position3);
          return new _ast.Token(_tokenKind.TokenKind.BLOCK_STRING, start3, position3 + 3, line, col, prev, (0, _blockString.dedentBlockStringValue)(rawValue));
        }
        if (code < 32 && code !== 9 && code !== 10 && code !== 13) {
          throw (0, _syntaxError.syntaxError)(source, position3, "Invalid character within String: ".concat(printCharCode(code), "."));
        }
        if (code === 10) {
          ++position3;
          ++lexer.line;
          lexer.lineStart = position3;
        } else if (code === 13) {
          if (body.charCodeAt(position3 + 1) === 10) {
            position3 += 2;
          } else {
            ++position3;
          }
          ++lexer.line;
          lexer.lineStart = position3;
        } else if (
          // Escape Triple-Quote (\""")
          code === 92 && body.charCodeAt(position3 + 1) === 34 && body.charCodeAt(position3 + 2) === 34 && body.charCodeAt(position3 + 3) === 34
        ) {
          rawValue += body.slice(chunkStart, position3) + '"""';
          position3 += 4;
          chunkStart = position3;
        } else {
          ++position3;
        }
      }
      throw (0, _syntaxError.syntaxError)(source, position3, "Unterminated string.");
    }
    function uniCharCode(a13, b6, c16, d17) {
      return char2hex(a13) << 12 | char2hex(b6) << 8 | char2hex(c16) << 4 | char2hex(d17);
    }
    function char2hex(a13) {
      return a13 >= 48 && a13 <= 57 ? a13 - 48 : a13 >= 65 && a13 <= 70 ? a13 - 55 : a13 >= 97 && a13 <= 102 ? a13 - 87 : -1;
    }
    function readName(source, start3, line, col, prev) {
      var body = source.body;
      var bodyLength = body.length;
      var position3 = start3 + 1;
      var code = 0;
      while (position3 !== bodyLength && !isNaN(code = body.charCodeAt(position3)) && (code === 95 || // _
      code >= 48 && code <= 57 || // 0-9
      code >= 65 && code <= 90 || // A-Z
      code >= 97 && code <= 122)) {
        ++position3;
      }
      return new _ast.Token(_tokenKind.TokenKind.NAME, start3, position3, line, col, prev, body.slice(start3, position3));
    }
    function isNameStart(code) {
      return code === 95 || code >= 65 && code <= 90 || code >= 97 && code <= 122;
    }
  }
});

// node_modules/graphql/language/parser.js
var require_parser = __commonJS({
  "node_modules/graphql/language/parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.parse = parse6;
    exports2.parseValue = parseValue;
    exports2.parseType = parseType;
    exports2.Parser = void 0;
    var _syntaxError = require_syntaxError();
    var _kinds = require_kinds();
    var _ast = require_ast();
    var _tokenKind = require_tokenKind();
    var _source = require_source();
    var _directiveLocation = require_directiveLocation();
    var _lexer = require_lexer();
    function parse6(source, options) {
      var parser = new Parser2(source, options);
      return parser.parseDocument();
    }
    function parseValue(source, options) {
      var parser = new Parser2(source, options);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      var value = parser.parseValueLiteral(false);
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return value;
    }
    function parseType(source, options) {
      var parser = new Parser2(source, options);
      parser.expectToken(_tokenKind.TokenKind.SOF);
      var type = parser.parseTypeReference();
      parser.expectToken(_tokenKind.TokenKind.EOF);
      return type;
    }
    var Parser2 = function() {
      function Parser3(source, options) {
        var sourceObj = (0, _source.isSource)(source) ? source : new _source.Source(source);
        this._lexer = new _lexer.Lexer(sourceObj);
        this._options = options;
      }
      var _proto = Parser3.prototype;
      _proto.parseName = function parseName() {
        var token2 = this.expectToken(_tokenKind.TokenKind.NAME);
        return {
          kind: _kinds.Kind.NAME,
          value: token2.value,
          loc: this.loc(token2)
        };
      };
      _proto.parseDocument = function parseDocument2() {
        var start3 = this._lexer.token;
        return {
          kind: _kinds.Kind.DOCUMENT,
          definitions: this.many(_tokenKind.TokenKind.SOF, this.parseDefinition, _tokenKind.TokenKind.EOF),
          loc: this.loc(start3)
        };
      };
      _proto.parseDefinition = function parseDefinition() {
        if (this.peek(_tokenKind.TokenKind.NAME)) {
          switch (this._lexer.token.value) {
            case "query":
            case "mutation":
            case "subscription":
              return this.parseOperationDefinition();
            case "fragment":
              return this.parseFragmentDefinition();
            case "schema":
            case "scalar":
            case "type":
            case "interface":
            case "union":
            case "enum":
            case "input":
            case "directive":
              return this.parseTypeSystemDefinition();
            case "extend":
              return this.parseTypeSystemExtension();
          }
        } else if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
          return this.parseOperationDefinition();
        } else if (this.peekDescription()) {
          return this.parseTypeSystemDefinition();
        }
        throw this.unexpected();
      };
      _proto.parseOperationDefinition = function parseOperationDefinition() {
        var start3 = this._lexer.token;
        if (this.peek(_tokenKind.TokenKind.BRACE_L)) {
          return {
            kind: _kinds.Kind.OPERATION_DEFINITION,
            operation: "query",
            name: void 0,
            variableDefinitions: [],
            directives: [],
            selectionSet: this.parseSelectionSet(),
            loc: this.loc(start3)
          };
        }
        var operation = this.parseOperationType();
        var name2;
        if (this.peek(_tokenKind.TokenKind.NAME)) {
          name2 = this.parseName();
        }
        return {
          kind: _kinds.Kind.OPERATION_DEFINITION,
          operation,
          name: name2,
          variableDefinitions: this.parseVariableDefinitions(),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
          loc: this.loc(start3)
        };
      };
      _proto.parseOperationType = function parseOperationType() {
        var operationToken = this.expectToken(_tokenKind.TokenKind.NAME);
        switch (operationToken.value) {
          case "query":
            return "query";
          case "mutation":
            return "mutation";
          case "subscription":
            return "subscription";
        }
        throw this.unexpected(operationToken);
      };
      _proto.parseVariableDefinitions = function parseVariableDefinitions() {
        return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseVariableDefinition, _tokenKind.TokenKind.PAREN_R);
      };
      _proto.parseVariableDefinition = function parseVariableDefinition() {
        var start3 = this._lexer.token;
        return {
          kind: _kinds.Kind.VARIABLE_DEFINITION,
          variable: this.parseVariable(),
          type: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseTypeReference()),
          defaultValue: this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.parseValueLiteral(true) : void 0,
          directives: this.parseDirectives(true),
          loc: this.loc(start3)
        };
      };
      _proto.parseVariable = function parseVariable() {
        var start3 = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.DOLLAR);
        return {
          kind: _kinds.Kind.VARIABLE,
          name: this.parseName(),
          loc: this.loc(start3)
        };
      };
      _proto.parseSelectionSet = function parseSelectionSet() {
        var start3 = this._lexer.token;
        return {
          kind: _kinds.Kind.SELECTION_SET,
          selections: this.many(_tokenKind.TokenKind.BRACE_L, this.parseSelection, _tokenKind.TokenKind.BRACE_R),
          loc: this.loc(start3)
        };
      };
      _proto.parseSelection = function parseSelection() {
        return this.peek(_tokenKind.TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
      };
      _proto.parseField = function parseField() {
        var start3 = this._lexer.token;
        var nameOrAlias = this.parseName();
        var alias;
        var name2;
        if (this.expectOptionalToken(_tokenKind.TokenKind.COLON)) {
          alias = nameOrAlias;
          name2 = this.parseName();
        } else {
          name2 = nameOrAlias;
        }
        return {
          kind: _kinds.Kind.FIELD,
          alias,
          name: name2,
          arguments: this.parseArguments(false),
          directives: this.parseDirectives(false),
          selectionSet: this.peek(_tokenKind.TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0,
          loc: this.loc(start3)
        };
      };
      _proto.parseArguments = function parseArguments(isConst) {
        var item = isConst ? this.parseConstArgument : this.parseArgument;
        return this.optionalMany(_tokenKind.TokenKind.PAREN_L, item, _tokenKind.TokenKind.PAREN_R);
      };
      _proto.parseArgument = function parseArgument() {
        var start3 = this._lexer.token;
        var name2 = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        return {
          kind: _kinds.Kind.ARGUMENT,
          name: name2,
          value: this.parseValueLiteral(false),
          loc: this.loc(start3)
        };
      };
      _proto.parseConstArgument = function parseConstArgument() {
        var start3 = this._lexer.token;
        return {
          kind: _kinds.Kind.ARGUMENT,
          name: this.parseName(),
          value: (this.expectToken(_tokenKind.TokenKind.COLON), this.parseValueLiteral(true)),
          loc: this.loc(start3)
        };
      };
      _proto.parseFragment = function parseFragment() {
        var start3 = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.SPREAD);
        var hasTypeCondition = this.expectOptionalKeyword("on");
        if (!hasTypeCondition && this.peek(_tokenKind.TokenKind.NAME)) {
          return {
            kind: _kinds.Kind.FRAGMENT_SPREAD,
            name: this.parseFragmentName(),
            directives: this.parseDirectives(false),
            loc: this.loc(start3)
          };
        }
        return {
          kind: _kinds.Kind.INLINE_FRAGMENT,
          typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
          loc: this.loc(start3)
        };
      };
      _proto.parseFragmentDefinition = function parseFragmentDefinition() {
        var _this$_options;
        var start3 = this._lexer.token;
        this.expectKeyword("fragment");
        if (((_this$_options = this._options) === null || _this$_options === void 0 ? void 0 : _this$_options.experimentalFragmentVariables) === true) {
          return {
            kind: _kinds.Kind.FRAGMENT_DEFINITION,
            name: this.parseFragmentName(),
            variableDefinitions: this.parseVariableDefinitions(),
            typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
            directives: this.parseDirectives(false),
            selectionSet: this.parseSelectionSet(),
            loc: this.loc(start3)
          };
        }
        return {
          kind: _kinds.Kind.FRAGMENT_DEFINITION,
          name: this.parseFragmentName(),
          typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
          directives: this.parseDirectives(false),
          selectionSet: this.parseSelectionSet(),
          loc: this.loc(start3)
        };
      };
      _proto.parseFragmentName = function parseFragmentName() {
        if (this._lexer.token.value === "on") {
          throw this.unexpected();
        }
        return this.parseName();
      };
      _proto.parseValueLiteral = function parseValueLiteral(isConst) {
        var token2 = this._lexer.token;
        switch (token2.kind) {
          case _tokenKind.TokenKind.BRACKET_L:
            return this.parseList(isConst);
          case _tokenKind.TokenKind.BRACE_L:
            return this.parseObject(isConst);
          case _tokenKind.TokenKind.INT:
            this._lexer.advance();
            return {
              kind: _kinds.Kind.INT,
              value: token2.value,
              loc: this.loc(token2)
            };
          case _tokenKind.TokenKind.FLOAT:
            this._lexer.advance();
            return {
              kind: _kinds.Kind.FLOAT,
              value: token2.value,
              loc: this.loc(token2)
            };
          case _tokenKind.TokenKind.STRING:
          case _tokenKind.TokenKind.BLOCK_STRING:
            return this.parseStringLiteral();
          case _tokenKind.TokenKind.NAME:
            this._lexer.advance();
            switch (token2.value) {
              case "true":
                return {
                  kind: _kinds.Kind.BOOLEAN,
                  value: true,
                  loc: this.loc(token2)
                };
              case "false":
                return {
                  kind: _kinds.Kind.BOOLEAN,
                  value: false,
                  loc: this.loc(token2)
                };
              case "null":
                return {
                  kind: _kinds.Kind.NULL,
                  loc: this.loc(token2)
                };
              default:
                return {
                  kind: _kinds.Kind.ENUM,
                  value: token2.value,
                  loc: this.loc(token2)
                };
            }
          case _tokenKind.TokenKind.DOLLAR:
            if (!isConst) {
              return this.parseVariable();
            }
            break;
        }
        throw this.unexpected();
      };
      _proto.parseStringLiteral = function parseStringLiteral() {
        var token2 = this._lexer.token;
        this._lexer.advance();
        return {
          kind: _kinds.Kind.STRING,
          value: token2.value,
          block: token2.kind === _tokenKind.TokenKind.BLOCK_STRING,
          loc: this.loc(token2)
        };
      };
      _proto.parseList = function parseList(isConst) {
        var _this = this;
        var start3 = this._lexer.token;
        var item = function item2() {
          return _this.parseValueLiteral(isConst);
        };
        return {
          kind: _kinds.Kind.LIST,
          values: this.any(_tokenKind.TokenKind.BRACKET_L, item, _tokenKind.TokenKind.BRACKET_R),
          loc: this.loc(start3)
        };
      };
      _proto.parseObject = function parseObject(isConst) {
        var _this2 = this;
        var start3 = this._lexer.token;
        var item = function item2() {
          return _this2.parseObjectField(isConst);
        };
        return {
          kind: _kinds.Kind.OBJECT,
          fields: this.any(_tokenKind.TokenKind.BRACE_L, item, _tokenKind.TokenKind.BRACE_R),
          loc: this.loc(start3)
        };
      };
      _proto.parseObjectField = function parseObjectField(isConst) {
        var start3 = this._lexer.token;
        var name2 = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        return {
          kind: _kinds.Kind.OBJECT_FIELD,
          name: name2,
          value: this.parseValueLiteral(isConst),
          loc: this.loc(start3)
        };
      };
      _proto.parseDirectives = function parseDirectives(isConst) {
        var directives = [];
        while (this.peek(_tokenKind.TokenKind.AT)) {
          directives.push(this.parseDirective(isConst));
        }
        return directives;
      };
      _proto.parseDirective = function parseDirective(isConst) {
        var start3 = this._lexer.token;
        this.expectToken(_tokenKind.TokenKind.AT);
        return {
          kind: _kinds.Kind.DIRECTIVE,
          name: this.parseName(),
          arguments: this.parseArguments(isConst),
          loc: this.loc(start3)
        };
      };
      _proto.parseTypeReference = function parseTypeReference() {
        var start3 = this._lexer.token;
        var type;
        if (this.expectOptionalToken(_tokenKind.TokenKind.BRACKET_L)) {
          type = this.parseTypeReference();
          this.expectToken(_tokenKind.TokenKind.BRACKET_R);
          type = {
            kind: _kinds.Kind.LIST_TYPE,
            type,
            loc: this.loc(start3)
          };
        } else {
          type = this.parseNamedType();
        }
        if (this.expectOptionalToken(_tokenKind.TokenKind.BANG)) {
          return {
            kind: _kinds.Kind.NON_NULL_TYPE,
            type,
            loc: this.loc(start3)
          };
        }
        return type;
      };
      _proto.parseNamedType = function parseNamedType() {
        var start3 = this._lexer.token;
        return {
          kind: _kinds.Kind.NAMED_TYPE,
          name: this.parseName(),
          loc: this.loc(start3)
        };
      };
      _proto.parseTypeSystemDefinition = function parseTypeSystemDefinition() {
        var keywordToken = this.peekDescription() ? this._lexer.lookahead() : this._lexer.token;
        if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaDefinition();
            case "scalar":
              return this.parseScalarTypeDefinition();
            case "type":
              return this.parseObjectTypeDefinition();
            case "interface":
              return this.parseInterfaceTypeDefinition();
            case "union":
              return this.parseUnionTypeDefinition();
            case "enum":
              return this.parseEnumTypeDefinition();
            case "input":
              return this.parseInputObjectTypeDefinition();
            case "directive":
              return this.parseDirectiveDefinition();
          }
        }
        throw this.unexpected(keywordToken);
      };
      _proto.peekDescription = function peekDescription() {
        return this.peek(_tokenKind.TokenKind.STRING) || this.peek(_tokenKind.TokenKind.BLOCK_STRING);
      };
      _proto.parseDescription = function parseDescription() {
        if (this.peekDescription()) {
          return this.parseStringLiteral();
        }
      };
      _proto.parseSchemaDefinition = function parseSchemaDefinition() {
        var start3 = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("schema");
        var directives = this.parseDirectives(true);
        var operationTypes = this.many(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
        return {
          kind: _kinds.Kind.SCHEMA_DEFINITION,
          description,
          directives,
          operationTypes,
          loc: this.loc(start3)
        };
      };
      _proto.parseOperationTypeDefinition = function parseOperationTypeDefinition() {
        var start3 = this._lexer.token;
        var operation = this.parseOperationType();
        this.expectToken(_tokenKind.TokenKind.COLON);
        var type = this.parseNamedType();
        return {
          kind: _kinds.Kind.OPERATION_TYPE_DEFINITION,
          operation,
          type,
          loc: this.loc(start3)
        };
      };
      _proto.parseScalarTypeDefinition = function parseScalarTypeDefinition() {
        var start3 = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("scalar");
        var name2 = this.parseName();
        var directives = this.parseDirectives(true);
        return {
          kind: _kinds.Kind.SCALAR_TYPE_DEFINITION,
          description,
          name: name2,
          directives,
          loc: this.loc(start3)
        };
      };
      _proto.parseObjectTypeDefinition = function parseObjectTypeDefinition() {
        var start3 = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("type");
        var name2 = this.parseName();
        var interfaces = this.parseImplementsInterfaces();
        var directives = this.parseDirectives(true);
        var fields = this.parseFieldsDefinition();
        return {
          kind: _kinds.Kind.OBJECT_TYPE_DEFINITION,
          description,
          name: name2,
          interfaces,
          directives,
          fields,
          loc: this.loc(start3)
        };
      };
      _proto.parseImplementsInterfaces = function parseImplementsInterfaces() {
        var _this$_options2;
        if (!this.expectOptionalKeyword("implements")) {
          return [];
        }
        if (((_this$_options2 = this._options) === null || _this$_options2 === void 0 ? void 0 : _this$_options2.allowLegacySDLImplementsInterfaces) === true) {
          var types = [];
          this.expectOptionalToken(_tokenKind.TokenKind.AMP);
          do {
            types.push(this.parseNamedType());
          } while (this.expectOptionalToken(_tokenKind.TokenKind.AMP) || this.peek(_tokenKind.TokenKind.NAME));
          return types;
        }
        return this.delimitedMany(_tokenKind.TokenKind.AMP, this.parseNamedType);
      };
      _proto.parseFieldsDefinition = function parseFieldsDefinition() {
        var _this$_options3;
        if (((_this$_options3 = this._options) === null || _this$_options3 === void 0 ? void 0 : _this$_options3.allowLegacySDLEmptyFields) === true && this.peek(_tokenKind.TokenKind.BRACE_L) && this._lexer.lookahead().kind === _tokenKind.TokenKind.BRACE_R) {
          this._lexer.advance();
          this._lexer.advance();
          return [];
        }
        return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseFieldDefinition, _tokenKind.TokenKind.BRACE_R);
      };
      _proto.parseFieldDefinition = function parseFieldDefinition() {
        var start3 = this._lexer.token;
        var description = this.parseDescription();
        var name2 = this.parseName();
        var args = this.parseArgumentDefs();
        this.expectToken(_tokenKind.TokenKind.COLON);
        var type = this.parseTypeReference();
        var directives = this.parseDirectives(true);
        return {
          kind: _kinds.Kind.FIELD_DEFINITION,
          description,
          name: name2,
          arguments: args,
          type,
          directives,
          loc: this.loc(start3)
        };
      };
      _proto.parseArgumentDefs = function parseArgumentDefs() {
        return this.optionalMany(_tokenKind.TokenKind.PAREN_L, this.parseInputValueDef, _tokenKind.TokenKind.PAREN_R);
      };
      _proto.parseInputValueDef = function parseInputValueDef() {
        var start3 = this._lexer.token;
        var description = this.parseDescription();
        var name2 = this.parseName();
        this.expectToken(_tokenKind.TokenKind.COLON);
        var type = this.parseTypeReference();
        var defaultValue;
        if (this.expectOptionalToken(_tokenKind.TokenKind.EQUALS)) {
          defaultValue = this.parseValueLiteral(true);
        }
        var directives = this.parseDirectives(true);
        return {
          kind: _kinds.Kind.INPUT_VALUE_DEFINITION,
          description,
          name: name2,
          type,
          defaultValue,
          directives,
          loc: this.loc(start3)
        };
      };
      _proto.parseInterfaceTypeDefinition = function parseInterfaceTypeDefinition() {
        var start3 = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("interface");
        var name2 = this.parseName();
        var interfaces = this.parseImplementsInterfaces();
        var directives = this.parseDirectives(true);
        var fields = this.parseFieldsDefinition();
        return {
          kind: _kinds.Kind.INTERFACE_TYPE_DEFINITION,
          description,
          name: name2,
          interfaces,
          directives,
          fields,
          loc: this.loc(start3)
        };
      };
      _proto.parseUnionTypeDefinition = function parseUnionTypeDefinition() {
        var start3 = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("union");
        var name2 = this.parseName();
        var directives = this.parseDirectives(true);
        var types = this.parseUnionMemberTypes();
        return {
          kind: _kinds.Kind.UNION_TYPE_DEFINITION,
          description,
          name: name2,
          directives,
          types,
          loc: this.loc(start3)
        };
      };
      _proto.parseUnionMemberTypes = function parseUnionMemberTypes() {
        return this.expectOptionalToken(_tokenKind.TokenKind.EQUALS) ? this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseNamedType) : [];
      };
      _proto.parseEnumTypeDefinition = function parseEnumTypeDefinition() {
        var start3 = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("enum");
        var name2 = this.parseName();
        var directives = this.parseDirectives(true);
        var values3 = this.parseEnumValuesDefinition();
        return {
          kind: _kinds.Kind.ENUM_TYPE_DEFINITION,
          description,
          name: name2,
          directives,
          values: values3,
          loc: this.loc(start3)
        };
      };
      _proto.parseEnumValuesDefinition = function parseEnumValuesDefinition() {
        return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseEnumValueDefinition, _tokenKind.TokenKind.BRACE_R);
      };
      _proto.parseEnumValueDefinition = function parseEnumValueDefinition() {
        var start3 = this._lexer.token;
        var description = this.parseDescription();
        var name2 = this.parseName();
        var directives = this.parseDirectives(true);
        return {
          kind: _kinds.Kind.ENUM_VALUE_DEFINITION,
          description,
          name: name2,
          directives,
          loc: this.loc(start3)
        };
      };
      _proto.parseInputObjectTypeDefinition = function parseInputObjectTypeDefinition() {
        var start3 = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("input");
        var name2 = this.parseName();
        var directives = this.parseDirectives(true);
        var fields = this.parseInputFieldsDefinition();
        return {
          kind: _kinds.Kind.INPUT_OBJECT_TYPE_DEFINITION,
          description,
          name: name2,
          directives,
          fields,
          loc: this.loc(start3)
        };
      };
      _proto.parseInputFieldsDefinition = function parseInputFieldsDefinition() {
        return this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseInputValueDef, _tokenKind.TokenKind.BRACE_R);
      };
      _proto.parseTypeSystemExtension = function parseTypeSystemExtension() {
        var keywordToken = this._lexer.lookahead();
        if (keywordToken.kind === _tokenKind.TokenKind.NAME) {
          switch (keywordToken.value) {
            case "schema":
              return this.parseSchemaExtension();
            case "scalar":
              return this.parseScalarTypeExtension();
            case "type":
              return this.parseObjectTypeExtension();
            case "interface":
              return this.parseInterfaceTypeExtension();
            case "union":
              return this.parseUnionTypeExtension();
            case "enum":
              return this.parseEnumTypeExtension();
            case "input":
              return this.parseInputObjectTypeExtension();
          }
        }
        throw this.unexpected(keywordToken);
      };
      _proto.parseSchemaExtension = function parseSchemaExtension() {
        var start3 = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("schema");
        var directives = this.parseDirectives(true);
        var operationTypes = this.optionalMany(_tokenKind.TokenKind.BRACE_L, this.parseOperationTypeDefinition, _tokenKind.TokenKind.BRACE_R);
        if (directives.length === 0 && operationTypes.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.SCHEMA_EXTENSION,
          directives,
          operationTypes,
          loc: this.loc(start3)
        };
      };
      _proto.parseScalarTypeExtension = function parseScalarTypeExtension() {
        var start3 = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("scalar");
        var name2 = this.parseName();
        var directives = this.parseDirectives(true);
        if (directives.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.SCALAR_TYPE_EXTENSION,
          name: name2,
          directives,
          loc: this.loc(start3)
        };
      };
      _proto.parseObjectTypeExtension = function parseObjectTypeExtension() {
        var start3 = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("type");
        var name2 = this.parseName();
        var interfaces = this.parseImplementsInterfaces();
        var directives = this.parseDirectives(true);
        var fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.OBJECT_TYPE_EXTENSION,
          name: name2,
          interfaces,
          directives,
          fields,
          loc: this.loc(start3)
        };
      };
      _proto.parseInterfaceTypeExtension = function parseInterfaceTypeExtension() {
        var start3 = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("interface");
        var name2 = this.parseName();
        var interfaces = this.parseImplementsInterfaces();
        var directives = this.parseDirectives(true);
        var fields = this.parseFieldsDefinition();
        if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.INTERFACE_TYPE_EXTENSION,
          name: name2,
          interfaces,
          directives,
          fields,
          loc: this.loc(start3)
        };
      };
      _proto.parseUnionTypeExtension = function parseUnionTypeExtension() {
        var start3 = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("union");
        var name2 = this.parseName();
        var directives = this.parseDirectives(true);
        var types = this.parseUnionMemberTypes();
        if (directives.length === 0 && types.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.UNION_TYPE_EXTENSION,
          name: name2,
          directives,
          types,
          loc: this.loc(start3)
        };
      };
      _proto.parseEnumTypeExtension = function parseEnumTypeExtension() {
        var start3 = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("enum");
        var name2 = this.parseName();
        var directives = this.parseDirectives(true);
        var values3 = this.parseEnumValuesDefinition();
        if (directives.length === 0 && values3.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.ENUM_TYPE_EXTENSION,
          name: name2,
          directives,
          values: values3,
          loc: this.loc(start3)
        };
      };
      _proto.parseInputObjectTypeExtension = function parseInputObjectTypeExtension() {
        var start3 = this._lexer.token;
        this.expectKeyword("extend");
        this.expectKeyword("input");
        var name2 = this.parseName();
        var directives = this.parseDirectives(true);
        var fields = this.parseInputFieldsDefinition();
        if (directives.length === 0 && fields.length === 0) {
          throw this.unexpected();
        }
        return {
          kind: _kinds.Kind.INPUT_OBJECT_TYPE_EXTENSION,
          name: name2,
          directives,
          fields,
          loc: this.loc(start3)
        };
      };
      _proto.parseDirectiveDefinition = function parseDirectiveDefinition() {
        var start3 = this._lexer.token;
        var description = this.parseDescription();
        this.expectKeyword("directive");
        this.expectToken(_tokenKind.TokenKind.AT);
        var name2 = this.parseName();
        var args = this.parseArgumentDefs();
        var repeatable = this.expectOptionalKeyword("repeatable");
        this.expectKeyword("on");
        var locations = this.parseDirectiveLocations();
        return {
          kind: _kinds.Kind.DIRECTIVE_DEFINITION,
          description,
          name: name2,
          arguments: args,
          repeatable,
          locations,
          loc: this.loc(start3)
        };
      };
      _proto.parseDirectiveLocations = function parseDirectiveLocations() {
        return this.delimitedMany(_tokenKind.TokenKind.PIPE, this.parseDirectiveLocation);
      };
      _proto.parseDirectiveLocation = function parseDirectiveLocation() {
        var start3 = this._lexer.token;
        var name2 = this.parseName();
        if (_directiveLocation.DirectiveLocation[name2.value] !== void 0) {
          return name2;
        }
        throw this.unexpected(start3);
      };
      _proto.loc = function loc(startToken) {
        var _this$_options4;
        if (((_this$_options4 = this._options) === null || _this$_options4 === void 0 ? void 0 : _this$_options4.noLocation) !== true) {
          return new _ast.Location(startToken, this._lexer.lastToken, this._lexer.source);
        }
      };
      _proto.peek = function peek(kind) {
        return this._lexer.token.kind === kind;
      };
      _proto.expectToken = function expectToken(kind) {
        var token2 = this._lexer.token;
        if (token2.kind === kind) {
          this._lexer.advance();
          return token2;
        }
        throw (0, _syntaxError.syntaxError)(this._lexer.source, token2.start, "Expected ".concat(getTokenKindDesc(kind), ", found ").concat(getTokenDesc(token2), "."));
      };
      _proto.expectOptionalToken = function expectOptionalToken(kind) {
        var token2 = this._lexer.token;
        if (token2.kind === kind) {
          this._lexer.advance();
          return token2;
        }
        return void 0;
      };
      _proto.expectKeyword = function expectKeyword(value) {
        var token2 = this._lexer.token;
        if (token2.kind === _tokenKind.TokenKind.NAME && token2.value === value) {
          this._lexer.advance();
        } else {
          throw (0, _syntaxError.syntaxError)(this._lexer.source, token2.start, 'Expected "'.concat(value, '", found ').concat(getTokenDesc(token2), "."));
        }
      };
      _proto.expectOptionalKeyword = function expectOptionalKeyword(value) {
        var token2 = this._lexer.token;
        if (token2.kind === _tokenKind.TokenKind.NAME && token2.value === value) {
          this._lexer.advance();
          return true;
        }
        return false;
      };
      _proto.unexpected = function unexpected(atToken) {
        var token2 = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
        return (0, _syntaxError.syntaxError)(this._lexer.source, token2.start, "Unexpected ".concat(getTokenDesc(token2), "."));
      };
      _proto.any = function any(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        var nodes = [];
        while (!this.expectOptionalToken(closeKind)) {
          nodes.push(parseFn.call(this));
        }
        return nodes;
      };
      _proto.optionalMany = function optionalMany(openKind, parseFn, closeKind) {
        if (this.expectOptionalToken(openKind)) {
          var nodes = [];
          do {
            nodes.push(parseFn.call(this));
          } while (!this.expectOptionalToken(closeKind));
          return nodes;
        }
        return [];
      };
      _proto.many = function many(openKind, parseFn, closeKind) {
        this.expectToken(openKind);
        var nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (!this.expectOptionalToken(closeKind));
        return nodes;
      };
      _proto.delimitedMany = function delimitedMany(delimiterKind, parseFn) {
        this.expectOptionalToken(delimiterKind);
        var nodes = [];
        do {
          nodes.push(parseFn.call(this));
        } while (this.expectOptionalToken(delimiterKind));
        return nodes;
      };
      return Parser3;
    }();
    exports2.Parser = Parser2;
    function getTokenDesc(token2) {
      var value = token2.value;
      return getTokenKindDesc(token2.kind) + (value != null ? ' "'.concat(value, '"') : "");
    }
    function getTokenKindDesc(kind) {
      return (0, _lexer.isPunctuatorTokenKind)(kind) ? '"'.concat(kind, '"') : kind;
    }
  }
});

// node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k3) => typeof obj[obj[k3]] !== "number");
    const filtered = {};
    for (const k3 of validKeys) {
      filtered[k3] = obj[k3];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e9) {
      return obj[e9];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object2) => {
    const keys6 = [];
    for (const key in object2) {
      if (Object.prototype.hasOwnProperty.call(object2, key)) {
        keys6.push(key);
      }
    }
    return keys6;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array2, separator = " | ") {
    return array2.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_7, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t20 = typeof data;
  switch (t20) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json2 = JSON.stringify(obj, null, 2);
  return json2.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error2) => {
      for (const issue of error2.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i15 = 0;
          while (i15 < issue.path.length) {
            const el = issue.path[i15];
            const terminal = i15 === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i15++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error2 = new ZodError(issues);
  return error2;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map5) {
  overrideErrorMap = map5;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m10) => !!m10).slice().reverse();
  for (const map5 of maps) {
    errorMessage = map5(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
      // then global default map
    ].filter((x7) => !!x7)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s20 of results) {
      if (s20.status === "aborted")
        return INVALID;
      if (s20.status === "dirty")
        status.dirty();
      arrayValue.push(s20.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (typeof value.value !== "undefined" || pair.alwaysSet) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x7) => x7.status === "aborted";
var isDirty = (x7) => x7.status === "dirty";
var isValid = (x7) => x7.status === "valid";
var isAsync = (x7) => typeof Promise !== "undefined" && x7 instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var ParseInputLazyPath = class {
  constructor(parent2, value, path, key) {
    this._cachedPath = [];
    this.parent = parent2;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error2 = new ZodError(ctx.common.issues);
        this._error = error2;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /[0-9A-HJKMNP-TV-Z]{26}/;
var uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;
var emailRegex = /^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\])|(\[IPv6:(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))\])|([A-Za-z0-9]([A-Za-z0-9-]*[A-Za-z0-9])*(\.[A-Za-z]{2,})+))$/;
var emojiRegex = /^(\p{Extended_Pictographic}|\p{Emoji_Component})+$/u;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z$`);
    }
  }
};
function isValidIP(ip, version3) {
  if ((version3 === "v4" || !version3) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version3 === "v6" || !version3) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class extends ZodType {
  constructor() {
    super(...arguments);
    this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
    this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));
    this.trim = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
    this.toLowerCase = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
    this.toUpperCase = () => new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(
        ctx2,
        {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.string,
          received: ctx2.parsedType
        }
        //
      );
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min4 === null || ch.value > min4)
          min4 = ch.value;
      }
    }
    return min4;
  }
  get maxLength() {
    let max4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max4 === null || ch.value < max4)
          max4 = ch.value;
      }
    }
    return max4;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min4 === null || ch.value > min4)
          min4 = ch.value;
      }
    }
    return min4;
  }
  get maxValue() {
    let max4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max4 === null || ch.value < max4)
          max4 = ch.value;
      }
    }
    return max4;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max4 = null, min4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min4 === null || ch.value > min4)
          min4 = ch.value;
      } else if (ch.kind === "max") {
        if (max4 === null || ch.value < max4)
          max4 = ch.value;
      }
    }
    return Number.isFinite(min4) && Number.isFinite(max4);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min4 === null || ch.value > min4)
          min4 = ch.value;
      }
    }
    return min4;
  }
  get maxValue() {
    let max4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max4 === null || ch.value < max4)
          max4 = ch.value;
      }
    }
    return max4;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min4 === null || ch.value > min4)
          min4 = ch.value;
      }
    }
    return min4 != null ? new Date(min4) : null;
  }
  get maxDate() {
    let max4 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max4 === null || ch.value < max4)
          max4 = ch.value;
      }
    }
    return max4 != null ? new Date(max4) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i15) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i15));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i15) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i15));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys6 = util.objectKeys(shape);
    return this._cached = { shape, keys: keys6 };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};
var ZodDiscriminatedUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a13, b6) {
  const aType = getParsedType(a13);
  const bType = getParsedType(b6);
  if (a13 === b6) {
    return { valid: true, data: a13 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b6);
    const sharedKeys = util.objectKeys(a13).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a13, ...b6 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a13[key], b6[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a13.length !== b6.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a13.length; index2++) {
      const itemA = a13[index2];
      const itemB = b6[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a13 === +b6) {
    return { valid: true, data: a13 };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x7) => !!x7);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i15) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i15)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size2, message) {
    return this.min(size2, message).max(size2, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error2) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x7) => !!x7),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error2
        }
      });
    }
    function makeReturnsIssue(returns, error2) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x7) => !!x7),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error2
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn2 = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      return OK(async (...args) => {
        const error2 = new ZodError([]);
        const parsedArgs = await this._def.args.parseAsync(args, params).catch((e9) => {
          error2.addIssue(makeArgsIssue(args, e9));
          throw error2;
        });
        const result = await fn2(...parsedArgs);
        const parsedReturns = await this._def.returns._def.type.parseAsync(result, params).catch((e9) => {
          error2.addIssue(makeReturnsIssue(result, e9));
          throw error2;
        });
        return parsedReturns;
      });
    } else {
      return OK((...args) => {
        const parsedArgs = this._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = fn2(...parsedArgs.data);
        const parsedReturns = this._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter3, params) => {
  return new ZodLazy({
    getter: getter3,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values3, params) {
  return new ZodEnum({
    values: values3,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values3) {
    return ZodEnum.create(values3);
  }
  exclude(values3) {
    return ZodEnum.create(this.options.filter((opt) => !values3.includes(opt)));
  }
};
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
ZodNativeEnum.create = (values3, params) => {
  return new ZodNativeEnum({
    values: values3,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data);
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a13, b6) {
    return new ZodPipeline({
      in: a13,
      out: b6,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p12 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p12.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p22 = typeof p12 === "string" ? { message: p12 } : p12;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/@tinacms/toolkit/dist/index.es.js
var React68 = __toESM(require_react());
var import_react117 = __toESM(require_react());
var import_react_dom9 = __toESM(require_react_dom());

// node_modules/jotai/esm/index.mjs
var import_react = __toESM(require_react(), 1);

// node_modules/jotai/esm/vanilla.mjs
var keyCount = 0;
function atom(read, write) {
  const key = `atom${++keyCount}`;
  const config2 = {
    toString: () => key
  };
  if (typeof read === "function") {
    config2.read = read;
  } else {
    config2.init = read;
    config2.read = (get8) => get8(config2);
    config2.write = (get8, set3, arg) => set3(
      config2,
      typeof arg === "function" ? arg(get8(config2)) : arg
    );
  }
  if (write) {
    config2.write = write;
  }
  return config2;
}

// node_modules/jotai/esm/index.mjs
var SUSPENSE_PROMISE = Symbol();
var isSuspensePromise = (promise) => !!promise[SUSPENSE_PROMISE];
var isSuspensePromiseAlreadyCancelled = (suspensePromise) => !suspensePromise[SUSPENSE_PROMISE].c;
var cancelSuspensePromise = (suspensePromise) => {
  var _a;
  const { b: basePromise, c: cancelPromise } = suspensePromise[SUSPENSE_PROMISE];
  if (cancelPromise) {
    cancelPromise();
    (_a = promiseAbortMap.get(basePromise)) == null ? void 0 : _a();
  }
};
var isEqualSuspensePromise = (oldSuspensePromise, newSuspensePromise) => {
  const oldOriginalPromise = oldSuspensePromise[SUSPENSE_PROMISE].o;
  const newOriginalPromise = newSuspensePromise[SUSPENSE_PROMISE].o;
  return oldOriginalPromise === newOriginalPromise || oldSuspensePromise === newOriginalPromise || isSuspensePromise(oldOriginalPromise) && isEqualSuspensePromise(oldOriginalPromise, newSuspensePromise);
};
var createSuspensePromise = (basePromise, promise) => {
  const suspensePromiseExtra = {
    b: basePromise,
    o: promise,
    c: null
  };
  const suspensePromise = new Promise((resolve) => {
    suspensePromiseExtra.c = () => {
      suspensePromiseExtra.c = null;
      resolve();
    };
    promise.finally(suspensePromiseExtra.c);
  });
  suspensePromise[SUSPENSE_PROMISE] = suspensePromiseExtra;
  return suspensePromise;
};
var copySuspensePromise = (suspensePromise) => createSuspensePromise(
  suspensePromise[SUSPENSE_PROMISE].b,
  suspensePromise[SUSPENSE_PROMISE].o
);
var promiseAbortMap = /* @__PURE__ */ new WeakMap();
var hasInitialValue = (atom3) => "init" in atom3;
var READ_ATOM = "r";
var WRITE_ATOM = "w";
var COMMIT_ATOM = "c";
var SUBSCRIBE_ATOM = "s";
var RESTORE_ATOMS = "h";
var DEV_SUBSCRIBE_STATE = "n";
var DEV_GET_MOUNTED_ATOMS = "l";
var DEV_GET_ATOM_STATE = "a";
var DEV_GET_MOUNTED = "m";
var createStore = (initialValues) => {
  const committedAtomStateMap = /* @__PURE__ */ new WeakMap();
  const mountedMap = /* @__PURE__ */ new WeakMap();
  const pendingMap = /* @__PURE__ */ new Map();
  let stateListeners;
  let mountedAtoms;
  if ((import.meta.env && import.meta.env.MODE) !== "production") {
    stateListeners = /* @__PURE__ */ new Set();
    mountedAtoms = /* @__PURE__ */ new Set();
  }
  if (initialValues) {
    for (const [atom3, value] of initialValues) {
      const atomState = {
        v: value,
        r: 0,
        y: true,
        // not invalidated
        d: /* @__PURE__ */ new Map()
      };
      if ((import.meta.env && import.meta.env.MODE) !== "production") {
        Object.freeze(atomState);
        if (!hasInitialValue(atom3)) {
          console.warn(
            "Found initial value for derived atom which can cause unexpected behavior",
            atom3
          );
        }
      }
      committedAtomStateMap.set(atom3, atomState);
    }
  }
  const suspensePromiseCacheMap = /* @__PURE__ */ new WeakMap();
  const addSuspensePromiseToCache = (version3, atom3, suspensePromise) => {
    let cache = suspensePromiseCacheMap.get(atom3);
    if (!cache) {
      cache = /* @__PURE__ */ new Map();
      suspensePromiseCacheMap.set(atom3, cache);
    }
    suspensePromise.then(() => {
      if (cache.get(version3) === suspensePromise) {
        cache.delete(version3);
        if (!cache.size) {
          suspensePromiseCacheMap.delete(atom3);
        }
      }
    });
    cache.set(version3, suspensePromise);
  };
  const cancelAllSuspensePromiseInCache = (atom3) => {
    const versionSet = /* @__PURE__ */ new Set();
    const cache = suspensePromiseCacheMap.get(atom3);
    if (cache) {
      suspensePromiseCacheMap.delete(atom3);
      cache.forEach((suspensePromise, version3) => {
        cancelSuspensePromise(suspensePromise);
        versionSet.add(version3);
      });
    }
    return versionSet;
  };
  const versionedAtomStateMapMap = /* @__PURE__ */ new WeakMap();
  const getVersionedAtomStateMap = (version3) => {
    let versionedAtomStateMap = versionedAtomStateMapMap.get(version3);
    if (!versionedAtomStateMap) {
      versionedAtomStateMap = /* @__PURE__ */ new Map();
      versionedAtomStateMapMap.set(version3, versionedAtomStateMap);
    }
    return versionedAtomStateMap;
  };
  const getAtomState = (version3, atom3) => {
    if (version3) {
      const versionedAtomStateMap = getVersionedAtomStateMap(version3);
      let atomState = versionedAtomStateMap.get(atom3);
      if (!atomState) {
        atomState = getAtomState(version3.p, atom3);
        if (atomState && "p" in atomState && isSuspensePromiseAlreadyCancelled(atomState.p)) {
          atomState = void 0;
        }
        if (atomState) {
          versionedAtomStateMap.set(atom3, atomState);
        }
      }
      return atomState;
    }
    return committedAtomStateMap.get(atom3);
  };
  const setAtomState = (version3, atom3, atomState) => {
    if ((import.meta.env && import.meta.env.MODE) !== "production") {
      Object.freeze(atomState);
    }
    if (version3) {
      const versionedAtomStateMap = getVersionedAtomStateMap(version3);
      versionedAtomStateMap.set(atom3, atomState);
    } else {
      const prevAtomState = committedAtomStateMap.get(atom3);
      committedAtomStateMap.set(atom3, atomState);
      if (!pendingMap.has(atom3)) {
        pendingMap.set(atom3, prevAtomState);
      }
    }
  };
  const createReadDependencies = (version3, prevReadDependencies = /* @__PURE__ */ new Map(), dependencies) => {
    if (!dependencies) {
      return prevReadDependencies;
    }
    const readDependencies = /* @__PURE__ */ new Map();
    let changed = false;
    dependencies.forEach((atom3) => {
      var _a;
      const revision = ((_a = getAtomState(version3, atom3)) == null ? void 0 : _a.r) || 0;
      readDependencies.set(atom3, revision);
      if (prevReadDependencies.get(atom3) !== revision) {
        changed = true;
      }
    });
    if (prevReadDependencies.size === readDependencies.size && !changed) {
      return prevReadDependencies;
    }
    return readDependencies;
  };
  const setAtomValue = (version3, atom3, value, dependencies, suspensePromise) => {
    const atomState = getAtomState(version3, atom3);
    if (atomState) {
      if (suspensePromise && (!("p" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {
        return atomState;
      }
      if ("p" in atomState) {
        cancelSuspensePromise(atomState.p);
      }
    }
    const nextAtomState = {
      v: value,
      r: (atomState == null ? void 0 : atomState.r) || 0,
      y: true,
      // not invalidated
      d: createReadDependencies(version3, atomState == null ? void 0 : atomState.d, dependencies)
    };
    let changed = !(atomState == null ? void 0 : atomState.y);
    if (!atomState || !("v" in atomState) || // new value, or
    !Object.is(atomState.v, value)) {
      changed = true;
      ++nextAtomState.r;
      if (nextAtomState.d.has(atom3)) {
        nextAtomState.d = new Map(nextAtomState.d).set(atom3, nextAtomState.r);
      }
    } else if (nextAtomState.d !== atomState.d && (nextAtomState.d.size !== atomState.d.size || !Array.from(nextAtomState.d.keys()).every((a13) => atomState.d.has(a13)))) {
      changed = true;
      Promise.resolve().then(() => {
        flushPending(version3);
      });
    }
    if (atomState && !changed) {
      return atomState;
    }
    setAtomState(version3, atom3, nextAtomState);
    return nextAtomState;
  };
  const setAtomReadError = (version3, atom3, error2, dependencies, suspensePromise) => {
    const atomState = getAtomState(version3, atom3);
    if (atomState) {
      if (suspensePromise && (!("p" in atomState) || !isEqualSuspensePromise(atomState.p, suspensePromise))) {
        return atomState;
      }
      if ("p" in atomState) {
        cancelSuspensePromise(atomState.p);
      }
    }
    const nextAtomState = {
      e: error2,
      // set read error
      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,
      y: true,
      // not invalidated
      d: createReadDependencies(version3, atomState == null ? void 0 : atomState.d, dependencies)
    };
    setAtomState(version3, atom3, nextAtomState);
    return nextAtomState;
  };
  const setAtomSuspensePromise = (version3, atom3, suspensePromise, dependencies) => {
    const atomState = getAtomState(version3, atom3);
    if (atomState && "p" in atomState) {
      if (isEqualSuspensePromise(atomState.p, suspensePromise) && !isSuspensePromiseAlreadyCancelled(atomState.p)) {
        if (!atomState.y) {
          return { ...atomState, y: true };
        }
        return atomState;
      }
      cancelSuspensePromise(atomState.p);
    }
    addSuspensePromiseToCache(version3, atom3, suspensePromise);
    const nextAtomState = {
      p: suspensePromise,
      r: ((atomState == null ? void 0 : atomState.r) || 0) + 1,
      y: true,
      // not invalidated
      d: createReadDependencies(version3, atomState == null ? void 0 : atomState.d, dependencies)
    };
    setAtomState(version3, atom3, nextAtomState);
    return nextAtomState;
  };
  const setAtomPromiseOrValue = (version3, atom3, promiseOrValue, dependencies) => {
    if (promiseOrValue instanceof Promise) {
      const suspensePromise = createSuspensePromise(
        promiseOrValue,
        promiseOrValue.then((value) => {
          setAtomValue(version3, atom3, value, dependencies, suspensePromise);
        }).catch((e9) => {
          if (e9 instanceof Promise) {
            if (isSuspensePromise(e9)) {
              return e9.then(() => {
                readAtomState(version3, atom3, true);
              });
            }
            return e9;
          }
          setAtomReadError(version3, atom3, e9, dependencies, suspensePromise);
        })
      );
      return setAtomSuspensePromise(
        version3,
        atom3,
        suspensePromise,
        dependencies
      );
    }
    return setAtomValue(
      version3,
      atom3,
      promiseOrValue,
      dependencies
    );
  };
  const setAtomInvalidated = (version3, atom3) => {
    const atomState = getAtomState(version3, atom3);
    if (atomState) {
      const nextAtomState = {
        ...atomState,
        // copy everything
        y: false
        // invalidated
      };
      setAtomState(version3, atom3, nextAtomState);
    } else if ((import.meta.env && import.meta.env.MODE) !== "production") {
      console.warn("[Bug] could not invalidate non existing atom", atom3);
    }
  };
  const readAtomState = (version3, atom3, force) => {
    if (!force) {
      const atomState = getAtomState(version3, atom3);
      if (atomState) {
        if (atomState.y && // not invalidated
        "p" in atomState && !isSuspensePromiseAlreadyCancelled(atomState.p)) {
          return atomState;
        }
        atomState.d.forEach((_7, a13) => {
          if (a13 !== atom3) {
            if (!mountedMap.has(a13)) {
              readAtomState(version3, a13);
            } else {
              const aState = getAtomState(version3, a13);
              if (aState && !aState.y) {
                readAtomState(version3, a13);
              }
            }
          }
        });
        if (Array.from(atomState.d).every(([a13, r15]) => {
          const aState = getAtomState(version3, a13);
          return aState && !("p" in aState) && // has no suspense promise
          aState.r === r15;
        })) {
          if (!atomState.y) {
            return { ...atomState, y: true };
          }
          return atomState;
        }
      }
    }
    const dependencies = /* @__PURE__ */ new Set();
    try {
      const promiseOrValue = atom3.read((a13) => {
        dependencies.add(a13);
        const aState = a13 === atom3 ? getAtomState(version3, a13) : readAtomState(version3, a13);
        if (aState) {
          if ("e" in aState) {
            throw aState.e;
          }
          if ("p" in aState) {
            throw aState.p;
          }
          return aState.v;
        }
        if (hasInitialValue(a13)) {
          return a13.init;
        }
        throw new Error("no atom init");
      });
      return setAtomPromiseOrValue(version3, atom3, promiseOrValue, dependencies);
    } catch (errorOrPromise) {
      if (errorOrPromise instanceof Promise) {
        const suspensePromise = isSuspensePromise(errorOrPromise) && isSuspensePromiseAlreadyCancelled(errorOrPromise) ? copySuspensePromise(errorOrPromise) : createSuspensePromise(errorOrPromise, errorOrPromise);
        return setAtomSuspensePromise(
          version3,
          atom3,
          suspensePromise,
          dependencies
        );
      }
      return setAtomReadError(version3, atom3, errorOrPromise, dependencies);
    }
  };
  const readAtom = (readingAtom, version3) => {
    const atomState = readAtomState(version3, readingAtom);
    return atomState;
  };
  const addAtom = (version3, addingAtom) => {
    let mounted = mountedMap.get(addingAtom);
    if (!mounted) {
      mounted = mountAtom(version3, addingAtom);
    }
    return mounted;
  };
  const canUnmountAtom = (atom3, mounted) => !mounted.l.size && (!mounted.t.size || mounted.t.size === 1 && mounted.t.has(atom3));
  const delAtom = (version3, deletingAtom) => {
    const mounted = mountedMap.get(deletingAtom);
    if (mounted && canUnmountAtom(deletingAtom, mounted)) {
      unmountAtom(version3, deletingAtom);
    }
  };
  const invalidateDependents = (version3, atom3) => {
    const mounted = mountedMap.get(atom3);
    mounted == null ? void 0 : mounted.t.forEach((dependent) => {
      if (dependent !== atom3) {
        setAtomInvalidated(version3, dependent);
        invalidateDependents(version3, dependent);
      }
    });
  };
  const writeAtomState = (version3, atom3, update4) => {
    let isSync = true;
    const writeGetter = (a13, options) => {
      const aState = readAtomState(version3, a13);
      if ("e" in aState) {
        throw aState.e;
      }
      if ("p" in aState) {
        if (options == null ? void 0 : options.unstable_promise) {
          return aState.p.then(() => {
            const s20 = getAtomState(version3, a13);
            if (s20 && "p" in s20 && s20.p === aState.p) {
              return new Promise((resolve) => setTimeout(resolve)).then(
                () => writeGetter(a13, options)
              );
            }
            return writeGetter(a13, options);
          });
        }
        if ((import.meta.env && import.meta.env.MODE) !== "production") {
          console.info(
            "Reading pending atom state in write operation. We throw a promise for now.",
            a13
          );
        }
        throw aState.p;
      }
      if ("v" in aState) {
        return aState.v;
      }
      if ((import.meta.env && import.meta.env.MODE) !== "production") {
        console.warn(
          "[Bug] no value found while reading atom in write operation. This is probably a bug.",
          a13
        );
      }
      throw new Error("no value found");
    };
    const setter = (a13, v6) => {
      let promiseOrVoid2;
      if (a13 === atom3) {
        if (!hasInitialValue(a13)) {
          throw new Error("atom not writable");
        }
        const versionSet = cancelAllSuspensePromiseInCache(a13);
        versionSet.forEach((cancelledVersion) => {
          if (cancelledVersion !== version3) {
            setAtomPromiseOrValue(cancelledVersion, a13, v6);
          }
        });
        const prevAtomState = getAtomState(version3, a13);
        const nextAtomState = setAtomPromiseOrValue(version3, a13, v6);
        if (prevAtomState !== nextAtomState) {
          invalidateDependents(version3, a13);
        }
      } else {
        promiseOrVoid2 = writeAtomState(version3, a13, v6);
      }
      if (!isSync) {
        flushPending(version3);
      }
      return promiseOrVoid2;
    };
    const promiseOrVoid = atom3.write(writeGetter, setter, update4);
    isSync = false;
    return promiseOrVoid;
  };
  const writeAtom = (writingAtom, update4, version3) => {
    const promiseOrVoid = writeAtomState(version3, writingAtom, update4);
    flushPending(version3);
    return promiseOrVoid;
  };
  const isActuallyWritableAtom = (atom3) => !!atom3.write;
  const mountAtom = (version3, atom3, initialDependent) => {
    const mounted = {
      t: new Set(initialDependent && [initialDependent]),
      l: /* @__PURE__ */ new Set()
    };
    mountedMap.set(atom3, mounted);
    if ((import.meta.env && import.meta.env.MODE) !== "production") {
      mountedAtoms.add(atom3);
    }
    const atomState = readAtomState(void 0, atom3);
    atomState.d.forEach((_7, a13) => {
      const aMounted = mountedMap.get(a13);
      if (aMounted) {
        aMounted.t.add(atom3);
      } else {
        if (a13 !== atom3) {
          mountAtom(version3, a13, atom3);
        }
      }
    });
    if (isActuallyWritableAtom(atom3) && atom3.onMount) {
      const setAtom = (update4) => writeAtom(atom3, update4, version3);
      const onUnmount = atom3.onMount(setAtom);
      version3 = void 0;
      if (onUnmount) {
        mounted.u = onUnmount;
      }
    }
    return mounted;
  };
  const unmountAtom = (version3, atom3) => {
    var _a;
    const onUnmount = (_a = mountedMap.get(atom3)) == null ? void 0 : _a.u;
    if (onUnmount) {
      onUnmount();
    }
    mountedMap.delete(atom3);
    if ((import.meta.env && import.meta.env.MODE) !== "production") {
      mountedAtoms.delete(atom3);
    }
    const atomState = getAtomState(version3, atom3);
    if (atomState) {
      if ("p" in atomState) {
        cancelSuspensePromise(atomState.p);
      }
      atomState.d.forEach((_7, a13) => {
        if (a13 !== atom3) {
          const mounted = mountedMap.get(a13);
          if (mounted) {
            mounted.t.delete(atom3);
            if (canUnmountAtom(a13, mounted)) {
              unmountAtom(version3, a13);
            }
          }
        }
      });
    } else if ((import.meta.env && import.meta.env.MODE) !== "production") {
      console.warn("[Bug] could not find atom state to unmount", atom3);
    }
  };
  const mountDependencies = (version3, atom3, atomState, prevReadDependencies) => {
    const dependencies = new Set(atomState.d.keys());
    prevReadDependencies == null ? void 0 : prevReadDependencies.forEach((_7, a13) => {
      if (dependencies.has(a13)) {
        dependencies.delete(a13);
        return;
      }
      const mounted = mountedMap.get(a13);
      if (mounted) {
        mounted.t.delete(atom3);
        if (canUnmountAtom(a13, mounted)) {
          unmountAtom(version3, a13);
        }
      }
    });
    dependencies.forEach((a13) => {
      const mounted = mountedMap.get(a13);
      if (mounted) {
        mounted.t.add(atom3);
      } else if (mountedMap.has(atom3)) {
        mountAtom(version3, a13, atom3);
      }
    });
  };
  const flushPending = (version3) => {
    if (version3) {
      const versionedAtomStateMap = getVersionedAtomStateMap(version3);
      versionedAtomStateMap.forEach((atomState, atom3) => {
        const committedAtomState = committedAtomStateMap.get(atom3);
        if (atomState !== committedAtomState) {
          const mounted = mountedMap.get(atom3);
          mounted == null ? void 0 : mounted.l.forEach((listener) => listener(version3));
        }
      });
      return;
    }
    while (pendingMap.size) {
      const pending = Array.from(pendingMap);
      pendingMap.clear();
      pending.forEach(([atom3, prevAtomState]) => {
        const atomState = getAtomState(void 0, atom3);
        if (atomState && atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {
          mountDependencies(void 0, atom3, atomState, prevAtomState == null ? void 0 : prevAtomState.d);
        }
        if (prevAtomState && !prevAtomState.y && // invalidated
        (atomState == null ? void 0 : atomState.y)) {
          return;
        }
        const mounted = mountedMap.get(atom3);
        mounted == null ? void 0 : mounted.l.forEach((listener) => listener());
      });
    }
    if ((import.meta.env && import.meta.env.MODE) !== "production") {
      stateListeners.forEach((l14) => l14());
    }
  };
  const commitVersionedAtomStateMap = (version3) => {
    const versionedAtomStateMap = getVersionedAtomStateMap(version3);
    versionedAtomStateMap.forEach((atomState, atom3) => {
      const prevAtomState = committedAtomStateMap.get(atom3);
      if (!prevAtomState || atomState.r > prevAtomState.r || atomState.y !== prevAtomState.y || atomState.r === prevAtomState.r && atomState.d !== prevAtomState.d) {
        committedAtomStateMap.set(atom3, atomState);
        if (atomState.d !== (prevAtomState == null ? void 0 : prevAtomState.d)) {
          mountDependencies(version3, atom3, atomState, prevAtomState == null ? void 0 : prevAtomState.d);
        }
      }
    });
  };
  const commitAtom = (_atom, version3) => {
    if (version3) {
      commitVersionedAtomStateMap(version3);
    }
    flushPending(void 0);
  };
  const subscribeAtom = (atom3, callback, version3) => {
    const mounted = addAtom(version3, atom3);
    const listeners = mounted.l;
    listeners.add(callback);
    return () => {
      listeners.delete(callback);
      delAtom(version3, atom3);
    };
  };
  const restoreAtoms = (values3, version3) => {
    for (const [atom3, value] of values3) {
      if (hasInitialValue(atom3)) {
        setAtomPromiseOrValue(version3, atom3, value);
        invalidateDependents(version3, atom3);
      }
    }
    flushPending(version3);
  };
  if ((import.meta.env && import.meta.env.MODE) !== "production") {
    return {
      [READ_ATOM]: readAtom,
      [WRITE_ATOM]: writeAtom,
      [COMMIT_ATOM]: commitAtom,
      [SUBSCRIBE_ATOM]: subscribeAtom,
      [RESTORE_ATOMS]: restoreAtoms,
      [DEV_SUBSCRIBE_STATE]: (l14) => {
        stateListeners.add(l14);
        return () => {
          stateListeners.delete(l14);
        };
      },
      [DEV_GET_MOUNTED_ATOMS]: () => mountedAtoms.values(),
      [DEV_GET_ATOM_STATE]: (a13) => committedAtomStateMap.get(a13),
      [DEV_GET_MOUNTED]: (a13) => mountedMap.get(a13)
    };
  }
  return {
    [READ_ATOM]: readAtom,
    [WRITE_ATOM]: writeAtom,
    [COMMIT_ATOM]: commitAtom,
    [SUBSCRIBE_ATOM]: subscribeAtom,
    [RESTORE_ATOMS]: restoreAtoms
  };
};
var createScopeContainer = (initialValues, unstable_createStore) => {
  const store = unstable_createStore ? unstable_createStore(initialValues).SECRET_INTERNAL_store : createStore(initialValues);
  return { s: store };
};
var ScopeContextMap = /* @__PURE__ */ new Map();
var getScopeContext = (scope) => {
  if (!ScopeContextMap.has(scope)) {
    ScopeContextMap.set(scope, (0, import_react.createContext)(createScopeContainer()));
  }
  return ScopeContextMap.get(scope);
};
var Provider = ({
  children,
  initialValues,
  scope,
  unstable_createStore,
  unstable_enableVersionedWrite
}) => {
  const [version3, setVersion] = (0, import_react.useState)({});
  (0, import_react.useEffect)(() => {
    const scopeContainer = scopeContainerRef.current;
    if (scopeContainer.w) {
      scopeContainer.s[COMMIT_ATOM](null, version3);
      delete version3.p;
      scopeContainer.v = version3;
    }
  }, [version3]);
  const scopeContainerRef = (0, import_react.useRef)();
  if (!scopeContainerRef.current) {
    const scopeContainer = createScopeContainer(
      initialValues,
      unstable_createStore
    );
    if (unstable_enableVersionedWrite) {
      let retrying = 0;
      scopeContainer.w = (write) => {
        setVersion((parentVersion) => {
          const nextVersion = retrying ? parentVersion : { p: parentVersion };
          write(nextVersion);
          return nextVersion;
        });
      };
      scopeContainer.v = version3;
      scopeContainer.r = (fn2) => {
        ++retrying;
        fn2();
        --retrying;
      };
    }
    scopeContainerRef.current = scopeContainer;
  }
  const ScopeContainerContext = getScopeContext(scope);
  return (0, import_react.createElement)(
    ScopeContainerContext.Provider,
    {
      value: scopeContainerRef.current
    },
    children
  );
};
function atom2(read, write) {
  return atom(read, write);
}
function useAtomValue(atom3, scope) {
  const ScopeContext = getScopeContext(scope);
  const scopeContainer = (0, import_react.useContext)(ScopeContext);
  const { s: store, v: versionFromProvider } = scopeContainer;
  const getAtomValue = (version22) => {
    const atomState = store[READ_ATOM](atom3, version22);
    if ((import.meta.env && import.meta.env.MODE) !== "production" && !atomState.y) {
      throw new Error("should not be invalidated");
    }
    if ("e" in atomState) {
      throw atomState.e;
    }
    if ("p" in atomState) {
      throw atomState.p;
    }
    if ("v" in atomState) {
      return atomState.v;
    }
    throw new Error("no atom value");
  };
  const [[version3, valueFromReducer, atomFromReducer], rerenderIfChanged] = (0, import_react.useReducer)(
    (prev, nextVersion) => {
      const nextValue = getAtomValue(nextVersion);
      if (Object.is(prev[1], nextValue) && prev[2] === atom3) {
        return prev;
      }
      return [nextVersion, nextValue, atom3];
    },
    versionFromProvider,
    (initialVersion) => {
      const initialValue = getAtomValue(initialVersion);
      return [initialVersion, initialValue, atom3];
    }
  );
  let value = valueFromReducer;
  if (atomFromReducer !== atom3) {
    rerenderIfChanged(version3);
    value = getAtomValue(version3);
  }
  (0, import_react.useEffect)(() => {
    const { v: versionFromProvider2 } = scopeContainer;
    if (versionFromProvider2) {
      store[COMMIT_ATOM](atom3, versionFromProvider2);
    }
    const unsubscribe = store[SUBSCRIBE_ATOM](
      atom3,
      rerenderIfChanged,
      versionFromProvider2
    );
    rerenderIfChanged(versionFromProvider2);
    return unsubscribe;
  }, [store, atom3, scopeContainer]);
  (0, import_react.useEffect)(() => {
    store[COMMIT_ATOM](atom3, version3);
  });
  (0, import_react.useDebugValue)(value);
  return value;
}
function useSetAtom(atom3, scope) {
  const ScopeContext = getScopeContext(scope);
  const { s: store, w: versionedWrite } = (0, import_react.useContext)(ScopeContext);
  const setAtom = (0, import_react.useCallback)(
    (update4) => {
      if ((import.meta.env && import.meta.env.MODE) !== "production" && !("write" in atom3)) {
        throw new Error("not writable atom");
      }
      const write = (version3) => store[WRITE_ATOM](atom3, update4, version3);
      return versionedWrite ? versionedWrite(write) : write();
    },
    [store, versionedWrite, atom3]
  );
  return setAtom;
}
function useAtom(atom3, scope) {
  if ("scope" in atom3) {
    console.warn(
      "atom.scope is deprecated. Please do useAtom(atom, scope) instead."
    );
    scope = atom3.scope;
  }
  return [
    useAtomValue(atom3, scope),
    // We do wrong type assertion here, which results in throwing an error.
    useSetAtom(atom3, scope)
  ];
}

// node_modules/@udecode/plate-core/dist/index.es.js
var import_react7 = __toESM(require_react());

// node_modules/slate-react/dist/index.es.js
var import_react2 = __toESM(require_react());

// node_modules/is-plain-object/dist/is-plain-object.mjs
function isObject(o16) {
  return Object.prototype.toString.call(o16) === "[object Object]";
}
function isPlainObject(o16) {
  var ctor, prot;
  if (isObject(o16) === false)
    return false;
  ctor = o16.constructor;
  if (ctor === void 0)
    return true;
  prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}

// node_modules/immer/dist/immer.esm.mjs
function n(n12) {
  for (var r15 = arguments.length, t20 = Array(r15 > 1 ? r15 - 1 : 0), e9 = 1; e9 < r15; e9++)
    t20[e9 - 1] = arguments[e9];
  if (true) {
    var i15 = Y[n12], o16 = i15 ? "function" == typeof i15 ? i15.apply(null, t20) : i15 : "unknown error nr: " + n12;
    throw Error("[Immer] " + o16);
  }
  throw Error("[Immer] minified error nr: " + n12 + (t20.length ? " " + t20.map(function(n13) {
    return "'" + n13 + "'";
  }).join(",") : "") + ". Find the full error at: https://bit.ly/3cXEKWf");
}
function r(n12) {
  return !!n12 && !!n12[Q];
}
function t(n12) {
  var r15;
  return !!n12 && (function(n13) {
    if (!n13 || "object" != typeof n13)
      return false;
    var r16 = Object.getPrototypeOf(n13);
    if (null === r16)
      return true;
    var t20 = Object.hasOwnProperty.call(r16, "constructor") && r16.constructor;
    return t20 === Object || "function" == typeof t20 && Function.toString.call(t20) === Z;
  }(n12) || Array.isArray(n12) || !!n12[L] || !!(null === (r15 = n12.constructor) || void 0 === r15 ? void 0 : r15[L]) || s(n12) || v(n12));
}
function i(n12, r15, t20) {
  void 0 === t20 && (t20 = false), 0 === o(n12) ? (t20 ? Object.keys : nn)(n12).forEach(function(e9) {
    t20 && "symbol" == typeof e9 || r15(e9, n12[e9], n12);
  }) : n12.forEach(function(t21, e9) {
    return r15(e9, t21, n12);
  });
}
function o(n12) {
  var r15 = n12[Q];
  return r15 ? r15.i > 3 ? r15.i - 4 : r15.i : Array.isArray(n12) ? 1 : s(n12) ? 2 : v(n12) ? 3 : 0;
}
function u(n12, r15) {
  return 2 === o(n12) ? n12.has(r15) : Object.prototype.hasOwnProperty.call(n12, r15);
}
function a(n12, r15) {
  return 2 === o(n12) ? n12.get(r15) : n12[r15];
}
function f(n12, r15, t20) {
  var e9 = o(n12);
  2 === e9 ? n12.set(r15, t20) : 3 === e9 ? n12.add(t20) : n12[r15] = t20;
}
function c(n12, r15) {
  return n12 === r15 ? 0 !== n12 || 1 / n12 == 1 / r15 : n12 != n12 && r15 != r15;
}
function s(n12) {
  return X && n12 instanceof Map;
}
function v(n12) {
  return q && n12 instanceof Set;
}
function p(n12) {
  return n12.o || n12.t;
}
function l(n12) {
  if (Array.isArray(n12))
    return Array.prototype.slice.call(n12);
  var r15 = rn(n12);
  delete r15[Q];
  for (var t20 = nn(r15), e9 = 0; e9 < t20.length; e9++) {
    var i15 = t20[e9], o16 = r15[i15];
    false === o16.writable && (o16.writable = true, o16.configurable = true), (o16.get || o16.set) && (r15[i15] = { configurable: true, writable: true, enumerable: o16.enumerable, value: n12[i15] });
  }
  return Object.create(Object.getPrototypeOf(n12), r15);
}
function d(n12, e9) {
  return void 0 === e9 && (e9 = false), y(n12) || r(n12) || !t(n12) || (o(n12) > 1 && (n12.set = n12.add = n12.clear = n12.delete = h), Object.freeze(n12), e9 && i(n12, function(n13, r15) {
    return d(r15, true);
  }, true)), n12;
}
function h() {
  n(2);
}
function y(n12) {
  return null == n12 || "object" != typeof n12 || Object.isFrozen(n12);
}
function b(r15) {
  var t20 = tn[r15];
  return t20 || n(18, r15), t20;
}
function m(n12, r15) {
  tn[n12] || (tn[n12] = r15);
}
function _() {
  return U || n(0), U;
}
function j(n12, r15) {
  r15 && (b("Patches"), n12.u = [], n12.s = [], n12.v = r15);
}
function g(n12) {
  O(n12), n12.p.forEach(S), n12.p = null;
}
function O(n12) {
  n12 === U && (U = n12.l);
}
function w(n12) {
  return U = { p: [], l: U, h: n12, m: true, _: 0 };
}
function S(n12) {
  var r15 = n12[Q];
  0 === r15.i || 1 === r15.i ? r15.j() : r15.g = true;
}
function P(r15, e9) {
  e9._ = e9.p.length;
  var i15 = e9.p[0], o16 = void 0 !== r15 && r15 !== i15;
  return e9.h.O || b("ES5").S(e9, r15, o16), o16 ? (i15[Q].P && (g(e9), n(4)), t(r15) && (r15 = M(e9, r15), e9.l || x(e9, r15)), e9.u && b("Patches").M(i15[Q].t, r15, e9.u, e9.s)) : r15 = M(e9, i15, []), g(e9), e9.u && e9.v(e9.u, e9.s), r15 !== H ? r15 : void 0;
}
function M(n12, r15, t20) {
  if (y(r15))
    return r15;
  var e9 = r15[Q];
  if (!e9)
    return i(r15, function(i15, o17) {
      return A(n12, e9, r15, i15, o17, t20);
    }, true), r15;
  if (e9.A !== n12)
    return r15;
  if (!e9.P)
    return x(n12, e9.t, true), e9.t;
  if (!e9.I) {
    e9.I = true, e9.A._--;
    var o16 = 4 === e9.i || 5 === e9.i ? e9.o = l(e9.k) : e9.o, u11 = o16, a13 = false;
    3 === e9.i && (u11 = new Set(o16), o16.clear(), a13 = true), i(u11, function(r16, i15) {
      return A(n12, e9, o16, r16, i15, t20, a13);
    }), x(n12, o16, false), t20 && n12.u && b("Patches").N(e9, t20, n12.u, n12.s);
  }
  return e9.o;
}
function A(e9, i15, o16, a13, c16, s20, v6) {
  if (c16 === o16 && n(5), r(c16)) {
    var p12 = M(e9, c16, s20 && i15 && 3 !== i15.i && !u(i15.R, a13) ? s20.concat(a13) : void 0);
    if (f(o16, a13, p12), !r(p12))
      return;
    e9.m = false;
  } else
    v6 && o16.add(c16);
  if (t(c16) && !y(c16)) {
    if (!e9.h.D && e9._ < 1)
      return;
    M(e9, c16), i15 && i15.A.l || x(e9, c16);
  }
}
function x(n12, r15, t20) {
  void 0 === t20 && (t20 = false), !n12.l && n12.h.D && n12.m && d(r15, t20);
}
function z2(n12, r15) {
  var t20 = n12[Q];
  return (t20 ? p(t20) : n12)[r15];
}
function I(n12, r15) {
  if (r15 in n12)
    for (var t20 = Object.getPrototypeOf(n12); t20; ) {
      var e9 = Object.getOwnPropertyDescriptor(t20, r15);
      if (e9)
        return e9;
      t20 = Object.getPrototypeOf(t20);
    }
}
function k(n12) {
  n12.P || (n12.P = true, n12.l && k(n12.l));
}
function E(n12) {
  n12.o || (n12.o = l(n12.t));
}
function N(n12, r15, t20) {
  var e9 = s(r15) ? b("MapSet").F(r15, t20) : v(r15) ? b("MapSet").T(r15, t20) : n12.O ? function(n13, r16) {
    var t21 = Array.isArray(n13), e10 = { i: t21 ? 1 : 0, A: r16 ? r16.A : _(), P: false, I: false, R: {}, l: r16, t: n13, k: null, o: null, j: null, C: false }, i15 = e10, o16 = en;
    t21 && (i15 = [e10], o16 = on);
    var u11 = Proxy.revocable(i15, o16), a13 = u11.revoke, f16 = u11.proxy;
    return e10.k = f16, e10.j = a13, f16;
  }(r15, t20) : b("ES5").J(r15, t20);
  return (t20 ? t20.A : _()).p.push(e9), e9;
}
function R(e9) {
  return r(e9) || n(22, e9), function n12(r15) {
    if (!t(r15))
      return r15;
    var e10, u11 = r15[Q], c16 = o(r15);
    if (u11) {
      if (!u11.P && (u11.i < 4 || !b("ES5").K(u11)))
        return u11.t;
      u11.I = true, e10 = D(r15, c16), u11.I = false;
    } else
      e10 = D(r15, c16);
    return i(e10, function(r16, t20) {
      u11 && a(u11.t, r16) === t20 || f(e10, r16, n12(t20));
    }), 3 === c16 ? new Set(e10) : e10;
  }(e9);
}
function D(n12, r15) {
  switch (r15) {
    case 2:
      return new Map(n12);
    case 3:
      return Array.from(n12);
  }
  return l(n12);
}
function C() {
  function r15(n12, r16) {
    function t20() {
      this.constructor = n12;
    }
    a13(n12, r16), n12.prototype = (t20.prototype = r16.prototype, new t20());
  }
  function e9(n12) {
    n12.o || (n12.R = /* @__PURE__ */ new Map(), n12.o = new Map(n12.t));
  }
  function o16(n12) {
    n12.o || (n12.o = /* @__PURE__ */ new Set(), n12.t.forEach(function(r16) {
      if (t(r16)) {
        var e10 = N(n12.A.h, r16, n12);
        n12.p.set(r16, e10), n12.o.add(e10);
      } else
        n12.o.add(r16);
    }));
  }
  function u11(r16) {
    r16.g && n(3, JSON.stringify(p(r16)));
  }
  var a13 = function(n12, r16) {
    return (a13 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n13, r17) {
      n13.__proto__ = r17;
    } || function(n13, r17) {
      for (var t20 in r17)
        r17.hasOwnProperty(t20) && (n13[t20] = r17[t20]);
    })(n12, r16);
  }, f16 = function() {
    function n12(n13, r16) {
      return this[Q] = { i: 2, l: r16, A: r16 ? r16.A : _(), P: false, I: false, o: void 0, R: void 0, t: n13, k: this, C: false, g: false }, this;
    }
    r15(n12, Map);
    var o17 = n12.prototype;
    return Object.defineProperty(o17, "size", { get: function() {
      return p(this[Q]).size;
    } }), o17.has = function(n13) {
      return p(this[Q]).has(n13);
    }, o17.set = function(n13, r16) {
      var t20 = this[Q];
      return u11(t20), p(t20).has(n13) && p(t20).get(n13) === r16 || (e9(t20), k(t20), t20.R.set(n13, true), t20.o.set(n13, r16), t20.R.set(n13, true)), this;
    }, o17.delete = function(n13) {
      if (!this.has(n13))
        return false;
      var r16 = this[Q];
      return u11(r16), e9(r16), k(r16), r16.t.has(n13) ? r16.R.set(n13, false) : r16.R.delete(n13), r16.o.delete(n13), true;
    }, o17.clear = function() {
      var n13 = this[Q];
      u11(n13), p(n13).size && (e9(n13), k(n13), n13.R = /* @__PURE__ */ new Map(), i(n13.t, function(r16) {
        n13.R.set(r16, false);
      }), n13.o.clear());
    }, o17.forEach = function(n13, r16) {
      var t20 = this;
      p(this[Q]).forEach(function(e10, i15) {
        n13.call(r16, t20.get(i15), i15, t20);
      });
    }, o17.get = function(n13) {
      var r16 = this[Q];
      u11(r16);
      var i15 = p(r16).get(n13);
      if (r16.I || !t(i15))
        return i15;
      if (i15 !== r16.t.get(n13))
        return i15;
      var o18 = N(r16.A.h, i15, r16);
      return e9(r16), r16.o.set(n13, o18), o18;
    }, o17.keys = function() {
      return p(this[Q]).keys();
    }, o17.values = function() {
      var n13, r16 = this, t20 = this.keys();
      return (n13 = {})[V] = function() {
        return r16.values();
      }, n13.next = function() {
        var n14 = t20.next();
        return n14.done ? n14 : { done: false, value: r16.get(n14.value) };
      }, n13;
    }, o17.entries = function() {
      var n13, r16 = this, t20 = this.keys();
      return (n13 = {})[V] = function() {
        return r16.entries();
      }, n13.next = function() {
        var n14 = t20.next();
        if (n14.done)
          return n14;
        var e10 = r16.get(n14.value);
        return { done: false, value: [n14.value, e10] };
      }, n13;
    }, o17[V] = function() {
      return this.entries();
    }, n12;
  }(), c16 = function() {
    function n12(n13, r16) {
      return this[Q] = { i: 3, l: r16, A: r16 ? r16.A : _(), P: false, I: false, o: void 0, t: n13, k: this, p: /* @__PURE__ */ new Map(), g: false, C: false }, this;
    }
    r15(n12, Set);
    var t20 = n12.prototype;
    return Object.defineProperty(t20, "size", { get: function() {
      return p(this[Q]).size;
    } }), t20.has = function(n13) {
      var r16 = this[Q];
      return u11(r16), r16.o ? !!r16.o.has(n13) || !(!r16.p.has(n13) || !r16.o.has(r16.p.get(n13))) : r16.t.has(n13);
    }, t20.add = function(n13) {
      var r16 = this[Q];
      return u11(r16), this.has(n13) || (o16(r16), k(r16), r16.o.add(n13)), this;
    }, t20.delete = function(n13) {
      if (!this.has(n13))
        return false;
      var r16 = this[Q];
      return u11(r16), o16(r16), k(r16), r16.o.delete(n13) || !!r16.p.has(n13) && r16.o.delete(r16.p.get(n13));
    }, t20.clear = function() {
      var n13 = this[Q];
      u11(n13), p(n13).size && (o16(n13), k(n13), n13.o.clear());
    }, t20.values = function() {
      var n13 = this[Q];
      return u11(n13), o16(n13), n13.o.values();
    }, t20.entries = function() {
      var n13 = this[Q];
      return u11(n13), o16(n13), n13.o.entries();
    }, t20.keys = function() {
      return this.values();
    }, t20[V] = function() {
      return this.values();
    }, t20.forEach = function(n13, r16) {
      for (var t21 = this.values(), e10 = t21.next(); !e10.done; )
        n13.call(r16, e10.value, e10.value, this), e10 = t21.next();
    }, n12;
  }();
  m("MapSet", { F: function(n12, r16) {
    return new f16(n12, r16);
  }, T: function(n12, r16) {
    return new c16(n12, r16);
  } });
}
var G;
var U;
var W = "undefined" != typeof Symbol && "symbol" == typeof Symbol("x");
var X = "undefined" != typeof Map;
var q = "undefined" != typeof Set;
var B = "undefined" != typeof Proxy && void 0 !== Proxy.revocable && "undefined" != typeof Reflect;
var H = W ? Symbol.for("immer-nothing") : ((G = {})["immer-nothing"] = true, G);
var L = W ? Symbol.for("immer-draftable") : "__$immer_draftable";
var Q = W ? Symbol.for("immer-state") : "__$immer_state";
var V = "undefined" != typeof Symbol && Symbol.iterator || "@@iterator";
var Y = { 0: "Illegal state", 1: "Immer drafts cannot have computed properties", 2: "This object has been frozen and should not be mutated", 3: function(n12) {
  return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + n12;
}, 4: "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.", 5: "Immer forbids circular references", 6: "The first or second argument to `produce` must be a function", 7: "The third argument to `produce` must be a function or undefined", 8: "First argument to `createDraft` must be a plain object, an array, or an immerable object", 9: "First argument to `finishDraft` must be a draft returned by `createDraft`", 10: "The given draft is already finalized", 11: "Object.defineProperty() cannot be used on an Immer draft", 12: "Object.setPrototypeOf() cannot be used on an Immer draft", 13: "Immer only supports deleting array indices", 14: "Immer only supports setting array indices and the 'length' property", 15: function(n12) {
  return "Cannot apply patch, path doesn't resolve: " + n12;
}, 16: 'Sets cannot have "replace" patches.', 17: function(n12) {
  return "Unsupported patch operation: " + n12;
}, 18: function(n12) {
  return "The plugin for '" + n12 + "' has not been loaded into Immer. To enable the plugin, import and call `enable" + n12 + "()` when initializing your application.";
}, 20: "Cannot use proxies if Proxy, Proxy.revocable or Reflect are not available", 21: function(n12) {
  return "produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '" + n12 + "'";
}, 22: function(n12) {
  return "'current' expects a draft, got: " + n12;
}, 23: function(n12) {
  return "'original' expects a draft, got: " + n12;
}, 24: "Patching reserved attributes like __proto__, prototype and constructor is not allowed" };
var Z = "" + Object.prototype.constructor;
var nn = "undefined" != typeof Reflect && Reflect.ownKeys ? Reflect.ownKeys : void 0 !== Object.getOwnPropertySymbols ? function(n12) {
  return Object.getOwnPropertyNames(n12).concat(Object.getOwnPropertySymbols(n12));
} : Object.getOwnPropertyNames;
var rn = Object.getOwnPropertyDescriptors || function(n12) {
  var r15 = {};
  return nn(n12).forEach(function(t20) {
    r15[t20] = Object.getOwnPropertyDescriptor(n12, t20);
  }), r15;
};
var tn = {};
var en = { get: function(n12, r15) {
  if (r15 === Q)
    return n12;
  var e9 = p(n12);
  if (!u(e9, r15))
    return function(n13, r16, t20) {
      var e10, i16 = I(r16, t20);
      return i16 ? "value" in i16 ? i16.value : null === (e10 = i16.get) || void 0 === e10 ? void 0 : e10.call(n13.k) : void 0;
    }(n12, e9, r15);
  var i15 = e9[r15];
  return n12.I || !t(i15) ? i15 : i15 === z2(n12.t, r15) ? (E(n12), n12.o[r15] = N(n12.A.h, i15, n12)) : i15;
}, has: function(n12, r15) {
  return r15 in p(n12);
}, ownKeys: function(n12) {
  return Reflect.ownKeys(p(n12));
}, set: function(n12, r15, t20) {
  var e9 = I(p(n12), r15);
  if (null == e9 ? void 0 : e9.set)
    return e9.set.call(n12.k, t20), true;
  if (!n12.P) {
    var i15 = z2(p(n12), r15), o16 = null == i15 ? void 0 : i15[Q];
    if (o16 && o16.t === t20)
      return n12.o[r15] = t20, n12.R[r15] = false, true;
    if (c(t20, i15) && (void 0 !== t20 || u(n12.t, r15)))
      return true;
    E(n12), k(n12);
  }
  return n12.o[r15] === t20 && (void 0 !== t20 || r15 in n12.o) || Number.isNaN(t20) && Number.isNaN(n12.o[r15]) || (n12.o[r15] = t20, n12.R[r15] = true), true;
}, deleteProperty: function(n12, r15) {
  return void 0 !== z2(n12.t, r15) || r15 in n12.t ? (n12.R[r15] = false, E(n12), k(n12)) : delete n12.R[r15], n12.o && delete n12.o[r15], true;
}, getOwnPropertyDescriptor: function(n12, r15) {
  var t20 = p(n12), e9 = Reflect.getOwnPropertyDescriptor(t20, r15);
  return e9 ? { writable: true, configurable: 1 !== n12.i || "length" !== r15, enumerable: e9.enumerable, value: t20[r15] } : e9;
}, defineProperty: function() {
  n(11);
}, getPrototypeOf: function(n12) {
  return Object.getPrototypeOf(n12.t);
}, setPrototypeOf: function() {
  n(12);
} };
var on = {};
i(en, function(n12, r15) {
  on[n12] = function() {
    return arguments[0] = arguments[0][0], r15.apply(this, arguments);
  };
}), on.deleteProperty = function(r15, t20) {
  return isNaN(parseInt(t20)) && n(13), on.set.call(this, r15, t20, void 0);
}, on.set = function(r15, t20, e9) {
  return "length" !== t20 && isNaN(parseInt(t20)) && n(14), en.set.call(this, r15[0], t20, e9, r15[0]);
};
var un = function() {
  function e9(r15) {
    var e10 = this;
    this.O = B, this.D = true, this.produce = function(r16, i16, o16) {
      if ("function" == typeof r16 && "function" != typeof i16) {
        var u11 = i16;
        i16 = r16;
        var a13 = e10;
        return function(n12) {
          var r17 = this;
          void 0 === n12 && (n12 = u11);
          for (var t20 = arguments.length, e11 = Array(t20 > 1 ? t20 - 1 : 0), o17 = 1; o17 < t20; o17++)
            e11[o17 - 1] = arguments[o17];
          return a13.produce(n12, function(n13) {
            var t21;
            return (t21 = i16).call.apply(t21, [r17, n13].concat(e11));
          });
        };
      }
      var f16;
      if ("function" != typeof i16 && n(6), void 0 !== o16 && "function" != typeof o16 && n(7), t(r16)) {
        var c16 = w(e10), s20 = N(e10, r16, void 0), v6 = true;
        try {
          f16 = i16(s20), v6 = false;
        } finally {
          v6 ? g(c16) : O(c16);
        }
        return "undefined" != typeof Promise && f16 instanceof Promise ? f16.then(function(n12) {
          return j(c16, o16), P(n12, c16);
        }, function(n12) {
          throw g(c16), n12;
        }) : (j(c16, o16), P(f16, c16));
      }
      if (!r16 || "object" != typeof r16) {
        if (void 0 === (f16 = i16(r16)) && (f16 = r16), f16 === H && (f16 = void 0), e10.D && d(f16, true), o16) {
          var p12 = [], l14 = [];
          b("Patches").M(r16, f16, p12, l14), o16(p12, l14);
        }
        return f16;
      }
      n(21, r16);
    }, this.produceWithPatches = function(n12, r16) {
      if ("function" == typeof n12)
        return function(r17) {
          for (var t21 = arguments.length, i17 = Array(t21 > 1 ? t21 - 1 : 0), o17 = 1; o17 < t21; o17++)
            i17[o17 - 1] = arguments[o17];
          return e10.produceWithPatches(r17, function(r18) {
            return n12.apply(void 0, [r18].concat(i17));
          });
        };
      var t20, i16, o16 = e10.produce(n12, r16, function(n13, r17) {
        t20 = n13, i16 = r17;
      });
      return "undefined" != typeof Promise && o16 instanceof Promise ? o16.then(function(n13) {
        return [n13, t20, i16];
      }) : [o16, t20, i16];
    }, "boolean" == typeof (null == r15 ? void 0 : r15.useProxies) && this.setUseProxies(r15.useProxies), "boolean" == typeof (null == r15 ? void 0 : r15.autoFreeze) && this.setAutoFreeze(r15.autoFreeze);
  }
  var i15 = e9.prototype;
  return i15.createDraft = function(e10) {
    t(e10) || n(8), r(e10) && (e10 = R(e10));
    var i16 = w(this), o16 = N(this, e10, void 0);
    return o16[Q].C = true, O(i16), o16;
  }, i15.finishDraft = function(r15, t20) {
    var e10 = r15 && r15[Q];
    e10 && e10.C || n(9), e10.I && n(10);
    var i16 = e10.A;
    return j(i16, t20), P(void 0, i16);
  }, i15.setAutoFreeze = function(n12) {
    this.D = n12;
  }, i15.setUseProxies = function(r15) {
    r15 && !B && n(20), this.O = r15;
  }, i15.applyPatches = function(n12, t20) {
    var e10;
    for (e10 = t20.length - 1; e10 >= 0; e10--) {
      var i16 = t20[e10];
      if (0 === i16.path.length && "replace" === i16.op) {
        n12 = i16.value;
        break;
      }
    }
    e10 > -1 && (t20 = t20.slice(e10 + 1));
    var o16 = b("Patches").$;
    return r(n12) ? o16(n12, t20) : this.produce(n12, function(n13) {
      return o16(n13, t20);
    });
  }, e9;
}();
var an = new un();
var fn = an.produce;
var cn = an.produceWithPatches.bind(an);
var sn = an.setAutoFreeze.bind(an);
var vn = an.setUseProxies.bind(an);
var pn = an.applyPatches.bind(an);
var ln = an.createDraft.bind(an);
var dn = an.finishDraft.bind(an);
var immer_esm_default = fn;

// node_modules/slate/dist/index.es.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var DIRTY_PATHS = /* @__PURE__ */ new WeakMap();
var DIRTY_PATH_KEYS = /* @__PURE__ */ new WeakMap();
var FLUSHING = /* @__PURE__ */ new WeakMap();
var NORMALIZING = /* @__PURE__ */ new WeakMap();
var PATH_REFS = /* @__PURE__ */ new WeakMap();
var POINT_REFS = /* @__PURE__ */ new WeakMap();
var RANGE_REFS = /* @__PURE__ */ new WeakMap();
function ownKeys$9(object2, enumerableOnly) {
  var keys6 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys6.push.apply(keys6, symbols);
  }
  return keys6;
}
function _objectSpread$9(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15] != null ? arguments[i15] : {};
    if (i15 % 2) {
      ownKeys$9(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$9(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var createEditor = () => {
  var editor = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isInline: () => false,
    isVoid: () => false,
    onChange: () => {
    },
    apply: (op) => {
      for (var ref2 of Editor.pathRefs(editor)) {
        PathRef.transform(ref2, op);
      }
      for (var _ref of Editor.pointRefs(editor)) {
        PointRef.transform(_ref, op);
      }
      for (var _ref2 of Editor.rangeRefs(editor)) {
        RangeRef.transform(_ref2, op);
      }
      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];
      var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || /* @__PURE__ */ new Set();
      var dirtyPaths;
      var dirtyPathKeys;
      var add4 = (path2) => {
        if (path2) {
          var key = path2.join(",");
          if (!dirtyPathKeys.has(key)) {
            dirtyPathKeys.add(key);
            dirtyPaths.push(path2);
          }
        }
      };
      if (Path.operationCanTransformPath(op)) {
        dirtyPaths = [];
        dirtyPathKeys = /* @__PURE__ */ new Set();
        for (var path of oldDirtyPaths) {
          var newPath = Path.transform(path, op);
          add4(newPath);
        }
      } else {
        dirtyPaths = oldDirtyPaths;
        dirtyPathKeys = oldDirtyPathKeys;
      }
      var newDirtyPaths = getDirtyPaths(op);
      for (var _path of newDirtyPaths) {
        add4(_path);
      }
      DIRTY_PATHS.set(editor, dirtyPaths);
      DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);
      Transforms.transform(editor, op);
      editor.operations.push(op);
      Editor.normalize(editor);
      if (op.type === "set_selection") {
        editor.marks = null;
      }
      if (!FLUSHING.get(editor)) {
        FLUSHING.set(editor, true);
        Promise.resolve().then(() => {
          FLUSHING.set(editor, false);
          editor.onChange();
          editor.operations = [];
        });
      }
    },
    addMark: (key, value) => {
      var {
        selection
      } = editor;
      if (selection) {
        if (Range.isExpanded(selection)) {
          Transforms.setNodes(editor, {
            [key]: value
          }, {
            match: Text.isText,
            split: true
          });
        } else {
          var marks = _objectSpread$9(_objectSpread$9({}, Editor.marks(editor) || {}), {}, {
            [key]: value
          });
          editor.marks = marks;
          if (!FLUSHING.get(editor)) {
            editor.onChange();
          }
        }
      }
    },
    deleteBackward: (unit) => {
      var {
        selection
      } = editor;
      if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
          unit,
          reverse: true
        });
      }
    },
    deleteForward: (unit) => {
      var {
        selection
      } = editor;
      if (selection && Range.isCollapsed(selection)) {
        Transforms.delete(editor, {
          unit
        });
      }
    },
    deleteFragment: (direction) => {
      var {
        selection
      } = editor;
      if (selection && Range.isExpanded(selection)) {
        Transforms.delete(editor, {
          reverse: direction === "backward"
        });
      }
    },
    getFragment: () => {
      var {
        selection
      } = editor;
      if (selection) {
        return Node2.fragment(editor, selection);
      }
      return [];
    },
    insertBreak: () => {
      Transforms.splitNodes(editor, {
        always: true
      });
    },
    insertSoftBreak: () => {
      Transforms.splitNodes(editor, {
        always: true
      });
    },
    insertFragment: (fragment) => {
      Transforms.insertFragment(editor, fragment);
    },
    insertNode: (node) => {
      Transforms.insertNodes(editor, node);
    },
    insertText: (text) => {
      var {
        selection,
        marks
      } = editor;
      if (selection) {
        if (marks) {
          var node = _objectSpread$9({
            text
          }, marks);
          Transforms.insertNodes(editor, node);
        } else {
          Transforms.insertText(editor, text);
        }
        editor.marks = null;
      }
    },
    normalizeNode: (entry) => {
      var [node, path] = entry;
      if (Text.isText(node)) {
        return;
      }
      if (Element2.isElement(node) && node.children.length === 0) {
        var child = {
          text: ""
        };
        Transforms.insertNodes(editor, child, {
          at: path.concat(0),
          voids: true
        });
        return;
      }
      var shouldHaveInlines = Editor.isEditor(node) ? false : Element2.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0]));
      var n12 = 0;
      for (var i15 = 0; i15 < node.children.length; i15++, n12++) {
        var currentNode = Node2.get(editor, path);
        if (Text.isText(currentNode))
          continue;
        var _child = node.children[i15];
        var prev = currentNode.children[n12 - 1];
        var isLast = i15 === node.children.length - 1;
        var isInlineOrText = Text.isText(_child) || Element2.isElement(_child) && editor.isInline(_child);
        if (isInlineOrText !== shouldHaveInlines) {
          Transforms.removeNodes(editor, {
            at: path.concat(n12),
            voids: true
          });
          n12--;
        } else if (Element2.isElement(_child)) {
          if (editor.isInline(_child)) {
            if (prev == null || !Text.isText(prev)) {
              var newChild = {
                text: ""
              };
              Transforms.insertNodes(editor, newChild, {
                at: path.concat(n12),
                voids: true
              });
              n12++;
            } else if (isLast) {
              var _newChild = {
                text: ""
              };
              Transforms.insertNodes(editor, _newChild, {
                at: path.concat(n12 + 1),
                voids: true
              });
              n12++;
            }
          }
        } else {
          if (prev != null && Text.isText(prev)) {
            if (Text.equals(_child, prev, {
              loose: true
            })) {
              Transforms.mergeNodes(editor, {
                at: path.concat(n12),
                voids: true
              });
              n12--;
            } else if (prev.text === "") {
              Transforms.removeNodes(editor, {
                at: path.concat(n12 - 1),
                voids: true
              });
              n12--;
            } else if (_child.text === "") {
              Transforms.removeNodes(editor, {
                at: path.concat(n12),
                voids: true
              });
              n12--;
            }
          }
        }
      }
    },
    removeMark: (key) => {
      var {
        selection
      } = editor;
      if (selection) {
        if (Range.isExpanded(selection)) {
          Transforms.unsetNodes(editor, key, {
            match: Text.isText,
            split: true
          });
        } else {
          var marks = _objectSpread$9({}, Editor.marks(editor) || {});
          delete marks[key];
          editor.marks = marks;
          if (!FLUSHING.get(editor)) {
            editor.onChange();
          }
        }
      }
    }
  };
  return editor;
};
var getDirtyPaths = (op) => {
  switch (op.type) {
    case "insert_text":
    case "remove_text":
    case "set_node": {
      var {
        path
      } = op;
      return Path.levels(path);
    }
    case "insert_node": {
      var {
        node,
        path: _path2
      } = op;
      var levels = Path.levels(_path2);
      var descendants = Text.isText(node) ? [] : Array.from(Node2.nodes(node), (_ref3) => {
        var [, p13] = _ref3;
        return _path2.concat(p13);
      });
      return [...levels, ...descendants];
    }
    case "merge_node": {
      var {
        path: _path3
      } = op;
      var ancestors = Path.ancestors(_path3);
      var previousPath = Path.previous(_path3);
      return [...ancestors, previousPath];
    }
    case "move_node": {
      var {
        path: _path4,
        newPath
      } = op;
      if (Path.equals(_path4, newPath)) {
        return [];
      }
      var oldAncestors = [];
      var newAncestors = [];
      for (var ancestor of Path.ancestors(_path4)) {
        var p12 = Path.transform(ancestor, op);
        oldAncestors.push(p12);
      }
      for (var _ancestor of Path.ancestors(newPath)) {
        var _p = Path.transform(_ancestor, op);
        newAncestors.push(_p);
      }
      var newParent = newAncestors[newAncestors.length - 1];
      var newIndex = newPath[newPath.length - 1];
      var resultPath = newParent.concat(newIndex);
      return [...oldAncestors, ...newAncestors, resultPath];
    }
    case "remove_node": {
      var {
        path: _path5
      } = op;
      var _ancestors = Path.ancestors(_path5);
      return [..._ancestors];
    }
    case "split_node": {
      var {
        path: _path6
      } = op;
      var _levels = Path.levels(_path6);
      var nextPath = Path.next(_path6);
      return [..._levels, nextPath];
    }
    default: {
      return [];
    }
  }
};
function _objectWithoutPropertiesLoose2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i15;
  for (i15 = 0; i15 < sourceKeys.length; i15++) {
    key = sourceKeys[i15];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose2(source, excluded);
  var key, i15;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i15 = 0; i15 < sourceSymbolKeys.length; i15++) {
      key = sourceSymbolKeys[i15];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var getCharacterDistance = function getCharacterDistance2(str) {
  var isRTL = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var isLTR = !isRTL;
  var codepoints = isRTL ? codepointsIteratorRTL(str) : str;
  var left = CodepointType.None;
  var right = CodepointType.None;
  var distance3 = 0;
  var gb11 = null;
  var gb12Or13 = null;
  for (var char of codepoints) {
    var code = char.codePointAt(0);
    if (!code)
      break;
    var type = getCodepointType(char, code);
    [left, right] = isLTR ? [right, type] : [type, left];
    if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {
      if (isLTR) {
        gb11 = endsWithEmojiZWJ(str.substring(0, distance3));
      } else {
        gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance3));
      }
      if (!gb11)
        break;
    }
    if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {
      if (gb12Or13 !== null) {
        gb12Or13 = !gb12Or13;
      } else {
        if (isLTR) {
          gb12Or13 = true;
        } else {
          gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance3));
        }
      }
      if (!gb12Or13)
        break;
    }
    if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {
      break;
    }
    distance3 += char.length;
  }
  return distance3 || 1;
};
var SPACE = /\s/;
var PUNCTUATION = /[\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
var CHAMELEON = /['\u2018\u2019]/;
var getWordDistance = function getWordDistance2(text) {
  var isRTL = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
  var dist = 0;
  var started = false;
  while (text.length > 0) {
    var charDist = getCharacterDistance(text, isRTL);
    var [char, remaining] = splitByCharacterDistance(text, charDist, isRTL);
    if (isWordCharacter(char, remaining, isRTL)) {
      started = true;
      dist += charDist;
    } else if (!started) {
      dist += charDist;
    } else {
      break;
    }
    text = remaining;
  }
  return dist;
};
var splitByCharacterDistance = (str, dist, isRTL) => {
  if (isRTL) {
    var at = str.length - dist;
    return [str.slice(at, str.length), str.slice(0, at)];
  }
  return [str.slice(0, dist), str.slice(dist)];
};
var isWordCharacter = function isWordCharacter2(char, remaining) {
  var isRTL = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
  if (SPACE.test(char)) {
    return false;
  }
  if (CHAMELEON.test(char)) {
    var charDist = getCharacterDistance(remaining, isRTL);
    var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);
    if (isWordCharacter2(nextChar, nextRemaining, isRTL)) {
      return true;
    }
  }
  if (PUNCTUATION.test(char)) {
    return false;
  }
  return true;
};
var codepointsIteratorRTL = function* codepointsIteratorRTL2(str) {
  var end2 = str.length - 1;
  for (var i15 = 0; i15 < str.length; i15++) {
    var char1 = str.charAt(end2 - i15);
    if (isLowSurrogate(char1.charCodeAt(0))) {
      var char2 = str.charAt(end2 - i15 - 1);
      if (isHighSurrogate(char2.charCodeAt(0))) {
        yield char2 + char1;
        i15++;
        continue;
      }
    }
    yield char1;
  }
};
var isHighSurrogate = (charCode) => {
  return charCode >= 55296 && charCode <= 56319;
};
var isLowSurrogate = (charCode) => {
  return charCode >= 56320 && charCode <= 57343;
};
var CodepointType;
(function(CodepointType2) {
  CodepointType2[CodepointType2["None"] = 0] = "None";
  CodepointType2[CodepointType2["Extend"] = 1] = "Extend";
  CodepointType2[CodepointType2["ZWJ"] = 2] = "ZWJ";
  CodepointType2[CodepointType2["RI"] = 4] = "RI";
  CodepointType2[CodepointType2["Prepend"] = 8] = "Prepend";
  CodepointType2[CodepointType2["SpacingMark"] = 16] = "SpacingMark";
  CodepointType2[CodepointType2["L"] = 32] = "L";
  CodepointType2[CodepointType2["V"] = 64] = "V";
  CodepointType2[CodepointType2["T"] = 128] = "T";
  CodepointType2[CodepointType2["LV"] = 256] = "LV";
  CodepointType2[CodepointType2["LVT"] = 512] = "LVT";
  CodepointType2[CodepointType2["ExtPict"] = 1024] = "ExtPict";
  CodepointType2[CodepointType2["Any"] = 2048] = "Any";
})(CodepointType || (CodepointType = {}));
var reExtend = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/;
var rePrepend = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/;
var reSpacingMark = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/;
var reL = /^[\u1100-\u115F\uA960-\uA97C]$/;
var reV = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/;
var reT = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/;
var reLV = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/;
var reLVT = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/;
var reExtPict = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/;
var getCodepointType = (char, code) => {
  var type = CodepointType.Any;
  if (char.search(reExtend) !== -1) {
    type |= CodepointType.Extend;
  }
  if (code === 8205) {
    type |= CodepointType.ZWJ;
  }
  if (code >= 127462 && code <= 127487) {
    type |= CodepointType.RI;
  }
  if (char.search(rePrepend) !== -1) {
    type |= CodepointType.Prepend;
  }
  if (char.search(reSpacingMark) !== -1) {
    type |= CodepointType.SpacingMark;
  }
  if (char.search(reL) !== -1) {
    type |= CodepointType.L;
  }
  if (char.search(reV) !== -1) {
    type |= CodepointType.V;
  }
  if (char.search(reT) !== -1) {
    type |= CodepointType.T;
  }
  if (char.search(reLV) !== -1) {
    type |= CodepointType.LV;
  }
  if (char.search(reLVT) !== -1) {
    type |= CodepointType.LVT;
  }
  if (char.search(reExtPict) !== -1) {
    type |= CodepointType.ExtPict;
  }
  return type;
};
function intersects(x7, y9) {
  return (x7 & y9) !== 0;
}
var NonBoundaryPairs = [
  // GB6
  [CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT],
  // GB7
  [CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T],
  // GB8
  [CodepointType.LVT | CodepointType.T, CodepointType.T],
  // GB9
  [CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ],
  // GB9a
  [CodepointType.Any, CodepointType.SpacingMark],
  // GB9b
  [CodepointType.Prepend, CodepointType.Any],
  // GB11
  [CodepointType.ZWJ, CodepointType.ExtPict],
  // GB12 and GB13
  [CodepointType.RI, CodepointType.RI]
];
function isBoundaryPair(left, right) {
  return NonBoundaryPairs.findIndex((r15) => intersects(left, r15[0]) && intersects(right, r15[1])) === -1;
}
var endingEmojiZWJ = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1AC0\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDF46-\uDF50]|\uD804[\uDC01\uDC38-\uDC46\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDD30-\uDD36\uDEEC-\uDEEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/;
var endsWithEmojiZWJ = (str) => {
  return str.search(endingEmojiZWJ) !== -1;
};
var endingRIs = /(?:\uD83C[\uDDE6-\uDDFF])+$/g;
var endsWithOddNumberOfRIs = (str) => {
  var match5 = str.match(endingRIs);
  if (match5 === null) {
    return false;
  } else {
    var numRIs = match5[0].length / 2;
    return numRIs % 2 === 1;
  }
};
var isElement = (value) => {
  return isPlainObject(value) && Node2.isNodeList(value.children) && !Editor.isEditor(value);
};
var Element2 = {
  /**
   * Check if a value implements the 'Ancestor' interface.
   */
  isAncestor(value) {
    return isPlainObject(value) && Node2.isNodeList(value.children);
  },
  /**
   * Check if a value implements the `Element` interface.
   */
  isElement,
  /**
   * Check if a value is an array of `Element` objects.
   */
  isElementList(value) {
    return Array.isArray(value) && value.every((val) => Element2.isElement(val));
  },
  /**
   * Check if a set of props is a partial of Element.
   */
  isElementProps(props) {
    return props.children !== void 0;
  },
  /**
   * Check if a value implements the `Element` interface and has elementKey with selected value.
   * Default it check to `type` key value
   */
  isElementType: function isElementType(value, elementVal) {
    var elementKey = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return isElement(value) && value[elementKey] === elementVal;
  },
  /**
   * Check if an element matches set of properties.
   *
   * Note: this checks custom properties, and it does not ensure that any
   * children are equivalent.
   */
  matches(element, props) {
    for (var key in props) {
      if (key === "children") {
        continue;
      }
      if (element[key] !== props[key]) {
        return false;
      }
    }
    return true;
  }
};
var _excluded$4 = ["text"];
var _excluded2$3 = ["text"];
function ownKeys$8(object2, enumerableOnly) {
  var keys6 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys6.push.apply(keys6, symbols);
  }
  return keys6;
}
function _objectSpread$8(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15] != null ? arguments[i15] : {};
    if (i15 % 2) {
      ownKeys$8(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$8(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var IS_EDITOR_CACHE = /* @__PURE__ */ new WeakMap();
var Editor = {
  /**
   * Get the ancestor above a location in the document.
   */
  above(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      voids = false,
      mode = "lowest",
      at = editor.selection,
      match: match5
    } = options;
    if (!at) {
      return;
    }
    var path = Editor.path(editor, at);
    var reverse = mode === "lowest";
    for (var [n12, p12] of Editor.levels(editor, {
      at: path,
      voids,
      match: match5,
      reverse
    })) {
      if (!Text.isText(n12) && !Path.equals(path, p12)) {
        return [n12, p12];
      }
    }
  },
  /**
   * Add a custom property to the leaf text nodes in the current selection.
   *
   * If the selection is currently collapsed, the marks will be added to the
   * `editor.marks` property instead, and applied when text is inserted next.
   */
  addMark(editor, key, value) {
    editor.addMark(key, value);
  },
  /**
   * Get the point after a location.
   */
  after(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var anchor = Editor.point(editor, at, {
      edge: "end"
    });
    var focus2 = Editor.end(editor, []);
    var range = {
      anchor,
      focus: focus2
    };
    var {
      distance: distance3 = 1
    } = options;
    var d17 = 0;
    var target;
    for (var p12 of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
      at: range
    }))) {
      if (d17 > distance3) {
        break;
      }
      if (d17 !== 0) {
        target = p12;
      }
      d17++;
    }
    return target;
  },
  /**
   * Get the point before a location.
   */
  before(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var anchor = Editor.start(editor, []);
    var focus2 = Editor.point(editor, at, {
      edge: "start"
    });
    var range = {
      anchor,
      focus: focus2
    };
    var {
      distance: distance3 = 1
    } = options;
    var d17 = 0;
    var target;
    for (var p12 of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
      at: range,
      reverse: true
    }))) {
      if (d17 > distance3) {
        break;
      }
      if (d17 !== 0) {
        target = p12;
      }
      d17++;
    }
    return target;
  },
  /**
   * Delete content in the editor backward from the current selection.
   */
  deleteBackward(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      unit = "character"
    } = options;
    editor.deleteBackward(unit);
  },
  /**
   * Delete content in the editor forward from the current selection.
   */
  deleteForward(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      unit = "character"
    } = options;
    editor.deleteForward(unit);
  },
  /**
   * Delete the content in the current selection.
   */
  deleteFragment(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      direction = "forward"
    } = options;
    editor.deleteFragment(direction);
  },
  /**
   * Get the start and end points of a location.
   */
  edges(editor, at) {
    return [Editor.start(editor, at), Editor.end(editor, at)];
  },
  /**
   * Get the end point of a location.
   */
  end(editor, at) {
    return Editor.point(editor, at, {
      edge: "end"
    });
  },
  /**
   * Get the first node at a location.
   */
  first(editor, at) {
    var path = Editor.path(editor, at, {
      edge: "start"
    });
    return Editor.node(editor, path);
  },
  /**
   * Get the fragment at a location.
   */
  fragment(editor, at) {
    var range = Editor.range(editor, at);
    var fragment = Node2.fragment(editor, range);
    return fragment;
  },
  /**
   * Check if a node has block children.
   */
  hasBlocks(editor, element) {
    return element.children.some((n12) => Editor.isBlock(editor, n12));
  },
  /**
   * Check if a node has inline and text children.
   */
  hasInlines(editor, element) {
    return element.children.some((n12) => Text.isText(n12) || Editor.isInline(editor, n12));
  },
  /**
   * Check if a node has text children.
   */
  hasTexts(editor, element) {
    return element.children.every((n12) => Text.isText(n12));
  },
  /**
   * Insert a block break at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertBreak(editor) {
    editor.insertBreak();
  },
  /**
   * Insert a soft break at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertSoftBreak(editor) {
    editor.insertSoftBreak();
  },
  /**
   * Insert a fragment at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertFragment(editor, fragment) {
    editor.insertFragment(fragment);
  },
  /**
   * Insert a node at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertNode(editor, node) {
    editor.insertNode(node);
  },
  /**
   * Insert text at the current selection.
   *
   * If the selection is currently expanded, it will be deleted first.
   */
  insertText(editor, text) {
    editor.insertText(text);
  },
  /**
   * Check if a value is a block `Element` object.
   */
  isBlock(editor, value) {
    return Element2.isElement(value) && !editor.isInline(value);
  },
  /**
   * Check if a value is an `Editor` object.
   */
  isEditor(value) {
    if (!isPlainObject(value))
      return false;
    var cachedIsEditor = IS_EDITOR_CACHE.get(value);
    if (cachedIsEditor !== void 0) {
      return cachedIsEditor;
    }
    var isEditor = typeof value.addMark === "function" && typeof value.apply === "function" && typeof value.deleteBackward === "function" && typeof value.deleteForward === "function" && typeof value.deleteFragment === "function" && typeof value.insertBreak === "function" && typeof value.insertSoftBreak === "function" && typeof value.insertFragment === "function" && typeof value.insertNode === "function" && typeof value.insertText === "function" && typeof value.isInline === "function" && typeof value.isVoid === "function" && typeof value.normalizeNode === "function" && typeof value.onChange === "function" && typeof value.removeMark === "function" && (value.marks === null || isPlainObject(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node2.isNodeList(value.children) && Operation.isOperationList(value.operations);
    IS_EDITOR_CACHE.set(value, isEditor);
    return isEditor;
  },
  /**
   * Check if a point is the end point of a location.
   */
  isEnd(editor, point, at) {
    var end2 = Editor.end(editor, at);
    return Point.equals(point, end2);
  },
  /**
   * Check if a point is an edge of a location.
   */
  isEdge(editor, point, at) {
    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);
  },
  /**
   * Check if an element is empty, accounting for void nodes.
   */
  isEmpty(editor, element) {
    var {
      children
    } = element;
    var [first] = children;
    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === "" && !editor.isVoid(element);
  },
  /**
   * Check if a value is an inline `Element` object.
   */
  isInline(editor, value) {
    return Element2.isElement(value) && editor.isInline(value);
  },
  /**
   * Check if the editor is currently normalizing after each operation.
   */
  isNormalizing(editor) {
    var isNormalizing = NORMALIZING.get(editor);
    return isNormalizing === void 0 ? true : isNormalizing;
  },
  /**
   * Check if a point is the start point of a location.
   */
  isStart(editor, point, at) {
    if (point.offset !== 0) {
      return false;
    }
    var start3 = Editor.start(editor, at);
    return Point.equals(point, start3);
  },
  /**
   * Check if a value is a void `Element` object.
   */
  isVoid(editor, value) {
    return Element2.isElement(value) && editor.isVoid(value);
  },
  /**
   * Get the last node at a location.
   */
  last(editor, at) {
    var path = Editor.path(editor, at, {
      edge: "end"
    });
    return Editor.node(editor, path);
  },
  /**
   * Get the leaf text node at a location.
   */
  leaf(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var path = Editor.path(editor, at, options);
    var node = Node2.leaf(editor, path);
    return [node, path];
  },
  /**
   * Iterate through all of the levels at a location.
   */
  *levels(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      at = editor.selection,
      reverse = false,
      voids = false
    } = options;
    var {
      match: match5
    } = options;
    if (match5 == null) {
      match5 = () => true;
    }
    if (!at) {
      return;
    }
    var levels = [];
    var path = Editor.path(editor, at);
    for (var [n12, p12] of Node2.levels(editor, path)) {
      if (!match5(n12, p12)) {
        continue;
      }
      levels.push([n12, p12]);
      if (!voids && Editor.isVoid(editor, n12)) {
        break;
      }
    }
    if (reverse) {
      levels.reverse();
    }
    yield* levels;
  },
  /**
   * Get the marks that would be added to text at the current selection.
   */
  marks(editor) {
    var {
      marks,
      selection
    } = editor;
    if (!selection) {
      return null;
    }
    if (marks) {
      return marks;
    }
    if (Range.isExpanded(selection)) {
      var [match5] = Editor.nodes(editor, {
        match: Text.isText
      });
      if (match5) {
        var [_node] = match5;
        var _rest = _objectWithoutProperties(_node, _excluded$4);
        return _rest;
      } else {
        return {};
      }
    }
    var {
      anchor
    } = selection;
    var {
      path
    } = anchor;
    var [node] = Editor.leaf(editor, path);
    if (anchor.offset === 0) {
      var prev = Editor.previous(editor, {
        at: path,
        match: Text.isText
      });
      var block = Editor.above(editor, {
        match: (n12) => Editor.isBlock(editor, n12)
      });
      if (prev && block) {
        var [prevNode, prevPath] = prev;
        var [, blockPath] = block;
        if (Path.isAncestor(blockPath, prevPath)) {
          node = prevNode;
        }
      }
    }
    var rest = _objectWithoutProperties(node, _excluded2$3);
    return rest;
  },
  /**
   * Get the matching node in the branch of the document after a location.
   */
  next(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      mode = "lowest",
      voids = false
    } = options;
    var {
      match: match5,
      at = editor.selection
    } = options;
    if (!at) {
      return;
    }
    var pointAfterLocation = Editor.after(editor, at, {
      voids
    });
    if (!pointAfterLocation)
      return;
    var [, to4] = Editor.last(editor, []);
    var span = [pointAfterLocation.path, to4];
    if (Path.isPath(at) && at.length === 0) {
      throw new Error("Cannot get the next node from the root node!");
    }
    if (match5 == null) {
      if (Path.isPath(at)) {
        var [parent2] = Editor.parent(editor, at);
        match5 = (n12) => parent2.children.includes(n12);
      } else {
        match5 = () => true;
      }
    }
    var [next] = Editor.nodes(editor, {
      at: span,
      match: match5,
      mode,
      voids
    });
    return next;
  },
  /**
   * Get the node at a location.
   */
  node(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var path = Editor.path(editor, at, options);
    var node = Node2.get(editor, path);
    return [node, path];
  },
  /**
   * Iterate through all of the nodes in the Editor.
   */
  *nodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      at = editor.selection,
      mode = "all",
      universal = false,
      reverse = false,
      voids = false
    } = options;
    var {
      match: match5
    } = options;
    if (!match5) {
      match5 = () => true;
    }
    if (!at) {
      return;
    }
    var from2;
    var to4;
    if (Span.isSpan(at)) {
      from2 = at[0];
      to4 = at[1];
    } else {
      var first = Editor.path(editor, at, {
        edge: "start"
      });
      var last2 = Editor.path(editor, at, {
        edge: "end"
      });
      from2 = reverse ? last2 : first;
      to4 = reverse ? first : last2;
    }
    var nodeEntries = Node2.nodes(editor, {
      reverse,
      from: from2,
      to: to4,
      pass: (_ref) => {
        var [n12] = _ref;
        return voids ? false : Editor.isVoid(editor, n12);
      }
    });
    var matches = [];
    var hit;
    for (var [node, path] of nodeEntries) {
      var isLower = hit && Path.compare(path, hit[1]) === 0;
      if (mode === "highest" && isLower) {
        continue;
      }
      if (!match5(node, path)) {
        if (universal && !isLower && Text.isText(node)) {
          return;
        } else {
          continue;
        }
      }
      if (mode === "lowest" && isLower) {
        hit = [node, path];
        continue;
      }
      var emit = mode === "lowest" ? hit : [node, path];
      if (emit) {
        if (universal) {
          matches.push(emit);
        } else {
          yield emit;
        }
      }
      hit = [node, path];
    }
    if (mode === "lowest" && hit) {
      if (universal) {
        matches.push(hit);
      } else {
        yield hit;
      }
    }
    if (universal) {
      yield* matches;
    }
  },
  /**
   * Normalize any dirty objects in the editor.
   */
  normalize(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      force = false
    } = options;
    var getDirtyPaths2 = (editor2) => {
      return DIRTY_PATHS.get(editor2) || [];
    };
    var getDirtyPathKeys = (editor2) => {
      return DIRTY_PATH_KEYS.get(editor2) || /* @__PURE__ */ new Set();
    };
    var popDirtyPath = (editor2) => {
      var path = getDirtyPaths2(editor2).pop();
      var key = path.join(",");
      getDirtyPathKeys(editor2).delete(key);
      return path;
    };
    if (!Editor.isNormalizing(editor)) {
      return;
    }
    if (force) {
      var allPaths = Array.from(Node2.nodes(editor), (_ref2) => {
        var [, p12] = _ref2;
        return p12;
      });
      var allPathKeys = new Set(allPaths.map((p12) => p12.join(",")));
      DIRTY_PATHS.set(editor, allPaths);
      DIRTY_PATH_KEYS.set(editor, allPathKeys);
    }
    if (getDirtyPaths2(editor).length === 0) {
      return;
    }
    Editor.withoutNormalizing(editor, () => {
      for (var dirtyPath of getDirtyPaths2(editor)) {
        if (Node2.has(editor, dirtyPath)) {
          var entry = Editor.node(editor, dirtyPath);
          var [node, _7] = entry;
          if (Element2.isElement(node) && node.children.length === 0) {
            editor.normalizeNode(entry);
          }
        }
      }
      var max4 = getDirtyPaths2(editor).length * 42;
      var m10 = 0;
      while (getDirtyPaths2(editor).length !== 0) {
        if (m10 > max4) {
          throw new Error("\n            Could not completely normalize the editor after ".concat(max4, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\n          "));
        }
        var _dirtyPath = popDirtyPath(editor);
        if (Node2.has(editor, _dirtyPath)) {
          var _entry = Editor.node(editor, _dirtyPath);
          editor.normalizeNode(_entry);
        }
        m10++;
      }
    });
  },
  /**
   * Get the parent node of a location.
   */
  parent(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var path = Editor.path(editor, at, options);
    var parentPath = Path.parent(path);
    var entry = Editor.node(editor, parentPath);
    return entry;
  },
  /**
   * Get the path of a location.
   */
  path(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      depth,
      edge
    } = options;
    if (Path.isPath(at)) {
      if (edge === "start") {
        var [, firstPath] = Node2.first(editor, at);
        at = firstPath;
      } else if (edge === "end") {
        var [, lastPath] = Node2.last(editor, at);
        at = lastPath;
      }
    }
    if (Range.isRange(at)) {
      if (edge === "start") {
        at = Range.start(at);
      } else if (edge === "end") {
        at = Range.end(at);
      } else {
        at = Path.common(at.anchor.path, at.focus.path);
      }
    }
    if (Point.isPoint(at)) {
      at = at.path;
    }
    if (depth != null) {
      at = at.slice(0, depth);
    }
    return at;
  },
  hasPath(editor, path) {
    return Node2.has(editor, path);
  },
  /**
   * Create a mutable ref for a `Path` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  pathRef(editor, path) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      affinity = "forward"
    } = options;
    var ref2 = {
      current: path,
      affinity,
      unref() {
        var {
          current
        } = ref2;
        var pathRefs = Editor.pathRefs(editor);
        pathRefs.delete(ref2);
        ref2.current = null;
        return current;
      }
    };
    var refs = Editor.pathRefs(editor);
    refs.add(ref2);
    return ref2;
  },
  /**
   * Get the set of currently tracked path refs of the editor.
   */
  pathRefs(editor) {
    var refs = PATH_REFS.get(editor);
    if (!refs) {
      refs = /* @__PURE__ */ new Set();
      PATH_REFS.set(editor, refs);
    }
    return refs;
  },
  /**
   * Get the start or end point of a location.
   */
  point(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      edge = "start"
    } = options;
    if (Path.isPath(at)) {
      var path;
      if (edge === "end") {
        var [, lastPath] = Node2.last(editor, at);
        path = lastPath;
      } else {
        var [, firstPath] = Node2.first(editor, at);
        path = firstPath;
      }
      var node = Node2.get(editor, path);
      if (!Text.isText(node)) {
        throw new Error("Cannot get the ".concat(edge, " point in the node at path [").concat(at, "] because it has no ").concat(edge, " text node."));
      }
      return {
        path,
        offset: edge === "end" ? node.text.length : 0
      };
    }
    if (Range.isRange(at)) {
      var [start3, end2] = Range.edges(at);
      return edge === "start" ? start3 : end2;
    }
    return at;
  },
  /**
   * Create a mutable ref for a `Point` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  pointRef(editor, point) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      affinity = "forward"
    } = options;
    var ref2 = {
      current: point,
      affinity,
      unref() {
        var {
          current
        } = ref2;
        var pointRefs = Editor.pointRefs(editor);
        pointRefs.delete(ref2);
        ref2.current = null;
        return current;
      }
    };
    var refs = Editor.pointRefs(editor);
    refs.add(ref2);
    return ref2;
  },
  /**
   * Get the set of currently tracked point refs of the editor.
   */
  pointRefs(editor) {
    var refs = POINT_REFS.get(editor);
    if (!refs) {
      refs = /* @__PURE__ */ new Set();
      POINT_REFS.set(editor, refs);
    }
    return refs;
  },
  /**
   * Return all the positions in `at` range where a `Point` can be placed.
   *
   * By default, moves forward by individual offsets at a time, but
   * the `unit` option can be used to to move by character, word, line, or block.
   *
   * The `reverse` option can be used to change iteration direction.
   *
   * Note: By default void nodes are treated as a single point and iteration
   * will not happen inside their content unless you pass in true for the
   * `voids` option, then iteration will occur.
   */
  *positions(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      at = editor.selection,
      unit = "offset",
      reverse = false,
      voids = false
    } = options;
    if (!at) {
      return;
    }
    var range = Editor.range(editor, at);
    var [start3, end2] = Range.edges(range);
    var first = reverse ? end2 : start3;
    var isNewBlock = false;
    var blockText = "";
    var distance3 = 0;
    var leafTextRemaining = 0;
    var leafTextOffset = 0;
    for (var [node, path] of Editor.nodes(editor, {
      at,
      reverse,
      voids
    })) {
      if (Element2.isElement(node)) {
        if (!voids && editor.isVoid(node)) {
          yield Editor.start(editor, path);
          continue;
        }
        if (editor.isInline(node))
          continue;
        if (Editor.hasInlines(editor, node)) {
          var e9 = Path.isAncestor(path, end2.path) ? end2 : Editor.end(editor, path);
          var s20 = Path.isAncestor(path, start3.path) ? start3 : Editor.start(editor, path);
          blockText = Editor.string(editor, {
            anchor: s20,
            focus: e9
          }, {
            voids
          });
          isNewBlock = true;
        }
      }
      if (Text.isText(node)) {
        var isFirst = Path.equals(path, first.path);
        if (isFirst) {
          leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;
          leafTextOffset = first.offset;
        } else {
          leafTextRemaining = node.text.length;
          leafTextOffset = reverse ? leafTextRemaining : 0;
        }
        if (isFirst || isNewBlock || unit === "offset") {
          yield {
            path,
            offset: leafTextOffset
          };
          isNewBlock = false;
        }
        while (true) {
          if (distance3 === 0) {
            if (blockText === "")
              break;
            distance3 = calcDistance(blockText, unit, reverse);
            blockText = splitByCharacterDistance(blockText, distance3, reverse)[1];
          }
          leafTextOffset = reverse ? leafTextOffset - distance3 : leafTextOffset + distance3;
          leafTextRemaining = leafTextRemaining - distance3;
          if (leafTextRemaining < 0) {
            distance3 = -leafTextRemaining;
            break;
          }
          distance3 = 0;
          yield {
            path,
            offset: leafTextOffset
          };
        }
      }
    }
    function calcDistance(text, unit2, reverse2) {
      if (unit2 === "character") {
        return getCharacterDistance(text, reverse2);
      } else if (unit2 === "word") {
        return getWordDistance(text, reverse2);
      } else if (unit2 === "line" || unit2 === "block") {
        return text.length;
      }
      return 1;
    }
  },
  /**
   * Get the matching node in the branch of the document before a location.
   */
  previous(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      mode = "lowest",
      voids = false
    } = options;
    var {
      match: match5,
      at = editor.selection
    } = options;
    if (!at) {
      return;
    }
    var pointBeforeLocation = Editor.before(editor, at, {
      voids
    });
    if (!pointBeforeLocation) {
      return;
    }
    var [, to4] = Editor.first(editor, []);
    var span = [pointBeforeLocation.path, to4];
    if (Path.isPath(at) && at.length === 0) {
      throw new Error("Cannot get the previous node from the root node!");
    }
    if (match5 == null) {
      if (Path.isPath(at)) {
        var [parent2] = Editor.parent(editor, at);
        match5 = (n12) => parent2.children.includes(n12);
      } else {
        match5 = () => true;
      }
    }
    var [previous] = Editor.nodes(editor, {
      reverse: true,
      at: span,
      match: match5,
      mode,
      voids
    });
    return previous;
  },
  /**
   * Get a range of a location.
   */
  range(editor, at, to4) {
    if (Range.isRange(at) && !to4) {
      return at;
    }
    var start3 = Editor.start(editor, at);
    var end2 = Editor.end(editor, to4 || at);
    return {
      anchor: start3,
      focus: end2
    };
  },
  /**
   * Create a mutable ref for a `Range` object, which will stay in sync as new
   * operations are applied to the editor.
   */
  rangeRef(editor, range) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      affinity = "forward"
    } = options;
    var ref2 = {
      current: range,
      affinity,
      unref() {
        var {
          current
        } = ref2;
        var rangeRefs = Editor.rangeRefs(editor);
        rangeRefs.delete(ref2);
        ref2.current = null;
        return current;
      }
    };
    var refs = Editor.rangeRefs(editor);
    refs.add(ref2);
    return ref2;
  },
  /**
   * Get the set of currently tracked range refs of the editor.
   */
  rangeRefs(editor) {
    var refs = RANGE_REFS.get(editor);
    if (!refs) {
      refs = /* @__PURE__ */ new Set();
      RANGE_REFS.set(editor, refs);
    }
    return refs;
  },
  /**
   * Remove a custom property from all of the leaf text nodes in the current
   * selection.
   *
   * If the selection is currently collapsed, the removal will be stored on
   * `editor.marks` and applied to the text inserted next.
   */
  removeMark(editor, key) {
    editor.removeMark(key);
  },
  /**
   * Manually set if the editor should currently be normalizing.
   *
   * Note: Using this incorrectly can leave the editor in an invalid state.
   *
   */
  setNormalizing(editor, isNormalizing) {
    NORMALIZING.set(editor, isNormalizing);
  },
  /**
   * Get the start point of a location.
   */
  start(editor, at) {
    return Editor.point(editor, at, {
      edge: "start"
    });
  },
  /**
   * Get the text string content of a location.
   *
   * Note: by default the text of void nodes is considered to be an empty
   * string, regardless of content, unless you pass in true for the voids option
   */
  string(editor, at) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      voids = false
    } = options;
    var range = Editor.range(editor, at);
    var [start3, end2] = Range.edges(range);
    var text = "";
    for (var [node, path] of Editor.nodes(editor, {
      at: range,
      match: Text.isText,
      voids
    })) {
      var t20 = node.text;
      if (Path.equals(path, end2.path)) {
        t20 = t20.slice(0, end2.offset);
      }
      if (Path.equals(path, start3.path)) {
        t20 = t20.slice(start3.offset);
      }
      text += t20;
    }
    return text;
  },
  /**
   * Convert a range into a non-hanging one.
   */
  unhangRange(editor, range) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      voids = false
    } = options;
    var [start3, end2] = Range.edges(range);
    if (start3.offset !== 0 || end2.offset !== 0 || Range.isCollapsed(range)) {
      return range;
    }
    var endBlock = Editor.above(editor, {
      at: end2,
      match: (n12) => Editor.isBlock(editor, n12)
    });
    var blockPath = endBlock ? endBlock[1] : [];
    var first = Editor.start(editor, start3);
    var before = {
      anchor: first,
      focus: end2
    };
    var skip = true;
    for (var [node, path] of Editor.nodes(editor, {
      at: before,
      match: Text.isText,
      reverse: true,
      voids
    })) {
      if (skip) {
        skip = false;
        continue;
      }
      if (node.text !== "" || Path.isBefore(path, blockPath)) {
        end2 = {
          path,
          offset: node.text.length
        };
        break;
      }
    }
    return {
      anchor: start3,
      focus: end2
    };
  },
  /**
   * Match a void node in the current branch of the editor.
   */
  void(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return Editor.above(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {
      match: (n12) => Editor.isVoid(editor, n12)
    }));
  },
  /**
   * Call a function, deferring normalization until after it completes.
   */
  withoutNormalizing(editor, fn2) {
    var value = Editor.isNormalizing(editor);
    Editor.setNormalizing(editor, false);
    try {
      fn2();
    } finally {
      Editor.setNormalizing(editor, value);
    }
    Editor.normalize(editor);
  }
};
var Span = {
  /**
   * Check if a value implements the `Span` interface.
   */
  isSpan(value) {
    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);
  }
};
var _excluded$3 = ["children"];
var _excluded2$2 = ["text"];
var IS_NODE_LIST_CACHE = /* @__PURE__ */ new WeakMap();
var Node2 = {
  /**
   * Get the node at a specific path, asserting that it's an ancestor node.
   */
  ancestor(root6, path) {
    var node = Node2.get(root6, path);
    if (Text.isText(node)) {
      throw new Error("Cannot get the ancestor node at path [".concat(path, "] because it refers to a text node instead: ").concat(Scrubber.stringify(node)));
    }
    return node;
  },
  /**
   * Return a generator of all the ancestor nodes above a specific path.
   *
   * By default the order is top-down, from highest to lowest ancestor in
   * the tree, but you can pass the `reverse: true` option to go bottom-up.
   */
  *ancestors(root6, path) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    for (var p12 of Path.ancestors(path, options)) {
      var n12 = Node2.ancestor(root6, p12);
      var entry = [n12, p12];
      yield entry;
    }
  },
  /**
   * Get the child of a node at a specific index.
   */
  child(root6, index2) {
    if (Text.isText(root6)) {
      throw new Error("Cannot get the child of a text node: ".concat(Scrubber.stringify(root6)));
    }
    var c16 = root6.children[index2];
    if (c16 == null) {
      throw new Error("Cannot get child at index `".concat(index2, "` in node: ").concat(Scrubber.stringify(root6)));
    }
    return c16;
  },
  /**
   * Iterate over the children of a node at a specific path.
   */
  *children(root6, path) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      reverse = false
    } = options;
    var ancestor = Node2.ancestor(root6, path);
    var {
      children
    } = ancestor;
    var index2 = reverse ? children.length - 1 : 0;
    while (reverse ? index2 >= 0 : index2 < children.length) {
      var child = Node2.child(ancestor, index2);
      var childPath = path.concat(index2);
      yield [child, childPath];
      index2 = reverse ? index2 - 1 : index2 + 1;
    }
  },
  /**
   * Get an entry for the common ancesetor node of two paths.
   */
  common(root6, path, another) {
    var p12 = Path.common(path, another);
    var n12 = Node2.get(root6, p12);
    return [n12, p12];
  },
  /**
   * Get the node at a specific path, asserting that it's a descendant node.
   */
  descendant(root6, path) {
    var node = Node2.get(root6, path);
    if (Editor.isEditor(node)) {
      throw new Error("Cannot get the descendant node at path [".concat(path, "] because it refers to the root editor node instead: ").concat(Scrubber.stringify(node)));
    }
    return node;
  },
  /**
   * Return a generator of all the descendant node entries inside a root node.
   */
  *descendants(root6) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [node, path] of Node2.nodes(root6, options)) {
      if (path.length !== 0) {
        yield [node, path];
      }
    }
  },
  /**
   * Return a generator of all the element nodes inside a root node. Each iteration
   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the
   * root node is an element it will be included in the iteration as well.
   */
  *elements(root6) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [node, path] of Node2.nodes(root6, options)) {
      if (Element2.isElement(node)) {
        yield [node, path];
      }
    }
  },
  /**
   * Extract props from a Node.
   */
  extractProps(node) {
    if (Element2.isAncestor(node)) {
      var properties = _objectWithoutProperties(node, _excluded$3);
      return properties;
    } else {
      var properties = _objectWithoutProperties(node, _excluded2$2);
      return properties;
    }
  },
  /**
   * Get the first node entry in a root node from a path.
   */
  first(root6, path) {
    var p12 = path.slice();
    var n12 = Node2.get(root6, p12);
    while (n12) {
      if (Text.isText(n12) || n12.children.length === 0) {
        break;
      } else {
        n12 = n12.children[0];
        p12.push(0);
      }
    }
    return [n12, p12];
  },
  /**
   * Get the sliced fragment represented by a range inside a root node.
   */
  fragment(root6, range) {
    if (Text.isText(root6)) {
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Scrubber.stringify(root6)));
    }
    var newRoot = fn({
      children: root6.children
    }, (r15) => {
      var [start3, end2] = Range.edges(range);
      var nodeEntries = Node2.nodes(r15, {
        reverse: true,
        pass: (_ref) => {
          var [, path2] = _ref;
          return !Range.includes(range, path2);
        }
      });
      for (var [, path] of nodeEntries) {
        if (!Range.includes(range, path)) {
          var parent2 = Node2.parent(r15, path);
          var index2 = path[path.length - 1];
          parent2.children.splice(index2, 1);
        }
        if (Path.equals(path, end2.path)) {
          var leaf = Node2.leaf(r15, path);
          leaf.text = leaf.text.slice(0, end2.offset);
        }
        if (Path.equals(path, start3.path)) {
          var _leaf = Node2.leaf(r15, path);
          _leaf.text = _leaf.text.slice(start3.offset);
        }
      }
      if (Editor.isEditor(r15)) {
        r15.selection = null;
      }
    });
    return newRoot.children;
  },
  /**
   * Get the descendant node referred to by a specific path. If the path is an
   * empty array, it refers to the root node itself.
   */
  get(root6, path) {
    var node = root6;
    for (var i15 = 0; i15 < path.length; i15++) {
      var p12 = path[i15];
      if (Text.isText(node) || !node.children[p12]) {
        throw new Error("Cannot find a descendant at path [".concat(path, "] in node: ").concat(Scrubber.stringify(root6)));
      }
      node = node.children[p12];
    }
    return node;
  },
  /**
   * Check if a descendant node exists at a specific path.
   */
  has(root6, path) {
    var node = root6;
    for (var i15 = 0; i15 < path.length; i15++) {
      var p12 = path[i15];
      if (Text.isText(node) || !node.children[p12]) {
        return false;
      }
      node = node.children[p12];
    }
    return true;
  },
  /**
   * Check if a value implements the `Node` interface.
   */
  isNode(value) {
    return Text.isText(value) || Element2.isElement(value) || Editor.isEditor(value);
  },
  /**
   * Check if a value is a list of `Node` objects.
   */
  isNodeList(value) {
    if (!Array.isArray(value)) {
      return false;
    }
    var cachedResult = IS_NODE_LIST_CACHE.get(value);
    if (cachedResult !== void 0) {
      return cachedResult;
    }
    var isNodeList = value.every((val) => Node2.isNode(val));
    IS_NODE_LIST_CACHE.set(value, isNodeList);
    return isNodeList;
  },
  /**
   * Get the last node entry in a root node from a path.
   */
  last(root6, path) {
    var p12 = path.slice();
    var n12 = Node2.get(root6, p12);
    while (n12) {
      if (Text.isText(n12) || n12.children.length === 0) {
        break;
      } else {
        var i15 = n12.children.length - 1;
        n12 = n12.children[i15];
        p12.push(i15);
      }
    }
    return [n12, p12];
  },
  /**
   * Get the node at a specific path, ensuring it's a leaf text node.
   */
  leaf(root6, path) {
    var node = Node2.get(root6, path);
    if (!Text.isText(node)) {
      throw new Error("Cannot get the leaf node at path [".concat(path, "] because it refers to a non-leaf node: ").concat(Scrubber.stringify(node)));
    }
    return node;
  },
  /**
   * Return a generator of the in a branch of the tree, from a specific path.
   *
   * By default the order is top-down, from highest to lowest node in the tree,
   * but you can pass the `reverse: true` option to go bottom-up.
   */
  *levels(root6, path) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    for (var p12 of Path.levels(path, options)) {
      var n12 = Node2.get(root6, p12);
      yield [n12, p12];
    }
  },
  /**
   * Check if a node matches a set of props.
   */
  matches(node, props) {
    return Element2.isElement(node) && Element2.isElementProps(props) && Element2.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);
  },
  /**
   * Return a generator of all the node entries of a root node. Each entry is
   * returned as a `[Node, Path]` tuple, with the path referring to the node's
   * position inside the root node.
   */
  *nodes(root6) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      pass,
      reverse = false
    } = options;
    var {
      from: from2 = [],
      to: to4
    } = options;
    var visited = /* @__PURE__ */ new Set();
    var p12 = [];
    var n12 = root6;
    while (true) {
      if (to4 && (reverse ? Path.isBefore(p12, to4) : Path.isAfter(p12, to4))) {
        break;
      }
      if (!visited.has(n12)) {
        yield [n12, p12];
      }
      if (!visited.has(n12) && !Text.isText(n12) && n12.children.length !== 0 && (pass == null || pass([n12, p12]) === false)) {
        visited.add(n12);
        var nextIndex = reverse ? n12.children.length - 1 : 0;
        if (Path.isAncestor(p12, from2)) {
          nextIndex = from2[p12.length];
        }
        p12 = p12.concat(nextIndex);
        n12 = Node2.get(root6, p12);
        continue;
      }
      if (p12.length === 0) {
        break;
      }
      if (!reverse) {
        var newPath = Path.next(p12);
        if (Node2.has(root6, newPath)) {
          p12 = newPath;
          n12 = Node2.get(root6, p12);
          continue;
        }
      }
      if (reverse && p12[p12.length - 1] !== 0) {
        var _newPath = Path.previous(p12);
        p12 = _newPath;
        n12 = Node2.get(root6, p12);
        continue;
      }
      p12 = Path.parent(p12);
      n12 = Node2.get(root6, p12);
      visited.add(n12);
    }
  },
  /**
   * Get the parent of a node at a specific path.
   */
  parent(root6, path) {
    var parentPath = Path.parent(path);
    var p12 = Node2.get(root6, parentPath);
    if (Text.isText(p12)) {
      throw new Error("Cannot get the parent of path [".concat(path, "] because it does not exist in the root."));
    }
    return p12;
  },
  /**
   * Get the concatenated text string of a node's content.
   *
   * Note that this will not include spaces or line breaks between block nodes.
   * It is not a user-facing string, but a string for performing offset-related
   * computations for a node.
   */
  string(node) {
    if (Text.isText(node)) {
      return node.text;
    } else {
      return node.children.map(Node2.string).join("");
    }
  },
  /**
   * Return a generator of all leaf text nodes in a root node.
   */
  *texts(root6) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    for (var [node, path] of Node2.nodes(root6, options)) {
      if (Text.isText(node)) {
        yield [node, path];
      }
    }
  }
};
function ownKeys$7(object2, enumerableOnly) {
  var keys6 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys6.push.apply(keys6, symbols);
  }
  return keys6;
}
function _objectSpread$7(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15] != null ? arguments[i15] : {};
    if (i15 % 2) {
      ownKeys$7(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$7(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Operation = {
  /**
   * Check of a value is a `NodeOperation` object.
   */
  isNodeOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith("_node");
  },
  /**
   * Check of a value is an `Operation` object.
   */
  isOperation(value) {
    if (!isPlainObject(value)) {
      return false;
    }
    switch (value.type) {
      case "insert_node":
        return Path.isPath(value.path) && Node2.isNode(value.node);
      case "insert_text":
        return typeof value.offset === "number" && typeof value.text === "string" && Path.isPath(value.path);
      case "merge_node":
        return typeof value.position === "number" && Path.isPath(value.path) && isPlainObject(value.properties);
      case "move_node":
        return Path.isPath(value.path) && Path.isPath(value.newPath);
      case "remove_node":
        return Path.isPath(value.path) && Node2.isNode(value.node);
      case "remove_text":
        return typeof value.offset === "number" && typeof value.text === "string" && Path.isPath(value.path);
      case "set_node":
        return Path.isPath(value.path) && isPlainObject(value.properties) && isPlainObject(value.newProperties);
      case "set_selection":
        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || isPlainObject(value.properties) && isPlainObject(value.newProperties);
      case "split_node":
        return Path.isPath(value.path) && typeof value.position === "number" && isPlainObject(value.properties);
      default:
        return false;
    }
  },
  /**
   * Check if a value is a list of `Operation` objects.
   */
  isOperationList(value) {
    return Array.isArray(value) && value.every((val) => Operation.isOperation(val));
  },
  /**
   * Check of a value is a `SelectionOperation` object.
   */
  isSelectionOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith("_selection");
  },
  /**
   * Check of a value is a `TextOperation` object.
   */
  isTextOperation(value) {
    return Operation.isOperation(value) && value.type.endsWith("_text");
  },
  /**
   * Invert an operation, returning a new operation that will exactly undo the
   * original when applied.
   */
  inverse(op) {
    switch (op.type) {
      case "insert_node": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "remove_node"
        });
      }
      case "insert_text": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "remove_text"
        });
      }
      case "merge_node": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "split_node",
          path: Path.previous(op.path)
        });
      }
      case "move_node": {
        var {
          newPath,
          path
        } = op;
        if (Path.equals(newPath, path)) {
          return op;
        }
        if (Path.isSibling(path, newPath)) {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            path: newPath,
            newPath: path
          });
        }
        var inversePath = Path.transform(path, op);
        var inverseNewPath = Path.transform(Path.next(path), op);
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          path: inversePath,
          newPath: inverseNewPath
        });
      }
      case "remove_node": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "insert_node"
        });
      }
      case "remove_text": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "insert_text"
        });
      }
      case "set_node": {
        var {
          properties,
          newProperties
        } = op;
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          properties: newProperties,
          newProperties: properties
        });
      }
      case "set_selection": {
        var {
          properties: _properties,
          newProperties: _newProperties
        } = op;
        if (_properties == null) {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            properties: _newProperties,
            newProperties: null
          });
        } else if (_newProperties == null) {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            properties: null,
            newProperties: _properties
          });
        } else {
          return _objectSpread$7(_objectSpread$7({}, op), {}, {
            properties: _newProperties,
            newProperties: _properties
          });
        }
      }
      case "split_node": {
        return _objectSpread$7(_objectSpread$7({}, op), {}, {
          type: "merge_node",
          path: Path.next(op.path)
        });
      }
    }
  }
};
var Path = {
  /**
   * Get a list of ancestor paths for a given path.
   *
   * The paths are sorted from shallowest to deepest ancestor. However, if the
   * `reverse: true` option is passed, they are reversed.
   */
  ancestors(path) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var paths = Path.levels(path, options);
    if (reverse) {
      paths = paths.slice(1);
    } else {
      paths = paths.slice(0, -1);
    }
    return paths;
  },
  /**
   * Get the common ancestor path of two paths.
   */
  common(path, another) {
    var common = [];
    for (var i15 = 0; i15 < path.length && i15 < another.length; i15++) {
      var av = path[i15];
      var bv = another[i15];
      if (av !== bv) {
        break;
      }
      common.push(av);
    }
    return common;
  },
  /**
   * Compare a path to another, returning an integer indicating whether the path
   * was before, at, or after the other.
   *
   * Note: Two paths of unequal length can still receive a `0` result if one is
   * directly above or below the other. If you want exact matching, use
   * [[Path.equals]] instead.
   */
  compare(path, another) {
    var min4 = Math.min(path.length, another.length);
    for (var i15 = 0; i15 < min4; i15++) {
      if (path[i15] < another[i15])
        return -1;
      if (path[i15] > another[i15])
        return 1;
    }
    return 0;
  },
  /**
   * Check if a path ends after one of the indexes in another.
   */
  endsAfter(path, another) {
    var i15 = path.length - 1;
    var as2 = path.slice(0, i15);
    var bs = another.slice(0, i15);
    var av = path[i15];
    var bv = another[i15];
    return Path.equals(as2, bs) && av > bv;
  },
  /**
   * Check if a path ends at one of the indexes in another.
   */
  endsAt(path, another) {
    var i15 = path.length;
    var as2 = path.slice(0, i15);
    var bs = another.slice(0, i15);
    return Path.equals(as2, bs);
  },
  /**
   * Check if a path ends before one of the indexes in another.
   */
  endsBefore(path, another) {
    var i15 = path.length - 1;
    var as2 = path.slice(0, i15);
    var bs = another.slice(0, i15);
    var av = path[i15];
    var bv = another[i15];
    return Path.equals(as2, bs) && av < bv;
  },
  /**
   * Check if a path is exactly equal to another.
   */
  equals(path, another) {
    return path.length === another.length && path.every((n12, i15) => n12 === another[i15]);
  },
  /**
   * Check if the path of previous sibling node exists
   */
  hasPrevious(path) {
    return path[path.length - 1] > 0;
  },
  /**
   * Check if a path is after another.
   */
  isAfter(path, another) {
    return Path.compare(path, another) === 1;
  },
  /**
   * Check if a path is an ancestor of another.
   */
  isAncestor(path, another) {
    return path.length < another.length && Path.compare(path, another) === 0;
  },
  /**
   * Check if a path is before another.
   */
  isBefore(path, another) {
    return Path.compare(path, another) === -1;
  },
  /**
   * Check if a path is a child of another.
   */
  isChild(path, another) {
    return path.length === another.length + 1 && Path.compare(path, another) === 0;
  },
  /**
   * Check if a path is equal to or an ancestor of another.
   */
  isCommon(path, another) {
    return path.length <= another.length && Path.compare(path, another) === 0;
  },
  /**
   * Check if a path is a descendant of another.
   */
  isDescendant(path, another) {
    return path.length > another.length && Path.compare(path, another) === 0;
  },
  /**
   * Check if a path is the parent of another.
   */
  isParent(path, another) {
    return path.length + 1 === another.length && Path.compare(path, another) === 0;
  },
  /**
   * Check is a value implements the `Path` interface.
   */
  isPath(value) {
    return Array.isArray(value) && (value.length === 0 || typeof value[0] === "number");
  },
  /**
   * Check if a path is a sibling of another.
   */
  isSibling(path, another) {
    if (path.length !== another.length) {
      return false;
    }
    var as2 = path.slice(0, -1);
    var bs = another.slice(0, -1);
    var al = path[path.length - 1];
    var bl = another[another.length - 1];
    return al !== bl && Path.equals(as2, bs);
  },
  /**
   * Get a list of paths at every level down to a path. Note: this is the same
   * as `Path.ancestors`, but including the path itself.
   *
   * The paths are sorted from shallowest to deepest. However, if the `reverse:
   * true` option is passed, they are reversed.
   */
  levels(path) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var list = [];
    for (var i15 = 0; i15 <= path.length; i15++) {
      list.push(path.slice(0, i15));
    }
    if (reverse) {
      list.reverse();
    }
    return list;
  },
  /**
   * Given a path, get the path to the next sibling node.
   */
  next(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the next path of a root path [".concat(path, "], because it has no next index."));
    }
    var last2 = path[path.length - 1];
    return path.slice(0, -1).concat(last2 + 1);
  },
  /**
   * Returns whether this operation can affect paths or not. Used as an
   * optimization when updating dirty paths during normalization
   *
   * NOTE: This *must* be kept in sync with the implementation of 'transform'
   * below
   */
  operationCanTransformPath(operation) {
    switch (operation.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return true;
      default:
        return false;
    }
  },
  /**
   * Given a path, return a new path referring to the parent node above it.
   */
  parent(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the parent path of the root path [".concat(path, "]."));
    }
    return path.slice(0, -1);
  },
  /**
   * Given a path, get the path to the previous sibling node.
   */
  previous(path) {
    if (path.length === 0) {
      throw new Error("Cannot get the previous path of a root path [".concat(path, "], because it has no previous index."));
    }
    var last2 = path[path.length - 1];
    if (last2 <= 0) {
      throw new Error("Cannot get the previous path of a first child path [".concat(path, "] because it would result in a negative index."));
    }
    return path.slice(0, -1).concat(last2 - 1);
  },
  /**
   * Get a path relative to an ancestor.
   */
  relative(path, ancestor) {
    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {
      throw new Error("Cannot get the relative path of [".concat(path, "] inside ancestor [").concat(ancestor, "], because it is not above or equal to the path."));
    }
    return path.slice(ancestor.length);
  },
  /**
   * Transform a path by an operation.
   */
  transform(path, operation) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fn(path, (p12) => {
      var {
        affinity = "forward"
      } = options;
      if (!path || (path === null || path === void 0 ? void 0 : path.length) === 0) {
        return;
      }
      if (p12 === null) {
        return null;
      }
      switch (operation.type) {
        case "insert_node": {
          var {
            path: op
          } = operation;
          if (Path.equals(op, p12) || Path.endsBefore(op, p12) || Path.isAncestor(op, p12)) {
            p12[op.length - 1] += 1;
          }
          break;
        }
        case "remove_node": {
          var {
            path: _op
          } = operation;
          if (Path.equals(_op, p12) || Path.isAncestor(_op, p12)) {
            return null;
          } else if (Path.endsBefore(_op, p12)) {
            p12[_op.length - 1] -= 1;
          }
          break;
        }
        case "merge_node": {
          var {
            path: _op2,
            position: position3
          } = operation;
          if (Path.equals(_op2, p12) || Path.endsBefore(_op2, p12)) {
            p12[_op2.length - 1] -= 1;
          } else if (Path.isAncestor(_op2, p12)) {
            p12[_op2.length - 1] -= 1;
            p12[_op2.length] += position3;
          }
          break;
        }
        case "split_node": {
          var {
            path: _op3,
            position: _position
          } = operation;
          if (Path.equals(_op3, p12)) {
            if (affinity === "forward") {
              p12[p12.length - 1] += 1;
            } else if (affinity === "backward")
              ;
            else {
              return null;
            }
          } else if (Path.endsBefore(_op3, p12)) {
            p12[_op3.length - 1] += 1;
          } else if (Path.isAncestor(_op3, p12) && path[_op3.length] >= _position) {
            p12[_op3.length - 1] += 1;
            p12[_op3.length] -= _position;
          }
          break;
        }
        case "move_node": {
          var {
            path: _op4,
            newPath: onp
          } = operation;
          if (Path.equals(_op4, onp)) {
            return;
          }
          if (Path.isAncestor(_op4, p12) || Path.equals(_op4, p12)) {
            var copy = onp.slice();
            if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {
              copy[_op4.length - 1] -= 1;
            }
            return copy.concat(p12.slice(_op4.length));
          } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p12) || Path.equals(onp, p12))) {
            if (Path.endsBefore(_op4, p12)) {
              p12[_op4.length - 1] -= 1;
            } else {
              p12[_op4.length - 1] += 1;
            }
          } else if (Path.endsBefore(onp, p12) || Path.equals(onp, p12) || Path.isAncestor(onp, p12)) {
            if (Path.endsBefore(_op4, p12)) {
              p12[_op4.length - 1] -= 1;
            }
            p12[onp.length - 1] += 1;
          } else if (Path.endsBefore(_op4, p12)) {
            if (Path.equals(onp, p12)) {
              p12[onp.length - 1] += 1;
            }
            p12[_op4.length - 1] -= 1;
          }
          break;
        }
      }
    });
  }
};
var PathRef = {
  /**
   * Transform the path ref's current value by an operation.
   */
  transform(ref2, op) {
    var {
      current,
      affinity
    } = ref2;
    if (current == null) {
      return;
    }
    var path = Path.transform(current, op, {
      affinity
    });
    ref2.current = path;
    if (path == null) {
      ref2.unref();
    }
  }
};
function ownKeys$6(object2, enumerableOnly) {
  var keys6 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys6.push.apply(keys6, symbols);
  }
  return keys6;
}
function _objectSpread$6(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15] != null ? arguments[i15] : {};
    if (i15 % 2) {
      ownKeys$6(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$6(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Point = {
  /**
   * Compare a point to another, returning an integer indicating whether the
   * point was before, at, or after the other.
   */
  compare(point, another) {
    var result = Path.compare(point.path, another.path);
    if (result === 0) {
      if (point.offset < another.offset)
        return -1;
      if (point.offset > another.offset)
        return 1;
      return 0;
    }
    return result;
  },
  /**
   * Check if a point is after another.
   */
  isAfter(point, another) {
    return Point.compare(point, another) === 1;
  },
  /**
   * Check if a point is before another.
   */
  isBefore(point, another) {
    return Point.compare(point, another) === -1;
  },
  /**
   * Check if a point is exactly equal to another.
   */
  equals(point, another) {
    return point.offset === another.offset && Path.equals(point.path, another.path);
  },
  /**
   * Check if a value implements the `Point` interface.
   */
  isPoint(value) {
    return isPlainObject(value) && typeof value.offset === "number" && Path.isPath(value.path);
  },
  /**
   * Transform a point by an operation.
   */
  transform(point, op) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fn(point, (p12) => {
      if (p12 === null) {
        return null;
      }
      var {
        affinity = "forward"
      } = options;
      var {
        path,
        offset: offset5
      } = p12;
      switch (op.type) {
        case "insert_node":
        case "move_node": {
          p12.path = Path.transform(path, op, options);
          break;
        }
        case "insert_text": {
          if (Path.equals(op.path, path) && (op.offset < offset5 || op.offset === offset5 && affinity === "forward")) {
            p12.offset += op.text.length;
          }
          break;
        }
        case "merge_node": {
          if (Path.equals(op.path, path)) {
            p12.offset += op.position;
          }
          p12.path = Path.transform(path, op, options);
          break;
        }
        case "remove_text": {
          if (Path.equals(op.path, path) && op.offset <= offset5) {
            p12.offset -= Math.min(offset5 - op.offset, op.text.length);
          }
          break;
        }
        case "remove_node": {
          if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {
            return null;
          }
          p12.path = Path.transform(path, op, options);
          break;
        }
        case "split_node": {
          if (Path.equals(op.path, path)) {
            if (op.position === offset5 && affinity == null) {
              return null;
            } else if (op.position < offset5 || op.position === offset5 && affinity === "forward") {
              p12.offset -= op.position;
              p12.path = Path.transform(path, op, _objectSpread$6(_objectSpread$6({}, options), {}, {
                affinity: "forward"
              }));
            }
          } else {
            p12.path = Path.transform(path, op, options);
          }
          break;
        }
      }
    });
  }
};
var PointRef = {
  /**
   * Transform the point ref's current value by an operation.
   */
  transform(ref2, op) {
    var {
      current,
      affinity
    } = ref2;
    if (current == null) {
      return;
    }
    var point = Point.transform(current, op, {
      affinity
    });
    ref2.current = point;
    if (point == null) {
      ref2.unref();
    }
  }
};
var _excluded$2 = ["anchor", "focus"];
function ownKeys$5(object2, enumerableOnly) {
  var keys6 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys6.push.apply(keys6, symbols);
  }
  return keys6;
}
function _objectSpread$5(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15] != null ? arguments[i15] : {};
    if (i15 % 2) {
      ownKeys$5(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$5(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Range = {
  /**
   * Get the start and end points of a range, in the order in which they appear
   * in the document.
   */
  edges(range) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      reverse = false
    } = options;
    var {
      anchor,
      focus: focus2
    } = range;
    return Range.isBackward(range) === reverse ? [anchor, focus2] : [focus2, anchor];
  },
  /**
   * Get the end point of a range.
   */
  end(range) {
    var [, end2] = Range.edges(range);
    return end2;
  },
  /**
   * Check if a range is exactly equal to another.
   */
  equals(range, another) {
    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);
  },
  /**
   * Check if a range includes a path, a point or part of another range.
   */
  includes(range, target) {
    if (Range.isRange(target)) {
      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {
        return true;
      }
      var [rs, re6] = Range.edges(range);
      var [ts, te4] = Range.edges(target);
      return Point.isBefore(rs, ts) && Point.isAfter(re6, te4);
    }
    var [start3, end2] = Range.edges(range);
    var isAfterStart = false;
    var isBeforeEnd = false;
    if (Point.isPoint(target)) {
      isAfterStart = Point.compare(target, start3) >= 0;
      isBeforeEnd = Point.compare(target, end2) <= 0;
    } else {
      isAfterStart = Path.compare(target, start3.path) >= 0;
      isBeforeEnd = Path.compare(target, end2.path) <= 0;
    }
    return isAfterStart && isBeforeEnd;
  },
  /**
   * Get the intersection of a range with another.
   */
  intersection(range, another) {
    var rest = _objectWithoutProperties(range, _excluded$2);
    var [s1, e1] = Range.edges(range);
    var [s22, e22] = Range.edges(another);
    var start3 = Point.isBefore(s1, s22) ? s22 : s1;
    var end2 = Point.isBefore(e1, e22) ? e1 : e22;
    if (Point.isBefore(end2, start3)) {
      return null;
    } else {
      return _objectSpread$5({
        anchor: start3,
        focus: end2
      }, rest);
    }
  },
  /**
   * Check if a range is backward, meaning that its anchor point appears in the
   * document _after_ its focus point.
   */
  isBackward(range) {
    var {
      anchor,
      focus: focus2
    } = range;
    return Point.isAfter(anchor, focus2);
  },
  /**
   * Check if a range is collapsed, meaning that both its anchor and focus
   * points refer to the exact same position in the document.
   */
  isCollapsed(range) {
    var {
      anchor,
      focus: focus2
    } = range;
    return Point.equals(anchor, focus2);
  },
  /**
   * Check if a range is expanded.
   *
   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.
   */
  isExpanded(range) {
    return !Range.isCollapsed(range);
  },
  /**
   * Check if a range is forward.
   *
   * This is the opposite of [[Range.isBackward]] and is provided for legibility.
   */
  isForward(range) {
    return !Range.isBackward(range);
  },
  /**
   * Check if a value implements the [[Range]] interface.
   */
  isRange(value) {
    return isPlainObject(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);
  },
  /**
   * Iterate through all of the point entries in a range.
   */
  *points(range) {
    yield [range.anchor, "anchor"];
    yield [range.focus, "focus"];
  },
  /**
   * Get the start point of a range.
   */
  start(range) {
    var [start3] = Range.edges(range);
    return start3;
  },
  /**
   * Transform a range by an operation.
   */
  transform(range, op) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fn(range, (r15) => {
      if (r15 === null) {
        return null;
      }
      var {
        affinity = "inward"
      } = options;
      var affinityAnchor;
      var affinityFocus;
      if (affinity === "inward") {
        var isCollapsed2 = Range.isCollapsed(r15);
        if (Range.isForward(r15)) {
          affinityAnchor = "forward";
          affinityFocus = isCollapsed2 ? affinityAnchor : "backward";
        } else {
          affinityAnchor = "backward";
          affinityFocus = isCollapsed2 ? affinityAnchor : "forward";
        }
      } else if (affinity === "outward") {
        if (Range.isForward(r15)) {
          affinityAnchor = "backward";
          affinityFocus = "forward";
        } else {
          affinityAnchor = "forward";
          affinityFocus = "backward";
        }
      } else {
        affinityAnchor = affinity;
        affinityFocus = affinity;
      }
      var anchor = Point.transform(r15.anchor, op, {
        affinity: affinityAnchor
      });
      var focus2 = Point.transform(r15.focus, op, {
        affinity: affinityFocus
      });
      if (!anchor || !focus2) {
        return null;
      }
      r15.anchor = anchor;
      r15.focus = focus2;
    });
  }
};
var RangeRef = {
  /**
   * Transform the range ref's current value by an operation.
   */
  transform(ref2, op) {
    var {
      current,
      affinity
    } = ref2;
    if (current == null) {
      return;
    }
    var path = Range.transform(current, op, {
      affinity
    });
    ref2.current = path;
    if (path == null) {
      ref2.unref();
    }
  }
};
var _scrubber = void 0;
var Scrubber = {
  setScrubber(scrubber) {
    _scrubber = scrubber;
  },
  stringify(value) {
    return JSON.stringify(value, _scrubber);
  }
};
var isDeepEqual = (node, another) => {
  for (var key in node) {
    var a13 = node[key];
    var b6 = another[key];
    if (isPlainObject(a13) && isPlainObject(b6)) {
      if (!isDeepEqual(a13, b6))
        return false;
    } else if (Array.isArray(a13) && Array.isArray(b6)) {
      if (a13.length !== b6.length)
        return false;
      for (var i15 = 0; i15 < a13.length; i15++) {
        if (a13[i15] !== b6[i15])
          return false;
      }
    } else if (a13 !== b6) {
      return false;
    }
  }
  for (var _key in another) {
    if (node[_key] === void 0 && another[_key] !== void 0) {
      return false;
    }
  }
  return true;
};
var _excluded$1 = ["text"];
var _excluded2$1 = ["anchor", "focus"];
function ownKeys$4(object2, enumerableOnly) {
  var keys6 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys6.push.apply(keys6, symbols);
  }
  return keys6;
}
function _objectSpread$4(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15] != null ? arguments[i15] : {};
    if (i15 % 2) {
      ownKeys$4(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$4(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Text = {
  /**
   * Check if two text nodes are equal.
   *
   * When loose is set, the text is not compared. This is
   * used to check whether sibling text nodes can be merged.
   */
  equals(text, another) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      loose = false
    } = options;
    function omitText(obj) {
      var rest = _objectWithoutProperties(obj, _excluded$1);
      return rest;
    }
    return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);
  },
  /**
   * Check if a value implements the `Text` interface.
   */
  isText(value) {
    return isPlainObject(value) && typeof value.text === "string";
  },
  /**
   * Check if a value is a list of `Text` objects.
   */
  isTextList(value) {
    return Array.isArray(value) && value.every((val) => Text.isText(val));
  },
  /**
   * Check if some props are a partial of Text.
   */
  isTextProps(props) {
    return props.text !== void 0;
  },
  /**
   * Check if an text matches set of properties.
   *
   * Note: this is for matching custom properties, and it does not ensure that
   * the `text` property are two nodes equal.
   */
  matches(text, props) {
    for (var key in props) {
      if (key === "text") {
        continue;
      }
      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {
        return false;
      }
    }
    return true;
  },
  /**
   * Get the leaves for a text node given decorations.
   */
  decorations(node, decorations) {
    var leaves = [_objectSpread$4({}, node)];
    for (var dec of decorations) {
      var rest = _objectWithoutProperties(dec, _excluded2$1);
      var [start3, end2] = Range.edges(dec);
      var next = [];
      var leafEnd = 0;
      var decorationStart = start3.offset;
      var decorationEnd = end2.offset;
      for (var leaf of leaves) {
        var {
          length
        } = leaf.text;
        var leafStart = leafEnd;
        leafEnd += length;
        if (decorationStart <= leafStart && leafEnd <= decorationEnd) {
          Object.assign(leaf, rest);
          next.push(leaf);
          continue;
        }
        if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {
          next.push(leaf);
          continue;
        }
        var middle = leaf;
        var before = void 0;
        var after = void 0;
        if (decorationEnd < leafEnd) {
          var off = decorationEnd - leafStart;
          after = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(off)
          });
          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(0, off)
          });
        }
        if (decorationStart > leafStart) {
          var _off = decorationStart - leafStart;
          before = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(0, _off)
          });
          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {
            text: middle.text.slice(_off)
          });
        }
        Object.assign(middle, rest);
        if (before) {
          next.push(before);
        }
        next.push(middle);
        if (after) {
          next.push(after);
        }
      }
      leaves = next;
    }
    return leaves;
  }
};
function ownKeys$3(object2, enumerableOnly) {
  var keys6 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys6.push.apply(keys6, symbols);
  }
  return keys6;
}
function _objectSpread$3(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15] != null ? arguments[i15] : {};
    if (i15 % 2) {
      ownKeys$3(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var applyToDraft = (editor, selection, op) => {
  switch (op.type) {
    case "insert_node": {
      var {
        path,
        node
      } = op;
      var parent2 = Node2.parent(editor, path);
      var index2 = path[path.length - 1];
      if (index2 > parent2.children.length) {
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(path, "] because the destination is past the end of the node."));
      }
      parent2.children.splice(index2, 0, node);
      if (selection) {
        for (var [point, key] of Range.points(selection)) {
          selection[key] = Point.transform(point, op);
        }
      }
      break;
    }
    case "insert_text": {
      var {
        path: _path,
        offset: offset5,
        text
      } = op;
      if (text.length === 0)
        break;
      var _node = Node2.leaf(editor, _path);
      var before = _node.text.slice(0, offset5);
      var after = _node.text.slice(offset5);
      _node.text = before + text + after;
      if (selection) {
        for (var [_point, _key] of Range.points(selection)) {
          selection[_key] = Point.transform(_point, op);
        }
      }
      break;
    }
    case "merge_node": {
      var {
        path: _path2
      } = op;
      var _node2 = Node2.get(editor, _path2);
      var prevPath = Path.previous(_path2);
      var prev = Node2.get(editor, prevPath);
      var _parent2 = Node2.parent(editor, _path2);
      var _index = _path2[_path2.length - 1];
      if (Text.isText(_node2) && Text.isText(prev)) {
        prev.text += _node2.text;
      } else if (!Text.isText(_node2) && !Text.isText(prev)) {
        prev.children.push(..._node2.children);
      } else {
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(_path2, "] to nodes of different interfaces: ").concat(Scrubber.stringify(_node2), " ").concat(Scrubber.stringify(prev)));
      }
      _parent2.children.splice(_index, 1);
      if (selection) {
        for (var [_point2, _key2] of Range.points(selection)) {
          selection[_key2] = Point.transform(_point2, op);
        }
      }
      break;
    }
    case "move_node": {
      var {
        path: _path3,
        newPath
      } = op;
      if (Path.isAncestor(_path3, newPath)) {
        throw new Error("Cannot move a path [".concat(_path3, "] to new path [").concat(newPath, "] because the destination is inside itself."));
      }
      var _node3 = Node2.get(editor, _path3);
      var _parent22 = Node2.parent(editor, _path3);
      var _index2 = _path3[_path3.length - 1];
      _parent22.children.splice(_index2, 1);
      var truePath = Path.transform(_path3, op);
      var newParent = Node2.get(editor, Path.parent(truePath));
      var newIndex = truePath[truePath.length - 1];
      newParent.children.splice(newIndex, 0, _node3);
      if (selection) {
        for (var [_point3, _key3] of Range.points(selection)) {
          selection[_key3] = Point.transform(_point3, op);
        }
      }
      break;
    }
    case "remove_node": {
      var {
        path: _path4
      } = op;
      var _index3 = _path4[_path4.length - 1];
      var _parent3 = Node2.parent(editor, _path4);
      _parent3.children.splice(_index3, 1);
      if (selection) {
        for (var [_point4, _key4] of Range.points(selection)) {
          var result = Point.transform(_point4, op);
          if (selection != null && result != null) {
            selection[_key4] = result;
          } else {
            var _prev = void 0;
            var next = void 0;
            for (var [n12, p12] of Node2.texts(editor)) {
              if (Path.compare(p12, _path4) === -1) {
                _prev = [n12, p12];
              } else {
                next = [n12, p12];
                break;
              }
            }
            var preferNext = false;
            if (_prev && next) {
              if (Path.equals(next[1], _path4)) {
                preferNext = !Path.hasPrevious(next[1]);
              } else {
                preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;
              }
            }
            if (_prev && !preferNext) {
              _point4.path = _prev[1];
              _point4.offset = _prev[0].text.length;
            } else if (next) {
              _point4.path = next[1];
              _point4.offset = 0;
            } else {
              selection = null;
            }
          }
        }
      }
      break;
    }
    case "remove_text": {
      var {
        path: _path5,
        offset: _offset,
        text: _text
      } = op;
      if (_text.length === 0)
        break;
      var _node4 = Node2.leaf(editor, _path5);
      var _before = _node4.text.slice(0, _offset);
      var _after = _node4.text.slice(_offset + _text.length);
      _node4.text = _before + _after;
      if (selection) {
        for (var [_point5, _key5] of Range.points(selection)) {
          selection[_key5] = Point.transform(_point5, op);
        }
      }
      break;
    }
    case "set_node": {
      var {
        path: _path6,
        properties,
        newProperties
      } = op;
      if (_path6.length === 0) {
        throw new Error("Cannot set properties on the root node!");
      }
      var _node5 = Node2.get(editor, _path6);
      for (var _key6 in newProperties) {
        if (_key6 === "children" || _key6 === "text") {
          throw new Error('Cannot set the "'.concat(_key6, '" property of nodes!'));
        }
        var value = newProperties[_key6];
        if (value == null) {
          delete _node5[_key6];
        } else {
          _node5[_key6] = value;
        }
      }
      for (var _key7 in properties) {
        if (!newProperties.hasOwnProperty(_key7)) {
          delete _node5[_key7];
        }
      }
      break;
    }
    case "set_selection": {
      var {
        newProperties: _newProperties
      } = op;
      if (_newProperties == null) {
        selection = _newProperties;
      } else {
        if (selection == null) {
          if (!Range.isRange(_newProperties)) {
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Scrubber.stringify(_newProperties), " when there is no current selection."));
          }
          selection = _objectSpread$3({}, _newProperties);
        }
        for (var _key8 in _newProperties) {
          var _value = _newProperties[_key8];
          if (_value == null) {
            if (_key8 === "anchor" || _key8 === "focus") {
              throw new Error('Cannot remove the "'.concat(_key8, '" selection property'));
            }
            delete selection[_key8];
          } else {
            selection[_key8] = _value;
          }
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: _path7,
        position: position3,
        properties: _properties
      } = op;
      if (_path7.length === 0) {
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(_path7, "] because the root node cannot be split."));
      }
      var _node6 = Node2.get(editor, _path7);
      var _parent4 = Node2.parent(editor, _path7);
      var _index4 = _path7[_path7.length - 1];
      var newNode;
      if (Text.isText(_node6)) {
        var _before2 = _node6.text.slice(0, position3);
        var _after2 = _node6.text.slice(position3);
        _node6.text = _before2;
        newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {
          text: _after2
        });
      } else {
        var _before3 = _node6.children.slice(0, position3);
        var _after3 = _node6.children.slice(position3);
        _node6.children = _before3;
        newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {
          children: _after3
        });
      }
      _parent4.children.splice(_index4 + 1, 0, newNode);
      if (selection) {
        for (var [_point6, _key9] of Range.points(selection)) {
          selection[_key9] = Point.transform(_point6, op);
        }
      }
      break;
    }
  }
  return selection;
};
var GeneralTransforms = {
  /**
   * Transform the editor by an operation.
   */
  transform(editor, op) {
    editor.children = ln(editor.children);
    var selection = editor.selection && ln(editor.selection);
    try {
      selection = applyToDraft(editor, selection, op);
    } finally {
      editor.children = dn(editor.children);
      if (selection) {
        editor.selection = r(selection) ? dn(selection) : selection;
      } else {
        editor.selection = null;
      }
    }
  }
};
var _excluded = ["text"];
var _excluded2 = ["children"];
function ownKeys$2(object2, enumerableOnly) {
  var keys6 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys6.push.apply(keys6, symbols);
  }
  return keys6;
}
function _objectSpread$2(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15] != null ? arguments[i15] : {};
    if (i15 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var NodeTransforms = {
  /**
   * Insert nodes at a specific location in the Editor.
   */
  insertNodes(editor, nodes) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false,
        mode = "lowest"
      } = options;
      var {
        at,
        match: match5,
        select: select2
      } = options;
      if (Node2.isNode(nodes)) {
        nodes = [nodes];
      }
      if (nodes.length === 0) {
        return;
      }
      var [node] = nodes;
      if (!at) {
        if (editor.selection) {
          at = editor.selection;
        } else if (editor.children.length > 0) {
          at = Editor.end(editor, []);
        } else {
          at = [0];
        }
        select2 = true;
      }
      if (select2 == null) {
        select2 = false;
      }
      if (Range.isRange(at)) {
        if (!hanging) {
          at = Editor.unhangRange(editor, at);
        }
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end2] = Range.edges(at);
          var pointRef = Editor.pointRef(editor, end2);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
        }
      }
      if (Point.isPoint(at)) {
        if (match5 == null) {
          if (Text.isText(node)) {
            match5 = (n12) => Text.isText(n12);
          } else if (editor.isInline(node)) {
            match5 = (n12) => Text.isText(n12) || Editor.isInline(editor, n12);
          } else {
            match5 = (n12) => Editor.isBlock(editor, n12);
          }
        }
        var [entry] = Editor.nodes(editor, {
          at: at.path,
          match: match5,
          mode,
          voids
        });
        if (entry) {
          var [, _matchPath] = entry;
          var pathRef = Editor.pathRef(editor, _matchPath);
          var isAtEnd = Editor.isEnd(editor, at, _matchPath);
          Transforms.splitNodes(editor, {
            at,
            match: match5,
            mode,
            voids
          });
          var path = pathRef.unref();
          at = isAtEnd ? Path.next(path) : path;
        } else {
          return;
        }
      }
      var parentPath = Path.parent(at);
      var index2 = at[at.length - 1];
      if (!voids && Editor.void(editor, {
        at: parentPath
      })) {
        return;
      }
      for (var _node of nodes) {
        var _path = parentPath.concat(index2);
        index2++;
        editor.apply({
          type: "insert_node",
          path: _path,
          node: _node
        });
        at = Path.next(at);
      }
      at = Path.previous(at);
      if (select2) {
        var point = Editor.end(editor, at);
        if (point) {
          Transforms.select(editor, point);
        }
      }
    });
  },
  /**
   * Lift nodes at a specific location upwards in the document tree, splitting
   * their parent in two if necessary.
   */
  liftNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        at = editor.selection,
        mode = "lowest",
        voids = false
      } = options;
      var {
        match: match5
      } = options;
      if (match5 == null) {
        match5 = Path.isPath(at) ? matchPath(editor, at) : (n12) => Editor.isBlock(editor, n12);
      }
      if (!at) {
        return;
      }
      var matches = Editor.nodes(editor, {
        at,
        match: match5,
        mode,
        voids
      });
      var pathRefs = Array.from(matches, (_ref) => {
        var [, p12] = _ref;
        return Editor.pathRef(editor, p12);
      });
      for (var pathRef of pathRefs) {
        var path = pathRef.unref();
        if (path.length < 2) {
          throw new Error("Cannot lift node at a path [".concat(path, "] because it has a depth of less than `2`."));
        }
        var parentNodeEntry = Editor.node(editor, Path.parent(path));
        var [parent2, parentPath] = parentNodeEntry;
        var index2 = path[path.length - 1];
        var {
          length
        } = parent2.children;
        if (length === 1) {
          var toPath3 = Path.next(parentPath);
          Transforms.moveNodes(editor, {
            at: path,
            to: toPath3,
            voids
          });
          Transforms.removeNodes(editor, {
            at: parentPath,
            voids
          });
        } else if (index2 === 0) {
          Transforms.moveNodes(editor, {
            at: path,
            to: parentPath,
            voids
          });
        } else if (index2 === length - 1) {
          var _toPath = Path.next(parentPath);
          Transforms.moveNodes(editor, {
            at: path,
            to: _toPath,
            voids
          });
        } else {
          var splitPath = Path.next(path);
          var _toPath2 = Path.next(parentPath);
          Transforms.splitNodes(editor, {
            at: splitPath,
            voids
          });
          Transforms.moveNodes(editor, {
            at: path,
            to: _toPath2,
            voids
          });
        }
      }
    });
  },
  /**
   * Merge a node at a location with the previous node of the same depth,
   * removing any empty containing nodes after the merge if necessary.
   */
  mergeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        match: match5,
        at = editor.selection
      } = options;
      var {
        hanging = false,
        voids = false,
        mode = "lowest"
      } = options;
      if (!at) {
        return;
      }
      if (match5 == null) {
        if (Path.isPath(at)) {
          var [parent2] = Editor.parent(editor, at);
          match5 = (n12) => parent2.children.includes(n12);
        } else {
          match5 = (n12) => Editor.isBlock(editor, n12);
        }
      }
      if (!hanging && Range.isRange(at)) {
        at = Editor.unhangRange(editor, at);
      }
      if (Range.isRange(at)) {
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end2] = Range.edges(at);
          var pointRef = Editor.pointRef(editor, end2);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
          if (options.at == null) {
            Transforms.select(editor, at);
          }
        }
      }
      var [current] = Editor.nodes(editor, {
        at,
        match: match5,
        voids,
        mode
      });
      var prev = Editor.previous(editor, {
        at,
        match: match5,
        voids,
        mode
      });
      if (!current || !prev) {
        return;
      }
      var [node, path] = current;
      var [prevNode, prevPath] = prev;
      if (path.length === 0 || prevPath.length === 0) {
        return;
      }
      var newPath = Path.next(prevPath);
      var commonPath = Path.common(path, prevPath);
      var isPreviousSibling = Path.isSibling(path, prevPath);
      var levels = Array.from(Editor.levels(editor, {
        at: path
      }), (_ref2) => {
        var [n12] = _ref2;
        return n12;
      }).slice(commonPath.length).slice(0, -1);
      var emptyAncestor = Editor.above(editor, {
        at: path,
        mode: "highest",
        match: (n12) => levels.includes(n12) && hasSingleChildNest(editor, n12)
      });
      var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);
      var properties;
      var position3;
      if (Text.isText(node) && Text.isText(prevNode)) {
        var rest = _objectWithoutProperties(node, _excluded);
        position3 = prevNode.text.length;
        properties = rest;
      } else if (Element2.isElement(node) && Element2.isElement(prevNode)) {
        var rest = _objectWithoutProperties(node, _excluded2);
        position3 = prevNode.children.length;
        properties = rest;
      } else {
        throw new Error("Cannot merge the node at path [".concat(path, "] with the previous sibling because it is not the same kind: ").concat(Scrubber.stringify(node), " ").concat(Scrubber.stringify(prevNode)));
      }
      if (!isPreviousSibling) {
        Transforms.moveNodes(editor, {
          at: path,
          to: newPath,
          voids
        });
      }
      if (emptyRef) {
        Transforms.removeNodes(editor, {
          at: emptyRef.current,
          voids
        });
      }
      if (Element2.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === "" && prevPath[prevPath.length - 1] !== 0) {
        Transforms.removeNodes(editor, {
          at: prevPath,
          voids
        });
      } else {
        editor.apply({
          type: "merge_node",
          path: newPath,
          position: position3,
          properties
        });
      }
      if (emptyRef) {
        emptyRef.unref();
      }
    });
  },
  /**
   * Move the nodes at a location to a new location.
   */
  moveNodes(editor, options) {
    Editor.withoutNormalizing(editor, () => {
      var {
        to: to4,
        at = editor.selection,
        mode = "lowest",
        voids = false
      } = options;
      var {
        match: match5
      } = options;
      if (!at) {
        return;
      }
      if (match5 == null) {
        match5 = Path.isPath(at) ? matchPath(editor, at) : (n12) => Editor.isBlock(editor, n12);
      }
      var toRef = Editor.pathRef(editor, to4);
      var targets = Editor.nodes(editor, {
        at,
        match: match5,
        mode,
        voids
      });
      var pathRefs = Array.from(targets, (_ref3) => {
        var [, p12] = _ref3;
        return Editor.pathRef(editor, p12);
      });
      for (var pathRef of pathRefs) {
        var path = pathRef.unref();
        var newPath = toRef.current;
        if (path.length !== 0) {
          editor.apply({
            type: "move_node",
            path,
            newPath
          });
        }
        if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {
          toRef.current = Path.next(toRef.current);
        }
      }
      toRef.unref();
    });
  },
  /**
   * Remove the nodes at a specific location in the document.
   */
  removeNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false,
        mode = "lowest"
      } = options;
      var {
        at = editor.selection,
        match: match5
      } = options;
      if (!at) {
        return;
      }
      if (match5 == null) {
        match5 = Path.isPath(at) ? matchPath(editor, at) : (n12) => Editor.isBlock(editor, n12);
      }
      if (!hanging && Range.isRange(at)) {
        at = Editor.unhangRange(editor, at);
      }
      var depths = Editor.nodes(editor, {
        at,
        match: match5,
        mode,
        voids
      });
      var pathRefs = Array.from(depths, (_ref4) => {
        var [, p12] = _ref4;
        return Editor.pathRef(editor, p12);
      });
      for (var pathRef of pathRefs) {
        var path = pathRef.unref();
        if (path) {
          var [node] = Editor.node(editor, path);
          editor.apply({
            type: "remove_node",
            path,
            node
          });
        }
      }
    });
  },
  /**
   * Set new properties on the nodes at a location.
   */
  setNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        match: match5,
        at = editor.selection,
        compare,
        merge: merge3
      } = options;
      var {
        hanging = false,
        mode = "lowest",
        split: split2 = false,
        voids = false
      } = options;
      if (!at) {
        return;
      }
      if (match5 == null) {
        match5 = Path.isPath(at) ? matchPath(editor, at) : (n12) => Editor.isBlock(editor, n12);
      }
      if (!hanging && Range.isRange(at)) {
        at = Editor.unhangRange(editor, at);
      }
      if (split2 && Range.isRange(at)) {
        if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {
          return;
        }
        var rangeRef = Editor.rangeRef(editor, at, {
          affinity: "inward"
        });
        var [start3, end2] = Range.edges(at);
        var splitMode = mode === "lowest" ? "lowest" : "highest";
        var endAtEndOfNode = Editor.isEnd(editor, end2, end2.path);
        Transforms.splitNodes(editor, {
          at: end2,
          match: match5,
          mode: splitMode,
          voids,
          always: !endAtEndOfNode
        });
        var startAtStartOfNode = Editor.isStart(editor, start3, start3.path);
        Transforms.splitNodes(editor, {
          at: start3,
          match: match5,
          mode: splitMode,
          voids,
          always: !startAtStartOfNode
        });
        at = rangeRef.unref();
        if (options.at == null) {
          Transforms.select(editor, at);
        }
      }
      if (!compare) {
        compare = (prop, nodeProp) => prop !== nodeProp;
      }
      for (var [node, path] of Editor.nodes(editor, {
        at,
        match: match5,
        mode,
        voids
      })) {
        var properties = {};
        var newProperties = {};
        if (path.length === 0) {
          continue;
        }
        var hasChanges = false;
        for (var k3 in props) {
          if (k3 === "children" || k3 === "text") {
            continue;
          }
          if (compare(props[k3], node[k3])) {
            hasChanges = true;
            if (node.hasOwnProperty(k3))
              properties[k3] = node[k3];
            if (merge3) {
              if (props[k3] != null)
                newProperties[k3] = merge3(node[k3], props[k3]);
            } else {
              if (props[k3] != null)
                newProperties[k3] = props[k3];
            }
          }
        }
        if (hasChanges) {
          editor.apply({
            type: "set_node",
            path,
            properties,
            newProperties
          });
        }
      }
    });
  },
  /**
   * Split the nodes at a specific location.
   */
  splitNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = "lowest",
        voids = false
      } = options;
      var {
        match: match5,
        at = editor.selection,
        height = 0,
        always = false
      } = options;
      if (match5 == null) {
        match5 = (n12) => Editor.isBlock(editor, n12);
      }
      if (Range.isRange(at)) {
        at = deleteRange(editor, at);
      }
      if (Path.isPath(at)) {
        var path = at;
        var point = Editor.point(editor, path);
        var [parent2] = Editor.parent(editor, path);
        match5 = (n12) => n12 === parent2;
        height = point.path.length - path.length + 1;
        at = point;
        always = true;
      }
      if (!at) {
        return;
      }
      var beforeRef = Editor.pointRef(editor, at, {
        affinity: "backward"
      });
      var afterRef;
      try {
        var [highest] = Editor.nodes(editor, {
          at,
          match: match5,
          mode,
          voids
        });
        if (!highest) {
          return;
        }
        var voidMatch = Editor.void(editor, {
          at,
          mode: "highest"
        });
        var nudge = 0;
        if (!voids && voidMatch) {
          var [voidNode, voidPath] = voidMatch;
          if (Element2.isElement(voidNode) && editor.isInline(voidNode)) {
            var after = Editor.after(editor, voidPath);
            if (!after) {
              var text = {
                text: ""
              };
              var afterPath = Path.next(voidPath);
              Transforms.insertNodes(editor, text, {
                at: afterPath,
                voids
              });
              after = Editor.point(editor, afterPath);
            }
            at = after;
            always = true;
          }
          var siblingHeight = at.path.length - voidPath.length;
          height = siblingHeight + 1;
          always = true;
        }
        afterRef = Editor.pointRef(editor, at);
        var depth = at.path.length - height;
        var [, highestPath] = highest;
        var lowestPath = at.path.slice(0, depth);
        var position3 = height === 0 ? at.offset : at.path[depth] + nudge;
        for (var [node, _path2] of Editor.levels(editor, {
          at: lowestPath,
          reverse: true,
          voids
        })) {
          var split2 = false;
          if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Editor.isVoid(editor, node)) {
            break;
          }
          var _point = beforeRef.current;
          var isEnd = Editor.isEnd(editor, _point, _path2);
          if (always || !beforeRef || !Editor.isEdge(editor, _point, _path2)) {
            split2 = true;
            var properties = Node2.extractProps(node);
            editor.apply({
              type: "split_node",
              path: _path2,
              position: position3,
              properties
            });
          }
          position3 = _path2[_path2.length - 1] + (split2 || isEnd ? 1 : 0);
        }
        if (options.at == null) {
          var _point2 = afterRef.current || Editor.end(editor, []);
          Transforms.select(editor, _point2);
        }
      } finally {
        var _afterRef;
        beforeRef.unref();
        (_afterRef = afterRef) === null || _afterRef === void 0 ? void 0 : _afterRef.unref();
      }
    });
  },
  /**
   * Unset properties on the nodes at a location.
   */
  unsetNodes(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!Array.isArray(props)) {
      props = [props];
    }
    var obj = {};
    for (var key of props) {
      obj[key] = null;
    }
    Transforms.setNodes(editor, obj, options);
  },
  /**
   * Unwrap the nodes at a location from a parent node, splitting the parent if
   * necessary to ensure that only the content in the range is unwrapped.
   */
  unwrapNodes(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = "lowest",
        split: split2 = false,
        voids = false
      } = options;
      var {
        at = editor.selection,
        match: match5
      } = options;
      if (!at) {
        return;
      }
      if (match5 == null) {
        match5 = Path.isPath(at) ? matchPath(editor, at) : (n12) => Editor.isBlock(editor, n12);
      }
      if (Path.isPath(at)) {
        at = Editor.range(editor, at);
      }
      var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;
      var matches = Editor.nodes(editor, {
        at,
        match: match5,
        mode,
        voids
      });
      var pathRefs = Array.from(
        matches,
        (_ref5) => {
          var [, p12] = _ref5;
          return Editor.pathRef(editor, p12);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse();
      var _loop = function _loop2(pathRef2) {
        var path = pathRef2.unref();
        var [node] = Editor.node(editor, path);
        var range = Editor.range(editor, path);
        if (split2 && rangeRef) {
          range = Range.intersection(rangeRef.current, range);
        }
        Transforms.liftNodes(editor, {
          at: range,
          match: (n12) => Element2.isAncestor(node) && node.children.includes(n12),
          voids
        });
      };
      for (var pathRef of pathRefs) {
        _loop(pathRef);
      }
      if (rangeRef) {
        rangeRef.unref();
      }
    });
  },
  /**
   * Wrap the nodes at a location in a new container node, splitting the edges
   * of the range first to ensure that only the content in the range is wrapped.
   */
  wrapNodes(editor, element) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        mode = "lowest",
        split: split2 = false,
        voids = false
      } = options;
      var {
        match: match5,
        at = editor.selection
      } = options;
      if (!at) {
        return;
      }
      if (match5 == null) {
        if (Path.isPath(at)) {
          match5 = matchPath(editor, at);
        } else if (editor.isInline(element)) {
          match5 = (n12) => Editor.isInline(editor, n12) || Text.isText(n12);
        } else {
          match5 = (n12) => Editor.isBlock(editor, n12);
        }
      }
      if (split2 && Range.isRange(at)) {
        var [start3, end2] = Range.edges(at);
        var rangeRef = Editor.rangeRef(editor, at, {
          affinity: "inward"
        });
        Transforms.splitNodes(editor, {
          at: end2,
          match: match5,
          voids
        });
        Transforms.splitNodes(editor, {
          at: start3,
          match: match5,
          voids
        });
        at = rangeRef.unref();
        if (options.at == null) {
          Transforms.select(editor, at);
        }
      }
      var roots = Array.from(Editor.nodes(editor, {
        at,
        match: editor.isInline(element) ? (n12) => Editor.isBlock(editor, n12) : (n12) => Editor.isEditor(n12),
        mode: "lowest",
        voids
      }));
      for (var [, rootPath] of roots) {
        var a13 = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;
        if (!a13) {
          continue;
        }
        var matches = Array.from(Editor.nodes(editor, {
          at: a13,
          match: match5,
          mode,
          voids
        }));
        if (matches.length > 0) {
          var _ret = function() {
            var [first] = matches;
            var last2 = matches[matches.length - 1];
            var [, firstPath] = first;
            var [, lastPath] = last2;
            if (firstPath.length === 0 && lastPath.length === 0) {
              return "continue";
            }
            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);
            var range = Editor.range(editor, firstPath, lastPath);
            var commonNodeEntry = Editor.node(editor, commonPath);
            var [commonNode] = commonNodeEntry;
            var depth = commonPath.length + 1;
            var wrapperPath = Path.next(lastPath.slice(0, depth));
            var wrapper = _objectSpread$2(_objectSpread$2({}, element), {}, {
              children: []
            });
            Transforms.insertNodes(editor, wrapper, {
              at: wrapperPath,
              voids
            });
            Transforms.moveNodes(editor, {
              at: range,
              match: (n12) => Element2.isAncestor(commonNode) && commonNode.children.includes(n12),
              to: wrapperPath.concat(0),
              voids
            });
          }();
          if (_ret === "continue")
            continue;
        }
      }
    });
  }
};
var hasSingleChildNest = (editor, node) => {
  if (Element2.isElement(node)) {
    var element = node;
    if (Editor.isVoid(editor, node)) {
      return true;
    } else if (element.children.length === 1) {
      return hasSingleChildNest(editor, element.children[0]);
    } else {
      return false;
    }
  } else if (Editor.isEditor(node)) {
    return false;
  } else {
    return true;
  }
};
var deleteRange = (editor, range) => {
  if (Range.isCollapsed(range)) {
    return range.anchor;
  } else {
    var [, end2] = Range.edges(range);
    var pointRef = Editor.pointRef(editor, end2);
    Transforms.delete(editor, {
      at: range
    });
    return pointRef.unref();
  }
};
var matchPath = (editor, path) => {
  var [node] = Editor.node(editor, path);
  return (n12) => n12 === node;
};
function ownKeys$1(object2, enumerableOnly) {
  var keys6 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys6.push.apply(keys6, symbols);
  }
  return keys6;
}
function _objectSpread$1(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15] != null ? arguments[i15] : {};
    if (i15 % 2) {
      ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var SelectionTransforms = {
  /**
   * Collapse the selection.
   */
  collapse(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      edge = "anchor"
    } = options;
    var {
      selection
    } = editor;
    if (!selection) {
      return;
    } else if (edge === "anchor") {
      Transforms.select(editor, selection.anchor);
    } else if (edge === "focus") {
      Transforms.select(editor, selection.focus);
    } else if (edge === "start") {
      var [start3] = Range.edges(selection);
      Transforms.select(editor, start3);
    } else if (edge === "end") {
      var [, end2] = Range.edges(selection);
      Transforms.select(editor, end2);
    }
  },
  /**
   * Unset the selection.
   */
  deselect(editor) {
    var {
      selection
    } = editor;
    if (selection) {
      editor.apply({
        type: "set_selection",
        properties: selection,
        newProperties: null
      });
    }
  },
  /**
   * Move the selection's point forward or backward.
   */
  move(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var {
      selection
    } = editor;
    var {
      distance: distance3 = 1,
      unit = "character",
      reverse = false
    } = options;
    var {
      edge = null
    } = options;
    if (!selection) {
      return;
    }
    if (edge === "start") {
      edge = Range.isBackward(selection) ? "focus" : "anchor";
    }
    if (edge === "end") {
      edge = Range.isBackward(selection) ? "anchor" : "focus";
    }
    var {
      anchor,
      focus: focus2
    } = selection;
    var opts = {
      distance: distance3,
      unit
    };
    var props = {};
    if (edge == null || edge === "anchor") {
      var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);
      if (point) {
        props.anchor = point;
      }
    }
    if (edge == null || edge === "focus") {
      var _point = reverse ? Editor.before(editor, focus2, opts) : Editor.after(editor, focus2, opts);
      if (_point) {
        props.focus = _point;
      }
    }
    Transforms.setSelection(editor, props);
  },
  /**
   * Set the selection to a new value.
   */
  select(editor, target) {
    var {
      selection
    } = editor;
    target = Editor.range(editor, target);
    if (selection) {
      Transforms.setSelection(editor, target);
      return;
    }
    if (!Range.isRange(target)) {
      throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(Scrubber.stringify(target)));
    }
    editor.apply({
      type: "set_selection",
      properties: selection,
      newProperties: target
    });
  },
  /**
   * Set new properties on one of the selection's points.
   */
  setPoint(editor, props) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      selection
    } = editor;
    var {
      edge = "both"
    } = options;
    if (!selection) {
      return;
    }
    if (edge === "start") {
      edge = Range.isBackward(selection) ? "focus" : "anchor";
    }
    if (edge === "end") {
      edge = Range.isBackward(selection) ? "anchor" : "focus";
    }
    var {
      anchor,
      focus: focus2
    } = selection;
    var point = edge === "anchor" ? anchor : focus2;
    Transforms.setSelection(editor, {
      [edge === "anchor" ? "anchor" : "focus"]: _objectSpread$1(_objectSpread$1({}, point), props)
    });
  },
  /**
   * Set new properties on the selection.
   */
  setSelection(editor, props) {
    var {
      selection
    } = editor;
    var oldProps = {};
    var newProps = {};
    if (!selection) {
      return;
    }
    for (var k3 in props) {
      if (k3 === "anchor" && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k3 === "focus" && props.focus != null && !Point.equals(props.focus, selection.focus) || k3 !== "anchor" && k3 !== "focus" && props[k3] !== selection[k3]) {
        oldProps[k3] = selection[k3];
        newProps[k3] = props[k3];
      }
    }
    if (Object.keys(oldProps).length > 0) {
      editor.apply({
        type: "set_selection",
        properties: oldProps,
        newProperties: newProps
      });
    }
  }
};
var TextTransforms = {
  /**
   * Delete content in the editor.
   */
  delete(editor) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        reverse = false,
        unit = "character",
        distance: distance3 = 1,
        voids = false
      } = options;
      var {
        at = editor.selection,
        hanging = false
      } = options;
      if (!at) {
        return;
      }
      var isCollapsed2 = false;
      if (Range.isRange(at) && Range.isCollapsed(at)) {
        isCollapsed2 = true;
        at = at.anchor;
      }
      if (Point.isPoint(at)) {
        var furthestVoid = Editor.void(editor, {
          at,
          mode: "highest"
        });
        if (!voids && furthestVoid) {
          var [, voidPath] = furthestVoid;
          at = voidPath;
        } else {
          var opts = {
            unit,
            distance: distance3
          };
          var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);
          at = {
            anchor: at,
            focus: target
          };
          hanging = true;
        }
      }
      if (Path.isPath(at)) {
        Transforms.removeNodes(editor, {
          at,
          voids
        });
        return;
      }
      if (Range.isCollapsed(at)) {
        return;
      }
      if (!hanging) {
        var [, _end] = Range.edges(at);
        var endOfDoc = Editor.end(editor, []);
        if (!Point.equals(_end, endOfDoc)) {
          at = Editor.unhangRange(editor, at, {
            voids
          });
        }
      }
      var [start3, end2] = Range.edges(at);
      var startBlock = Editor.above(editor, {
        match: (n12) => Editor.isBlock(editor, n12),
        at: start3,
        voids
      });
      var endBlock = Editor.above(editor, {
        match: (n12) => Editor.isBlock(editor, n12),
        at: end2,
        voids
      });
      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);
      var isSingleText = Path.equals(start3.path, end2.path);
      var startVoid = voids ? null : Editor.void(editor, {
        at: start3,
        mode: "highest"
      });
      var endVoid = voids ? null : Editor.void(editor, {
        at: end2,
        mode: "highest"
      });
      if (startVoid) {
        var before = Editor.before(editor, start3);
        if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {
          start3 = before;
        }
      }
      if (endVoid) {
        var after = Editor.after(editor, end2);
        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {
          end2 = after;
        }
      }
      var matches = [];
      var lastPath;
      for (var entry of Editor.nodes(editor, {
        at,
        voids
      })) {
        var [node, path] = entry;
        if (lastPath && Path.compare(path, lastPath) === 0) {
          continue;
        }
        if (!voids && Editor.isVoid(editor, node) || !Path.isCommon(path, start3.path) && !Path.isCommon(path, end2.path)) {
          matches.push(entry);
          lastPath = path;
        }
      }
      var pathRefs = Array.from(matches, (_ref) => {
        var [, p12] = _ref;
        return Editor.pathRef(editor, p12);
      });
      var startRef = Editor.pointRef(editor, start3);
      var endRef = Editor.pointRef(editor, end2);
      var removedText = "";
      if (!isSingleText && !startVoid) {
        var _point = startRef.current;
        var [_node] = Editor.leaf(editor, _point);
        var {
          path: _path
        } = _point;
        var {
          offset: offset5
        } = start3;
        var text = _node.text.slice(offset5);
        if (text.length > 0) {
          editor.apply({
            type: "remove_text",
            path: _path,
            offset: offset5,
            text
          });
          removedText = text;
        }
      }
      for (var pathRef of pathRefs) {
        var _path2 = pathRef.unref();
        Transforms.removeNodes(editor, {
          at: _path2,
          voids
        });
      }
      if (!endVoid) {
        var _point2 = endRef.current;
        var [_node2] = Editor.leaf(editor, _point2);
        var {
          path: _path3
        } = _point2;
        var _offset = isSingleText ? start3.offset : 0;
        var _text = _node2.text.slice(_offset, end2.offset);
        if (_text.length > 0) {
          editor.apply({
            type: "remove_text",
            path: _path3,
            offset: _offset,
            text: _text
          });
          removedText = _text;
        }
      }
      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {
        Transforms.mergeNodes(editor, {
          at: endRef.current,
          hanging: true,
          voids
        });
      }
      if (isCollapsed2 && reverse && unit === "character" && removedText.length > 1 && removedText.match(/[\u0E00-\u0E7F]+/)) {
        Transforms.insertText(editor, removedText.slice(0, removedText.length - distance3));
      }
      var startUnref = startRef.unref();
      var endUnref = endRef.unref();
      var point = reverse ? startUnref || endUnref : endUnref || startUnref;
      if (options.at == null && point) {
        Transforms.select(editor, point);
      }
    });
  },
  /**
   * Insert a fragment at a specific location in the editor.
   */
  insertFragment(editor, fragment) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        hanging = false,
        voids = false
      } = options;
      var {
        at = editor.selection
      } = options;
      if (!fragment.length) {
        return;
      }
      if (!at) {
        return;
      } else if (Range.isRange(at)) {
        if (!hanging) {
          at = Editor.unhangRange(editor, at);
        }
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var [, end2] = Range.edges(at);
          if (!voids && Editor.void(editor, {
            at: end2
          })) {
            return;
          }
          var pointRef = Editor.pointRef(editor, end2);
          Transforms.delete(editor, {
            at
          });
          at = pointRef.unref();
        }
      } else if (Path.isPath(at)) {
        at = Editor.start(editor, at);
      }
      if (!voids && Editor.void(editor, {
        at
      })) {
        return;
      }
      var inlineElementMatch = Editor.above(editor, {
        at,
        match: (n12) => Editor.isInline(editor, n12),
        mode: "highest",
        voids
      });
      if (inlineElementMatch) {
        var [, _inlinePath] = inlineElementMatch;
        if (Editor.isEnd(editor, at, _inlinePath)) {
          var after = Editor.after(editor, _inlinePath);
          at = after;
        } else if (Editor.isStart(editor, at, _inlinePath)) {
          var before = Editor.before(editor, _inlinePath);
          at = before;
        }
      }
      var blockMatch = Editor.above(editor, {
        match: (n12) => Editor.isBlock(editor, n12),
        at,
        voids
      });
      var [, blockPath] = blockMatch;
      var isBlockStart = Editor.isStart(editor, at, blockPath);
      var isBlockEnd = Editor.isEnd(editor, at, blockPath);
      var isBlockEmpty = isBlockStart && isBlockEnd;
      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;
      var mergeEnd = !isBlockEnd;
      var [, firstPath] = Node2.first({
        children: fragment
      }, []);
      var [, lastPath] = Node2.last({
        children: fragment
      }, []);
      var matches = [];
      var matcher = (_ref2) => {
        var [n12, p12] = _ref2;
        var isRoot = p12.length === 0;
        if (isRoot) {
          return false;
        }
        if (isBlockEmpty) {
          return true;
        }
        if (mergeStart && Path.isAncestor(p12, firstPath) && Element2.isElement(n12) && !editor.isVoid(n12) && !editor.isInline(n12)) {
          return false;
        }
        if (mergeEnd && Path.isAncestor(p12, lastPath) && Element2.isElement(n12) && !editor.isVoid(n12) && !editor.isInline(n12)) {
          return false;
        }
        return true;
      };
      for (var entry of Node2.nodes({
        children: fragment
      }, {
        pass: matcher
      })) {
        if (matcher(entry)) {
          matches.push(entry);
        }
      }
      var starts = [];
      var middles = [];
      var ends = [];
      var starting = true;
      var hasBlocks = false;
      for (var [node] of matches) {
        if (Element2.isElement(node) && !editor.isInline(node)) {
          starting = false;
          hasBlocks = true;
          middles.push(node);
        } else if (starting) {
          starts.push(node);
        } else {
          ends.push(node);
        }
      }
      var [inlineMatch] = Editor.nodes(editor, {
        at,
        match: (n12) => Text.isText(n12) || Editor.isInline(editor, n12),
        mode: "highest",
        voids
      });
      var [, inlinePath] = inlineMatch;
      var isInlineStart = Editor.isStart(editor, at, inlinePath);
      var isInlineEnd = Editor.isEnd(editor, at, inlinePath);
      var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);
      var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);
      Transforms.splitNodes(editor, {
        at,
        match: (n12) => hasBlocks ? Editor.isBlock(editor, n12) : Text.isText(n12) || Editor.isInline(editor, n12),
        mode: hasBlocks ? "lowest" : "highest",
        always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),
        voids
      });
      var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);
      Transforms.insertNodes(editor, starts, {
        at: startRef.current,
        match: (n12) => Text.isText(n12) || Editor.isInline(editor, n12),
        mode: "highest",
        voids
      });
      if (isBlockEmpty && !starts.length && middles.length && !ends.length) {
        Transforms.delete(editor, {
          at: blockPath,
          voids
        });
      }
      Transforms.insertNodes(editor, middles, {
        at: middleRef.current,
        match: (n12) => Editor.isBlock(editor, n12),
        mode: "lowest",
        voids
      });
      Transforms.insertNodes(editor, ends, {
        at: endRef.current,
        match: (n12) => Text.isText(n12) || Editor.isInline(editor, n12),
        mode: "highest",
        voids
      });
      if (!options.at) {
        var path;
        if (ends.length > 0 && endRef.current) {
          path = Path.previous(endRef.current);
        } else if (middles.length > 0 && middleRef.current) {
          path = Path.previous(middleRef.current);
        } else if (startRef.current) {
          path = Path.previous(startRef.current);
        }
        if (path) {
          var _end2 = Editor.end(editor, path);
          Transforms.select(editor, _end2);
        }
      }
      startRef.unref();
      middleRef.unref();
      endRef.unref();
    });
  },
  /**
   * Insert a string of text in the Editor.
   */
  insertText(editor, text) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Editor.withoutNormalizing(editor, () => {
      var {
        voids = false
      } = options;
      var {
        at = editor.selection
      } = options;
      if (!at) {
        return;
      }
      if (Path.isPath(at)) {
        at = Editor.range(editor, at);
      }
      if (Range.isRange(at)) {
        if (Range.isCollapsed(at)) {
          at = at.anchor;
        } else {
          var end2 = Range.end(at);
          if (!voids && Editor.void(editor, {
            at: end2
          })) {
            return;
          }
          var start3 = Range.start(at);
          var startRef = Editor.pointRef(editor, start3);
          var endRef = Editor.pointRef(editor, end2);
          Transforms.delete(editor, {
            at,
            voids
          });
          var startPoint = startRef.unref();
          var endPoint = endRef.unref();
          at = startPoint || endPoint;
          Transforms.setSelection(editor, {
            anchor: at,
            focus: at
          });
        }
      }
      if (!voids && Editor.void(editor, {
        at
      })) {
        return;
      }
      var {
        path,
        offset: offset5
      } = at;
      if (text.length > 0)
        editor.apply({
          type: "insert_text",
          path,
          offset: offset5,
          text
        });
    });
  }
};
function ownKeys(object2, enumerableOnly) {
  var keys6 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys6.push.apply(keys6, symbols);
  }
  return keys6;
}
function _objectSpread(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15] != null ? arguments[i15] : {};
    if (i15 % 2) {
      ownKeys(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Transforms = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);

// node_modules/slate-react/dist/index.es.js
var import_direction = __toESM(require_direction());
var import_debounce = __toESM(require_debounce());
var import_throttle = __toESM(require_throttle());

// node_modules/compute-scroll-into-view/dist/index.mjs
function t2(t20) {
  return "object" == typeof t20 && null != t20 && 1 === t20.nodeType;
}
function e(t20, e9) {
  return (!e9 || "hidden" !== t20) && "visible" !== t20 && "clip" !== t20;
}
function n2(t20, n12) {
  if (t20.clientHeight < t20.scrollHeight || t20.clientWidth < t20.scrollWidth) {
    var r15 = getComputedStyle(t20, null);
    return e(r15.overflowY, n12) || e(r15.overflowX, n12) || function(t21) {
      var e9 = function(t22) {
        if (!t22.ownerDocument || !t22.ownerDocument.defaultView)
          return null;
        try {
          return t22.ownerDocument.defaultView.frameElement;
        } catch (t23) {
          return null;
        }
      }(t21);
      return !!e9 && (e9.clientHeight < t21.scrollHeight || e9.clientWidth < t21.scrollWidth);
    }(t20);
  }
  return false;
}
function r2(t20, e9, n12, r15, i15, o16, l14, d17) {
  return o16 < t20 && l14 > e9 || o16 > t20 && l14 < e9 ? 0 : o16 <= t20 && d17 <= n12 || l14 >= e9 && d17 >= n12 ? o16 - t20 - r15 : l14 > e9 && d17 < n12 || o16 < t20 && d17 > n12 ? l14 - e9 + i15 : 0;
}
var i2 = function(e9, i15) {
  var o16 = window, l14 = i15.scrollMode, d17 = i15.block, f16 = i15.inline, h11 = i15.boundary, u11 = i15.skipOverflowHiddenElements, s20 = "function" == typeof h11 ? h11 : function(t20) {
    return t20 !== h11;
  };
  if (!t2(e9))
    throw new TypeError("Invalid target");
  for (var a13, c16, g6 = document.scrollingElement || document.documentElement, p12 = [], m10 = e9; t2(m10) && s20(m10); ) {
    if ((m10 = null == (c16 = (a13 = m10).parentElement) ? a13.getRootNode().host || null : c16) === g6) {
      p12.push(m10);
      break;
    }
    null != m10 && m10 === document.body && n2(m10) && !n2(document.documentElement) || null != m10 && n2(m10, u11) && p12.push(m10);
  }
  for (var w7 = o16.visualViewport ? o16.visualViewport.width : innerWidth, v6 = o16.visualViewport ? o16.visualViewport.height : innerHeight, W2 = window.scrollX || pageXOffset, H9 = window.scrollY || pageYOffset, b6 = e9.getBoundingClientRect(), y9 = b6.height, E8 = b6.width, M10 = b6.top, V7 = b6.right, x7 = b6.bottom, I9 = b6.left, C5 = "start" === d17 || "nearest" === d17 ? M10 : "end" === d17 ? x7 : M10 + y9 / 2, R4 = "center" === f16 ? I9 + E8 / 2 : "end" === f16 ? V7 : I9, T7 = [], k3 = 0; k3 < p12.length; k3++) {
    var B5 = p12[k3], D9 = B5.getBoundingClientRect(), O5 = D9.height, X10 = D9.width, Y8 = D9.top, L6 = D9.right, S11 = D9.bottom, j6 = D9.left;
    if ("if-needed" === l14 && M10 >= 0 && I9 >= 0 && x7 <= v6 && V7 <= w7 && M10 >= Y8 && x7 <= S11 && I9 >= j6 && V7 <= L6)
      return T7;
    var N6 = getComputedStyle(B5), q7 = parseInt(N6.borderLeftWidth, 10), z7 = parseInt(N6.borderTopWidth, 10), A8 = parseInt(N6.borderRightWidth, 10), F9 = parseInt(N6.borderBottomWidth, 10), G5 = 0, J4 = 0, K4 = "offsetWidth" in B5 ? B5.offsetWidth - B5.clientWidth - q7 - A8 : 0, P6 = "offsetHeight" in B5 ? B5.offsetHeight - B5.clientHeight - z7 - F9 : 0, Q7 = "offsetWidth" in B5 ? 0 === B5.offsetWidth ? 0 : X10 / B5.offsetWidth : 0, U6 = "offsetHeight" in B5 ? 0 === B5.offsetHeight ? 0 : O5 / B5.offsetHeight : 0;
    if (g6 === B5)
      G5 = "start" === d17 ? C5 : "end" === d17 ? C5 - v6 : "nearest" === d17 ? r2(H9, H9 + v6, v6, z7, F9, H9 + C5, H9 + C5 + y9, y9) : C5 - v6 / 2, J4 = "start" === f16 ? R4 : "center" === f16 ? R4 - w7 / 2 : "end" === f16 ? R4 - w7 : r2(W2, W2 + w7, w7, q7, A8, W2 + R4, W2 + R4 + E8, E8), G5 = Math.max(0, G5 + H9), J4 = Math.max(0, J4 + W2);
    else {
      G5 = "start" === d17 ? C5 - Y8 - z7 : "end" === d17 ? C5 - S11 + F9 + P6 : "nearest" === d17 ? r2(Y8, S11, O5, z7, F9 + P6, C5, C5 + y9, y9) : C5 - (Y8 + O5 / 2) + P6 / 2, J4 = "start" === f16 ? R4 - j6 - q7 : "center" === f16 ? R4 - (j6 + X10 / 2) + K4 / 2 : "end" === f16 ? R4 - L6 + A8 + K4 : r2(j6, L6, X10, q7, A8 + K4, R4, R4 + E8, E8);
      var Z7 = B5.scrollLeft, $7 = B5.scrollTop;
      C5 += $7 - (G5 = Math.max(0, Math.min($7 + G5 / U6, B5.scrollHeight - O5 / U6 + P6))), R4 += Z7 - (J4 = Math.max(0, Math.min(Z7 + J4 / Q7, B5.scrollWidth - X10 / Q7 + K4)));
    }
    T7.push({ el: B5, top: G5, left: J4 });
  }
  return T7;
};

// node_modules/scroll-into-view-if-needed/es/index.js
function isOptionsObject(options) {
  return options === Object(options) && Object.keys(options).length !== 0;
}
function defaultBehavior(actions, behavior) {
  if (behavior === void 0) {
    behavior = "auto";
  }
  var canSmoothScroll = "scrollBehavior" in document.body.style;
  actions.forEach(function(_ref) {
    var el = _ref.el, top = _ref.top, left = _ref.left;
    if (el.scroll && canSmoothScroll) {
      el.scroll({
        top,
        left,
        behavior
      });
    } else {
      el.scrollTop = top;
      el.scrollLeft = left;
    }
  });
}
function getOptions(options) {
  if (options === false) {
    return {
      block: "end",
      inline: "nearest"
    };
  }
  if (isOptionsObject(options)) {
    return options;
  }
  return {
    block: "start",
    inline: "nearest"
  };
}
function scrollIntoView(target, options) {
  var isTargetAttached = target.isConnected || target.ownerDocument.documentElement.contains(target);
  if (isOptionsObject(options) && typeof options.behavior === "function") {
    return options.behavior(isTargetAttached ? i2(target, options) : []);
  }
  if (!isTargetAttached) {
    return;
  }
  var computeOptions = getOptions(options);
  return defaultBehavior(i2(target, computeOptions), computeOptions.behavior);
}
var es_default = scrollIntoView;

// node_modules/slate-react/dist/index.es.js
var import_is_hotkey = __toESM(require_lib());
var import_react_dom = __toESM(require_react_dom());
function _defineProperty2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutPropertiesLoose3(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i15;
  for (i15 = 0; i15 < sourceKeys.length; i15++) {
    key = sourceKeys[i15];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _objectWithoutProperties2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose3(source, excluded);
  var key, i15;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i15 = 0; i15 < sourceSymbolKeys.length; i15++) {
      key = sourceSymbolKeys[i15];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
var IS_REACT_VERSION_17_OR_ABOVE = parseInt(import_react2.default.version.split(".")[0], 10) >= 17;
var IS_IOS = typeof navigator !== "undefined" && typeof window !== "undefined" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
var IS_APPLE = typeof navigator !== "undefined" && /Mac OS X/.test(navigator.userAgent);
var IS_ANDROID = typeof navigator !== "undefined" && /Android/.test(navigator.userAgent);
var IS_FIREFOX = typeof navigator !== "undefined" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent);
var IS_SAFARI = typeof navigator !== "undefined" && /Version\/[\d\.]+.*Safari/.test(navigator.userAgent);
var IS_EDGE_LEGACY = typeof navigator !== "undefined" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent);
var IS_CHROME = typeof navigator !== "undefined" && /Chrome/i.test(navigator.userAgent);
var IS_CHROME_LEGACY = typeof navigator !== "undefined" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent);
var IS_FIREFOX_LEGACY = typeof navigator !== "undefined" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent);
var IS_QQBROWSER = typeof navigator !== "undefined" && /.*QQBrowser/.test(navigator.userAgent);
var IS_UC_MOBILE = typeof navigator !== "undefined" && /.*UCBrowser/.test(navigator.userAgent);
var IS_WECHATBROWSER = typeof navigator !== "undefined" && /.*Wechat/.test(navigator.userAgent);
var CAN_USE_DOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var HAS_BEFORE_INPUT_SUPPORT = !IS_CHROME_LEGACY && !IS_EDGE_LEGACY && // globalThis is undefined in older browsers
typeof globalThis !== "undefined" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges === "function";
var useIsomorphicLayoutEffect = CAN_USE_DOM ? import_react2.useLayoutEffect : import_react2.useEffect;
var String2 = (props) => {
  var {
    isLast,
    leaf,
    parent: parent2,
    text
  } = props;
  var editor = useSlateStatic();
  var path = ReactEditor.findPath(editor, text);
  var parentPath = Path.parent(path);
  if (editor.isVoid(parent2)) {
    return import_react2.default.createElement(ZeroWidthString, {
      length: Node2.string(parent2).length
    });
  }
  if (leaf.text === "" && parent2.children[parent2.children.length - 1] === text && !editor.isInline(parent2) && Editor.string(editor, parentPath) === "") {
    return import_react2.default.createElement(ZeroWidthString, {
      isLineBreak: true
    });
  }
  if (leaf.text === "") {
    return import_react2.default.createElement(ZeroWidthString, null);
  }
  if (isLast && leaf.text.slice(-1) === "\n") {
    return import_react2.default.createElement(TextString, {
      isTrailing: true,
      text: leaf.text
    });
  }
  return import_react2.default.createElement(TextString, {
    text: leaf.text
  });
};
var TextString = (props) => {
  var {
    text,
    isTrailing = false
  } = props;
  var ref2 = (0, import_react2.useRef)(null);
  var getTextContent = () => {
    return "".concat(text !== null && text !== void 0 ? text : "").concat(isTrailing ? "\n" : "");
  };
  useIsomorphicLayoutEffect(() => {
    var textWithTrailing = getTextContent();
    if (ref2.current && ref2.current.textContent !== textWithTrailing) {
      ref2.current.textContent = textWithTrailing;
    }
  });
  if (!ref2.current) {
    return import_react2.default.createElement("span", {
      "data-slate-string": true,
      ref: ref2
    }, getTextContent());
  }
  return import_react2.default.createElement("span", {
    "data-slate-string": true,
    ref: ref2
  });
};
var ZeroWidthString = (props) => {
  var {
    length = 0,
    isLineBreak: isLineBreak2 = false
  } = props;
  return import_react2.default.createElement("span", {
    "data-slate-zero-width": isLineBreak2 ? "n" : "z",
    "data-slate-length": length
  }, "\uFEFF", isLineBreak2 ? import_react2.default.createElement("br", null) : null);
};
var NODE_TO_INDEX = /* @__PURE__ */ new WeakMap();
var NODE_TO_PARENT = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_WINDOW = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_ELEMENT = /* @__PURE__ */ new WeakMap();
var ELEMENT_TO_NODE = /* @__PURE__ */ new WeakMap();
var NODE_TO_ELEMENT = /* @__PURE__ */ new WeakMap();
var NODE_TO_KEY = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_KEY_TO_ELEMENT = /* @__PURE__ */ new WeakMap();
var IS_READ_ONLY = /* @__PURE__ */ new WeakMap();
var IS_FOCUSED = /* @__PURE__ */ new WeakMap();
var IS_COMPOSING = /* @__PURE__ */ new WeakMap();
var IS_ON_COMPOSITION_END = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_USER_SELECTION = /* @__PURE__ */ new WeakMap();
var EDITOR_ON_COMPOSITION_TEXT = /* @__PURE__ */ new WeakMap();
var EDITOR_TO_ON_CHANGE = /* @__PURE__ */ new WeakMap();
var NODE_TO_RESTORE_DOM = /* @__PURE__ */ new WeakMap();
var PLACEHOLDER_SYMBOL = Symbol("placeholder");
var Leaf = (props) => {
  var {
    leaf,
    isLast,
    text,
    parent: parent2,
    renderPlaceholder,
    renderLeaf = (props2) => import_react2.default.createElement(DefaultLeaf, Object.assign({}, props2))
  } = props;
  var placeholderRef = (0, import_react2.useRef)(null);
  (0, import_react2.useEffect)(() => {
    var placeholderEl = placeholderRef === null || placeholderRef === void 0 ? void 0 : placeholderRef.current;
    var editorEl = document.querySelector('[data-slate-editor="true"]');
    if (!placeholderEl || !editorEl) {
      return;
    }
    editorEl.style.minHeight = "".concat(placeholderEl.clientHeight, "px");
    return () => {
      editorEl.style.minHeight = "auto";
    };
  }, [placeholderRef, leaf]);
  var children = import_react2.default.createElement(String2, {
    isLast,
    leaf,
    parent: parent2,
    text
  });
  if (leaf[PLACEHOLDER_SYMBOL]) {
    var placeholderProps = {
      children: leaf.placeholder,
      attributes: {
        "data-slate-placeholder": true,
        style: {
          position: "absolute",
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none"
        },
        contentEditable: false,
        ref: placeholderRef
      }
    };
    children = import_react2.default.createElement(import_react2.default.Fragment, null, renderPlaceholder(placeholderProps), children);
  }
  var attributes = {
    "data-slate-leaf": true
  };
  return renderLeaf({
    attributes,
    children,
    leaf,
    text
  });
};
var MemoizedLeaf = import_react2.default.memo(Leaf, (prev, next) => {
  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.renderPlaceholder === prev.renderPlaceholder && next.text === prev.text && Text.equals(next.leaf, prev.leaf) && next.leaf[PLACEHOLDER_SYMBOL] === prev.leaf[PLACEHOLDER_SYMBOL];
});
var DefaultLeaf = (props) => {
  var {
    attributes,
    children
  } = props;
  return import_react2.default.createElement("span", Object.assign({}, attributes), children);
};
var _excluded$32 = ["anchor", "focus"];
var _excluded22 = ["anchor", "focus"];
var shallowCompare = (obj1, obj2) => Object.keys(obj1).length === Object.keys(obj2).length && Object.keys(obj1).every((key) => obj2.hasOwnProperty(key) && obj1[key] === obj2[key]);
var isDecoratorRangeListEqual = (list, another) => {
  if (list.length !== another.length) {
    return false;
  }
  for (var i15 = 0; i15 < list.length; i15++) {
    var range = list[i15];
    var other = another[i15];
    var rangeOwnProps = _objectWithoutProperties2(range, _excluded$32);
    var otherOwnProps = _objectWithoutProperties2(other, _excluded22);
    if (!Range.equals(range, other) || range[PLACEHOLDER_SYMBOL] !== other[PLACEHOLDER_SYMBOL] || !shallowCompare(rangeOwnProps, otherOwnProps)) {
      return false;
    }
  }
  return true;
};
function useContentKey(node) {
  var contentKeyRef = (0, import_react2.useRef)(0);
  var updateAnimationFrameRef = (0, import_react2.useRef)(null);
  var [, setForceRerenderCounter] = (0, import_react2.useState)(0);
  (0, import_react2.useEffect)(() => {
    NODE_TO_RESTORE_DOM.set(node, () => {
      if (updateAnimationFrameRef.current) {
        return;
      }
      updateAnimationFrameRef.current = requestAnimationFrame(() => {
        setForceRerenderCounter((state) => state + 1);
        updateAnimationFrameRef.current = null;
      });
      contentKeyRef.current++;
    });
    return () => {
      NODE_TO_RESTORE_DOM.delete(node);
    };
  }, [node]);
  if (updateAnimationFrameRef.current) {
    cancelAnimationFrame(updateAnimationFrameRef.current);
    updateAnimationFrameRef.current = null;
  }
  return contentKeyRef.current;
}
var Text2 = (props) => {
  var {
    decorations,
    isLast,
    parent: parent2,
    renderPlaceholder,
    renderLeaf,
    text
  } = props;
  var editor = useSlateStatic();
  var ref2 = (0, import_react2.useRef)(null);
  var leaves = Text.decorations(text, decorations);
  var key = ReactEditor.findKey(editor, text);
  var children = [];
  for (var i15 = 0; i15 < leaves.length; i15++) {
    var leaf = leaves[i15];
    children.push(import_react2.default.createElement(MemoizedLeaf, {
      isLast: isLast && i15 === leaves.length - 1,
      key: "".concat(key.id, "-").concat(i15),
      renderPlaceholder,
      leaf,
      text,
      parent: parent2,
      renderLeaf
    }));
  }
  useIsomorphicLayoutEffect(() => {
    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
    if (ref2.current) {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref2.current);
      NODE_TO_ELEMENT.set(text, ref2.current);
      ELEMENT_TO_NODE.set(ref2.current, text);
    } else {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);
      NODE_TO_ELEMENT.delete(text);
    }
  });
  var contentKey = IS_ANDROID ? useContentKey(text) : void 0;
  return import_react2.default.createElement("span", {
    "data-slate-node": "text",
    ref: ref2,
    key: contentKey
  }, children);
};
var MemoizedText = import_react2.default.memo(Text2, (prev, next) => {
  return next.parent === prev.parent && next.isLast === prev.isLast && next.renderLeaf === prev.renderLeaf && next.text === prev.text && isDecoratorRangeListEqual(next.decorations, prev.decorations);
});
var Element3 = (props) => {
  var {
    decorations,
    element,
    renderElement = (p12) => import_react2.default.createElement(DefaultElement, Object.assign({}, p12)),
    renderPlaceholder,
    renderLeaf,
    selection
  } = props;
  var ref2 = (0, import_react2.useRef)(null);
  var editor = useSlateStatic();
  var readOnly = useReadOnly();
  var isInline2 = editor.isInline(element);
  var key = ReactEditor.findKey(editor, element);
  var children = useChildren({
    decorations,
    node: element,
    renderElement,
    renderPlaceholder,
    renderLeaf,
    selection
  });
  var attributes = {
    "data-slate-node": "element",
    ref: ref2
  };
  if (isInline2) {
    attributes["data-slate-inline"] = true;
  }
  if (!isInline2 && Editor.hasInlines(editor, element)) {
    var text = Node2.string(element);
    var dir = (0, import_direction.default)(text);
    if (dir === "rtl") {
      attributes.dir = dir;
    }
  }
  if (Editor.isVoid(editor, element)) {
    attributes["data-slate-void"] = true;
    if (!readOnly && isInline2) {
      attributes.contentEditable = false;
    }
    var Tag2 = isInline2 ? "span" : "div";
    var [[_text]] = Node2.texts(element);
    children = import_react2.default.createElement(Tag2, {
      "data-slate-spacer": true,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, import_react2.default.createElement(MemoizedText, {
      renderPlaceholder,
      decorations: [],
      isLast: false,
      parent: element,
      text: _text
    }));
    NODE_TO_INDEX.set(_text, 0);
    NODE_TO_PARENT.set(_text, element);
  }
  useIsomorphicLayoutEffect(() => {
    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
    if (ref2.current) {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.set(key, ref2.current);
      NODE_TO_ELEMENT.set(element, ref2.current);
      ELEMENT_TO_NODE.set(ref2.current, element);
    } else {
      KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.delete(key);
      NODE_TO_ELEMENT.delete(element);
    }
  });
  var content = renderElement({
    attributes,
    children,
    element
  });
  if (IS_ANDROID) {
    var contentKey = useContentKey(element);
    return import_react2.default.createElement(import_react2.Fragment, {
      key: contentKey
    }, content);
  }
  return content;
};
var MemoizedElement = import_react2.default.memo(Element3, (prev, next) => {
  return prev.element === next.element && prev.renderElement === next.renderElement && prev.renderLeaf === next.renderLeaf && isDecoratorRangeListEqual(prev.decorations, next.decorations) && (prev.selection === next.selection || !!prev.selection && !!next.selection && Range.equals(prev.selection, next.selection));
});
var DefaultElement = (props) => {
  var {
    attributes,
    children,
    element
  } = props;
  var editor = useSlateStatic();
  var Tag2 = editor.isInline(element) ? "span" : "div";
  return import_react2.default.createElement(Tag2, Object.assign({}, attributes, {
    style: {
      position: "relative"
    }
  }), children);
};
var EditorContext = (0, import_react2.createContext)(null);
var useSlateStatic = () => {
  var editor = (0, import_react2.useContext)(EditorContext);
  if (!editor) {
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  }
  return editor;
};
var DecorateContext = (0, import_react2.createContext)(() => []);
var useDecorate = () => {
  return (0, import_react2.useContext)(DecorateContext);
};
var SelectedContext = (0, import_react2.createContext)(false);
var useSelected = () => {
  return (0, import_react2.useContext)(SelectedContext);
};
var useChildren = (props) => {
  var {
    decorations,
    node,
    renderElement,
    renderPlaceholder,
    renderLeaf,
    selection
  } = props;
  var decorate = useDecorate();
  var editor = useSlateStatic();
  var path = ReactEditor.findPath(editor, node);
  var children = [];
  var isLeafBlock = Element2.isElement(node) && !editor.isInline(node) && Editor.hasInlines(editor, node);
  for (var i15 = 0; i15 < node.children.length; i15++) {
    var p12 = path.concat(i15);
    var n12 = node.children[i15];
    var key = ReactEditor.findKey(editor, n12);
    var range = Editor.range(editor, p12);
    var sel = selection && Range.intersection(range, selection);
    var ds = decorate([n12, p12]);
    for (var dec of decorations) {
      var d17 = Range.intersection(dec, range);
      if (d17) {
        ds.push(d17);
      }
    }
    if (Element2.isElement(n12)) {
      children.push(import_react2.default.createElement(SelectedContext.Provider, {
        key: "provider-".concat(key.id),
        value: !!sel
      }, import_react2.default.createElement(MemoizedElement, {
        decorations: ds,
        element: n12,
        key: key.id,
        renderElement,
        renderPlaceholder,
        renderLeaf,
        selection: sel
      })));
    } else {
      children.push(import_react2.default.createElement(MemoizedText, {
        decorations: ds,
        key: key.id,
        isLast: isLeafBlock && i15 === node.children.length - 1,
        parent: node,
        renderPlaceholder,
        renderLeaf,
        text: n12
      }));
    }
    NODE_TO_INDEX.set(n12, i15);
    NODE_TO_PARENT.set(n12, node);
  }
  return children;
};
var HOTKEYS = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
};
var APPLE_HOTKEYS = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
};
var WINDOWS_HOTKEYS = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
};
var create = (key) => {
  var generic = HOTKEYS[key];
  var apple = APPLE_HOTKEYS[key];
  var windows = WINDOWS_HOTKEYS[key];
  var isGeneric = generic && (0, import_is_hotkey.isKeyHotkey)(generic);
  var isApple = apple && (0, import_is_hotkey.isKeyHotkey)(apple);
  var isWindows = windows && (0, import_is_hotkey.isKeyHotkey)(windows);
  return (event) => {
    if (isGeneric && isGeneric(event))
      return true;
    if (IS_APPLE && isApple && isApple(event))
      return true;
    if (!IS_APPLE && isWindows && isWindows(event))
      return true;
    return false;
  };
};
var Hotkeys = {
  isBold: create("bold"),
  isCompose: create("compose"),
  isMoveBackward: create("moveBackward"),
  isMoveForward: create("moveForward"),
  isDeleteBackward: create("deleteBackward"),
  isDeleteForward: create("deleteForward"),
  isDeleteLineBackward: create("deleteLineBackward"),
  isDeleteLineForward: create("deleteLineForward"),
  isDeleteWordBackward: create("deleteWordBackward"),
  isDeleteWordForward: create("deleteWordForward"),
  isExtendBackward: create("extendBackward"),
  isExtendForward: create("extendForward"),
  isExtendLineBackward: create("extendLineBackward"),
  isExtendLineForward: create("extendLineForward"),
  isItalic: create("italic"),
  isMoveLineBackward: create("moveLineBackward"),
  isMoveLineForward: create("moveLineForward"),
  isMoveWordBackward: create("moveWordBackward"),
  isMoveWordForward: create("moveWordForward"),
  isRedo: create("redo"),
  isSoftBreak: create("insertSoftBreak"),
  isSplitBlock: create("splitBlock"),
  isTransposeCharacter: create("transposeCharacter"),
  isUndo: create("undo")
};
var ReadOnlyContext = (0, import_react2.createContext)(false);
var useReadOnly = () => {
  return (0, import_react2.useContext)(ReadOnlyContext);
};
var SlateContext = (0, import_react2.createContext)(null);
var useSlate = () => {
  var context = (0, import_react2.useContext)(SlateContext);
  if (!context) {
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  }
  var [editor] = context;
  return editor;
};
var getDefaultView = (value) => {
  return value && value.ownerDocument && value.ownerDocument.defaultView || null;
};
var isDOMComment = (value) => {
  return isDOMNode(value) && value.nodeType === 8;
};
var isDOMElement = (value) => {
  return isDOMNode(value) && value.nodeType === 1;
};
var isDOMNode = (value) => {
  var window2 = getDefaultView(value);
  return !!window2 && value instanceof window2.Node;
};
var isDOMSelection = (value) => {
  var window2 = value && value.anchorNode && getDefaultView(value.anchorNode);
  return !!window2 && value instanceof window2.Selection;
};
var isDOMText = (value) => {
  return isDOMNode(value) && value.nodeType === 3;
};
var isPlainTextOnlyPaste = (event) => {
  return event.clipboardData && event.clipboardData.getData("text/plain") !== "" && event.clipboardData.types.length === 1;
};
var normalizeDOMPoint = (domPoint) => {
  var [node, offset5] = domPoint;
  if (isDOMElement(node) && node.childNodes.length) {
    var isLast = offset5 === node.childNodes.length;
    var index2 = isLast ? offset5 - 1 : offset5;
    [node, index2] = getEditableChildAndIndex(node, index2, isLast ? "backward" : "forward");
    isLast = index2 < offset5;
    while (isDOMElement(node) && node.childNodes.length) {
      var i15 = isLast ? node.childNodes.length - 1 : 0;
      node = getEditableChild(node, i15, isLast ? "backward" : "forward");
    }
    offset5 = isLast && node.textContent != null ? node.textContent.length : 0;
  }
  return [node, offset5];
};
var hasShadowRoot = () => {
  return !!(window.document.activeElement && window.document.activeElement.shadowRoot);
};
var getEditableChildAndIndex = (parent2, index2, direction) => {
  var {
    childNodes
  } = parent2;
  var child = childNodes[index2];
  var i15 = index2;
  var triedForward = false;
  var triedBackward = false;
  while (isDOMComment(child) || isDOMElement(child) && child.childNodes.length === 0 || isDOMElement(child) && child.getAttribute("contenteditable") === "false") {
    if (triedForward && triedBackward) {
      break;
    }
    if (i15 >= childNodes.length) {
      triedForward = true;
      i15 = index2 - 1;
      direction = "backward";
      continue;
    }
    if (i15 < 0) {
      triedBackward = true;
      i15 = index2 + 1;
      direction = "forward";
      continue;
    }
    child = childNodes[i15];
    index2 = i15;
    i15 += direction === "forward" ? 1 : -1;
  }
  return [child, index2];
};
var getEditableChild = (parent2, index2, direction) => {
  var [child] = getEditableChildAndIndex(parent2, index2, direction);
  return child;
};
var getPlainText = (domNode) => {
  var text = "";
  if (isDOMText(domNode) && domNode.nodeValue) {
    return domNode.nodeValue;
  }
  if (isDOMElement(domNode)) {
    for (var childNode of Array.from(domNode.childNodes)) {
      text += getPlainText(childNode);
    }
    var display = getComputedStyle(domNode).getPropertyValue("display");
    if (display === "block" || display === "list" || domNode.tagName === "BR") {
      text += "\n";
    }
  }
  return text;
};
var catchSlateFragment = /data-slate-fragment="(.+?)"/m;
var getSlateFragmentAttribute = (dataTransfer) => {
  var htmlData = dataTransfer.getData("text/html");
  var [, fragment] = htmlData.match(catchSlateFragment) || [];
  return fragment;
};
var getClipboardData = (dataTransfer) => {
  if (!dataTransfer.getData("application/x-slate-fragment")) {
    var fragment = getSlateFragmentAttribute(dataTransfer);
    if (fragment) {
      var clipboardData = new DataTransfer();
      dataTransfer.types.forEach((type) => {
        clipboardData.setData(type, dataTransfer.getData(type));
      });
      clipboardData.setData("application/x-slate-fragment", fragment);
      return clipboardData;
    }
  }
  return dataTransfer;
};
var TRIPLE_CLICK = 3;
var _excluded$22 = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as"];
function ownKeys$12(object2, enumerableOnly) {
  var keys6 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys6.push.apply(keys6, symbols);
  }
  return keys6;
}
function _objectSpread$12(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15] != null ? arguments[i15] : {};
    if (i15 % 2) {
      ownKeys$12(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$12(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var Children = (props) => import_react2.default.createElement(import_react2.default.Fragment, null, useChildren(props));
var Editable$1 = (props) => {
  var {
    autoFocus,
    decorate = defaultDecorate,
    onDOMBeforeInput: propsOnDOMBeforeInput,
    placeholder: placeholder2,
    readOnly = false,
    renderElement,
    renderLeaf,
    renderPlaceholder = (props2) => import_react2.default.createElement(DefaultPlaceholder, Object.assign({}, props2)),
    scrollSelectionIntoView = defaultScrollSelectionIntoView,
    style: style2 = {},
    as: Component9 = "div"
  } = props, attributes = _objectWithoutProperties2(props, _excluded$22);
  var editor = useSlate();
  var [isComposing2, setIsComposing] = (0, import_react2.useState)(false);
  var ref2 = (0, import_react2.useRef)(null);
  var deferredOperations = (0, import_react2.useRef)([]);
  IS_READ_ONLY.set(editor, readOnly);
  var state = (0, import_react2.useMemo)(() => ({
    hasInsertPrefixInCompositon: false,
    isDraggingInternally: false,
    isUpdatingSelection: false,
    latestElement: null
  }), []);
  useIsomorphicLayoutEffect(() => {
    var window2;
    if (ref2.current && (window2 = getDefaultView(ref2.current))) {
      EDITOR_TO_WINDOW.set(editor, window2);
      EDITOR_TO_ELEMENT.set(editor, ref2.current);
      NODE_TO_ELEMENT.set(editor, ref2.current);
      ELEMENT_TO_NODE.set(ref2.current, editor);
    } else {
      NODE_TO_ELEMENT.delete(editor);
    }
    var {
      selection
    } = editor;
    var root6 = ReactEditor.findDocumentOrShadowRoot(editor);
    var domSelection = root6.getSelection();
    if (ReactEditor.isComposing(editor) || !domSelection || !ReactEditor.isFocused(editor)) {
      return;
    }
    var hasDomSelection = domSelection.type !== "None";
    if (!selection && !hasDomSelection) {
      return;
    }
    var editorElement = EDITOR_TO_ELEMENT.get(editor);
    var hasDomSelectionInEditor = false;
    if (editorElement.contains(domSelection.anchorNode) && editorElement.contains(domSelection.focusNode)) {
      hasDomSelectionInEditor = true;
    }
    if (hasDomSelection && hasDomSelectionInEditor && selection) {
      var slateRange = ReactEditor.toSlateRange(editor, domSelection, {
        exactMatch: true,
        // domSelection is not necessarily a valid Slate range
        // (e.g. when clicking on contentEditable:false element)
        suppressThrow: true
      });
      if (slateRange && Range.equals(slateRange, selection)) {
        return;
      }
    }
    if (selection && !ReactEditor.hasRange(editor, selection)) {
      editor.selection = ReactEditor.toSlateRange(editor, domSelection, {
        exactMatch: false,
        suppressThrow: false
      });
      return;
    }
    state.isUpdatingSelection = true;
    var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);
    if (newDomRange) {
      if (Range.isBackward(selection)) {
        domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);
      } else {
        domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);
      }
      scrollSelectionIntoView(editor, newDomRange);
    } else {
      domSelection.removeAllRanges();
    }
    setTimeout(() => {
      if (newDomRange && IS_FIREFOX) {
        var el = ReactEditor.toDOMNode(editor, editor);
        el.focus();
      }
      state.isUpdatingSelection = false;
    });
  });
  (0, import_react2.useEffect)(() => {
    if (ref2.current && autoFocus) {
      ref2.current.focus();
    }
  }, [autoFocus]);
  var onDOMSelectionChange = (0, import_react2.useCallback)((0, import_throttle.default)(() => {
    if (!ReactEditor.isComposing(editor) && !state.isUpdatingSelection && !state.isDraggingInternally) {
      var root6 = ReactEditor.findDocumentOrShadowRoot(editor);
      var {
        activeElement
      } = root6;
      var el = ReactEditor.toDOMNode(editor, editor);
      var domSelection = root6.getSelection();
      if (activeElement === el) {
        state.latestElement = activeElement;
        IS_FOCUSED.set(editor, true);
      } else {
        IS_FOCUSED.delete(editor);
      }
      if (!domSelection) {
        return Transforms.deselect(editor);
      }
      var {
        anchorNode,
        focusNode
      } = domSelection;
      var anchorNodeSelectable = hasEditableTarget(editor, anchorNode) || isTargetInsideNonReadonlyVoid(editor, anchorNode);
      var focusNodeSelectable = hasEditableTarget(editor, focusNode) || isTargetInsideNonReadonlyVoid(editor, focusNode);
      if (anchorNodeSelectable && focusNodeSelectable) {
        var range = ReactEditor.toSlateRange(editor, domSelection, {
          exactMatch: false,
          suppressThrow: false
        });
        Transforms.select(editor, range);
      }
    }
  }, 100), [readOnly]);
  var scheduleOnDOMSelectionChange = (0, import_react2.useMemo)(() => (0, import_debounce.default)(onDOMSelectionChange, 0), [onDOMSelectionChange]);
  var onDOMBeforeInput = (0, import_react2.useCallback)((event) => {
    if (!readOnly && hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {
      var _EDITOR_TO_USER_SELEC;
      scheduleOnDOMSelectionChange.flush();
      onDOMSelectionChange.flush();
      var {
        selection
      } = editor;
      var {
        inputType: type
      } = event;
      var data = event.dataTransfer || event.data || void 0;
      if (type === "insertCompositionText" || type === "deleteCompositionText") {
        return;
      }
      var native = false;
      if (type === "insertText" && selection && Range.isCollapsed(selection) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise
      // causes duplicate inserts.
      event.data && event.data.length === 1 && /[a-z ]/i.test(event.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      selection.anchor.offset !== 0) {
        var _node$parentElement;
        native = true;
        if (editor.marks) {
          native = false;
        }
        var {
          anchor
        } = selection;
        var [node, offset5] = ReactEditor.toDOMPoint(editor, anchor);
        var anchorNode = (_node$parentElement = node.parentElement) === null || _node$parentElement === void 0 ? void 0 : _node$parentElement.closest("a");
        if (anchorNode && ReactEditor.hasDOMNode(editor, anchorNode)) {
          var _lastText$textContent;
          var {
            document: document2
          } = ReactEditor.getWindow(editor);
          var lastText = document2.createTreeWalker(anchorNode, NodeFilter.SHOW_TEXT).lastChild();
          if (lastText === node && ((_lastText$textContent = lastText.textContent) === null || _lastText$textContent === void 0 ? void 0 : _lastText$textContent.length) === offset5) {
            native = false;
          }
        }
      }
      if (!type.startsWith("delete") || type.startsWith("deleteBy")) {
        var [targetRange] = event.getTargetRanges();
        if (targetRange) {
          var range = ReactEditor.toSlateRange(editor, targetRange, {
            exactMatch: false,
            suppressThrow: false
          });
          if (!selection || !Range.equals(selection, range)) {
            native = false;
            var selectionRef = editor.selection && Editor.rangeRef(editor, editor.selection);
            Transforms.select(editor, range);
            if (selectionRef) {
              EDITOR_TO_USER_SELECTION.set(editor, selectionRef);
            }
          }
        }
      }
      if (!native) {
        event.preventDefault();
      }
      if (selection && Range.isExpanded(selection) && type.startsWith("delete")) {
        var direction = type.endsWith("Backward") ? "backward" : "forward";
        Editor.deleteFragment(editor, {
          direction
        });
        return;
      }
      switch (type) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          Editor.deleteFragment(editor);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          Editor.deleteForward(editor);
          break;
        }
        case "deleteContentBackward": {
          Editor.deleteBackward(editor);
          break;
        }
        case "deleteEntireSoftLine": {
          Editor.deleteBackward(editor, {
            unit: "line"
          });
          Editor.deleteForward(editor, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          Editor.deleteBackward(editor, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          Editor.deleteBackward(editor, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          Editor.deleteForward(editor, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          Editor.deleteForward(editor, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          Editor.deleteBackward(editor, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          Editor.deleteForward(editor, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          Editor.insertSoftBreak(editor);
          break;
        case "insertParagraph": {
          Editor.insertBreak(editor);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          var {
            selection: _selection
          } = editor;
          if (_selection) {
            if (Range.isExpanded(_selection)) {
              Editor.deleteFragment(editor);
            }
          }
          if (type === "insertFromComposition") {
            if (ReactEditor.isComposing(editor)) {
              setIsComposing(false);
              IS_COMPOSING.set(editor, false);
            }
          }
          if ((data === null || data === void 0 ? void 0 : data.constructor.name) === "DataTransfer") {
            ReactEditor.insertData(editor, data);
          } else if (typeof data === "string") {
            if (native) {
              deferredOperations.current.push(() => Editor.insertText(editor, data));
            } else {
              Editor.insertText(editor, data);
            }
          }
          break;
        }
      }
      var toRestore = (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();
      EDITOR_TO_USER_SELECTION.delete(editor);
      if (toRestore && (!editor.selection || !Range.equals(editor.selection, toRestore))) {
        Transforms.select(editor, toRestore);
      }
    }
  }, [readOnly, propsOnDOMBeforeInput]);
  useIsomorphicLayoutEffect(() => {
    if (ref2.current && HAS_BEFORE_INPUT_SUPPORT) {
      ref2.current.addEventListener("beforeinput", onDOMBeforeInput);
    }
    return () => {
      if (ref2.current && HAS_BEFORE_INPUT_SUPPORT) {
        ref2.current.removeEventListener("beforeinput", onDOMBeforeInput);
      }
    };
  }, [onDOMBeforeInput]);
  useIsomorphicLayoutEffect(() => {
    var window2 = ReactEditor.getWindow(editor);
    window2.document.addEventListener("selectionchange", scheduleOnDOMSelectionChange);
    return () => {
      window2.document.removeEventListener("selectionchange", scheduleOnDOMSelectionChange);
    };
  }, [scheduleOnDOMSelectionChange]);
  var decorations = decorate([editor, []]);
  if (placeholder2 && editor.children.length === 1 && Array.from(Node2.texts(editor)).length === 1 && Node2.string(editor) === "" && !isComposing2) {
    var start3 = Editor.start(editor, []);
    decorations.push({
      [PLACEHOLDER_SYMBOL]: true,
      placeholder: placeholder2,
      anchor: start3,
      focus: start3
    });
  }
  return import_react2.default.createElement(ReadOnlyContext.Provider, {
    value: readOnly
  }, import_react2.default.createElement(DecorateContext.Provider, {
    value: decorate
  }, import_react2.default.createElement(Component9, Object.assign({
    role: readOnly ? void 0 : "textbox"
  }, attributes, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.spellCheck : false,
    autoCorrect: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCorrect : "false",
    autoCapitalize: HAS_BEFORE_INPUT_SUPPORT || !CAN_USE_DOM ? attributes.autoCapitalize : "false",
    "data-slate-editor": true,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !readOnly,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: true,
    ref: ref2,
    style: _objectSpread$12({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Prevent the default outline styles.
      outline: "none",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, style2),
    onBeforeInput: (0, import_react2.useCallback)((event) => {
      if (!HAS_BEFORE_INPUT_SUPPORT && !readOnly && !isEventHandled(event, attributes.onBeforeInput) && hasEditableTarget(editor, event.target)) {
        event.preventDefault();
        if (!ReactEditor.isComposing(editor)) {
          var text = event.data;
          Editor.insertText(editor, text);
        }
      }
    }, [readOnly]),
    onInput: (0, import_react2.useCallback)((event) => {
      for (var op of deferredOperations.current) {
        op();
      }
      deferredOperations.current = [];
    }, []),
    onBlur: (0, import_react2.useCallback)((event) => {
      if (readOnly || state.isUpdatingSelection || !hasEditableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {
        return;
      }
      var root6 = ReactEditor.findDocumentOrShadowRoot(editor);
      if (state.latestElement === root6.activeElement) {
        return;
      }
      var {
        relatedTarget
      } = event;
      var el = ReactEditor.toDOMNode(editor, editor);
      if (relatedTarget === el) {
        return;
      }
      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute("data-slate-spacer")) {
        return;
      }
      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {
        var node = ReactEditor.toSlateNode(editor, relatedTarget);
        if (Element2.isElement(node) && !editor.isVoid(node)) {
          return;
        }
      }
      if (IS_SAFARI) {
        var domSelection = root6.getSelection();
        domSelection === null || domSelection === void 0 ? void 0 : domSelection.removeAllRanges();
      }
      IS_FOCUSED.delete(editor);
    }, [readOnly, attributes.onBlur]),
    onClick: (0, import_react2.useCallback)((event) => {
      if (hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {
        var node = ReactEditor.toSlateNode(editor, event.target);
        var path = ReactEditor.findPath(editor, node);
        if (!Editor.hasPath(editor, path) || Node2.get(editor, path) !== node) {
          return;
        }
        if (event.detail === TRIPLE_CLICK && path.length >= 1) {
          var blockPath = path;
          if (!Editor.isBlock(editor, node)) {
            var _block$;
            var block = Editor.above(editor, {
              match: (n12) => Editor.isBlock(editor, n12),
              at: path
            });
            blockPath = (_block$ = block === null || block === void 0 ? void 0 : block[1]) !== null && _block$ !== void 0 ? _block$ : path.slice(0, 1);
          }
          var range = Editor.range(editor, blockPath);
          Transforms.select(editor, range);
          return;
        }
        if (readOnly) {
          return;
        }
        var _start = Editor.start(editor, path);
        var end2 = Editor.end(editor, path);
        var startVoid = Editor.void(editor, {
          at: _start
        });
        var endVoid = Editor.void(editor, {
          at: end2
        });
        if (startVoid && endVoid && Path.equals(startVoid[1], endVoid[1])) {
          var _range = Editor.range(editor, _start);
          Transforms.select(editor, _range);
        }
      }
    }, [readOnly, attributes.onClick]),
    onCompositionEnd: (0, import_react2.useCallback)((event) => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionEnd)) {
        if (ReactEditor.isComposing(editor)) {
          setIsComposing(false);
          IS_COMPOSING.set(editor, false);
        }
        if (!IS_SAFARI && !IS_FIREFOX_LEGACY && !IS_IOS && !IS_QQBROWSER && !IS_WECHATBROWSER && !IS_UC_MOBILE && event.data) {
          Editor.insertText(editor, event.data);
        }
        if (editor.selection && Range.isCollapsed(editor.selection)) {
          var leafPath = editor.selection.anchor.path;
          var currentTextNode = Node2.leaf(editor, leafPath);
          if (state.hasInsertPrefixInCompositon) {
            state.hasInsertPrefixInCompositon = false;
            Editor.withoutNormalizing(editor, () => {
              var text = currentTextNode.text.replace(/^\uFEFF/, "");
              Transforms.delete(editor, {
                distance: currentTextNode.text.length,
                reverse: true
              });
              Editor.insertText(editor, text);
            });
          }
        }
      }
    }, [attributes.onCompositionEnd]),
    onCompositionUpdate: (0, import_react2.useCallback)((event) => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {
        if (!ReactEditor.isComposing(editor)) {
          setIsComposing(true);
          IS_COMPOSING.set(editor, true);
        }
      }
    }, [attributes.onCompositionUpdate]),
    onCompositionStart: (0, import_react2.useCallback)((event) => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionStart)) {
        var {
          selection,
          marks
        } = editor;
        if (selection) {
          if (Range.isExpanded(selection)) {
            Editor.deleteFragment(editor);
            return;
          }
          var inline2 = Editor.above(editor, {
            match: (n12) => Editor.isInline(editor, n12),
            mode: "highest"
          });
          if (inline2) {
            var [, inlinePath] = inline2;
            if (Editor.isEnd(editor, selection.anchor, inlinePath)) {
              var point = Editor.after(editor, inlinePath);
              Transforms.setSelection(editor, {
                anchor: point,
                focus: point
              });
            }
          }
          if (marks) {
            state.hasInsertPrefixInCompositon = true;
            Transforms.insertNodes(editor, _objectSpread$12({
              text: "\uFEFF"
            }, marks), {
              select: true
            });
          }
        }
      }
    }, [attributes.onCompositionStart]),
    onCopy: (0, import_react2.useCallback)((event) => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData, "copy");
      }
    }, [attributes.onCopy]),
    onCut: (0, import_react2.useCallback)((event) => {
      if (!readOnly && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData, "cut");
        var {
          selection
        } = editor;
        if (selection) {
          if (Range.isExpanded(selection)) {
            Editor.deleteFragment(editor);
          } else {
            var node = Node2.parent(editor, selection.anchor.path);
            if (Editor.isVoid(editor, node)) {
              Transforms.delete(editor);
            }
          }
        }
      }
    }, [readOnly, attributes.onCut]),
    onDragOver: (0, import_react2.useCallback)((event) => {
      if (hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragOver)) {
        var node = ReactEditor.toSlateNode(editor, event.target);
        if (Editor.isVoid(editor, node)) {
          event.preventDefault();
        }
      }
    }, [attributes.onDragOver]),
    onDragStart: (0, import_react2.useCallback)((event) => {
      if (!readOnly && hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDragStart)) {
        var node = ReactEditor.toSlateNode(editor, event.target);
        var path = ReactEditor.findPath(editor, node);
        var voidMatch = Editor.isVoid(editor, node) || Editor.void(editor, {
          at: path,
          voids: true
        });
        if (voidMatch) {
          var range = Editor.range(editor, path);
          Transforms.select(editor, range);
        }
        state.isDraggingInternally = true;
        ReactEditor.setFragmentData(editor, event.dataTransfer, "drag");
      }
    }, [readOnly, attributes.onDragStart]),
    onDrop: (0, import_react2.useCallback)((event) => {
      if (!readOnly && hasTarget(editor, event.target) && !isEventHandled(event, attributes.onDrop)) {
        event.preventDefault();
        var draggedRange = editor.selection;
        var range = ReactEditor.findEventRange(editor, event);
        var data = event.dataTransfer;
        Transforms.select(editor, range);
        if (state.isDraggingInternally) {
          if (draggedRange && !Range.equals(draggedRange, range) && !Editor.void(editor, {
            at: range,
            voids: true
          })) {
            Transforms.delete(editor, {
              at: draggedRange
            });
          }
        }
        ReactEditor.insertData(editor, data);
        if (!ReactEditor.isFocused(editor)) {
          ReactEditor.focus(editor);
        }
      }
      state.isDraggingInternally = false;
    }, [readOnly, attributes.onDrop]),
    onDragEnd: (0, import_react2.useCallback)((event) => {
      if (!readOnly && state.isDraggingInternally && attributes.onDragEnd && hasTarget(editor, event.target)) {
        attributes.onDragEnd(event);
      }
      state.isDraggingInternally = false;
    }, [readOnly, attributes.onDragEnd]),
    onFocus: (0, import_react2.useCallback)((event) => {
      if (!readOnly && !state.isUpdatingSelection && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {
        var el = ReactEditor.toDOMNode(editor, editor);
        var root6 = ReactEditor.findDocumentOrShadowRoot(editor);
        state.latestElement = root6.activeElement;
        if (IS_FIREFOX && event.target !== el) {
          el.focus();
          return;
        }
        IS_FOCUSED.set(editor, true);
      }
    }, [readOnly, attributes.onFocus]),
    onKeyDown: (0, import_react2.useCallback)((event) => {
      if (!readOnly && hasEditableTarget(editor, event.target)) {
        var {
          nativeEvent
        } = event;
        if (ReactEditor.isComposing(editor) && nativeEvent.isComposing === false) {
          IS_COMPOSING.set(editor, false);
          setIsComposing(false);
        }
        if (isEventHandled(event, attributes.onKeyDown) || ReactEditor.isComposing(editor)) {
          return;
        }
        var {
          selection
        } = editor;
        var element = editor.children[selection !== null ? selection.focus.path[0] : 0];
        var isRTL = (0, import_direction.default)(Node2.string(element)) === "rtl";
        if (Hotkeys.isRedo(nativeEvent)) {
          event.preventDefault();
          var maybeHistoryEditor = editor;
          if (typeof maybeHistoryEditor.redo === "function") {
            maybeHistoryEditor.redo();
          }
          return;
        }
        if (Hotkeys.isUndo(nativeEvent)) {
          event.preventDefault();
          var _maybeHistoryEditor = editor;
          if (typeof _maybeHistoryEditor.undo === "function") {
            _maybeHistoryEditor.undo();
          }
          return;
        }
        if (Hotkeys.isMoveLineBackward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line",
            reverse: true
          });
          return;
        }
        if (Hotkeys.isMoveLineForward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line"
          });
          return;
        }
        if (Hotkeys.isExtendLineBackward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line",
            edge: "focus",
            reverse: true
          });
          return;
        }
        if (Hotkeys.isExtendLineForward(nativeEvent)) {
          event.preventDefault();
          Transforms.move(editor, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (Hotkeys.isMoveBackward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isCollapsed(selection)) {
            Transforms.move(editor, {
              reverse: !isRTL
            });
          } else {
            Transforms.collapse(editor, {
              edge: "start"
            });
          }
          return;
        }
        if (Hotkeys.isMoveForward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isCollapsed(selection)) {
            Transforms.move(editor, {
              reverse: isRTL
            });
          } else {
            Transforms.collapse(editor, {
              edge: "end"
            });
          }
          return;
        }
        if (Hotkeys.isMoveWordBackward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isExpanded(selection)) {
            Transforms.collapse(editor, {
              edge: "focus"
            });
          }
          Transforms.move(editor, {
            unit: "word",
            reverse: !isRTL
          });
          return;
        }
        if (Hotkeys.isMoveWordForward(nativeEvent)) {
          event.preventDefault();
          if (selection && Range.isExpanded(selection)) {
            Transforms.collapse(editor, {
              edge: "focus"
            });
          }
          Transforms.move(editor, {
            unit: "word",
            reverse: isRTL
          });
          return;
        }
        if (!HAS_BEFORE_INPUT_SUPPORT) {
          if (Hotkeys.isBold(nativeEvent) || Hotkeys.isItalic(nativeEvent) || Hotkeys.isTransposeCharacter(nativeEvent)) {
            event.preventDefault();
            return;
          }
          if (Hotkeys.isSoftBreak(nativeEvent)) {
            event.preventDefault();
            Editor.insertSoftBreak(editor);
            return;
          }
          if (Hotkeys.isSplitBlock(nativeEvent)) {
            event.preventDefault();
            Editor.insertBreak(editor);
            return;
          }
          if (Hotkeys.isDeleteBackward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "backward"
              });
            } else {
              Editor.deleteBackward(editor);
            }
            return;
          }
          if (Hotkeys.isDeleteForward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "forward"
              });
            } else {
              Editor.deleteForward(editor);
            }
            return;
          }
          if (Hotkeys.isDeleteLineBackward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "backward"
              });
            } else {
              Editor.deleteBackward(editor, {
                unit: "line"
              });
            }
            return;
          }
          if (Hotkeys.isDeleteLineForward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "forward"
              });
            } else {
              Editor.deleteForward(editor, {
                unit: "line"
              });
            }
            return;
          }
          if (Hotkeys.isDeleteWordBackward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "backward"
              });
            } else {
              Editor.deleteBackward(editor, {
                unit: "word"
              });
            }
            return;
          }
          if (Hotkeys.isDeleteWordForward(nativeEvent)) {
            event.preventDefault();
            if (selection && Range.isExpanded(selection)) {
              Editor.deleteFragment(editor, {
                direction: "forward"
              });
            } else {
              Editor.deleteForward(editor, {
                unit: "word"
              });
            }
            return;
          }
        } else {
          if (IS_CHROME || IS_SAFARI) {
            if (selection && (Hotkeys.isDeleteBackward(nativeEvent) || Hotkeys.isDeleteForward(nativeEvent)) && Range.isCollapsed(selection)) {
              var currentNode = Node2.parent(editor, selection.anchor.path);
              if (Element2.isElement(currentNode) && Editor.isVoid(editor, currentNode) && Editor.isInline(editor, currentNode)) {
                event.preventDefault();
                Editor.deleteBackward(editor, {
                  unit: "block"
                });
                return;
              }
            }
          }
        }
      }
    }, [readOnly, attributes.onKeyDown]),
    onPaste: (0, import_react2.useCallback)((event) => {
      if (!readOnly && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste)) {
        if (!HAS_BEFORE_INPUT_SUPPORT || isPlainTextOnlyPaste(event.nativeEvent)) {
          event.preventDefault();
          ReactEditor.insertData(editor, event.clipboardData);
        }
      }
    }, [readOnly, attributes.onPaste])
  }), import_react2.default.createElement(Children, {
    decorations,
    node: editor,
    renderElement,
    renderPlaceholder,
    renderLeaf,
    selection: editor.selection
  }))));
};
var DefaultPlaceholder = (_ref) => {
  var {
    attributes,
    children
  } = _ref;
  return import_react2.default.createElement("span", Object.assign({}, attributes), children);
};
var defaultDecorate = () => [];
var defaultScrollSelectionIntoView = (editor, domRange) => {
  if (!editor.selection || editor.selection && Range.isCollapsed(editor.selection)) {
    var leafEl = domRange.startContainer.parentElement;
    leafEl.getBoundingClientRect = domRange.getBoundingClientRect.bind(domRange);
    es_default(leafEl, {
      scrollMode: "if-needed"
    });
    delete leafEl.getBoundingClientRect;
  }
};
var hasTarget = (editor, target) => {
  return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target);
};
var hasEditableTarget = (editor, target) => {
  return isDOMNode(target) && ReactEditor.hasDOMNode(editor, target, {
    editable: true
  });
};
var isTargetInsideNonReadonlyVoid = (editor, target) => {
  if (IS_READ_ONLY.get(editor))
    return false;
  var slateNode = hasTarget(editor, target) && ReactEditor.toSlateNode(editor, target);
  return Editor.isVoid(editor, slateNode);
};
var isEventHandled = (event, handler) => {
  if (!handler) {
    return false;
  }
  var shouldTreatEventAsHandled = handler(event);
  if (shouldTreatEventAsHandled != null) {
    return shouldTreatEventAsHandled;
  }
  return event.isDefaultPrevented() || event.isPropagationStopped();
};
var isDOMEventHandled = (event, handler) => {
  if (!handler) {
    return false;
  }
  var shouldTreatEventAsHandled = handler(event);
  if (shouldTreatEventAsHandled != null) {
    return shouldTreatEventAsHandled;
  }
  return event.defaultPrevented;
};
function getDiffStart(prev, next) {
  var length = Math.min(prev.length, next.length);
  for (var i15 = 0; i15 < length; i15++) {
    if (prev.charAt(i15) !== next.charAt(i15))
      return i15;
  }
  if (prev.length !== next.length)
    return length;
  return null;
}
function getDiffEnd(prev, next, max4) {
  var prevLength = prev.length;
  var nextLength = next.length;
  var length = Math.min(prevLength, nextLength, max4);
  for (var i15 = 0; i15 < length; i15++) {
    var prevChar = prev.charAt(prevLength - i15 - 1);
    var nextChar = next.charAt(nextLength - i15 - 1);
    if (prevChar !== nextChar)
      return i15;
  }
  if (prev.length !== next.length)
    return length;
  return null;
}
function getDiffOffsets(prev, next) {
  if (prev === next)
    return null;
  var start3 = getDiffStart(prev, next);
  if (start3 === null)
    return null;
  var maxEnd = Math.min(prev.length - start3, next.length - start3);
  var end2 = getDiffEnd(prev, next, maxEnd);
  if (end2 === null)
    return null;
  return {
    start: start3,
    end: end2
  };
}
function sliceText(text, offsets) {
  return text.slice(offsets.start, text.length - offsets.end);
}
function diffText(prev, next) {
  if (prev === void 0 || next === void 0)
    return null;
  var offsets = getDiffOffsets(prev, next);
  if (offsets == null)
    return null;
  var insertText2 = sliceText(next, offsets);
  var removeText = sliceText(prev, offsets);
  return {
    start: offsets.start,
    end: prev.length - offsets.end,
    insertText: insertText2,
    removeText
  };
}
function combineInsertedText(insertedText) {
  return insertedText.reduce((acc, _ref) => {
    var {
      text
    } = _ref;
    return "".concat(acc).concat(text.insertText);
  }, "");
}
function getTextInsertion(editor, domNode) {
  var node = ReactEditor.toSlateNode(editor, domNode);
  if (!Text.isText(node)) {
    return void 0;
  }
  var prevText = node.text;
  var nextText = domNode.textContent;
  if (nextText.endsWith("\n")) {
    nextText = nextText.slice(0, nextText.length - 1);
  }
  if (nextText !== prevText) {
    var textDiff = diffText(prevText, nextText);
    if (textDiff !== null) {
      var textPath = ReactEditor.findPath(editor, node);
      return {
        text: textDiff,
        path: textPath
      };
    }
  }
  return void 0;
}
function normalizeTextInsertionRange(editor, range, _ref2) {
  var {
    path,
    text
  } = _ref2;
  var insertionRange = {
    anchor: {
      path,
      offset: text.start
    },
    focus: {
      path,
      offset: text.end
    }
  };
  if (!range || !Range.isCollapsed(range)) {
    return insertionRange;
  }
  var {
    insertText: insertText2,
    removeText
  } = text;
  var isSingleCharacterInsertion = insertText2.length === 1 || removeText.length === 1;
  if (isSingleCharacterInsertion && Path.equals(range.anchor.path, path)) {
    var [_text] = Array.from(Editor.nodes(editor, {
      at: range,
      match: Text.isText
    }));
    if (_text) {
      var [node] = _text;
      var {
        anchor
      } = range;
      var characterBeforeAnchor = node.text[anchor.offset - 1];
      var characterAfterAnchor = node.text[anchor.offset];
      if (insertText2.length === 1 && insertText2 === characterAfterAnchor) {
        return range;
      }
      if (removeText.length === 1 && removeText === characterBeforeAnchor) {
        return {
          anchor: {
            path,
            offset: anchor.offset - 1
          },
          focus: {
            path,
            offset: anchor.offset
          }
        };
      }
    }
  }
  return insertionRange;
}
var n3 = 0;
var Key = class {
  constructor() {
    this.id = "".concat(n3++);
  }
};
var ReactEditor = {
  /**
   * Check if the user is currently composing inside the editor.
   */
  isComposing(editor) {
    return !!IS_COMPOSING.get(editor);
  },
  /**
   * Return the host window of the current editor.
   */
  getWindow(editor) {
    var window2 = EDITOR_TO_WINDOW.get(editor);
    if (!window2) {
      throw new Error("Unable to find a host window element for this editor");
    }
    return window2;
  },
  /**
   * Find a key for a Slate node.
   */
  findKey(editor, node) {
    var key = NODE_TO_KEY.get(node);
    if (!key) {
      key = new Key();
      NODE_TO_KEY.set(node, key);
    }
    return key;
  },
  /**
   * Find the path of Slate node.
   */
  findPath(editor, node) {
    var path = [];
    var child = node;
    while (true) {
      var parent2 = NODE_TO_PARENT.get(child);
      if (parent2 == null) {
        if (Editor.isEditor(child)) {
          return path;
        } else {
          break;
        }
      }
      var i15 = NODE_TO_INDEX.get(child);
      if (i15 == null) {
        break;
      }
      path.unshift(i15);
      child = parent2;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Scrubber.stringify(node)));
  },
  /**
   * Find the DOM node that implements DocumentOrShadowRoot for the editor.
   */
  findDocumentOrShadowRoot(editor) {
    var el = ReactEditor.toDOMNode(editor, editor);
    var root6 = el.getRootNode();
    if ((root6 instanceof Document || root6 instanceof ShadowRoot) && root6.getSelection != null) {
      return root6;
    }
    return el.ownerDocument;
  },
  /**
   * Check if the editor is focused.
   */
  isFocused(editor) {
    return !!IS_FOCUSED.get(editor);
  },
  /**
   * Check if the editor is in read-only mode.
   */
  isReadOnly(editor) {
    return !!IS_READ_ONLY.get(editor);
  },
  /**
   * Blur the editor.
   */
  blur(editor) {
    var el = ReactEditor.toDOMNode(editor, editor);
    var root6 = ReactEditor.findDocumentOrShadowRoot(editor);
    IS_FOCUSED.set(editor, false);
    if (root6.activeElement === el) {
      el.blur();
    }
  },
  /**
   * Focus the editor.
   */
  focus(editor) {
    var el = ReactEditor.toDOMNode(editor, editor);
    var root6 = ReactEditor.findDocumentOrShadowRoot(editor);
    IS_FOCUSED.set(editor, true);
    if (root6.activeElement !== el) {
      el.focus({
        preventScroll: true
      });
    }
  },
  /**
   * Deselect the editor.
   */
  deselect(editor) {
    ReactEditor.toDOMNode(editor, editor);
    var {
      selection
    } = editor;
    var root6 = ReactEditor.findDocumentOrShadowRoot(editor);
    var domSelection = root6.getSelection();
    if (domSelection && domSelection.rangeCount > 0) {
      domSelection.removeAllRanges();
    }
    if (selection) {
      Transforms.deselect(editor);
    }
  },
  /**
   * Check if a DOM node is within the editor.
   */
  hasDOMNode(editor, target) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var {
      editable = false
    } = options;
    var editorEl = ReactEditor.toDOMNode(editor, editor);
    var targetEl;
    try {
      targetEl = isDOMElement(target) ? target : target.parentElement;
    } catch (err) {
      if (!err.message.includes('Permission denied to access property "nodeType"')) {
        throw err;
      }
    }
    if (!targetEl) {
      return false;
    }
    return targetEl.closest("[data-slate-editor]") === editorEl && (!editable || targetEl.isContentEditable ? true : typeof targetEl.isContentEditable === "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    targetEl.closest('[contenteditable="false"]') === editorEl || !!targetEl.getAttribute("data-slate-zero-width"));
  },
  /**
   * Insert data from a `DataTransfer` into the editor.
   */
  insertData(editor, data) {
    editor.insertData(data);
  },
  /**
   * Insert fragment data from a `DataTransfer` into the editor.
   */
  insertFragmentData(editor, data) {
    return editor.insertFragmentData(data);
  },
  /**
   * Insert text data from a `DataTransfer` into the editor.
   */
  insertTextData(editor, data) {
    return editor.insertTextData(data);
  },
  /**
   * Sets data from the currently selected fragment on a `DataTransfer`.
   */
  setFragmentData(editor, data, originEvent) {
    editor.setFragmentData(data, originEvent);
  },
  /**
   * Find the native DOM element from a Slate node.
   */
  toDOMNode(editor, node) {
    var KEY_TO_ELEMENT = EDITOR_TO_KEY_TO_ELEMENT.get(editor);
    var domNode = Editor.isEditor(node) ? EDITOR_TO_ELEMENT.get(editor) : KEY_TO_ELEMENT === null || KEY_TO_ELEMENT === void 0 ? void 0 : KEY_TO_ELEMENT.get(ReactEditor.findKey(editor, node));
    if (!domNode) {
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Scrubber.stringify(node)));
    }
    return domNode;
  },
  /**
   * Find a native DOM selection point from a Slate point.
   */
  toDOMPoint(editor, point) {
    var [node] = Editor.node(editor, point.path);
    var el = ReactEditor.toDOMNode(editor, node);
    var domPoint;
    if (Editor.void(editor, {
      at: point
    })) {
      point = {
        path: point.path,
        offset: 0
      };
    }
    var selector = "[data-slate-string], [data-slate-zero-width]";
    var texts = Array.from(el.querySelectorAll(selector));
    var start3 = 0;
    for (var text of texts) {
      var domNode = text.childNodes[0];
      if (domNode == null || domNode.textContent == null) {
        continue;
      }
      var {
        length
      } = domNode.textContent;
      var attr = text.getAttribute("data-slate-length");
      var trueLength = attr == null ? length : parseInt(attr, 10);
      var end2 = start3 + trueLength;
      if (point.offset <= end2) {
        var offset5 = Math.min(length, Math.max(0, point.offset - start3));
        domPoint = [domNode, offset5];
        break;
      }
      start3 = end2;
    }
    if (!domPoint) {
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Scrubber.stringify(point)));
    }
    return domPoint;
  },
  /**
   * Find a native DOM range from a Slate `range`.
   *
   * Notice: the returned range will always be ordinal regardless of the direction of Slate `range` due to DOM API limit.
   *
   * there is no way to create a reverse DOM Range using Range.setStart/setEnd
   * according to https://dom.spec.whatwg.org/#concept-range-bp-set.
   */
  toDOMRange(editor, range) {
    var {
      anchor,
      focus: focus2
    } = range;
    var isBackward = Range.isBackward(range);
    var domAnchor = ReactEditor.toDOMPoint(editor, anchor);
    var domFocus = Range.isCollapsed(range) ? domAnchor : ReactEditor.toDOMPoint(editor, focus2);
    var window2 = ReactEditor.getWindow(editor);
    var domRange = window2.document.createRange();
    var [startNode, startOffset] = isBackward ? domFocus : domAnchor;
    var [endNode, endOffset] = isBackward ? domAnchor : domFocus;
    var startEl = isDOMElement(startNode) ? startNode : startNode.parentElement;
    var isStartAtZeroWidth = !!startEl.getAttribute("data-slate-zero-width");
    var endEl = isDOMElement(endNode) ? endNode : endNode.parentElement;
    var isEndAtZeroWidth = !!endEl.getAttribute("data-slate-zero-width");
    domRange.setStart(startNode, isStartAtZeroWidth ? 1 : startOffset);
    domRange.setEnd(endNode, isEndAtZeroWidth ? 1 : endOffset);
    return domRange;
  },
  /**
   * Find a Slate node from a native DOM `element`.
   */
  toSlateNode(editor, domNode) {
    var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;
    if (domEl && !domEl.hasAttribute("data-slate-node")) {
      domEl = domEl.closest("[data-slate-node]");
    }
    var node = domEl ? ELEMENT_TO_NODE.get(domEl) : null;
    if (!node) {
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(domEl));
    }
    return node;
  },
  /**
   * Get the target range from a DOM `event`.
   */
  findEventRange(editor, event) {
    if ("nativeEvent" in event) {
      event = event.nativeEvent;
    }
    var {
      clientX: x7,
      clientY: y9,
      target
    } = event;
    if (x7 == null || y9 == null) {
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
    }
    var node = ReactEditor.toSlateNode(editor, event.target);
    var path = ReactEditor.findPath(editor, node);
    if (Editor.isVoid(editor, node)) {
      var rect = target.getBoundingClientRect();
      var isPrev = editor.isInline(node) ? x7 - rect.left < rect.left + rect.width - x7 : y9 - rect.top < rect.top + rect.height - y9;
      var edge = Editor.point(editor, path, {
        edge: isPrev ? "start" : "end"
      });
      var point = isPrev ? Editor.before(editor, edge) : Editor.after(editor, edge);
      if (point) {
        var _range = Editor.range(editor, point);
        return _range;
      }
    }
    var domRange;
    var {
      document: document2
    } = ReactEditor.getWindow(editor);
    if (document2.caretRangeFromPoint) {
      domRange = document2.caretRangeFromPoint(x7, y9);
    } else {
      var position3 = document2.caretPositionFromPoint(x7, y9);
      if (position3) {
        domRange = document2.createRange();
        domRange.setStart(position3.offsetNode, position3.offset);
        domRange.setEnd(position3.offsetNode, position3.offset);
      }
    }
    if (!domRange) {
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(event));
    }
    var range = ReactEditor.toSlateRange(editor, domRange, {
      exactMatch: false,
      suppressThrow: false
    });
    return range;
  },
  /**
   * Find a Slate point from a DOM selection's `domNode` and `domOffset`.
   */
  toSlatePoint(editor, domPoint, options) {
    var {
      exactMatch,
      suppressThrow
    } = options;
    var [nearestNode, nearestOffset] = exactMatch ? domPoint : normalizeDOMPoint(domPoint);
    var parentNode = nearestNode.parentNode;
    var textNode = null;
    var offset5 = 0;
    if (parentNode) {
      var _domNode$textContent;
      var editorEl = ReactEditor.toDOMNode(editor, editor);
      var potentialVoidNode = parentNode.closest('[data-slate-void="true"]');
      var voidNode = potentialVoidNode && editorEl.contains(potentialVoidNode) ? potentialVoidNode : null;
      var leafNode = parentNode.closest("[data-slate-leaf]");
      var domNode = null;
      if (leafNode) {
        textNode = leafNode.closest('[data-slate-node="text"]');
        if (textNode) {
          var window2 = ReactEditor.getWindow(editor);
          var range = window2.document.createRange();
          range.setStart(textNode, 0);
          range.setEnd(nearestNode, nearestOffset);
          var contents = range.cloneContents();
          var removals = [...Array.prototype.slice.call(contents.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(contents.querySelectorAll("[contenteditable=false]"))];
          removals.forEach((el) => {
            el.parentNode.removeChild(el);
          });
          offset5 = contents.textContent.length;
          domNode = textNode;
        }
      } else if (voidNode) {
        leafNode = voidNode.querySelector("[data-slate-leaf]");
        if (!leafNode) {
          offset5 = 1;
        } else {
          textNode = leafNode.closest('[data-slate-node="text"]');
          domNode = leafNode;
          offset5 = domNode.textContent.length;
          domNode.querySelectorAll("[data-slate-zero-width]").forEach((el) => {
            offset5 -= el.textContent.length;
          });
        }
      }
      if (domNode && offset5 === domNode.textContent.length && (parentNode.hasAttribute("data-slate-zero-width") || IS_FIREFOX && (_domNode$textContent = domNode.textContent) !== null && _domNode$textContent !== void 0 && _domNode$textContent.endsWith("\n\n"))) {
        offset5--;
      }
    }
    if (!textNode) {
      if (suppressThrow) {
        return null;
      }
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(domPoint));
    }
    var slateNode = ReactEditor.toSlateNode(editor, textNode);
    var path = ReactEditor.findPath(editor, slateNode);
    return {
      path,
      offset: offset5
    };
  },
  /**
   * Find a Slate range from a DOM range or selection.
   */
  toSlateRange(editor, domRange, options) {
    var {
      exactMatch,
      suppressThrow
    } = options;
    var el = isDOMSelection(domRange) ? domRange.anchorNode : domRange.startContainer;
    var anchorNode;
    var anchorOffset;
    var focusNode;
    var focusOffset;
    var isCollapsed2;
    if (el) {
      if (isDOMSelection(domRange)) {
        anchorNode = domRange.anchorNode;
        anchorOffset = domRange.anchorOffset;
        focusNode = domRange.focusNode;
        focusOffset = domRange.focusOffset;
        if (IS_CHROME && hasShadowRoot()) {
          isCollapsed2 = domRange.anchorNode === domRange.focusNode && domRange.anchorOffset === domRange.focusOffset;
        } else {
          isCollapsed2 = domRange.isCollapsed;
        }
      } else {
        anchorNode = domRange.startContainer;
        anchorOffset = domRange.startOffset;
        focusNode = domRange.endContainer;
        focusOffset = domRange.endOffset;
        isCollapsed2 = domRange.collapsed;
      }
    }
    if (anchorNode == null || focusNode == null || anchorOffset == null || focusOffset == null) {
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(domRange));
    }
    var anchor = ReactEditor.toSlatePoint(editor, [anchorNode, anchorOffset], {
      exactMatch,
      suppressThrow
    });
    if (!anchor) {
      return null;
    }
    var focus2 = isCollapsed2 ? anchor : ReactEditor.toSlatePoint(editor, [focusNode, focusOffset], {
      exactMatch,
      suppressThrow
    });
    if (!focus2) {
      return null;
    }
    var range = {
      anchor,
      focus: focus2
    };
    if (Range.isExpanded(range) && Range.isForward(range) && isDOMElement(focusNode) && Editor.void(editor, {
      at: range.focus,
      mode: "highest"
    })) {
      range = Editor.unhangRange(editor, range, {
        voids: true
      });
    }
    return range;
  },
  hasRange(editor, range) {
    var {
      anchor,
      focus: focus2
    } = range;
    return Editor.hasPath(editor, anchor.path) && Editor.hasPath(editor, focus2.path);
  }
};
function gatherMutationData(editor, mutations) {
  var addedNodes = [];
  var removedNodes = [];
  var insertedText = [];
  var characterDataMutations = [];
  mutations.forEach((mutation) => {
    switch (mutation.type) {
      case "childList": {
        if (mutation.addedNodes.length) {
          mutation.addedNodes.forEach((addedNode) => {
            addedNodes.push(addedNode);
          });
        }
        mutation.removedNodes.forEach((removedNode) => {
          removedNodes.push(removedNode);
        });
        break;
      }
      case "characterData": {
        characterDataMutations.push(mutation);
        var {
          parentNode
        } = mutation.target;
        if (!parentNode) {
          return;
        }
        var textInsertion = getTextInsertion(editor, parentNode);
        if (!textInsertion) {
          return;
        }
        if (insertedText.some((_ref) => {
          var {
            path
          } = _ref;
          return Path.equals(path, textInsertion.path);
        })) {
          return;
        }
        insertedText.push(textInsertion);
      }
    }
  });
  return {
    addedNodes,
    removedNodes,
    insertedText,
    characterDataMutations
  };
}
var isLineBreak = (editor, _ref2) => {
  var {
    addedNodes
  } = _ref2;
  var {
    selection
  } = editor;
  var parentNode = selection ? Node2.parent(editor, selection.anchor.path) : null;
  var parentDOMNode = parentNode ? ReactEditor.toDOMNode(editor, parentNode) : null;
  if (!parentDOMNode) {
    return false;
  }
  return addedNodes.some((addedNode) => addedNode instanceof HTMLElement && addedNode.tagName === (parentDOMNode === null || parentDOMNode === void 0 ? void 0 : parentDOMNode.tagName));
};
var isDeletion = (_7, _ref3) => {
  var {
    removedNodes
  } = _ref3;
  return removedNodes.length > 0;
};
var isReplaceExpandedSelection = (_ref4, _ref5) => {
  var {
    selection
  } = _ref4;
  var {
    removedNodes
  } = _ref5;
  return selection ? Range.isExpanded(selection) && removedNodes.length > 0 : false;
};
var isTextInsertion = (_7, _ref6) => {
  var {
    insertedText
  } = _ref6;
  return insertedText.length > 0;
};
var isRemoveLeafNodes = (_7, _ref7) => {
  var {
    addedNodes,
    characterDataMutations,
    removedNodes
  } = _ref7;
  return removedNodes.length > 0 && addedNodes.length === 0 && characterDataMutations.length > 0;
};
var AndroidInputManager = class {
  constructor(editor, restoreDOM) {
    this.editor = editor;
    this.restoreDOM = restoreDOM;
    this.flush = (mutations) => {
      try {
        this.reconcileMutations(mutations);
      } catch (err) {
        console.error(err);
        this.restoreDOM();
      }
    };
    this.reconcileMutations = (mutations) => {
      var mutationData = gatherMutationData(this.editor, mutations);
      var {
        insertedText,
        removedNodes
      } = mutationData;
      if (isReplaceExpandedSelection(this.editor, mutationData)) {
        var text = combineInsertedText(insertedText);
        this.replaceExpandedSelection(text);
      } else if (isLineBreak(this.editor, mutationData)) {
        this.insertBreak();
      } else if (isRemoveLeafNodes(this.editor, mutationData)) {
        this.removeLeafNodes(removedNodes);
      } else if (isDeletion(this.editor, mutationData)) {
        this.deleteBackward();
      } else if (isTextInsertion(this.editor, mutationData)) {
        this.insertText(insertedText);
      }
    };
    this.insertText = (insertedText) => {
      var {
        selection
      } = this.editor;
      if (ReactEditor.isComposing(this.editor) || IS_ON_COMPOSITION_END.get(this.editor)) {
        EDITOR_ON_COMPOSITION_TEXT.set(this.editor, insertedText);
        IS_ON_COMPOSITION_END.set(this.editor, false);
        return;
      }
      insertedText.forEach((insertion) => {
        var text = insertion.text.insertText;
        var at = normalizeTextInsertionRange(this.editor, selection, insertion);
        Transforms.setSelection(this.editor, at);
        Editor.insertText(this.editor, text);
      });
    };
    this.insertBreak = () => {
      var {
        selection
      } = this.editor;
      Editor.insertBreak(this.editor);
      this.restoreDOM();
      if (selection) {
        setTimeout(() => {
          if (this.editor.selection && Range.equals(selection, this.editor.selection)) {
            Transforms.move(this.editor);
          }
        }, 100);
      }
    };
    this.replaceExpandedSelection = (text) => {
      Editor.deleteFragment(this.editor);
      if (text.length) {
        Editor.insertText(this.editor, text);
      }
      this.restoreDOM();
    };
    this.deleteBackward = () => {
      Editor.deleteBackward(this.editor);
      ReactEditor.focus(this.editor);
      this.restoreDOM();
    };
    this.removeLeafNodes = (nodes) => {
      for (var node of nodes) {
        var slateNode = ReactEditor.toSlateNode(this.editor, node);
        if (slateNode) {
          var path = ReactEditor.findPath(this.editor, slateNode);
          Transforms.delete(this.editor, {
            at: path
          });
          this.restoreDOM();
        }
      }
    };
    this.editor = editor;
    this.restoreDOM = restoreDOM;
  }
};
function useMutationObserver(node, callback, options) {
  var [mutationObserver] = (0, import_react2.useState)(() => new MutationObserver(callback));
  useIsomorphicLayoutEffect(() => {
    mutationObserver.disconnect();
  });
  (0, import_react2.useEffect)(() => {
    if (!node.current) {
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    }
    mutationObserver.observe(node.current, options);
    return mutationObserver.disconnect.bind(mutationObserver);
  });
}
var MUTATION_OBSERVER_CONFIG$1 = {
  childList: true,
  characterData: true,
  subtree: true
};
function findClosestKnowSlateNode(domNode) {
  var _domEl;
  var domEl = isDOMElement(domNode) ? domNode : domNode.parentElement;
  if (domEl && !domEl.hasAttribute("data-slate-node")) {
    domEl = domEl.closest("[data-slate-node]");
  }
  var slateNode = domEl && ELEMENT_TO_NODE.get(domEl);
  if (slateNode) {
    return slateNode;
  }
  return (_domEl = domEl) !== null && _domEl !== void 0 && _domEl.parentElement ? findClosestKnowSlateNode(domEl.parentElement) : null;
}
function useRestoreDom(node, receivedUserInput) {
  var editor = useSlateStatic();
  var mutatedNodes = (0, import_react2.useRef)(/* @__PURE__ */ new Set());
  var handleDOMMutation = (0, import_react2.useCallback)((mutations) => {
    if (!receivedUserInput.current) {
      return;
    }
    mutations.forEach((_ref) => {
      var {
        target
      } = _ref;
      var slateNode = findClosestKnowSlateNode(target);
      if (!slateNode) {
        return;
      }
      return mutatedNodes.current.add(slateNode);
    });
  }, []);
  useMutationObserver(node, handleDOMMutation, MUTATION_OBSERVER_CONFIG$1);
  mutatedNodes.current.clear();
  var restore = (0, import_react2.useCallback)(() => {
    var mutated = Array.from(mutatedNodes.current.values());
    var nodesToRestore = mutated.filter((n12) => !mutated.some((m10) => Path.isParent(ReactEditor.findPath(editor, m10), ReactEditor.findPath(editor, n12))));
    nodesToRestore.forEach((n12) => {
      var _NODE_TO_RESTORE_DOM$;
      (_NODE_TO_RESTORE_DOM$ = NODE_TO_RESTORE_DOM.get(n12)) === null || _NODE_TO_RESTORE_DOM$ === void 0 ? void 0 : _NODE_TO_RESTORE_DOM$();
    });
    mutatedNodes.current.clear();
  }, []);
  return restore;
}
function useTrackUserInput() {
  var editor = useSlateStatic();
  var receivedUserInput = (0, import_react2.useRef)(false);
  var animationFrameRef = (0, import_react2.useRef)(null);
  var onUserInput = (0, import_react2.useCallback)(() => {
    if (receivedUserInput.current === false) {
      var window2 = ReactEditor.getWindow(editor);
      receivedUserInput.current = true;
      if (animationFrameRef.current) {
        window2.cancelAnimationFrame(animationFrameRef.current);
      }
      animationFrameRef.current = window2.requestAnimationFrame(() => {
        receivedUserInput.current = false;
        animationFrameRef.current = null;
      });
    }
  }, []);
  (0, import_react2.useEffect)(() => {
    if (receivedUserInput.current) {
      receivedUserInput.current = false;
    }
  });
  return {
    receivedUserInput,
    onUserInput
  };
}
var MUTATION_OBSERVER_CONFIG = {
  childList: true,
  characterData: true,
  characterDataOldValue: true,
  subtree: true
};
function useAndroidInputManager(node) {
  var editor = useSlateStatic();
  var {
    receivedUserInput,
    onUserInput
  } = useTrackUserInput();
  var restoreDom = useRestoreDom(node, receivedUserInput);
  var inputManager = (0, import_react2.useMemo)(() => new AndroidInputManager(editor, restoreDom), [restoreDom, editor]);
  var timeoutId = (0, import_react2.useRef)(null);
  var isReconciling = (0, import_react2.useRef)(false);
  var flush3 = (0, import_react2.useCallback)((mutations) => {
    if (!receivedUserInput.current) {
      return;
    }
    isReconciling.current = true;
    inputManager.flush(mutations);
    if (timeoutId.current) {
      clearTimeout(timeoutId.current);
    }
    timeoutId.current = setTimeout(() => {
      isReconciling.current = false;
      timeoutId.current = null;
    }, 250);
  }, []);
  useMutationObserver(node, flush3, MUTATION_OBSERVER_CONFIG);
  return {
    isReconciling,
    onUserInput
  };
}
var _excluded$12 = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "style", "as"];
function ownKeys2(object2, enumerableOnly) {
  var keys6 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys6.push.apply(keys6, symbols);
  }
  return keys6;
}
function _objectSpread2(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15] != null ? arguments[i15] : {};
    if (i15 % 2) {
      ownKeys2(Object(source), true).forEach(function(key) {
        _defineProperty2(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var RESOLVE_DELAY = 20;
var AndroidEditable = (props) => {
  var {
    autoFocus,
    decorate = defaultDecorate,
    onDOMBeforeInput: propsOnDOMBeforeInput,
    placeholder: placeholder2,
    readOnly = false,
    renderElement,
    renderLeaf,
    renderPlaceholder = (props2) => import_react2.default.createElement(DefaultPlaceholder, Object.assign({}, props2)),
    style: style2 = {},
    as: Component9 = "div"
  } = props, attributes = _objectWithoutProperties2(props, _excluded$12);
  var editor = useSlate();
  var [isComposing2, setIsComposing] = (0, import_react2.useState)(false);
  var ref2 = (0, import_react2.useRef)(null);
  var inputManager = useAndroidInputManager(ref2);
  IS_READ_ONLY.set(editor, readOnly);
  var state = (0, import_react2.useMemo)(() => ({
    isComposing: false,
    isUpdatingSelection: false,
    latestElement: null
  }), []);
  var contentKey = useContentKey(editor);
  useIsomorphicLayoutEffect(() => {
    var window2;
    if (ref2.current && (window2 = getDefaultView(ref2.current))) {
      EDITOR_TO_WINDOW.set(editor, window2);
      EDITOR_TO_ELEMENT.set(editor, ref2.current);
      NODE_TO_ELEMENT.set(editor, ref2.current);
      ELEMENT_TO_NODE.set(ref2.current, editor);
    } else {
      NODE_TO_ELEMENT.delete(editor);
    }
    try {
      var {
        selection
      } = editor;
      var root6 = ReactEditor.findDocumentOrShadowRoot(editor);
      var domSelection = root6.getSelection();
      if (state.isComposing || !domSelection || !ReactEditor.isFocused(editor)) {
        return;
      }
      var hasDomSelection = domSelection.type !== "None";
      if (!selection && !hasDomSelection) {
        return;
      }
      var editorElement = EDITOR_TO_ELEMENT.get(editor);
      var hasDomSelectionInEditor = false;
      if (editorElement.contains(domSelection.anchorNode) && editorElement.contains(domSelection.focusNode)) {
        hasDomSelectionInEditor = true;
      }
      if (hasDomSelection && hasDomSelectionInEditor && selection) {
        var slateRange = ReactEditor.toSlateRange(editor, domSelection, {
          exactMatch: true,
          suppressThrow: true
        });
        if (slateRange && Range.equals(slateRange, selection)) {
          return;
        }
      }
      if (selection && !ReactEditor.hasRange(editor, selection)) {
        editor.selection = ReactEditor.toSlateRange(editor, domSelection, {
          exactMatch: false,
          suppressThrow: false
        });
        return;
      }
      var el = ReactEditor.toDOMNode(editor, editor);
      state.isUpdatingSelection = true;
      var newDomRange = selection && ReactEditor.toDOMRange(editor, selection);
      if (newDomRange) {
        if (Range.isBackward(selection)) {
          domSelection.setBaseAndExtent(newDomRange.endContainer, newDomRange.endOffset, newDomRange.startContainer, newDomRange.startOffset);
        } else {
          domSelection.setBaseAndExtent(newDomRange.startContainer, newDomRange.startOffset, newDomRange.endContainer, newDomRange.endOffset);
        }
        var leafEl = newDomRange.startContainer.parentElement;
        leafEl.getBoundingClientRect = newDomRange.getBoundingClientRect.bind(newDomRange);
        es_default(leafEl, {
          scrollMode: "if-needed",
          boundary: el
        });
        delete leafEl.getBoundingClientRect;
      } else {
        domSelection.removeAllRanges();
      }
      setTimeout(() => {
        state.isUpdatingSelection = false;
      });
    } catch (_unused) {
      state.isUpdatingSelection = false;
    }
  });
  (0, import_react2.useEffect)(() => {
    if (ref2.current && autoFocus) {
      ref2.current.focus();
    }
  }, [autoFocus]);
  var onDOMSelectionChange = (0, import_react2.useCallback)((0, import_throttle.default)(() => {
    try {
      if (!state.isComposing && !state.isUpdatingSelection && !inputManager.isReconciling.current) {
        var root6 = ReactEditor.findDocumentOrShadowRoot(editor);
        var {
          activeElement
        } = root6;
        var el = ReactEditor.toDOMNode(editor, editor);
        var domSelection = root6.getSelection();
        if (activeElement === el) {
          state.latestElement = activeElement;
          IS_FOCUSED.set(editor, true);
        } else {
          IS_FOCUSED.delete(editor);
        }
        if (!domSelection) {
          return Transforms.deselect(editor);
        }
        var {
          anchorNode,
          focusNode
        } = domSelection;
        var anchorNodeSelectable = hasEditableTarget(editor, anchorNode) || isTargetInsideNonReadonlyVoid(editor, anchorNode);
        var focusNodeSelectable = hasEditableTarget(editor, focusNode) || isTargetInsideNonReadonlyVoid(editor, focusNode);
        if (anchorNodeSelectable && focusNodeSelectable) {
          var range = ReactEditor.toSlateRange(editor, domSelection, {
            exactMatch: false,
            suppressThrow: false
          });
          Transforms.select(editor, range);
        } else {
          Transforms.deselect(editor);
        }
      }
    } catch (_unused2) {
    }
  }, 100), [readOnly]);
  var scheduleOnDOMSelectionChange = (0, import_react2.useMemo)(() => (0, import_debounce.default)(onDOMSelectionChange, 0), [onDOMSelectionChange]);
  var onDOMBeforeInput = (0, import_react2.useCallback)((event) => {
    if (!readOnly && hasEditableTarget(editor, event.target) && !isDOMEventHandled(event, propsOnDOMBeforeInput)) {
      scheduleOnDOMSelectionChange.flush();
      inputManager.onUserInput();
    }
  }, [readOnly, propsOnDOMBeforeInput]);
  useIsomorphicLayoutEffect(() => {
    var node = ref2.current;
    node === null || node === void 0 ? void 0 : node.addEventListener("beforeinput", onDOMBeforeInput);
    return () => node === null || node === void 0 ? void 0 : node.removeEventListener("beforeinput", onDOMBeforeInput);
  }, [contentKey, propsOnDOMBeforeInput]);
  useIsomorphicLayoutEffect(() => {
    var window2 = ReactEditor.getWindow(editor);
    window2.document.addEventListener("selectionchange", scheduleOnDOMSelectionChange);
    return () => {
      window2.document.removeEventListener("selectionchange", scheduleOnDOMSelectionChange);
    };
  }, [scheduleOnDOMSelectionChange]);
  var decorations = decorate([editor, []]);
  if (placeholder2 && editor.children.length === 1 && Array.from(Node2.texts(editor)).length === 1 && Node2.string(editor) === "" && !isComposing2) {
    var start3 = Editor.start(editor, []);
    decorations.push({
      [PLACEHOLDER_SYMBOL]: true,
      placeholder: placeholder2,
      anchor: start3,
      focus: start3
    });
  }
  return import_react2.default.createElement(ReadOnlyContext.Provider, {
    value: readOnly
  }, import_react2.default.createElement(DecorateContext.Provider, {
    value: decorate
  }, import_react2.default.createElement(Component9, Object.assign({
    key: contentKey,
    role: readOnly ? void 0 : "textbox"
  }, attributes, {
    spellCheck: attributes.spellCheck,
    autoCorrect: attributes.autoCorrect,
    autoCapitalize: attributes.autoCapitalize,
    "data-slate-editor": true,
    "data-slate-node": "value",
    contentEditable: readOnly ? void 0 : true,
    suppressContentEditableWarning: true,
    ref: ref2,
    style: _objectSpread2({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Prevent the default outline styles.
      outline: "none",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, style2),
    onCopy: (0, import_react2.useCallback)((event) => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCopy)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData, "copy");
      }
    }, [attributes.onCopy]),
    onCut: (0, import_react2.useCallback)((event) => {
      if (!readOnly && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCut)) {
        event.preventDefault();
        ReactEditor.setFragmentData(editor, event.clipboardData, "cut");
        var {
          selection
        } = editor;
        if (selection) {
          if (Range.isExpanded(selection)) {
            Editor.deleteFragment(editor);
          } else {
            var node = Node2.parent(editor, selection.anchor.path);
            if (Editor.isVoid(editor, node)) {
              Transforms.delete(editor);
            }
          }
        }
      }
    }, [readOnly, attributes.onCut]),
    onFocus: (0, import_react2.useCallback)((event) => {
      if (!readOnly && !state.isUpdatingSelection && hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onFocus)) {
        var root6 = ReactEditor.findDocumentOrShadowRoot(editor);
        state.latestElement = root6.activeElement;
        IS_FOCUSED.set(editor, true);
      }
    }, [readOnly, attributes.onFocus]),
    onBlur: (0, import_react2.useCallback)((event) => {
      if (readOnly || state.isUpdatingSelection || !hasEditableTarget(editor, event.target) || isEventHandled(event, attributes.onBlur)) {
        return;
      }
      var root6 = ReactEditor.findDocumentOrShadowRoot(editor);
      if (state.latestElement === root6.activeElement) {
        return;
      }
      var {
        relatedTarget
      } = event;
      var el = ReactEditor.toDOMNode(editor, editor);
      if (relatedTarget === el) {
        return;
      }
      if (isDOMElement(relatedTarget) && relatedTarget.hasAttribute("data-slate-spacer")) {
        return;
      }
      if (relatedTarget != null && isDOMNode(relatedTarget) && ReactEditor.hasDOMNode(editor, relatedTarget)) {
        var node = ReactEditor.toSlateNode(editor, relatedTarget);
        if (Element2.isElement(node) && !editor.isVoid(node)) {
          return;
        }
      }
      IS_FOCUSED.delete(editor);
    }, [readOnly, attributes.onBlur]),
    onClick: (0, import_react2.useCallback)((event) => {
      if (!readOnly && hasTarget(editor, event.target) && !isEventHandled(event, attributes.onClick) && isDOMNode(event.target)) {
        var node = ReactEditor.toSlateNode(editor, event.target);
        var path = ReactEditor.findPath(editor, node);
        if (Editor.hasPath(editor, path)) {
          var lookupNode = Node2.get(editor, path);
          if (lookupNode === node) {
            var _start = Editor.start(editor, path);
            var end2 = Editor.end(editor, path);
            var startVoid = Editor.void(editor, {
              at: _start
            });
            var endVoid = Editor.void(editor, {
              at: end2
            });
            if (startVoid && endVoid && Path.equals(startVoid[1], endVoid[1])) {
              var range = Editor.range(editor, _start);
              Transforms.select(editor, range);
            }
          }
        }
      }
    }, [readOnly, attributes.onClick]),
    onCompositionEnd: (0, import_react2.useCallback)((event) => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionEnd)) {
        scheduleOnDOMSelectionChange.flush();
        setTimeout(() => {
          state.isComposing && setIsComposing(false);
          state.isComposing = false;
          IS_COMPOSING.set(editor, false);
          IS_ON_COMPOSITION_END.set(editor, true);
          var insertedText = EDITOR_ON_COMPOSITION_TEXT.get(editor) || [];
          if (!insertedText.length) {
            return;
          }
          EDITOR_ON_COMPOSITION_TEXT.set(editor, []);
          var {
            selection
          } = editor;
          insertedText.forEach((insertion) => {
            var text = insertion.text.insertText;
            var at = normalizeTextInsertionRange(editor, selection, insertion);
            Transforms.setSelection(editor, at);
            Editor.insertText(editor, text);
          });
        }, RESOLVE_DELAY);
      }
    }, [attributes.onCompositionEnd]),
    onCompositionUpdate: (0, import_react2.useCallback)((event) => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionUpdate)) {
        !state.isComposing && setIsComposing(true);
        state.isComposing = true;
        IS_COMPOSING.set(editor, true);
      }
    }, [attributes.onCompositionUpdate]),
    onCompositionStart: (0, import_react2.useCallback)((event) => {
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onCompositionStart)) {
        !state.isComposing && setIsComposing(true);
        state.isComposing = true;
        IS_COMPOSING.set(editor, true);
      }
    }, [attributes.onCompositionStart]),
    onPaste: (0, import_react2.useCallback)((event) => {
      event.clipboardData = getClipboardData(event.clipboardData);
      if (hasEditableTarget(editor, event.target) && !isEventHandled(event, attributes.onPaste) && !readOnly) {
        event.preventDefault();
        ReactEditor.insertData(editor, event.clipboardData);
      }
    }, [readOnly, attributes.onPaste])
  }), useChildren({
    decorations,
    node: editor,
    renderElement,
    renderPlaceholder,
    renderLeaf,
    selection: editor.selection
  }))));
};
var FocusedContext = (0, import_react2.createContext)(false);
var SlateSelectorContext = (0, import_react2.createContext)({});
function getSelectorContext(editor) {
  var eventListeners = (0, import_react2.useRef)([]).current;
  var slateRef = (0, import_react2.useRef)({
    editor
  }).current;
  var onChange = (0, import_react2.useCallback)((editor2) => {
    slateRef.editor = editor2;
    eventListeners.forEach((listener) => listener(editor2));
  }, []);
  var selectorContext = (0, import_react2.useMemo)(() => {
    return {
      getSlate: () => slateRef.editor,
      addEventListener: (callback) => {
        eventListeners.push(callback);
        return () => {
          eventListeners.splice(eventListeners.indexOf(callback), 1);
        };
      }
    };
  }, [eventListeners, slateRef]);
  return {
    selectorContext,
    onChange
  };
}
var _excluded3 = ["editor", "children", "onChange", "value"];
var Slate = (props) => {
  var {
    editor,
    children,
    onChange,
    value
  } = props, rest = _objectWithoutProperties2(props, _excluded3);
  var unmountRef = (0, import_react2.useRef)(false);
  var [context, setContext] = import_react2.default.useState(() => {
    if (!Node2.isNodeList(value)) {
      throw new Error("[Slate] value is invalid! Expected a list of elements" + "but got: ".concat(Scrubber.stringify(value)));
    }
    if (!Editor.isEditor(editor)) {
      throw new Error("[Slate] editor is invalid! you passed:" + "".concat(Scrubber.stringify(editor)));
    }
    editor.children = value;
    Object.assign(editor, rest);
    return [editor];
  });
  var {
    selectorContext,
    onChange: handleSelectorChange
  } = getSelectorContext(editor);
  var onContextChange = (0, import_react2.useCallback)(() => {
    if (onChange) {
      onChange(editor.children);
    }
    setContext([editor]);
    handleSelectorChange(editor);
  }, [onChange]);
  EDITOR_TO_ON_CHANGE.set(editor, onContextChange);
  (0, import_react2.useEffect)(() => {
    return () => {
      EDITOR_TO_ON_CHANGE.set(editor, () => {
      });
      unmountRef.current = true;
    };
  }, []);
  var [isFocused, setIsFocused] = (0, import_react2.useState)(ReactEditor.isFocused(editor));
  (0, import_react2.useEffect)(() => {
    setIsFocused(ReactEditor.isFocused(editor));
  });
  useIsomorphicLayoutEffect(() => {
    var fn2 = () => setIsFocused(ReactEditor.isFocused(editor));
    if (IS_REACT_VERSION_17_OR_ABOVE) {
      document.addEventListener("focusin", fn2);
      document.addEventListener("focusout", fn2);
      return () => {
        document.removeEventListener("focusin", fn2);
        document.removeEventListener("focusout", fn2);
      };
    } else {
      document.addEventListener("focus", fn2, true);
      document.addEventListener("blur", fn2, true);
      return () => {
        document.removeEventListener("focus", fn2, true);
        document.removeEventListener("blur", fn2, true);
      };
    }
  }, []);
  return import_react2.default.createElement(SlateSelectorContext.Provider, {
    value: selectorContext
  }, import_react2.default.createElement(SlateContext.Provider, {
    value: context
  }, import_react2.default.createElement(EditorContext.Provider, {
    value: editor
  }, import_react2.default.createElement(FocusedContext.Provider, {
    value: isFocused
  }, children))));
};
var doRectsIntersect = (rect, compareRect) => {
  var middle = (compareRect.top + compareRect.bottom) / 2;
  return rect.top <= middle && rect.bottom >= middle;
};
var areRangesSameLine = (editor, range1, range2) => {
  var rect1 = ReactEditor.toDOMRange(editor, range1).getBoundingClientRect();
  var rect2 = ReactEditor.toDOMRange(editor, range2).getBoundingClientRect();
  return doRectsIntersect(rect1, rect2) && doRectsIntersect(rect2, rect1);
};
var findCurrentLineRange = (editor, parentRange) => {
  var parentRangeBoundary = Editor.range(editor, Range.end(parentRange));
  var positions = Array.from(Editor.positions(editor, {
    at: parentRange
  }));
  var left = 0;
  var right = positions.length;
  var middle = Math.floor(right / 2);
  if (areRangesSameLine(editor, Editor.range(editor, positions[left]), parentRangeBoundary)) {
    return Editor.range(editor, positions[left], parentRangeBoundary);
  }
  if (positions.length < 2) {
    return Editor.range(editor, positions[positions.length - 1], parentRangeBoundary);
  }
  while (middle !== positions.length && middle !== left) {
    if (areRangesSameLine(editor, Editor.range(editor, positions[middle]), parentRangeBoundary)) {
      right = middle;
    } else {
      left = middle;
    }
    middle = Math.floor((left + right) / 2);
  }
  return Editor.range(editor, positions[right], parentRangeBoundary);
};
var withReact = (editor) => {
  var e9 = editor;
  var {
    apply: apply5,
    onChange,
    deleteBackward: deleteBackward2
  } = e9;
  EDITOR_TO_KEY_TO_ELEMENT.set(e9, /* @__PURE__ */ new WeakMap());
  e9.deleteBackward = (unit) => {
    if (unit !== "line") {
      return deleteBackward2(unit);
    }
    if (editor.selection && Range.isCollapsed(editor.selection)) {
      var parentBlockEntry = Editor.above(editor, {
        match: (n12) => Editor.isBlock(editor, n12),
        at: editor.selection
      });
      if (parentBlockEntry) {
        var [, parentBlockPath] = parentBlockEntry;
        var parentElementRange = Editor.range(editor, parentBlockPath, editor.selection.anchor);
        var currentLineRange = findCurrentLineRange(e9, parentElementRange);
        if (!Range.isCollapsed(currentLineRange)) {
          Transforms.delete(editor, {
            at: currentLineRange
          });
        }
      }
    }
  };
  e9.apply = (op) => {
    var matches = [];
    switch (op.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        matches.push(...getMatches(e9, op.path));
        break;
      }
      case "set_selection": {
        var _EDITOR_TO_USER_SELEC;
        (_EDITOR_TO_USER_SELEC = EDITOR_TO_USER_SELECTION.get(editor)) === null || _EDITOR_TO_USER_SELEC === void 0 ? void 0 : _EDITOR_TO_USER_SELEC.unref();
        EDITOR_TO_USER_SELECTION.delete(editor);
        break;
      }
      case "insert_node":
      case "remove_node": {
        matches.push(...getMatches(e9, Path.parent(op.path)));
        break;
      }
      case "merge_node": {
        var prevPath = Path.previous(op.path);
        matches.push(...getMatches(e9, prevPath));
        break;
      }
      case "move_node": {
        var commonPath = Path.common(Path.parent(op.path), Path.parent(op.newPath));
        matches.push(...getMatches(e9, commonPath));
        break;
      }
    }
    apply5(op);
    for (var [path, key] of matches) {
      var [node] = Editor.node(e9, path);
      NODE_TO_KEY.set(node, key);
    }
  };
  e9.setFragmentData = (data) => {
    var {
      selection
    } = e9;
    if (!selection) {
      return;
    }
    var [start3, end2] = Range.edges(selection);
    var startVoid = Editor.void(e9, {
      at: start3.path
    });
    var endVoid = Editor.void(e9, {
      at: end2.path
    });
    if (Range.isCollapsed(selection) && !startVoid) {
      return;
    }
    var domRange = ReactEditor.toDOMRange(e9, selection);
    var contents = domRange.cloneContents();
    var attach = contents.childNodes[0];
    contents.childNodes.forEach((node) => {
      if (node.textContent && node.textContent.trim() !== "") {
        attach = node;
      }
    });
    if (endVoid) {
      var [voidNode] = endVoid;
      var r15 = domRange.cloneRange();
      var domNode = ReactEditor.toDOMNode(e9, voidNode);
      r15.setEndAfter(domNode);
      contents = r15.cloneContents();
    }
    if (startVoid) {
      attach = contents.querySelector("[data-slate-spacer]");
    }
    Array.from(contents.querySelectorAll("[data-slate-zero-width]")).forEach((zw) => {
      var isNewline = zw.getAttribute("data-slate-zero-width") === "n";
      zw.textContent = isNewline ? "\n" : "";
    });
    if (isDOMText(attach)) {
      var span = attach.ownerDocument.createElement("span");
      span.style.whiteSpace = "pre";
      span.appendChild(attach);
      contents.appendChild(span);
      attach = span;
    }
    var fragment = e9.getFragment();
    var string2 = JSON.stringify(fragment);
    var encoded = window.btoa(encodeURIComponent(string2));
    attach.setAttribute("data-slate-fragment", encoded);
    data.setData("application/x-slate-fragment", encoded);
    var div = contents.ownerDocument.createElement("div");
    div.appendChild(contents);
    div.setAttribute("hidden", "true");
    contents.ownerDocument.body.appendChild(div);
    data.setData("text/html", div.innerHTML);
    data.setData("text/plain", getPlainText(div));
    contents.ownerDocument.body.removeChild(div);
    return data;
  };
  e9.insertData = (data) => {
    if (!e9.insertFragmentData(data)) {
      e9.insertTextData(data);
    }
  };
  e9.insertFragmentData = (data) => {
    var fragment = data.getData("application/x-slate-fragment") || getSlateFragmentAttribute(data);
    if (fragment) {
      var decoded = decodeURIComponent(window.atob(fragment));
      var parsed = JSON.parse(decoded);
      e9.insertFragment(parsed);
      return true;
    }
    return false;
  };
  e9.insertTextData = (data) => {
    var text = data.getData("text/plain");
    if (text) {
      var lines = text.split(/\r\n|\r|\n/);
      var split2 = false;
      for (var line of lines) {
        if (split2) {
          Transforms.splitNodes(e9, {
            always: true
          });
        }
        e9.insertText(line);
        split2 = true;
      }
      return true;
    }
    return false;
  };
  e9.onChange = () => {
    import_react_dom.default.unstable_batchedUpdates(() => {
      var onContextChange = EDITOR_TO_ON_CHANGE.get(e9);
      if (onContextChange) {
        onContextChange();
      }
      onChange();
    });
  };
  return e9;
};
var getMatches = (e9, path) => {
  var matches = [];
  for (var [n12, p12] of Editor.levels(e9, {
    at: path
  })) {
    var key = ReactEditor.findKey(e9, n12);
    matches.push([p12, key]);
  }
  return matches;
};
var Editable = IS_ANDROID ? AndroidEditable : Editable$1;

// node_modules/react-tracked/dist/index.modern.js
var import_react4 = __toESM(require_react());

// node_modules/use-context-selector/dist/index.modern.js
var import_react3 = __toESM(require_react());
var import_scheduler = __toESM(require_scheduler());
var import_react_dom2 = __toESM(require_react_dom());
var d2 = Symbol();
var f2 = Symbol();
var v2 = "undefined" == typeof window || /ServerSideRendering/.test(window.navigator && window.navigator.userAgent) ? import_react3.useEffect : import_react3.useLayoutEffect;

// node_modules/proxy-compare/dist/index.modern.js
var e3 = Symbol();
var t4 = Symbol();
var r4 = "a";
var n5 = "w";
var o3 = (e9, t20) => new Proxy(e9, t20);
var s3 = Object.getPrototypeOf;
var c3 = /* @__PURE__ */ new WeakMap();
var l3 = (e9) => e9 && (c3.has(e9) ? c3.get(e9) : s3(e9) === Object.prototype || s3(e9) === Array.prototype);
var f3 = (e9) => "object" == typeof e9 && null !== e9;
var i4 = /* @__PURE__ */ new WeakMap();
var a2 = (e9) => e9[t4] || e9;
var u3 = (c16, f16, p12) => {
  if (!l3(c16))
    return c16;
  const y9 = a2(c16), g6 = ((e9) => Object.isFrozen(e9) || Object.values(Object.getOwnPropertyDescriptors(e9)).some((e10) => !e10.writable))(y9);
  let h11 = p12 && p12.get(y9);
  return h11 && h11[1].f === g6 || (h11 = ((o16, s20) => {
    const c17 = { f: s20 };
    let l14 = false;
    const f17 = (e9, t20) => {
      if (!l14) {
        let s21 = c17[r4].get(o16);
        if (s21 || (s21 = {}, c17[r4].set(o16, s21)), e9 === n5)
          s21[n5] = true;
        else {
          let r15 = s21[e9];
          r15 || (r15 = /* @__PURE__ */ new Set(), s21[e9] = r15), r15.add(t20);
        }
      }
    }, i15 = { get: (e9, n12) => n12 === t4 ? o16 : (f17("k", n12), u3(Reflect.get(e9, n12), c17[r4], c17.c)), has: (t20, n12) => n12 === e3 ? (l14 = true, c17[r4].delete(o16), true) : (f17("h", n12), Reflect.has(t20, n12)), getOwnPropertyDescriptor: (e9, t20) => (f17("o", t20), Reflect.getOwnPropertyDescriptor(e9, t20)), ownKeys: (e9) => (f17(n5), Reflect.ownKeys(e9)) };
    return s20 && (i15.set = i15.deleteProperty = () => false), [i15, c17];
  })(y9, g6), h11[1].p = o3(g6 ? ((e9) => {
    let t20 = i4.get(e9);
    if (!t20) {
      if (Array.isArray(e9))
        t20 = Array.from(e9);
      else {
        const r15 = Object.getOwnPropertyDescriptors(e9);
        Object.values(r15).forEach((e10) => {
          e10.configurable = true;
        }), t20 = Object.create(s3(e9), r15);
      }
      i4.set(e9, t20);
    }
    return t20;
  })(y9) : y9, h11[0]), p12 && p12.set(y9, h11)), h11[1][r4] = f16, h11[1].c = p12, h11[1].p;
};
var p3 = (e9, t20, r15, o16) => {
  if (Object.is(e9, t20))
    return false;
  if (!f3(e9) || !f3(t20))
    return true;
  const s20 = r15.get(a2(e9));
  if (!s20)
    return true;
  if (o16) {
    const r16 = o16.get(e9);
    if (r16 && r16.n === t20)
      return r16.g;
    o16.set(e9, { n: t20, g: false });
  }
  let c16 = null;
  try {
    for (const r16 of s20.h || [])
      if (c16 = Reflect.has(e9, r16) !== Reflect.has(t20, r16), c16)
        return c16;
    if (true === s20[n5]) {
      if (c16 = ((e10, t21) => {
        const r16 = Reflect.ownKeys(e10), n12 = Reflect.ownKeys(t21);
        return r16.length !== n12.length || r16.some((e11, t22) => e11 !== n12[t22]);
      })(e9, t20), c16)
        return c16;
    } else
      for (const r16 of s20.o || [])
        if (c16 = !!Reflect.getOwnPropertyDescriptor(e9, r16) != !!Reflect.getOwnPropertyDescriptor(t20, r16), c16)
          return c16;
    for (const n12 of s20.k || [])
      if (c16 = p3(e9[n12], t20[n12], r15, o16), c16)
        return c16;
    return null === c16 && (c16 = true), c16;
  } finally {
    o16 && o16.set(e9, { n: t20, g: c16 });
  }
};
var w2 = (e9, t20, r15) => {
  const o16 = [], s20 = /* @__PURE__ */ new WeakSet(), c16 = (e10, l14) => {
    if (s20.has(e10))
      return;
    f3(e10) && s20.add(e10);
    const i15 = f3(e10) && t20.get(a2(e10));
    if (i15) {
      var u11, p12;
      if (null == (u11 = i15.h) || u11.forEach((e11) => {
        const t21 = `:has(${String(e11)})`;
        o16.push(l14 ? [...l14, t21] : [t21]);
      }), true === i15[n5]) {
        const e11 = ":ownKeys";
        o16.push(l14 ? [...l14, e11] : [e11]);
      } else {
        var y9;
        null == (y9 = i15.o) || y9.forEach((e11) => {
          const t21 = `:hasOwn(${String(e11)})`;
          o16.push(l14 ? [...l14, t21] : [t21]);
        });
      }
      null == (p12 = i15.k) || p12.forEach((t21) => {
        r15 && !("value" in (Object.getOwnPropertyDescriptor(e10, t21) || {})) || c16(e10[t21], l14 ? [...l14, t21] : [t21]);
      });
    } else
      l14 && o16.push(l14);
  };
  return c16(e9), o16;
};

// node_modules/react-tracked/dist/index.modern.js
var useAffectedDebugValue = (state, affected) => {
  const pathList = (0, import_react4.useRef)();
  (0, import_react4.useEffect)(() => {
    pathList.current = w2(state, affected);
  });
  (0, import_react4.useDebugValue)(state);
};
var createTrackedSelector = (useSelector2) => {
  const useTrackedSelector = () => {
    const [, forceUpdate] = (0, import_react4.useReducer)((c16) => c16 + 1, 0);
    const affected = /* @__PURE__ */ new WeakMap();
    const lastAffected = (0, import_react4.useRef)();
    const prevState = (0, import_react4.useRef)();
    const lastState = (0, import_react4.useRef)();
    (0, import_react4.useEffect)(() => {
      lastAffected.current = affected;
      if (prevState.current !== lastState.current && p3(prevState.current, lastState.current, affected, /* @__PURE__ */ new WeakMap())) {
        prevState.current = lastState.current;
        forceUpdate();
      }
    });
    const selector = (0, import_react4.useCallback)((nextState) => {
      lastState.current = nextState;
      if (prevState.current && prevState.current !== nextState && lastAffected.current && !p3(prevState.current, nextState, lastAffected.current, /* @__PURE__ */ new WeakMap())) {
        return prevState.current;
      }
      prevState.current = nextState;
      return nextState;
    }, []);
    const state = useSelector2(selector);
    if (typeof process === "object" && true) {
      useAffectedDebugValue(state, affected);
    }
    const proxyCache = (0, import_react4.useMemo)(() => /* @__PURE__ */ new WeakMap(), []);
    return u3(state, affected, proxyCache);
  };
  return useTrackedSelector;
};

// node_modules/zustand/esm/index.js
var import_react5 = __toESM(require_react());
function createStore2(createState) {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (nextState !== state) {
      const previousState = state;
      state = replace ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState2 = () => state;
  const subscribeWithSelector = (listener, selector = getState2, equalityFn = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let currentSlice = selector(state);
    function listenerToAdd() {
      const nextSlice = selector(state);
      if (!equalityFn(currentSlice, nextSlice)) {
        const previousSlice = currentSlice;
        listener(currentSlice = nextSlice, previousSlice);
      }
    }
    listeners.add(listenerToAdd);
    return () => listeners.delete(listenerToAdd);
  };
  const subscribe = (listener, selector, equalityFn) => {
    if (selector || equalityFn) {
      return subscribeWithSelector(listener, selector, equalityFn);
    }
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => listeners.clear();
  const api = { setState, getState: getState2, subscribe, destroy };
  state = createState(setState, getState2, api);
  return api;
}
var isSSR = typeof window === "undefined" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent);
var useIsomorphicLayoutEffect2 = isSSR ? import_react5.useEffect : import_react5.useLayoutEffect;
function create2(createState) {
  const api = typeof createState === "function" ? createStore2(createState) : createState;
  const useStore2 = (selector = api.getState, equalityFn = Object.is) => {
    const [, forceUpdate] = (0, import_react5.useReducer)((c16) => c16 + 1, 0);
    const state = api.getState();
    const stateRef = (0, import_react5.useRef)(state);
    const selectorRef = (0, import_react5.useRef)(selector);
    const equalityFnRef = (0, import_react5.useRef)(equalityFn);
    const erroredRef = (0, import_react5.useRef)(false);
    const currentSliceRef = (0, import_react5.useRef)();
    if (currentSliceRef.current === void 0) {
      currentSliceRef.current = selector(state);
    }
    let newStateSlice;
    let hasNewStateSlice = false;
    if (stateRef.current !== state || selectorRef.current !== selector || equalityFnRef.current !== equalityFn || erroredRef.current) {
      newStateSlice = selector(state);
      hasNewStateSlice = !equalityFn(currentSliceRef.current, newStateSlice);
    }
    useIsomorphicLayoutEffect2(() => {
      if (hasNewStateSlice) {
        currentSliceRef.current = newStateSlice;
      }
      stateRef.current = state;
      selectorRef.current = selector;
      equalityFnRef.current = equalityFn;
      erroredRef.current = false;
    });
    const stateBeforeSubscriptionRef = (0, import_react5.useRef)(state);
    useIsomorphicLayoutEffect2(() => {
      const listener = () => {
        try {
          const nextState = api.getState();
          const nextStateSlice = selectorRef.current(nextState);
          if (!equalityFnRef.current(currentSliceRef.current, nextStateSlice)) {
            stateRef.current = nextState;
            currentSliceRef.current = nextStateSlice;
            forceUpdate();
          }
        } catch (error2) {
          erroredRef.current = true;
          forceUpdate();
        }
      };
      const unsubscribe = api.subscribe(listener);
      if (api.getState() !== stateBeforeSubscriptionRef.current) {
        listener();
      }
      return unsubscribe;
    }, []);
    const sliceToReturn = hasNewStateSlice ? newStateSlice : currentSliceRef.current;
    (0, import_react5.useDebugValue)(sliceToReturn);
    return sliceToReturn;
  };
  Object.assign(useStore2, api);
  useStore2[Symbol.iterator] = function() {
    console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
    const items = [useStore2, api];
    return {
      next() {
        const done = items.length <= 0;
        return { value: items.shift(), done };
      }
    };
  };
  return useStore2;
}

// node_modules/zustand/esm/middleware.js
function devtools(fn2, options) {
  return (set3, get8, api) => {
    var _a;
    let didWarnAboutNameDeprecation = false;
    if (typeof options === "string" && !didWarnAboutNameDeprecation) {
      console.warn("[zustand devtools middleware]: passing `name` as directly will be not allowed in next majorpass the `name` in an object `{ name: ... }` instead");
      didWarnAboutNameDeprecation = true;
    }
    const devtoolsOptions = options === void 0 ? { name: void 0, anonymousActionType: void 0 } : typeof options === "string" ? { name: options } : options;
    if (typeof ((_a = devtoolsOptions == null ? void 0 : devtoolsOptions.serialize) == null ? void 0 : _a.options) !== "undefined") {
      console.warn("[zustand devtools middleware]: `serialize.options` is deprecated, just use `serialize`");
    }
    let extensionConnector;
    try {
      extensionConnector = window.__REDUX_DEVTOOLS_EXTENSION__ || window.top.__REDUX_DEVTOOLS_EXTENSION__;
    } catch {
    }
    if (!extensionConnector) {
      if ((import.meta.env && import.meta.env.MODE) !== "production" && typeof window !== "undefined") {
        console.warn("[zustand devtools middleware] Please install/enable Redux devtools extension");
      }
      return fn2(set3, get8, api);
    }
    let extension = Object.create(extensionConnector.connect(devtoolsOptions));
    let didWarnAboutDevtools = false;
    Object.defineProperty(api, "devtools", {
      get: () => {
        if (!didWarnAboutDevtools) {
          console.warn("[zustand devtools middleware] `devtools` property on the store is deprecated it will be removed in the next major.\nYou shouldn't interact with the extension directly. But in case you still want to you can patch `window.__REDUX_DEVTOOLS_EXTENSION__` directly");
          didWarnAboutDevtools = true;
        }
        return extension;
      },
      set: (value) => {
        if (!didWarnAboutDevtools) {
          console.warn("[zustand devtools middleware] `api.devtools` is deprecated, it will be removed in the next major.\nYou shouldn't interact with the extension directly. But in case you still want to you can patch `window.__REDUX_DEVTOOLS_EXTENSION__` directly");
          didWarnAboutDevtools = true;
        }
        extension = value;
      }
    });
    let didWarnAboutPrefix = false;
    Object.defineProperty(extension, "prefix", {
      get: () => {
        if (!didWarnAboutPrefix) {
          console.warn("[zustand devtools middleware] along with `api.devtools`, `api.devtools.prefix` is deprecated.\nWe no longer prefix the actions/names" + devtoolsOptions.name === void 0 ? ", pass the `name` option to create a separate instance of devtools for each store." : ", because the `name` option already creates a separate instance of devtools for each store.");
          didWarnAboutPrefix = true;
        }
        return "";
      },
      set: () => {
        if (!didWarnAboutPrefix) {
          console.warn("[zustand devtools middleware] along with `api.devtools`, `api.devtools.prefix` is deprecated.\nWe no longer prefix the actions/names" + devtoolsOptions.name === void 0 ? ", pass the `name` option to create a separate instance of devtools for each store." : ", because the `name` option already creates a separate instance of devtools for each store.");
          didWarnAboutPrefix = true;
        }
      }
    });
    let isRecording = true;
    api.setState = (state, replace, nameOrAction) => {
      set3(state, replace);
      if (!isRecording)
        return;
      extension.send(nameOrAction === void 0 ? { type: devtoolsOptions.anonymousActionType || "anonymous" } : typeof nameOrAction === "string" ? { type: nameOrAction } : nameOrAction, get8());
    };
    const setStateFromDevtools = (...a13) => {
      const originalIsRecording = isRecording;
      isRecording = false;
      set3(...a13);
      isRecording = originalIsRecording;
    };
    const initialState2 = fn2(api.setState, get8, api);
    extension.init(initialState2);
    if (api.dispatchFromDevtools && typeof api.dispatch === "function") {
      let didWarnAboutReservedActionType = false;
      const originalDispatch = api.dispatch;
      api.dispatch = (...a13) => {
        if (a13[0].type === "__setState" && !didWarnAboutReservedActionType) {
          console.warn('[zustand devtools middleware] "__setState" action type is reserved to set state from the devtools. Avoid using it.');
          didWarnAboutReservedActionType = true;
        }
        originalDispatch(...a13);
      };
    }
    extension.subscribe((message) => {
      var _a2;
      switch (message.type) {
        case "ACTION":
          if (typeof message.payload !== "string") {
            console.error("[zustand devtools middleware] Unsupported action format");
            return;
          }
          return parseJsonThen(message.payload, (action) => {
            if (action.type === "__setState") {
              setStateFromDevtools(action.state);
              return;
            }
            if (!api.dispatchFromDevtools)
              return;
            if (typeof api.dispatch !== "function")
              return;
            api.dispatch(action);
          });
        case "DISPATCH":
          switch (message.payload.type) {
            case "RESET":
              setStateFromDevtools(initialState2);
              return extension.init(api.getState());
            case "COMMIT":
              return extension.init(api.getState());
            case "ROLLBACK":
              return parseJsonThen(message.state, (state) => {
                setStateFromDevtools(state);
                extension.init(api.getState());
              });
            case "JUMP_TO_STATE":
            case "JUMP_TO_ACTION":
              return parseJsonThen(message.state, (state) => {
                setStateFromDevtools(state);
              });
            case "IMPORT_STATE": {
              const { nextLiftedState } = message.payload;
              const lastComputedState = (_a2 = nextLiftedState.computedStates.slice(-1)[0]) == null ? void 0 : _a2.state;
              if (!lastComputedState)
                return;
              setStateFromDevtools(lastComputedState);
              extension.send(null, nextLiftedState);
              return;
            }
            case "PAUSE_RECORDING":
              return isRecording = !isRecording;
          }
          return;
      }
    });
    return initialState2;
  };
}
var parseJsonThen = (stringified, f16) => {
  let parsed;
  try {
    parsed = JSON.parse(stringified);
  } catch (e9) {
    console.error("[zustand devtools middleware] Could not parse the received json", e9);
  }
  if (parsed !== void 0)
    f16(parsed);
};
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a13, b6) => {
  for (var prop in b6 || (b6 = {}))
    if (__hasOwnProp.call(b6, prop))
      __defNormalProp(a13, prop, b6[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b6)) {
      if (__propIsEnum.call(b6, prop))
        __defNormalProp(a13, prop, b6[prop]);
    }
  return a13;
};
var toThenable = (fn2) => (input) => {
  try {
    const result = fn2(input);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e9) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e9);
      }
    };
  }
};
var persist = (config2, baseOptions) => (set3, get8, api) => {
  let options = __spreadValues({
    getStorage: () => localStorage,
    serialize: JSON.stringify,
    deserialize: JSON.parse,
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => __spreadValues(__spreadValues({}, currentState), persistedState)
  }, baseOptions);
  if (options.blacklist || options.whitelist) {
    console.warn(`The ${options.blacklist ? "blacklist" : "whitelist"} option is deprecated and will be removed in the next version. Please use the 'partialize' option instead.`);
  }
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage;
  try {
    storage = options.getStorage();
  } catch (e9) {
  }
  if (!storage) {
    return config2((...args) => {
      console.warn(`[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`);
      set3(...args);
    }, get8, api);
  } else if (!storage.removeItem) {
    console.warn(`[zustand persist middleware] The given storage for item '${options.name}' does not contain a 'removeItem' method, which will be required in v4.`);
  }
  const thenableSerialize = toThenable(options.serialize);
  const setItem = () => {
    const state = options.partialize(__spreadValues({}, get8()));
    if (options.whitelist) {
      Object.keys(state).forEach((key) => {
        var _a;
        !((_a = options.whitelist) == null ? void 0 : _a.includes(key)) && delete state[key];
      });
    }
    if (options.blacklist) {
      options.blacklist.forEach((key) => delete state[key]);
    }
    let errorInSync;
    const thenable = thenableSerialize({ state, version: options.version }).then((serializedValue) => storage.setItem(options.name, serializedValue)).catch((e9) => {
      errorInSync = e9;
    });
    if (errorInSync) {
      throw errorInSync;
    }
    return thenable;
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config2((...args) => {
    set3(...args);
    void setItem();
  }, get8, api);
  let stateFromStorage;
  const hydrate = () => {
    var _a;
    if (!storage)
      return;
    hasHydrated = false;
    hydrationListeners.forEach((cb) => cb(get8()));
    const postRehydrationCallback = ((_a = options.onRehydrateStorage) == null ? void 0 : _a.call(options, get8())) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((storageValue) => {
      if (storageValue) {
        return options.deserialize(storageValue);
      }
    }).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return options.migrate(deserializedStorageValue.state, deserializedStorageValue.version);
          }
          console.error(`State loaded from storage couldn't be migrated since no migrate function was provided`);
        } else {
          return deserializedStorageValue.state;
        }
      }
    }).then((migratedState) => {
      var _a2;
      stateFromStorage = options.merge(migratedState, (_a2 = get8()) != null ? _a2 : configResult);
      set3(stateFromStorage, true);
      return setItem();
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      hasHydrated = true;
      finishHydrationListeners.forEach((cb) => cb(stateFromStorage));
    }).catch((e9) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e9);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = __spreadValues(__spreadValues({}, options), newOptions);
      if (newOptions.getStorage) {
        storage = newOptions.getStorage();
      }
    },
    clearStorage: () => {
      var _a;
      (_a = storage == null ? void 0 : storage.removeItem) == null ? void 0 : _a.call(storage, options.name);
    },
    rehydrate: () => hydrate(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb) => {
      hydrationListeners.add(cb);
      return () => {
        hydrationListeners.delete(cb);
      };
    },
    onFinishHydration: (cb) => {
      finishHydrationListeners.add(cb);
      return () => {
        finishHydrationListeners.delete(cb);
      };
    }
  };
  hydrate();
  return stateFromStorage || configResult;
};

// node_modules/zustand/esm/vanilla.js
function createStore3(createState) {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (nextState !== state) {
      const previousState = state;
      state = replace ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState2 = () => state;
  const subscribeWithSelector = (listener, selector = getState2, equalityFn = Object.is) => {
    console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
    let currentSlice = selector(state);
    function listenerToAdd() {
      const nextSlice = selector(state);
      if (!equalityFn(currentSlice, nextSlice)) {
        const previousSlice = currentSlice;
        listener(currentSlice = nextSlice, previousSlice);
      }
    }
    listeners.add(listenerToAdd);
    return () => listeners.delete(listenerToAdd);
  };
  const subscribe = (listener, selector, equalityFn) => {
    if (selector || equalityFn) {
      return subscribeWithSelector(listener, selector, equalityFn);
    }
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const destroy = () => listeners.clear();
  const api = { setState, getState: getState2, subscribe, destroy };
  state = createState(setState, getState2, api);
  return api;
}

// node_modules/@udecode/zustood/dist/index.es.js
var generateStateActions = (store, storeName) => {
  const actions = {};
  Object.keys(store.getState()).forEach((key) => {
    actions[key] = (value) => {
      const prevValue = store.getState()[key];
      if (prevValue === value)
        return;
      const actionKey = key.replace(/^\S/, (s20) => s20.toUpperCase());
      store.setState((draft) => {
        draft[key] = value;
      }, `@@${storeName}/set${actionKey}`);
    };
  });
  return actions;
};
var extendActions = (builder, api) => {
  const actions = builder(api.set, api.get, api);
  return {
    ...api,
    set: {
      ...api.set,
      ...actions
    }
  };
};
var extendSelectors = (builder, api) => {
  const use = {
    ...api.use
  };
  const useTracked = {
    ...api.useTracked
  };
  const get8 = {
    ...api.get
  };
  Object.keys(builder(api.store.getState(), api.get, api)).forEach((key) => {
    use[key] = (...args) => api.useStore((state) => {
      const selectors = builder(state, api.get, api);
      const selector = selectors[key];
      return selector(...args);
    });
    useTracked[key] = (...args) => {
      const trackedState = api.useTrackedStore();
      const selectors = builder(trackedState, api.get, api);
      const selector = selectors[key];
      return selector(...args);
    };
    get8[key] = (...args) => {
      const selectors = builder(api.store.getState(), api.get, api);
      const selector = selectors[key];
      return selector(...args);
    };
  });
  return {
    ...api,
    get: get8,
    use,
    useTracked
  };
};
var storeFactory = (api) => {
  return {
    ...api,
    extendSelectors: (builder) => storeFactory(extendSelectors(builder, api)),
    extendActions: (builder) => storeFactory(extendActions(builder, api))
  };
};
var generateStateGetSelectors = (store) => {
  const selectors = {};
  Object.keys(store.getState()).forEach((key) => {
    selectors[key] = () => store.getState()[key];
  });
  return selectors;
};
var generateStateHookSelectors = (store) => {
  const selectors = {};
  Object.keys(store.getState()).forEach((key) => {
    selectors[key] = (equalityFn) => {
      return store((state) => state[key], equalityFn);
    };
  });
  return selectors;
};
var generateStateTrackedHooksSelectors = (store, trackedStore) => {
  const selectors = {};
  Object.keys(store.getState()).forEach((key) => {
    selectors[key] = () => {
      return trackedStore()[key];
    };
  });
  return selectors;
};
var immerMiddleware = (config2) => (set3, get8, api) => {
  const setState = (fn2, actionName) => set3(immer_esm_default(fn2), true, actionName);
  api.setState = setState;
  return config2(setState, get8, api);
};
function pipe(x7, ...fns) {
  return fns.reduce((y9, fn2) => fn2(y9), x7);
}
var createStore4 = (name2) => (initialState2, options = {}) => {
  var _immer$enabledAutoFre;
  const {
    middlewares: _middlewares = [],
    devtools: devtools$1,
    persist: persist$1,
    immer
  } = options;
  sn((_immer$enabledAutoFre = immer === null || immer === void 0 ? void 0 : immer.enabledAutoFreeze) !== null && _immer$enabledAutoFre !== void 0 ? _immer$enabledAutoFre : false);
  if (immer !== null && immer !== void 0 && immer.enableMapSet) {
    C();
  }
  const middlewares = [immerMiddleware, ..._middlewares];
  if (persist$1 !== null && persist$1 !== void 0 && persist$1.enabled) {
    var _persist$name;
    const options2 = {
      ...persist$1,
      name: (_persist$name = persist$1.name) !== null && _persist$name !== void 0 ? _persist$name : name2
    };
    middlewares.push((config2) => persist(config2, options2));
  }
  if (devtools$1 !== null && devtools$1 !== void 0 && devtools$1.enabled) {
    middlewares.push((config2) => devtools(config2, {
      ...devtools$1,
      name: name2
    }));
  }
  middlewares.push(createStore3);
  const createStore7 = (createState) => pipe(createState, ...middlewares);
  const store = createStore7(() => initialState2);
  const useStore2 = create2(store);
  const stateActions = generateStateActions(useStore2, name2);
  const mergeState = (state, actionName) => {
    store.setState((draft) => {
      Object.assign(draft, state);
    }, actionName || `@@${name2}/mergeState`);
  };
  const setState = (fn2, actionName) => {
    store.setState(fn2, actionName || `@@${name2}/setState`);
  };
  const hookSelectors = generateStateHookSelectors(useStore2);
  const getterSelectors = generateStateGetSelectors(useStore2);
  const useTrackedStore = createTrackedSelector(useStore2);
  const trackedHooksSelectors = generateStateTrackedHooksSelectors(useStore2, useTrackedStore);
  const api = {
    get: {
      state: store.getState,
      ...getterSelectors
    },
    name: name2,
    set: {
      state: setState,
      mergeState,
      ...stateActions
    },
    store,
    use: hookSelectors,
    useTracked: trackedHooksSelectors,
    useStore: useStore2,
    useTrackedStore,
    extendSelectors: () => api,
    extendActions: () => api
  };
  return storeFactory(api);
};
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function createCommonjsModule(fn2, module2) {
  return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
}
var freeGlobal = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root = _freeGlobal || freeSelf || Function("return this")();
var _root = root;
var Symbol2 = _root.Symbol;
var _Symbol = Symbol2;
var objectProto$b = Object.prototype;
var hasOwnProperty$8 = objectProto$b.hasOwnProperty;
var nativeObjectToString$1 = objectProto$b.toString;
var symToStringTag$1 = _Symbol ? _Symbol.toStringTag : void 0;
function getRawTag(value) {
  var isOwn = hasOwnProperty$8.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e9) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag;
var objectProto$a = Object.prototype;
var nativeObjectToString = objectProto$a.toString;
function objectToString(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString;
var nullTag = "[object Null]";
var undefinedTag = "[object Undefined]";
var symToStringTag = _Symbol ? _Symbol.toStringTag : void 0;
function baseGetTag(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? _getRawTag(value) : _objectToString(value);
}
var _baseGetTag = baseGetTag;
function isObject2(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject2;
var asyncTag = "[object AsyncFunction]";
var funcTag$1 = "[object Function]";
var genTag = "[object GeneratorFunction]";
var proxyTag = "[object Proxy]";
function isFunction(value) {
  if (!isObject_1(value)) {
    return false;
  }
  var tag = _baseGetTag(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction;
var coreJsData = _root["__core-js_shared__"];
var _coreJsData = coreJsData;
var maskSrcKey = function() {
  var uid2 = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e9) {
    }
    try {
      return func + "";
    } catch (e9) {
    }
  }
  return "";
}
var _toSource = toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype;
var objectProto$9 = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$7).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative(value) {
  if (!isObject_1(value) || _isMasked(value)) {
    return false;
  }
  var pattern = isFunction_1(value) ? reIsNative : reIsHostCtor;
  return pattern.test(_toSource(value));
}
var _baseIsNative = baseIsNative;
function getValue(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
var _getValue = getValue;
function getNative(object2, key) {
  var value = _getValue(object2, key);
  return _baseIsNative(value) ? value : void 0;
}
var _getNative = getNative;
var defineProperty = function() {
  try {
    var func = _getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e9) {
  }
}();
function createBaseFor(fromRight) {
  return function(object2, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object2;
  };
}
var _createBaseFor = createBaseFor;
var baseFor = _createBaseFor();
function isObjectLike(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike;
var argsTag$2 = "[object Arguments]";
function baseIsArguments(value) {
  return isObjectLike_1(value) && _baseGetTag(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments;
var objectProto$8 = Object.prototype;
var hasOwnProperty$6 = objectProto$8.hasOwnProperty;
var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;
var isArguments = _baseIsArguments(function() {
  return arguments;
}()) ? _baseIsArguments : function(value) {
  return isObjectLike_1(value) && hasOwnProperty$6.call(value, "callee") && !propertyIsEnumerable$1.call(value, "callee");
};
var isArray = Array.isArray;
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
var isBuffer_1 = createCommonjsModule(function(module2, exports2) {
  var freeExports4 = exports2 && !exports2.nodeType && exports2;
  var freeModule4 = freeExports4 && true && module2 && !module2.nodeType && module2;
  var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
  var Buffer3 = moduleExports4 ? _root.Buffer : void 0;
  var nativeIsBuffer2 = Buffer3 ? Buffer3.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer2 || stubFalse_1;
  module2.exports = isBuffer2;
});
var MAX_SAFE_INTEGER = 9007199254740991;
function isLength(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
var isLength_1 = isLength;
var argsTag$1 = "[object Arguments]";
var arrayTag$1 = "[object Array]";
var boolTag$1 = "[object Boolean]";
var dateTag$1 = "[object Date]";
var errorTag$1 = "[object Error]";
var funcTag = "[object Function]";
var mapTag$2 = "[object Map]";
var numberTag$1 = "[object Number]";
var objectTag$2 = "[object Object]";
var regexpTag$1 = "[object RegExp]";
var setTag$2 = "[object Set]";
var stringTag$1 = "[object String]";
var weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag$1 = "[object ArrayBuffer]";
var dataViewTag$2 = "[object DataView]";
var float32Tag = "[object Float32Array]";
var float64Tag = "[object Float64Array]";
var int8Tag = "[object Int8Array]";
var int16Tag = "[object Int16Array]";
var int32Tag = "[object Int32Array]";
var uint8Tag = "[object Uint8Array]";
var uint8ClampedTag = "[object Uint8ClampedArray]";
var uint16Tag = "[object Uint16Array]";
var uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag$1] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$2] = typedArrayTags[dateTag$1] = typedArrayTags[errorTag$1] = typedArrayTags[funcTag] = typedArrayTags[mapTag$2] = typedArrayTags[numberTag$1] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag$1] = typedArrayTags[setTag$2] = typedArrayTags[stringTag$1] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray(value) {
  return isObjectLike_1(value) && isLength_1(value.length) && !!typedArrayTags[_baseGetTag(value)];
}
var _baseIsTypedArray = baseIsTypedArray;
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary;
var _nodeUtil = createCommonjsModule(function(module2, exports2) {
  var freeExports4 = exports2 && !exports2.nodeType && exports2;
  var freeModule4 = freeExports4 && true && module2 && !module2.nodeType && module2;
  var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
  var freeProcess2 = moduleExports4 && _freeGlobal.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule4 && freeModule4.require && freeModule4.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
    } catch (e9) {
    }
  }();
  module2.exports = nodeUtil2;
});
var nodeIsTypedArray = _nodeUtil && _nodeUtil.isTypedArray;
var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;
var objectProto$7 = Object.prototype;
var hasOwnProperty$5 = objectProto$7.hasOwnProperty;
var objectProto$6 = Object.prototype;
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg;
var nativeKeys = _overArg(Object.keys, Object);
var objectProto$5 = Object.prototype;
var hasOwnProperty$4 = objectProto$5.hasOwnProperty;
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear;
function eq(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq;
function assocIndexOf(array2, key) {
  var length = array2.length;
  while (length--) {
    if (eq_1(array2[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete(key) {
  var data = this.__data__, index2 = _assocIndexOf(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete;
function listCacheGet(key) {
  var data = this.__data__, index2 = _assocIndexOf(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet = listCacheGet;
function listCacheHas(key) {
  return _assocIndexOf(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas;
function listCacheSet(key, value) {
  var data = this.__data__, index2 = _assocIndexOf(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet;
function ListCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache.prototype.clear = _listCacheClear;
ListCache.prototype["delete"] = _listCacheDelete;
ListCache.prototype.get = _listCacheGet;
ListCache.prototype.has = _listCacheHas;
ListCache.prototype.set = _listCacheSet;
var _ListCache = ListCache;
function stackClear() {
  this.__data__ = new _ListCache();
  this.size = 0;
}
var _stackClear = stackClear;
function stackDelete(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete;
function stackGet(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet;
function stackHas(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas;
var Map2 = _getNative(_root, "Map");
var _Map = Map2;
var nativeCreate = _getNative(Object, "create");
var _nativeCreate = nativeCreate;
function hashClear() {
  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
  this.size = 0;
}
var _hashClear = hashClear;
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$4 = Object.prototype;
var hasOwnProperty$3 = objectProto$4.hasOwnProperty;
function hashGet(key) {
  var data = this.__data__;
  if (_nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$3.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet;
var objectProto$3 = Object.prototype;
var hasOwnProperty$2 = objectProto$3.hasOwnProperty;
function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate ? data[key] !== void 0 : hasOwnProperty$2.call(data, key);
}
var _hashHas = hashHas;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = _nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet;
function Hash(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash.prototype.clear = _hashClear;
Hash.prototype["delete"] = _hashDelete;
Hash.prototype.get = _hashGet;
Hash.prototype.has = _hashHas;
Hash.prototype.set = _hashSet;
var _Hash = Hash;
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    "hash": new _Hash(),
    "map": new (_Map || _ListCache)(),
    "string": new _Hash()
  };
}
var _mapCacheClear = mapCacheClear;
function isKeyable(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable;
function getMapData(map5, key) {
  var data = map5.__data__;
  return _isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData;
function mapCacheDelete(key) {
  var result = _getMapData(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete;
function mapCacheGet(key) {
  return _getMapData(this, key).get(key);
}
var _mapCacheGet = mapCacheGet;
function mapCacheHas(key) {
  return _getMapData(this, key).has(key);
}
var _mapCacheHas = mapCacheHas;
function mapCacheSet(key, value) {
  var data = _getMapData(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet;
function MapCache(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache.prototype.clear = _mapCacheClear;
MapCache.prototype["delete"] = _mapCacheDelete;
MapCache.prototype.get = _mapCacheGet;
MapCache.prototype.has = _mapCacheHas;
MapCache.prototype.set = _mapCacheSet;
var _MapCache = MapCache;
var LARGE_ARRAY_SIZE = 200;
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof _ListCache) {
    var pairs = data.__data__;
    if (!_Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new _MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet;
function Stack(entries) {
  var data = this.__data__ = new _ListCache(entries);
  this.size = data.size;
}
Stack.prototype.clear = _stackClear;
Stack.prototype["delete"] = _stackDelete;
Stack.prototype.get = _stackGet;
Stack.prototype.has = _stackHas;
Stack.prototype.set = _stackSet;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd;
function setCacheHas(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas;
function SetCache(values3) {
  var index2 = -1, length = values3 == null ? 0 : values3.length;
  this.__data__ = new _MapCache();
  while (++index2 < length) {
    this.add(values3[index2]);
  }
}
SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
SetCache.prototype.has = _setCacheHas;
var Uint8Array2 = _root.Uint8Array;
var symbolProto$1 = _Symbol ? _Symbol.prototype : void 0;
var symbolValueOf = symbolProto$1 ? symbolProto$1.valueOf : void 0;
var objectProto$2 = Object.prototype;
var propertyIsEnumerable = objectProto$2.propertyIsEnumerable;
var objectProto$1 = Object.prototype;
var hasOwnProperty$1 = objectProto$1.hasOwnProperty;
var DataView = _getNative(_root, "DataView");
var _DataView = DataView;
var Promise$1 = _getNative(_root, "Promise");
var _Promise = Promise$1;
var Set2 = _getNative(_root, "Set");
var _Set = Set2;
var WeakMap2 = _getNative(_root, "WeakMap");
var _WeakMap = WeakMap2;
var mapTag = "[object Map]";
var objectTag$1 = "[object Object]";
var promiseTag = "[object Promise]";
var setTag = "[object Set]";
var weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var dataViewCtorString = _toSource(_DataView);
var mapCtorString = _toSource(_Map);
var promiseCtorString = _toSource(_Promise);
var setCtorString = _toSource(_Set);
var weakMapCtorString = _toSource(_WeakMap);
var getTag = _baseGetTag;
if (_DataView && getTag(new _DataView(new ArrayBuffer(1))) != dataViewTag || _Map && getTag(new _Map()) != mapTag || _Promise && getTag(_Promise.resolve()) != promiseTag || _Set && getTag(new _Set()) != setTag || _WeakMap && getTag(new _WeakMap()) != weakMapTag) {
  getTag = function(value) {
    var result = _baseGetTag(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? _toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var objectProto = Object.prototype;
var hasOwnProperty = objectProto.hasOwnProperty;
var FUNC_ERROR_TEXT = "Expected a function";
function memoize(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || _MapCache)();
  return memoized;
}
memoize.Cache = _MapCache;
var memoize_1 = memoize;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped(func) {
  var result = memoize_1(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath = _memoizeCapped(function(string2) {
  var result = [];
  if (string2.charCodeAt(0) === 46) {
    result.push("");
  }
  string2.replace(rePropName, function(match5, number2, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match5);
  });
  return result;
});
var INFINITY$1 = 1 / 0;
var symbolProto = _Symbol ? _Symbol.prototype : void 0;
var symbolToString = symbolProto ? symbolProto.toString : void 0;
var INFINITY = 1 / 0;

// node_modules/slate-history/dist/index.es.js
var History = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(value) {
    return isPlainObject(value) && Array.isArray(value.redos) && Array.isArray(value.undos) && (value.redos.length === 0 || Operation.isOperationList(value.redos[0])) && (value.undos.length === 0 || Operation.isOperationList(value.undos[0]));
  }
};
var SAVING = /* @__PURE__ */ new WeakMap();
var MERGING = /* @__PURE__ */ new WeakMap();
var HistoryEditor = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(value) {
    return History.isHistory(value.history) && Editor.isEditor(value);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(editor) {
    return MERGING.get(editor);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(editor) {
    return SAVING.get(editor);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(editor) {
    editor.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(editor) {
    editor.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(editor, fn2) {
    var prev = HistoryEditor.isMerging(editor);
    MERGING.set(editor, false);
    fn2();
    MERGING.set(editor, prev);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(editor, fn2) {
    var prev = HistoryEditor.isSaving(editor);
    SAVING.set(editor, false);
    fn2();
    SAVING.set(editor, prev);
  }
};
var withHistory = (editor) => {
  var e9 = editor;
  var {
    apply: apply5
  } = e9;
  e9.history = {
    undos: [],
    redos: []
  };
  e9.redo = () => {
    var {
      history
    } = e9;
    var {
      redos
    } = history;
    if (redos.length > 0) {
      var batch2 = redos[redos.length - 1];
      HistoryEditor.withoutSaving(e9, () => {
        Editor.withoutNormalizing(e9, () => {
          for (var op of batch2) {
            e9.apply(op);
          }
        });
      });
      history.redos.pop();
      history.undos.push(batch2);
    }
  };
  e9.undo = () => {
    var {
      history
    } = e9;
    var {
      undos
    } = history;
    if (undos.length > 0) {
      var batch2 = undos[undos.length - 1];
      HistoryEditor.withoutSaving(e9, () => {
        Editor.withoutNormalizing(e9, () => {
          var inverseOps = batch2.map(Operation.inverse).reverse();
          for (var op of inverseOps) {
            e9.apply(op);
          }
        });
      });
      history.redos.push(batch2);
      history.undos.pop();
    }
  };
  e9.apply = (op) => {
    var {
      operations,
      history
    } = e9;
    var {
      undos
    } = history;
    var lastBatch = undos[undos.length - 1];
    var lastOp = lastBatch && lastBatch[lastBatch.length - 1];
    var overwrite = shouldOverwrite(op, lastOp);
    var save = HistoryEditor.isSaving(e9);
    var merge3 = HistoryEditor.isMerging(e9);
    if (save == null) {
      save = shouldSave(op);
    }
    if (save) {
      if (merge3 == null) {
        if (lastBatch == null) {
          merge3 = false;
        } else if (operations.length !== 0) {
          merge3 = true;
        } else {
          merge3 = shouldMerge(op, lastOp) || overwrite;
        }
      }
      if (lastBatch && merge3) {
        if (overwrite) {
          lastBatch.pop();
        }
        lastBatch.push(op);
      } else {
        var batch2 = [op];
        undos.push(batch2);
      }
      while (undos.length > 100) {
        undos.shift();
      }
      if (shouldClear(op)) {
        history.redos = [];
      }
    }
    apply5(op);
  };
  return e9;
};
var shouldMerge = (op, prev) => {
  if (op.type === "set_selection") {
    return true;
  }
  if (prev && op.type === "insert_text" && prev.type === "insert_text" && op.offset === prev.offset + prev.text.length && Path.equals(op.path, prev.path)) {
    return true;
  }
  if (prev && op.type === "remove_text" && prev.type === "remove_text" && op.offset + op.text.length === prev.offset && Path.equals(op.path, prev.path)) {
    return true;
  }
  return false;
};
var shouldSave = (op, prev) => {
  if (op.type === "set_selection" && (op.properties == null || op.newProperties == null)) {
    return false;
  }
  return true;
};
var shouldOverwrite = (op, prev) => {
  if (prev && op.type === "set_selection" && prev.type === "set_selection") {
    return true;
  }
  return false;
};
var shouldClear = (op) => {
  if (op.type === "set_selection") {
    return false;
  }
  return true;
};

// node_modules/clsx/dist/clsx.m.js
function r5(e9) {
  var t20, f16, n12 = "";
  if ("string" == typeof e9 || "number" == typeof e9)
    n12 += e9;
  else if ("object" == typeof e9)
    if (Array.isArray(e9))
      for (t20 = 0; t20 < e9.length; t20++)
        e9[t20] && (f16 = r5(e9[t20])) && (n12 && (n12 += " "), n12 += f16);
    else
      for (t20 in e9)
        e9[t20] && (n12 && (n12 += " "), n12 += t20);
  return n12;
}
function clsx() {
  for (var e9, t20, f16 = 0, n12 = ""; f16 < arguments.length; )
    (e9 = arguments[f16++]) && (t20 = r5(e9)) && (n12 && (n12 += " "), n12 += t20);
  return n12;
}
var clsx_m_default = clsx;

// node_modules/@radix-ui/react-compose-refs/dist/index.module.js
var o4 = __toESM(require_react());
function composeRefs(...o16) {
  return (e9) => o16.forEach((o17) => function(o18, e10) {
    "function" == typeof o18 ? o18(e10) : null != o18 && (o18.current = e10);
  }(o17, e9));
}

// node_modules/@radix-ui/react-slot/dist/index.module.js
var t5 = __toESM(require_react());
var Slot = t5.forwardRef((e9, o16) => {
  const { children: a13, ...s20 } = e9;
  return t5.Children.toArray(a13).some(l4) ? t5.createElement(t5.Fragment, null, t5.Children.map(a13, (e10) => l4(e10) ? t5.createElement(n6, _extends({}, s20, { ref: o16 }), e10.props.children) : e10)) : t5.createElement(n6, _extends({}, s20, { ref: o16 }), a13);
});
Slot.displayName = "Slot";
var n6 = t5.forwardRef((r15, n12) => {
  const { children: l14, ...a13 } = r15;
  return t5.isValidElement(l14) ? t5.cloneElement(l14, { ...o5(a13, l14.props), ref: composeRefs(n12, l14.ref) }) : t5.Children.count(l14) > 1 ? t5.Children.only(null) : null;
});
n6.displayName = "SlotClone";
var Slottable = ({ children: e9 }) => t5.createElement(t5.Fragment, null, e9);
function l4(e9) {
  return t5.isValidElement(e9) && e9.type === Slottable;
}
function o5(e9, t20) {
  const r15 = { ...t20 };
  for (const n12 in t20) {
    const l14 = e9[n12], o16 = t20[n12];
    /^on[A-Z]/.test(n12) ? r15[n12] = (...e10) => {
      null == o16 || o16(...e10), null == l14 || l14(...e10);
    } : "style" === n12 ? r15[n12] = { ...l14, ...o16 } : "className" === n12 && (r15[n12] = [l14, o16].filter(Boolean).join(" "));
  }
  return { ...e9, ...r15 };
}

// node_modules/use-deep-compare/dist-web/index.js
var import_react6 = __toESM(require_react());

// node_modules/use-deep-compare/node_modules/dequal/dist/dequal.mjs
function dequal(foo, bar) {
  var ctor, len;
  if (foo === bar)
    return true;
  if (foo && bar && (ctor = foo.constructor) === bar.constructor) {
    if (ctor === Date)
      return foo.getTime() === bar.getTime();
    if (ctor === RegExp)
      return foo.toString() === bar.toString();
    if (ctor === Array && (len = foo.length) === bar.length) {
      while (len-- && dequal(foo[len], bar[len]))
        ;
      return len === -1;
    }
    if (ctor === Object) {
      if (Object.keys(foo).length !== Object.keys(bar).length)
        return false;
      for (len in foo)
        if (!(len in bar) || !dequal(foo[len], bar[len]))
          return false;
      return true;
    }
  }
  return foo !== foo && bar !== bar;
}

// node_modules/use-deep-compare/dist-web/index.js
function checkDeps(deps, name2) {
  const reactHookName = `React.${name2.replace(/DeepCompare/, "")}`;
  if (!deps || deps.length === 0) {
    throw new Error(`${name2} should not be used with no dependencies. Use ${reactHookName} instead.`);
  }
}
function useDeepCompareMemoize(value) {
  const ref2 = import_react6.default.useRef([]);
  if (!dequal(value, ref2.current)) {
    ref2.current = value;
  }
  return ref2.current;
}
function useDeepCompareEffect(effect, dependencies) {
  if (true) {
    checkDeps(dependencies, "useDeepCompareEffect");
  }
  import_react6.default.useEffect(effect, useDeepCompareMemoize(dependencies));
}
function useDeepCompareMemo(factory, dependencies) {
  if (true) {
    checkDeps(dependencies, "useDeepCompareMemo");
  }
  return import_react6.default.useMemo(factory, useDeepCompareMemoize(dependencies));
}

// node_modules/@udecode/plate-core/dist/index.es.js
var capitalizeFirstLetter = (str = "") => str.length ? str[0].toUpperCase() + str.slice(1) : "";
var getStoreIndex = (name2 = "") => name2.length ? `${name2}Store` : "store";
var getUseStoreIndex = (name2 = "") => `use${capitalizeFirstLetter(name2)}Store`;
var createAtomStore = (initialState2, {
  scope: storeScope,
  initialStore,
  name: name2 = ""
} = {}) => {
  const useInitialStoreIndex = getUseStoreIndex(initialStore === null || initialStore === void 0 ? void 0 : initialStore.name);
  const initialStoreIndex = getStoreIndex(initialStore === null || initialStore === void 0 ? void 0 : initialStore.name);
  const useStoreIndex = getUseStoreIndex(name2);
  const storeIndex = getStoreIndex(name2);
  const getAtoms = initialStore ? initialStore[useInitialStoreIndex]().get : {};
  const setAtoms = initialStore ? initialStore[useInitialStoreIndex]().set : {};
  const useAtoms = initialStore ? initialStore[useInitialStoreIndex]().use : {};
  const atoms = initialStore ? initialStore[initialStoreIndex].atom : {};
  Object.keys(initialState2).forEach((key) => {
    const atomConfig = atom2(initialState2[key]);
    atoms[key] = atomConfig;
    getAtoms[key] = (scope) => {
      return useAtomValue(atomConfig, scope !== null && scope !== void 0 ? scope : storeScope);
    };
    setAtoms[key] = (scope) => {
      return useSetAtom(atomConfig, scope !== null && scope !== void 0 ? scope : storeScope);
    };
    useAtoms[key] = (scope) => {
      return useAtom(atomConfig, scope !== null && scope !== void 0 ? scope : storeScope);
    };
  });
  const api = {
    [useStoreIndex]: () => ({
      get: getAtoms,
      set: setAtoms,
      use: useAtoms
    }),
    [storeIndex]: {
      atom: atoms
    },
    name: name2
  };
  return {
    ...api,
    [storeIndex]: {
      ...api[storeIndex],
      extend: (extendedState, options) => createAtomStore(extendedState, {
        scope: storeScope,
        initialStore: api,
        ...options
      })
    }
  };
};
function _extends2() {
  _extends2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i15 = 1; i15 < arguments.length; i15++) {
      var source = arguments[i15];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends2.apply(this, arguments);
}
var DOM_HANDLERS = [
  // Clipboard Events
  "onCopy",
  "onCopyCapture",
  "onCut",
  "onCutCapture",
  "onPaste",
  "onPasteCapture",
  // Composition Events
  "onCompositionEnd",
  "onCompositionEndCapture",
  "onCompositionStart",
  "onCompositionStartCapture",
  "onCompositionUpdate",
  "onCompositionUpdateCapture",
  // Focus Events
  "onFocus",
  "onFocusCapture",
  "onBlur",
  "onBlurCapture",
  // Form Events
  "onDOMBeforeInput",
  "onBeforeInput",
  "onBeforeInputCapture",
  "onInput",
  "onInputCapture",
  "onReset",
  "onResetCapture",
  "onSubmit",
  "onSubmitCapture",
  "onInvalid",
  "onInvalidCapture",
  // Image Events
  "onLoad",
  "onLoadCapture",
  // Keyboard Events
  "onKeyDown",
  "onKeyDownCapture",
  "onKeyPress",
  "onKeyPressCapture",
  "onKeyUp",
  "onKeyUpCapture",
  // Media Events
  "onAbort",
  "onAbortCapture",
  "onCanPlay",
  "onCanPlayCapture",
  "onCanPlayThrough",
  "onCanPlayThroughCapture",
  "onDurationChange",
  "onDurationChangeCapture",
  "onEmptied",
  "onEmptiedCapture",
  "onEncrypted",
  "onEncryptedCapture",
  "onEnded",
  "onEndedCapture",
  "onLoadedData",
  "onLoadedDataCapture",
  "onLoadedMetadata",
  "onLoadedMetadataCapture",
  "onLoadStart",
  "onLoadStartCapture",
  "onPause",
  "onPauseCapture",
  "onPlay",
  "onPlayCapture",
  "onPlaying",
  "onPlayingCapture",
  "onProgress",
  "onProgressCapture",
  "onRateChange",
  "onRateChangeCapture",
  "onSeeked",
  "onSeekedCapture",
  "onSeeking",
  "onSeekingCapture",
  "onStalled",
  "onStalledCapture",
  "onSuspend",
  "onSuspendCapture",
  "onTimeUpdate",
  "onTimeUpdateCapture",
  "onVolumeChange",
  "onVolumeChangeCapture",
  "onWaiting",
  "onWaitingCapture",
  // MouseEvents
  "onAuxClick",
  "onAuxClickCapture",
  "onClick",
  "onClickCapture",
  "onContextMenu",
  "onContextMenuCapture",
  "onDoubleClick",
  "onDoubleClickCapture",
  "onDrag",
  "onDragCapture",
  "onDragEnd",
  "onDragEndCapture",
  "onDragEnter",
  "onDragEnterCapture",
  "onDragExit",
  "onDragExitCapture",
  "onDragLeave",
  "onDragLeaveCapture",
  "onDragOver",
  "onDragOverCapture",
  "onDragStart",
  "onDragStartCapture",
  "onDrop",
  "onDropCapture",
  "onMouseDown",
  "onMouseDownCapture",
  "onMouseEnter",
  "onMouseLeave",
  "onMouseMove",
  "onMouseMoveCapture",
  "onMouseOut",
  "onMouseOutCapture",
  "onMouseOver",
  "onMouseOverCapture",
  "onMouseUp",
  "onMouseUpCapture",
  // Selection Events
  "onSelect",
  "onSelectCapture",
  // Touch Events
  "onTouchCancel",
  "onTouchCancelCapture",
  "onTouchEnd",
  "onTouchEndCapture",
  "onTouchMove",
  "onTouchMoveCapture",
  "onTouchStart",
  "onTouchStartCapture",
  // Pointer Events
  "onPointerDown",
  "onPointerDownCapture",
  "onPointerMove",
  "onPointerMoveCapture",
  "onPointerUp",
  "onPointerUpCapture",
  "onPointerCancel",
  "onPointerCancelCapture",
  "onPointerEnter",
  "onPointerEnterCapture",
  "onPointerLeave",
  "onPointerLeaveCapture",
  "onPointerOver",
  "onPointerOverCapture",
  "onPointerOut",
  "onPointerOutCapture",
  "onGotPointerCapture",
  "onGotPointerCaptureCapture",
  "onLostPointerCapture",
  "onLostPointerCaptureCapture",
  // UI Events
  "onScroll",
  "onScrollCapture",
  // Wheel Events
  "onWheel",
  "onWheelCapture",
  // Animation Events
  "onAnimationStart",
  "onAnimationStartCapture",
  "onAnimationEnd",
  "onAnimationEndCapture",
  "onAnimationIteration",
  "onAnimationIterationCapture",
  // Transition Events
  "onTransitionEnd",
  "onTransitionEndCapture"
];
var IS_APPLE2 = typeof navigator !== "undefined" && /Mac OS X/.test(navigator.userAgent);
var escapeRegExp = (text) => {
  return text.replace(/[-[\]{}()*+?.,\\^$|#\\s]/g, "\\$&");
};
var findHtmlParentElement = (el, nodeName) => {
  if (!el || el.nodeName === nodeName) {
    return el;
  }
  return findHtmlParentElement(el.parentElement, nodeName);
};
var getSlateClass = (type) => `slate-${type}`;
var hexToBase64 = (hex) => {
  const hexPairs = hex.match(/\w{2}/g) || [];
  const binary = hexPairs.map((hexPair) => String.fromCharCode(parseInt(hexPair, 16)));
  return btoa(binary.join(""));
};
var commonjsGlobal2 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function unwrapExports(x7) {
  return x7 && x7.__esModule && Object.prototype.hasOwnProperty.call(x7, "default") ? x7["default"] : x7;
}
function createCommonjsModule2(fn2, module2) {
  return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
}
var lib = createCommonjsModule2(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var IS_MAC = () => typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
  var MODIFIERS = {
    alt: "altKey",
    control: "ctrlKey",
    meta: "metaKey",
    shift: "shiftKey"
  };
  var ALIASES = () => ({
    add: "+",
    break: "pause",
    cmd: "meta",
    command: "meta",
    ctl: "control",
    ctrl: "control",
    del: "delete",
    down: "arrowdown",
    esc: "escape",
    ins: "insert",
    left: "arrowleft",
    mod: IS_MAC() ? "meta" : "control",
    opt: "alt",
    option: "alt",
    return: "enter",
    right: "arrowright",
    space: " ",
    spacebar: " ",
    up: "arrowup",
    win: "meta",
    windows: "meta"
  });
  var CODES = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    control: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    " ": 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    insert: 45,
    delete: 46,
    meta: 91,
    numlock: 144,
    scrolllock: 145,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
  };
  for (var f16 = 1; f16 < 20; f16++) {
    CODES["f" + f16] = 111 + f16;
  }
  function isHotkey14(hotkey, options, event) {
    if (options && !("byKey" in options)) {
      event = options;
      options = null;
    }
    if (!Array.isArray(hotkey)) {
      hotkey = [hotkey];
    }
    var array2 = hotkey.map(function(string2) {
      return parseHotkey(string2, options);
    });
    var check = function check2(e9) {
      return array2.some(function(object2) {
        return compareHotkey(object2, e9);
      });
    };
    var ret = event == null ? check : check(event);
    return ret;
  }
  function isCodeHotkey(hotkey, event) {
    return isHotkey14(hotkey, event);
  }
  function isKeyHotkey2(hotkey, event) {
    return isHotkey14(hotkey, { byKey: true }, event);
  }
  function parseHotkey(hotkey, options) {
    var byKey = options && options.byKey;
    var ret = {};
    hotkey = hotkey.replace("++", "+add");
    var values3 = hotkey.split("+");
    var length = values3.length;
    for (var k3 in MODIFIERS) {
      ret[MODIFIERS[k3]] = false;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = void 0;
    try {
      for (var _iterator = values3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var value = _step.value;
        var optional = value.endsWith("?") && value.length > 1;
        if (optional) {
          value = value.slice(0, -1);
        }
        var name2 = toKeyName(value);
        var modifier = MODIFIERS[name2];
        if (length === 1 || !modifier) {
          if (byKey) {
            ret.key = name2;
          } else {
            ret.which = toKeyCode(value);
          }
        }
        if (modifier) {
          ret[modifier] = optional ? null : true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return ret;
  }
  function compareHotkey(object2, event) {
    for (var key in object2) {
      var expected = object2[key];
      var actual = void 0;
      if (expected == null) {
        continue;
      }
      if (key === "key" && event.key != null) {
        actual = event.key.toLowerCase();
      } else if (key === "which") {
        actual = expected === 91 && event.which === 93 ? 91 : event.which;
      } else {
        actual = event[key];
      }
      if (actual == null && expected === false) {
        continue;
      }
      if (actual !== expected) {
        return false;
      }
    }
    return true;
  }
  function toKeyCode(name2) {
    name2 = toKeyName(name2);
    var code = CODES[name2] || name2.toUpperCase().charCodeAt(0);
    return code;
  }
  function toKeyName(name2) {
    name2 = name2.toLowerCase();
    name2 = ALIASES()[name2] || name2;
    return name2;
  }
  exports2.default = isHotkey14;
  exports2.isHotkey = isHotkey14;
  exports2.isCodeHotkey = isCodeHotkey;
  exports2.isKeyHotkey = isKeyHotkey2;
  exports2.parseHotkey = parseHotkey;
  exports2.compareHotkey = compareHotkey;
  exports2.toKeyCode = toKeyCode;
  exports2.toKeyName = toKeyName;
});
var isHotkey = unwrapExports(lib);
lib.isHotkey;
lib.isCodeHotkey;
var lib_3 = lib.isKeyHotkey;
lib.parseHotkey;
lib.compareHotkey;
lib.toKeyCode;
lib.toKeyName;
var isComposing = (editor) => ReactEditor.isComposing(editor);
var HOTKEYS2 = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  insertSoftBreak: "shift+enter",
  italic: "mod+i",
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  splitBlock: "enter",
  tab: "tab",
  untab: "shift+tab",
  undo: "mod+z"
};
var APPLE_HOTKEYS2 = {
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
};
var WINDOWS_HOTKEYS2 = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
};
var create3 = (key) => {
  const generic = HOTKEYS2[key];
  const apple = APPLE_HOTKEYS2[key];
  const windows = WINDOWS_HOTKEYS2[key];
  const isGeneric = generic && lib_3(generic);
  const isApple = apple && lib_3(apple);
  const isWindows = windows && lib_3(windows);
  return (event) => {
    if (isGeneric && isGeneric(event))
      return true;
    if (IS_APPLE2 && isApple && isApple(event))
      return true;
    if (!IS_APPLE2 && isWindows && isWindows(event))
      return true;
    return false;
  };
};
var createComposing = (key) => (editor, event, {
  composing
} = {}) => {
  if (!create3(key)(event))
    return false;
  if (!!composing !== isComposing(editor))
    return false;
  return true;
};
var Hotkeys2 = {
  isBold: create3("bold"),
  isCompose: create3("compose"),
  isMoveBackward: create3("moveBackward"),
  isMoveForward: create3("moveForward"),
  isDeleteBackward: create3("deleteBackward"),
  isDeleteForward: create3("deleteForward"),
  isDeleteLineBackward: create3("deleteLineBackward"),
  isDeleteLineForward: create3("deleteLineForward"),
  isDeleteWordBackward: create3("deleteWordBackward"),
  isDeleteWordForward: create3("deleteWordForward"),
  isExtendBackward: create3("extendBackward"),
  isExtendForward: create3("extendForward"),
  isExtendLineBackward: create3("extendLineBackward"),
  isExtendLineForward: create3("extendLineForward"),
  isItalic: create3("italic"),
  isMoveLineBackward: create3("moveLineBackward"),
  isMoveLineForward: create3("moveLineForward"),
  isMoveWordBackward: create3("moveWordBackward"),
  isMoveWordForward: create3("moveWordForward"),
  isRedo: create3("redo"),
  isSoftBreak: create3("insertSoftBreak"),
  isSplitBlock: create3("splitBlock"),
  isTab: createComposing("tab"),
  isTransposeCharacter: create3("transposeCharacter"),
  isUndo: create3("undo"),
  isUntab: createComposing("untab")
};
var protocolAndDomainRE = /^(?:\w+:)?\/\/(\S+)$/;
var localhostDomainRE = /^localhost[:?\d]*(?:[^:?\d]\S*)?$/;
var nonLocalhostDomainRE = /^[^\s.]+\.\S{2,}$/;
var isUrl = (string2) => {
  if (typeof string2 !== "string") {
    return false;
  }
  const match5 = string2.match(protocolAndDomainRE);
  if (!match5) {
    return false;
  }
  const everythingAfterProtocol = match5[1];
  if (!everythingAfterProtocol) {
    return false;
  }
  try {
    new URL(string2);
  } catch (err) {
    return false;
  }
  return localhostDomainRE.test(everythingAfterProtocol) || nonLocalhostDomainRE.test(everythingAfterProtocol);
};
var JotaiProvider = Provider;
var isUndefined = (obj) => typeof obj === "undefined";
var isNull = (obj) => obj === null;
var isUndefinedOrNull = (obj) => isUndefined(obj) || isNull(obj);
var isDefined = (arg) => !isUndefinedOrNull(arg);
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply;
function identity(value) {
  return value;
}
var identity_1 = identity;
var nativeMax = Math.max;
function overRest(func, start3, transform) {
  start3 = nativeMax(start3 === void 0 ? func.length - 1 : start3, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax(args.length - start3, 0), array2 = Array(length);
    while (++index2 < length) {
      array2[index2] = args[start3 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start3 + 1);
    while (++index2 < start3) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start3] = transform(array2);
    return _apply(func, this, otherArgs);
  };
}
var _overRest = overRest;
function constant(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant;
var freeGlobal2 = typeof commonjsGlobal2 == "object" && commonjsGlobal2 && commonjsGlobal2.Object === Object && commonjsGlobal2;
var _freeGlobal2 = freeGlobal2;
var freeSelf2 = typeof self == "object" && self && self.Object === Object && self;
var root2 = _freeGlobal2 || freeSelf2 || Function("return this")();
var _root2 = root2;
var Symbol$1 = _root2.Symbol;
var _Symbol2 = Symbol$1;
var objectProto$g = Object.prototype;
var hasOwnProperty$d = objectProto$g.hasOwnProperty;
var nativeObjectToString$12 = objectProto$g.toString;
var symToStringTag$12 = _Symbol2 ? _Symbol2.toStringTag : void 0;
function getRawTag2(value) {
  var isOwn = hasOwnProperty$d.call(value, symToStringTag$12), tag = value[symToStringTag$12];
  try {
    value[symToStringTag$12] = void 0;
    var unmasked = true;
  } catch (e9) {
  }
  var result = nativeObjectToString$12.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$12] = tag;
    } else {
      delete value[symToStringTag$12];
    }
  }
  return result;
}
var _getRawTag2 = getRawTag2;
var objectProto$f = Object.prototype;
var nativeObjectToString2 = objectProto$f.toString;
function objectToString2(value) {
  return nativeObjectToString2.call(value);
}
var _objectToString2 = objectToString2;
var nullTag2 = "[object Null]";
var undefinedTag2 = "[object Undefined]";
var symToStringTag2 = _Symbol2 ? _Symbol2.toStringTag : void 0;
function baseGetTag2(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag2 : nullTag2;
  }
  return symToStringTag2 && symToStringTag2 in Object(value) ? _getRawTag2(value) : _objectToString2(value);
}
var _baseGetTag2 = baseGetTag2;
function isObject$1(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_12 = isObject$1;
var asyncTag2 = "[object AsyncFunction]";
var funcTag$2 = "[object Function]";
var genTag$1 = "[object GeneratorFunction]";
var proxyTag2 = "[object Proxy]";
function isFunction2(value) {
  if (!isObject_12(value)) {
    return false;
  }
  var tag = _baseGetTag2(value);
  return tag == funcTag$2 || tag == genTag$1 || tag == asyncTag2 || tag == proxyTag2;
}
var isFunction_12 = isFunction2;
var coreJsData2 = _root2["__core-js_shared__"];
var _coreJsData2 = coreJsData2;
var maskSrcKey2 = function() {
  var uid2 = /[^.]+$/.exec(_coreJsData2 && _coreJsData2.keys && _coreJsData2.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked2(func) {
  return !!maskSrcKey2 && maskSrcKey2 in func;
}
var _isMasked2 = isMasked2;
var funcProto$2 = Function.prototype;
var funcToString$2 = funcProto$2.toString;
function toSource2(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e9) {
    }
    try {
      return func + "";
    } catch (e9) {
    }
  }
  return "";
}
var _toSource2 = toSource2;
var reRegExpChar2 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor2 = /^\[object .+?Constructor\]$/;
var funcProto$12 = Function.prototype;
var objectProto$e = Object.prototype;
var funcToString$12 = funcProto$12.toString;
var hasOwnProperty$c = objectProto$e.hasOwnProperty;
var reIsNative2 = RegExp(
  "^" + funcToString$12.call(hasOwnProperty$c).replace(reRegExpChar2, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative2(value) {
  if (!isObject_12(value) || _isMasked2(value)) {
    return false;
  }
  var pattern = isFunction_12(value) ? reIsNative2 : reIsHostCtor2;
  return pattern.test(_toSource2(value));
}
var _baseIsNative2 = baseIsNative2;
function getValue2(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
var _getValue2 = getValue2;
function getNative2(object2, key) {
  var value = _getValue2(object2, key);
  return _baseIsNative2(value) ? value : void 0;
}
var _getNative2 = getNative2;
var defineProperty2 = function() {
  try {
    var func = _getNative2(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e9) {
  }
}();
var _defineProperty$1 = defineProperty2;
var baseSetToString = !_defineProperty$1 ? identity_1 : function(func, string2) {
  return _defineProperty$1(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_1(string2),
    "writable": true
  });
};
var _baseSetToString = baseSetToString;
var HOT_COUNT = 800;
var HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut;
var setToString = _shortOut(_baseSetToString);
var _setToString = setToString;
function baseRest(func, start3) {
  return _setToString(_overRest(func, start3, identity_1), func + "");
}
var _baseRest = baseRest;
function listCacheClear2() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear2 = listCacheClear2;
function eq2(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_12 = eq2;
function assocIndexOf2(array2, key) {
  var length = array2.length;
  while (length--) {
    if (eq_12(array2[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf2 = assocIndexOf2;
var arrayProto2 = Array.prototype;
var splice2 = arrayProto2.splice;
function listCacheDelete2(key) {
  var data = this.__data__, index2 = _assocIndexOf2(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice2.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete2 = listCacheDelete2;
function listCacheGet2(key) {
  var data = this.__data__, index2 = _assocIndexOf2(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet2 = listCacheGet2;
function listCacheHas2(key) {
  return _assocIndexOf2(this.__data__, key) > -1;
}
var _listCacheHas2 = listCacheHas2;
function listCacheSet2(key, value) {
  var data = this.__data__, index2 = _assocIndexOf2(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var _listCacheSet2 = listCacheSet2;
function ListCache2(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache2.prototype.clear = _listCacheClear2;
ListCache2.prototype["delete"] = _listCacheDelete2;
ListCache2.prototype.get = _listCacheGet2;
ListCache2.prototype.has = _listCacheHas2;
ListCache2.prototype.set = _listCacheSet2;
var _ListCache2 = ListCache2;
function stackClear2() {
  this.__data__ = new _ListCache2();
  this.size = 0;
}
var _stackClear2 = stackClear2;
function stackDelete2(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete2 = stackDelete2;
function stackGet2(key) {
  return this.__data__.get(key);
}
var _stackGet2 = stackGet2;
function stackHas2(key) {
  return this.__data__.has(key);
}
var _stackHas2 = stackHas2;
var Map3 = _getNative2(_root2, "Map");
var _Map2 = Map3;
var nativeCreate2 = _getNative2(Object, "create");
var _nativeCreate2 = nativeCreate2;
function hashClear2() {
  this.__data__ = _nativeCreate2 ? _nativeCreate2(null) : {};
  this.size = 0;
}
var _hashClear2 = hashClear2;
function hashDelete2(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete2 = hashDelete2;
var HASH_UNDEFINED$22 = "__lodash_hash_undefined__";
var objectProto$d = Object.prototype;
var hasOwnProperty$b = objectProto$d.hasOwnProperty;
function hashGet2(key) {
  var data = this.__data__;
  if (_nativeCreate2) {
    var result = data[key];
    return result === HASH_UNDEFINED$22 ? void 0 : result;
  }
  return hasOwnProperty$b.call(data, key) ? data[key] : void 0;
}
var _hashGet2 = hashGet2;
var objectProto$c = Object.prototype;
var hasOwnProperty$a = objectProto$c.hasOwnProperty;
function hashHas2(key) {
  var data = this.__data__;
  return _nativeCreate2 ? data[key] !== void 0 : hasOwnProperty$a.call(data, key);
}
var _hashHas2 = hashHas2;
var HASH_UNDEFINED$12 = "__lodash_hash_undefined__";
function hashSet2(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = _nativeCreate2 && value === void 0 ? HASH_UNDEFINED$12 : value;
  return this;
}
var _hashSet2 = hashSet2;
function Hash2(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash2.prototype.clear = _hashClear2;
Hash2.prototype["delete"] = _hashDelete2;
Hash2.prototype.get = _hashGet2;
Hash2.prototype.has = _hashHas2;
Hash2.prototype.set = _hashSet2;
var _Hash2 = Hash2;
function mapCacheClear2() {
  this.size = 0;
  this.__data__ = {
    "hash": new _Hash2(),
    "map": new (_Map2 || _ListCache2)(),
    "string": new _Hash2()
  };
}
var _mapCacheClear2 = mapCacheClear2;
function isKeyable2(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable2 = isKeyable2;
function getMapData2(map5, key) {
  var data = map5.__data__;
  return _isKeyable2(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData2 = getMapData2;
function mapCacheDelete2(key) {
  var result = _getMapData2(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete2 = mapCacheDelete2;
function mapCacheGet2(key) {
  return _getMapData2(this, key).get(key);
}
var _mapCacheGet2 = mapCacheGet2;
function mapCacheHas2(key) {
  return _getMapData2(this, key).has(key);
}
var _mapCacheHas2 = mapCacheHas2;
function mapCacheSet2(key, value) {
  var data = _getMapData2(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var _mapCacheSet2 = mapCacheSet2;
function MapCache2(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache2.prototype.clear = _mapCacheClear2;
MapCache2.prototype["delete"] = _mapCacheDelete2;
MapCache2.prototype.get = _mapCacheGet2;
MapCache2.prototype.has = _mapCacheHas2;
MapCache2.prototype.set = _mapCacheSet2;
var _MapCache2 = MapCache2;
var LARGE_ARRAY_SIZE2 = 200;
function stackSet2(key, value) {
  var data = this.__data__;
  if (data instanceof _ListCache2) {
    var pairs = data.__data__;
    if (!_Map2 || pairs.length < LARGE_ARRAY_SIZE2 - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new _MapCache2(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet2 = stackSet2;
function Stack2(entries) {
  var data = this.__data__ = new _ListCache2(entries);
  this.size = data.size;
}
Stack2.prototype.clear = _stackClear2;
Stack2.prototype["delete"] = _stackDelete2;
Stack2.prototype.get = _stackGet2;
Stack2.prototype.has = _stackHas2;
Stack2.prototype.set = _stackSet2;
var _Stack = Stack2;
function baseAssignValue(object2, key, value) {
  if (key == "__proto__" && _defineProperty$1) {
    _defineProperty$1(object2, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object2[key] = value;
  }
}
var _baseAssignValue = baseAssignValue;
function assignMergeValue(object2, key, value) {
  if (value !== void 0 && !eq_12(object2[key], value) || value === void 0 && !(key in object2)) {
    _baseAssignValue(object2, key, value);
  }
}
var _assignMergeValue = assignMergeValue;
function createBaseFor2(fromRight) {
  return function(object2, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object2;
  };
}
var _createBaseFor2 = createBaseFor2;
var baseFor2 = _createBaseFor2();
var _baseFor = baseFor2;
var _cloneBuffer = createCommonjsModule2(function(module2, exports2) {
  var freeExports4 = exports2 && !exports2.nodeType && exports2;
  var freeModule4 = freeExports4 && true && module2 && !module2.nodeType && module2;
  var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
  var Buffer3 = moduleExports4 ? _root2.Buffer : void 0, allocUnsafe2 = Buffer3 ? Buffer3.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe2 ? allocUnsafe2(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module2.exports = cloneBuffer2;
});
var Uint8Array3 = _root2.Uint8Array;
var _Uint8Array = Uint8Array3;
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
  return result;
}
var _cloneArrayBuffer = cloneArrayBuffer;
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray = cloneTypedArray;
function copyArray(source, array2) {
  var index2 = -1, length = source.length;
  array2 || (array2 = Array(length));
  while (++index2 < length) {
    array2[index2] = source[index2];
  }
  return array2;
}
var _copyArray = copyArray;
var objectCreate = Object.create;
var baseCreate = function() {
  function object2() {
  }
  return function(proto2) {
    if (!isObject_12(proto2)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto2);
    }
    object2.prototype = proto2;
    var result = new object2();
    object2.prototype = void 0;
    return result;
  };
}();
var _baseCreate = baseCreate;
function overArg2(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg2 = overArg2;
var getPrototype = _overArg2(Object.getPrototypeOf, Object);
var _getPrototype = getPrototype;
var objectProto$b2 = Object.prototype;
function isPrototype(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$b2;
  return value === proto2;
}
var _isPrototype = isPrototype;
function initCloneObject(object2) {
  return typeof object2.constructor == "function" && !_isPrototype(object2) ? _baseCreate(_getPrototype(object2)) : {};
}
var _initCloneObject = initCloneObject;
function isObjectLike2(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_12 = isObjectLike2;
var argsTag$3 = "[object Arguments]";
function baseIsArguments2(value) {
  return isObjectLike_12(value) && _baseGetTag2(value) == argsTag$3;
}
var _baseIsArguments2 = baseIsArguments2;
var objectProto$a2 = Object.prototype;
var hasOwnProperty$9 = objectProto$a2.hasOwnProperty;
var propertyIsEnumerable$12 = objectProto$a2.propertyIsEnumerable;
var isArguments2 = _baseIsArguments2(function() {
  return arguments;
}()) ? _baseIsArguments2 : function(value) {
  return isObjectLike_12(value) && hasOwnProperty$9.call(value, "callee") && !propertyIsEnumerable$12.call(value, "callee");
};
var isArguments_1 = isArguments2;
var isArray2 = Array.isArray;
var isArray_1 = isArray2;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength2(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
var isLength_12 = isLength2;
function isArrayLike(value) {
  return value != null && isLength_12(value.length) && !isFunction_12(value);
}
var isArrayLike_1 = isArrayLike;
function isArrayLikeObject(value) {
  return isObjectLike_12(value) && isArrayLike_1(value);
}
var isArrayLikeObject_1 = isArrayLikeObject;
function stubFalse2() {
  return false;
}
var stubFalse_12 = stubFalse2;
var isBuffer_12 = createCommonjsModule2(function(module2, exports2) {
  var freeExports4 = exports2 && !exports2.nodeType && exports2;
  var freeModule4 = freeExports4 && true && module2 && !module2.nodeType && module2;
  var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
  var Buffer3 = moduleExports4 ? _root2.Buffer : void 0;
  var nativeIsBuffer2 = Buffer3 ? Buffer3.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer2 || stubFalse_12;
  module2.exports = isBuffer2;
});
var objectTag$4 = "[object Object]";
var funcProto2 = Function.prototype;
var objectProto$92 = Object.prototype;
var funcToString2 = funcProto2.toString;
var hasOwnProperty$82 = objectProto$92.hasOwnProperty;
var objectCtorString = funcToString2.call(Object);
function isPlainObject$1(value) {
  if (!isObjectLike_12(value) || _baseGetTag2(value) != objectTag$4) {
    return false;
  }
  var proto2 = _getPrototype(value);
  if (proto2 === null) {
    return true;
  }
  var Ctor = hasOwnProperty$82.call(proto2, "constructor") && proto2.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString2.call(Ctor) == objectCtorString;
}
var isPlainObject_1 = isPlainObject$1;
var argsTag$22 = "[object Arguments]";
var arrayTag$2 = "[object Array]";
var boolTag$3 = "[object Boolean]";
var dateTag$3 = "[object Date]";
var errorTag$2 = "[object Error]";
var funcTag$12 = "[object Function]";
var mapTag$5 = "[object Map]";
var numberTag$3 = "[object Number]";
var objectTag$3 = "[object Object]";
var regexpTag$3 = "[object RegExp]";
var setTag$5 = "[object Set]";
var stringTag$3 = "[object String]";
var weakMapTag$2 = "[object WeakMap]";
var arrayBufferTag$3 = "[object ArrayBuffer]";
var dataViewTag$4 = "[object DataView]";
var float32Tag$2 = "[object Float32Array]";
var float64Tag$2 = "[object Float64Array]";
var int8Tag$2 = "[object Int8Array]";
var int16Tag$2 = "[object Int16Array]";
var int32Tag$2 = "[object Int32Array]";
var uint8Tag$2 = "[object Uint8Array]";
var uint8ClampedTag$2 = "[object Uint8ClampedArray]";
var uint16Tag$2 = "[object Uint16Array]";
var uint32Tag$2 = "[object Uint32Array]";
var typedArrayTags2 = {};
typedArrayTags2[float32Tag$2] = typedArrayTags2[float64Tag$2] = typedArrayTags2[int8Tag$2] = typedArrayTags2[int16Tag$2] = typedArrayTags2[int32Tag$2] = typedArrayTags2[uint8Tag$2] = typedArrayTags2[uint8ClampedTag$2] = typedArrayTags2[uint16Tag$2] = typedArrayTags2[uint32Tag$2] = true;
typedArrayTags2[argsTag$22] = typedArrayTags2[arrayTag$2] = typedArrayTags2[arrayBufferTag$3] = typedArrayTags2[boolTag$3] = typedArrayTags2[dataViewTag$4] = typedArrayTags2[dateTag$3] = typedArrayTags2[errorTag$2] = typedArrayTags2[funcTag$12] = typedArrayTags2[mapTag$5] = typedArrayTags2[numberTag$3] = typedArrayTags2[objectTag$3] = typedArrayTags2[regexpTag$3] = typedArrayTags2[setTag$5] = typedArrayTags2[stringTag$3] = typedArrayTags2[weakMapTag$2] = false;
function baseIsTypedArray2(value) {
  return isObjectLike_12(value) && isLength_12(value.length) && !!typedArrayTags2[_baseGetTag2(value)];
}
var _baseIsTypedArray2 = baseIsTypedArray2;
function baseUnary2(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary2 = baseUnary2;
var _nodeUtil2 = createCommonjsModule2(function(module2, exports2) {
  var freeExports4 = exports2 && !exports2.nodeType && exports2;
  var freeModule4 = freeExports4 && true && module2 && !module2.nodeType && module2;
  var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
  var freeProcess2 = moduleExports4 && _freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule4 && freeModule4.require && freeModule4.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
    } catch (e9) {
    }
  }();
  module2.exports = nodeUtil2;
});
var nodeIsTypedArray2 = _nodeUtil2 && _nodeUtil2.isTypedArray;
var isTypedArray2 = nodeIsTypedArray2 ? _baseUnary2(nodeIsTypedArray2) : _baseIsTypedArray2;
var isTypedArray_1 = isTypedArray2;
function safeGet(object2, key) {
  if (key === "constructor" && typeof object2[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object2[key];
}
var _safeGet = safeGet;
var objectProto$82 = Object.prototype;
var hasOwnProperty$72 = objectProto$82.hasOwnProperty;
function assignValue(object2, key, value) {
  var objValue = object2[key];
  if (!(hasOwnProperty$72.call(object2, key) && eq_12(objValue, value)) || value === void 0 && !(key in object2)) {
    _baseAssignValue(object2, key, value);
  }
}
var _assignValue = assignValue;
function copyObject(source, props, object2, customizer) {
  var isNew = !object2;
  object2 || (object2 = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      _baseAssignValue(object2, key, newValue);
    } else {
      _assignValue(object2, key, newValue);
    }
  }
  return object2;
}
var _copyObject = copyObject;
function baseTimes(n12, iteratee) {
  var index2 = -1, result = Array(n12);
  while (++index2 < n12) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes = baseTimes;
var MAX_SAFE_INTEGER2 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER2 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex;
var objectProto$72 = Object.prototype;
var hasOwnProperty$62 = objectProto$72.hasOwnProperty;
function arrayLikeKeys(value, inherited) {
  var isArr = isArray_1(value), isArg = !isArr && isArguments_1(value), isBuff = !isArr && !isArg && isBuffer_12(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray_1(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? _baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$62.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    _isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys;
function nativeKeysIn(object2) {
  var result = [];
  if (object2 != null) {
    for (var key in Object(object2)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn = nativeKeysIn;
var objectProto$62 = Object.prototype;
var hasOwnProperty$52 = objectProto$62.hasOwnProperty;
function baseKeysIn(object2) {
  if (!isObject_12(object2)) {
    return _nativeKeysIn(object2);
  }
  var isProto = _isPrototype(object2), result = [];
  for (var key in object2) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$52.call(object2, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn = baseKeysIn;
function keysIn(object2) {
  return isArrayLike_1(object2) ? _arrayLikeKeys(object2, true) : _baseKeysIn(object2);
}
var keysIn_1 = keysIn;
function toPlainObject(value) {
  return _copyObject(value, keysIn_1(value));
}
var toPlainObject_1 = toPlainObject;
function baseMergeDeep(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = _safeGet(object2, key), srcValue = _safeGet(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    _assignMergeValue(object2, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_1(srcValue), isBuff = !isArr && isBuffer_12(srcValue), isTyped = !isArr && !isBuff && isTypedArray_1(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_1(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_1(objValue)) {
        newValue = _copyArray(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = _cloneBuffer(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = _cloneTypedArray(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_1(srcValue) || isArguments_1(srcValue)) {
      newValue = objValue;
      if (isArguments_1(objValue)) {
        newValue = toPlainObject_1(objValue);
      } else if (!isObject_12(objValue) || isFunction_12(objValue)) {
        newValue = _initCloneObject(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  _assignMergeValue(object2, key, newValue);
}
var _baseMergeDeep = baseMergeDeep;
function baseMerge(object2, source, srcIndex, customizer, stack) {
  if (object2 === source) {
    return;
  }
  _baseFor(source, function(srcValue, key) {
    stack || (stack = new _Stack());
    if (isObject_12(srcValue)) {
      _baseMergeDeep(object2, source, key, srcIndex, baseMerge, customizer, stack);
    } else {
      var newValue = customizer ? customizer(_safeGet(object2, key), srcValue, key + "", object2, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      _assignMergeValue(object2, key, newValue);
    }
  }, keysIn_1);
}
var _baseMerge = baseMerge;
function customDefaultsMerge(objValue, srcValue, key, object2, source, stack) {
  if (isObject_12(objValue) && isObject_12(srcValue)) {
    stack.set(srcValue, objValue);
    _baseMerge(objValue, srcValue, void 0, customDefaultsMerge, stack);
    stack["delete"](srcValue);
  }
  return objValue;
}
var _customDefaultsMerge = customDefaultsMerge;
function isIterateeCall(value, index2, object2) {
  if (!isObject_12(object2)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike_1(object2) && _isIndex(index2, object2.length) : type == "string" && index2 in object2) {
    return eq_12(object2[index2], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall;
function createAssigner(assigner) {
  return _baseRest(function(object2, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object2 = Object(object2);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object2, source, index2, customizer);
      }
    }
    return object2;
  });
}
var _createAssigner = createAssigner;
var mergeWith = _createAssigner(function(object2, source, srcIndex, customizer) {
  _baseMerge(object2, source, srcIndex, customizer);
});
var mergeWith_1 = mergeWith;
var defaultsDeep = _baseRest(function(args) {
  args.push(void 0, _customDefaultsMerge);
  return _apply(mergeWith_1, void 0, args);
});
var defaultsDeep_1 = defaultsDeep;
var overridePluginsByKey = (plugin, overrideByKey2 = {}, nested) => {
  var _overrideByKey$plugin;
  if (overrideByKey2[plugin.key]) {
    const {
      plugins: pluginOverridesPlugins,
      then: pluginOverridesThen,
      ...pluginOverrides
    } = overrideByKey2[plugin.key];
    plugin = defaultsDeep_1(pluginOverrides, plugin);
    if (!nested) {
      pluginOverridesPlugins === null || pluginOverridesPlugins === void 0 ? void 0 : pluginOverridesPlugins.forEach((pOverrides) => {
        if (!plugin.plugins)
          plugin.plugins = [];
        const found = plugin.plugins.find((p12) => p12.key === pOverrides.key);
        if (!found)
          plugin.plugins.push(pOverrides);
      });
    }
  }
  if (plugin.plugins) {
    plugin.plugins = plugin.plugins.map((p12) => overridePluginsByKey(p12, overrideByKey2, true));
  }
  const {
    then
  } = plugin;
  if (then) {
    plugin.then = (editor, p12) => {
      const pluginThen = {
        key: plugin.key,
        ...then(editor, p12)
      };
      return defaultsDeep_1(overridePluginsByKey(pluginThen, overrideByKey2), pluginThen);
    };
  } else if ((_overrideByKey$plugin = overrideByKey2[plugin.key]) !== null && _overrideByKey$plugin !== void 0 && _overrideByKey$plugin.then) {
    plugin.then = overrideByKey2[plugin.key].then;
  }
  return plugin;
};
var createPluginFactory = (defaultPlugin) => (override, overrideByKey2 = {}) => {
  overrideByKey2[defaultPlugin.key] = override;
  return overridePluginsByKey({
    ...defaultPlugin
  }, overrideByKey2);
};
var KEY_DESERIALIZE_AST = "deserializeAst";
var createDeserializeAstPlugin = createPluginFactory({
  key: KEY_DESERIALIZE_AST,
  editor: {
    insertData: {
      format: "application/x-slate-fragment",
      getFragment: ({
        data
      }) => {
        const decoded = decodeURIComponent(window.atob(data));
        return JSON.parse(decoded);
      }
    }
  }
});
var eventEditorStore = createStore4("event-editor")({
  blur: null,
  focus: null,
  last: null
});
var eventEditorActions = eventEditorStore.set;
var eventEditorSelectors = eventEditorStore.get;
var useEventEditorSelectors = eventEditorStore.use;
var KEY_EVENT_EDITOR = "event-editor";
var createEventEditorPlugin = createPluginFactory({
  key: KEY_EVENT_EDITOR,
  handlers: {
    onFocus: (editor) => () => {
      eventEditorActions.focus(editor.id);
    },
    onBlur: (editor) => () => {
      const focus2 = eventEditorSelectors.focus();
      if (focus2 === editor.id) {
        eventEditorActions.focus(null);
      }
      eventEditorActions.blur(editor.id);
    }
  }
});
var withTHistory = (editor) => withHistory(editor);
var createHistoryPlugin = createPluginFactory({
  key: "history",
  withOverrides: withTHistory
});
var KEY_INLINE_VOID = "inline-void";
var withInlineVoid = (editor) => {
  const {
    isInline: isInline2
  } = editor;
  const {
    isVoid: isVoid3
  } = editor;
  const inlineTypes = [];
  const voidTypes = [];
  editor.plugins.forEach((plugin) => {
    if (plugin.isInline) {
      inlineTypes.push(plugin.type);
    }
    if (plugin.isVoid) {
      voidTypes.push(plugin.type);
    }
  });
  editor.isInline = (element) => {
    return inlineTypes.includes(element.type) ? true : isInline2(element);
  };
  editor.isVoid = (element) => voidTypes.includes(element.type) ? true : isVoid3(element);
  return editor;
};
var createInlineVoidPlugin = createPluginFactory({
  key: KEY_INLINE_VOID,
  withOverrides: withInlineVoid
});
var getInjectedPlugins = (editor, plugin) => {
  const injectedPlugins = [];
  [...editor.plugins].reverse().forEach((p12) => {
    var _p$inject$pluginsByKe;
    const injectedPlugin = (_p$inject$pluginsByKe = p12.inject.pluginsByKey) === null || _p$inject$pluginsByKe === void 0 ? void 0 : _p$inject$pluginsByKe[plugin.key];
    if (injectedPlugin)
      injectedPlugins.push(injectedPlugin);
  });
  return [plugin, ...injectedPlugins];
};
var pipeInsertDataQuery = (plugins2, {
  data,
  dataTransfer
}) => plugins2.every((p12) => {
  var _p$editor, _p$editor$insertData;
  const query = (_p$editor = p12.editor) === null || _p$editor === void 0 ? void 0 : (_p$editor$insertData = _p$editor.insertData) === null || _p$editor$insertData === void 0 ? void 0 : _p$editor$insertData.query;
  return !query || query({
    data,
    dataTransfer
  });
});
var withoutNormalizing = (editor, fn2) => {
  let normalized = false;
  Editor.withoutNormalizing(editor, () => {
    normalized = !!fn2();
  });
  return normalized;
};
var pipeInsertFragment = (editor, injectedPlugins, {
  fragment,
  ...options
}) => {
  withoutNormalizing(editor, () => {
    injectedPlugins.some((p12) => {
      var _p$editor, _p$editor$insertData, _p$editor$insertData$;
      return ((_p$editor = p12.editor) === null || _p$editor === void 0 ? void 0 : (_p$editor$insertData = _p$editor.insertData) === null || _p$editor$insertData === void 0 ? void 0 : (_p$editor$insertData$ = _p$editor$insertData.preInsert) === null || _p$editor$insertData$ === void 0 ? void 0 : _p$editor$insertData$.call(_p$editor$insertData, fragment, options)) === true;
    });
    editor.insertFragment(fragment);
  });
};
var pipeTransformData = (plugins2, {
  data,
  dataTransfer
}) => {
  plugins2.forEach((p12) => {
    var _p$editor, _p$editor$insertData;
    const transformData = (_p$editor = p12.editor) === null || _p$editor === void 0 ? void 0 : (_p$editor$insertData = _p$editor.insertData) === null || _p$editor$insertData === void 0 ? void 0 : _p$editor$insertData.transformData;
    if (!transformData)
      return;
    data = transformData(data, {
      dataTransfer
    });
  });
  return data;
};
var pipeTransformFragment = (plugins2, {
  fragment,
  ...options
}) => {
  plugins2.forEach((p12) => {
    var _p$editor, _p$editor$insertData;
    const transformFragment = (_p$editor = p12.editor) === null || _p$editor === void 0 ? void 0 : (_p$editor$insertData = _p$editor.insertData) === null || _p$editor$insertData === void 0 ? void 0 : _p$editor$insertData.transformFragment;
    if (!transformFragment)
      return;
    fragment = transformFragment(fragment, options);
  });
  return fragment;
};
var withInsertData = (editor) => {
  const {
    insertData
  } = editor;
  editor.insertData = (dataTransfer) => {
    const inserted = [...editor.plugins].reverse().some((plugin) => {
      var _fragment;
      const insertDataOptions = plugin.editor.insertData;
      if (!insertDataOptions)
        return false;
      const injectedPlugins = getInjectedPlugins(editor, plugin);
      const {
        format: format3,
        getFragment
      } = insertDataOptions;
      if (!format3)
        return false;
      let data = dataTransfer.getData(format3);
      if (!data)
        return;
      if (!pipeInsertDataQuery(injectedPlugins, {
        data,
        dataTransfer
      })) {
        return false;
      }
      data = pipeTransformData(injectedPlugins, {
        data,
        dataTransfer
      });
      let fragment = getFragment === null || getFragment === void 0 ? void 0 : getFragment({
        data,
        dataTransfer
      });
      if (!((_fragment = fragment) !== null && _fragment !== void 0 && _fragment.length))
        return false;
      fragment = pipeTransformFragment(injectedPlugins, {
        fragment,
        data,
        dataTransfer
      });
      if (!fragment.length)
        return false;
      pipeInsertFragment(editor, injectedPlugins, {
        fragment,
        data,
        dataTransfer
      });
      return true;
    });
    if (inserted)
      return;
    insertData(dataTransfer);
  };
  return editor;
};
var KEY_INSERT_DATA = "insertData";
var createInsertDataPlugin = createPluginFactory({
  key: KEY_INSERT_DATA,
  withOverrides: withInsertData
});
var withTReact = (editor) => withReact(editor);
var createReactPlugin = createPluginFactory({
  key: "react",
  withOverrides: withTReact
});
var isElement2 = (value) => Element2.isElement(value);
var isText = (value) => Text.isText(value);
var ELEMENT_DEFAULT = "p";
var createTEditor = () => createEditor();
var createPlateStore = (state = {}) => createStore4(`plate-${state.id}`)({
  id: "main",
  value: [{
    type: ELEMENT_DEFAULT,
    children: [{
      text: ""
    }]
  }],
  editor: null,
  isReady: false,
  isRendered: false,
  keyEditor: 1,
  keyPlugins: 1,
  keySelection: 1,
  keyDecorate: 1,
  decorate: null,
  enabled: true,
  editableProps: null,
  onChange: null,
  plugins: [],
  renderElement: null,
  renderLeaf: null,
  ...state
}).extendActions((_set, _get) => ({
  /**
   * Set a new editor with plate.
   */
  resetEditor: () => {
    var _get$editor;
    _set.editor(withPlate(createTEditor(), {
      id: state.id,
      plugins: (_get$editor = _get.editor()) === null || _get$editor === void 0 ? void 0 : _get$editor.plugins
    }));
  },
  incrementKey: (key) => {
    var _get$key;
    const prev = (_get$key = _get[key]()) !== null && _get$key !== void 0 ? _get$key : 1;
    _set[key](prev + 1);
  }
})).extendActions((_set) => ({
  /**
   * Redecorate the editor.
   */
  redecorate: () => {
    _set.incrementKey("keyDecorate");
  }
}));
var getPluginsByKey = (editor) => {
  var _ref;
  return (_ref = editor === null || editor === void 0 ? void 0 : editor.pluginsByKey) !== null && _ref !== void 0 ? _ref : {};
};
var getPlugin = (editor, key) => {
  var _getPluginsByKey$key;
  return (_getPluginsByKey$key = getPluginsByKey(editor)[key]) !== null && _getPluginsByKey$key !== void 0 ? _getPluginsByKey$key : {
    key
  };
};
var getPluginType = (editor, key) => {
  var _ref, _getPlugin$type;
  return (_ref = (_getPlugin$type = getPlugin(editor, key).type) !== null && _getPlugin$type !== void 0 ? _getPlugin$type : key) !== null && _ref !== void 0 ? _ref : "";
};
var isInlineNode = (editor) => (node) => isText(node) || isElement2(node) && editor.isInline(node);
var makeBlockLazy = (type) => () => ({
  type,
  children: []
});
var hasDifferentChildNodes = (descendants, isInline2) => {
  return descendants.some((descendant, index2, arr) => {
    const prevDescendant = arr[index2 - 1];
    if (index2 !== 0) {
      return isInline2(descendant) !== isInline2(prevDescendant);
    }
    return false;
  });
};
var normalizeDifferentNodeTypes = (descendants, isInline2, makeDefaultBlock) => {
  const hasDifferentNodes = hasDifferentChildNodes(descendants, isInline2);
  const {
    fragment
  } = descendants.reduce((memo2, node) => {
    if (hasDifferentNodes && isInline2(node)) {
      let block = memo2.precedingBlock;
      if (!block) {
        block = makeDefaultBlock();
        memo2.precedingBlock = block;
        memo2.fragment.push(block);
      }
      block.children.push(node);
    } else {
      memo2.fragment.push(node);
      memo2.precedingBlock = null;
    }
    return memo2;
  }, {
    fragment: [],
    precedingBlock: null
  });
  return fragment;
};
var normalizeEmptyChildren = (descendants) => {
  if (!descendants.length) {
    return [{
      text: ""
    }];
  }
  return descendants;
};
var normalize = (descendants, isInline2, makeDefaultBlock) => {
  descendants = normalizeEmptyChildren(descendants);
  descendants = normalizeDifferentNodeTypes(descendants, isInline2, makeDefaultBlock);
  descendants = descendants.map((node) => {
    if (isElement2(node)) {
      return {
        ...node,
        children: normalize(node.children, isInline2, makeDefaultBlock)
      };
    }
    return node;
  });
  return descendants;
};
var normalizeDescendantsToDocumentFragment = (editor, {
  descendants
}) => {
  const isInline2 = isInlineNode(editor);
  const defaultType = getPluginType(editor, ELEMENT_DEFAULT);
  const makeDefaultBlock = makeBlockLazy(defaultType);
  return normalize(descendants, isInline2, makeDefaultBlock);
};
function isObject3(o16) {
  return Object.prototype.toString.call(o16) === "[object Object]";
}
function isPlainObject2(o16) {
  var ctor, prot;
  if (isObject3(o16) === false)
    return false;
  ctor = o16.constructor;
  if (ctor === void 0)
    return true;
  prot = ctor.prototype;
  if (isObject3(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function _defineProperty3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
var ANCHOR = /* @__PURE__ */ new WeakMap();
var FOCUS = /* @__PURE__ */ new WeakMap();
var Token = class {
};
var AnchorToken = class extends Token {
  constructor() {
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super();
    var {
      offset: offset5,
      path
    } = props;
    this.offset = offset5;
    this.path = path;
  }
};
var FocusToken = class extends Token {
  constructor() {
    var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    super();
    var {
      offset: offset5,
      path
    } = props;
    this.offset = offset5;
    this.path = path;
  }
};
var addAnchorToken = (text, token2) => {
  var offset5 = text.text.length;
  ANCHOR.set(text, [offset5, token2]);
};
var getAnchorOffset = (text) => {
  return ANCHOR.get(text);
};
var addFocusToken = (text, token2) => {
  var offset5 = text.text.length;
  FOCUS.set(text, [offset5, token2]);
};
var getFocusOffset = (text) => {
  return FOCUS.get(text);
};
function ownKeys$13(object2, enumerableOnly) {
  var keys6 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys6.push.apply(keys6, symbols);
  }
  return keys6;
}
function _objectSpread$13(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15] != null ? arguments[i15] : {};
    if (i15 % 2) {
      ownKeys$13(Object(source), true).forEach(function(key) {
        _defineProperty3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$13(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var STRINGS = /* @__PURE__ */ new WeakSet();
var resolveDescendants = (children) => {
  var nodes = [];
  var addChild = (child2) => {
    if (child2 == null) {
      return;
    }
    var prev = nodes[nodes.length - 1];
    if (typeof child2 === "string") {
      var text = {
        text: child2
      };
      STRINGS.add(text);
      child2 = text;
    }
    if (Text.isText(child2)) {
      var c16 = child2;
      if (Text.isText(prev) && STRINGS.has(prev) && STRINGS.has(c16) && Text.equals(prev, c16, {
        loose: true
      })) {
        prev.text += c16.text;
      } else {
        nodes.push(c16);
      }
    } else if (Element2.isElement(child2)) {
      nodes.push(child2);
    } else if (child2 instanceof Token) {
      var n12 = nodes[nodes.length - 1];
      if (!Text.isText(n12)) {
        addChild("");
        n12 = nodes[nodes.length - 1];
      }
      if (child2 instanceof AnchorToken) {
        addAnchorToken(n12, child2);
      } else if (child2 instanceof FocusToken) {
        addFocusToken(n12, child2);
      }
    } else {
      throw new Error("Unexpected hyperscript child object: ".concat(child2));
    }
  };
  for (var child of children.flat(Infinity)) {
    addChild(child);
  }
  return nodes;
};
function createAnchor(tagName, attributes, children) {
  return new AnchorToken(attributes);
}
function createCursor(tagName, attributes, children) {
  return [new AnchorToken(attributes), new FocusToken(attributes)];
}
function createElement4(tagName, attributes, children) {
  return _objectSpread$13(_objectSpread$13({}, attributes), {}, {
    children: resolveDescendants(children)
  });
}
function createFocus(tagName, attributes, children) {
  return new FocusToken(attributes);
}
function createFragment(tagName, attributes, children) {
  return resolveDescendants(children);
}
function createSelection(tagName, attributes, children) {
  var anchor = children.find((c16) => c16 instanceof AnchorToken);
  var focus2 = children.find((c16) => c16 instanceof FocusToken);
  if (!anchor || anchor.offset == null || anchor.path == null) {
    throw new Error("The <selection> hyperscript tag must have an <anchor> tag as a child with `path` and `offset` attributes defined.");
  }
  if (!focus2 || focus2.offset == null || focus2.path == null) {
    throw new Error("The <selection> hyperscript tag must have a <focus> tag as a child with `path` and `offset` attributes defined.");
  }
  return _objectSpread$13({
    anchor: {
      offset: anchor.offset,
      path: anchor.path
    },
    focus: {
      offset: focus2.offset,
      path: focus2.path
    }
  }, attributes);
}
function createText(tagName, attributes, children) {
  var nodes = resolveDescendants(children);
  if (nodes.length > 1) {
    throw new Error("The <text> hyperscript tag must only contain a single node's worth of children.");
  }
  var [node] = nodes;
  if (node == null) {
    node = {
      text: ""
    };
  }
  if (!Text.isText(node)) {
    throw new Error("\n    The <text> hyperscript tag can only contain text content as children.");
  }
  STRINGS.delete(node);
  Object.assign(node, attributes);
  return node;
}
var createEditor2 = (makeEditor) => (tagName, attributes, children) => {
  var otherChildren = [];
  var selectionChild;
  for (var child of children) {
    if (Range.isRange(child)) {
      selectionChild = child;
    } else {
      otherChildren.push(child);
    }
  }
  var descendants = resolveDescendants(otherChildren);
  var selection = {};
  var editor = makeEditor();
  Object.assign(editor, attributes);
  editor.children = descendants;
  for (var [node, path] of Node2.texts(editor)) {
    var anchor = getAnchorOffset(node);
    var focus2 = getFocusOffset(node);
    if (anchor != null) {
      var [offset5] = anchor;
      selection.anchor = {
        path,
        offset: offset5
      };
    }
    if (focus2 != null) {
      var [_offset] = focus2;
      selection.focus = {
        path,
        offset: _offset
      };
    }
  }
  if (selection.anchor && !selection.focus) {
    throw new Error("Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<anchor />`. For collapsed selections, use `<cursor />` instead.");
  }
  if (!selection.anchor && selection.focus) {
    throw new Error("Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<focus />`. For collapsed selections, use `<cursor />` instead.");
  }
  if (selectionChild != null) {
    editor.selection = selectionChild;
  } else if (Range.isRange(selection)) {
    editor.selection = selection;
  }
  return editor;
};
function ownKeys3(object2, enumerableOnly) {
  var keys6 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    }
    keys6.push.apply(keys6, symbols);
  }
  return keys6;
}
function _objectSpread3(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15] != null ? arguments[i15] : {};
    if (i15 % 2) {
      ownKeys3(Object(source), true).forEach(function(key) {
        _defineProperty3(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys3(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
var DEFAULT_CREATORS = {
  anchor: createAnchor,
  cursor: createCursor,
  editor: createEditor2(createEditor),
  element: createElement4,
  focus: createFocus,
  fragment: createFragment,
  selection: createSelection,
  text: createText
};
var createHyperscript = function createHyperscript2() {
  var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var {
    elements = {}
  } = options;
  var elementCreators = normalizeElements(elements);
  var creators = _objectSpread3(_objectSpread3(_objectSpread3({}, DEFAULT_CREATORS), elementCreators), options.creators);
  var jsx2 = createFactory(creators);
  return jsx2;
};
var createFactory = (creators) => {
  var jsx2 = function jsx3(tagName, attributes) {
    for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      children[_key - 2] = arguments[_key];
    }
    var creator = creators[tagName];
    if (!creator) {
      throw new Error("No hyperscript creator found for tag: <".concat(tagName, ">"));
    }
    if (attributes == null) {
      attributes = {};
    }
    if (!isPlainObject2(attributes)) {
      children = [attributes].concat(children);
      attributes = {};
    }
    children = children.filter((child) => Boolean(child)).flat();
    var ret = creator(tagName, attributes, children);
    return ret;
  };
  return jsx2;
};
var normalizeElements = (elements) => {
  var creators = {};
  var _loop = function _loop2(tagName2) {
    var props = elements[tagName2];
    if (typeof props !== "object") {
      throw new Error("Properties specified for a hyperscript shorthand should be an object, but for the custom element <".concat(tagName2, ">  tag you passed: ").concat(props));
    }
    creators[tagName2] = (tagName3, attributes, children) => {
      return createElement4("element", _objectSpread3(_objectSpread3({}, props), attributes), children);
    };
  };
  for (var tagName in elements) {
    _loop(tagName);
  }
  return creators;
};
var jsx = createHyperscript();
var deserializeHtmlNodeChildren = (editor, node) => Array.from(node.childNodes).map(deserializeHtmlNode(editor)).flat();
var htmlBodyToFragment = (editor, element) => {
  if (element.nodeName === "BODY") {
    return jsx("fragment", {}, deserializeHtmlNodeChildren(editor, element));
  }
};
var htmlBrToNewLine = (node) => {
  if (node.nodeName === "BR") {
    return "\n";
  }
};
function castArray() {
  if (!arguments.length) {
    return [];
  }
  var value = arguments[0];
  return isArray_1(value) ? value : [value];
}
var castArray_1 = castArray;
var pluginDeserializeHtml = (editor, plugin, {
  element: el,
  deserializeLeaf
}) => {
  var _getNode;
  const {
    deserializeHtml: deserializeHtml2,
    isElement: isElementRoot,
    isLeaf: isLeafRoot,
    type
  } = plugin;
  if (!deserializeHtml2)
    return;
  const {
    attributeNames,
    query,
    isLeaf: isLeafRule,
    isElement: isElementRule,
    rules
  } = deserializeHtml2;
  let {
    getNode: getNode2
  } = deserializeHtml2;
  const isElement5 = isElementRule || isElementRoot;
  const isLeaf = isLeafRule || isLeafRoot;
  if (!deserializeLeaf && !isElement5) {
    return;
  }
  if (deserializeLeaf && !isLeaf) {
    return;
  }
  if (rules) {
    const isValid4 = rules.some(({
      validNodeName = "*",
      validStyle,
      validClassName,
      validAttribute
    }) => {
      if (validNodeName) {
        const validNodeNames = castArray_1(validNodeName);
        if (validNodeNames.length && !validNodeNames.includes(el.nodeName) && validNodeName !== "*")
          return false;
      }
      if (validClassName && !el.classList.contains(validClassName))
        return false;
      if (validStyle) {
        for (const [key, value] of Object.entries(validStyle)) {
          var _plugin$inject$props;
          const values3 = castArray_1(value);
          if (!values3.includes(el.style[key]) && value !== "*")
            return;
          if (value === "*" && !el.style[key])
            return;
          const defaultNodeValue = (_plugin$inject$props = plugin.inject.props) === null || _plugin$inject$props === void 0 ? void 0 : _plugin$inject$props.defaultNodeValue;
          if (defaultNodeValue && defaultNodeValue === el.style[key]) {
            return false;
          }
        }
      }
      if (validAttribute) {
        if (typeof validAttribute === "string") {
          if (!el.getAttributeNames().includes(validAttribute))
            return false;
        } else {
          for (const [attributeName, attributeValue] of Object.entries(validAttribute)) {
            const attributeValues = castArray_1(attributeValue);
            const elAttribute = el.getAttribute(attributeName);
            if (!elAttribute || !attributeValues.includes(elAttribute))
              return false;
          }
        }
      }
      return true;
    });
    if (!isValid4)
      return;
  }
  if (query && !query(el)) {
    return;
  }
  if (!getNode2) {
    if (isElement5) {
      getNode2 = () => ({
        type
      });
    } else if (isLeaf) {
      getNode2 = () => ({
        [type]: true
      });
    } else {
      return;
    }
  }
  let node = (_getNode = getNode2(el, {})) !== null && _getNode !== void 0 ? _getNode : {};
  if (!Object.keys(node).length)
    return;
  const injectedPlugins = getInjectedPlugins(editor, plugin);
  injectedPlugins.forEach((injectedPlugin) => {
    var _injectedPlugin$deser, _injectedPlugin$deser2;
    const res = (_injectedPlugin$deser = injectedPlugin.deserializeHtml) === null || _injectedPlugin$deser === void 0 ? void 0 : (_injectedPlugin$deser2 = _injectedPlugin$deser.getNode) === null || _injectedPlugin$deser2 === void 0 ? void 0 : _injectedPlugin$deser2.call(_injectedPlugin$deser, el, node);
    if (res) {
      node = {
        ...node,
        ...res
      };
    }
  });
  if (attributeNames) {
    const elementAttributes = {};
    const elementAttributeNames = el.getAttributeNames();
    for (const elementAttributeName of elementAttributeNames) {
      if (attributeNames.includes(elementAttributeName)) {
        elementAttributes[elementAttributeName] = el.getAttribute(elementAttributeName);
      }
    }
    if (Object.keys(elementAttributes).length) {
      node.attributes = elementAttributes;
    }
  }
  return {
    ...deserializeHtml2,
    node
  };
};
var pipeDeserializeHtmlElement = (editor, element) => {
  let result;
  [...editor.plugins].reverse().some((plugin) => {
    result = pluginDeserializeHtml(editor, plugin, {
      element
    });
    return !!result;
  });
  return result;
};
var htmlElementToElement = (editor, element) => {
  const deserialized = pipeDeserializeHtmlElement(editor, element);
  if (deserialized) {
    var _node$children;
    const {
      node,
      withoutChildren
    } = deserialized;
    let descendants = (_node$children = node.children) !== null && _node$children !== void 0 ? _node$children : deserializeHtmlNodeChildren(editor, element);
    if (!descendants.length || withoutChildren) {
      descendants = [{
        text: ""
      }];
    }
    return jsx("element", node, descendants);
  }
};
var merge = _createAssigner(function(object2, source, srcIndex) {
  _baseMerge(object2, source, srcIndex);
});
var merge_1 = merge;
var getNodeEntry = (editor, at, options) => Editor.node(editor, at, options);
var getPath = (editor, at, options) => Editor.path(editor, at, options);
var isVoid = (editor, value) => {
  return Editor.isVoid(editor, value);
};
var getNodeDescendants = (root6, options) => Node2.descendants(root6, options);
var isBlock = (editor, value) => Editor.isBlock(editor, value);
var match = (obj, path, predicate) => {
  if (!predicate)
    return true;
  if (typeof predicate === "object") {
    return Object.entries(predicate).every(([key, value]) => {
      const values3 = castArray_1(value);
      return values3.includes(obj[key]);
    });
  }
  return predicate(obj, path);
};
var getQueryOptions = (editor, options = {}) => {
  const {
    match: _match,
    block
  } = options;
  return {
    ...options,
    match: _match || block ? (n12, path) => match(n12, path, _match) && (!block || isBlock(editor, n12)) : void 0
  };
};
var findDescendant = (editor, options) => {
  try {
    const {
      match: _match,
      at = editor.selection,
      reverse = false,
      voids = false
    } = options;
    if (!at)
      return;
    let from2;
    let to4;
    if (Span.isSpan(at)) {
      [from2, to4] = at;
    } else if (Range.isRange(at)) {
      const first = getPath(editor, at, {
        edge: "start"
      });
      const last2 = getPath(editor, at, {
        edge: "end"
      });
      from2 = reverse ? last2 : first;
      to4 = reverse ? first : last2;
    }
    let root6 = [editor, []];
    if (Path.isPath(at)) {
      root6 = getNodeEntry(editor, at);
    }
    const nodeEntries = getNodeDescendants(root6[0], {
      reverse,
      from: from2,
      to: to4,
      pass: ([n12]) => voids ? false : isVoid(editor, n12)
    });
    for (const [node, path] of nodeEntries) {
      if (match(node, path, _match)) {
        return [node, at.concat(path)];
      }
    }
  } catch (error2) {
    return void 0;
  }
};
var unhangRange = (editor, range, options = {}) => {
  const {
    voids,
    unhang = true
  } = options;
  if (Range.isRange(range) && unhang) {
    return Editor.unhangRange(editor, range, {
      voids
    });
  }
};
var getNodeEntries = (editor, options) => {
  unhangRange(editor, options === null || options === void 0 ? void 0 : options.at, options);
  return Editor.nodes(editor, getQueryOptions(editor, options));
};
var findNode = (editor, options = {}) => {
  try {
    const nodeEntries = getNodeEntries(editor, {
      at: editor.selection || [],
      ...getQueryOptions(editor, options)
    });
    for (const [node, path] of nodeEntries) {
      return [node, path];
    }
  } catch (error2) {
    return void 0;
  }
};
var getAboveNode = (editor, options) => Editor.above(editor, getQueryOptions(editor, options));
var getBlockAbove = (editor, options = {}) => getAboveNode(editor, {
  ...options,
  block: true
});
var isAncestor = (value) => Element2.isAncestor(value);
var getChildren = (nodeEntry) => {
  const [node, path] = nodeEntry;
  if (isAncestor(node)) {
    const {
      children
    } = node;
    return children.map((child, index2) => {
      const childPath = path.concat([index2]);
      return [child, childPath];
    });
  }
  return [];
};
var getEdgePoints = (editor, at) => Editor.edges(editor, at);
var getEdgeBlocksAbove = (editor, {
  at: _at,
  ...options
} = {}) => {
  const at = _at !== null && _at !== void 0 ? _at : editor.selection;
  if (!at)
    return null;
  const [start3, end2] = getEdgePoints(editor, at !== null && at !== void 0 ? at : editor.selection);
  const startBlock = getBlockAbove(editor, {
    at: start3,
    ...options
  });
  if (!startBlock)
    return null;
  const endBlock = getBlockAbove(editor, {
    at: end2,
    ...options
  });
  if (!endBlock)
    return null;
  return [startBlock, endBlock];
};
var getLastChild$1 = (nodeEntry) => {
  const [node, path] = nodeEntry;
  if (isText(node))
    return null;
  if (!node.children.length)
    return null;
  const children = node.children;
  return [children[children.length - 1], path.concat([children.length - 1])];
};
var getLastChildPath = (nodeEntry) => {
  const lastChild = getLastChild$1(nodeEntry);
  if (!lastChild)
    return nodeEntry[1].concat([-1]);
  return lastChild[1];
};
var isLastChild = (parentEntry, childPath) => {
  const lastChildPath = getLastChildPath(parentEntry);
  return Path.equals(lastChildPath, childPath);
};
var getLastNode = (editor, at) => Editor.last(editor, at);
var getLastChild = (node, level) => {
  if (!(level + 1) || !isAncestor(node))
    return node;
  const {
    children
  } = node;
  const lastNode = children[children.length - 1];
  return getLastChild(lastNode, level - 1);
};
var getLastNodeByLevel = (editor, level) => {
  const {
    children
  } = editor;
  const lastNode = children[children.length - 1];
  if (!lastNode)
    return;
  const [, lastPath] = getLastNode(editor, []);
  return [getLastChild(lastNode, level - 1), lastPath.slice(0, level + 1)];
};
var getMarks = (editor) => Editor.marks(editor);
var getMark = (editor, type) => {
  if (!editor)
    return;
  const marks = getMarks(editor);
  return marks === null || marks === void 0 ? void 0 : marks[type];
};
var getNextSiblingNodes = (ancestorEntry, path) => {
  const [ancestor, ancestorPath] = ancestorEntry;
  const leafIndex = path[ancestorPath.length];
  const siblings = [];
  const ancestorChildren = ancestor.children;
  if (leafIndex + 1 < ancestor.children.length) {
    for (let i15 = leafIndex + 1; i15 < ancestor.children.length; i15++) {
      siblings.push(ancestorChildren[i15]);
    }
  }
  return siblings;
};
function arrayMap(array2, iteratee) {
  var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array2[index2], index2, array2);
  }
  return result;
}
var _arrayMap = arrayMap;
var HASH_UNDEFINED2 = "__lodash_hash_undefined__";
function setCacheAdd2(value) {
  this.__data__.set(value, HASH_UNDEFINED2);
  return this;
}
var _setCacheAdd2 = setCacheAdd2;
function setCacheHas2(value) {
  return this.__data__.has(value);
}
var _setCacheHas2 = setCacheHas2;
function SetCache2(values3) {
  var index2 = -1, length = values3 == null ? 0 : values3.length;
  this.__data__ = new _MapCache2();
  while (++index2 < length) {
    this.add(values3[index2]);
  }
}
SetCache2.prototype.add = SetCache2.prototype.push = _setCacheAdd2;
SetCache2.prototype.has = _setCacheHas2;
var _SetCache = SetCache2;
function arraySome(array2, predicate) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (predicate(array2[index2], index2, array2)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome;
function cacheHas(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas;
var COMPARE_PARTIAL_FLAG$5 = 1;
var COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays(array2, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array2.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array2);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array2;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new _SetCache() : void 0;
  stack.set(array2, other);
  stack.set(other, array2);
  while (++index2 < arrLength) {
    var arrValue = array2[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!_arraySome(other, function(othValue2, othIndex) {
        if (!_cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array2);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays;
function mapToArray(map5) {
  var index2 = -1, result = Array(map5.size);
  map5.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray;
function setToArray(set3) {
  var index2 = -1, result = Array(set3.size);
  set3.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var _setToArray = setToArray;
var COMPARE_PARTIAL_FLAG$4 = 1;
var COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag$2 = "[object Boolean]";
var dateTag$2 = "[object Date]";
var errorTag$12 = "[object Error]";
var mapTag$4 = "[object Map]";
var numberTag$2 = "[object Number]";
var regexpTag$2 = "[object RegExp]";
var setTag$4 = "[object Set]";
var stringTag$2 = "[object String]";
var symbolTag$3 = "[object Symbol]";
var arrayBufferTag$2 = "[object ArrayBuffer]";
var dataViewTag$3 = "[object DataView]";
var symbolProto$2 = _Symbol2 ? _Symbol2.prototype : void 0;
var symbolValueOf$1 = symbolProto$2 ? symbolProto$2.valueOf : void 0;
function equalByTag(object2, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$3:
      if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
        return false;
      }
      object2 = object2.buffer;
      other = other.buffer;
    case arrayBufferTag$2:
      if (object2.byteLength != other.byteLength || !equalFunc(new _Uint8Array(object2), new _Uint8Array(other))) {
        return false;
      }
      return true;
    case boolTag$2:
    case dateTag$2:
    case numberTag$2:
      return eq_12(+object2, +other);
    case errorTag$12:
      return object2.name == other.name && object2.message == other.message;
    case regexpTag$2:
    case stringTag$2:
      return object2 == other + "";
    case mapTag$4:
      var convert = _mapToArray;
    case setTag$4:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert || (convert = _setToArray);
      if (object2.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object2);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object2, other);
      var result = _equalArrays(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object2);
      return result;
    case symbolTag$3:
      if (symbolValueOf$1) {
        return symbolValueOf$1.call(object2) == symbolValueOf$1.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag;
function arrayPush(array2, values3) {
  var index2 = -1, length = values3.length, offset5 = array2.length;
  while (++index2 < length) {
    array2[offset5 + index2] = values3[index2];
  }
  return array2;
}
var _arrayPush = arrayPush;
function baseGetAllKeys(object2, keysFunc, symbolsFunc) {
  var result = keysFunc(object2);
  return isArray_1(object2) ? result : _arrayPush(result, symbolsFunc(object2));
}
var _baseGetAllKeys = baseGetAllKeys;
function arrayFilter(array2, predicate) {
  var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array2[index2];
    if (predicate(value, index2, array2)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter;
function stubArray() {
  return [];
}
var stubArray_1 = stubArray;
var objectProto$52 = Object.prototype;
var propertyIsEnumerable2 = objectProto$52.propertyIsEnumerable;
var nativeGetSymbols$1 = Object.getOwnPropertySymbols;
var getSymbols = !nativeGetSymbols$1 ? stubArray_1 : function(object2) {
  if (object2 == null) {
    return [];
  }
  object2 = Object(object2);
  return _arrayFilter(nativeGetSymbols$1(object2), function(symbol) {
    return propertyIsEnumerable2.call(object2, symbol);
  });
};
var _getSymbols = getSymbols;
var nativeKeys2 = _overArg2(Object.keys, Object);
var _nativeKeys = nativeKeys2;
var objectProto$42 = Object.prototype;
var hasOwnProperty$42 = objectProto$42.hasOwnProperty;
function baseKeys(object2) {
  if (!_isPrototype(object2)) {
    return _nativeKeys(object2);
  }
  var result = [];
  for (var key in Object(object2)) {
    if (hasOwnProperty$42.call(object2, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys;
function keys(object2) {
  return isArrayLike_1(object2) ? _arrayLikeKeys(object2) : _baseKeys(object2);
}
var keys_1 = keys;
function getAllKeys(object2) {
  return _baseGetAllKeys(object2, keys_1, _getSymbols);
}
var _getAllKeys = getAllKeys;
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$32 = Object.prototype;
var hasOwnProperty$32 = objectProto$32.hasOwnProperty;
function equalObjects(object2, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = _getAllKeys(object2), objLength = objProps.length, othProps = _getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty$32.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object2);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object2;
  }
  var result = true;
  stack.set(object2, other);
  stack.set(other, object2);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object2[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object2.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object2);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects;
var DataView2 = _getNative2(_root2, "DataView");
var _DataView2 = DataView2;
var Promise$12 = _getNative2(_root2, "Promise");
var _Promise2 = Promise$12;
var Set3 = _getNative2(_root2, "Set");
var _Set2 = Set3;
var WeakMap$1 = _getNative2(_root2, "WeakMap");
var _WeakMap2 = WeakMap$1;
var mapTag$3 = "[object Map]";
var objectTag$22 = "[object Object]";
var promiseTag2 = "[object Promise]";
var setTag$3 = "[object Set]";
var weakMapTag$12 = "[object WeakMap]";
var dataViewTag$22 = "[object DataView]";
var dataViewCtorString2 = _toSource2(_DataView2);
var mapCtorString2 = _toSource2(_Map2);
var promiseCtorString2 = _toSource2(_Promise2);
var setCtorString2 = _toSource2(_Set2);
var weakMapCtorString2 = _toSource2(_WeakMap2);
var getTag2 = _baseGetTag2;
if (_DataView2 && getTag2(new _DataView2(new ArrayBuffer(1))) != dataViewTag$22 || _Map2 && getTag2(new _Map2()) != mapTag$3 || _Promise2 && getTag2(_Promise2.resolve()) != promiseTag2 || _Set2 && getTag2(new _Set2()) != setTag$3 || _WeakMap2 && getTag2(new _WeakMap2()) != weakMapTag$12) {
  getTag2 = function(value) {
    var result = _baseGetTag2(value), Ctor = result == objectTag$22 ? value.constructor : void 0, ctorString = Ctor ? _toSource2(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString2:
          return dataViewTag$22;
        case mapCtorString2:
          return mapTag$3;
        case promiseCtorString2:
          return promiseTag2;
        case setCtorString2:
          return setTag$3;
        case weakMapCtorString2:
          return weakMapTag$12;
      }
    }
    return result;
  };
}
var _getTag = getTag2;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag$12 = "[object Arguments]";
var arrayTag$12 = "[object Array]";
var objectTag$12 = "[object Object]";
var objectProto$22 = Object.prototype;
var hasOwnProperty$22 = objectProto$22.hasOwnProperty;
function baseIsEqualDeep(object2, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_1(object2), othIsArr = isArray_1(other), objTag = objIsArr ? arrayTag$12 : _getTag(object2), othTag = othIsArr ? arrayTag$12 : _getTag(other);
  objTag = objTag == argsTag$12 ? objectTag$12 : objTag;
  othTag = othTag == argsTag$12 ? objectTag$12 : othTag;
  var objIsObj = objTag == objectTag$12, othIsObj = othTag == objectTag$12, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_12(object2)) {
    if (!isBuffer_12(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new _Stack());
    return objIsArr || isTypedArray_1(object2) ? _equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : _equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$22.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$22.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new _Stack());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new _Stack());
  return _equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep;
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_12(value) && !isObjectLike_12(other)) {
    return value !== value && other !== other;
  }
  return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}
var _baseIsEqual = baseIsEqual;
var COMPARE_PARTIAL_FLAG$1 = 1;
var COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch(object2, source, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object2 == null) {
    return !length;
  }
  object2 = Object(object2);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key = data[0], objValue = object2[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object2)) {
        return false;
      }
    } else {
      var stack = new _Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object2, source, stack);
      }
      if (!(result === void 0 ? _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch;
function isStrictComparable(value) {
  return value === value && !isObject_12(value);
}
var _isStrictComparable = isStrictComparable;
function getMatchData(object2) {
  var result = keys_1(object2), length = result.length;
  while (length--) {
    var key = result[length], value = object2[key];
    result[length] = [key, value, _isStrictComparable(value)];
  }
  return result;
}
var _getMatchData = getMatchData;
function matchesStrictComparable(key, srcValue) {
  return function(object2) {
    if (object2 == null) {
      return false;
    }
    return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
  };
}
var _matchesStrictComparable = matchesStrictComparable;
function baseMatches(source) {
  var matchData = _getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return _matchesStrictComparable(matchData[0][0], matchData[0][1]);
  }
  return function(object2) {
    return object2 === source || _baseIsMatch(object2, source, matchData);
  };
}
var _baseMatches = baseMatches;
var symbolTag$2 = "[object Symbol]";
function isSymbol(value) {
  return typeof value == "symbol" || isObjectLike_12(value) && _baseGetTag2(value) == symbolTag$2;
}
var isSymbol_1 = isSymbol;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp = /^\w*$/;
function isKey(value, object2) {
  if (isArray_1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_1(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
}
var _isKey = isKey;
var FUNC_ERROR_TEXT2 = "Expected a function";
function memoize2(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT2);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize2.Cache || _MapCache2)();
  return memoized;
}
memoize2.Cache = _MapCache2;
var memoize_12 = memoize2;
var MAX_MEMOIZE_SIZE2 = 500;
function memoizeCapped2(func) {
  var result = memoize_12(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE2) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped2 = memoizeCapped2;
var rePropName2 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar2 = /\\(\\)?/g;
var stringToPath2 = _memoizeCapped2(function(string2) {
  var result = [];
  if (string2.charCodeAt(0) === 46) {
    result.push("");
  }
  string2.replace(rePropName2, function(match5, number2, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar2, "$1") : number2 || match5);
  });
  return result;
});
var _stringToPath = stringToPath2;
var INFINITY$12 = 1 / 0;
var symbolProto$12 = _Symbol2 ? _Symbol2.prototype : void 0;
var symbolToString2 = symbolProto$12 ? symbolProto$12.toString : void 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_1(value)) {
    return _arrayMap(value, baseToString) + "";
  }
  if (isSymbol_1(value)) {
    return symbolToString2 ? symbolToString2.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$12 ? "-0" : result;
}
var _baseToString = baseToString;
function toString(value) {
  return value == null ? "" : _baseToString(value);
}
var toString_1 = toString;
function castPath(value, object2) {
  if (isArray_1(value)) {
    return value;
  }
  return _isKey(value, object2) ? [value] : _stringToPath(toString_1(value));
}
var _castPath = castPath;
var INFINITY2 = 1 / 0;
function toKey(value) {
  if (typeof value == "string" || isSymbol_1(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY2 ? "-0" : result;
}
var _toKey = toKey;
function baseGet(object2, path) {
  path = _castPath(path, object2);
  var index2 = 0, length = path.length;
  while (object2 != null && index2 < length) {
    object2 = object2[_toKey(path[index2++])];
  }
  return index2 && index2 == length ? object2 : void 0;
}
var _baseGet = baseGet;
function get(object2, path, defaultValue) {
  var result = object2 == null ? void 0 : _baseGet(object2, path);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get;
function baseHasIn(object2, key) {
  return object2 != null && key in Object(object2);
}
var _baseHasIn = baseHasIn;
function hasPath(object2, path, hasFunc) {
  path = _castPath(path, object2);
  var index2 = -1, length = path.length, result = false;
  while (++index2 < length) {
    var key = _toKey(path[index2]);
    if (!(result = object2 != null && hasFunc(object2, key))) {
      break;
    }
    object2 = object2[key];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object2 == null ? 0 : object2.length;
  return !!length && isLength_12(length) && _isIndex(key, length) && (isArray_1(object2) || isArguments_1(object2));
}
var _hasPath = hasPath;
function hasIn(object2, path) {
  return object2 != null && _hasPath(object2, path, _baseHasIn);
}
var hasIn_1 = hasIn;
var COMPARE_PARTIAL_FLAG = 1;
var COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty(path, srcValue) {
  if (_isKey(path) && _isStrictComparable(srcValue)) {
    return _matchesStrictComparable(_toKey(path), srcValue);
  }
  return function(object2) {
    var objValue = get_1(object2, path);
    return objValue === void 0 && objValue === srcValue ? hasIn_1(object2, path) : _baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
var _baseMatchesProperty = baseMatchesProperty;
function baseProperty(key) {
  return function(object2) {
    return object2 == null ? void 0 : object2[key];
  };
}
var _baseProperty = baseProperty;
function basePropertyDeep(path) {
  return function(object2) {
    return _baseGet(object2, path);
  };
}
var _basePropertyDeep = basePropertyDeep;
function property(path) {
  return _isKey(path) ? _baseProperty(_toKey(path)) : _basePropertyDeep(path);
}
var property_1 = property;
function baseIteratee(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_1;
  }
  if (typeof value == "object") {
    return isArray_1(value) ? _baseMatchesProperty(value[0], value[1]) : _baseMatches(value);
  }
  return property_1(value);
}
var _baseIteratee = baseIteratee;
function baseForOwn(object2, iteratee) {
  return object2 && _baseFor(object2, iteratee, keys_1);
}
var _baseForOwn = baseForOwn;
function createBaseEach(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_1(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var _createBaseEach = createBaseEach;
var baseEach = _createBaseEach(_baseForOwn);
var _baseEach = baseEach;
function baseMap(collection, iteratee) {
  var index2 = -1, result = isArrayLike_1(collection) ? Array(collection.length) : [];
  _baseEach(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
var _baseMap = baseMap;
function map(collection, iteratee) {
  var func = isArray_1(collection) ? _arrayMap : _baseMap;
  return func(collection, _baseIteratee(iteratee));
}
var map_1 = map;
var getEditorString = (editor, at, options) => at ? Editor.string(editor, at, options) : "";
var getPoint = (editor, at, options) => Editor.point(editor, at, options);
var getPointBefore = (editor, at, options) => Editor.before(editor, at, options);
var isRangeAcrossBlocks = (editor, {
  at,
  ...options
} = {}) => {
  if (!at)
    at = editor.selection;
  if (!at)
    return false;
  const [start3, end2] = Range.edges(at);
  const startBlock = getBlockAbove(editor, {
    at: start3,
    ...options
  });
  const endBlock = getBlockAbove(editor, {
    at: end2,
    ...options
  });
  return startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);
};
var getPointBeforeLocation = (editor, at, options) => {
  if (!options || !options.match && !options.matchString) {
    return getPointBefore(editor, at, options);
  }
  const unitOffset = !options.unit || options.unit === "offset";
  const matchStrings = options.matchString ? castArray_1(options.matchString) : [""];
  let point;
  matchStrings.some((matchString) => {
    let beforeAt = at;
    let previousBeforePoint = getPoint(editor, at, {
      edge: "end"
    });
    const stackLength = matchString.length + 1;
    const stack = Array(stackLength);
    let count2 = 0;
    while (true) {
      var _options$match;
      const beforePoint = getPointBefore(editor, beforeAt, options);
      if (!beforePoint)
        return;
      if (isRangeAcrossBlocks(editor, {
        at: {
          anchor: beforePoint,
          focus: previousBeforePoint
        }
      })) {
        return;
      }
      const beforeString = getEditorString(editor, {
        anchor: beforePoint,
        focus: previousBeforePoint
      });
      let beforeStringToMatch = beforeString;
      if (unitOffset && stackLength) {
        stack.unshift({
          point: beforePoint,
          text: beforeString
        });
        stack.pop();
        beforeStringToMatch = map_1(stack.slice(0, -1), "text").join("");
      }
      if (matchString === beforeStringToMatch || (_options$match = options.match) !== null && _options$match !== void 0 && _options$match.call(options, {
        beforeString: beforeStringToMatch,
        beforePoint,
        at
      })) {
        if (options.afterMatch) {
          if (stackLength && unitOffset) {
            var _stack;
            point = (_stack = stack[stack.length - 1]) === null || _stack === void 0 ? void 0 : _stack.point;
            return !!point;
          }
          point = previousBeforePoint;
          return true;
        }
        point = beforePoint;
        return true;
      }
      previousBeforePoint = beforePoint;
      beforeAt = beforePoint;
      count2 += 1;
      if (!options.skipInvalid) {
        if (!matchString || count2 > matchString.length)
          return;
      }
    }
  });
  return point;
};
var getPointFromLocation = (editor, {
  at = editor.selection,
  focus: focus2
} = {}) => {
  let point;
  if (Range.isRange(at))
    point = !focus2 ? at.anchor : at.focus;
  if (Point.isPoint(at))
    point = at;
  if (Path.isPath(at))
    point = {
      path: at,
      offset: 0
    };
  return point;
};
var getPointAfter = (editor, at, options) => Editor.after(editor, at, options);
var getVoidNode = (editor, options) => Editor.void(editor, options);
var getPreviousNode = (editor, options) => Editor.previous(editor, options);
var queryNode = (entry, {
  filter,
  allow,
  exclude
} = {}) => {
  if (!entry)
    return false;
  if (filter && !filter(entry)) {
    return false;
  }
  if (allow) {
    const allows = castArray_1(allow);
    if (allows.length && !allows.includes(entry[0].type)) {
      return false;
    }
  }
  if (exclude) {
    const excludes = castArray_1(exclude);
    if (excludes.length && excludes.includes(entry[0].type)) {
      return false;
    }
  }
  return true;
};
var getPreviousPath = (path) => {
  if (path.length === 0)
    return;
  const last2 = path[path.length - 1];
  if (last2 <= 0)
    return;
  return path.slice(0, -1).concat(last2 - 1);
};
var getRangeBefore = (editor, at, options) => {
  const anchor = getPointBeforeLocation(editor, at, options);
  if (!anchor)
    return;
  const focus2 = getPoint(editor, at, {
    edge: "end"
  });
  return {
    anchor,
    focus: focus2
  };
};
var getStartPoint = (editor, at) => Editor.start(editor, at);
var getRangeFromBlockStart = (editor, options = {}) => {
  var _getBlockAbove;
  const path = (_getBlockAbove = getBlockAbove(editor, options)) === null || _getBlockAbove === void 0 ? void 0 : _getBlockAbove[1];
  if (!path)
    return;
  const start3 = getStartPoint(editor, path);
  const focus2 = getPointFromLocation(editor, options);
  if (!focus2)
    return;
  return {
    anchor: start3,
    focus: focus2
  };
};
var hasSingleChild = (node) => {
  if (isText(node)) {
    return true;
  }
  return node.children.length === 1 && hasSingleChild(node.children[0]);
};
var isInline = (editor, value) => Editor.isInline(editor, value);
var getNodeString = (node) => Node2.string(node);
var isAncestorEmpty = (editor, node) => !getNodeString(node) && !node.children.some((n12) => isInline(editor, n12));
var isBlockAboveEmpty = (editor) => {
  var _getBlockAbove;
  const block = (_getBlockAbove = getBlockAbove(editor)) === null || _getBlockAbove === void 0 ? void 0 : _getBlockAbove[0];
  if (!block)
    return false;
  return isAncestorEmpty(editor, block);
};
var getParentNode = (editor, at, options) => {
  try {
    return Editor.parent(editor, at, options);
  } catch (err) {
  }
};
var isEndPoint = (editor, point, at) => !!point && Editor.isEnd(editor, point, at);
var isBlockTextEmptyAfterSelection = (editor) => {
  if (!editor.selection)
    return false;
  const blockAbove = getBlockAbove(editor);
  if (!blockAbove)
    return false;
  const cursor = editor.selection.focus;
  const selectionParentEntry = getParentNode(editor, editor.selection);
  if (!selectionParentEntry)
    return false;
  const [, selectionParentPath] = selectionParentEntry;
  if (!isEndPoint(editor, cursor, selectionParentPath))
    return false;
  const siblingNodes = getNextSiblingNodes(blockAbove, cursor.path);
  if (siblingNodes.length) {
    for (const siblingNode of siblingNodes) {
      if (isText(siblingNode) && siblingNode.text) {
        return false;
      }
    }
  } else {
    return isEndPoint(editor, cursor, blockAbove[1]);
  }
  return true;
};
var isFirstChild = (path) => path[path.length - 1] === 0;
var isMarkActive = (editor, type) => {
  return isDefined(getMark(editor, type));
};
var getRange = (editor, at, to4) => Editor.range(editor, at, to4);
var isSelectionAtBlockEnd = (editor) => {
  var _getBlockAbove, _editor$selection;
  const path = (_getBlockAbove = getBlockAbove(editor)) === null || _getBlockAbove === void 0 ? void 0 : _getBlockAbove[1];
  return !!path && isEndPoint(editor, (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.focus, path);
};
var isStartPoint = (editor, point, at) => !!point && Editor.isStart(editor, point, at);
var isSelectionAtBlockStart = (editor, options) => {
  var _getBlockAbove, _editor$selection;
  const path = (_getBlockAbove = getBlockAbove(editor, options)) === null || _getBlockAbove === void 0 ? void 0 : _getBlockAbove[1];
  return !!path && isStartPoint(editor, (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.focus, path);
};
var isExpanded = (range) => !!range && Range.isExpanded(range);
var getNode = (root6, path) => {
  try {
    return Node2.get(root6, path);
  } catch (err) {
    return null;
  }
};
var isType = (editor, node, key) => {
  const keys6 = castArray_1(key);
  const types = [];
  keys6.forEach((_key) => types.push(getPluginType(editor, _key)));
  return types.includes(node === null || node === void 0 ? void 0 : node.type);
};
var someNode = (editor, options) => {
  return !!findNode(editor, options);
};
var applyDeepToNodes = ({
  node,
  source,
  apply: apply5,
  query
}) => {
  const entry = [node, []];
  if (queryNode(entry, query)) {
    if (source instanceof Function) {
      apply5(node, source());
    } else {
      apply5(node, source);
    }
  }
  if (!isAncestor(node))
    return;
  node.children.forEach((child) => {
    applyDeepToNodes({
      node: child,
      source,
      apply: apply5,
      query
    });
  });
};
var mergeDeepToNodes = (options) => {
  applyDeepToNodes({
    ...options,
    apply: merge_1
  });
};
var pipeDeserializeHtmlLeaf = (editor, element) => {
  let node = {};
  [...editor.plugins].reverse().forEach((plugin) => {
    const deserialized = pluginDeserializeHtml(editor, plugin, {
      element,
      deserializeLeaf: true
    });
    if (!deserialized)
      return;
    node = {
      ...node,
      ...deserialized.node
    };
  });
  return node;
};
var htmlElementToLeaf = (editor, element) => {
  const node = pipeDeserializeHtmlLeaf(editor, element);
  return deserializeHtmlNodeChildren(editor, element).reduce((arr, child) => {
    if (!child)
      return arr;
    if (isElement2(child)) {
      if (Object.keys(node).length) {
        mergeDeepToNodes({
          node: child,
          source: node,
          query: {
            filter: ([n12]) => isText(n12)
          }
        });
      }
      arr.push(child);
    } else {
      const attributes = {
        ...node
      };
      if (isText(child) && child.text) {
        Object.keys(attributes).forEach((key) => {
          if (attributes[key] && child[key]) {
            attributes[key] = child[key];
          }
        });
      }
      arr.push(jsx("text", attributes, child));
    }
    return arr;
  }, []);
};
var isHtmlText = (node) => node.nodeType === Node.TEXT_NODE;
var htmlTextNodeToString = (node) => {
  if (isHtmlText(node)) {
    return node.nodeValue === "\n" ? null : node.textContent;
  }
};
var isHtmlElement = (node) => node.nodeType === Node.ELEMENT_NODE;
var deserializeHtmlNode = (editor) => (node) => {
  const textNode = htmlTextNodeToString(node);
  if (textNode)
    return textNode;
  if (!isHtmlElement(node))
    return null;
  const breakLine = htmlBrToNewLine(node);
  if (breakLine)
    return breakLine;
  const fragment = htmlBodyToFragment(editor, node);
  if (fragment)
    return fragment;
  const element = htmlElementToElement(editor, node);
  if (element)
    return element;
  return htmlElementToLeaf(editor, node);
};
var deserializeHtmlElement = (editor, element) => {
  return deserializeHtmlNode(editor)(element);
};
var htmlStringToDOMNode = (rawHtml, stripWhitespace = true) => {
  const node = document.createElement("body");
  node.innerHTML = rawHtml;
  if (stripWhitespace) {
    node.innerHTML = node.innerHTML.replace(/(\r\n|\n|\r|\t)/gm, "");
  }
  return node;
};
var deserializeHtml = (editor, {
  element,
  stripWhitespace = true
}) => {
  if (typeof element === "string") {
    element = htmlStringToDOMNode(element, stripWhitespace);
  }
  const fragment = deserializeHtmlElement(editor, element);
  return normalizeDescendantsToDocumentFragment(editor, {
    descendants: fragment
  });
};
var parseHtmlDocument = (html) => {
  return new DOMParser().parseFromString(html, "text/html");
};
var KEY_DESERIALIZE_HTML = "deserializeHtml";
var createDeserializeHtmlPlugin = createPluginFactory({
  key: KEY_DESERIALIZE_HTML,
  then: (editor) => ({
    editor: {
      insertData: {
        format: "text/html",
        getFragment: ({
          data
        }) => {
          const document2 = parseHtmlDocument(data);
          return deserializeHtml(editor, {
            element: document2.body
          });
        }
      }
    }
  })
});
var SCOPE_PLATE = Symbol("plate");
var plateIdAtom = atom2(null);
var usePlateId = (scope = SCOPE_PLATE) => {
  const [plateId] = useAtom(plateIdAtom, scope);
  return plateId;
};
var getEventEditorId = (id) => {
  var _eventEditorSelectors;
  if (id)
    return id;
  const focus2 = eventEditorSelectors.focus();
  if (focus2)
    return focus2;
  const blur = eventEditorSelectors.blur();
  if (blur)
    return blur;
  return (_eventEditorSelectors = eventEditorSelectors.last()) !== null && _eventEditorSelectors !== void 0 ? _eventEditorSelectors : "main";
};
var loadingStore = createPlateStore({
  id: "loading"
});
var getPlateStore = (id) => {
  id = getEventEditorId(id);
  const store = platesStore.get.get(id);
  return store || loadingStore;
};
var usePlateStore = (id) => {
  var _ref, _id;
  const plateId = usePlateId();
  id = (_ref = (_id = id) !== null && _id !== void 0 ? _id : plateId) !== null && _ref !== void 0 ? _ref : "main";
  const store = platesStore.use.get(id);
  if (store) {
    return store;
  }
  console.warn("The plate hooks must be used inside the <PlateProvider id={id}> component's context.");
  return store || loadingStore;
};
var setPlateState = (draft, state) => {
  if (!isUndefined(state.onChange))
    draft.onChange = state.onChange;
  if (!isUndefined(state.plugins))
    draft.plugins = state.plugins;
  if (!isUndefined(state.editableProps))
    draft.editableProps = state.editableProps;
  if (!isUndefined(state.renderElement))
    draft.renderElement = state.renderElement;
  if (!isUndefined(state.renderLeaf))
    draft.renderLeaf = state.renderLeaf;
  if (!isUndefined(state.decorate))
    draft.decorate = state.decorate;
  if (!isUndefined(state.enabled))
    draft.enabled = state.enabled;
  if (!isUndefined(state.editor)) {
    draft.editor = state.editor;
    if (state.editor) {
      draft.value = state.editor.children;
    }
  }
  if (!isUndefined(state.initialValue))
    draft.value = state.initialValue;
  if (!isUndefined(state.value))
    draft.value = state.value;
  return draft;
};
var createPlatesStore = (initialState2 = {}) => createStore4("plate")(initialState2).extendActions((set3) => ({
  /**
   * Set state by id.
   * If the store is not yet initialized, it will be initialized.
   * If the store is already set, it will be updated.
   */
  // eslint-disable-next-line prettier/prettier
  set: (id, state) => {
    set3.state((draft) => {
      if (!id)
        return;
      let store = draft[id];
      if (!store) {
        store = createPlateStore({
          id,
          ...setPlateState({}, state !== null && state !== void 0 ? state : {})
        });
        draft[id] = store;
        eventEditorActions.last(id);
      }
    });
  },
  /**
   * Remove state by id. Called by `Plate` on unmount.
   */
  unset: (id) => {
    set3.state((draft) => {
      delete draft[id];
    });
  }
})).extendSelectors((state) => ({
  // eslint-disable-next-line prettier/prettier
  get(id) {
    return state[id];
  },
  has(id) {
    const ids = castArray_1(id);
    return ids.every((_id) => !!state[_id]);
  }
}));
var platesStore = createPlatesStore({});
var platesActions = platesStore.set;
var platesSelectors = platesStore.get;
var usePlatesSelectors = platesStore.use;
var getPlateActions = (id) => getPlateStore(id).set;
var usePlateSelectors = (id) => usePlateStore(id).use;
function arrayAggregator(array2, setter, iteratee, accumulator) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    var value = array2[index2];
    setter(accumulator, value, iteratee(value), array2);
  }
  return accumulator;
}
var _arrayAggregator = arrayAggregator;
function baseAggregator(collection, setter, iteratee, accumulator) {
  _baseEach(collection, function(value, key, collection2) {
    setter(accumulator, value, iteratee(value), collection2);
  });
  return accumulator;
}
var _baseAggregator = baseAggregator;
function createAggregator(setter, initializer) {
  return function(collection, iteratee) {
    var func = isArray_1(collection) ? _arrayAggregator : _baseAggregator, accumulator = initializer ? initializer() : {};
    return func(collection, setter, _baseIteratee(iteratee), accumulator);
  };
}
var _createAggregator = createAggregator;
var keyBy = _createAggregator(function(result, value, key) {
  _baseAssignValue(result, key, value);
});
var keyBy_1 = keyBy;
function baseValues(object2, props) {
  return _arrayMap(props, function(key) {
    return object2[key];
  });
}
var _baseValues = baseValues;
function values(object2) {
  return object2 == null ? [] : _baseValues(object2, keys_1(object2));
}
var values_1 = values;
var mergeDeepPlugins = (editor, _plugin) => {
  const plugin = {
    ..._plugin
  };
  const {
    then
  } = plugin;
  if (then) {
    delete plugin.then;
    const {
      plugins: pluginPlugins
    } = plugin;
    const pluginThen = mergeDeepPlugins(editor, defaultsDeep_1(then(editor, plugin), plugin));
    if (pluginPlugins && pluginThen.plugins) {
      const merged = merge_1(keyBy_1(pluginPlugins, "key"), keyBy_1(pluginThen.plugins, "key"));
      pluginThen.plugins = values_1(merged);
    }
    return pluginThen;
  }
  return plugin;
};
var setDefaultPlugin = (plugin) => {
  if (plugin.type === void 0)
    plugin.type = plugin.key;
  if (!plugin.options)
    plugin.options = {};
  if (!plugin.inject)
    plugin.inject = {};
  if (!plugin.editor)
    plugin.editor = {};
  return plugin;
};
var flattenDeepPlugins = (editor, plugins2) => {
  if (!plugins2)
    return;
  plugins2.forEach((plugin) => {
    let p12 = setDefaultPlugin(plugin);
    p12 = mergeDeepPlugins(editor, p12);
    if (!editor.pluginsByKey[p12.key]) {
      editor.plugins.push(p12);
      editor.pluginsByKey[p12.key] = p12;
    } else {
      const index2 = editor.plugins.indexOf(editor.pluginsByKey[p12.key]);
      const mergedPlugin = defaultsDeep_1(p12, editor.pluginsByKey[p12.key]);
      if (index2 >= 0) {
        editor.plugins[index2] = mergedPlugin;
      }
      editor.pluginsByKey[p12.key] = mergedPlugin;
    }
    flattenDeepPlugins(editor, p12.plugins);
  });
};
var setPlatePlugins = (editor, {
  disableCorePlugins,
  plugins: _plugins = []
}) => {
  let plugins2 = [];
  if (disableCorePlugins !== true) {
    const dcp = disableCorePlugins;
    if (typeof dcp !== "object" || !dcp.react) {
      var _ref, _editor$pluginsByKey;
      plugins2.push((_ref = (_editor$pluginsByKey = editor.pluginsByKey) === null || _editor$pluginsByKey === void 0 ? void 0 : _editor$pluginsByKey.react) !== null && _ref !== void 0 ? _ref : createReactPlugin());
    }
    if (typeof dcp !== "object" || !dcp.history) {
      var _ref2, _editor$pluginsByKey2;
      plugins2.push((_ref2 = (_editor$pluginsByKey2 = editor.pluginsByKey) === null || _editor$pluginsByKey2 === void 0 ? void 0 : _editor$pluginsByKey2.history) !== null && _ref2 !== void 0 ? _ref2 : createHistoryPlugin());
    }
    if (typeof dcp !== "object" || !dcp.eventEditor) {
      var _ref3, _editor$pluginsByKey3;
      plugins2.push((_ref3 = (_editor$pluginsByKey3 = editor.pluginsByKey) === null || _editor$pluginsByKey3 === void 0 ? void 0 : _editor$pluginsByKey3[KEY_EVENT_EDITOR]) !== null && _ref3 !== void 0 ? _ref3 : createEventEditorPlugin());
    }
    if (typeof dcp !== "object" || !dcp.inlineVoid) {
      var _ref4, _editor$pluginsByKey4;
      plugins2.push((_ref4 = (_editor$pluginsByKey4 = editor.pluginsByKey) === null || _editor$pluginsByKey4 === void 0 ? void 0 : _editor$pluginsByKey4[KEY_INLINE_VOID]) !== null && _ref4 !== void 0 ? _ref4 : createInlineVoidPlugin());
    }
    if (typeof dcp !== "object" || !dcp.insertData) {
      var _ref5, _editor$pluginsByKey5;
      plugins2.push((_ref5 = (_editor$pluginsByKey5 = editor.pluginsByKey) === null || _editor$pluginsByKey5 === void 0 ? void 0 : _editor$pluginsByKey5[KEY_INSERT_DATA]) !== null && _ref5 !== void 0 ? _ref5 : createInsertDataPlugin());
    }
    if (typeof dcp !== "object" || !dcp.deserializeHtml) {
      var _ref6, _editor$pluginsByKey6;
      plugins2.push((_ref6 = (_editor$pluginsByKey6 = editor.pluginsByKey) === null || _editor$pluginsByKey6 === void 0 ? void 0 : _editor$pluginsByKey6[KEY_DESERIALIZE_HTML]) !== null && _ref6 !== void 0 ? _ref6 : createDeserializeHtmlPlugin());
    }
    if (typeof dcp !== "object" || !dcp.deserializeAst) {
      var _ref7, _editor$pluginsByKey7;
      plugins2.push((_ref7 = (_editor$pluginsByKey7 = editor.pluginsByKey) === null || _editor$pluginsByKey7 === void 0 ? void 0 : _editor$pluginsByKey7[KEY_DESERIALIZE_AST]) !== null && _ref7 !== void 0 ? _ref7 : createDeserializeAstPlugin());
    }
  }
  plugins2 = [...plugins2, ..._plugins];
  editor.plugins = [];
  editor.pluginsByKey = {};
  flattenDeepPlugins(editor, plugins2);
  editor.plugins.forEach((plugin) => {
    if (plugin.overrideByKey) {
      const newPlugins = editor.plugins.map((p12) => {
        return overridePluginsByKey(p12, plugin.overrideByKey);
      });
      editor.plugins = [];
      editor.pluginsByKey = {};
      flattenDeepPlugins(editor, newPlugins);
    }
  });
  getPlateActions(editor.id).incrementKey("keyPlugins");
};
var withPlate = (e9, {
  id = "main",
  plugins: plugins2 = [],
  disableCorePlugins
} = {}) => {
  let editor = e9;
  editor.id = id;
  if (!editor.key) {
    editor.key = Math.random();
  }
  setPlatePlugins(editor, {
    plugins: plugins2,
    disableCorePlugins
  });
  editor.plugins.forEach((plugin) => {
    if (plugin.withOverrides) {
      editor = plugin.withOverrides(editor, plugin);
    }
  });
  return editor;
};
var normalizeEditor = (editor, options) => Editor.normalize(editor, options);
function arrayEach(array2, iteratee) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (iteratee(array2[index2], index2, array2) === false) {
      break;
    }
  }
  return array2;
}
var _arrayEach = arrayEach;
function baseAssign(object2, source) {
  return object2 && _copyObject(source, keys_1(source), object2);
}
var _baseAssign = baseAssign;
function baseAssignIn(object2, source) {
  return object2 && _copyObject(source, keysIn_1(source), object2);
}
var _baseAssignIn = baseAssignIn;
function copySymbols(source, object2) {
  return _copyObject(source, _getSymbols(source), object2);
}
var _copySymbols = copySymbols;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbolsIn = !nativeGetSymbols ? stubArray_1 : function(object2) {
  var result = [];
  while (object2) {
    _arrayPush(result, _getSymbols(object2));
    object2 = _getPrototype(object2);
  }
  return result;
};
var _getSymbolsIn = getSymbolsIn;
function copySymbolsIn(source, object2) {
  return _copyObject(source, _getSymbolsIn(source), object2);
}
var _copySymbolsIn = copySymbolsIn;
function getAllKeysIn(object2) {
  return _baseGetAllKeys(object2, keysIn_1, _getSymbolsIn);
}
var _getAllKeysIn = getAllKeysIn;
var objectProto$12 = Object.prototype;
var hasOwnProperty$12 = objectProto$12.hasOwnProperty;
function initCloneArray(array2) {
  var length = array2.length, result = new array2.constructor(length);
  if (length && typeof array2[0] == "string" && hasOwnProperty$12.call(array2, "index")) {
    result.index = array2.index;
    result.input = array2.input;
  }
  return result;
}
var _initCloneArray = initCloneArray;
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView = cloneDataView;
var reFlags = /\w*$/;
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp = cloneRegExp;
var symbolProto2 = _Symbol2 ? _Symbol2.prototype : void 0;
var symbolValueOf2 = symbolProto2 ? symbolProto2.valueOf : void 0;
function cloneSymbol(symbol) {
  return symbolValueOf2 ? Object(symbolValueOf2.call(symbol)) : {};
}
var _cloneSymbol = cloneSymbol;
var boolTag$12 = "[object Boolean]";
var dateTag$12 = "[object Date]";
var mapTag$22 = "[object Map]";
var numberTag$12 = "[object Number]";
var regexpTag$12 = "[object RegExp]";
var setTag$22 = "[object Set]";
var stringTag$12 = "[object String]";
var symbolTag$1 = "[object Symbol]";
var arrayBufferTag$12 = "[object ArrayBuffer]";
var dataViewTag$1 = "[object DataView]";
var float32Tag$1 = "[object Float32Array]";
var float64Tag$1 = "[object Float64Array]";
var int8Tag$1 = "[object Int8Array]";
var int16Tag$1 = "[object Int16Array]";
var int32Tag$1 = "[object Int32Array]";
var uint8Tag$1 = "[object Uint8Array]";
var uint8ClampedTag$1 = "[object Uint8ClampedArray]";
var uint16Tag$1 = "[object Uint16Array]";
var uint32Tag$1 = "[object Uint32Array]";
function initCloneByTag(object2, tag, isDeep) {
  var Ctor = object2.constructor;
  switch (tag) {
    case arrayBufferTag$12:
      return _cloneArrayBuffer(object2);
    case boolTag$12:
    case dateTag$12:
      return new Ctor(+object2);
    case dataViewTag$1:
      return _cloneDataView(object2, isDeep);
    case float32Tag$1:
    case float64Tag$1:
    case int8Tag$1:
    case int16Tag$1:
    case int32Tag$1:
    case uint8Tag$1:
    case uint8ClampedTag$1:
    case uint16Tag$1:
    case uint32Tag$1:
      return _cloneTypedArray(object2, isDeep);
    case mapTag$22:
      return new Ctor();
    case numberTag$12:
    case stringTag$12:
      return new Ctor(object2);
    case regexpTag$12:
      return _cloneRegExp(object2);
    case setTag$22:
      return new Ctor();
    case symbolTag$1:
      return _cloneSymbol(object2);
  }
}
var _initCloneByTag = initCloneByTag;
var mapTag$1 = "[object Map]";
function baseIsMap(value) {
  return isObjectLike_12(value) && _getTag(value) == mapTag$1;
}
var _baseIsMap = baseIsMap;
var nodeIsMap = _nodeUtil2 && _nodeUtil2.isMap;
var isMap = nodeIsMap ? _baseUnary2(nodeIsMap) : _baseIsMap;
var isMap_1 = isMap;
var setTag$1 = "[object Set]";
function baseIsSet(value) {
  return isObjectLike_12(value) && _getTag(value) == setTag$1;
}
var _baseIsSet = baseIsSet;
var nodeIsSet = _nodeUtil2 && _nodeUtil2.isSet;
var isSet = nodeIsSet ? _baseUnary2(nodeIsSet) : _baseIsSet;
var isSet_1 = isSet;
var CLONE_DEEP_FLAG$2 = 1;
var CLONE_FLAT_FLAG$1 = 2;
var CLONE_SYMBOLS_FLAG$2 = 4;
var argsTag = "[object Arguments]";
var arrayTag = "[object Array]";
var boolTag = "[object Boolean]";
var dateTag = "[object Date]";
var errorTag = "[object Error]";
var funcTag2 = "[object Function]";
var genTag2 = "[object GeneratorFunction]";
var mapTag2 = "[object Map]";
var numberTag = "[object Number]";
var objectTag = "[object Object]";
var regexpTag = "[object RegExp]";
var setTag2 = "[object Set]";
var stringTag = "[object String]";
var symbolTag = "[object Symbol]";
var weakMapTag2 = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]";
var dataViewTag2 = "[object DataView]";
var float32Tag2 = "[object Float32Array]";
var float64Tag2 = "[object Float64Array]";
var int8Tag2 = "[object Int8Array]";
var int16Tag2 = "[object Int16Array]";
var int32Tag2 = "[object Int32Array]";
var uint8Tag2 = "[object Uint8Array]";
var uint8ClampedTag2 = "[object Uint8ClampedArray]";
var uint16Tag2 = "[object Uint16Array]";
var uint32Tag2 = "[object Uint32Array]";
var cloneableTags = {};
cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag2] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag2] = cloneableTags[float64Tag2] = cloneableTags[int8Tag2] = cloneableTags[int16Tag2] = cloneableTags[int32Tag2] = cloneableTags[mapTag2] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag2] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag2] = cloneableTags[uint8ClampedTag2] = cloneableTags[uint16Tag2] = cloneableTags[uint32Tag2] = true;
cloneableTags[errorTag] = cloneableTags[funcTag2] = cloneableTags[weakMapTag2] = false;
function baseClone(value, bitmask, customizer, key, object2, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$2, isFlat = bitmask & CLONE_FLAT_FLAG$1, isFull = bitmask & CLONE_SYMBOLS_FLAG$2;
  if (customizer) {
    result = object2 ? customizer(value, key, object2, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject_12(value)) {
    return value;
  }
  var isArr = isArray_1(value);
  if (isArr) {
    result = _initCloneArray(value);
    if (!isDeep) {
      return _copyArray(value, result);
    }
  } else {
    var tag = _getTag(value), isFunc = tag == funcTag2 || tag == genTag2;
    if (isBuffer_12(value)) {
      return _cloneBuffer(value, isDeep);
    }
    if (tag == objectTag || tag == argsTag || isFunc && !object2) {
      result = isFlat || isFunc ? {} : _initCloneObject(value);
      if (!isDeep) {
        return isFlat ? _copySymbolsIn(value, _baseAssignIn(result, value)) : _copySymbols(value, _baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object2 ? value : {};
      }
      result = _initCloneByTag(value, tag, isDeep);
    }
  }
  stack || (stack = new _Stack());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet_1(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_1(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? _getAllKeysIn : _getAllKeys : isFlat ? keysIn_1 : keys_1;
  var props = isArr ? void 0 : keysFunc(value);
  _arrayEach(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    _assignValue(result, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone = baseClone;
var CLONE_DEEP_FLAG$1 = 1;
var CLONE_SYMBOLS_FLAG$1 = 4;
function cloneDeep(value) {
  return _baseClone(value, CLONE_DEEP_FLAG$1 | CLONE_SYMBOLS_FLAG$1);
}
var cloneDeep_1 = cloneDeep;
var createPlugins = (plugins2, {
  components: components2,
  overrideByKey: overrideByKey2
} = {}) => {
  let allOverrideByKey = {};
  if (overrideByKey2) {
    allOverrideByKey = cloneDeep_1(overrideByKey2);
  }
  if (components2) {
    Object.keys(components2).forEach((key) => {
      if (!allOverrideByKey[key])
        allOverrideByKey[key] = {};
      allOverrideByKey[key].component = components2[key];
    });
  }
  if (Object.keys(allOverrideByKey).length) {
    return plugins2.map((plugin) => {
      return overridePluginsByKey(plugin, allOverrideByKey);
    });
  }
  return plugins2;
};
var getKeysByTypes = (editor, type) => {
  const types = castArray_1(type);
  const found = Object.values(editor.pluginsByKey).filter((plugin) => {
    return types.includes(plugin.type);
  });
  return found.map((p12) => p12.key);
};
var getPluginInjectProps = (editor, key) => {
  var _getPlugin$inject$pro, _getPlugin$inject;
  return (_getPlugin$inject$pro = (_getPlugin$inject = getPlugin(editor, key).inject) === null || _getPlugin$inject === void 0 ? void 0 : _getPlugin$inject.props) !== null && _getPlugin$inject$pro !== void 0 ? _getPlugin$inject$pro : {};
};
var getPluginOptions = (editor, key) => {
  var _getPlugin$options;
  return (_getPlugin$options = getPlugin(editor, key).options) !== null && _getPlugin$options !== void 0 ? _getPlugin$options : {};
};
var getPluginTypes = (editor, keys6) => keys6.map((key) => getPluginType(editor, key));
var getRenderNodeProps = ({
  attributes,
  nodeProps,
  props,
  type
}) => {
  let newProps = {};
  if (props) {
    var _ref;
    newProps = (_ref = typeof props === "function" ? props(nodeProps) : props) !== null && _ref !== void 0 ? _ref : {};
  }
  if (!newProps.nodeProps && attributes) {
    newProps.nodeProps = attributes;
  }
  nodeProps = {
    ...nodeProps,
    ...newProps
  };
  const {
    className
  } = nodeProps;
  return {
    ...nodeProps,
    className: clsx_m_default(getSlateClass(type), className)
  };
};
var mapInjectPropsToPlugin = (editor, plugin, injectedPlugin) => {
  var _plugin$inject$props;
  const validTypes = (_plugin$inject$props = plugin.inject.props) === null || _plugin$inject$props === void 0 ? void 0 : _plugin$inject$props.validTypes;
  if (!validTypes)
    return;
  const keys6 = getKeysByTypes(editor, validTypes);
  const injected = {};
  keys6.forEach((key) => {
    injected[key] = injectedPlugin;
  });
  return {
    inject: {
      pluginsByKey: injected
    }
  };
};
var mockPlugin = (plugin) => ({
  key: "",
  type: "",
  editor: {},
  inject: {},
  options: {},
  ...plugin
});
function isEqual(value, other) {
  return _baseIsEqual(value, other);
}
var isEqual_1 = isEqual;
var usePlateEditorRef = (id) => usePlateSelectors(id).editor();
var normalizeInitialValue = (editor, value) => {
  let normalizedValue = cloneDeep_1(value);
  editor.plugins.forEach((p12) => {
    var _p$normalizeInitialVa;
    const _normalizedValue = (_p$normalizeInitialVa = p12.normalizeInitialValue) === null || _p$normalizeInitialVa === void 0 ? void 0 : _p$normalizeInitialVa.call(p12, normalizedValue);
    if (_normalizedValue) {
      normalizedValue = _normalizedValue;
    }
  });
  if (!isEqual_1(value, normalizedValue)) {
    getPlateActions(editor.id).value(normalizedValue);
    return normalizedValue;
  }
};
var pipeDecorate = (editor, decorateProp) => {
  const decorates = editor.plugins.flatMap((plugin) => {
    var _plugin$decorate, _plugin$decorate2;
    return (_plugin$decorate = (_plugin$decorate2 = plugin.decorate) === null || _plugin$decorate2 === void 0 ? void 0 : _plugin$decorate2.call(plugin, editor, plugin)) !== null && _plugin$decorate !== void 0 ? _plugin$decorate : [];
  });
  if (decorateProp) {
    decorates.push(decorateProp);
  }
  if (!decorates.length)
    return;
  return (entry) => {
    let ranges = [];
    const addRanges = (newRanges) => {
      if (newRanges !== null && newRanges !== void 0 && newRanges.length)
        ranges = [...ranges, ...newRanges];
    };
    decorates.forEach((decorate) => {
      addRanges(decorate(entry));
    });
    return ranges;
  };
};
var isEventHandled2 = (event, handler) => {
  if (!handler) {
    return false;
  }
  const shouldTreatEventAsHandled = handler(event);
  if (shouldTreatEventAsHandled != null) {
    return shouldTreatEventAsHandled;
  }
  return event.isPropagationStopped();
};
var pipeHandler = (editor, {
  editableProps,
  handlerKey
}) => {
  let pluginsHandlers = [];
  pluginsHandlers = editor.plugins.flatMap((plugin) => {
    var _plugin$handlers$hand, _plugin$handlers, _plugin$handlers$hand2;
    return (_plugin$handlers$hand = (_plugin$handlers = plugin.handlers) === null || _plugin$handlers === void 0 ? void 0 : (_plugin$handlers$hand2 = _plugin$handlers[handlerKey]) === null || _plugin$handlers$hand2 === void 0 ? void 0 : _plugin$handlers$hand2.call(_plugin$handlers, editor, plugin)) !== null && _plugin$handlers$hand !== void 0 ? _plugin$handlers$hand : [];
  });
  const propsHandler = editableProps === null || editableProps === void 0 ? void 0 : editableProps[handlerKey];
  if (!pluginsHandlers.length && !propsHandler)
    return;
  return (event) => {
    const eventIsHandled = pluginsHandlers.some((handler) => isEventHandled2(event, handler));
    if (eventIsHandled)
      return true;
    return isEventHandled2(event, propsHandler);
  };
};
var pluginInjectProps = (editor, {
  key,
  inject: {
    props
  }
}, nodeProps) => {
  var _transformNodeValue;
  const {
    element,
    text,
    className,
    style: style2
  } = nodeProps;
  const node = element !== null && element !== void 0 ? element : text;
  if (!node)
    return;
  if (!props)
    return;
  const {
    nodeKey = key,
    styleKey = nodeKey,
    validTypes,
    classNames: classNames2,
    transformClassName,
    transformNodeValue,
    transformStyle,
    validNodeValues,
    defaultNodeValue
  } = props;
  if (validTypes && isElement2(node) && node.type && !validTypes.includes(node.type)) {
    return;
  }
  const nodeValue = node[nodeKey];
  if (!nodeValue || validNodeValues && !validNodeValues.includes(nodeValue) || nodeValue === defaultNodeValue) {
    return;
  }
  const res = {};
  const transformOptions = {
    ...nodeProps,
    nodeValue
  };
  const value = (_transformNodeValue = transformNodeValue === null || transformNodeValue === void 0 ? void 0 : transformNodeValue(transformOptions)) !== null && _transformNodeValue !== void 0 ? _transformNodeValue : nodeValue;
  if (element) {
    res.className = clsx_m_default(className, `slate-${nodeKey}-${nodeValue}`);
  }
  if (classNames2 !== null && classNames2 !== void 0 && classNames2[nodeValue] || transformClassName) {
    var _transformClassName;
    res.className = (_transformClassName = transformClassName === null || transformClassName === void 0 ? void 0 : transformClassName(transformOptions)) !== null && _transformClassName !== void 0 ? _transformClassName : clsx_m_default(className, classNames2 === null || classNames2 === void 0 ? void 0 : classNames2[value]);
  }
  if (styleKey) {
    var _transformStyle;
    res.style = (_transformStyle = transformStyle === null || transformStyle === void 0 ? void 0 : transformStyle(transformOptions)) !== null && _transformStyle !== void 0 ? _transformStyle : {
      ...style2,
      [styleKey]: value
    };
  }
  return res;
};
var pipeInjectProps = (editor, nodeProps) => {
  editor.plugins.forEach((plugin) => {
    if (plugin.inject.props) {
      const props = pluginInjectProps(editor, plugin, nodeProps);
      if (props) {
        nodeProps = {
          ...nodeProps,
          ...props
        };
      }
    }
  });
  return {
    ...nodeProps,
    editor
  };
};
var pipeOnChange = (editor) => {
  const onChanges = editor.plugins.flatMap((plugin) => {
    var _plugin$handlers$onCh, _plugin$handlers, _plugin$handlers$onCh2;
    return (_plugin$handlers$onCh = (_plugin$handlers = plugin.handlers) === null || _plugin$handlers === void 0 ? void 0 : (_plugin$handlers$onCh2 = _plugin$handlers.onChange) === null || _plugin$handlers$onCh2 === void 0 ? void 0 : _plugin$handlers$onCh2.call(_plugin$handlers, editor, plugin)) !== null && _plugin$handlers$onCh !== void 0 ? _plugin$handlers$onCh : [];
  });
  return (nodes) => {
    return onChanges.some((handler) => {
      if (!handler) {
        return false;
      }
      const shouldTreatEventAsHandled = handler(nodes);
      if (shouldTreatEventAsHandled != null) {
        return shouldTreatEventAsHandled;
      }
      return false;
    });
  };
};
var pluginRenderElement = (editor, {
  key,
  type,
  component: _component,
  props
}) => (nodeProps) => {
  const {
    element,
    children: _children
  } = nodeProps;
  if (element.type === type) {
    const Element4 = _component !== null && _component !== void 0 ? _component : DefaultElement;
    const injectAboveComponents = editor.plugins.flatMap((o16) => {
      var _o$inject$aboveCompon, _o$inject;
      return (_o$inject$aboveCompon = (_o$inject = o16.inject) === null || _o$inject === void 0 ? void 0 : _o$inject.aboveComponent) !== null && _o$inject$aboveCompon !== void 0 ? _o$inject$aboveCompon : [];
    });
    const injectBelowComponents = editor.plugins.flatMap((o16) => {
      var _o$inject$belowCompon, _o$inject2;
      return (_o$inject$belowCompon = (_o$inject2 = o16.inject) === null || _o$inject2 === void 0 ? void 0 : _o$inject2.belowComponent) !== null && _o$inject$belowCompon !== void 0 ? _o$inject$belowCompon : [];
    });
    nodeProps = getRenderNodeProps({
      attributes: element.attributes,
      nodeProps,
      props,
      type
    });
    let children = _children;
    injectBelowComponents.forEach((withHOC) => {
      const hoc = withHOC({
        ...nodeProps,
        key
      });
      if (hoc) {
        children = hoc({
          ...nodeProps,
          children
        });
      }
    });
    let component = import_react7.default.createElement(Element4, nodeProps, children);
    injectAboveComponents.forEach((withHOC) => {
      const hoc = withHOC({
        ...nodeProps,
        key
      });
      if (hoc) {
        component = hoc({
          ...nodeProps,
          children: component
        });
      }
    });
    return import_react7.default.createElement(ElementProvider, {
      element,
      scope: key
    }, component);
  }
};
var pipeRenderElement = (editor, renderElementProp) => {
  const renderElements = [];
  editor.plugins.forEach((plugin) => {
    if (plugin.isElement) {
      renderElements.push(pluginRenderElement(editor, plugin));
    }
  });
  return (nodeProps) => {
    const props = pipeInjectProps(editor, nodeProps);
    let element;
    renderElements.some((renderElement) => {
      element = renderElement(props);
      return !!element;
    });
    if (element)
      return element;
    if (renderElementProp) {
      return renderElementProp(props);
    }
    return import_react7.default.createElement(DefaultElement, props);
  };
};
var DefaultLeaf2 = ({
  attributes,
  children,
  text,
  leaf,
  editor,
  nodeProps,
  ...props
}) => import_react7.default.createElement("span", _extends2({}, attributes, props), children);
var pluginRenderLeaf = (editor, {
  key,
  type = key,
  component,
  props
}) => (nodeProps) => {
  const {
    leaf,
    children
  } = nodeProps;
  if (leaf[type]) {
    const Leaf2 = component !== null && component !== void 0 ? component : DefaultLeaf2;
    nodeProps = getRenderNodeProps({
      attributes: leaf.attributes,
      props,
      nodeProps,
      type
    });
    return import_react7.default.createElement(Leaf2, nodeProps, children);
  }
  return children;
};
var pipeRenderLeaf = (editor, renderLeafProp) => {
  const renderLeafs = [];
  editor.plugins.forEach((plugin) => {
    if (plugin.isLeaf && plugin.key) {
      renderLeafs.push(pluginRenderLeaf(editor, plugin));
    }
  });
  return (nodeProps) => {
    const props = pipeInjectProps(editor, nodeProps);
    renderLeafs.forEach((renderLeaf) => {
      const newChildren = renderLeaf(props);
      if (newChildren !== void 0) {
        props.children = newChildren;
      }
    });
    if (renderLeafProp) {
      return renderLeafProp(props);
    }
    return import_react7.default.createElement(DefaultLeaf2, props);
  };
};
var createComponentAs = (render3) => {
  const Role = ({
    asChild,
    ...props
  }, ref2) => {
    const Comp = asChild ? Slot : render3;
    return Comp({
      ref: ref2,
      ...props
    });
  };
  return (0, import_react7.forwardRef)(Role);
};
var isRenderProp = (children) => typeof children === "function";
var createElementAs = (Type, props) => {
  const {
    as: As,
    wrapElement,
    ...rest
  } = props;
  let element;
  if (As && typeof As !== "string") {
    element = import_react7.default.createElement(As, rest);
  } else if (isRenderProp(props.children)) {
    const {
      children,
      ...otherProps
    } = rest;
    element = props.children(otherProps);
  } else if (As) {
    element = import_react7.default.createElement(As, rest);
  } else {
    element = import_react7.default.createElement(Type, rest);
  }
  if (wrapElement) {
    return wrapElement(element);
  }
  return element;
};
var getPreventDefaultHandler = (cb, ...args) => (event) => {
  event.preventDefault();
  cb === null || cb === void 0 ? void 0 : cb(...args);
};
var {
  elementStore,
  useElementStore
} = createAtomStore({
  element: null
}, {
  name: "element"
});
var useElement = (pluginKey) => {
  const value = useElementStore().get.element(pluginKey);
  if (!value)
    throw new Error(`The \`useElement(pluginKey)\` hook must be used inside the node component's context`);
  return value;
};
var ElementProviderChild = ({
  element,
  scope,
  children
}) => {
  const setElement = useElementStore().set.element(scope);
  (0, import_react7.useEffect)(() => {
    setElement(element);
  }, [element, setElement]);
  return children;
};
var ElementProvider = ({
  element,
  scope,
  children,
  ...props
}) => import_react7.default.createElement(JotaiProvider, _extends2({
  initialValues: [[elementStore.atom.element, element]],
  scope
}, props), import_react7.default.createElement(ElementProviderChild, {
  element,
  scope
}, children));
var Box = createComponentAs((props) => createElementAs("div", props));
function last(array2) {
  var length = array2 == null ? 0 : array2.length;
  return length ? array2[length - 1] : void 0;
}
var last_1 = last;
function baseSlice(array2, start3, end2) {
  var index2 = -1, length = array2.length;
  if (start3 < 0) {
    start3 = -start3 > length ? 0 : length + start3;
  }
  end2 = end2 > length ? length : end2;
  if (end2 < 0) {
    end2 += length;
  }
  length = start3 > end2 ? 0 : end2 - start3 >>> 0;
  start3 >>>= 0;
  var result = Array(length);
  while (++index2 < length) {
    result[index2] = array2[index2 + start3];
  }
  return result;
}
var _baseSlice = baseSlice;
function parent(object2, path) {
  return path.length < 2 ? object2 : _baseGet(object2, _baseSlice(path, 0, -1));
}
var _parent = parent;
function baseUnset(object2, path) {
  path = _castPath(path, object2);
  object2 = _parent(object2, path);
  return object2 == null || delete object2[_toKey(last_1(path))];
}
var _baseUnset = baseUnset;
function customOmitClone(value) {
  return isPlainObject_1(value) ? void 0 : value;
}
var _customOmitClone = customOmitClone;
var spreadableSymbol = _Symbol2 ? _Symbol2.isConcatSpreadable : void 0;
function isFlattenable(value) {
  return isArray_1(value) || isArguments_1(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable;
function baseFlatten(array2, depth, predicate, isStrict, result) {
  var index2 = -1, length = array2.length;
  predicate || (predicate = _isFlattenable);
  result || (result = []);
  while (++index2 < length) {
    var value = array2[index2];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        _arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten;
function flatten(array2) {
  var length = array2 == null ? 0 : array2.length;
  return length ? _baseFlatten(array2, 1) : [];
}
var flatten_1 = flatten;
function flatRest(func) {
  return _setToString(_overRest(func, void 0, flatten_1), func + "");
}
var _flatRest = flatRest;
var CLONE_DEEP_FLAG = 1;
var CLONE_FLAT_FLAG = 2;
var CLONE_SYMBOLS_FLAG = 4;
var omit = _flatRest(function(object2, paths) {
  var result = {};
  if (object2 == null) {
    return result;
  }
  var isDeep = false;
  paths = _arrayMap(paths, function(path) {
    path = _castPath(path, object2);
    isDeep || (isDeep = path.length > 1);
    return path;
  });
  _copyObject(object2, _getAllKeysIn(object2), result);
  if (isDeep) {
    result = _baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, _customOmitClone);
  }
  var length = paths.length;
  while (length--) {
    _baseUnset(result, paths[length]);
  }
  return result;
});
var omit_1 = omit;
var useEditableProps = ({
  id = "main"
}) => {
  const editor = usePlateEditorRef(id);
  const keyPlugins = usePlateSelectors(id).keyPlugins();
  const keyDecorate = usePlateSelectors(id).keyDecorate();
  const editableProps = usePlateSelectors(id).editableProps();
  const storeDecorate = usePlateSelectors(id).decorate();
  const storeRenderLeaf = usePlateSelectors(id).renderLeaf();
  const storeRenderElement = usePlateSelectors(id).renderElement();
  const isValid4 = editor && !!keyPlugins;
  const decorateMemo = (0, import_react7.useMemo)(() => {
    if (!isValid4)
      return;
    return pipeDecorate(editor, storeDecorate !== null && storeDecorate !== void 0 ? storeDecorate : editableProps === null || editableProps === void 0 ? void 0 : editableProps.decorate);
  }, [editableProps === null || editableProps === void 0 ? void 0 : editableProps.decorate, editor, isValid4, storeDecorate]);
  const decorate = (0, import_react7.useMemo)(() => {
    if (!keyDecorate || !decorateMemo)
      return;
    return (entry) => decorateMemo(entry);
  }, [decorateMemo, keyDecorate]);
  const renderElement = (0, import_react7.useMemo)(() => {
    if (!isValid4)
      return;
    return pipeRenderElement(editor, storeRenderElement !== null && storeRenderElement !== void 0 ? storeRenderElement : editableProps === null || editableProps === void 0 ? void 0 : editableProps.renderElement);
  }, [editableProps === null || editableProps === void 0 ? void 0 : editableProps.renderElement, editor, isValid4, storeRenderElement]);
  const renderLeaf = (0, import_react7.useMemo)(() => {
    if (!isValid4)
      return;
    return pipeRenderLeaf(editor, storeRenderLeaf !== null && storeRenderLeaf !== void 0 ? storeRenderLeaf : editableProps === null || editableProps === void 0 ? void 0 : editableProps.renderLeaf);
  }, [editableProps === null || editableProps === void 0 ? void 0 : editableProps.renderLeaf, editor, isValid4, storeRenderLeaf]);
  const props = useDeepCompareMemo(() => {
    if (!isValid4)
      return {};
    const _props = {
      decorate,
      renderElement,
      renderLeaf
    };
    DOM_HANDLERS.forEach((handlerKey) => {
      const handler = pipeHandler(editor, {
        editableProps,
        handlerKey
      });
      if (handler) {
        _props[handlerKey] = handler;
      }
    });
    return _props;
  }, [decorate, editableProps, isValid4, renderElement, renderLeaf]);
  return useDeepCompareMemo(() => ({
    ...omit_1(editableProps, [...DOM_HANDLERS, "renderElement", "renderLeaf"]),
    ...props
  }), [editableProps, props]);
};
var usePlateStoreEffects = ({
  id,
  value: valueProp,
  enabled: enabledProp = true,
  onChange,
  editableProps,
  plugins: plugins2,
  decorate,
  renderElement,
  renderLeaf
}) => {
  const plateActions = getPlateActions(id);
  (0, import_react7.useEffect)(() => {
    if (!isUndefined(valueProp)) {
      valueProp && plateActions.value(valueProp);
    }
  }, [valueProp, plateActions]);
  (0, import_react7.useEffect)(() => {
    if (!isUndefined(enabledProp)) {
      plateActions.enabled(enabledProp);
    }
  }, [enabledProp, plateActions]);
  (0, import_react7.useEffect)(() => {
    if (!isUndefined(onChange)) {
      plateActions.onChange(onChange);
    }
  }, [onChange, plateActions]);
  useDeepCompareEffect(() => {
    if (!isUndefined(editableProps)) {
      plateActions.editableProps(editableProps);
    }
  }, [editableProps, plateActions]);
  (0, import_react7.useEffect)(() => {
    if (!isUndefined(decorate)) {
      plateActions.decorate(decorate);
    }
  }, [decorate, plateActions]);
  (0, import_react7.useEffect)(() => {
    if (!isUndefined(renderElement)) {
      plateActions.renderElement(renderElement);
    }
  }, [renderElement, plateActions]);
  (0, import_react7.useEffect)(() => {
    if (!isUndefined(renderLeaf)) {
      plateActions.renderLeaf(renderLeaf);
    }
  }, [renderLeaf, plateActions]);
  (0, import_react7.useEffect)(() => {
    if (!isUndefined(plugins2)) {
      plateActions.plugins(plugins2);
    }
  }, [plugins2, plateActions]);
};
var usePlateEffects = ({
  id = "main",
  editor: editorProp,
  initialValue,
  normalizeInitialValue: normalizeInitialValueProp,
  plugins: pluginsProp,
  disableCorePlugins,
  editableProps,
  onChange,
  value: valueProp,
  enabled: enabledProp
}) => {
  const editor = usePlateEditorRef(id);
  const enabled = usePlateSelectors(id).enabled();
  const plugins2 = usePlateSelectors(id).plugins();
  const value = usePlateSelectors(id).value();
  const isReady = usePlateSelectors(id).isReady();
  const prevEditor = (0, import_react7.useRef)(editor);
  const prevPlugins = (0, import_react7.useRef)(plugins2);
  const plateActions = getPlateActions(id);
  (0, import_react7.useEffect)(() => {
    initialValue && plateActions.value(initialValue);
  }, [plateActions]);
  usePlateStoreEffects({
    editableProps,
    onChange,
    id,
    value: valueProp,
    enabled: enabledProp,
    plugins: pluginsProp
  });
  (0, import_react7.useEffect)(() => {
    if (!editor || !value || isReady)
      return;
    normalizeInitialValue === null || normalizeInitialValue === void 0 ? void 0 : normalizeInitialValue(editor, value);
    plateActions.isReady(true);
  }, [editor, isReady, plateActions, value]);
  (0, import_react7.useEffect)(() => {
    if (editor && !enabled) {
      plateActions.editor(null);
    }
  }, [enabled, editor, plateActions]);
  (0, import_react7.useEffect)(() => {
    if (!editor && enabled) {
      plateActions.editor(editorProp !== null && editorProp !== void 0 ? editorProp : withPlate(createTEditor(), {
        id,
        plugins: pluginsProp,
        disableCorePlugins
      }));
    }
  }, [editorProp, id, plugins2, editor, enabled, disableCorePlugins, plateActions, pluginsProp]);
  (0, import_react7.useEffect)(() => {
    if (editor && prevEditor.current === editor && prevPlugins.current !== plugins2) {
      setPlatePlugins(editor, {
        plugins: plugins2,
        disableCorePlugins
      });
      prevPlugins.current = plugins2;
    }
  }, [plugins2, editor, disableCorePlugins]);
  (0, import_react7.useEffect)(() => {
    if (editor && normalizeInitialValueProp && isReady) {
      normalizeEditor(editor, {
        force: true
      });
    }
  }, [editor, isReady, normalizeInitialValueProp]);
  (0, import_react7.useEffect)(() => {
    prevEditor.current = editor;
  }, [editor]);
};
var useSlateProps = ({
  id
} = {}) => {
  const editor = usePlateEditorRef(id);
  const keyPlugins = usePlateSelectors(id).keyPlugins();
  const value = usePlateSelectors(id).value();
  const isReady = usePlateSelectors(id).isReady();
  const onChangeProp = usePlateSelectors(id).onChange();
  const onChange = (0, import_react7.useCallback)((newValue) => {
    if (!editor || !keyPlugins)
      return;
    const eventIsHandled = pipeOnChange(editor)(newValue);
    if (!eventIsHandled) {
      onChangeProp === null || onChangeProp === void 0 ? void 0 : onChangeProp(newValue);
    }
    getPlateActions(id).value(newValue);
  }, [onChangeProp, editor, id, keyPlugins]);
  return (0, import_react7.useMemo)(() => {
    if (!editor || !isReady)
      return {};
    return {
      key: editor.key,
      editor,
      onChange,
      value
    };
  }, [editor, isReady, onChange, value]);
};
var usePlate = (options) => {
  const {
    id
  } = options;
  usePlateEffects(options);
  return {
    slateProps: useSlateProps({
      id
    }),
    editableProps: useEditableProps({
      id
    })
  };
};
var useEditorRef = () => useSlateStatic();
var EditorRefPluginEffect = ({
  plugin
}) => {
  var _plugin$useHooks;
  const editor = useEditorRef();
  (_plugin$useHooks = plugin.useHooks) === null || _plugin$useHooks === void 0 ? void 0 : _plugin$useHooks.call(plugin, editor, plugin);
  return null;
};
var EditorRefEffect = ({
  id
}) => {
  const editor = useEditorRef();
  usePlateSelectors(id).keyPlugins();
  (0, import_react7.useEffect)(() => {
    const plateActions = getPlateActions(editor.id);
    plateActions.isRendered(true);
    return () => {
      plateActions.isRendered(false);
    };
  }, [editor.id]);
  return import_react7.default.createElement(import_react7.default.Fragment, null, editor.plugins.map((plugin) => import_react7.default.createElement(EditorRefPluginEffect, {
    key: plugin.key,
    plugin
  })));
};
var useEditorState = () => useSlate();
var EditorStateEffect = (0, import_react7.memo)(({
  id
}) => {
  const editorState = useEditorState();
  (0, import_react7.useEffect)(() => {
    getPlateActions(id).incrementKey("keyEditor");
  });
  (0, import_react7.useEffect)(() => {
    getPlateActions(id).incrementKey("keySelection");
  }, [editorState.selection, id]);
  return null;
});
var usePlatesStoreEffect = (id, props) => {
  (0, import_react7.useEffect)(() => {
    if (!platesSelectors.has(id)) {
      platesActions.set(id, props);
    }
  }, [id]);
};
var PlateContent = ({
  children,
  renderEditable,
  editableRef,
  firstChildren,
  ...options
}) => {
  const {
    slateProps,
    editableProps
  } = usePlate(options);
  if (!slateProps.editor)
    return null;
  const editable = import_react7.default.createElement(Editable, _extends2({
    ref: editableRef
  }, editableProps));
  return import_react7.default.createElement(Slate, slateProps, firstChildren, renderEditable ? renderEditable(editable) : editable, import_react7.default.createElement(EditorStateEffect, {
    id: options.id
  }), import_react7.default.createElement(EditorRefEffect, {
    id: options.id
  }), children);
};
var Plate = (props) => {
  const {
    id = "main",
    scope = SCOPE_PLATE,
    ...state
  } = props;
  const hasId = usePlatesSelectors.has(id);
  (0, import_react7.useEffect)(() => () => {
    platesActions.unset(id);
  }, [id]);
  usePlatesStoreEffect(id, state);
  if (!hasId)
    return null;
  return import_react7.default.createElement(JotaiProvider, {
    initialValues: [[plateIdAtom, id]],
    scope
  }, import_react7.default.createElement(PlateContent, props));
};
var setRef = (ref2, value) => {
  if (typeof ref2 === "function") {
    ref2(value);
  } else if (ref2 !== null && ref2 !== void 0) {
    ref2.current = value;
  }
};
var composeRefs2 = (...refs) => (node) => refs.forEach((ref2) => setRef(ref2, node));
var useComposedRef = (...refs) => {
  return (0, import_react7.useCallback)(composeRefs2(...refs), refs);
};
var setNodes = (editor, props, options) => Transforms.setNodes(editor, props, options);
var setElements = (editor, props, options) => setNodes(editor, props, options);
var toggleNodeType = (editor, options, editorNodesOptions) => {
  const {
    activeType,
    inactiveType = getPluginType(editor, ELEMENT_DEFAULT)
  } = options;
  if (!activeType || !editor.selection)
    return;
  const isActive = someNode(editor, {
    ...editorNodesOptions,
    match: {
      type: activeType
    }
  });
  if (isActive && activeType === inactiveType)
    return;
  setElements(editor, {
    type: isActive ? inactiveType : activeType
  });
};
var onKeyDownToggleElement = (editor, {
  type,
  options: {
    hotkey
  }
}) => (e9) => {
  const defaultType = getPluginType(editor, ELEMENT_DEFAULT);
  if (!hotkey)
    return;
  const hotkeys = castArray_1(hotkey);
  for (const _hotkey of hotkeys) {
    if (isHotkey(_hotkey, e9)) {
      e9.preventDefault();
      toggleNodeType(editor, {
        activeType: type,
        inactiveType: defaultType
      });
      return;
    }
  }
};
var unsetNodes = (editor, props, options) => {
  return Transforms.unsetNodes(editor, props, options);
};
var removeMark = (editor, {
  key,
  at,
  shouldChange = true,
  ...rest
}) => {
  const selection = at !== null && at !== void 0 ? at : editor.selection;
  key = castArray_1(key);
  if (selection) {
    if (Range.isRange(selection) && Range.isExpanded(selection)) {
      unsetNodes(editor, key, {
        at: selection,
        match: isText,
        split: true,
        ...rest
      });
    } else if (editor.selection) {
      const marks = {
        ...getMarks(editor) || {}
      };
      key.forEach((k3) => {
        delete marks[k3];
      });
      editor.marks = marks;
      shouldChange && editor.onChange();
    }
  }
};
var toggleMark = (editor, {
  key,
  clear
}) => {
  if (!editor.selection)
    return;
  withoutNormalizing(editor, () => {
    const isActive = isMarkActive(editor, key);
    if (isActive) {
      removeMark(editor, {
        key
      });
      return;
    }
    if (clear) {
      const clears = castArray_1(clear);
      removeMark(editor, {
        key: clears
      });
    }
    editor.addMark(key, true);
  });
};
var onKeyDownToggleMark = (editor, {
  type,
  options: {
    hotkey,
    clear
  }
}) => (e9) => {
  if (!hotkey)
    return;
  if (isHotkey(hotkey, e9)) {
    e9.preventDefault();
    toggleMark(editor, {
      key: type,
      clear
    });
  }
};
var CARRIAGE_RETURN = "\r";
var LINE_FEED = "\n";
var NO_BREAK_SPACE = " ";
var SPACE2 = " ";
var TAB = "	";
var ZERO_WIDTH_SPACE = "​";
var traverseHtmlNode = (node, callback) => {
  const keepTraversing = callback(node);
  if (!keepTraversing) {
    return;
  }
  let child = node.firstChild;
  while (child) {
    const currentChild = child;
    const previousChild = child.previousSibling;
    child = child.nextSibling;
    traverseHtmlNode(currentChild, callback);
    if (
      // An unwrap was made. Need to compute the next child again.
      !currentChild.previousSibling && !currentChild.nextSibling && !currentChild.parentNode && child && previousChild !== child.previousSibling && child.parentNode
    ) {
      if (previousChild) {
        child = previousChild.nextSibling;
      } else {
        child = node.firstChild;
      }
    } else if (
      // A list was created. Need to compute the next child again.
      !currentChild.previousSibling && !currentChild.nextSibling && !currentChild.parentNode && child && !child.previousSibling && !child.nextSibling && !child.parentNode
    ) {
      if (previousChild) {
        if (previousChild.nextSibling) {
          child = previousChild.nextSibling.nextSibling;
        } else {
          child = null;
        }
      } else if (node.firstChild) {
        child = node.firstChild.nextSibling;
      }
    }
  }
};
var traverseHtmlElements = (rootNode, callback) => {
  traverseHtmlNode(rootNode, (node) => {
    if (!isHtmlElement(node)) {
      return true;
    }
    return callback(node);
  });
};
var cleanHtmlBrElements = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    if (element.tagName !== "BR") {
      return true;
    }
    const replacementTextNode = document.createTextNode(LINE_FEED);
    if (element.parentElement) {
      element.parentElement.replaceChild(replacementTextNode, element);
    }
    return false;
  });
};
var cleanHtmlCrLf = (html) => {
  return html.replace(/(\r\n|\r)/gm, "\n");
};
var ALLOWED_EMPTY_ELEMENTS = ["BR", "IMG"];
var isEmpty = (element) => {
  return !ALLOWED_EMPTY_ELEMENTS.includes(element.nodeName) && !element.innerHTML.trim();
};
var removeIfEmpty = (element) => {
  if (isEmpty(element)) {
    const {
      parentElement
    } = element;
    element.remove();
    if (parentElement) {
      removeIfEmpty(parentElement);
    }
  }
};
var cleanHtmlEmptyElements = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    removeIfEmpty(element);
    return true;
  });
};
var replaceTagName = (element, tagName) => {
  const newElement = document.createElement(tagName);
  newElement.innerHTML = element.innerHTML;
  for (const {
    name: name2
  } of element.attributes) {
    const value = element.getAttribute(name2);
    if (value) {
      newElement.setAttribute(name2, value);
    }
  }
  if (element.parentNode) {
    element.parentNode.replaceChild(newElement, element);
  }
  return newElement;
};
var cleanHtmlFontElements = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    if (element.tagName === "FONT") {
      if (element.textContent) {
        replaceTagName(element, "span");
      } else {
        element.remove();
      }
    }
    return true;
  });
};
var isHtmlFragmentHref = (href) => href.startsWith("#");
var unwrapHtmlElement = (element) => {
  element.outerHTML = element.innerHTML;
};
var cleanHtmlLinkElements = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    if (element.tagName !== "A") {
      return true;
    }
    const href = element.getAttribute("href");
    if (!href || isHtmlFragmentHref(href)) {
      unwrapHtmlElement(element);
    }
    if (href && element.querySelector("img")) {
      for (const span of element.querySelectorAll("span")) {
        if (!span.innerText) {
          unwrapHtmlElement(span);
        }
      }
    }
    return true;
  });
};
var traverseHtmlTexts = (rootNode, callback) => {
  traverseHtmlNode(rootNode, (node) => {
    if (!isHtmlText(node)) {
      return true;
    }
    return callback(node);
  });
};
var cleanHtmlTextNodes = (rootNode) => {
  traverseHtmlTexts(rootNode, (textNode) => {
    if (/^\n\s*$/.test(textNode.data) && (textNode.previousElementSibling || textNode.nextElementSibling)) {
      textNode.remove();
      return true;
    }
    textNode.data = textNode.data.replace(/\n\s*/g, "\n");
    if (textNode.data.includes(CARRIAGE_RETURN) || textNode.data.includes(LINE_FEED) || textNode.data.includes(NO_BREAK_SPACE)) {
      const hasSpace = textNode.data.includes(SPACE2);
      const hasNonWhitespace = /\S/.test(textNode.data);
      const hasLineFeed = textNode.data.includes(LINE_FEED);
      if (!(hasSpace || hasNonWhitespace) && !hasLineFeed) {
        if (textNode.data === NO_BREAK_SPACE) {
          textNode.data = SPACE2;
          return true;
        }
        textNode.remove();
        return true;
      }
      if (textNode.previousSibling && textNode.previousSibling.nodeName === "BR" && textNode.parentElement) {
        textNode.parentElement.removeChild(textNode.previousSibling);
        const matches = textNode.data.match(/^[\r\n]+/);
        const offset5 = matches ? matches[0].length : 0;
        textNode.data = textNode.data.substring(offset5).replace(new RegExp(LINE_FEED, "g"), SPACE2).replace(new RegExp(CARRIAGE_RETURN, "g"), SPACE2);
        textNode.data = `
${textNode.data}`;
      } else {
        textNode.data = textNode.data.replace(new RegExp(LINE_FEED, "g"), SPACE2).replace(new RegExp(CARRIAGE_RETURN, "g"), SPACE2);
      }
    }
    return true;
  });
};
var isHtmlBlockElement = (element) => {
  const blockRegex = /^(address|blockquote|body|center|dir|div|dl|fieldset|form|h[1-6]|hr|isindex|menu|noframes|noscript|ol|p|pre|table|ul|dd|dt|frameset|li|tbody|td|tfoot|th|thead|tr|html)$/i;
  return blockRegex.test(element.nodeName);
};
var copyBlockMarksToSpanChild = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    const el = element;
    const styleAttribute = element.getAttribute("style");
    if (!styleAttribute)
      return true;
    if (isHtmlBlockElement(el)) {
      const {
        style: {
          backgroundColor,
          color,
          fontFamily,
          fontSize,
          fontStyle,
          fontWeight,
          textDecoration
        }
      } = el;
      if (backgroundColor || color || fontFamily || fontSize || fontStyle || fontWeight || textDecoration) {
        const span = document.createElement("span");
        if (!["initial", "inherit"].includes(color)) {
          span.style.color = color;
        }
        span.style.fontFamily = fontFamily;
        span.style.fontSize = fontSize;
        if (!["normal", "initial", "inherit"].includes(color)) {
          span.style.fontStyle = fontStyle;
        }
        if (!["normal", 400].includes(fontWeight)) {
          span.style.fontWeight = fontWeight;
        }
        span.style.textDecoration = textDecoration;
        span.innerHTML = el.innerHTML;
        element.innerHTML = span.outerHTML;
      }
    }
    return true;
  });
};
var findHtmlElement = (rootNode, predicate) => {
  let res = null;
  traverseHtmlElements(rootNode, (node) => {
    if (predicate(node)) {
      res = node;
      return false;
    }
    return true;
  });
  return res;
};
var someHtmlElement = (rootNode, predicate) => {
  return !!findHtmlElement(rootNode, predicate);
};
var acceptNode = () => NodeFilter.FILTER_ACCEPT;
var getHtmlComments = (node) => {
  const comments = [];
  const iterator = document.createNodeIterator(node, NodeFilter.SHOW_COMMENT, {
    acceptNode
  });
  let currentNode = iterator.nextNode();
  while (currentNode) {
    if (currentNode.nodeValue) {
      comments.push(currentNode.nodeValue);
    }
    currentNode = iterator.nextNode();
  }
  return comments;
};
var isHtmlComment = (node) => node.nodeType === Node.COMMENT_NODE;
var postCleanHtml = (html) => {
  const cleanHtml = html.trim().replace(new RegExp(ZERO_WIDTH_SPACE, "g"), "");
  return `<body>${cleanHtml}</body>`;
};
var removeBeforeHtml = (html) => {
  const index2 = html.indexOf("<html");
  if (index2 === -1) {
    return html;
  }
  return html.substring(index2);
};
var removeAfterHtml = (html) => {
  const index2 = html.lastIndexOf("</html>");
  if (index2 === -1) {
    return html;
  }
  return html.substring(0, index2 + "</html>".length);
};
var removeHtmlSurroundings = (html) => {
  return removeBeforeHtml(removeAfterHtml(html));
};
var cleaners = [removeHtmlSurroundings, cleanHtmlCrLf];
var preCleanHtml = (html) => {
  return cleaners.reduce((result, clean4) => clean4(result), html);
};
var traverseHtmlComments = (rootNode, callback) => {
  traverseHtmlNode(rootNode, (node) => {
    if (!isHtmlComment(node)) {
      return true;
    }
    return callback(node);
  });
};
var removeHtmlNodesBetweenComments = (rootNode, start3, end2) => {
  const isClosingComment = (node) => isHtmlComment(node) && node.data === end2;
  traverseHtmlComments(rootNode, (comment) => {
    if (comment.data === start3) {
      let node = comment.nextSibling;
      comment.remove();
      while (node && !isClosingComment(node)) {
        const {
          nextSibling
        } = node;
        node.remove();
        node = nextSibling;
      }
      if (node && isClosingComment(node)) {
        node.remove();
      }
    }
    return true;
  });
};
var createPathRef = (editor, at, options) => Editor.pathRef(editor, at, options);
var createPointRef = (editor, point, options) => Editor.pointRef(editor, point, options);
var deleteBackward = (editor, options) => Editor.deleteBackward(editor, options);
var isElementEmpty = (editor, element) => Editor.isEmpty(editor, element);
var deleteText = (editor, options) => {
  Transforms.delete(editor, options);
};
var moveNodes = (editor, options) => Transforms.moveNodes(editor, options);
var removeNodes = (editor, options) => Transforms.removeNodes(editor, options);
var select = (editor, target) => {
  Transforms.select(editor, target);
};
var mergeNodes = (editor, options = {}) => {
  withoutNormalizing(editor, () => {
    let {
      match: match5,
      at = editor.selection
    } = options;
    const {
      mergeNode,
      removeEmptyAncestor,
      hanging = false,
      voids = false,
      mode = "lowest"
    } = options;
    if (!at) {
      return;
    }
    if (match5 == null) {
      if (Path.isPath(at)) {
        const [parent2] = getParentNode(editor, at);
        match5 = (n12) => parent2.children.includes(n12);
      } else {
        match5 = (n12) => isBlock(editor, n12);
      }
    }
    if (!hanging && Range.isRange(at)) {
      at = Editor.unhangRange(editor, at);
    }
    if (Range.isRange(at)) {
      if (Range.isCollapsed(at)) {
        at = at.anchor;
      } else {
        const [, end2] = Range.edges(at);
        const pointRef = createPointRef(editor, end2);
        deleteText(editor, {
          at
        });
        at = pointRef.unref();
        if (options.at == null) {
          select(editor, at);
        }
      }
    }
    const _nodes = getNodeEntries(editor, {
      at,
      match: match5,
      voids,
      mode
    });
    const [current] = Array.from(_nodes);
    const prev = getPreviousNode(editor, {
      at,
      match: match5,
      voids,
      mode
    });
    if (!current || !prev) {
      return;
    }
    const [node, path] = current;
    const [prevNode, prevPath] = prev;
    if (path.length === 0 || prevPath.length === 0) {
      return;
    }
    const newPath = Path.next(prevPath);
    const commonPath = Path.common(path, prevPath);
    const isPreviousSibling = Path.isSibling(path, prevPath);
    const _levels = Editor.levels(editor, {
      at: path
    });
    const levels = Array.from(_levels, ([n12]) => n12).slice(commonPath.length).slice(0, -1);
    const emptyAncestor = getAboveNode(editor, {
      at: path,
      mode: "highest",
      match: (n12) => levels.includes(n12) && isElement2(n12) && hasSingleChild(n12)
    });
    const emptyRef = emptyAncestor && createPathRef(editor, emptyAncestor[1]);
    let properties;
    let position3;
    if (isText(node) && isText(prevNode)) {
      const {
        text,
        ...rest
      } = node;
      position3 = prevNode.text.length;
      properties = rest;
    } else if (isElement2(node) && isElement2(prevNode)) {
      const {
        children,
        ...rest
      } = node;
      position3 = prevNode.children.length;
      properties = rest;
    } else {
      throw new Error(`Cannot merge the node at path [${path}] with the previous sibling because it is not the same kind: ${JSON.stringify(node)} ${JSON.stringify(prevNode)}`);
    }
    if (!isPreviousSibling) {
      if (!mergeNode) {
        moveNodes(editor, {
          at: path,
          to: newPath,
          voids
        });
      }
    }
    if (emptyRef) {
      if (!removeEmptyAncestor) {
        removeNodes(editor, {
          at: emptyRef.current,
          voids
        });
      } else {
        const emptyPath = emptyRef.current;
        emptyPath && removeEmptyAncestor(editor, {
          at: emptyPath
        });
      }
    }
    if (mergeNode) {
      mergeNode(editor, {
        at: path,
        to: newPath
      });
    } else if (isElement2(prevNode) && isElementEmpty(editor, prevNode) || isText(prevNode) && prevNode.text === "") {
      removeNodes(editor, {
        at: prevPath,
        voids
      });
    } else {
      editor.apply({
        type: "merge_node",
        path: newPath,
        position: position3,
        properties
      });
    }
    if (emptyRef) {
      emptyRef.unref();
    }
  });
};
var getEndPoint = (editor, at) => Editor.end(editor, at);
var getLeafNode = (editor, at, options) => Editor.leaf(editor, at, options);
var deleteMerge = (editor, options = {}) => {
  withoutNormalizing(editor, () => {
    const {
      reverse = false,
      unit = "character",
      distance: distance3 = 1,
      voids = false
    } = options;
    let {
      at = editor.selection,
      hanging = false
    } = options;
    if (!at) {
      return;
    }
    if (Range.isRange(at) && Range.isCollapsed(at)) {
      at = at.anchor;
    }
    if (Point.isPoint(at)) {
      const furthestVoid = getVoidNode(editor, {
        at,
        mode: "highest"
      });
      if (!voids && furthestVoid) {
        const [, voidPath] = furthestVoid;
        at = voidPath;
      } else {
        const opts = {
          unit,
          distance: distance3
        };
        const target = reverse ? getPointBefore(editor, at, opts) || getStartPoint(editor, []) : getPointAfter(editor, at, opts) || getEndPoint(editor, []);
        at = {
          anchor: at,
          focus: target
        };
        hanging = true;
      }
    }
    if (Path.isPath(at)) {
      removeNodes(editor, {
        at,
        voids
      });
      return;
    }
    if (Range.isCollapsed(at)) {
      return;
    }
    if (!hanging) {
      at = Editor.unhangRange(editor, at, {
        voids
      });
    }
    let [start3, end2] = Range.edges(at);
    const startBlock = getAboveNode(editor, {
      match: (n12) => isBlock(editor, n12),
      at: start3,
      voids
    });
    const endBlock = getAboveNode(editor, {
      match: (n12) => isBlock(editor, n12),
      at: end2,
      voids
    });
    const isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);
    const isSingleText = Path.equals(start3.path, end2.path);
    const startVoid = voids ? null : getVoidNode(editor, {
      at: start3,
      mode: "highest"
    });
    const endVoid = voids ? null : getVoidNode(editor, {
      at: end2,
      mode: "highest"
    });
    if (startVoid) {
      const before = getPointBefore(editor, start3);
      if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {
        start3 = before;
      }
    }
    if (endVoid) {
      const after = getPointAfter(editor, end2);
      if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {
        end2 = after;
      }
    }
    const matches = [];
    let lastPath;
    const _nodes = getNodeEntries(editor, {
      at,
      voids
    });
    for (const entry of _nodes) {
      const [node, path] = entry;
      if (lastPath && Path.compare(path, lastPath) === 0) {
        continue;
      }
      if (!voids && isVoid(editor, node) || !Path.isCommon(path, start3.path) && !Path.isCommon(path, end2.path)) {
        matches.push(entry);
        lastPath = path;
      }
    }
    const pathRefs = Array.from(matches, ([, p12]) => createPathRef(editor, p12));
    const startRef = createPointRef(editor, start3);
    const endRef = createPointRef(editor, end2);
    if (!isSingleText && !startVoid) {
      const point2 = startRef.current;
      const [node] = getLeafNode(editor, point2);
      const {
        path
      } = point2;
      const {
        offset: offset5
      } = start3;
      const text = node.text.slice(offset5);
      editor.apply({
        type: "remove_text",
        path,
        offset: offset5,
        text
      });
    }
    for (const pathRef of pathRefs) {
      const path = pathRef.unref();
      removeNodes(editor, {
        at: path,
        voids
      });
    }
    if (!endVoid) {
      const point2 = endRef.current;
      const [node] = getLeafNode(editor, point2);
      const {
        path
      } = point2;
      const offset5 = isSingleText ? start3.offset : 0;
      const text = node.text.slice(offset5, end2.offset);
      editor.apply({
        type: "remove_text",
        path,
        offset: offset5,
        text
      });
    }
    if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {
      mergeNodes(editor, {
        at: endRef.current,
        hanging: true,
        voids
      });
    }
    const point = endRef.unref() || startRef.unref();
    if (options.at == null && point) {
      select(editor, point);
    }
  });
};
var insertNode = (editor, node) => Editor.insertNode(editor, node);
var getCommonNode = (root6, path, another) => Node2.common(root6, path, another);
var getNodeChildren = (root6, path, options) => Node2.children(root6, path, options);
var getNodeTexts = (root6, options) => Node2.texts(root6, options);
var getNodes = (root6, options) => Node2.nodes(root6, options);
var hasNode = (root6, path) => Node2.has(root6, path);
var isCollapsed = (range) => !!range && Range.isCollapsed(range);
var findNodePath = (editor, node) => {
  try {
    return ReactEditor.findPath(editor, node);
  } catch (e9) {
  }
};
var collapseSelection = (editor, options) => {
  Transforms.collapse(editor, options);
};
var deselect = (editor) => {
  Transforms.deselect(editor);
};
var insertFragment = (editor, fragment, options) => {
  Transforms.insertFragment(editor, fragment, options);
};
var insertNodes = (editor, nodes, options) => Transforms.insertNodes(editor, nodes, options);
var insertText = (editor, text, options) => {
  Transforms.insertText(editor, text, options);
};
var moveSelection = (editor, options) => {
  Transforms.move(editor, options);
};
var setSelection = (editor, props) => {
  Transforms.setSelection(editor, props);
};
var splitNodes = (editor, options) => Transforms.splitNodes(editor, options);
var unwrapNodes = (editor, options) => {
  Transforms.unwrapNodes(editor, getQueryOptions(editor, options));
};
var wrapNodes = (editor, element, options) => {
  unhangRange(editor, options === null || options === void 0 ? void 0 : options.at, options);
  Transforms.wrapNodes(editor, element, options);
};
var focusEditor = (editor, target) => {
  if (target) {
    withoutNormalizing(editor, () => {
      deselect(editor);
      select(editor, target);
    });
  }
  ReactEditor.focus(editor);
};
var isEditorFocused = (editor) => ReactEditor.isFocused(editor);
var objectProto2 = Object.prototype;
var hasOwnProperty2 = objectProto2.hasOwnProperty;
var defaults = _baseRest(function(object2, sources) {
  object2 = Object(object2);
  var index2 = -1;
  var length = sources.length;
  var guard = length > 2 ? sources[2] : void 0;
  if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
    length = 1;
  }
  while (++index2 < length) {
    var source = sources[index2];
    var props = keysIn_1(source);
    var propsIndex = -1;
    var propsLength = props.length;
    while (++propsIndex < propsLength) {
      var key = props[propsIndex];
      var value = object2[key];
      if (value === void 0 || eq_12(value, objectProto2[key]) && !hasOwnProperty2.call(object2, key)) {
        object2[key] = source[key];
      }
    }
  }
  return object2;
});
var defaults_1 = defaults;
var defaultsDeepToNodes = (options) => {
  applyDeepToNodes({
    ...options,
    apply: defaults_1
  });
};
var insertElements = (editor, nodes, options) => insertNodes(editor, nodes, options);
var insertEmptyElement = (editor, type, options) => {
  insertElements(editor, {
    type,
    children: [{
      text: ""
    }]
  }, getQueryOptions(editor, options));
};
var moveChildren = (editor, {
  at,
  to: to4,
  match: match5,
  fromStartIndex = 0
}) => {
  let moved = 0;
  const parentPath = Path.isPath(at) ? at : at[1];
  const parentNode = Path.isPath(at) ? getNode(editor, parentPath) : at[0];
  if (!isBlock(editor, parentNode))
    return moved;
  for (let i15 = parentNode.children.length - 1; i15 >= fromStartIndex; i15--) {
    const childPath = [...parentPath, i15];
    const childNode = getNode(editor, childPath);
    if (!match5 || childNode && match5([childNode, childPath])) {
      moveNodes(editor, {
        at: childPath,
        to: to4
      });
      moved++;
    }
  }
  return moved;
};

// node_modules/@udecode/plate-alignment/dist/index.es.js
var KEY_ALIGN = "align";
var createAlignPlugin = createPluginFactory({
  key: KEY_ALIGN,
  then: (editor) => ({
    inject: {
      props: {
        nodeKey: KEY_ALIGN,
        defaultNodeValue: "left",
        styleKey: "textAlign",
        validNodeValues: ["left", "center", "right", "justify"],
        validTypes: [getPluginType(editor, ELEMENT_DEFAULT)]
      }
    },
    then: (_7, plugin) => mapInjectPropsToPlugin(editor, plugin, {
      deserializeHtml: {
        getNode: (el, node) => {
          if (el.style.textAlign) {
            node[plugin.key] = el.style.textAlign;
          }
        }
      }
    })
  })
});

// node_modules/@udecode/plate-autoformat/dist/index.es.js
function unwrapExports2(x7) {
  return x7 && x7.__esModule && Object.prototype.hasOwnProperty.call(x7, "default") ? x7["default"] : x7;
}
function createCommonjsModule3(fn2, module2) {
  return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
}
var lib2 = createCommonjsModule3(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var IS_MAC = () => typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
  var MODIFIERS = {
    alt: "altKey",
    control: "ctrlKey",
    meta: "metaKey",
    shift: "shiftKey"
  };
  var ALIASES = () => ({
    add: "+",
    break: "pause",
    cmd: "meta",
    command: "meta",
    ctl: "control",
    ctrl: "control",
    del: "delete",
    down: "arrowdown",
    esc: "escape",
    ins: "insert",
    left: "arrowleft",
    mod: IS_MAC() ? "meta" : "control",
    opt: "alt",
    option: "alt",
    return: "enter",
    right: "arrowright",
    space: " ",
    spacebar: " ",
    up: "arrowup",
    win: "meta",
    windows: "meta"
  });
  var CODES = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    control: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    " ": 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    insert: 45,
    delete: 46,
    meta: 91,
    numlock: 144,
    scrolllock: 145,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
  };
  for (var f16 = 1; f16 < 20; f16++) {
    CODES["f" + f16] = 111 + f16;
  }
  function isHotkey14(hotkey, options, event) {
    if (options && !("byKey" in options)) {
      event = options;
      options = null;
    }
    if (!Array.isArray(hotkey)) {
      hotkey = [hotkey];
    }
    var array2 = hotkey.map(function(string2) {
      return parseHotkey(string2, options);
    });
    var check = function check2(e9) {
      return array2.some(function(object2) {
        return compareHotkey(object2, e9);
      });
    };
    var ret = event == null ? check : check(event);
    return ret;
  }
  function isCodeHotkey(hotkey, event) {
    return isHotkey14(hotkey, event);
  }
  function isKeyHotkey2(hotkey, event) {
    return isHotkey14(hotkey, { byKey: true }, event);
  }
  function parseHotkey(hotkey, options) {
    var byKey = options && options.byKey;
    var ret = {};
    hotkey = hotkey.replace("++", "+add");
    var values3 = hotkey.split("+");
    var length = values3.length;
    for (var k3 in MODIFIERS) {
      ret[MODIFIERS[k3]] = false;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = void 0;
    try {
      for (var _iterator = values3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var value = _step.value;
        var optional = value.endsWith("?") && value.length > 1;
        if (optional) {
          value = value.slice(0, -1);
        }
        var name2 = toKeyName(value);
        var modifier = MODIFIERS[name2];
        if (length === 1 || !modifier) {
          if (byKey) {
            ret.key = name2;
          } else {
            ret.which = toKeyCode(value);
          }
        }
        if (modifier) {
          ret[modifier] = optional ? null : true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return ret;
  }
  function compareHotkey(object2, event) {
    for (var key in object2) {
      var expected = object2[key];
      var actual = void 0;
      if (expected == null) {
        continue;
      }
      if (key === "key" && event.key != null) {
        actual = event.key.toLowerCase();
      } else if (key === "which") {
        actual = expected === 91 && event.which === 93 ? 91 : event.which;
      } else {
        actual = event[key];
      }
      if (actual == null && expected === false) {
        continue;
      }
      if (actual !== expected) {
        return false;
      }
    }
    return true;
  }
  function toKeyCode(name2) {
    name2 = toKeyName(name2);
    var code = CODES[name2] || name2.toUpperCase().charCodeAt(0);
    return code;
  }
  function toKeyName(name2) {
    name2 = name2.toLowerCase();
    name2 = ALIASES()[name2] || name2;
    return name2;
  }
  exports2.default = isHotkey14;
  exports2.isHotkey = isHotkey14;
  exports2.isCodeHotkey = isCodeHotkey;
  exports2.isKeyHotkey = isKeyHotkey2;
  exports2.parseHotkey = parseHotkey;
  exports2.compareHotkey = compareHotkey;
  exports2.toKeyCode = toKeyCode;
  exports2.toKeyName = toKeyName;
});
var isHotkey2 = unwrapExports2(lib2);
lib2.isHotkey;
lib2.isCodeHotkey;
lib2.isKeyHotkey;
lib2.parseHotkey;
lib2.compareHotkey;
lib2.toKeyCode;
lib2.toKeyName;
var onKeyDownAutoformat = (editor, {
  options: {
    rules,
    enableUndoOnDelete
  }
}) => (e9) => {
  if (!isHotkey2("backspace", {
    byKey: true
  }, e9))
    return false;
  if (!rules)
    return false;
  if (!enableUndoOnDelete)
    return false;
  const {
    selection
  } = editor;
  if (!selection || !Range.isCollapsed(selection))
    return;
  const [start3, end2] = Range.edges(selection);
  const before = getPointBefore(editor, end2, {
    unit: "character",
    distance: 1
  });
  if (!start3)
    return false;
  if (!before)
    return false;
  const charRange = {
    anchor: before,
    focus: start3
  };
  if (!charRange)
    return false;
  const char = getEditorString(editor, charRange);
  if (!char)
    return false;
  const matchers2 = [...rules].filter((rule2) => {
    const textRule = rule2;
    if (textRule) {
      return textRule.mode === "text" && textRule.format === char;
    }
    return false;
  });
  if (!matchers2 || matchers2.length === 0)
    return false;
  e9.preventDefault();
  deleteBackward(editor, {
    unit: "character"
  });
  const rule = matchers2[0];
  if (rule && typeof rule.match === "string") {
    insertText(editor, rule.match);
  } else {
    const matchArray = rule.match;
    if (matchArray && matchArray.length > 0) {
      insertText(editor, matchArray[0]);
    }
  }
  return true;
};
var isArray3 = Array.isArray;
var isArray_12 = isArray3;
function castArray2() {
  if (!arguments.length) {
    return [];
  }
  var value = arguments[0];
  return isArray_12(value) ? value : [value];
}
var castArray_12 = castArray2;
var getMatchRange = ({
  match: match5,
  trigger
}) => {
  let start3;
  let end2;
  if (typeof match5 === "object") {
    start3 = match5.start;
    end2 = match5.end;
  } else {
    start3 = match5;
    end2 = start3.split("").reverse().join("");
  }
  const triggers = trigger ? castArray_12(trigger) : [end2.slice(-1)];
  end2 = trigger ? end2 : end2.slice(0, -1);
  return {
    start: start3,
    end: end2,
    triggers
  };
};
var autoformatBlock = (editor, {
  text,
  trigger,
  match: _match,
  type = ELEMENT_DEFAULT,
  allowSameTypeAbove = false,
  preFormat: preFormat2,
  format: format3,
  triggerAtBlockStart = true
}) => {
  const matches = castArray_12(_match);
  for (const match5 of matches) {
    const {
      end: end2,
      triggers
    } = getMatchRange({
      match: {
        start: "",
        end: match5
      },
      trigger
    });
    if (!triggers.includes(text))
      continue;
    let matchRange;
    if (triggerAtBlockStart) {
      matchRange = getRangeFromBlockStart(editor);
      const hasVoidNode = someNode(editor, {
        at: matchRange,
        match: (n12) => isVoid(editor, n12)
      });
      if (hasVoidNode)
        continue;
      const textFromBlockStart = getEditorString(editor, matchRange);
      if (end2 !== textFromBlockStart)
        continue;
    } else {
      matchRange = getRangeBefore(editor, editor.selection, {
        matchString: end2
      });
      if (!matchRange)
        continue;
    }
    if (!allowSameTypeAbove) {
      const isBelowSameBlockType = someNode(editor, {
        match: {
          type
        }
      });
      if (isBelowSameBlockType)
        continue;
    }
    if (match5.length > 1) {
      deleteText(editor, {
        at: matchRange
      });
    }
    if (preFormat2) {
      preFormat2(editor);
    }
    if (!format3) {
      setElements(editor, {
        type
      }, {
        match: (n12) => isBlock(editor, n12)
      });
    } else {
      format3(editor);
    }
    return true;
  }
  return false;
};
var isPreviousCharacterEmpty = (editor, at) => {
  const range = getRangeBefore(editor, at);
  if (range) {
    const text = getEditorString(editor, range);
    if (text) {
      const noWhiteSpaceRegex = new RegExp(`\\S+`);
      return !text.match(noWhiteSpaceRegex);
    }
  }
  return true;
};
var getMatchPoints = (editor, {
  start: start3,
  end: end2
}) => {
  const selection = editor.selection;
  let beforeEndMatchPoint = selection.anchor;
  if (end2) {
    beforeEndMatchPoint = getPointBeforeLocation(editor, selection, {
      matchString: end2
    });
    if (!beforeEndMatchPoint)
      return;
  }
  let afterStartMatchPoint;
  let beforeStartMatchPoint;
  if (start3) {
    afterStartMatchPoint = getPointBeforeLocation(editor, beforeEndMatchPoint, {
      matchString: start3,
      skipInvalid: true,
      afterMatch: true
    });
    if (!afterStartMatchPoint)
      return;
    beforeStartMatchPoint = getPointBeforeLocation(editor, beforeEndMatchPoint, {
      matchString: start3,
      skipInvalid: true
    });
    if (!isPreviousCharacterEmpty(editor, beforeStartMatchPoint))
      return;
  }
  return {
    afterStartMatchPoint,
    beforeStartMatchPoint,
    beforeEndMatchPoint
  };
};
var autoformatMark = (editor, {
  type,
  text,
  trigger,
  match: _match,
  ignoreTrim
}) => {
  if (!type)
    return false;
  const selection = editor.selection;
  const matches = castArray_12(_match);
  for (const match5 of matches) {
    const {
      start: start3,
      end: end2,
      triggers
    } = getMatchRange({
      match: match5,
      trigger
    });
    if (!triggers.includes(text))
      continue;
    const matched = getMatchPoints(editor, {
      start: start3,
      end: end2
    });
    if (!matched)
      continue;
    const {
      afterStartMatchPoint,
      beforeEndMatchPoint,
      beforeStartMatchPoint
    } = matched;
    const matchRange = {
      anchor: afterStartMatchPoint,
      focus: beforeEndMatchPoint
    };
    if (!ignoreTrim) {
      const matchText = getEditorString(editor, matchRange);
      if (matchText.trim() !== matchText)
        continue;
    }
    if (end2) {
      deleteText(editor, {
        at: {
          anchor: beforeEndMatchPoint,
          focus: selection.anchor
        }
      });
    }
    const marks = castArray_12(type);
    select(editor, matchRange);
    marks.forEach((mark) => {
      editor.addMark(mark, true);
    });
    collapseSelection(editor, {
      edge: "end"
    });
    removeMark(editor, {
      key: marks,
      shouldChange: false
    });
    deleteText(editor, {
      at: {
        anchor: beforeStartMatchPoint,
        focus: afterStartMatchPoint
      }
    });
    return true;
  }
  return false;
};
var autoformatText = (editor, {
  text,
  match: _match,
  trigger,
  format: format3
}) => {
  const selection = editor.selection;
  const matches = castArray_12(_match);
  for (const match5 of matches) {
    const {
      start: start3,
      end: end2,
      triggers
    } = getMatchRange({
      match: Array.isArray(format3) ? match5 : {
        start: "",
        end: match5
      },
      trigger
    });
    if (!triggers.includes(text))
      continue;
    const matched = getMatchPoints(editor, {
      start: start3,
      end: end2
    });
    if (!matched)
      continue;
    const {
      afterStartMatchPoint,
      beforeEndMatchPoint,
      beforeStartMatchPoint
    } = matched;
    if (end2) {
      deleteText(editor, {
        at: {
          anchor: beforeEndMatchPoint,
          focus: selection.anchor
        }
      });
    }
    if (typeof format3 === "function") {
      format3(editor, matched);
    } else {
      const formatEnd = Array.isArray(format3) ? format3[1] : format3;
      editor.insertText(formatEnd);
      if (beforeStartMatchPoint) {
        const formatStart = Array.isArray(format3) ? format3[0] : format3;
        deleteText(editor, {
          at: {
            anchor: beforeStartMatchPoint,
            focus: afterStartMatchPoint
          }
        });
        insertText(editor, formatStart, {
          at: beforeStartMatchPoint
        });
      }
    }
    return true;
  }
  return false;
};
var withAutoformat = (editor, {
  options: {
    rules
  }
}) => {
  const {
    insertText: insertText2
  } = editor;
  editor.insertText = (text) => {
    if (!isCollapsed(editor.selection))
      return insertText2(text);
    for (const rule of rules) {
      var _autoformatter$mode;
      const {
        mode = "text",
        insertTrigger,
        query
      } = rule;
      if (query && !query(editor, {
        ...rule,
        text
      }))
        continue;
      const autoformatter = {
        block: autoformatBlock,
        mark: autoformatMark,
        text: autoformatText
      };
      if ((_autoformatter$mode = autoformatter[mode]) !== null && _autoformatter$mode !== void 0 && _autoformatter$mode.call(autoformatter, editor, {
        ...rule,
        text
      })) {
        return insertTrigger && insertText2(text);
      }
    }
    insertText2(text);
  };
  return editor;
};
var KEY_AUTOFORMAT = "autoformat";
var createAutoformatPlugin = createPluginFactory({
  key: KEY_AUTOFORMAT,
  withOverrides: withAutoformat,
  handlers: {
    onKeyDown: onKeyDownAutoformat
  },
  options: {
    rules: []
  }
});
var autoformatComparison = [{
  mode: "text",
  match: "!>",
  format: "≯"
}, {
  mode: "text",
  match: "!<",
  format: "≮"
}, {
  mode: "text",
  match: ">=",
  format: "≥"
}, {
  mode: "text",
  match: "<=",
  format: "≤"
}, {
  mode: "text",
  match: "!>=",
  format: "≱"
}, {
  mode: "text",
  match: "!<=",
  format: "≰"
}];
var autoformatEquality = [{
  mode: "text",
  match: "!=",
  format: "≠"
}, {
  mode: "text",
  match: "==",
  format: "≡"
}, {
  mode: "text",
  match: ["!==", "≠="],
  format: "≢"
}, {
  mode: "text",
  match: "~=",
  format: "≈"
}, {
  mode: "text",
  match: "!~=",
  format: "≉"
}];
var autoformatFraction = [{
  mode: "text",
  match: "1/2",
  format: "½"
}, {
  mode: "text",
  match: "1/3",
  format: "⅓"
}, {
  mode: "text",
  match: "1/4",
  format: "¼"
}, {
  mode: "text",
  match: "1/5",
  format: "⅕"
}, {
  mode: "text",
  match: "1/6",
  format: "⅙"
}, {
  mode: "text",
  match: "1/7",
  format: "⅐"
}, {
  mode: "text",
  match: "1/8",
  format: "⅛"
}, {
  mode: "text",
  match: "1/9",
  format: "⅑"
}, {
  mode: "text",
  match: "1/10",
  format: "⅒"
}, {
  mode: "text",
  match: "2/3",
  format: "⅔"
}, {
  mode: "text",
  match: "2/5",
  format: "⅖"
}, {
  mode: "text",
  match: "3/4",
  format: "¾"
}, {
  mode: "text",
  match: "3/5",
  format: "⅗"
}, {
  mode: "text",
  match: "3/8",
  format: "⅜"
}, {
  mode: "text",
  match: "4/5",
  format: "⅘"
}, {
  mode: "text",
  match: "5/6",
  format: "⅚"
}, {
  mode: "text",
  match: "5/8",
  format: "⅝"
}, {
  mode: "text",
  match: "7/8",
  format: "⅞"
}];
var autoformatDivision = [{
  mode: "text",
  match: "//",
  format: "÷"
}];
var autoformatOperation = [{
  mode: "text",
  match: "+-",
  format: "±"
}, {
  mode: "text",
  match: "%%",
  format: "‰"
}, {
  mode: "text",
  match: ["%%%", "‰%"],
  format: "‱"
}, ...autoformatDivision];
var autoformatSubscriptNumbers = [{
  mode: "text",
  match: "~0",
  format: "₀"
}, {
  mode: "text",
  match: "~1",
  format: "₁"
}, {
  mode: "text",
  match: "~2",
  format: "₂"
}, {
  mode: "text",
  match: "~3",
  format: "₃"
}, {
  mode: "text",
  match: "~4",
  format: "₄"
}, {
  mode: "text",
  match: "~5",
  format: "₅"
}, {
  mode: "text",
  match: "~6",
  format: "₆"
}, {
  mode: "text",
  match: "~7",
  format: "₇"
}, {
  mode: "text",
  match: "~8",
  format: "₈"
}, {
  mode: "text",
  match: "~9",
  format: "₉"
}];
var autoformatSubscriptSymbols = [{
  mode: "text",
  match: "~+",
  format: "₊"
}, {
  mode: "text",
  match: "~-",
  format: "₋"
}];
var autoformatSuperscriptNumbers = [{
  mode: "text",
  match: "^0",
  format: "⁰"
}, {
  mode: "text",
  match: "^1",
  format: "¹"
}, {
  mode: "text",
  match: "^2",
  format: "²"
}, {
  mode: "text",
  match: "^3",
  format: "³"
}, {
  mode: "text",
  match: "^4",
  format: "⁴"
}, {
  mode: "text",
  match: "^5",
  format: "⁵"
}, {
  mode: "text",
  match: "^6",
  format: "⁶"
}, {
  mode: "text",
  match: "^7",
  format: "⁷"
}, {
  mode: "text",
  match: "^8",
  format: "⁸"
}, {
  mode: "text",
  match: "^9",
  format: "⁹"
}];
var autoformatSuperscriptSymbols = [{
  mode: "text",
  match: "^o",
  format: "°"
}, {
  mode: "text",
  match: "^+",
  format: "⁺"
}, {
  mode: "text",
  match: "^-",
  format: "⁻"
}];
var autoformatMath = [...autoformatComparison, ...autoformatEquality, ...autoformatOperation, ...autoformatFraction, ...autoformatSuperscriptSymbols, ...autoformatSubscriptSymbols, ...autoformatSuperscriptNumbers, ...autoformatSubscriptNumbers];

// node_modules/@udecode/plate-block-quote/dist/index.es.js
var ELEMENT_BLOCKQUOTE = "blockquote";
var createBlockquotePlugin = createPluginFactory({
  key: ELEMENT_BLOCKQUOTE,
  isElement: true,
  deserializeHtml: {
    rules: [{
      validNodeName: "BLOCKQUOTE"
    }]
  },
  handlers: {
    onKeyDown: onKeyDownToggleElement
  },
  options: {
    hotkey: "mod+shift+."
  }
});

// node_modules/@udecode/plate-code-block/dist/index.es.js
var import_prismjs = __toESM(require_prism());
var ELEMENT_CODE_BLOCK = "code_block";
var ELEMENT_CODE_LINE = "code_line";
var ELEMENT_CODE_SYNTAX = "code_syntax";
Prism.languages.antlr4 = {
  "comment": /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
  "string": {
    pattern: /'(?:\\.|[^\\'\r\n])*'/,
    greedy: true
  },
  "character-class": {
    pattern: /\[(?:\\.|[^\\\]\r\n])*\]/,
    greedy: true,
    alias: "regex",
    inside: {
      "range": {
        pattern: /([^[]|(?:^|[^\\])(?:\\\\)*\\\[)-(?!\])/,
        lookbehind: true,
        alias: "punctuation"
      },
      "escape": /\\(?:u(?:[a-fA-F\d]{4}|\{[a-fA-F\d]+\})|[pP]\{[=\w-]+\}|[^\r\nupP])/,
      "punctuation": /[\[\]]/
    }
  },
  "action": {
    pattern: /\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\}/,
    greedy: true,
    inside: {
      "content": {
        // this might be C, C++, Python, Java, C#, or any other language ANTLR4 compiles to
        pattern: /(\{)[\s\S]+(?=\})/,
        lookbehind: true
      },
      "punctuation": /[{}]/
    }
  },
  "command": {
    pattern: /(->\s*(?!\s))(?:\s*(?:,\s*)?\b[a-z]\w*(?:\s*\([^()\r\n]*\))?)+(?=\s*;)/i,
    lookbehind: true,
    inside: {
      "function": /\b\w+(?=\s*(?:[,(]|$))/,
      "punctuation": /[,()]/
    }
  },
  "annotation": {
    pattern: /@\w+(?:::\w+)*/,
    alias: "keyword"
  },
  "label": {
    pattern: /#[ \t]*\w+/,
    alias: "punctuation"
  },
  "keyword": /\b(?:catch|channels|finally|fragment|grammar|import|lexer|locals|mode|options|parser|returns|throws|tokens)\b/,
  "definition": [
    {
      pattern: /\b[a-z]\w*(?=\s*:)/,
      alias: ["rule", "class-name"]
    },
    {
      pattern: /\b[A-Z]\w*(?=\s*:)/,
      alias: ["token", "constant"]
    }
  ],
  "constant": /\b[A-Z][A-Z_]*\b/,
  "operator": /\.\.|->|[|~]|[*+?]\??/,
  "punctuation": /[;:()=]/
};
Prism.languages.g4 = Prism.languages.antlr4;
(function(Prism2) {
  var envVars = "\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b";
  var commandAfterHeredoc = {
    pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
    lookbehind: true,
    alias: "punctuation",
    // this looks reasonably well in all themes
    inside: null
    // see below
  };
  var insideString = {
    "bash": commandAfterHeredoc,
    "environment": {
      pattern: RegExp("\\$" + envVars),
      alias: "constant"
    },
    "variable": [
      // [0]: Arithmetic Environment
      {
        pattern: /\$?\(\([\s\S]+?\)\)/,
        greedy: true,
        inside: {
          // If there is a $ sign at the beginning highlight $(( and )) as variable
          "variable": [
            {
              pattern: /(^\$\(\([\s\S]+)\)\)/,
              lookbehind: true
            },
            /^\$\(\(/
          ],
          "number": /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
          // Operators according to https://www.gnu.org/software/bash/manual/bashref.html#Shell-Arithmetic
          "operator": /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
          // If there is no $ sign at the beginning highlight (( and )) as punctuation
          "punctuation": /\(\(?|\)\)?|,|;/
        }
      },
      // [1]: Command Substitution
      {
        pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
        greedy: true,
        inside: {
          "variable": /^\$\(|^`|\)$|`$/
        }
      },
      // [2]: Brace expansion
      {
        pattern: /\$\{[^}]+\}/,
        greedy: true,
        inside: {
          "operator": /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
          "punctuation": /[\[\]]/,
          "environment": {
            pattern: RegExp("(\\{)" + envVars),
            lookbehind: true,
            alias: "constant"
          }
        }
      },
      /\$(?:\w+|[#?*!@$])/
    ],
    // Escape sequences from echo and printf's manuals, and escaped quotes.
    "entity": /\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
  };
  Prism2.languages.bash = {
    "shebang": {
      pattern: /^#!\s*\/.*/,
      alias: "important"
    },
    "comment": {
      pattern: /(^|[^"{\\$])#.*/,
      lookbehind: true
    },
    "function-name": [
      // a) function foo {
      // b) foo() {
      // c) function foo() {
      // but not “foo {”
      {
        // a) and c)
        pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
        lookbehind: true,
        alias: "function"
      },
      {
        // b)
        pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
        alias: "function"
      }
    ],
    // Highlight variable names as variables in for and select beginnings.
    "for-or-select": {
      pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
      alias: "variable",
      lookbehind: true
    },
    // Highlight variable names as variables in the left-hand part
    // of assignments (“=” and “+=”).
    "assign-left": {
      pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,
      inside: {
        "environment": {
          pattern: RegExp("(^|[\\s;|&]|[<>]\\()" + envVars),
          lookbehind: true,
          alias: "constant"
        }
      },
      alias: "variable",
      lookbehind: true
    },
    "string": [
      // Support for Here-documents https://en.wikipedia.org/wiki/Here_document
      {
        pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      // Here-document with quotes around the tag
      // → No expansion (so no “inside”).
      {
        pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
        lookbehind: true,
        greedy: true,
        inside: {
          "bash": commandAfterHeredoc
        }
      },
      // “Normal” string
      {
        // https://www.gnu.org/software/bash/manual/html_node/Double-Quotes.html
        pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
        lookbehind: true,
        greedy: true,
        inside: insideString
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/Single-Quotes.html
        pattern: /(^|[^$\\])'[^']*'/,
        lookbehind: true,
        greedy: true
      },
      {
        // https://www.gnu.org/software/bash/manual/html_node/ANSI_002dC-Quoting.html
        pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
        greedy: true,
        inside: {
          "entity": insideString.entity
        }
      }
    ],
    "environment": {
      pattern: RegExp("\\$?" + envVars),
      alias: "constant"
    },
    "variable": insideString.variable,
    "function": {
      pattern: /(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "keyword": {
      pattern: /(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    // https://www.gnu.org/software/bash/manual/html_node/Shell-Builtin-Commands.html
    "builtin": {
      pattern: /(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
      lookbehind: true,
      // Alias added to make those easier to distinguish from strings.
      alias: "class-name"
    },
    "boolean": {
      pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
      lookbehind: true
    },
    "file-descriptor": {
      pattern: /\B&\d\b/,
      alias: "important"
    },
    "operator": {
      // Lots of redirections here, but not just that.
      pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
      inside: {
        "file-descriptor": {
          pattern: /^\d/,
          alias: "important"
        }
      }
    },
    "punctuation": /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
    "number": {
      pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
      lookbehind: true
    }
  };
  commandAfterHeredoc.inside = Prism2.languages.bash;
  var toBeCopied = [
    "comment",
    "function-name",
    "for-or-select",
    "assign-left",
    "string",
    "environment",
    "function",
    "keyword",
    "builtin",
    "boolean",
    "file-descriptor",
    "operator",
    "punctuation",
    "number"
  ];
  var inside = insideString.variable[1].inside;
  for (var i15 = 0; i15 < toBeCopied.length; i15++) {
    inside[toBeCopied[i15]] = Prism2.languages.bash[toBeCopied[i15]];
  }
  Prism2.languages.shell = Prism2.languages.bash;
})(Prism);
Prism.languages.c = Prism.languages.extend("clike", {
  "comment": {
    pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "string": {
    // https://en.cppreference.com/w/c/language/string_literal
    pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "class-name": {
    pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
    lookbehind: true
  },
  "keyword": /\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "number": /(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
  "operator": />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
});
Prism.languages.insertBefore("c", "string", {
  "char": {
    // https://en.cppreference.com/w/c/language/character_constant
    pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
    greedy: true
  }
});
Prism.languages.insertBefore("c", "string", {
  "macro": {
    // allow for multiline macro definitions
    // spaces after the # character compile fine with gcc
    pattern: /(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
    lookbehind: true,
    greedy: true,
    alias: "property",
    inside: {
      "string": [
        {
          // highlight the path of the include statement as a string
          pattern: /^(#\s*include\s*)<[^>]+>/,
          lookbehind: true
        },
        Prism.languages.c["string"]
      ],
      "char": Prism.languages.c["char"],
      "comment": Prism.languages.c["comment"],
      "macro-name": [
        {
          pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
          lookbehind: true
        },
        {
          pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
          lookbehind: true,
          alias: "function"
        }
      ],
      // highlight macro directives as keywords
      "directive": {
        pattern: /^(#\s*)[a-z]+/,
        lookbehind: true,
        alias: "keyword"
      },
      "directive-hash": /^#/,
      "punctuation": /##|\\(?=[\r\n])/,
      "expression": {
        pattern: /\S[\s\S]*/,
        inside: Prism.languages.c
      }
    }
  }
});
Prism.languages.insertBefore("c", "function", {
  // highlight predefined macros as constants
  "constant": /\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
});
delete Prism.languages.c["boolean"];
Prism.languages.cmake = {
  "comment": /#.*/,
  "string": {
    pattern: /"(?:[^\\"]|\\.)*"/,
    greedy: true,
    inside: {
      "interpolation": {
        pattern: /\$\{(?:[^{}$]|\$\{[^{}$]*\})*\}/,
        inside: {
          "punctuation": /\$\{|\}/,
          "variable": /\w+/
        }
      }
    }
  },
  "variable": /\b(?:CMAKE_\w+|\w+_(?:(?:BINARY|SOURCE)_DIR|DESCRIPTION|HOMEPAGE_URL|ROOT|VERSION(?:_MAJOR|_MINOR|_PATCH|_TWEAK)?)|(?:ANDROID|APPLE|BORLAND|BUILD_SHARED_LIBS|CACHE|CPACK_(?:ABSOLUTE_DESTINATION_FILES|COMPONENT_INCLUDE_TOPLEVEL_DIRECTORY|ERROR_ON_ABSOLUTE_INSTALL_DESTINATION|INCLUDE_TOPLEVEL_DIRECTORY|INSTALL_DEFAULT_DIRECTORY_PERMISSIONS|INSTALL_SCRIPT|PACKAGING_INSTALL_PREFIX|SET_DESTDIR|WARN_ON_ABSOLUTE_INSTALL_DESTINATION)|CTEST_(?:BINARY_DIRECTORY|BUILD_COMMAND|BUILD_NAME|BZR_COMMAND|BZR_UPDATE_OPTIONS|CHANGE_ID|CHECKOUT_COMMAND|CONFIGURATION_TYPE|CONFIGURE_COMMAND|COVERAGE_COMMAND|COVERAGE_EXTRA_FLAGS|CURL_OPTIONS|CUSTOM_(?:COVERAGE_EXCLUDE|ERROR_EXCEPTION|ERROR_MATCH|ERROR_POST_CONTEXT|ERROR_PRE_CONTEXT|MAXIMUM_FAILED_TEST_OUTPUT_SIZE|MAXIMUM_NUMBER_OF_(?:ERRORS|WARNINGS)|MAXIMUM_PASSED_TEST_OUTPUT_SIZE|MEMCHECK_IGNORE|POST_MEMCHECK|POST_TEST|PRE_MEMCHECK|PRE_TEST|TESTS_IGNORE|WARNING_EXCEPTION|WARNING_MATCH)|CVS_CHECKOUT|CVS_COMMAND|CVS_UPDATE_OPTIONS|DROP_LOCATION|DROP_METHOD|DROP_SITE|DROP_SITE_CDASH|DROP_SITE_PASSWORD|DROP_SITE_USER|EXTRA_COVERAGE_GLOB|GIT_COMMAND|GIT_INIT_SUBMODULES|GIT_UPDATE_CUSTOM|GIT_UPDATE_OPTIONS|HG_COMMAND|HG_UPDATE_OPTIONS|LABELS_FOR_SUBPROJECTS|MEMORYCHECK_(?:COMMAND|COMMAND_OPTIONS|SANITIZER_OPTIONS|SUPPRESSIONS_FILE|TYPE)|NIGHTLY_START_TIME|P4_CLIENT|P4_COMMAND|P4_OPTIONS|P4_UPDATE_OPTIONS|RUN_CURRENT_SCRIPT|SCP_COMMAND|SITE|SOURCE_DIRECTORY|SUBMIT_URL|SVN_COMMAND|SVN_OPTIONS|SVN_UPDATE_OPTIONS|TEST_LOAD|TEST_TIMEOUT|TRIGGER_SITE|UPDATE_COMMAND|UPDATE_OPTIONS|UPDATE_VERSION_ONLY|USE_LAUNCHERS)|CYGWIN|ENV|EXECUTABLE_OUTPUT_PATH|GHS-MULTI|IOS|LIBRARY_OUTPUT_PATH|MINGW|MSVC(?:10|11|12|14|60|70|71|80|90|_IDE|_TOOLSET_VERSION|_VERSION)?|MSYS|PROJECT_NAME|UNIX|WIN32|WINCE|WINDOWS_PHONE|WINDOWS_STORE|XCODE))\b/,
  "property": /\b(?:cxx_\w+|(?:ARCHIVE_OUTPUT_(?:DIRECTORY|NAME)|COMPILE_DEFINITIONS|COMPILE_PDB_NAME|COMPILE_PDB_OUTPUT_DIRECTORY|EXCLUDE_FROM_DEFAULT_BUILD|IMPORTED_(?:IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_LANGUAGES|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|NO_SONAME|OBJECTS|SONAME)|INTERPROCEDURAL_OPTIMIZATION|LIBRARY_OUTPUT_DIRECTORY|LIBRARY_OUTPUT_NAME|LINK_FLAGS|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|MAP_IMPORTED_CONFIG|OSX_ARCHITECTURES|OUTPUT_NAME|PDB_NAME|PDB_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_NAME|STATIC_LIBRARY_FLAGS|VS_CSHARP|VS_DOTNET_REFERENCEPROP|VS_DOTNET_REFERENCE|VS_GLOBAL_SECTION_POST|VS_GLOBAL_SECTION_PRE|VS_GLOBAL|XCODE_ATTRIBUTE)_\w+|\w+_(?:CLANG_TIDY|COMPILER_LAUNCHER|CPPCHECK|CPPLINT|INCLUDE_WHAT_YOU_USE|OUTPUT_NAME|POSTFIX|VISIBILITY_PRESET)|ABSTRACT|ADDITIONAL_MAKE_CLEAN_FILES|ADVANCED|ALIASED_TARGET|ALLOW_DUPLICATE_CUSTOM_TARGETS|ANDROID_(?:ANT_ADDITIONAL_OPTIONS|API|API_MIN|ARCH|ASSETS_DIRECTORIES|GUI|JAR_DEPENDENCIES|NATIVE_LIB_DEPENDENCIES|NATIVE_LIB_DIRECTORIES|PROCESS_MAX|PROGUARD|PROGUARD_CONFIG_PATH|SECURE_PROPS_PATH|SKIP_ANT_STEP|STL_TYPE)|ARCHIVE_OUTPUT_DIRECTORY|ATTACHED_FILES|ATTACHED_FILES_ON_FAIL|AUTOGEN_(?:BUILD_DIR|ORIGIN_DEPENDS|PARALLEL|SOURCE_GROUP|TARGETS_FOLDER|TARGET_DEPENDS)|AUTOMOC|AUTOMOC_(?:COMPILER_PREDEFINES|DEPEND_FILTERS|EXECUTABLE|MACRO_NAMES|MOC_OPTIONS|SOURCE_GROUP|TARGETS_FOLDER)|AUTORCC|AUTORCC_EXECUTABLE|AUTORCC_OPTIONS|AUTORCC_SOURCE_GROUP|AUTOUIC|AUTOUIC_EXECUTABLE|AUTOUIC_OPTIONS|AUTOUIC_SEARCH_PATHS|BINARY_DIR|BUILDSYSTEM_TARGETS|BUILD_RPATH|BUILD_RPATH_USE_ORIGIN|BUILD_WITH_INSTALL_NAME_DIR|BUILD_WITH_INSTALL_RPATH|BUNDLE|BUNDLE_EXTENSION|CACHE_VARIABLES|CLEAN_NO_CUSTOM|COMMON_LANGUAGE_RUNTIME|COMPATIBLE_INTERFACE_(?:BOOL|NUMBER_MAX|NUMBER_MIN|STRING)|COMPILE_(?:DEFINITIONS|FEATURES|FLAGS|OPTIONS|PDB_NAME|PDB_OUTPUT_DIRECTORY)|COST|CPACK_DESKTOP_SHORTCUTS|CPACK_NEVER_OVERWRITE|CPACK_PERMANENT|CPACK_STARTUP_SHORTCUTS|CPACK_START_MENU_SHORTCUTS|CPACK_WIX_ACL|CROSSCOMPILING_EMULATOR|CUDA_EXTENSIONS|CUDA_PTX_COMPILATION|CUDA_RESOLVE_DEVICE_SYMBOLS|CUDA_SEPARABLE_COMPILATION|CUDA_STANDARD|CUDA_STANDARD_REQUIRED|CXX_EXTENSIONS|CXX_STANDARD|CXX_STANDARD_REQUIRED|C_EXTENSIONS|C_STANDARD|C_STANDARD_REQUIRED|DEBUG_CONFIGURATIONS|DEFINE_SYMBOL|DEFINITIONS|DEPENDS|DEPLOYMENT_ADDITIONAL_FILES|DEPLOYMENT_REMOTE_DIRECTORY|DISABLED|DISABLED_FEATURES|ECLIPSE_EXTRA_CPROJECT_CONTENTS|ECLIPSE_EXTRA_NATURES|ENABLED_FEATURES|ENABLED_LANGUAGES|ENABLE_EXPORTS|ENVIRONMENT|EXCLUDE_FROM_ALL|EXCLUDE_FROM_DEFAULT_BUILD|EXPORT_NAME|EXPORT_PROPERTIES|EXTERNAL_OBJECT|EchoString|FAIL_REGULAR_EXPRESSION|FIND_LIBRARY_USE_LIB32_PATHS|FIND_LIBRARY_USE_LIB64_PATHS|FIND_LIBRARY_USE_LIBX32_PATHS|FIND_LIBRARY_USE_OPENBSD_VERSIONING|FIXTURES_CLEANUP|FIXTURES_REQUIRED|FIXTURES_SETUP|FOLDER|FRAMEWORK|Fortran_FORMAT|Fortran_MODULE_DIRECTORY|GENERATED|GENERATOR_FILE_NAME|GENERATOR_IS_MULTI_CONFIG|GHS_INTEGRITY_APP|GHS_NO_SOURCE_GROUP_FILE|GLOBAL_DEPENDS_DEBUG_MODE|GLOBAL_DEPENDS_NO_CYCLES|GNUtoMS|HAS_CXX|HEADER_FILE_ONLY|HELPSTRING|IMPLICIT_DEPENDS_INCLUDE_TRANSFORM|IMPORTED|IMPORTED_(?:COMMON_LANGUAGE_RUNTIME|CONFIGURATIONS|GLOBAL|IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_(?:LANGUAGES|LIBRARIES|MULTIPLICITY)|LOCATION|NO_SONAME|OBJECTS|SONAME)|IMPORT_PREFIX|IMPORT_SUFFIX|INCLUDE_DIRECTORIES|INCLUDE_REGULAR_EXPRESSION|INSTALL_NAME_DIR|INSTALL_RPATH|INSTALL_RPATH_USE_LINK_PATH|INTERFACE_(?:AUTOUIC_OPTIONS|COMPILE_DEFINITIONS|COMPILE_FEATURES|COMPILE_OPTIONS|INCLUDE_DIRECTORIES|LINK_DEPENDS|LINK_DIRECTORIES|LINK_LIBRARIES|LINK_OPTIONS|POSITION_INDEPENDENT_CODE|SOURCES|SYSTEM_INCLUDE_DIRECTORIES)|INTERPROCEDURAL_OPTIMIZATION|IN_TRY_COMPILE|IOS_INSTALL_COMBINED|JOB_POOLS|JOB_POOL_COMPILE|JOB_POOL_LINK|KEEP_EXTENSION|LABELS|LANGUAGE|LIBRARY_OUTPUT_DIRECTORY|LINKER_LANGUAGE|LINK_(?:DEPENDS|DEPENDS_NO_SHARED|DIRECTORIES|FLAGS|INTERFACE_LIBRARIES|INTERFACE_MULTIPLICITY|LIBRARIES|OPTIONS|SEARCH_END_STATIC|SEARCH_START_STATIC|WHAT_YOU_USE)|LISTFILE_STACK|LOCATION|MACOSX_BUNDLE|MACOSX_BUNDLE_INFO_PLIST|MACOSX_FRAMEWORK_INFO_PLIST|MACOSX_PACKAGE_LOCATION|MACOSX_RPATH|MACROS|MANUALLY_ADDED_DEPENDENCIES|MEASUREMENT|MODIFIED|NAME|NO_SONAME|NO_SYSTEM_FROM_IMPORTED|OBJECT_DEPENDS|OBJECT_OUTPUTS|OSX_ARCHITECTURES|OUTPUT_NAME|PACKAGES_FOUND|PACKAGES_NOT_FOUND|PARENT_DIRECTORY|PASS_REGULAR_EXPRESSION|PDB_NAME|PDB_OUTPUT_DIRECTORY|POSITION_INDEPENDENT_CODE|POST_INSTALL_SCRIPT|PREDEFINED_TARGETS_FOLDER|PREFIX|PRE_INSTALL_SCRIPT|PRIVATE_HEADER|PROCESSORS|PROCESSOR_AFFINITY|PROJECT_LABEL|PUBLIC_HEADER|REPORT_UNDEFINED_PROPERTIES|REQUIRED_FILES|RESOURCE|RESOURCE_LOCK|RULE_LAUNCH_COMPILE|RULE_LAUNCH_CUSTOM|RULE_LAUNCH_LINK|RULE_MESSAGES|RUNTIME_OUTPUT_DIRECTORY|RUN_SERIAL|SKIP_AUTOGEN|SKIP_AUTOMOC|SKIP_AUTORCC|SKIP_AUTOUIC|SKIP_BUILD_RPATH|SKIP_RETURN_CODE|SOURCES|SOURCE_DIR|SOVERSION|STATIC_LIBRARY_FLAGS|STATIC_LIBRARY_OPTIONS|STRINGS|SUBDIRECTORIES|SUFFIX|SYMBOLIC|TARGET_ARCHIVES_MAY_BE_SHARED_LIBS|TARGET_MESSAGES|TARGET_SUPPORTS_SHARED_LIBS|TESTS|TEST_INCLUDE_FILE|TEST_INCLUDE_FILES|TIMEOUT|TIMEOUT_AFTER_MATCH|TYPE|USE_FOLDERS|VALUE|VARIABLES|VERSION|VISIBILITY_INLINES_HIDDEN|VS_(?:CONFIGURATION_TYPE|COPY_TO_OUT_DIR|DEBUGGER_(?:COMMAND|COMMAND_ARGUMENTS|ENVIRONMENT|WORKING_DIRECTORY)|DEPLOYMENT_CONTENT|DEPLOYMENT_LOCATION|DOTNET_REFERENCES|DOTNET_REFERENCES_COPY_LOCAL|INCLUDE_IN_VSIX|IOT_STARTUP_TASK|KEYWORD|RESOURCE_GENERATOR|SCC_AUXPATH|SCC_LOCALPATH|SCC_PROJECTNAME|SCC_PROVIDER|SDK_REFERENCES|SHADER_(?:DISABLE_OPTIMIZATIONS|ENABLE_DEBUG|ENTRYPOINT|FLAGS|MODEL|OBJECT_FILE_NAME|OUTPUT_HEADER_FILE|TYPE|VARIABLE_NAME)|STARTUP_PROJECT|TOOL_OVERRIDE|USER_PROPS|WINRT_COMPONENT|WINRT_EXTENSIONS|WINRT_REFERENCES|XAML_TYPE)|WILL_FAIL|WIN32_EXECUTABLE|WINDOWS_EXPORT_ALL_SYMBOLS|WORKING_DIRECTORY|WRAP_EXCLUDE|XCODE_(?:EMIT_EFFECTIVE_PLATFORM_NAME|EXPLICIT_FILE_TYPE|FILE_ATTRIBUTES|LAST_KNOWN_FILE_TYPE|PRODUCT_TYPE|SCHEME_(?:ADDRESS_SANITIZER|ADDRESS_SANITIZER_USE_AFTER_RETURN|ARGUMENTS|DISABLE_MAIN_THREAD_CHECKER|DYNAMIC_LIBRARY_LOADS|DYNAMIC_LINKER_API_USAGE|ENVIRONMENT|EXECUTABLE|GUARD_MALLOC|MAIN_THREAD_CHECKER_STOP|MALLOC_GUARD_EDGES|MALLOC_SCRIBBLE|MALLOC_STACK|THREAD_SANITIZER(?:_STOP)?|UNDEFINED_BEHAVIOUR_SANITIZER(?:_STOP)?|ZOMBIE_OBJECTS))|XCTEST)\b/,
  "keyword": /\b(?:add_compile_definitions|add_compile_options|add_custom_command|add_custom_target|add_definitions|add_dependencies|add_executable|add_library|add_link_options|add_subdirectory|add_test|aux_source_directory|break|build_command|build_name|cmake_host_system_information|cmake_minimum_required|cmake_parse_arguments|cmake_policy|configure_file|continue|create_test_sourcelist|ctest_build|ctest_configure|ctest_coverage|ctest_empty_binary_directory|ctest_memcheck|ctest_read_custom_files|ctest_run_script|ctest_sleep|ctest_start|ctest_submit|ctest_test|ctest_update|ctest_upload|define_property|else|elseif|enable_language|enable_testing|endforeach|endfunction|endif|endmacro|endwhile|exec_program|execute_process|export|export_library_dependencies|file|find_file|find_library|find_package|find_path|find_program|fltk_wrap_ui|foreach|function|get_cmake_property|get_directory_property|get_filename_component|get_property|get_source_file_property|get_target_property|get_test_property|if|include|include_directories|include_external_msproject|include_guard|include_regular_expression|install|install_files|install_programs|install_targets|link_directories|link_libraries|list|load_cache|load_command|macro|make_directory|mark_as_advanced|math|message|option|output_required_files|project|qt_wrap_cpp|qt_wrap_ui|remove|remove_definitions|return|separate_arguments|set|set_directory_properties|set_property|set_source_files_properties|set_target_properties|set_tests_properties|site_name|source_group|string|subdir_depends|subdirs|target_compile_definitions|target_compile_features|target_compile_options|target_include_directories|target_link_directories|target_link_libraries|target_link_options|target_sources|try_compile|try_run|unset|use_mangled_mesa|utility_source|variable_requires|variable_watch|while|write_file)(?=\s*\()\b/,
  "boolean": /\b(?:FALSE|OFF|ON|TRUE)\b/,
  "namespace": /\b(?:INTERFACE|PRIVATE|PROPERTIES|PUBLIC|SHARED|STATIC|TARGET_OBJECTS)\b/,
  "operator": /\b(?:AND|DEFINED|EQUAL|GREATER|LESS|MATCHES|NOT|OR|STREQUAL|STRGREATER|STRLESS|VERSION_EQUAL|VERSION_GREATER|VERSION_LESS)\b/,
  "inserted": {
    pattern: /\b\w+::\w+\b/,
    alias: "class-name"
  },
  "number": /\b\d+(?:\.\d+)*\b/,
  "function": /\b[a-z_]\w*(?=\s*\()\b/i,
  "punctuation": /[()>}]|\$[<{]/
};
(function(Prism2) {
  var comment = /#(?!\{).+/;
  var interpolation = {
    pattern: /#\{[^}]+\}/,
    alias: "variable"
  };
  Prism2.languages.coffeescript = Prism2.languages.extend("javascript", {
    "comment": comment,
    "string": [
      // Strings are multiline
      {
        pattern: /'(?:\\[\s\S]|[^\\'])*'/,
        greedy: true
      },
      {
        // Strings are multiline
        pattern: /"(?:\\[\s\S]|[^\\"])*"/,
        greedy: true,
        inside: {
          "interpolation": interpolation
        }
      }
    ],
    "keyword": /\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
    "class-member": {
      pattern: /@(?!\d)\w+/,
      alias: "variable"
    }
  });
  Prism2.languages.insertBefore("coffeescript", "comment", {
    "multiline-comment": {
      pattern: /###[\s\S]+?###/,
      alias: "comment"
    },
    // Block regexp can contain comments and interpolation
    "block-regex": {
      pattern: /\/{3}[\s\S]*?\/{3}/,
      alias: "regex",
      inside: {
        "comment": comment,
        "interpolation": interpolation
      }
    }
  });
  Prism2.languages.insertBefore("coffeescript", "string", {
    "inline-javascript": {
      pattern: /`(?:\\[\s\S]|[^\\`])*`/,
      inside: {
        "delimiter": {
          pattern: /^`|`$/,
          alias: "punctuation"
        },
        "script": {
          pattern: /[\s\S]+/,
          alias: "language-javascript",
          inside: Prism2.languages.javascript
        }
      }
    },
    // Block strings
    "multiline-string": [
      {
        pattern: /'''[\s\S]*?'''/,
        greedy: true,
        alias: "string"
      },
      {
        pattern: /"""[\s\S]*?"""/,
        greedy: true,
        alias: "string",
        inside: {
          interpolation
        }
      }
    ]
  });
  Prism2.languages.insertBefore("coffeescript", "keyword", {
    // Object property
    "property": /(?!\d)\w+(?=\s*:(?!:))/
  });
  delete Prism2.languages.coffeescript["template-string"];
  Prism2.languages.coffee = Prism2.languages.coffeescript;
})(Prism);
(function(Prism2) {
  var keyword = /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
  var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(/<keyword>/g, function() {
    return keyword.source;
  });
  Prism2.languages.cpp = Prism2.languages.extend("c", {
    "class-name": [
      {
        pattern: RegExp(/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(/<keyword>/g, function() {
          return keyword.source;
        })),
        lookbehind: true
      },
      // This is intended to capture the class name of method implementations like:
      //   void foo::bar() const {}
      // However! The `foo` in the above example could also be a namespace, so we only capture the class name if
      // it starts with an uppercase letter. This approximation should give decent results.
      /\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
      // This will capture the class name before destructors like:
      //   Foo::~Foo() {}
      /\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
      // This also intends to capture the class name of method implementations but here the class has template
      // parameters, so it can't be a namespace (until C++ adds generic namespaces).
      /\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
    ],
    "keyword": keyword,
    "number": {
      pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
      greedy: true
    },
    "operator": />>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
    "boolean": /\b(?:false|true)\b/
  });
  Prism2.languages.insertBefore("cpp", "string", {
    "module": {
      // https://en.cppreference.com/w/cpp/language/modules
      pattern: RegExp(
        /(\b(?:import|module)\s+)/.source + "(?:" + // header-name
        /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source + "|" + // module name or partition or both
        /<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(/<mod-name>/g, function() {
          return modName;
        }) + ")"
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "string": /^[<"][\s\S]+/,
        "operator": /:/,
        "punctuation": /\./
      }
    },
    "raw-string": {
      pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
      alias: "string",
      greedy: true
    }
  });
  Prism2.languages.insertBefore("cpp", "keyword", {
    "generic-function": {
      pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
      inside: {
        "function": /^\w+/,
        "generic": {
          pattern: /<[\s\S]+/,
          alias: "class-name",
          inside: Prism2.languages.cpp
        }
      }
    }
  });
  Prism2.languages.insertBefore("cpp", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  });
  Prism2.languages.insertBefore("cpp", "class-name", {
    // the base clause is an optional list of parent classes
    // https://en.cppreference.com/w/cpp/language/class
    "base-clause": {
      pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
      lookbehind: true,
      greedy: true,
      inside: Prism2.languages.extend("cpp", {})
    }
  });
  Prism2.languages.insertBefore("inside", "double-colon", {
    // All untokenized words that are not namespaces should be class names
    "class-name": /\b[a-z_]\w*\b(?!\s*::)/i
  }, Prism2.languages.cpp["base-clause"]);
})(Prism);
(function(Prism2) {
  function replace(pattern, replacements) {
    return pattern.replace(/<<(\d+)>>/g, function(m10, index2) {
      return "(?:" + replacements[+index2] + ")";
    });
  }
  function re6(pattern, replacements, flags) {
    return RegExp(replace(pattern, replacements), flags || "");
  }
  function nested(pattern, depthLog2) {
    for (var i15 = 0; i15 < depthLog2; i15++) {
      pattern = pattern.replace(/<<self>>/g, function() {
        return "(?:" + pattern + ")";
      });
    }
    return pattern.replace(/<<self>>/g, "[^\\s\\S]");
  }
  var keywordKinds = {
    // keywords which represent a return or variable type
    type: "bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void",
    // keywords which are used to declare a type
    typeDeclaration: "class enum interface record struct",
    // contextual keywords
    // ("var" and "dynamic" are missing because they are used like types)
    contextual: "add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)",
    // all other keywords
    other: "abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield"
  };
  function keywordsToPattern(words) {
    return "\\b(?:" + words.trim().replace(/ /g, "|") + ")\\b";
  }
  var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);
  var keywords = RegExp(keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other));
  var nonTypeKeywords = keywordsToPattern(keywordKinds.typeDeclaration + " " + keywordKinds.contextual + " " + keywordKinds.other);
  var nonContextualKeywords = keywordsToPattern(keywordKinds.type + " " + keywordKinds.typeDeclaration + " " + keywordKinds.other);
  var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2);
  var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
  var name2 = /@?\b[A-Za-z_]\w*\b/.source;
  var genericName = replace(/<<0>>(?:\s*<<1>>)?/.source, [name2, generic]);
  var identifier = replace(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [nonTypeKeywords, genericName]);
  var array2 = /\[\s*(?:,\s*)*\]/.source;
  var typeExpressionWithoutTuple = replace(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [identifier, array2]);
  var tupleElement = replace(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [generic, nestedRound, array2]);
  var tuple = replace(/\(<<0>>+(?:,<<0>>+)+\)/.source, [tupleElement]);
  var typeExpression = replace(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [tuple, identifier, array2]);
  var typeInside = {
    "keyword": keywords,
    "punctuation": /[<>()?,.:[\]]/
  };
  var character = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source;
  var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
  var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
  Prism2.languages.csharp = Prism2.languages.extend("clike", {
    "string": [
      {
        pattern: re6(/(^|[^$\\])<<0>>/.source, [verbatimString]),
        lookbehind: true,
        greedy: true
      },
      {
        pattern: re6(/(^|[^@$\\])<<0>>/.source, [regularString]),
        lookbehind: true,
        greedy: true
      }
    ],
    "class-name": [
      {
        // Using static
        // using static System.Math;
        pattern: re6(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [identifier]),
        lookbehind: true,
        inside: typeInside
      },
      {
        // Using alias (type)
        // using Project = PC.MyCompany.Project;
        pattern: re6(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [name2, typeExpression]),
        lookbehind: true,
        inside: typeInside
      },
      {
        // Using alias (alias)
        // using Project = PC.MyCompany.Project;
        pattern: re6(/(\busing\s+)<<0>>(?=\s*=)/.source, [name2]),
        lookbehind: true
      },
      {
        // Type declarations
        // class Foo<A, B>
        // interface Foo<out A, B>
        pattern: re6(/(\b<<0>>\s+)<<1>>/.source, [typeDeclarationKeywords, genericName]),
        lookbehind: true,
        inside: typeInside
      },
      {
        // Single catch exception declaration
        // catch(Foo)
        // (things like catch(Foo e) is covered by variable declaration)
        pattern: re6(/(\bcatch\s*\(\s*)<<0>>/.source, [identifier]),
        lookbehind: true,
        inside: typeInside
      },
      {
        // Name of the type parameter of generic constraints
        // where Foo : class
        pattern: re6(/(\bwhere\s+)<<0>>/.source, [name2]),
        lookbehind: true
      },
      {
        // Casts and checks via as and is.
        // as Foo<A>, is Bar<B>
        // (things like if(a is Foo b) is covered by variable declaration)
        pattern: re6(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [typeExpressionWithoutTuple]),
        lookbehind: true,
        inside: typeInside
      },
      {
        // Variable, field and parameter declaration
        // (Foo bar, Bar baz, Foo[,,] bay, Foo<Bar, FooBar<Bar>> bax)
        pattern: re6(/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source, [typeExpression, nonContextualKeywords, name2]),
        inside: typeInside
      }
    ],
    "keyword": keywords,
    // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#literals
    "number": /(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
    "operator": />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
    "punctuation": /\?\.?|::|[{}[\];(),.:]/
  });
  Prism2.languages.insertBefore("csharp", "number", {
    "range": {
      pattern: /\.\./,
      alias: "operator"
    }
  });
  Prism2.languages.insertBefore("csharp", "punctuation", {
    "named-parameter": {
      pattern: re6(/([(,]\s*)<<0>>(?=\s*:)/.source, [name2]),
      lookbehind: true,
      alias: "punctuation"
    }
  });
  Prism2.languages.insertBefore("csharp", "class-name", {
    "namespace": {
      // namespace Foo.Bar {}
      // using Foo.Bar;
      pattern: re6(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [name2]),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    },
    "type-expression": {
      // default(Foo), typeof(Foo<Bar>), sizeof(int)
      pattern: re6(/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/.source, [nestedRound]),
      lookbehind: true,
      alias: "class-name",
      inside: typeInside
    },
    "return-type": {
      // Foo<Bar> ForBar(); Foo IFoo.Bar() => 0
      // int this[int index] => 0; T IReadOnlyList<T>.this[int index] => this[index];
      // int Foo => 0; int Foo { get; set } = 0;
      pattern: re6(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [typeExpression, identifier]),
      inside: typeInside,
      alias: "class-name"
    },
    "constructor-invocation": {
      // new List<Foo<Bar[]>> { }
      pattern: re6(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [typeExpression]),
      lookbehind: true,
      inside: typeInside,
      alias: "class-name"
    },
    /*'explicit-implementation': {
    	// int IFoo<Foo>.Bar => 0; void IFoo<Foo<Foo>>.Foo<T>();
    	pattern: replace(/\b<<0>>(?=\.<<1>>)/, className, methodOrPropertyDeclaration),
    	inside: classNameInside,
    	alias: 'class-name'
    },*/
    "generic-method": {
      // foo<Bar>()
      pattern: re6(/<<0>>\s*<<1>>(?=\s*\()/.source, [name2, generic]),
      inside: {
        "function": re6(/^<<0>>/.source, [name2]),
        "generic": {
          pattern: RegExp(generic),
          alias: "class-name",
          inside: typeInside
        }
      }
    },
    "type-list": {
      // The list of types inherited or of generic constraints
      // class Foo<F> : Bar, IList<FooBar>
      // where F : Bar, IList<int>
      pattern: re6(
        /\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/.source,
        [typeDeclarationKeywords, genericName, name2, typeExpression, keywords.source, nestedRound, /\bnew\s*\(\s*\)/.source]
      ),
      lookbehind: true,
      inside: {
        "record-arguments": {
          pattern: re6(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [genericName, nestedRound]),
          lookbehind: true,
          greedy: true,
          inside: Prism2.languages.csharp
        },
        "keyword": keywords,
        "class-name": {
          pattern: RegExp(typeExpression),
          greedy: true,
          inside: typeInside
        },
        "punctuation": /[,()]/
      }
    },
    "preprocessor": {
      pattern: /(^[\t ]*)#.*/m,
      lookbehind: true,
      alias: "property",
      inside: {
        // highlight preprocessor directives as keywords
        "directive": {
          pattern: /(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
          lookbehind: true,
          alias: "keyword"
        }
      }
    }
  });
  var regularStringOrCharacter = regularString + "|" + character;
  var regularStringCharacterOrComment = replace(/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source, [regularStringOrCharacter]);
  var roundExpression = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
  var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/.source;
  var attr = replace(/<<0>>(?:\s*\(<<1>>*\))?/.source, [identifier, roundExpression]);
  Prism2.languages.insertBefore("csharp", "class-name", {
    "attribute": {
      // Attributes
      // [Foo], [Foo(1), Bar(2, Prop = "foo")], [return: Foo(1), Bar(2)], [assembly: Foo(Bar)]
      pattern: re6(/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source, [attrTarget, attr]),
      lookbehind: true,
      greedy: true,
      inside: {
        "target": {
          pattern: re6(/^<<0>>(?=\s*:)/.source, [attrTarget]),
          alias: "keyword"
        },
        "attribute-arguments": {
          pattern: re6(/\(<<0>>*\)/.source, [roundExpression]),
          inside: Prism2.languages.csharp
        },
        "class-name": {
          pattern: RegExp(identifier),
          inside: {
            "punctuation": /\./
          }
        },
        "punctuation": /[:,]/
      }
    }
  });
  var formatString = /:[^}\r\n]+/.source;
  var mInterpolationRound = nested(replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]), 2);
  var mInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [mInterpolationRound, formatString]);
  var sInterpolationRound = nested(replace(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [regularStringOrCharacter]), 2);
  var sInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [sInterpolationRound, formatString]);
  function createInterpolationInside(interpolation, interpolationRound) {
    return {
      "interpolation": {
        pattern: re6(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [interpolation]),
        lookbehind: true,
        inside: {
          "format-string": {
            pattern: re6(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [interpolationRound, formatString]),
            lookbehind: true,
            inside: {
              "punctuation": /^:/
            }
          },
          "punctuation": /^\{|\}$/,
          "expression": {
            pattern: /[\s\S]+/,
            alias: "language-csharp",
            inside: Prism2.languages.csharp
          }
        }
      },
      "string": /[\s\S]+/
    };
  }
  Prism2.languages.insertBefore("csharp", "string", {
    "interpolation-string": [
      {
        pattern: re6(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [mInterpolation]),
        lookbehind: true,
        greedy: true,
        inside: createInterpolationInside(mInterpolation, mInterpolationRound)
      },
      {
        pattern: re6(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [sInterpolation]),
        lookbehind: true,
        greedy: true,
        inside: createInterpolationInside(sInterpolation, sInterpolationRound)
      }
    ],
    "char": {
      pattern: RegExp(character),
      greedy: true
    }
  });
  Prism2.languages.dotnet = Prism2.languages.cs = Prism2.languages.csharp;
})(Prism);
(function(Prism2) {
  var string2 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
  Prism2.languages.css = {
    "comment": /\/\*[\s\S]*?\*\//,
    "atrule": {
      pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
      inside: {
        "rule": /^@[\w-]+/,
        "selector-function-argument": {
          pattern: /(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
          lookbehind: true,
          alias: "selector"
        },
        "keyword": {
          pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
          lookbehind: true
        }
        // See rest below
      }
    },
    "url": {
      // https://drafts.csswg.org/css-values-3/#urls
      pattern: RegExp("\\burl\\((?:" + string2.source + "|" + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ")\\)", "i"),
      greedy: true,
      inside: {
        "function": /^url/i,
        "punctuation": /^\(|\)$/,
        "string": {
          pattern: RegExp("^" + string2.source + "$"),
          alias: "url"
        }
      }
    },
    "selector": {
      pattern: RegExp(`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string2.source + ")*(?=\\s*\\{)"),
      lookbehind: true
    },
    "string": {
      pattern: string2,
      greedy: true
    },
    "property": {
      pattern: /(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
      lookbehind: true
    },
    "important": /!important\b/i,
    "function": {
      pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
      lookbehind: true
    },
    "punctuation": /[(){};:,]/
  };
  Prism2.languages.css["atrule"].inside.rest = Prism2.languages.css;
  var markup = Prism2.languages.markup;
  if (markup) {
    markup.tag.addInlined("style", "css");
    markup.tag.addAttribute("style", "css");
  }
})(Prism);
(function(Prism2) {
  var keywords = [
    /\b(?:async|sync|yield)\*/,
    /\b(?:abstract|assert|async|await|break|case|catch|class|const|continue|covariant|default|deferred|do|dynamic|else|enum|export|extends|extension|external|factory|final|finally|for|get|hide|if|implements|import|in|interface|library|mixin|new|null|on|operator|part|rethrow|return|set|show|static|super|switch|sync|this|throw|try|typedef|var|void|while|with|yield)\b/
  ];
  var packagePrefix = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
  var className = {
    pattern: RegExp(packagePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
    lookbehind: true,
    inside: {
      "namespace": {
        pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
        inside: {
          "punctuation": /\./
        }
      }
    }
  };
  Prism2.languages.dart = Prism2.languages.extend("clike", {
    "class-name": [
      className,
      {
        // variables and parameters
        // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
        pattern: RegExp(packagePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source),
        lookbehind: true,
        inside: className.inside
      }
    ],
    "keyword": keywords,
    "operator": /\bis!|\b(?:as|is)\b|\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?/
  });
  Prism2.languages.insertBefore("dart", "string", {
    "string-literal": {
      pattern: /r?(?:("""|''')[\s\S]*?\1|(["'])(?:\\.|(?!\2)[^\\\r\n])*\2(?!\2))/,
      greedy: true,
      inside: {
        "interpolation": {
          pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
          lookbehind: true,
          inside: {
            "punctuation": /^\$\{?|\}$/,
            "expression": {
              pattern: /[\s\S]+/,
              inside: Prism2.languages.dart
            }
          }
        },
        "string": /[\s\S]+/
      }
    },
    "string": void 0
  });
  Prism2.languages.insertBefore("dart", "class-name", {
    "metadata": {
      pattern: /@\w+/,
      alias: "function"
    }
  });
  Prism2.languages.insertBefore("dart", "class-name", {
    "generics": {
      pattern: /<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<[\w\s,.&?]*>)*>)*>)*>/,
      inside: {
        "class-name": className,
        "keyword": keywords,
        "punctuation": /[<>(),.:]/,
        "operator": /[?&|]/
      }
    }
  });
})(Prism);
(function(Prism2) {
  Prism2.languages.django = {
    "comment": /^\{#[\s\S]*?#\}$/,
    "tag": {
      pattern: /(^\{%[+-]?\s*)\w+/,
      lookbehind: true,
      alias: "keyword"
    },
    "delimiter": {
      pattern: /^\{[{%][+-]?|[+-]?[}%]\}$/,
      alias: "punctuation"
    },
    "string": {
      pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
      greedy: true
    },
    "filter": {
      pattern: /(\|)\w+/,
      lookbehind: true,
      alias: "function"
    },
    "test": {
      pattern: /(\bis\s+(?:not\s+)?)(?!not\b)\w+/,
      lookbehind: true,
      alias: "function"
    },
    "function": /\b[a-z_]\w+(?=\s*\()/i,
    "keyword": /\b(?:and|as|by|else|for|if|import|in|is|loop|not|or|recursive|with|without)\b/,
    "operator": /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
    "number": /\b\d+(?:\.\d+)?\b/,
    "boolean": /[Ff]alse|[Nn]one|[Tt]rue/,
    "variable": /\b\w+\b/,
    "punctuation": /[{}[\](),.:;]/
  };
  var pattern = /\{\{[\s\S]*?\}\}|\{%[\s\S]*?%\}|\{#[\s\S]*?#\}/g;
  var markupTemplating = Prism2.languages["markup-templating"];
  Prism2.hooks.add("before-tokenize", function(env) {
    markupTemplating.buildPlaceholders(env, "django", pattern);
  });
  Prism2.hooks.add("after-tokenize", function(env) {
    markupTemplating.tokenizePlaceholders(env, "django");
  });
  Prism2.languages.jinja2 = Prism2.languages.django;
  Prism2.hooks.add("before-tokenize", function(env) {
    markupTemplating.buildPlaceholders(env, "jinja2", pattern);
  });
  Prism2.hooks.add("after-tokenize", function(env) {
    markupTemplating.tokenizePlaceholders(env, "jinja2");
  });
})(Prism);
(function(Prism2) {
  var spaceAfterBackSlash = /\\[\r\n](?:\s|\\[\r\n]|#.*(?!.))*(?![\s#]|\\[\r\n])/.source;
  var space2 = /(?:[ \t]+(?![ \t])(?:<SP_BS>)?|<SP_BS>)/.source.replace(/<SP_BS>/g, function() {
    return spaceAfterBackSlash;
  });
  var string2 = /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"|'(?:[^'\\\r\n]|\\(?:\r\n|[\s\S]))*'/.source;
  var option = /--[\w-]+=(?:<STR>|(?!["'])(?:[^\s\\]|\\.)+)/.source.replace(/<STR>/g, function() {
    return string2;
  });
  var stringRule = {
    pattern: RegExp(string2),
    greedy: true
  };
  var commentRule = {
    pattern: /(^[ \t]*)#.*/m,
    lookbehind: true,
    greedy: true
  };
  function re6(source, flags) {
    source = source.replace(/<OPT>/g, function() {
      return option;
    }).replace(/<SP>/g, function() {
      return space2;
    });
    return RegExp(source, flags);
  }
  Prism2.languages.docker = {
    "instruction": {
      pattern: /(^[ \t]*)(?:ADD|ARG|CMD|COPY|ENTRYPOINT|ENV|EXPOSE|FROM|HEALTHCHECK|LABEL|MAINTAINER|ONBUILD|RUN|SHELL|STOPSIGNAL|USER|VOLUME|WORKDIR)(?=\s)(?:\\.|[^\r\n\\])*(?:\\$(?:\s|#.*$)*(?![\s#])(?:\\.|[^\r\n\\])*)*/im,
      lookbehind: true,
      greedy: true,
      inside: {
        "options": {
          pattern: re6(/(^(?:ONBUILD<SP>)?\w+<SP>)<OPT>(?:<SP><OPT>)*/.source, "i"),
          lookbehind: true,
          greedy: true,
          inside: {
            "property": {
              pattern: /(^|\s)--[\w-]+/,
              lookbehind: true
            },
            "string": [
              stringRule,
              {
                pattern: /(=)(?!["'])(?:[^\s\\]|\\.)+/,
                lookbehind: true
              }
            ],
            "operator": /\\$/m,
            "punctuation": /=/
          }
        },
        "keyword": [
          {
            // https://docs.docker.com/engine/reference/builder/#healthcheck
            pattern: re6(/(^(?:ONBUILD<SP>)?HEALTHCHECK<SP>(?:<OPT><SP>)*)(?:CMD|NONE)\b/.source, "i"),
            lookbehind: true,
            greedy: true
          },
          {
            // https://docs.docker.com/engine/reference/builder/#from
            pattern: re6(/(^(?:ONBUILD<SP>)?FROM<SP>(?:<OPT><SP>)*(?!--)[^ \t\\]+<SP>)AS/.source, "i"),
            lookbehind: true,
            greedy: true
          },
          {
            // https://docs.docker.com/engine/reference/builder/#onbuild
            pattern: re6(/(^ONBUILD<SP>)\w+/.source, "i"),
            lookbehind: true,
            greedy: true
          },
          {
            pattern: /^\w+/,
            greedy: true
          }
        ],
        "comment": commentRule,
        "string": stringRule,
        "variable": /\$(?:\w+|\{[^{}"'\\]*\})/,
        "operator": /\\$/m
      }
    },
    "comment": commentRule
  };
  Prism2.languages.dockerfile = Prism2.languages.docker;
})(Prism);
(function(Prism2) {
  Prism2.languages.ejs = {
    "delimiter": {
      pattern: /^<%[-_=]?|[-_]?%>$/,
      alias: "punctuation"
    },
    "comment": /^#[\s\S]*/,
    "language-javascript": {
      pattern: /[\s\S]+/,
      inside: Prism2.languages.javascript
    }
  };
  Prism2.hooks.add("before-tokenize", function(env) {
    var ejsPattern = /<%(?!%)[\s\S]+?%>/g;
    Prism2.languages["markup-templating"].buildPlaceholders(env, "ejs", ejsPattern);
  });
  Prism2.hooks.add("after-tokenize", function(env) {
    Prism2.languages["markup-templating"].tokenizePlaceholders(env, "ejs");
  });
  Prism2.languages.eta = Prism2.languages.ejs;
})(Prism);
Prism.languages.erlang = {
  "comment": /%.+/,
  "string": {
    pattern: /"(?:\\.|[^\\"\r\n])*"/,
    greedy: true
  },
  "quoted-function": {
    pattern: /'(?:\\.|[^\\'\r\n])+'(?=\()/,
    alias: "function"
  },
  "quoted-atom": {
    pattern: /'(?:\\.|[^\\'\r\n])+'/,
    alias: "atom"
  },
  "boolean": /\b(?:false|true)\b/,
  "keyword": /\b(?:after|begin|case|catch|end|fun|if|of|receive|try|when)\b/,
  "number": [
    /\$\\?./,
    /\b\d+#[a-z0-9]+/i,
    /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i
  ],
  "function": /\b[a-z][\w@]*(?=\()/,
  "variable": {
    // Look-behind is used to prevent wrong highlighting of atoms containing "@"
    pattern: /(^|[^@])(?:\b|\?)[A-Z_][\w@]*/,
    lookbehind: true
  },
  "operator": [
    /[=\/<>:]=|=[:\/]=|\+\+?|--?|[=*\/!]|\b(?:and|andalso|band|bnot|bor|bsl|bsr|bxor|div|not|or|orelse|rem|xor)\b/,
    {
      // We don't want to match <<
      pattern: /(^|[^<])<(?!<)/,
      lookbehind: true
    },
    {
      // We don't want to match >>
      pattern: /(^|[^>])>(?!>)/,
      lookbehind: true
    }
  ],
  "atom": /\b[a-z][\w@]*/,
  "punctuation": /[()[\]{}:;,.#|]|<<|>>/
};
Prism.languages.git = {
  /*
   * A simple one line comment like in a git status command
   * For instance:
   * $ git status
   * # On branch infinite-scroll
   * # Your branch and 'origin/sharedBranches/frontendTeam/infinite-scroll' have diverged,
   * # and have 1 and 2 different commits each, respectively.
   * nothing to commit (working directory clean)
   */
  "comment": /^#.*/m,
  /*
   * Regexp to match the changed lines in a git diff output. Check the example below.
   */
  "deleted": /^[-–].*/m,
  "inserted": /^\+.*/m,
  /*
   * a string (double and simple quote)
   */
  "string": /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
  /*
   * a git command. It starts with a random prompt finishing by a $, then "git" then some other parameters
   * For instance:
   * $ git add file.txt
   */
  "command": {
    pattern: /^.*\$ git .*$/m,
    inside: {
      /*
       * A git command can contain a parameter starting by a single or a double dash followed by a string
       * For instance:
       * $ git diff --cached
       * $ git log -p
       */
      "parameter": /\s--?\w+/
    }
  },
  /*
   * Coordinates displayed in a git diff command
   * For instance:
   * $ git diff
   * diff --git file.txt file.txt
   * index 6214953..1d54a52 100644
   * --- file.txt
   * +++ file.txt
   * @@ -1 +1,2 @@
   * -Here's my tetx file
   * +Here's my text file
   * +And this is the second line
   */
  "coord": /^@@.*@@$/m,
  /*
   * Match a "commit [SHA1]" line in a git log output.
   * For instance:
   * $ git log
   * commit a11a14ef7e26f2ca62d4b35eac455ce636d0dc09
   * Author: lgiraudel
   * Date:   Mon Feb 17 11:18:34 2014 +0100
   *
   *     Add of a new line
   */
  "commit-sha1": /^commit \w{40}$/m
};
Prism.languages.go = Prism.languages.extend("clike", {
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
    lookbehind: true,
    greedy: true
  },
  "keyword": /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
  "boolean": /\b(?:_|false|iota|nil|true)\b/,
  "number": [
    // binary and octal integers
    /\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
    // hexadecimal integers and floats
    /\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
    // decimal integers and floats
    /(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
  ],
  "operator": /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
  "builtin": /\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
});
Prism.languages.insertBefore("go", "string", {
  "char": {
    pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
    greedy: true
  }
});
delete Prism.languages.go["class-name"];
Prism.languages.graphql = {
  "comment": /#.*/,
  "description": {
    pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i,
    greedy: true,
    alias: "string",
    inside: {
      "language-markdown": {
        pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/,
        lookbehind: true,
        inside: Prism.languages.markdown
      }
    }
  },
  "string": {
    pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/,
    greedy: true
  },
  "number": /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  "boolean": /\b(?:false|true)\b/,
  "variable": /\$[a-z_]\w*/i,
  "directive": {
    pattern: /@[a-z_]\w*/i,
    alias: "function"
  },
  "attr-name": {
    pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i,
    greedy: true
  },
  "atom-input": {
    pattern: /\b[A-Z]\w*Input\b/,
    alias: "class-name"
  },
  "scalar": /\b(?:Boolean|Float|ID|Int|String)\b/,
  "constant": /\b[A-Z][A-Z_\d]*\b/,
  "class-name": {
    pattern: /(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/,
    lookbehind: true
  },
  "fragment": {
    pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/,
    lookbehind: true,
    alias: "function"
  },
  "definition-mutation": {
    pattern: /(\bmutation\s+)[a-zA-Z_]\w*/,
    lookbehind: true,
    alias: "function"
  },
  "definition-query": {
    pattern: /(\bquery\s+)[a-zA-Z_]\w*/,
    lookbehind: true,
    alias: "function"
  },
  "keyword": /\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,
  "operator": /[!=|&]|\.{3}/,
  "property-query": /\w+(?=\s*\()/,
  "object": /\w+(?=\s*\{)/,
  "punctuation": /[!(){}\[\]:=,]/,
  "property": /\w+/
};
Prism.hooks.add("after-tokenize", function afterTokenizeGraphql(env) {
  if (env.language !== "graphql") {
    return;
  }
  var validTokens = env.tokens.filter(function(token2) {
    return typeof token2 !== "string" && token2.type !== "comment" && token2.type !== "scalar";
  });
  var currentIndex = 0;
  function getToken(offset5) {
    return validTokens[currentIndex + offset5];
  }
  function isTokenType(types, offset5) {
    offset5 = offset5 || 0;
    for (var i16 = 0; i16 < types.length; i16++) {
      var token2 = getToken(i16 + offset5);
      if (!token2 || token2.type !== types[i16]) {
        return false;
      }
    }
    return true;
  }
  function findClosingBracket(open, close2) {
    var stackHeight = 1;
    for (var i16 = currentIndex; i16 < validTokens.length; i16++) {
      var token2 = validTokens[i16];
      var content = token2.content;
      if (token2.type === "punctuation" && typeof content === "string") {
        if (open.test(content)) {
          stackHeight++;
        } else if (close2.test(content)) {
          stackHeight--;
          if (stackHeight === 0) {
            return i16;
          }
        }
      }
    }
    return -1;
  }
  function addAlias(token2, alias) {
    var aliases2 = token2.alias;
    if (!aliases2) {
      token2.alias = aliases2 = [];
    } else if (!Array.isArray(aliases2)) {
      token2.alias = aliases2 = [aliases2];
    }
    aliases2.push(alias);
  }
  for (; currentIndex < validTokens.length; ) {
    var startToken = validTokens[currentIndex++];
    if (startToken.type === "keyword" && startToken.content === "mutation") {
      var inputVariables = [];
      if (isTokenType(["definition-mutation", "punctuation"]) && getToken(1).content === "(") {
        currentIndex += 2;
        var definitionEnd = findClosingBracket(/^\($/, /^\)$/);
        if (definitionEnd === -1) {
          continue;
        }
        for (; currentIndex < definitionEnd; currentIndex++) {
          var t20 = getToken(0);
          if (t20.type === "variable") {
            addAlias(t20, "variable-input");
            inputVariables.push(t20.content);
          }
        }
        currentIndex = definitionEnd + 1;
      }
      if (isTokenType(["punctuation", "property-query"]) && getToken(0).content === "{") {
        currentIndex++;
        addAlias(getToken(0), "property-mutation");
        if (inputVariables.length > 0) {
          var mutationEnd = findClosingBracket(/^\{$/, /^\}$/);
          if (mutationEnd === -1) {
            continue;
          }
          for (var i15 = currentIndex; i15 < mutationEnd; i15++) {
            var varToken = validTokens[i15];
            if (varToken.type === "variable" && inputVariables.indexOf(varToken.content) >= 0) {
              addAlias(varToken, "variable-input");
            }
          }
        }
      }
    }
  }
});
(function(Prism2) {
  var interpolation = {
    pattern: /((?:^|[^\\$])(?:\\{2})*)\$(?:\w+|\{[^{}]*\})/,
    lookbehind: true,
    inside: {
      "interpolation-punctuation": {
        pattern: /^\$\{?|\}$/,
        alias: "punctuation"
      },
      "expression": {
        pattern: /[\s\S]+/,
        inside: null
        // see below
      }
    }
  };
  Prism2.languages.groovy = Prism2.languages.extend("clike", {
    "string": {
      // https://groovy-lang.org/syntax.html#_dollar_slashy_string
      pattern: /'''(?:[^\\]|\\[\s\S])*?'''|'(?:\\.|[^\\'\r\n])*'/,
      greedy: true
    },
    "keyword": /\b(?:abstract|as|assert|boolean|break|byte|case|catch|char|class|const|continue|def|default|do|double|else|enum|extends|final|finally|float|for|goto|if|implements|import|in|instanceof|int|interface|long|native|new|package|private|protected|public|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|trait|transient|try|void|volatile|while)\b/,
    "number": /\b(?:0b[01_]+|0x[\da-f_]+(?:\.[\da-f_p\-]+)?|[\d_]+(?:\.[\d_]+)?(?:e[+-]?\d+)?)[glidf]?\b/i,
    "operator": {
      pattern: /(^|[^.])(?:~|==?~?|\?[.:]?|\*(?:[.=]|\*=?)?|\.[@&]|\.\.<|\.\.(?!\.)|-[-=>]?|\+[+=]?|!=?|<(?:<=?|=>?)?|>(?:>>?=?|=)?|&[&=]?|\|[|=]?|\/=?|\^=?|%=?)/,
      lookbehind: true
    },
    "punctuation": /\.+|[{}[\];(),:$]/
  });
  Prism2.languages.insertBefore("groovy", "string", {
    "shebang": {
      pattern: /#!.+/,
      alias: "comment",
      greedy: true
    },
    "interpolation-string": {
      // TODO: Slash strings (e.g. /foo/) can contain line breaks but this will cause a lot of trouble with
      // simple division (see JS regex), so find a fix maybe?
      pattern: /"""(?:[^\\]|\\[\s\S])*?"""|(["/])(?:\\.|(?!\1)[^\\\r\n])*\1|\$\/(?:[^/$]|\$(?:[/$]|(?![/$]))|\/(?!\$))*\/\$/,
      greedy: true,
      inside: {
        "interpolation": interpolation,
        "string": /[\s\S]+/
      }
    }
  });
  Prism2.languages.insertBefore("groovy", "punctuation", {
    "spock-block": /\b(?:and|cleanup|expect|given|setup|then|when|where):/
  });
  Prism2.languages.insertBefore("groovy", "function", {
    "annotation": {
      pattern: /(^|[^.])@\w+/,
      lookbehind: true,
      alias: "punctuation"
    }
  });
  interpolation.inside.expression.inside = Prism2.languages.groovy;
})(Prism);
(function(Prism2) {
  var keywords = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record(?!\s*[(){}[\]<>=%~.:,;?+\-*/&|^])|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
  var classNamePrefix = /(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
  var className = {
    pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
    lookbehind: true,
    inside: {
      "namespace": {
        pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
        inside: {
          "punctuation": /\./
        }
      },
      "punctuation": /\./
    }
  };
  Prism2.languages.java = Prism2.languages.extend("clike", {
    "string": {
      pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
      lookbehind: true,
      greedy: true
    },
    "class-name": [
      className,
      {
        // variables, parameters, and constructor references
        // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
        pattern: RegExp(/(^|[^\w.])/.source + classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()]|\s*(?:\[[\s,]*\]\s*)?::\s*new\b)/.source),
        lookbehind: true,
        inside: className.inside
      },
      {
        // class names based on keyword
        // this to support class names (or generic parameters) which do not contain a lower case letter (also works for methods)
        pattern: RegExp(/(\b(?:class|enum|extends|implements|instanceof|interface|new|record|throws)\s+)/.source + classNamePrefix + /[A-Z]\w*\b/.source),
        lookbehind: true,
        inside: className.inside
      }
    ],
    "keyword": keywords,
    "function": [
      Prism2.languages.clike.function,
      {
        pattern: /(::\s*)[a-z_]\w*/,
        lookbehind: true
      }
    ],
    "number": /\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
    "operator": {
      pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
      lookbehind: true
    }
  });
  Prism2.languages.insertBefore("java", "string", {
    "triple-quoted-string": {
      // http://openjdk.java.net/jeps/355#Description
      pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
      greedy: true,
      alias: "string"
    },
    "char": {
      pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
      greedy: true
    }
  });
  Prism2.languages.insertBefore("java", "class-name", {
    "annotation": {
      pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
      lookbehind: true,
      alias: "punctuation"
    },
    "generics": {
      pattern: /<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
      inside: {
        "class-name": className,
        "keyword": keywords,
        "punctuation": /[<>(),.:]/,
        "operator": /[?&|]/
      }
    },
    "import": [
      {
        pattern: RegExp(/(\bimport\s+)/.source + classNamePrefix + /(?:[A-Z]\w*|\*)(?=\s*;)/.source),
        lookbehind: true,
        inside: {
          "namespace": className.inside.namespace,
          "punctuation": /\./,
          "operator": /\*/,
          "class-name": /\w+/
        }
      },
      {
        pattern: RegExp(/(\bimport\s+static\s+)/.source + classNamePrefix + /(?:\w+|\*)(?=\s*;)/.source),
        lookbehind: true,
        alias: "static",
        inside: {
          "namespace": className.inside.namespace,
          "static": /\b\w+$/,
          "punctuation": /\./,
          "operator": /\*/,
          "class-name": /\w+/
        }
      }
    ],
    "namespace": {
      pattern: RegExp(
        /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(/<keyword>/g, function() {
          return keywords.source;
        })
      ),
      lookbehind: true,
      inside: {
        "punctuation": /\./
      }
    }
  });
})(Prism);
Prism.languages.javascript = Prism.languages.extend("clike", {
  "class-name": [
    Prism.languages.clike["class-name"],
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
      lookbehind: true
    }
  ],
  "keyword": [
    {
      pattern: /((?:^|\})\s*)catch\b/,
      lookbehind: true
    },
    {
      pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
      lookbehind: true
    }
  ],
  // Allow for all non-ASCII characters (See http://stackoverflow.com/a/2008444)
  "function": /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
  "number": {
    pattern: RegExp(
      /(^|[^\w$])/.source + "(?:" + // constant
      (/NaN|Infinity/.source + "|" + // binary integer
      /0[bB][01]+(?:_[01]+)*n?/.source + "|" + // octal integer
      /0[oO][0-7]+(?:_[0-7]+)*n?/.source + "|" + // hexadecimal integer
      /0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source + "|" + // decimal bigint
      /\d+(?:_\d+)*n/.source + "|" + // decimal number (integer or float) but no bigint
      /(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/.source) + ")" + /(?![\w$])/.source
    ),
    lookbehind: true
  },
  "operator": /--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
});
Prism.languages.javascript["class-name"][0].pattern = /(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
Prism.languages.insertBefore("javascript", "keyword", {
  "regex": {
    pattern: RegExp(
      // lookbehind
      // eslint-disable-next-line regexp/no-dupe-characters-character-class
      /((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)/.source + // Regex pattern:
      // There are 2 regex patterns here. The RegExp set notation proposal added support for nested character
      // classes if the `v` flag is present. Unfortunately, nested CCs are both context-free and incompatible
      // with the only syntax, so we have to define 2 different regex patterns.
      /\//.source + "(?:" + /(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}/.source + "|" + // `v` flag syntax. This supports 3 levels of nested character classes.
      /(?:\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.|\[(?:[^[\]\\\r\n]|\\.)*\])*\])*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}v[dgimyus]{0,7}/.source + ")" + // lookahead
      /(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/.source
    ),
    lookbehind: true,
    greedy: true,
    inside: {
      "regex-source": {
        pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
        lookbehind: true,
        alias: "language-regex",
        inside: Prism.languages.regex
      },
      "regex-delimiter": /^\/|\/$/,
      "regex-flags": /^[a-z]+$/
    }
  },
  // This must be declared before keyword because we use "function" inside the look-forward
  "function-variable": {
    pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
    alias: "function"
  },
  "parameter": [
    {
      pattern: /(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
      lookbehind: true,
      inside: Prism.languages.javascript
    },
    {
      pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
      lookbehind: true,
      inside: Prism.languages.javascript
    }
  ],
  "constant": /\b[A-Z](?:[A-Z_]|\dx?)*\b/
});
Prism.languages.insertBefore("javascript", "string", {
  "hashbang": {
    pattern: /^#!.*/,
    greedy: true,
    alias: "comment"
  },
  "template-string": {
    pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
    greedy: true,
    inside: {
      "template-punctuation": {
        pattern: /^`|`$/,
        alias: "string"
      },
      "interpolation": {
        pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
        lookbehind: true,
        inside: {
          "interpolation-punctuation": {
            pattern: /^\$\{|\}$/,
            alias: "punctuation"
          },
          rest: Prism.languages.javascript
        }
      },
      "string": /[\s\S]+/
    }
  },
  "string-property": {
    pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
    lookbehind: true,
    greedy: true,
    alias: "property"
  }
});
Prism.languages.insertBefore("javascript", "operator", {
  "literal-property": {
    pattern: /((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
    lookbehind: true,
    alias: "property"
  }
});
if (Prism.languages.markup) {
  Prism.languages.markup.tag.addInlined("script", "javascript");
  Prism.languages.markup.tag.addAttribute(
    /on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/.source,
    "javascript"
  );
}
Prism.languages.js = Prism.languages.javascript;
Prism.languages.json = {
  "property": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "string": {
    pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
    lookbehind: true,
    greedy: true
  },
  "comment": {
    pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
    greedy: true
  },
  "number": /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
  "punctuation": /[{}[\],]/,
  "operator": /:/,
  "boolean": /\b(?:false|true)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: "keyword"
  }
};
Prism.languages.webmanifest = Prism.languages.json;
(function(Prism2) {
  var javascript = Prism2.util.clone(Prism2.languages.javascript);
  var space2 = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
  var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
  var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
  function re6(source, flags) {
    source = source.replace(/<S>/g, function() {
      return space2;
    }).replace(/<BRACES>/g, function() {
      return braces;
    }).replace(/<SPREAD>/g, function() {
      return spread;
    });
    return RegExp(source, flags);
  }
  spread = re6(spread).source;
  Prism2.languages.jsx = Prism2.languages.extend("markup", javascript);
  Prism2.languages.jsx.tag.pattern = re6(
    /<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/.source
  );
  Prism2.languages.jsx.tag.inside["tag"].pattern = /^<\/?[^\s>\/]*/;
  Prism2.languages.jsx.tag.inside["attr-value"].pattern = /=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
  Prism2.languages.jsx.tag.inside["tag"].inside["class-name"] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
  Prism2.languages.jsx.tag.inside["comment"] = javascript["comment"];
  Prism2.languages.insertBefore("inside", "attr-name", {
    "spread": {
      pattern: re6(/<SPREAD>/.source),
      inside: Prism2.languages.jsx
    }
  }, Prism2.languages.jsx.tag);
  Prism2.languages.insertBefore("inside", "special-attr", {
    "script": {
      // Allow for two levels of nesting
      pattern: re6(/=<BRACES>/.source),
      alias: "language-javascript",
      inside: {
        "script-punctuation": {
          pattern: /^=(?=\{)/,
          alias: "punctuation"
        },
        rest: Prism2.languages.jsx
      }
    }
  }, Prism2.languages.jsx.tag);
  var stringifyToken = function(token2) {
    if (!token2) {
      return "";
    }
    if (typeof token2 === "string") {
      return token2;
    }
    if (typeof token2.content === "string") {
      return token2.content;
    }
    return token2.content.map(stringifyToken).join("");
  };
  var walkTokens = function(tokens2) {
    var openedTags = [];
    for (var i15 = 0; i15 < tokens2.length; i15++) {
      var token2 = tokens2[i15];
      var notTagNorBrace = false;
      if (typeof token2 !== "string") {
        if (token2.type === "tag" && token2.content[0] && token2.content[0].type === "tag") {
          if (token2.content[0].content[0].content === "</") {
            if (openedTags.length > 0 && openedTags[openedTags.length - 1].tagName === stringifyToken(token2.content[0].content[1])) {
              openedTags.pop();
            }
          } else {
            if (token2.content[token2.content.length - 1].content === "/>")
              ;
            else {
              openedTags.push({
                tagName: stringifyToken(token2.content[0].content[1]),
                openedBraces: 0
              });
            }
          }
        } else if (openedTags.length > 0 && token2.type === "punctuation" && token2.content === "{") {
          openedTags[openedTags.length - 1].openedBraces++;
        } else if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces > 0 && token2.type === "punctuation" && token2.content === "}") {
          openedTags[openedTags.length - 1].openedBraces--;
        } else {
          notTagNorBrace = true;
        }
      }
      if (notTagNorBrace || typeof token2 === "string") {
        if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
          var plainText = stringifyToken(token2);
          if (i15 < tokens2.length - 1 && (typeof tokens2[i15 + 1] === "string" || tokens2[i15 + 1].type === "plain-text")) {
            plainText += stringifyToken(tokens2[i15 + 1]);
            tokens2.splice(i15 + 1, 1);
          }
          if (i15 > 0 && (typeof tokens2[i15 - 1] === "string" || tokens2[i15 - 1].type === "plain-text")) {
            plainText = stringifyToken(tokens2[i15 - 1]) + plainText;
            tokens2.splice(i15 - 1, 1);
            i15--;
          }
          tokens2[i15] = new Prism2.Token("plain-text", plainText, null, plainText);
        }
      }
      if (token2.content && typeof token2.content !== "string") {
        walkTokens(token2.content);
      }
    }
  };
  Prism2.hooks.add("after-tokenize", function(env) {
    if (env.language !== "jsx" && env.language !== "tsx") {
      return;
    }
    walkTokens(env.tokens);
  });
})(Prism);
(function(Prism2) {
  Prism2.languages.kotlin = Prism2.languages.extend("clike", {
    "keyword": {
      // The lookbehind prevents wrong highlighting of e.g. kotlin.properties.get
      pattern: /(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,
      lookbehind: true
    },
    "function": [
      {
        pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/,
        greedy: true
      },
      {
        pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/,
        lookbehind: true,
        greedy: true
      }
    ],
    "number": /\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,
    "operator": /\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/
  });
  delete Prism2.languages.kotlin["class-name"];
  var interpolationInside = {
    "interpolation-punctuation": {
      pattern: /^\$\{?|\}$/,
      alias: "punctuation"
    },
    "expression": {
      pattern: /[\s\S]+/,
      inside: Prism2.languages.kotlin
    }
  };
  Prism2.languages.insertBefore("kotlin", "string", {
    // https://kotlinlang.org/spec/expressions.html#string-interpolation-expressions
    "string-literal": [
      {
        pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,
        alias: "multiline",
        inside: {
          "interpolation": {
            pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i,
            inside: interpolationInside
          },
          "string": /[\s\S]+/
        }
      },
      {
        pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/,
        alias: "singleline",
        inside: {
          "interpolation": {
            pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,
            lookbehind: true,
            inside: interpolationInside
          },
          "string": /[\s\S]+/
        }
      }
    ],
    "char": {
      // https://kotlinlang.org/spec/expressions.html#character-literals
      pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/,
      greedy: true
    }
  });
  delete Prism2.languages.kotlin["string"];
  Prism2.languages.insertBefore("kotlin", "keyword", {
    "annotation": {
      pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,
      alias: "builtin"
    }
  });
  Prism2.languages.insertBefore("kotlin", "function", {
    "label": {
      pattern: /\b\w+@|@\w+\b/,
      alias: "symbol"
    }
  });
  Prism2.languages.kt = Prism2.languages.kotlin;
  Prism2.languages.kts = Prism2.languages.kotlin;
})(Prism);
(function(Prism2) {
  var funcPattern = /\\(?:[^a-z()[\]]|[a-z*]+)/i;
  var insideEqu = {
    "equation-command": {
      pattern: funcPattern,
      alias: "regex"
    }
  };
  Prism2.languages.latex = {
    "comment": /%.*/,
    // the verbatim environment prints whitespace to the document
    "cdata": {
      pattern: /(\\begin\{((?:lstlisting|verbatim)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
      lookbehind: true
    },
    /*
     * equations can be between $$ $$ or $ $ or \( \) or \[ \]
     * (all are multiline)
     */
    "equation": [
      {
        pattern: /\$\$(?:\\[\s\S]|[^\\$])+\$\$|\$(?:\\[\s\S]|[^\\$])+\$|\\\([\s\S]*?\\\)|\\\[[\s\S]*?\\\]/,
        inside: insideEqu,
        alias: "string"
      },
      {
        pattern: /(\\begin\{((?:align|eqnarray|equation|gather|math|multline)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
        lookbehind: true,
        inside: insideEqu,
        alias: "string"
      }
    ],
    /*
     * arguments which are keywords or references are highlighted
     * as keywords
     */
    "keyword": {
      pattern: /(\\(?:begin|cite|documentclass|end|label|ref|usepackage)(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
      lookbehind: true
    },
    "url": {
      pattern: /(\\url\{)[^}]+(?=\})/,
      lookbehind: true
    },
    /*
     * section or chapter headlines are highlighted as bold so that
     * they stand out more
     */
    "headline": {
      pattern: /(\\(?:chapter|frametitle|paragraph|part|section|subparagraph|subsection|subsubparagraph|subsubsection|subsubsubparagraph)\*?(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
      lookbehind: true,
      alias: "class-name"
    },
    "function": {
      pattern: funcPattern,
      alias: "selector"
    },
    "punctuation": /[[\]{}&]/
  };
  Prism2.languages.tex = Prism2.languages.latex;
  Prism2.languages.context = Prism2.languages.latex;
})(Prism);
Prism.languages.less = Prism.languages.extend("css", {
  "comment": [
    /\/\*[\s\S]*?\*\//,
    {
      pattern: /(^|[^\\])\/\/.*/,
      lookbehind: true
    }
  ],
  "atrule": {
    pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
    inside: {
      "punctuation": /[:()]/
    }
  },
  // selectors and mixins are considered the same
  "selector": {
    pattern: /(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
    inside: {
      // mixin parameters
      "variable": /@+[\w-]+/
    }
  },
  "property": /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
  "operator": /[+\-*\/]/
});
Prism.languages.insertBefore("less", "property", {
  "variable": [
    // Variable declaration (the colon must be consumed!)
    {
      pattern: /@[\w-]+\s*:/,
      inside: {
        "punctuation": /:/
      }
    },
    // Variable usage
    /@@?[\w-]+/
  ],
  "mixin-usage": {
    pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
    lookbehind: true,
    alias: "function"
  }
});
Prism.languages.lua = {
  "comment": /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
  // \z may be used to skip the following space
  "string": {
    pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
    greedy: true
  },
  "number": /\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
  "keyword": /\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
  "function": /(?!\d)\w+(?=\s*(?:[({]))/,
  "operator": [
    /[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,
    {
      // Match ".." but don't break "..."
      pattern: /(^|[^.])\.\.(?!\.)/,
      lookbehind: true
    }
  ],
  "punctuation": /[\[\](){},;]|\.+|:+/
};
Prism.languages.makefile = {
  "comment": {
    pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
    lookbehind: true
  },
  "string": {
    pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "builtin-target": {
    pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
    alias: "builtin"
  },
  "target": {
    pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
    alias: "symbol",
    inside: {
      "variable": /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/
    }
  },
  "variable": /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
  // Directives
  "keyword": /-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
  "function": {
    pattern: /(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
    lookbehind: true
  },
  "operator": /(?:::|[?:+!])?=|[|@]/,
  "punctuation": /[:;(){}]/
};
(function(Prism2) {
  var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
  function createInline(pattern) {
    pattern = pattern.replace(/<inner>/g, function() {
      return inner;
    });
    return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + "(?:" + pattern + ")");
  }
  var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
  var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(/__/g, function() {
    return tableCell;
  });
  var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/.source;
  Prism2.languages.markdown = Prism2.languages.extend("markup", {});
  Prism2.languages.insertBefore("markdown", "prolog", {
    "front-matter-block": {
      pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
      lookbehind: true,
      greedy: true,
      inside: {
        "punctuation": /^---|---$/,
        "front-matter": {
          pattern: /\S+(?:\s+\S+)*/,
          alias: ["yaml", "language-yaml"],
          inside: Prism2.languages.yaml
        }
      }
    },
    "blockquote": {
      // > ...
      pattern: /^>(?:[\t ]*>)*/m,
      alias: "punctuation"
    },
    "table": {
      pattern: RegExp("^" + tableRow + tableLine + "(?:" + tableRow + ")*", "m"),
      inside: {
        "table-data-rows": {
          pattern: RegExp("^(" + tableRow + tableLine + ")(?:" + tableRow + ")*$"),
          lookbehind: true,
          inside: {
            "table-data": {
              pattern: RegExp(tableCell),
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        },
        "table-line": {
          pattern: RegExp("^(" + tableRow + ")" + tableLine + "$"),
          lookbehind: true,
          inside: {
            "punctuation": /\||:?-{3,}:?/
          }
        },
        "table-header-row": {
          pattern: RegExp("^" + tableRow + "$"),
          inside: {
            "table-header": {
              pattern: RegExp(tableCell),
              alias: "important",
              inside: Prism2.languages.markdown
            },
            "punctuation": /\|/
          }
        }
      }
    },
    "code": [
      {
        // Prefixed by 4 spaces or 1 tab and preceded by an empty line
        pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
        lookbehind: true,
        alias: "keyword"
      },
      {
        // ```optional language
        // code block
        // ```
        pattern: /^```[\s\S]*?^```$/m,
        greedy: true,
        inside: {
          "code-block": {
            pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
            lookbehind: true
          },
          "code-language": {
            pattern: /^(```).+/,
            lookbehind: true
          },
          "punctuation": /```/
        }
      }
    ],
    "title": [
      {
        // title 1
        // =======
        // title 2
        // -------
        pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
        alias: "important",
        inside: {
          punctuation: /==+$|--+$/
        }
      },
      {
        // # title 1
        // ###### title 6
        pattern: /(^\s*)#.+/m,
        lookbehind: true,
        alias: "important",
        inside: {
          punctuation: /^#+|#+$/
        }
      }
    ],
    "hr": {
      // ***
      // ---
      // * * *
      // -----------
      pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "list": {
      // * item
      // + item
      // - item
      // 1. item
      pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
      lookbehind: true,
      alias: "punctuation"
    },
    "url-reference": {
      // [id]: http://example.com "Optional title"
      // [id]: http://example.com 'Optional title'
      // [id]: http://example.com (Optional title)
      // [id]: <http://example.com> "Optional title"
      pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
      inside: {
        "variable": {
          pattern: /^(!?\[)[^\]]+/,
          lookbehind: true
        },
        "string": /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
        "punctuation": /^[\[\]!:]|[<>]/
      },
      alias: "url"
    },
    "bold": {
      // **strong**
      // __strong__
      // allow one nested instance of italic text using the same delimiter
      pattern: createInline(/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^..)[\s\S]+(?=..$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /\*\*|__/
      }
    },
    "italic": {
      // *em*
      // _em_
      // allow one nested instance of bold text using the same delimiter
      pattern: createInline(/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^.)[\s\S]+(?=.$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /[*_]/
      }
    },
    "strike": {
      // ~~strike through~~
      // ~strike~
      // eslint-disable-next-line regexp/strict
      pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "content": {
          pattern: /(^~~?)[\s\S]+(?=\1$)/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "punctuation": /~~?/
      }
    },
    "code-snippet": {
      // `code`
      // ``code``
      pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
      lookbehind: true,
      greedy: true,
      alias: ["code", "keyword"]
    },
    "url": {
      // [example](http://example.com "Optional title")
      // [example][id]
      // [example] [id]
      pattern: createInline(/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/.source),
      lookbehind: true,
      greedy: true,
      inside: {
        "operator": /^!/,
        "content": {
          pattern: /(^\[)[^\]]+(?=\])/,
          lookbehind: true,
          inside: {}
          // see below
        },
        "variable": {
          pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
          lookbehind: true
        },
        "url": {
          pattern: /(^\]\()[^\s)]+/,
          lookbehind: true
        },
        "string": {
          pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
          lookbehind: true
        }
      }
    }
  });
  ["url", "bold", "italic", "strike"].forEach(function(token2) {
    ["url", "bold", "italic", "strike", "code-snippet"].forEach(function(inside) {
      if (token2 !== inside) {
        Prism2.languages.markdown[token2].inside.content.inside[inside] = Prism2.languages.markdown[inside];
      }
    });
  });
  Prism2.hooks.add("after-tokenize", function(env) {
    if (env.language !== "markdown" && env.language !== "md") {
      return;
    }
    function walkTokens(tokens2) {
      if (!tokens2 || typeof tokens2 === "string") {
        return;
      }
      for (var i15 = 0, l14 = tokens2.length; i15 < l14; i15++) {
        var token2 = tokens2[i15];
        if (token2.type !== "code") {
          walkTokens(token2.content);
          continue;
        }
        var codeLang = token2.content[1];
        var codeBlock = token2.content[3];
        if (codeLang && codeBlock && codeLang.type === "code-language" && codeBlock.type === "code-block" && typeof codeLang.content === "string") {
          var lang2 = codeLang.content.replace(/\b#/g, "sharp").replace(/\b\+\+/g, "pp");
          lang2 = (/[a-z][\w-]*/i.exec(lang2) || [""])[0].toLowerCase();
          var alias = "language-" + lang2;
          if (!codeBlock.alias) {
            codeBlock.alias = [alias];
          } else if (typeof codeBlock.alias === "string") {
            codeBlock.alias = [codeBlock.alias, alias];
          } else {
            codeBlock.alias.push(alias);
          }
        }
      }
    }
    walkTokens(env.tokens);
  });
  Prism2.hooks.add("wrap", function(env) {
    if (env.type !== "code-block") {
      return;
    }
    var codeLang = "";
    for (var i15 = 0, l14 = env.classes.length; i15 < l14; i15++) {
      var cls = env.classes[i15];
      var match5 = /language-(.+)/.exec(cls);
      if (match5) {
        codeLang = match5[1];
        break;
      }
    }
    var grammar = Prism2.languages[codeLang];
    if (!grammar) {
      if (codeLang && codeLang !== "none" && Prism2.plugins.autoloader) {
        var id = "md-" + new Date().valueOf() + "-" + Math.floor(Math.random() * 1e16);
        env.attributes["id"] = id;
        Prism2.plugins.autoloader.loadLanguages(codeLang, function() {
          var ele = document.getElementById(id);
          if (ele) {
            ele.innerHTML = Prism2.highlight(ele.textContent, Prism2.languages[codeLang], codeLang);
          }
        });
      }
    } else {
      env.content = Prism2.highlight(textContent(env.content), grammar, codeLang);
    }
  });
  var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, "gi");
  var KNOWN_ENTITY_NAMES = {
    "amp": "&",
    "lt": "<",
    "gt": ">",
    "quot": '"'
  };
  var fromCodePoint = String.fromCodePoint || String.fromCharCode;
  function textContent(html) {
    var text = html.replace(tagPattern, "");
    text = text.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function(m10, code) {
      code = code.toLowerCase();
      if (code[0] === "#") {
        var value;
        if (code[1] === "x") {
          value = parseInt(code.slice(2), 16);
        } else {
          value = Number(code.slice(1));
        }
        return fromCodePoint(value);
      } else {
        var known = KNOWN_ENTITY_NAMES[code];
        if (known) {
          return known;
        }
        return m10;
      }
    });
    return text;
  }
  Prism2.languages.md = Prism2.languages.markdown;
})(Prism);
Prism.languages.matlab = {
  "comment": [
    /%\{[\s\S]*?\}%/,
    /%.+/
  ],
  "string": {
    pattern: /\B'(?:''|[^'\r\n])*'/,
    greedy: true
  },
  // FIXME We could handle imaginary numbers as a whole
  "number": /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?(?:[ij])?|\b[ij]\b/,
  "keyword": /\b(?:NaN|break|case|catch|continue|else|elseif|end|for|function|if|inf|otherwise|parfor|pause|pi|return|switch|try|while)\b/,
  "function": /\b(?!\d)\w+(?=\s*\()/,
  "operator": /\.?[*^\/\\']|[+\-:@]|[<>=~]=?|&&?|\|\|?/,
  "punctuation": /\.{3}|[.,;\[\](){}!]/
};
Prism.languages.objectivec = Prism.languages.extend("c", {
  "string": {
    pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
    greedy: true
  },
  "keyword": /\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
  "operator": /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
});
delete Prism.languages.objectivec["class-name"];
Prism.languages.objc = Prism.languages.objectivec;
(function(Prism2) {
  var brackets = /(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/.source;
  Prism2.languages.perl = {
    "comment": [
      {
        // POD
        pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
        lookbehind: true,
        greedy: true
      },
      {
        pattern: /(^|[^\\$])#.*/,
        lookbehind: true,
        greedy: true
      }
    ],
    // TODO Could be nice to handle Heredoc too.
    "string": [
      {
        pattern: RegExp(
          /\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
            // q/.../
            /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
            // q a...a
            // eslint-disable-next-line regexp/strict
            /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
            // q(...)
            // q{...}
            // q[...]
            // q<...>
            brackets
          ].join("|") + ")"
        ),
        greedy: true
      },
      // "...", `...`
      {
        pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
        greedy: true
      },
      // '...'
      // FIXME Multi-line single-quoted strings are not supported as they would break variables containing '
      {
        pattern: /'(?:[^'\\\r\n]|\\.)*'/,
        greedy: true
      }
    ],
    "regex": [
      {
        pattern: RegExp(
          /\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
            // m/.../
            /([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
            // m a...a
            // eslint-disable-next-line regexp/strict
            /([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
            // m(...)
            // m{...}
            // m[...]
            // m<...>
            brackets
          ].join("|") + ")" + /[msixpodualngc]*/.source
        ),
        greedy: true
      },
      // The lookbehinds prevent -s from breaking
      {
        pattern: RegExp(
          /(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source + "(?:" + [
            // s/.../.../
            // eslint-disable-next-line regexp/strict
            /([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
            // s a...a...a
            // eslint-disable-next-line regexp/strict
            /([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
            // s(...)(...)
            // s{...}{...}
            // s[...][...]
            // s<...><...>
            // s(...)[...]
            brackets + /\s*/.source + brackets
          ].join("|") + ")" + /[msixpodualngcer]*/.source
        ),
        lookbehind: true,
        greedy: true
      },
      // /.../
      // The look-ahead tries to prevent two divisions on
      // the same line from being highlighted as regex.
      // This does not support multi-line regex.
      {
        pattern: /\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
        greedy: true
      }
    ],
    // FIXME Not sure about the handling of ::, ', and #
    "variable": [
      // ${^POSTMATCH}
      /[&*$@%]\{\^[A-Z]+\}/,
      // $^V
      /[&*$@%]\^[A-Z_]/,
      // ${...}
      /[&*$@%]#?(?=\{)/,
      // $foo
      /[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
      // $1
      /[&*$@%]\d+/,
      // $_, @_, %!
      // The negative lookahead prevents from breaking the %= operator
      /(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
    ],
    "filehandle": {
      // <>, <FOO>, _
      pattern: /<(?![<=])\S*?>|\b_\b/,
      alias: "symbol"
    },
    "v-string": {
      // v1.2, 1.2.3
      pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
      alias: "string"
    },
    "function": {
      pattern: /(\bsub[ \t]+)\w+/,
      lookbehind: true
    },
    "keyword": /\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
    "number": /\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
    "operator": /-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
    "punctuation": /[{}[\];(),:]/
  };
})(Prism);
(function(Prism2) {
  var comment = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/;
  var constant3 = [
    {
      pattern: /\b(?:false|true)\b/i,
      alias: "boolean"
    },
    {
      pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
      greedy: true,
      lookbehind: true
    },
    {
      pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
      greedy: true,
      lookbehind: true
    },
    /\b(?:null)\b/i,
    /\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/
  ];
  var number2 = /\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i;
  var operator = /<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;
  var punctuation = /[{}\[\](),:;]/;
  Prism2.languages.php = {
    "delimiter": {
      pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
      alias: "important"
    },
    "comment": comment,
    "variable": /\$+(?:\w+\b|(?=\{))/,
    "package": {
      pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    },
    "class-name-definition": {
      pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
      lookbehind: true,
      alias: "class-name"
    },
    "function-definition": {
      pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
      lookbehind: true,
      alias: "function"
    },
    "keyword": [
      {
        pattern: /(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
        alias: "type-casting",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
        alias: "type-hint",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|never|object|self|static|string|void)\b/i,
        alias: "return-type",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
        alias: "type-declaration",
        greedy: true
      },
      {
        pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
        alias: "type-declaration",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /\b(?:parent|self|static)(?=\s*::)/i,
        alias: "static-context",
        greedy: true
      },
      {
        // yield from
        pattern: /(\byield\s+)from\b/i,
        lookbehind: true
      },
      // `class` is always a keyword unlike other keywords
      /\bclass\b/i,
      {
        // https://www.php.net/manual/en/reserved.keywords.php
        //
        // keywords cannot be preceded by "->"
        // the complex lookbehind means `(?<!(?:->|::)\s*)`
        pattern: /((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|never|new|or|parent|print|private|protected|public|readonly|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
        lookbehind: true
      }
    ],
    "argument-name": {
      pattern: /([(,]\s*)\b[a-z_]\w*(?=\s*:(?!:))/i,
      lookbehind: true
    },
    "class-name": [
      {
        pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
        greedy: true
      },
      {
        pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
        alias: "class-name-fully-qualified",
        greedy: true,
        lookbehind: true,
        inside: {
          "punctuation": /\\/
        }
      },
      {
        pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
        alias: "class-name-fully-qualified",
        greedy: true,
        inside: {
          "punctuation": /\\/
        }
      },
      {
        pattern: /(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
        alias: "class-name-fully-qualified",
        greedy: true,
        lookbehind: true,
        inside: {
          "punctuation": /\\/
        }
      },
      {
        pattern: /\b[a-z_]\w*(?=\s*\$)/i,
        alias: "type-declaration",
        greedy: true
      },
      {
        pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
        alias: ["class-name-fully-qualified", "type-declaration"],
        greedy: true,
        inside: {
          "punctuation": /\\/
        }
      },
      {
        pattern: /\b[a-z_]\w*(?=\s*::)/i,
        alias: "static-context",
        greedy: true
      },
      {
        pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
        alias: ["class-name-fully-qualified", "static-context"],
        greedy: true,
        inside: {
          "punctuation": /\\/
        }
      },
      {
        pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
        alias: "type-hint",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
        alias: ["class-name-fully-qualified", "type-hint"],
        greedy: true,
        lookbehind: true,
        inside: {
          "punctuation": /\\/
        }
      },
      {
        pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
        alias: "return-type",
        greedy: true,
        lookbehind: true
      },
      {
        pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
        alias: ["class-name-fully-qualified", "return-type"],
        greedy: true,
        lookbehind: true,
        inside: {
          "punctuation": /\\/
        }
      }
    ],
    "constant": constant3,
    "function": {
      pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
      lookbehind: true,
      inside: {
        "punctuation": /\\/
      }
    },
    "property": {
      pattern: /(->\s*)\w+/,
      lookbehind: true
    },
    "number": number2,
    "operator": operator,
    "punctuation": punctuation
  };
  var string_interpolation = {
    pattern: /\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
    lookbehind: true,
    inside: Prism2.languages.php
  };
  var string2 = [
    {
      pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
      alias: "nowdoc-string",
      greedy: true,
      inside: {
        "delimiter": {
          pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
          alias: "symbol",
          inside: {
            "punctuation": /^<<<'?|[';]$/
          }
        }
      }
    },
    {
      pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
      alias: "heredoc-string",
      greedy: true,
      inside: {
        "delimiter": {
          pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
          alias: "symbol",
          inside: {
            "punctuation": /^<<<"?|[";]$/
          }
        },
        "interpolation": string_interpolation
      }
    },
    {
      pattern: /`(?:\\[\s\S]|[^\\`])*`/,
      alias: "backtick-quoted-string",
      greedy: true
    },
    {
      pattern: /'(?:\\[\s\S]|[^\\'])*'/,
      alias: "single-quoted-string",
      greedy: true
    },
    {
      pattern: /"(?:\\[\s\S]|[^\\"])*"/,
      alias: "double-quoted-string",
      greedy: true,
      inside: {
        "interpolation": string_interpolation
      }
    }
  ];
  Prism2.languages.insertBefore("php", "variable", {
    "string": string2,
    "attribute": {
      pattern: /#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
      greedy: true,
      inside: {
        "attribute-content": {
          pattern: /^(#\[)[\s\S]+(?=\]$)/,
          lookbehind: true,
          // inside can appear subset of php
          inside: {
            "comment": comment,
            "string": string2,
            "attribute-class-name": [
              {
                pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
                alias: "class-name",
                greedy: true,
                lookbehind: true
              },
              {
                pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
                alias: [
                  "class-name",
                  "class-name-fully-qualified"
                ],
                greedy: true,
                lookbehind: true,
                inside: {
                  "punctuation": /\\/
                }
              }
            ],
            "constant": constant3,
            "number": number2,
            "operator": operator,
            "punctuation": punctuation
          }
        },
        "delimiter": {
          pattern: /^#\[|\]$/,
          alias: "punctuation"
        }
      }
    }
  });
  Prism2.hooks.add("before-tokenize", function(env) {
    if (!/<\?/.test(env.code)) {
      return;
    }
    var phpPattern = /<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
    Prism2.languages["markup-templating"].buildPlaceholders(env, "php", phpPattern);
  });
  Prism2.hooks.add("after-tokenize", function(env) {
    Prism2.languages["markup-templating"].tokenizePlaceholders(env, "php");
  });
})(Prism);
(function(Prism2) {
  var powershell = Prism2.languages.powershell = {
    "comment": [
      {
        pattern: /(^|[^`])<#[\s\S]*?#>/,
        lookbehind: true
      },
      {
        pattern: /(^|[^`])#.*/,
        lookbehind: true
      }
    ],
    "string": [
      {
        pattern: /"(?:`[\s\S]|[^`"])*"/,
        greedy: true,
        inside: null
        // see below
      },
      {
        pattern: /'(?:[^']|'')*'/,
        greedy: true
      }
    ],
    // Matches name spaces as well as casts, attribute decorators. Force starting with letter to avoid matching array indices
    // Supports two levels of nested brackets (e.g. `[OutputType([System.Collections.Generic.List[int]])]`)
    "namespace": /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
    "boolean": /\$(?:false|true)\b/i,
    "variable": /\$\w+\b/,
    // Cmdlets and aliases. Aliases should come last, otherwise "write" gets preferred over "write-host" for example
    // Get-Command | ?{ $_.ModuleName -match "Microsoft.PowerShell.(Util|Core|Management)" }
    // Get-Alias | ?{ $_.ReferencedCommand.Module.Name -match "Microsoft.PowerShell.(Util|Core|Management)" }
    "function": [
      /\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
      /\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i
    ],
    // per http://technet.microsoft.com/en-us/library/hh847744.aspx
    "keyword": /\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
    "operator": {
      pattern: /(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
      lookbehind: true
    },
    "punctuation": /[|{}[\];(),.]/
  };
  powershell.string[0].inside = {
    "function": {
      // Allow for one level of nesting
      pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
      lookbehind: true,
      inside: powershell
    },
    "boolean": powershell.boolean,
    "variable": powershell.variable
  };
})(Prism);
Prism.languages.properties = {
  "comment": /^[ \t]*[#!].*$/m,
  "value": {
    pattern: /(^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?: *[=:] *(?! )| ))(?:\\(?:\r\n|[\s\S])|[^\\\r\n])+/m,
    lookbehind: true,
    alias: "attr-value"
  },
  "key": {
    pattern: /^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?= *[=:]| )/m,
    alias: "attr-name"
  },
  "punctuation": /[=:]/
};
(function(Prism2) {
  var builtinTypes = /\b(?:bool|bytes|double|s?fixed(?:32|64)|float|[su]?int(?:32|64)|string)\b/;
  Prism2.languages.protobuf = Prism2.languages.extend("clike", {
    "class-name": [
      {
        pattern: /(\b(?:enum|extend|message|service)\s+)[A-Za-z_]\w*(?=\s*\{)/,
        lookbehind: true
      },
      {
        pattern: /(\b(?:rpc\s+\w+|returns)\s*\(\s*(?:stream\s+)?)\.?[A-Za-z_]\w*(?:\.[A-Za-z_]\w*)*(?=\s*\))/,
        lookbehind: true
      }
    ],
    "keyword": /\b(?:enum|extend|extensions|import|message|oneof|option|optional|package|public|repeated|required|reserved|returns|rpc(?=\s+\w)|service|stream|syntax|to)\b(?!\s*=\s*\d)/,
    "function": /\b[a-z_]\w*(?=\s*\()/i
  });
  Prism2.languages.insertBefore("protobuf", "operator", {
    "map": {
      pattern: /\bmap<\s*[\w.]+\s*,\s*[\w.]+\s*>(?=\s+[a-z_]\w*\s*[=;])/i,
      alias: "class-name",
      inside: {
        "punctuation": /[<>.,]/,
        "builtin": builtinTypes
      }
    },
    "builtin": builtinTypes,
    "positional-class-name": {
      pattern: /(?:\b|\B\.)[a-z_]\w*(?:\.[a-z_]\w*)*(?=\s+[a-z_]\w*\s*[=;])/i,
      alias: "class-name",
      inside: {
        "punctuation": /\./
      }
    },
    "annotation": {
      pattern: /(\[\s*)[a-z_]\w*(?=\s*=)/i,
      lookbehind: true
    }
  });
})(Prism);
Prism.languages.python = {
  "comment": {
    pattern: /(^|[^\\])#.*/,
    lookbehind: true,
    greedy: true
  },
  "string-interpolation": {
    pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
    greedy: true,
    inside: {
      "interpolation": {
        // "{" <expression> <optional "!s", "!r", or "!a"> <optional ":" format specifier> "}"
        pattern: /((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
        lookbehind: true,
        inside: {
          "format-spec": {
            pattern: /(:)[^:(){}]+(?=\}$)/,
            lookbehind: true
          },
          "conversion-option": {
            pattern: /![sra](?=[:}]$)/,
            alias: "punctuation"
          },
          rest: null
        }
      },
      "string": /[\s\S]+/
    }
  },
  "triple-quoted-string": {
    pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
    greedy: true,
    alias: "string"
  },
  "string": {
    pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
    greedy: true
  },
  "function": {
    pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
    lookbehind: true
  },
  "class-name": {
    pattern: /(\bclass\s+)\w+/i,
    lookbehind: true
  },
  "decorator": {
    pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
    lookbehind: true,
    alias: ["annotation", "punctuation"],
    inside: {
      "punctuation": /\./
    }
  },
  "keyword": /\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
  "builtin": /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
  "boolean": /\b(?:False|None|True)\b/,
  "number": /\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
  "operator": /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
  "punctuation": /[{}[\];(),.:]/
};
Prism.languages.python["string-interpolation"].inside["interpolation"].inside.rest = Prism.languages.python;
Prism.languages.py = Prism.languages.python;
Prism.languages.r = {
  "comment": /#.*/,
  "string": {
    pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "percent-operator": {
    // Includes user-defined operators
    // and %%, %*%, %/%, %in%, %o%, %x%
    pattern: /%[^%\s]*%/,
    alias: "operator"
  },
  "boolean": /\b(?:FALSE|TRUE)\b/,
  "ellipsis": /\.\.(?:\.|\d+)/,
  "number": [
    /\b(?:Inf|NaN)\b/,
    /(?:\b0x[\dA-Fa-f]+(?:\.\d*)?|\b\d+(?:\.\d*)?|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/
  ],
  "keyword": /\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\b/,
  "operator": /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
  "punctuation": /[(){}\[\],;]/
};
(function(Prism2) {
  Prism2.languages.ruby = Prism2.languages.extend("clike", {
    "comment": {
      pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
      greedy: true
    },
    "class-name": {
      pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
      lookbehind: true,
      inside: {
        "punctuation": /[.\\]/
      }
    },
    "keyword": /\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
    "operator": /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
    "punctuation": /[(){}[\].,;]/
  });
  Prism2.languages.insertBefore("ruby", "operator", {
    "double-colon": {
      pattern: /::/,
      alias: "punctuation"
    }
  });
  var interpolation = {
    pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
    lookbehind: true,
    inside: {
      "content": {
        pattern: /^(#\{)[\s\S]+(?=\}$)/,
        lookbehind: true,
        inside: Prism2.languages.ruby
      },
      "delimiter": {
        pattern: /^#\{|\}$/,
        alias: "punctuation"
      }
    }
  };
  delete Prism2.languages.ruby.function;
  var percentExpression = "(?:" + [
    /([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
    /\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
    /\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
    /\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source,
    /<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source
  ].join("|") + ")";
  var symbolName = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/.source;
  Prism2.languages.insertBefore("ruby", "keyword", {
    "regex-literal": [
      {
        pattern: RegExp(/%r/.source + percentExpression + /[egimnosux]{0,6}/.source),
        greedy: true,
        inside: {
          "interpolation": interpolation,
          "regex": /[\s\S]+/
        }
      },
      {
        pattern: /(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
        lookbehind: true,
        greedy: true,
        inside: {
          "interpolation": interpolation,
          "regex": /[\s\S]+/
        }
      }
    ],
    "variable": /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
    "symbol": [
      {
        pattern: RegExp(/(^|[^:]):/.source + symbolName),
        lookbehind: true,
        greedy: true
      },
      {
        pattern: RegExp(/([\r\n{(,][ \t]*)/.source + symbolName + /(?=:(?!:))/.source),
        lookbehind: true,
        greedy: true
      }
    ],
    "method-definition": {
      pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
      lookbehind: true,
      inside: {
        "function": /\b\w+$/,
        "keyword": /^self\b/,
        "class-name": /^\w+/,
        "punctuation": /\./
      }
    }
  });
  Prism2.languages.insertBefore("ruby", "string", {
    "string-literal": [
      {
        pattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),
        greedy: true,
        inside: {
          "interpolation": interpolation,
          "string": /[\s\S]+/
        }
      },
      {
        pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
        greedy: true,
        inside: {
          "interpolation": interpolation,
          "string": /[\s\S]+/
        }
      },
      {
        pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
        alias: "heredoc-string",
        greedy: true,
        inside: {
          "delimiter": {
            pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
            inside: {
              "symbol": /\b\w+/,
              "punctuation": /^<<[-~]?/
            }
          },
          "interpolation": interpolation,
          "string": /[\s\S]+/
        }
      },
      {
        pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
        alias: "heredoc-string",
        greedy: true,
        inside: {
          "delimiter": {
            pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
            inside: {
              "symbol": /\b\w+/,
              "punctuation": /^<<[-~]?'|'$/
            }
          },
          "string": /[\s\S]+/
        }
      }
    ],
    "command-literal": [
      {
        pattern: RegExp(/%x/.source + percentExpression),
        greedy: true,
        inside: {
          "interpolation": interpolation,
          "command": {
            pattern: /[\s\S]+/,
            alias: "string"
          }
        }
      },
      {
        pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
        greedy: true,
        inside: {
          "interpolation": interpolation,
          "command": {
            pattern: /[\s\S]+/,
            alias: "string"
          }
        }
      }
    ]
  });
  delete Prism2.languages.ruby.string;
  Prism2.languages.insertBefore("ruby", "number", {
    "builtin": /\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
    "constant": /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
  });
  Prism2.languages.rb = Prism2.languages.ruby;
})(Prism);
(function(Prism2) {
  Prism2.languages.sass = Prism2.languages.extend("css", {
    // Sass comments don't need to be closed, only indented
    "comment": {
      pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
      lookbehind: true,
      greedy: true
    }
  });
  Prism2.languages.insertBefore("sass", "atrule", {
    // We want to consume the whole line
    "atrule-line": {
      // Includes support for = and + shortcuts
      pattern: /^(?:[ \t]*)[@+=].+/m,
      greedy: true,
      inside: {
        "atrule": /(?:@[\w-]+|[+=])/
      }
    }
  });
  delete Prism2.languages.sass.atrule;
  var variable = /\$[-\w]+|#\{\$[-\w]+\}/;
  var operator = [
    /[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/,
    {
      pattern: /(\s)-(?=\s)/,
      lookbehind: true
    }
  ];
  Prism2.languages.insertBefore("sass", "property", {
    // We want to consume the whole line
    "variable-line": {
      pattern: /^[ \t]*\$.+/m,
      greedy: true,
      inside: {
        "punctuation": /:/,
        "variable": variable,
        "operator": operator
      }
    },
    // We want to consume the whole line
    "property-line": {
      pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
      greedy: true,
      inside: {
        "property": [
          /[^:\s]+(?=\s*:)/,
          {
            pattern: /(:)[^:\s]+/,
            lookbehind: true
          }
        ],
        "punctuation": /:/,
        "variable": variable,
        "operator": operator,
        "important": Prism2.languages.sass.important
      }
    }
  });
  delete Prism2.languages.sass.property;
  delete Prism2.languages.sass.important;
  Prism2.languages.insertBefore("sass", "punctuation", {
    "selector": {
      pattern: /^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
      lookbehind: true,
      greedy: true
    }
  });
})(Prism);
Prism.languages.scala = Prism.languages.extend("java", {
  "triple-quoted-string": {
    pattern: /"""[\s\S]*?"""/,
    greedy: true,
    alias: "string"
  },
  "string": {
    pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
    greedy: true
  },
  "keyword": /<-|=>|\b(?:abstract|case|catch|class|def|do|else|extends|final|finally|for|forSome|if|implicit|import|lazy|match|new|null|object|override|package|private|protected|return|sealed|self|super|this|throw|trait|try|type|val|var|while|with|yield)\b/,
  "number": /\b0x(?:[\da-f]*\.)?[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e\d+)?[dfl]?/i,
  "builtin": /\b(?:Any|AnyRef|AnyVal|Boolean|Byte|Char|Double|Float|Int|Long|Nothing|Short|String|Unit)\b/,
  "symbol": /'[^\d\s\\]\w*/
});
Prism.languages.insertBefore("scala", "triple-quoted-string", {
  "string-interpolation": {
    pattern: /\b[a-z]\w*(?:"""(?:[^$]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*?"""|"(?:[^$"\r\n]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*")/i,
    greedy: true,
    inside: {
      "id": {
        pattern: /^\w+/,
        greedy: true,
        alias: "function"
      },
      "escape": {
        pattern: /\\\$"|\$[$"]/,
        greedy: true,
        alias: "symbol"
      },
      "interpolation": {
        pattern: /\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
        greedy: true,
        inside: {
          "punctuation": /^\$\{?|\}$/,
          "expression": {
            pattern: /[\s\S]+/,
            inside: Prism.languages.scala
          }
        }
      },
      "string": /[\s\S]+/
    }
  }
});
delete Prism.languages.scala["class-name"];
delete Prism.languages.scala["function"];
(function(Prism2) {
  Prism2.languages.scheme = {
    // this supports "normal" single-line comments:
    //   ; comment
    // and (potentially nested) multiline comments:
    //   #| comment #| nested |# still comment |#
    // (only 1 level of nesting is supported)
    "comment": /;.*|#;\s*(?:\((?:[^()]|\([^()]*\))*\)|\[(?:[^\[\]]|\[[^\[\]]*\])*\])|#\|(?:[^#|]|#(?!\|)|\|(?!#)|#\|(?:[^#|]|#(?!\|)|\|(?!#))*\|#)*\|#/,
    "string": {
      pattern: /"(?:[^"\\]|\\.)*"/,
      greedy: true
    },
    "symbol": {
      pattern: /'[^()\[\]#'\s]+/,
      greedy: true
    },
    "char": {
      pattern: /#\\(?:[ux][a-fA-F\d]+\b|[-a-zA-Z]+\b|[\uD800-\uDBFF][\uDC00-\uDFFF]|\S)/,
      greedy: true
    },
    "lambda-parameter": [
      // https://www.cs.cmu.edu/Groups/AI/html/r4rs/r4rs_6.html#SEC30
      {
        pattern: /((?:^|[^'`#])[(\[]lambda\s+)(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)/,
        lookbehind: true
      },
      {
        pattern: /((?:^|[^'`#])[(\[]lambda\s+[(\[])[^()\[\]']+/,
        lookbehind: true
      }
    ],
    "keyword": {
      pattern: /((?:^|[^'`#])[(\[])(?:begin|case(?:-lambda)?|cond(?:-expand)?|define(?:-library|-macro|-record-type|-syntax|-values)?|defmacro|delay(?:-force)?|do|else|except|export|guard|if|import|include(?:-ci|-library-declarations)?|lambda|let(?:rec)?(?:-syntax|-values|\*)?|let\*-values|only|parameterize|prefix|(?:quasi-?)?quote|rename|set!|syntax-(?:case|rules)|unless|unquote(?:-splicing)?|when)(?=[()\[\]\s]|$)/,
      lookbehind: true
    },
    "builtin": {
      // all functions of the base library of R7RS plus some of built-ins of R5Rs
      pattern: /((?:^|[^'`#])[(\[])(?:abs|and|append|apply|assoc|ass[qv]|binary-port\?|boolean=?\?|bytevector(?:-append|-copy|-copy!|-length|-u8-ref|-u8-set!|\?)?|caar|cadr|call-with-(?:current-continuation|port|values)|call\/cc|car|cdar|cddr|cdr|ceiling|char(?:->integer|-ready\?|\?|<\?|<=\?|=\?|>\?|>=\?)|close-(?:input-port|output-port|port)|complex\?|cons|current-(?:error|input|output)-port|denominator|dynamic-wind|eof-object\??|eq\?|equal\?|eqv\?|error|error-object(?:-irritants|-message|\?)|eval|even\?|exact(?:-integer-sqrt|-integer\?|\?)?|expt|features|file-error\?|floor(?:-quotient|-remainder|\/)?|flush-output-port|for-each|gcd|get-output-(?:bytevector|string)|inexact\??|input-port(?:-open\?|\?)|integer(?:->char|\?)|lcm|length|list(?:->string|->vector|-copy|-ref|-set!|-tail|\?)?|make-(?:bytevector|list|parameter|string|vector)|map|max|member|memq|memv|min|modulo|negative\?|newline|not|null\?|number(?:->string|\?)|numerator|odd\?|open-(?:input|output)-(?:bytevector|string)|or|output-port(?:-open\?|\?)|pair\?|peek-char|peek-u8|port\?|positive\?|procedure\?|quotient|raise|raise-continuable|rational\?|rationalize|read-(?:bytevector|bytevector!|char|error\?|line|string|u8)|real\?|remainder|reverse|round|set-c[ad]r!|square|string(?:->list|->number|->symbol|->utf8|->vector|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?|<\?|<=\?|=\?|>\?|>=\?)?|substring|symbol(?:->string|\?|=\?)|syntax-error|textual-port\?|truncate(?:-quotient|-remainder|\/)?|u8-ready\?|utf8->string|values|vector(?:->list|->string|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?)?|with-exception-handler|write-(?:bytevector|char|string|u8)|zero\?)(?=[()\[\]\s]|$)/,
      lookbehind: true
    },
    "operator": {
      pattern: /((?:^|[^'`#])[(\[])(?:[-+*%/]|[<>]=?|=>?)(?=[()\[\]\s]|$)/,
      lookbehind: true
    },
    "number": {
      // The number pattern from [the R7RS spec](https://small.r7rs.org/attachment/r7rs.pdf).
      //
      // <number>      := <num 2>|<num 8>|<num 10>|<num 16>
      // <num R>       := <prefix R><complex R>
      // <complex R>   := <real R>(?:@<real R>|<imaginary R>)?|<imaginary R>
      // <imaginary R> := [+-](?:<ureal R>|(?:inf|nan)\.0)?i
      // <real R>      := [+-]?<ureal R>|[+-](?:inf|nan)\.0
      // <ureal R>     := <uint R>(?:\/<uint R>)?
      //                | <decimal R>
      //
      // <decimal 10>  := (?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?
      // <uint R>      := <digit R>+
      // <prefix R>    := <radix R>(?:#[ei])?|(?:#[ei])?<radix R>
      // <radix 2>     := #b
      // <radix 8>     := #o
      // <radix 10>    := (?:#d)?
      // <radix 16>    := #x
      // <digit 2>     := [01]
      // <digit 8>     := [0-7]
      // <digit 10>    := \d
      // <digit 16>    := [0-9a-f]
      //
      // The problem with this grammar is that the resulting regex is way to complex, so we simplify by grouping all
      // non-decimal bases together. This results in a decimal (dec) and combined binary, octal, and hexadecimal (box)
      // pattern:
      pattern: RegExp(SortedBNF({
        "<ureal dec>": /\d+(?:\/\d+)|(?:\d+(?:\.\d*)?|\.\d+)(?:[esfdl][+-]?\d+)?/.source,
        "<real dec>": /[+-]?<ureal dec>|[+-](?:inf|nan)\.0/.source,
        "<imaginary dec>": /[+-](?:<ureal dec>|(?:inf|nan)\.0)?i/.source,
        "<complex dec>": /<real dec>(?:@<real dec>|<imaginary dec>)?|<imaginary dec>/.source,
        "<num dec>": /(?:#d(?:#[ei])?|#[ei](?:#d)?)?<complex dec>/.source,
        "<ureal box>": /[0-9a-f]+(?:\/[0-9a-f]+)?/.source,
        "<real box>": /[+-]?<ureal box>|[+-](?:inf|nan)\.0/.source,
        "<imaginary box>": /[+-](?:<ureal box>|(?:inf|nan)\.0)?i/.source,
        "<complex box>": /<real box>(?:@<real box>|<imaginary box>)?|<imaginary box>/.source,
        "<num box>": /#[box](?:#[ei])?|(?:#[ei])?#[box]<complex box>/.source,
        "<number>": /(^|[()\[\]\s])(?:<num dec>|<num box>)(?=[()\[\]\s]|$)/.source
      }), "i"),
      lookbehind: true
    },
    "boolean": {
      pattern: /(^|[()\[\]\s])#(?:[ft]|false|true)(?=[()\[\]\s]|$)/,
      lookbehind: true
    },
    "function": {
      pattern: /((?:^|[^'`#])[(\[])(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)(?=[()\[\]\s]|$)/,
      lookbehind: true
    },
    "identifier": {
      pattern: /(^|[()\[\]\s])\|(?:[^\\|]|\\.)*\|(?=[()\[\]\s]|$)/,
      lookbehind: true,
      greedy: true
    },
    "punctuation": /[()\[\]']/
  };
  function SortedBNF(grammar) {
    for (var key in grammar) {
      grammar[key] = grammar[key].replace(/<[\w\s]+>/g, function(key2) {
        return "(?:" + grammar[key2].trim() + ")";
      });
    }
    return grammar[key];
  }
})(Prism);
Prism.languages.scss = Prism.languages.extend("css", {
  "comment": {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
    lookbehind: true
  },
  "atrule": {
    pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
    inside: {
      "rule": /@[\w-]+/
      // See rest below
    }
  },
  // url, compassified
  "url": /(?:[-a-z]+-)?url(?=\()/i,
  // CSS selector regex is not appropriate for Sass
  // since there can be lot more things (var, @ directive, nesting..)
  // a selector must start at the end of a property or after a brace (end of other rules or nesting)
  // it can contain some characters that aren't used for defining rules or end of selector, & (parent selector), or interpolated variable
  // the end of a selector is found when there is no rules in it ( {} or {\s}) or if there is a property (because an interpolated var
  // can "pass" as a selector- e.g: proper#{$erty})
  // this one was hard to do, so please be careful if you edit this one :)
  "selector": {
    // Initial look-ahead is used to prevent matching of blank selectors
    pattern: /(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
    inside: {
      "parent": {
        pattern: /&/,
        alias: "important"
      },
      "placeholder": /%[-\w]+/,
      "variable": /\$[-\w]+|#\{\$[-\w]+\}/
    }
  },
  "property": {
    pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
    inside: {
      "variable": /\$[-\w]+|#\{\$[-\w]+\}/
    }
  }
});
Prism.languages.insertBefore("scss", "atrule", {
  "keyword": [
    /@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i,
    {
      pattern: /( )(?:from|through)(?= )/,
      lookbehind: true
    }
  ]
});
Prism.languages.insertBefore("scss", "important", {
  // var and interpolated vars
  "variable": /\$[-\w]+|#\{\$[-\w]+\}/
});
Prism.languages.insertBefore("scss", "function", {
  "module-modifier": {
    pattern: /\b(?:as|hide|show|with)\b/i,
    alias: "keyword"
  },
  "placeholder": {
    pattern: /%[-\w]+/,
    alias: "selector"
  },
  "statement": {
    pattern: /\B!(?:default|optional)\b/i,
    alias: "keyword"
  },
  "boolean": /\b(?:false|true)\b/,
  "null": {
    pattern: /\bnull\b/,
    alias: "keyword"
  },
  "operator": {
    pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
    lookbehind: true
  }
});
Prism.languages.scss["atrule"].inside.rest = Prism.languages.scss;
Prism.languages.sql = {
  "comment": {
    pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
    lookbehind: true
  },
  "variable": [
    {
      pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
      greedy: true
    },
    /@[\w.$]+/
  ],
  "string": {
    pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
    greedy: true,
    lookbehind: true
  },
  "identifier": {
    pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
    greedy: true,
    lookbehind: true,
    inside: {
      "punctuation": /^`|`$/
    }
  },
  "function": /\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
  // Should we highlight user defined functions too?
  "keyword": /\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
  "boolean": /\b(?:FALSE|NULL|TRUE)\b/i,
  "number": /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
  "operator": /[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
  "punctuation": /[;[\]()`,.]/
};
Prism.languages.swift = {
  "comment": {
    // Nested comments are supported up to 2 levels
    pattern: /(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
    lookbehind: true,
    greedy: true
  },
  "string-literal": [
    // https://docs.swift.org/swift-book/LanguageGuide/StringsAndCharacters.html
    {
      pattern: RegExp(
        /(^|[^"#])/.source + "(?:" + /"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source + "|" + /"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source + ")" + /(?!["#])/.source
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": {
          pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\\($/,
          alias: "punctuation"
        },
        "punctuation": /\\(?=[\r\n])/,
        "string": /[\s\S]+/
      }
    },
    {
      pattern: RegExp(
        /(^|[^"#])(#+)/.source + "(?:" + /"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source + "|" + /"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source + ")\\2"
      ),
      lookbehind: true,
      greedy: true,
      inside: {
        "interpolation": {
          pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
          lookbehind: true,
          inside: null
          // see below
        },
        "interpolation-punctuation": {
          pattern: /^\)|\\#+\($/,
          alias: "punctuation"
        },
        "string": /[\s\S]+/
      }
    }
  ],
  "directive": {
    // directives with conditions
    pattern: RegExp(
      /#/.source + "(?:" + (/(?:elseif|if)\b/.source + "(?:[ 	]*" + /(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/.source + ")+") + "|" + /(?:else|endif)\b/.source + ")"
    ),
    alias: "property",
    inside: {
      "directive-name": /^#\w+/,
      "boolean": /\b(?:false|true)\b/,
      "number": /\b\d+(?:\.\d+)*\b/,
      "operator": /!|&&|\|\||[<>]=?/,
      "punctuation": /[(),]/
    }
  },
  "literal": {
    pattern: /#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
    alias: "constant"
  },
  "other-directive": {
    pattern: /#\w+\b/,
    alias: "property"
  },
  "attribute": {
    pattern: /@\w+/,
    alias: "atrule"
  },
  "function-definition": {
    pattern: /(\bfunc\s+)\w+/,
    lookbehind: true,
    alias: "function"
  },
  "label": {
    // https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html#ID141
    pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
    lookbehind: true,
    alias: "important"
  },
  "keyword": /\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
  "boolean": /\b(?:false|true)\b/,
  "nil": {
    pattern: /\bnil\b/,
    alias: "constant"
  },
  "short-argument": /\$\d+\b/,
  "omit": {
    pattern: /\b_\b/,
    alias: "keyword"
  },
  "number": /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
  // A class name must start with an upper-case letter and be either 1 letter long or contain a lower-case letter.
  "class-name": /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
  "function": /\b[a-z_]\w*(?=\s*\()/i,
  "constant": /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
  // Operators are generic in Swift. Developers can even create new operators (e.g. +++).
  // https://docs.swift.org/swift-book/ReferenceManual/zzSummaryOfTheGrammar.html#ID481
  // This regex only supports ASCII operators.
  "operator": /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
  "punctuation": /[{}[\]();,.:\\]/
};
Prism.languages.swift["string-literal"].forEach(function(rule) {
  rule.inside["interpolation"].inside = Prism.languages.swift;
});
(function(Prism2) {
  var typescript = Prism2.util.clone(Prism2.languages.typescript);
  Prism2.languages.tsx = Prism2.languages.extend("jsx", typescript);
  delete Prism2.languages.tsx["parameter"];
  delete Prism2.languages.tsx["literal-property"];
  var tag = Prism2.languages.tsx.tag;
  tag.pattern = RegExp(/(^|[^\w$]|(?=<\/))/.source + "(?:" + tag.pattern.source + ")", tag.pattern.flags);
  tag.lookbehind = true;
})(Prism);
(function(Prism2) {
  Prism2.languages.typescript = Prism2.languages.extend("javascript", {
    "class-name": {
      pattern: /(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
      lookbehind: true,
      greedy: true,
      inside: null
      // see below
    },
    "builtin": /\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
  });
  Prism2.languages.typescript.keyword.push(
    /\b(?:abstract|declare|is|keyof|readonly|require)\b/,
    // keywords that have to be followed by an identifier
    /\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
    // This is for `import type *, {}`
    /\btype\b(?=\s*(?:[\{*]|$))/
  );
  delete Prism2.languages.typescript["parameter"];
  delete Prism2.languages.typescript["literal-property"];
  var typeInside = Prism2.languages.extend("typescript", {});
  delete typeInside["class-name"];
  Prism2.languages.typescript["class-name"].inside = typeInside;
  Prism2.languages.insertBefore("typescript", "function", {
    "decorator": {
      pattern: /@[$\w\xA0-\uFFFF]+/,
      inside: {
        "at": {
          pattern: /^@/,
          alias: "operator"
        },
        "function": /^[\s\S]+/
      }
    },
    "generic-function": {
      // e.g. foo<T extends "bar" | "baz">( ...
      pattern: /#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
      greedy: true,
      inside: {
        "function": /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
        "generic": {
          pattern: /<[\s\S]+/,
          // everything after the first <
          alias: "class-name",
          inside: typeInside
        }
      }
    }
  });
  Prism2.languages.ts = Prism2.languages.typescript;
})(Prism);
Prism.languages.wasm = {
  "comment": [
    /\(;[\s\S]*?;\)/,
    {
      pattern: /;;.*/,
      greedy: true
    }
  ],
  "string": {
    pattern: /"(?:\\[\s\S]|[^"\\])*"/,
    greedy: true
  },
  "keyword": [
    {
      pattern: /\b(?:align|offset)=/,
      inside: {
        "operator": /=/
      }
    },
    {
      pattern: /\b(?:(?:f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))?|memory\.(?:grow|size))\b/,
      inside: {
        "punctuation": /\./
      }
    },
    /\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\b/
  ],
  "variable": /\$[\w!#$%&'*+\-./:<=>?@\\^`|~]+/,
  "number": /[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
  "punctuation": /[()]/
};
(function(Prism2) {
  var anchorOrAlias = /[*&][^\s[\]{},]+/;
  var tag = /!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
  var properties = "(?:" + tag.source + "(?:[ 	]+" + anchorOrAlias.source + ")?|" + anchorOrAlias.source + "(?:[ 	]+" + tag.source + ")?)";
  var plainKey = /(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(/<PLAIN>/g, function() {
    return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/.source;
  });
  var string2 = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
  function createValuePattern(value, flags) {
    flags = (flags || "").replace(/m/g, "") + "m";
    var pattern = /([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source.replace(/<<prop>>/g, function() {
      return properties;
    }).replace(/<<value>>/g, function() {
      return value;
    });
    return RegExp(pattern, flags);
  }
  Prism2.languages.yaml = {
    "scalar": {
      pattern: RegExp(/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(/<<prop>>/g, function() {
        return properties;
      })),
      lookbehind: true,
      alias: "string"
    },
    "comment": /#.*/,
    "key": {
      pattern: RegExp(/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source.replace(/<<prop>>/g, function() {
        return properties;
      }).replace(/<<key>>/g, function() {
        return "(?:" + plainKey + "|" + string2 + ")";
      })),
      lookbehind: true,
      greedy: true,
      alias: "atrule"
    },
    "directive": {
      pattern: /(^[ \t]*)%.+/m,
      lookbehind: true,
      alias: "important"
    },
    "datetime": {
      pattern: createValuePattern(/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/.source),
      lookbehind: true,
      alias: "number"
    },
    "boolean": {
      pattern: createValuePattern(/false|true/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "null": {
      pattern: createValuePattern(/null|~/.source, "i"),
      lookbehind: true,
      alias: "important"
    },
    "string": {
      pattern: createValuePattern(string2),
      lookbehind: true,
      greedy: true
    },
    "number": {
      pattern: createValuePattern(/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/.source, "i"),
      lookbehind: true
    },
    "tag": tag,
    "important": anchorOrAlias,
    "punctuation": /---|[:[\]{}\-,|>?]|\.\.\./
  };
  Prism2.languages.yml = Prism2.languages.yaml;
})(Prism);
var decorateCodeLine = (editor) => {
  const code_block = getPlugin(editor, ELEMENT_CODE_BLOCK);
  const code_line = getPlugin(editor, ELEMENT_CODE_LINE);
  return ([node, path]) => {
    var _codeBlock$0$lang;
    const ranges = [];
    if (!code_block.options.syntax || node.type !== code_line.type) {
      return ranges;
    }
    const codeBlock = getParentNode(editor, path);
    if (!codeBlock) {
      return ranges;
    }
    let langName = (_codeBlock$0$lang = codeBlock[0].lang) !== null && _codeBlock$0$lang !== void 0 ? _codeBlock$0$lang : "";
    if (langName === "plain") {
      langName = "";
    }
    const lang2 = import_prismjs.languages[langName];
    if (!lang2) {
      return ranges;
    }
    const text = getNodeString(node);
    const tokens2 = (0, import_prismjs.tokenize)(text, lang2);
    let offset5 = 0;
    for (const element of tokens2) {
      if (element instanceof import_prismjs.Token) {
        ranges.push({
          anchor: {
            path,
            offset: offset5
          },
          focus: {
            path,
            offset: offset5 + element.length
          },
          tokenType: element.type,
          [ELEMENT_CODE_SYNTAX]: true
        });
      }
      offset5 += element.length;
    }
    return ranges;
  };
};
var deserializeHtmlCodeBlock = {
  rules: [{
    validNodeName: "PRE"
  }, {
    validNodeName: "P",
    validStyle: {
      fontFamily: "Consolas"
    }
  }],
  getNode: (el) => {
    var _find, _el$textContent, _lines;
    const languageSelectorText = ((_find = [...el.childNodes].find((node) => node.nodeName === "SELECT")) === null || _find === void 0 ? void 0 : _find.textContent) || "";
    const textContent = ((_el$textContent = el.textContent) === null || _el$textContent === void 0 ? void 0 : _el$textContent.replace(languageSelectorText, "")) || "";
    let lines = textContent.split("\n");
    if (!((_lines = lines) !== null && _lines !== void 0 && _lines.length)) {
      lines = [textContent];
    }
    const codeLines = lines.map((line) => ({
      type: ELEMENT_CODE_LINE,
      children: [{
        text: line
      }]
    }));
    return {
      type: ELEMENT_CODE_BLOCK,
      children: codeLines
    };
  }
};
function unwrapExports3(x7) {
  return x7 && x7.__esModule && Object.prototype.hasOwnProperty.call(x7, "default") ? x7["default"] : x7;
}
function createCommonjsModule4(fn2, module2) {
  return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
}
var lib3 = createCommonjsModule4(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var IS_MAC = () => typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
  var MODIFIERS = {
    alt: "altKey",
    control: "ctrlKey",
    meta: "metaKey",
    shift: "shiftKey"
  };
  var ALIASES = () => ({
    add: "+",
    break: "pause",
    cmd: "meta",
    command: "meta",
    ctl: "control",
    ctrl: "control",
    del: "delete",
    down: "arrowdown",
    esc: "escape",
    ins: "insert",
    left: "arrowleft",
    mod: IS_MAC() ? "meta" : "control",
    opt: "alt",
    option: "alt",
    return: "enter",
    right: "arrowright",
    space: " ",
    spacebar: " ",
    up: "arrowup",
    win: "meta",
    windows: "meta"
  });
  var CODES = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    control: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    " ": 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    insert: 45,
    delete: 46,
    meta: 91,
    numlock: 144,
    scrolllock: 145,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
  };
  for (var f16 = 1; f16 < 20; f16++) {
    CODES["f" + f16] = 111 + f16;
  }
  function isHotkey14(hotkey, options, event) {
    if (options && !("byKey" in options)) {
      event = options;
      options = null;
    }
    if (!Array.isArray(hotkey)) {
      hotkey = [hotkey];
    }
    var array2 = hotkey.map(function(string2) {
      return parseHotkey(string2, options);
    });
    var check = function check2(e9) {
      return array2.some(function(object2) {
        return compareHotkey(object2, e9);
      });
    };
    var ret = event == null ? check : check(event);
    return ret;
  }
  function isCodeHotkey(hotkey, event) {
    return isHotkey14(hotkey, event);
  }
  function isKeyHotkey2(hotkey, event) {
    return isHotkey14(hotkey, { byKey: true }, event);
  }
  function parseHotkey(hotkey, options) {
    var byKey = options && options.byKey;
    var ret = {};
    hotkey = hotkey.replace("++", "+add");
    var values3 = hotkey.split("+");
    var length = values3.length;
    for (var k3 in MODIFIERS) {
      ret[MODIFIERS[k3]] = false;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = void 0;
    try {
      for (var _iterator = values3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var value = _step.value;
        var optional = value.endsWith("?") && value.length > 1;
        if (optional) {
          value = value.slice(0, -1);
        }
        var name2 = toKeyName(value);
        var modifier = MODIFIERS[name2];
        if (length === 1 || !modifier) {
          if (byKey) {
            ret.key = name2;
          } else {
            ret.which = toKeyCode(value);
          }
        }
        if (modifier) {
          ret[modifier] = optional ? null : true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return ret;
  }
  function compareHotkey(object2, event) {
    for (var key in object2) {
      var expected = object2[key];
      var actual = void 0;
      if (expected == null) {
        continue;
      }
      if (key === "key" && event.key != null) {
        actual = event.key.toLowerCase();
      } else if (key === "which") {
        actual = expected === 91 && event.which === 93 ? 91 : event.which;
      } else {
        actual = event[key];
      }
      if (actual == null && expected === false) {
        continue;
      }
      if (actual !== expected) {
        return false;
      }
    }
    return true;
  }
  function toKeyCode(name2) {
    name2 = toKeyName(name2);
    var code = CODES[name2] || name2.toUpperCase().charCodeAt(0);
    return code;
  }
  function toKeyName(name2) {
    name2 = name2.toLowerCase();
    name2 = ALIASES()[name2] || name2;
    return name2;
  }
  exports2.default = isHotkey14;
  exports2.isHotkey = isHotkey14;
  exports2.isCodeHotkey = isCodeHotkey;
  exports2.isKeyHotkey = isKeyHotkey2;
  exports2.parseHotkey = parseHotkey;
  exports2.compareHotkey = compareHotkey;
  exports2.toKeyCode = toKeyCode;
  exports2.toKeyName = toKeyName;
});
var isHotkey3 = unwrapExports3(lib3);
lib3.isHotkey;
lib3.isCodeHotkey;
lib3.isKeyHotkey;
lib3.parseHotkey;
lib3.compareHotkey;
lib3.toKeyCode;
lib3.toKeyName;
var getCodeLineType = (editor) => getPluginType(editor, ELEMENT_CODE_LINE);
var getCodeLineEntry = (editor, {
  at = editor.selection
} = {}) => {
  if (at && someNode(editor, {
    at,
    match: {
      type: getCodeLineType(editor)
    }
  })) {
    const selectionParent = getParentNode(editor, at);
    if (!selectionParent)
      return;
    const [, parentPath] = selectionParent;
    const codeLine = getAboveNode(editor, {
      at,
      match: {
        type: getCodeLineType(editor)
      }
    }) || getParentNode(editor, parentPath);
    if (!codeLine)
      return;
    const [codeLineNode, codeLinePath] = codeLine;
    if (isElement2(codeLineNode) && codeLineNode.type !== getCodeLineType(editor))
      return;
    const codeBlock = getParentNode(editor, codeLinePath);
    if (!codeBlock)
      return;
    return {
      codeBlock,
      codeLine
    };
  }
};
var indentCodeLine = (editor, {
  codeLine
}) => {
  const [, codeLinePath] = codeLine;
  const codeLineStart = getStartPoint(editor, codeLinePath);
  if (!isExpanded(editor.selection)) {
    var _editor$selection;
    const cursor = (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor;
    const range = getRange(editor, codeLineStart, cursor);
    const text = getEditorString(editor, range);
    if (/\S/.test(text)) {
      insertText(editor, "  ", {
        at: editor.selection
      });
      return;
    }
  }
  insertText(editor, "  ", {
    at: codeLineStart
  });
};
var deleteStartSpace = (editor, {
  codeLine
}) => {
  const [, codeLinePath] = codeLine;
  const codeLineStart = getStartPoint(editor, codeLinePath);
  const codeLineEnd = codeLineStart && getPointAfter(editor, codeLineStart);
  const spaceRange = codeLineEnd && getRange(editor, codeLineStart, codeLineEnd);
  const spaceText = getEditorString(editor, spaceRange);
  if (/\s/.test(spaceText)) {
    deleteText(editor, {
      at: spaceRange
    });
    return true;
  }
  return false;
};
var outdentCodeLine = (editor, {
  codeBlock,
  codeLine
}) => {
  const deleted = deleteStartSpace(editor, {
    codeBlock,
    codeLine
  });
  deleted && deleteStartSpace(editor, {
    codeBlock,
    codeLine
  });
};
var onKeyDownCodeBlock = (editor) => (e9) => {
  const isTab = Hotkeys2.isTab(editor, e9);
  const isUntab = Hotkeys2.isUntab(editor, e9);
  if (isTab || isUntab) {
    const _codeLines = getNodeEntries(editor, {
      match: {
        type: getCodeLineType(editor)
      }
    });
    const codeLines = Array.from(_codeLines);
    if (codeLines.length) {
      e9.preventDefault();
      const [, firstLinePath] = codeLines[0];
      const codeBlock = getParentNode(editor, firstLinePath);
      if (!codeBlock)
        return;
      withoutNormalizing(editor, () => {
        for (const codeLine of codeLines) {
          if (isUntab) {
            outdentCodeLine(editor, {
              codeBlock,
              codeLine
            });
          }
          if (isTab) {
            indentCodeLine(editor, {
              codeBlock,
              codeLine
            });
          }
        }
      });
    }
  }
  if (isHotkey3("mod+a", e9)) {
    const res = getCodeLineEntry(editor, {});
    if (!res)
      return;
    const {
      codeBlock
    } = res;
    const [, codeBlockPath] = codeBlock;
    select(editor, codeBlockPath);
    e9.preventDefault();
    e9.stopPropagation();
  }
};
var insertFragmentCodeBlock = (editor) => {
  const {
    insertFragment: _insertFragment
  } = editor;
  const codeBlockType = getPluginType(editor, ELEMENT_CODE_BLOCK);
  const codeLineType = getPluginType(editor, ELEMENT_CODE_LINE);
  function convertNodeToCodeLine(node) {
    return {
      type: codeLineType,
      children: [{
        text: getNodeString(node)
      }]
    };
  }
  function extractCodeLinesFromCodeBlock(node) {
    return node.children;
  }
  return (fragment) => {
    const inCodeLine = findNode(editor, {
      match: {
        type: codeLineType
      }
    });
    if (!inCodeLine) {
      return _insertFragment(fragment);
    }
    return insertFragment(editor, fragment.flatMap((node) => {
      const element = node;
      return element.type === codeBlockType ? extractCodeLinesFromCodeBlock(element) : convertNodeToCodeLine(element);
    }));
  };
};
var getIndentDepth = (editor, {
  codeLine
}) => {
  const [, codeLinePath] = codeLine;
  const text = getEditorString(editor, codeLinePath);
  return text.search(/\S|$/);
};
var insertCodeLine = (editor, indentDepth = 0) => {
  if (editor.selection) {
    const indent2 = " ".repeat(indentDepth);
    insertElements(editor, {
      type: getCodeLineType(editor),
      children: [{
        text: indent2
      }]
    });
  }
};
var withCodeBlock = (editor) => {
  const {
    insertBreak
  } = editor;
  const insertBreakCodeBlock = () => {
    if (!editor.selection)
      return;
    const res = getCodeLineEntry(editor, {});
    if (!res)
      return;
    const {
      codeBlock,
      codeLine
    } = res;
    const indentDepth = getIndentDepth(editor, {
      codeBlock,
      codeLine
    });
    insertCodeLine(editor, indentDepth);
    return true;
  };
  editor.insertBreak = () => {
    if (insertBreakCodeBlock())
      return;
    insertBreak();
  };
  editor.insertFragment = insertFragmentCodeBlock(editor);
  return editor;
};
var createCodeBlockPlugin = createPluginFactory({
  key: ELEMENT_CODE_BLOCK,
  isElement: true,
  deserializeHtml: deserializeHtmlCodeBlock,
  handlers: {
    onKeyDown: onKeyDownCodeBlock
  },
  withOverrides: withCodeBlock,
  options: {
    hotkey: ["mod+opt+8", "mod+shift+8"],
    syntax: true,
    syntaxPopularFirst: false
  },
  then: (editor) => ({
    inject: {
      pluginsByKey: {
        [KEY_DESERIALIZE_HTML]: {
          editor: {
            insertData: {
              query: () => {
                const code_line = getPlugin(editor, ELEMENT_CODE_LINE);
                return !someNode(editor, {
                  match: {
                    type: code_line.type
                  }
                });
              }
            }
          }
        }
      }
    }
  }),
  plugins: [{
    key: ELEMENT_CODE_LINE,
    isElement: true
  }, {
    key: ELEMENT_CODE_SYNTAX,
    isLeaf: true,
    decorate: decorateCodeLine
  }]
});

// node_modules/@udecode/plate-heading/dist/index.es.js
var ELEMENT_H1 = "h1";
var ELEMENT_H2 = "h2";
var ELEMENT_H3 = "h3";
var ELEMENT_H4 = "h4";
var ELEMENT_H5 = "h5";
var ELEMENT_H6 = "h6";
var KEYS_HEADING = [ELEMENT_H1, ELEMENT_H2, ELEMENT_H3, ELEMENT_H4, ELEMENT_H5, ELEMENT_H6];
var createHeadingPlugin = createPluginFactory({
  key: "heading",
  options: {
    levels: 6
  },
  then: (editor, {
    options: {
      levels
    } = {}
  }) => {
    const plugins2 = [];
    for (let level = 1; level <= levels; level++) {
      const key = KEYS_HEADING[level - 1];
      const plugin = {
        key,
        isElement: true,
        deserializeHtml: {
          rules: [{
            validNodeName: `H${level}`
          }]
        },
        handlers: {
          onKeyDown: onKeyDownToggleElement
        },
        options: {}
      };
      if (level < 4) {
        plugin.options.hotkey = [`mod+opt+${level}`, `mod+shift+${level}`];
      }
      plugins2.push(plugin);
    }
    return {
      plugins: plugins2
    };
  }
});

// node_modules/@udecode/plate-paragraph/dist/index.es.js
var ELEMENT_PARAGRAPH = "p";
var createParagraphPlugin = createPluginFactory({
  key: ELEMENT_PARAGRAPH,
  isElement: true,
  handlers: {
    onKeyDown: onKeyDownToggleElement
  },
  options: {
    hotkey: ["mod+opt+0", "mod+shift+0"]
  },
  deserializeHtml: {
    rules: [{
      validNodeName: "P"
    }],
    query: (el) => el.style.fontFamily !== "Consolas"
  }
});

// node_modules/@udecode/plate-basic-elements/dist/index.es.js
var createBasicElementsPlugin = createPluginFactory({
  key: "basicElements",
  plugins: [createBlockquotePlugin(), createCodeBlockPlugin(), createHeadingPlugin(), createParagraphPlugin()]
});

// node_modules/@udecode/plate-basic-marks/dist/index.es.js
var MARK_BOLD = "bold";
var createBoldPlugin = createPluginFactory({
  key: MARK_BOLD,
  isLeaf: true,
  deserializeHtml: {
    rules: [{
      validNodeName: ["STRONG", "B"]
    }, {
      validStyle: {
        fontWeight: ["600", "700", "bold"]
      }
    }],
    query: (el) => !someHtmlElement(el, (node) => node.style.fontWeight === "normal")
  },
  handlers: {
    onKeyDown: onKeyDownToggleMark
  },
  options: {
    hotkey: "mod+b"
  }
});
var MARK_CODE = "code";
var createCodePlugin = createPluginFactory({
  key: MARK_CODE,
  isLeaf: true,
  deserializeHtml: {
    rules: [{
      validNodeName: ["CODE"]
    }, {
      validStyle: {
        wordWrap: "break-word"
      }
    }, {
      validStyle: {
        fontFamily: "Consolas"
      }
    }],
    query(el) {
      const blockAbove = findHtmlParentElement(el, "P");
      if ((blockAbove === null || blockAbove === void 0 ? void 0 : blockAbove.style.fontFamily) === "Consolas")
        return false;
      return !findHtmlParentElement(el, "PRE");
    }
  },
  handlers: {
    onKeyDown: onKeyDownToggleMark
  },
  options: {
    hotkey: "mod+e"
  }
});
var MARK_ITALIC = "italic";
var createItalicPlugin = createPluginFactory({
  key: MARK_ITALIC,
  isLeaf: true,
  handlers: {
    onKeyDown: onKeyDownToggleMark
  },
  options: {
    hotkey: "mod+i"
  },
  deserializeHtml: {
    rules: [{
      validNodeName: ["EM", "I"]
    }, {
      validStyle: {
        fontStyle: "italic"
      }
    }],
    query: (el) => !someHtmlElement(el, (node) => node.style.fontStyle === "normal")
  }
});
var MARK_STRIKETHROUGH = "strikethrough";
var createStrikethroughPlugin = createPluginFactory({
  key: MARK_STRIKETHROUGH,
  isLeaf: true,
  handlers: {
    onKeyDown: onKeyDownToggleMark
  },
  options: {
    hotkey: "mod+shift+x"
  },
  deserializeHtml: {
    rules: [{
      validNodeName: ["S", "DEL", "STRIKE"]
    }, {
      validStyle: {
        textDecoration: "line-through"
      }
    }],
    query: (el) => !someHtmlElement(el, (node) => node.style.textDecoration === "none")
  }
});
var MARK_SUBSCRIPT$1 = "subscript";
var MARK_SUPERSCRIPT$1 = "superscript";
var createSubscriptPlugin = createPluginFactory({
  key: MARK_SUBSCRIPT$1,
  isLeaf: true,
  handlers: {
    onKeyDown: onKeyDownToggleMark
  },
  options: {
    hotkey: "mod+,",
    clear: MARK_SUPERSCRIPT$1
  },
  deserializeHtml: {
    rules: [{
      validNodeName: ["SUB"]
    }, {
      validStyle: {
        verticalAlign: "sub"
      }
    }]
  }
});
var MARK_SUPERSCRIPT = "superscript";
var MARK_SUBSCRIPT = "subscript";
var createSuperscriptPlugin = createPluginFactory({
  key: MARK_SUPERSCRIPT,
  isLeaf: true,
  handlers: {
    onKeyDown: onKeyDownToggleMark
  },
  options: {
    hotkey: "mod+.",
    clear: MARK_SUBSCRIPT
  },
  deserializeHtml: {
    rules: [{
      validNodeName: ["SUP"]
    }, {
      validStyle: {
        verticalAlign: "super"
      }
    }]
  }
});
var MARK_UNDERLINE = "underline";
var createUnderlinePlugin = createPluginFactory({
  key: MARK_UNDERLINE,
  isLeaf: true,
  handlers: {
    onKeyDown: onKeyDownToggleMark
  },
  options: {
    hotkey: "mod+u"
  },
  deserializeHtml: {
    rules: [{
      validNodeName: ["U"]
    }, {
      validStyle: {
        textDecoration: ["underline"]
      }
    }],
    query: (el) => !someHtmlElement(el, (node) => node.style.textDecoration === "none")
  }
});
var createBasicMarksPlugin = createPluginFactory({
  key: "basicMarks",
  plugins: [createBoldPlugin(), createCodePlugin(), createItalicPlugin(), createStrikethroughPlugin(), createSubscriptPlugin(), createSuperscriptPlugin(), createUnderlinePlugin()]
});

// node_modules/@udecode/plate-break/dist/index.es.js
function unwrapExports4(x7) {
  return x7 && x7.__esModule && Object.prototype.hasOwnProperty.call(x7, "default") ? x7["default"] : x7;
}
function createCommonjsModule5(fn2, module2) {
  return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
}
var lib4 = createCommonjsModule5(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var IS_MAC = () => typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
  var MODIFIERS = {
    alt: "altKey",
    control: "ctrlKey",
    meta: "metaKey",
    shift: "shiftKey"
  };
  var ALIASES = () => ({
    add: "+",
    break: "pause",
    cmd: "meta",
    command: "meta",
    ctl: "control",
    ctrl: "control",
    del: "delete",
    down: "arrowdown",
    esc: "escape",
    ins: "insert",
    left: "arrowleft",
    mod: IS_MAC() ? "meta" : "control",
    opt: "alt",
    option: "alt",
    return: "enter",
    right: "arrowright",
    space: " ",
    spacebar: " ",
    up: "arrowup",
    win: "meta",
    windows: "meta"
  });
  var CODES = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    control: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    " ": 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    insert: 45,
    delete: 46,
    meta: 91,
    numlock: 144,
    scrolllock: 145,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
  };
  for (var f16 = 1; f16 < 20; f16++) {
    CODES["f" + f16] = 111 + f16;
  }
  function isHotkey14(hotkey, options, event) {
    if (options && !("byKey" in options)) {
      event = options;
      options = null;
    }
    if (!Array.isArray(hotkey)) {
      hotkey = [hotkey];
    }
    var array2 = hotkey.map(function(string2) {
      return parseHotkey(string2, options);
    });
    var check = function check2(e9) {
      return array2.some(function(object2) {
        return compareHotkey(object2, e9);
      });
    };
    var ret = event == null ? check : check(event);
    return ret;
  }
  function isCodeHotkey(hotkey, event) {
    return isHotkey14(hotkey, event);
  }
  function isKeyHotkey2(hotkey, event) {
    return isHotkey14(hotkey, { byKey: true }, event);
  }
  function parseHotkey(hotkey, options) {
    var byKey = options && options.byKey;
    var ret = {};
    hotkey = hotkey.replace("++", "+add");
    var values3 = hotkey.split("+");
    var length = values3.length;
    for (var k3 in MODIFIERS) {
      ret[MODIFIERS[k3]] = false;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = void 0;
    try {
      for (var _iterator = values3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var value = _step.value;
        var optional = value.endsWith("?") && value.length > 1;
        if (optional) {
          value = value.slice(0, -1);
        }
        var name2 = toKeyName(value);
        var modifier = MODIFIERS[name2];
        if (length === 1 || !modifier) {
          if (byKey) {
            ret.key = name2;
          } else {
            ret.which = toKeyCode(value);
          }
        }
        if (modifier) {
          ret[modifier] = optional ? null : true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return ret;
  }
  function compareHotkey(object2, event) {
    for (var key in object2) {
      var expected = object2[key];
      var actual = void 0;
      if (expected == null) {
        continue;
      }
      if (key === "key" && event.key != null) {
        actual = event.key.toLowerCase();
      } else if (key === "which") {
        actual = expected === 91 && event.which === 93 ? 91 : event.which;
      } else {
        actual = event[key];
      }
      if (actual == null && expected === false) {
        continue;
      }
      if (actual !== expected) {
        return false;
      }
    }
    return true;
  }
  function toKeyCode(name2) {
    name2 = toKeyName(name2);
    var code = CODES[name2] || name2.toUpperCase().charCodeAt(0);
    return code;
  }
  function toKeyName(name2) {
    name2 = name2.toLowerCase();
    name2 = ALIASES()[name2] || name2;
    return name2;
  }
  exports2.default = isHotkey14;
  exports2.isHotkey = isHotkey14;
  exports2.isCodeHotkey = isCodeHotkey;
  exports2.isKeyHotkey = isKeyHotkey2;
  exports2.parseHotkey = parseHotkey;
  exports2.compareHotkey = compareHotkey;
  exports2.toKeyCode = toKeyCode;
  exports2.toKeyName = toKeyName;
});
var isHotkey4 = unwrapExports4(lib4);
lib4.isHotkey;
lib4.isCodeHotkey;
lib4.isKeyHotkey;
lib4.parseHotkey;
lib4.compareHotkey;
lib4.toKeyCode;
lib4.toKeyName;
var exitBreakAtEdges = (editor, {
  start: start3,
  end: end2
}) => {
  let queryEdge = false;
  let isEdge2 = false;
  let isStart = false;
  if (start3 || end2) {
    queryEdge = true;
    if (start3 && isSelectionAtBlockStart(editor)) {
      isEdge2 = true;
      isStart = true;
    }
    if (end2 && isSelectionAtBlockEnd(editor)) {
      isEdge2 = true;
    }
    if (isEdge2 && isExpanded(editor.selection)) {
      editor.deleteFragment();
    }
  }
  return {
    queryEdge,
    isEdge: isEdge2,
    isStart
  };
};
var exitBreak = (editor, {
  level = 0,
  defaultType = getPluginType(editor, ELEMENT_DEFAULT),
  query = {},
  before
}) => {
  if (!editor.selection)
    return;
  const {
    queryEdge,
    isEdge: isEdge2,
    isStart
  } = exitBreakAtEdges(editor, query);
  if (isStart)
    before = true;
  if (queryEdge && !isEdge2)
    return;
  const selectionPath = getPath(editor, editor.selection);
  let insertPath;
  if (before) {
    insertPath = selectionPath.slice(0, level + 1);
  } else {
    insertPath = Path.next(selectionPath.slice(0, level + 1));
  }
  insertElements(editor, {
    type: defaultType,
    children: [{
      text: ""
    }]
  }, {
    at: insertPath,
    select: !isStart
  });
  return true;
};
var onKeyDownExitBreak = (editor, {
  options: {
    rules = []
  }
}) => (event) => {
  const entry = getBlockAbove(editor);
  if (!entry)
    return;
  rules.forEach(({
    hotkey,
    ...rule
  }) => {
    if (isHotkey4(hotkey, event) && queryNode(entry, rule.query)) {
      if (exitBreak(editor, rule)) {
        event.preventDefault();
        event.stopPropagation();
      }
    }
  });
};
var KEY_EXIT_BREAK = "exitBreak";
var createExitBreakPlugin = createPluginFactory({
  key: KEY_EXIT_BREAK,
  handlers: {
    onKeyDown: onKeyDownExitBreak
  },
  options: {
    rules: [{
      hotkey: "mod+enter"
    }, {
      hotkey: "mod+shift+enter",
      before: true
    }]
  }
});
var onKeyDownSingleLine = () => (event) => {
  if (Hotkeys2.isSplitBlock(event)) {
    event.preventDefault();
  }
};
var withSingleLine = (editor) => {
  const {
    normalizeNode
  } = editor;
  editor.insertBreak = () => null;
  editor.normalizeNode = (entry) => {
    if (editor.children.length > 1) {
      removeNodes(editor, {
        at: [],
        mode: "highest",
        match: (node, path) => path[0] > 0
      });
    }
    normalizeNode(entry);
  };
  return editor;
};
var KEY_SINGLE_LINE = "singleLine";
var createSingleLinePlugin = createPluginFactory({
  key: KEY_SINGLE_LINE,
  handlers: {
    onKeyDown: onKeyDownSingleLine
  },
  withOverrides: withSingleLine
});
var onKeyDownSoftBreak = (editor, {
  options: {
    rules = []
  }
}) => (event) => {
  const entry = getBlockAbove(editor);
  if (!entry)
    return;
  rules.forEach(({
    hotkey,
    query
  }) => {
    if (isHotkey4(hotkey, event) && queryNode(entry, query)) {
      event.preventDefault();
      event.stopPropagation();
      editor.insertText("\n");
    }
  });
};
var KEY_SOFT_BREAK = "softBreak";
var createSoftBreakPlugin = createPluginFactory({
  key: KEY_SOFT_BREAK,
  handlers: {
    onKeyDown: onKeyDownSoftBreak
  },
  options: {
    rules: [{
      hotkey: "shift+enter"
    }]
  }
});

// node_modules/@udecode/plate-combobox/dist/index.es.js
var import_react9 = __toESM(require_react());

// node_modules/downshift/dist/downshift.esm.js
var import_prop_types = __toESM(require_prop_types());
var import_react8 = __toESM(require_react());
var import_react_is = __toESM(require_react_is());

// node_modules/tslib/tslib.es6.js
var __assign = function() {
  __assign = Object.assign || function __assign7(t20) {
    for (var s20, i15 = 1, n12 = arguments.length; i15 < n12; i15++) {
      s20 = arguments[i15];
      for (var p12 in s20)
        if (Object.prototype.hasOwnProperty.call(s20, p12))
          t20[p12] = s20[p12];
    }
    return t20;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P6, generator) {
  function adopt(value) {
    return value instanceof P6 ? value : new P6(function(resolve) {
      resolve(value);
    });
  }
  return new (P6 || (P6 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e9) {
        reject(e9);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e9) {
        reject(e9);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _7 = { label: 0, sent: function() {
    if (t20[0] & 1)
      throw t20[1];
    return t20[1];
  }, trys: [], ops: [] }, f16, y9, t20, g6;
  return g6 = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g6[Symbol.iterator] = function() {
    return this;
  }), g6;
  function verb(n12) {
    return function(v6) {
      return step([n12, v6]);
    };
  }
  function step(op) {
    if (f16)
      throw new TypeError("Generator is already executing.");
    while (g6 && (g6 = 0, op[0] && (_7 = 0)), _7)
      try {
        if (f16 = 1, y9 && (t20 = op[0] & 2 ? y9["return"] : op[0] ? y9["throw"] || ((t20 = y9["return"]) && t20.call(y9), 0) : y9.next) && !(t20 = t20.call(y9, op[1])).done)
          return t20;
        if (y9 = 0, t20)
          op = [op[0] & 2, t20.value];
        switch (op[0]) {
          case 0:
          case 1:
            t20 = op;
            break;
          case 4:
            _7.label++;
            return { value: op[1], done: false };
          case 5:
            _7.label++;
            y9 = op[1];
            op = [0];
            continue;
          case 7:
            op = _7.ops.pop();
            _7.trys.pop();
            continue;
          default:
            if (!(t20 = _7.trys, t20 = t20.length > 0 && t20[t20.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _7 = 0;
              continue;
            }
            if (op[0] === 3 && (!t20 || op[1] > t20[0] && op[1] < t20[3])) {
              _7.label = op[1];
              break;
            }
            if (op[0] === 6 && _7.label < t20[1]) {
              _7.label = t20[1];
              t20 = op;
              break;
            }
            if (t20 && _7.label < t20[2]) {
              _7.label = t20[2];
              _7.ops.push(op);
              break;
            }
            if (t20[2])
              _7.ops.pop();
            _7.trys.pop();
            continue;
        }
        op = body.call(thisArg, _7);
      } catch (e9) {
        op = [6, e9];
        y9 = 0;
      } finally {
        f16 = t20 = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __read(o16, n12) {
  var m10 = typeof Symbol === "function" && o16[Symbol.iterator];
  if (!m10)
    return o16;
  var i15 = m10.call(o16), r15, ar = [], e9;
  try {
    while ((n12 === void 0 || n12-- > 0) && !(r15 = i15.next()).done)
      ar.push(r15.value);
  } catch (error2) {
    e9 = { error: error2 };
  } finally {
    try {
      if (r15 && !r15.done && (m10 = i15["return"]))
        m10.call(i15);
    } finally {
      if (e9)
        throw e9.error;
    }
  }
  return ar;
}
function __spreadArray(to4, from2, pack) {
  if (pack || arguments.length === 2)
    for (var i15 = 0, l14 = from2.length, ar; i15 < l14; i15++) {
      if (ar || !(i15 in from2)) {
        if (!ar)
          ar = Array.prototype.slice.call(from2, 0, i15);
        ar[i15] = from2[i15];
      }
    }
  return to4.concat(ar || Array.prototype.slice.call(from2));
}

// node_modules/downshift/dist/downshift.esm.js
var idCounter = 0;
function cbToCb(cb) {
  return typeof cb === "function" ? cb : noop;
}
function noop() {
}
function scrollIntoView2(node, menuNode) {
  if (!node) {
    return;
  }
  const actions = i2(node, {
    boundary: menuNode,
    block: "nearest",
    scrollMode: "if-needed"
  });
  actions.forEach((_ref) => {
    let {
      el,
      top,
      left
    } = _ref;
    el.scrollTop = top;
    el.scrollLeft = left;
  });
}
function isOrContainsNode(parent2, child, environment) {
  const result = parent2 === child || child instanceof environment.Node && parent2.contains && parent2.contains(child);
  return result;
}
function debounce2(fn2, time) {
  let timeoutId;
  function cancel() {
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
  }
  function wrapper() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    cancel();
    timeoutId = setTimeout(() => {
      timeoutId = null;
      fn2(...args);
    }, time);
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function callAllEventHandlers() {
  for (var _len2 = arguments.length, fns = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    fns[_key2] = arguments[_key2];
  }
  return function(event) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    return fns.some((fn2) => {
      if (fn2) {
        fn2(event, ...args);
      }
      return event.preventDownshiftDefault || event.hasOwnProperty("nativeEvent") && event.nativeEvent.preventDownshiftDefault;
    });
  };
}
function handleRefs() {
  for (var _len4 = arguments.length, refs = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    refs[_key4] = arguments[_key4];
  }
  return (node) => {
    refs.forEach((ref2) => {
      if (typeof ref2 === "function") {
        ref2(node);
      } else if (ref2) {
        ref2.current = node;
      }
    });
  };
}
function generateId() {
  return String(idCounter++);
}
function getA11yStatusMessage$1(_ref2) {
  let {
    isOpen,
    resultCount,
    previousResultCount
  } = _ref2;
  if (!isOpen) {
    return "";
  }
  if (!resultCount) {
    return "No results are available.";
  }
  if (resultCount !== previousResultCount) {
    return `${resultCount} result${resultCount === 1 ? " is" : "s are"} available, use up and down arrow keys to navigate. Press Enter key to select.`;
  }
  return "";
}
function unwrapArray(arg, defaultValue) {
  arg = Array.isArray(arg) ? (
    /* istanbul ignore next (preact) */
    arg[0]
  ) : arg;
  if (!arg && defaultValue) {
    return defaultValue;
  } else {
    return arg;
  }
}
function isDOMElement2(element) {
  return typeof element.type === "string";
}
function getElementProps(element) {
  return element.props;
}
function requiredProp(fnName, propName) {
  console.error(`The property "${propName}" is required in "${fnName}"`);
}
var stateKeys = ["highlightedIndex", "inputValue", "isOpen", "selectedItem", "type"];
function pickState(state) {
  if (state === void 0) {
    state = {};
  }
  const result = {};
  stateKeys.forEach((k3) => {
    if (state.hasOwnProperty(k3)) {
      result[k3] = state[k3];
    }
  });
  return result;
}
function getState(state, props) {
  return Object.keys(state).reduce((prevState, key) => {
    prevState[key] = isControlledProp(props, key) ? props[key] : state[key];
    return prevState;
  }, {});
}
function isControlledProp(props, key) {
  return props[key] !== void 0;
}
function normalizeArrowKey(event) {
  const {
    key,
    keyCode
  } = event;
  if (keyCode >= 37 && keyCode <= 40 && key.indexOf("Arrow") !== 0) {
    return `Arrow${key}`;
  }
  return key;
}
function isPlainObject3(obj) {
  return Object.prototype.toString.call(obj) === "[object Object]";
}
function getNextWrappingIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {
  if (circular === void 0) {
    circular = true;
  }
  if (itemCount === 0) {
    return -1;
  }
  const itemsLastIndex = itemCount - 1;
  if (typeof baseIndex !== "number" || baseIndex < 0 || baseIndex >= itemCount) {
    baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;
  }
  let newIndex = baseIndex + moveAmount;
  if (newIndex < 0) {
    newIndex = circular ? itemsLastIndex : 0;
  } else if (newIndex > itemsLastIndex) {
    newIndex = circular ? 0 : itemsLastIndex;
  }
  const nonDisabledNewIndex = getNextNonDisabledIndex(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular);
  if (nonDisabledNewIndex === -1) {
    return baseIndex >= itemCount ? -1 : baseIndex;
  }
  return nonDisabledNewIndex;
}
function getNextNonDisabledIndex(moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) {
  const currentElementNode = getItemNodeFromIndex(baseIndex);
  if (!currentElementNode || !currentElementNode.hasAttribute("disabled")) {
    return baseIndex;
  }
  if (moveAmount > 0) {
    for (let index2 = baseIndex + 1; index2 < itemCount; index2++) {
      if (!getItemNodeFromIndex(index2).hasAttribute("disabled")) {
        return index2;
      }
    }
  } else {
    for (let index2 = baseIndex - 1; index2 >= 0; index2--) {
      if (!getItemNodeFromIndex(index2).hasAttribute("disabled")) {
        return index2;
      }
    }
  }
  if (circular) {
    return moveAmount > 0 ? getNextNonDisabledIndex(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);
  }
  return -1;
}
function targetWithinDownshift(target, downshiftElements, environment, checkActiveElement) {
  if (checkActiveElement === void 0) {
    checkActiveElement = true;
  }
  return downshiftElements.some((contextNode) => contextNode && (isOrContainsNode(contextNode, target, environment) || checkActiveElement && isOrContainsNode(contextNode, environment.document.activeElement, environment)));
}
var validateControlledUnchanged = noop;
if (true) {
  validateControlledUnchanged = (state, prevProps, nextProps) => {
    const warningDescription = `This prop should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled Downshift element for the lifetime of the component. More info: https://github.com/downshift-js/downshift#control-props`;
    Object.keys(state).forEach((propKey) => {
      if (prevProps[propKey] !== void 0 && nextProps[propKey] === void 0) {
        console.error(`downshift: A component has changed the controlled prop "${propKey}" to be uncontrolled. ${warningDescription}`);
      } else if (prevProps[propKey] === void 0 && nextProps[propKey] !== void 0) {
        console.error(`downshift: A component has changed the uncontrolled prop "${propKey}" to be controlled. ${warningDescription}`);
      }
    });
  };
}
var cleanupStatus = debounce2((documentProp) => {
  getStatusDiv(documentProp).textContent = "";
}, 500);
function setStatus(status, documentProp) {
  const div = getStatusDiv(documentProp);
  if (!status) {
    return;
  }
  div.textContent = status;
  cleanupStatus(documentProp);
}
function getStatusDiv(documentProp) {
  if (documentProp === void 0) {
    documentProp = document;
  }
  let statusDiv = documentProp.getElementById("a11y-status-message");
  if (statusDiv) {
    return statusDiv;
  }
  statusDiv = documentProp.createElement("div");
  statusDiv.setAttribute("id", "a11y-status-message");
  statusDiv.setAttribute("role", "status");
  statusDiv.setAttribute("aria-live", "polite");
  statusDiv.setAttribute("aria-relevant", "additions text");
  Object.assign(statusDiv.style, {
    border: "0",
    clip: "rect(0 0 0 0)",
    height: "1px",
    margin: "-1px",
    overflow: "hidden",
    padding: "0",
    position: "absolute",
    width: "1px"
  });
  documentProp.body.appendChild(statusDiv);
  return statusDiv;
}
var unknown = true ? "__autocomplete_unknown__" : 0;
var mouseUp = true ? "__autocomplete_mouseup__" : 1;
var itemMouseEnter = true ? "__autocomplete_item_mouseenter__" : 2;
var keyDownArrowUp = true ? "__autocomplete_keydown_arrow_up__" : 3;
var keyDownArrowDown = true ? "__autocomplete_keydown_arrow_down__" : 4;
var keyDownEscape = true ? "__autocomplete_keydown_escape__" : 5;
var keyDownEnter = true ? "__autocomplete_keydown_enter__" : 6;
var keyDownHome = true ? "__autocomplete_keydown_home__" : 7;
var keyDownEnd = true ? "__autocomplete_keydown_end__" : 8;
var clickItem = true ? "__autocomplete_click_item__" : 9;
var blurInput = true ? "__autocomplete_blur_input__" : 10;
var changeInput = true ? "__autocomplete_change_input__" : 11;
var keyDownSpaceButton = true ? "__autocomplete_keydown_space_button__" : 12;
var clickButton = true ? "__autocomplete_click_button__" : 13;
var blurButton = true ? "__autocomplete_blur_button__" : 14;
var controlledPropUpdatedSelectedItem = true ? "__autocomplete_controlled_prop_updated_selected_item__" : 15;
var touchEnd = true ? "__autocomplete_touchend__" : 16;
var stateChangeTypes$3 = Object.freeze({
  __proto__: null,
  unknown,
  mouseUp,
  itemMouseEnter,
  keyDownArrowUp,
  keyDownArrowDown,
  keyDownEscape,
  keyDownEnter,
  keyDownHome,
  keyDownEnd,
  clickItem,
  blurInput,
  changeInput,
  keyDownSpaceButton,
  clickButton,
  blurButton,
  controlledPropUpdatedSelectedItem,
  touchEnd
});
var Downshift = (() => {
  class Downshift2 extends import_react8.Component {
    constructor(_props) {
      var _this;
      super(_props);
      _this = this;
      this.id = this.props.id || `downshift-${generateId()}`;
      this.menuId = this.props.menuId || `${this.id}-menu`;
      this.labelId = this.props.labelId || `${this.id}-label`;
      this.inputId = this.props.inputId || `${this.id}-input`;
      this.getItemId = this.props.getItemId || ((index2) => `${this.id}-item-${index2}`);
      this.input = null;
      this.items = [];
      this.itemCount = null;
      this.previousResultCount = 0;
      this.timeoutIds = [];
      this.internalSetTimeout = (fn2, time) => {
        const id = setTimeout(() => {
          this.timeoutIds = this.timeoutIds.filter((i15) => i15 !== id);
          fn2();
        }, time);
        this.timeoutIds.push(id);
      };
      this.setItemCount = (count2) => {
        this.itemCount = count2;
      };
      this.unsetItemCount = () => {
        this.itemCount = null;
      };
      this.setHighlightedIndex = function(highlightedIndex, otherStateToSet) {
        if (highlightedIndex === void 0) {
          highlightedIndex = _this.props.defaultHighlightedIndex;
        }
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState({
          highlightedIndex,
          ...otherStateToSet
        });
      };
      this.clearSelection = (cb) => {
        this.internalSetState({
          selectedItem: null,
          inputValue: "",
          highlightedIndex: this.props.defaultHighlightedIndex,
          isOpen: this.props.defaultIsOpen
        }, cb);
      };
      this.selectItem = (item, otherStateToSet, cb) => {
        otherStateToSet = pickState(otherStateToSet);
        this.internalSetState({
          isOpen: this.props.defaultIsOpen,
          highlightedIndex: this.props.defaultHighlightedIndex,
          selectedItem: item,
          inputValue: this.props.itemToString(item),
          ...otherStateToSet
        }, cb);
      };
      this.selectItemAtIndex = (itemIndex, otherStateToSet, cb) => {
        const item = this.items[itemIndex];
        if (item == null) {
          return;
        }
        this.selectItem(item, otherStateToSet, cb);
      };
      this.selectHighlightedItem = (otherStateToSet, cb) => {
        return this.selectItemAtIndex(this.getState().highlightedIndex, otherStateToSet, cb);
      };
      this.internalSetState = (stateToSet, cb) => {
        let isItemSelected, onChangeArg;
        const onStateChangeArg = {};
        const isStateToSetFunction = typeof stateToSet === "function";
        if (!isStateToSetFunction && stateToSet.hasOwnProperty("inputValue")) {
          this.props.onInputValueChange(stateToSet.inputValue, {
            ...this.getStateAndHelpers(),
            ...stateToSet
          });
        }
        return this.setState((state) => {
          state = this.getState(state);
          let newStateToSet = isStateToSetFunction ? stateToSet(state) : stateToSet;
          newStateToSet = this.props.stateReducer(state, newStateToSet);
          isItemSelected = newStateToSet.hasOwnProperty("selectedItem");
          const nextState = {};
          if (isItemSelected && newStateToSet.selectedItem !== state.selectedItem) {
            onChangeArg = newStateToSet.selectedItem;
          }
          newStateToSet.type = newStateToSet.type || unknown;
          Object.keys(newStateToSet).forEach((key) => {
            if (state[key] !== newStateToSet[key]) {
              onStateChangeArg[key] = newStateToSet[key];
            }
            if (key === "type") {
              return;
            }
            newStateToSet[key];
            if (!isControlledProp(this.props, key)) {
              nextState[key] = newStateToSet[key];
            }
          });
          if (isStateToSetFunction && newStateToSet.hasOwnProperty("inputValue")) {
            this.props.onInputValueChange(newStateToSet.inputValue, {
              ...this.getStateAndHelpers(),
              ...newStateToSet
            });
          }
          return nextState;
        }, () => {
          cbToCb(cb)();
          const hasMoreStateThanType = Object.keys(onStateChangeArg).length > 1;
          if (hasMoreStateThanType) {
            this.props.onStateChange(onStateChangeArg, this.getStateAndHelpers());
          }
          if (isItemSelected) {
            this.props.onSelect(stateToSet.selectedItem, this.getStateAndHelpers());
          }
          if (onChangeArg !== void 0) {
            this.props.onChange(onChangeArg, this.getStateAndHelpers());
          }
          this.props.onUserAction(onStateChangeArg, this.getStateAndHelpers());
        });
      };
      this.rootRef = (node) => this._rootNode = node;
      this.getRootProps = function(_temp, _temp2) {
        let {
          refKey = "ref",
          ref: ref2,
          ...rest
        } = _temp === void 0 ? {} : _temp;
        let {
          suppressRefError = false
        } = _temp2 === void 0 ? {} : _temp2;
        _this.getRootProps.called = true;
        _this.getRootProps.refKey = refKey;
        _this.getRootProps.suppressRefError = suppressRefError;
        const {
          isOpen
        } = _this.getState();
        return {
          [refKey]: handleRefs(ref2, _this.rootRef),
          role: "combobox",
          "aria-expanded": isOpen,
          "aria-haspopup": "listbox",
          "aria-owns": isOpen ? _this.menuId : null,
          "aria-labelledby": _this.labelId,
          ...rest
        };
      };
      this.keyDownHandlers = {
        ArrowDown(event) {
          event.preventDefault();
          if (this.getState().isOpen) {
            const amount = event.shiftKey ? 5 : 1;
            this.moveHighlightedIndex(amount, {
              type: keyDownArrowDown
            });
          } else {
            this.internalSetState({
              isOpen: true,
              type: keyDownArrowDown
            }, () => {
              const itemCount = this.getItemCount();
              if (itemCount > 0) {
                const {
                  highlightedIndex
                } = this.getState();
                const nextHighlightedIndex = getNextWrappingIndex(1, highlightedIndex, itemCount, (index2) => this.getItemNodeFromIndex(index2));
                this.setHighlightedIndex(nextHighlightedIndex, {
                  type: keyDownArrowDown
                });
              }
            });
          }
        },
        ArrowUp(event) {
          event.preventDefault();
          if (this.getState().isOpen) {
            const amount = event.shiftKey ? -5 : -1;
            this.moveHighlightedIndex(amount, {
              type: keyDownArrowUp
            });
          } else {
            this.internalSetState({
              isOpen: true,
              type: keyDownArrowUp
            }, () => {
              const itemCount = this.getItemCount();
              if (itemCount > 0) {
                const {
                  highlightedIndex
                } = this.getState();
                const nextHighlightedIndex = getNextWrappingIndex(-1, highlightedIndex, itemCount, (index2) => this.getItemNodeFromIndex(index2));
                this.setHighlightedIndex(nextHighlightedIndex, {
                  type: keyDownArrowUp
                });
              }
            });
          }
        },
        Enter(event) {
          if (event.which === 229) {
            return;
          }
          const {
            isOpen,
            highlightedIndex
          } = this.getState();
          if (isOpen && highlightedIndex != null) {
            event.preventDefault();
            const item = this.items[highlightedIndex];
            const itemNode = this.getItemNodeFromIndex(highlightedIndex);
            if (item == null || itemNode && itemNode.hasAttribute("disabled")) {
              return;
            }
            this.selectHighlightedItem({
              type: keyDownEnter
            });
          }
        },
        Escape(event) {
          event.preventDefault();
          this.reset({
            type: keyDownEscape,
            ...!this.state.isOpen && {
              selectedItem: null,
              inputValue: ""
            }
          });
        }
      };
      this.buttonKeyDownHandlers = {
        ...this.keyDownHandlers,
        " "(event) {
          event.preventDefault();
          this.toggleMenu({
            type: keyDownSpaceButton
          });
        }
      };
      this.inputKeyDownHandlers = {
        ...this.keyDownHandlers,
        Home(event) {
          const {
            isOpen
          } = this.getState();
          if (!isOpen) {
            return;
          }
          event.preventDefault();
          const itemCount = this.getItemCount();
          if (itemCount <= 0 || !isOpen) {
            return;
          }
          const newHighlightedIndex = getNextNonDisabledIndex(1, 0, itemCount, (index2) => this.getItemNodeFromIndex(index2), false);
          this.setHighlightedIndex(newHighlightedIndex, {
            type: keyDownHome
          });
        },
        End(event) {
          const {
            isOpen
          } = this.getState();
          if (!isOpen) {
            return;
          }
          event.preventDefault();
          const itemCount = this.getItemCount();
          if (itemCount <= 0 || !isOpen) {
            return;
          }
          const newHighlightedIndex = getNextNonDisabledIndex(-1, itemCount - 1, itemCount, (index2) => this.getItemNodeFromIndex(index2), false);
          this.setHighlightedIndex(newHighlightedIndex, {
            type: keyDownEnd
          });
        }
      };
      this.getToggleButtonProps = function(_temp3) {
        let {
          onClick,
          onPress,
          onKeyDown,
          onKeyUp,
          onBlur,
          ...rest
        } = _temp3 === void 0 ? {} : _temp3;
        const {
          isOpen
        } = _this.getState();
        const enabledEventHandlers = {
          onClick: callAllEventHandlers(onClick, _this.buttonHandleClick),
          onKeyDown: callAllEventHandlers(onKeyDown, _this.buttonHandleKeyDown),
          onKeyUp: callAllEventHandlers(onKeyUp, _this.buttonHandleKeyUp),
          onBlur: callAllEventHandlers(onBlur, _this.buttonHandleBlur)
        };
        const eventHandlers = rest.disabled ? {} : enabledEventHandlers;
        return {
          type: "button",
          role: "button",
          "aria-label": isOpen ? "close menu" : "open menu",
          "aria-haspopup": true,
          "data-toggle": true,
          ...eventHandlers,
          ...rest
        };
      };
      this.buttonHandleKeyUp = (event) => {
        event.preventDefault();
      };
      this.buttonHandleKeyDown = (event) => {
        const key = normalizeArrowKey(event);
        if (this.buttonKeyDownHandlers[key]) {
          this.buttonKeyDownHandlers[key].call(this, event);
        }
      };
      this.buttonHandleClick = (event) => {
        event.preventDefault();
        if (this.props.environment.document.activeElement === this.props.environment.document.body) {
          event.target.focus();
        }
        if (false) {
          this.toggleMenu({
            type: clickButton
          });
        } else {
          this.internalSetTimeout(() => this.toggleMenu({
            type: clickButton
          }));
        }
      };
      this.buttonHandleBlur = (event) => {
        const blurTarget = event.target;
        this.internalSetTimeout(() => {
          if (!this.isMouseDown && (this.props.environment.document.activeElement == null || this.props.environment.document.activeElement.id !== this.inputId) && this.props.environment.document.activeElement !== blurTarget) {
            this.reset({
              type: blurButton
            });
          }
        });
      };
      this.getLabelProps = (props) => {
        return {
          htmlFor: this.inputId,
          id: this.labelId,
          ...props
        };
      };
      this.getInputProps = function(_temp4) {
        let {
          onKeyDown,
          onBlur,
          onChange,
          onInput,
          onChangeText,
          ...rest
        } = _temp4 === void 0 ? {} : _temp4;
        let onChangeKey;
        let eventHandlers = {};
        {
          onChangeKey = "onChange";
        }
        const {
          inputValue,
          isOpen,
          highlightedIndex
        } = _this.getState();
        if (!rest.disabled) {
          eventHandlers = {
            [onChangeKey]: callAllEventHandlers(onChange, onInput, _this.inputHandleChange),
            onKeyDown: callAllEventHandlers(onKeyDown, _this.inputHandleKeyDown),
            onBlur: callAllEventHandlers(onBlur, _this.inputHandleBlur)
          };
        }
        return {
          "aria-autocomplete": "list",
          "aria-activedescendant": isOpen && typeof highlightedIndex === "number" && highlightedIndex >= 0 ? _this.getItemId(highlightedIndex) : null,
          "aria-controls": isOpen ? _this.menuId : null,
          "aria-labelledby": _this.labelId,
          // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion
          // revert back since autocomplete="nope" is ignored on latest Chrome and Opera
          autoComplete: "off",
          value: inputValue,
          id: _this.inputId,
          ...eventHandlers,
          ...rest
        };
      };
      this.inputHandleKeyDown = (event) => {
        const key = normalizeArrowKey(event);
        if (key && this.inputKeyDownHandlers[key]) {
          this.inputKeyDownHandlers[key].call(this, event);
        }
      };
      this.inputHandleChange = (event) => {
        this.internalSetState({
          type: changeInput,
          isOpen: true,
          inputValue: event.target.value,
          highlightedIndex: this.props.defaultHighlightedIndex
        });
      };
      this.inputHandleBlur = () => {
        this.internalSetTimeout(() => {
          const downshiftButtonIsActive = this.props.environment.document && !!this.props.environment.document.activeElement && !!this.props.environment.document.activeElement.dataset && this.props.environment.document.activeElement.dataset.toggle && this._rootNode && this._rootNode.contains(this.props.environment.document.activeElement);
          if (!this.isMouseDown && !downshiftButtonIsActive) {
            this.reset({
              type: blurInput
            });
          }
        });
      };
      this.menuRef = (node) => {
        this._menuNode = node;
      };
      this.getMenuProps = function(_temp5, _temp6) {
        let {
          refKey = "ref",
          ref: ref2,
          ...props
        } = _temp5 === void 0 ? {} : _temp5;
        let {
          suppressRefError = false
        } = _temp6 === void 0 ? {} : _temp6;
        _this.getMenuProps.called = true;
        _this.getMenuProps.refKey = refKey;
        _this.getMenuProps.suppressRefError = suppressRefError;
        return {
          [refKey]: handleRefs(ref2, _this.menuRef),
          role: "listbox",
          "aria-labelledby": props && props["aria-label"] ? null : _this.labelId,
          id: _this.menuId,
          ...props
        };
      };
      this.getItemProps = function(_temp7) {
        let {
          onMouseMove,
          onMouseDown,
          onClick,
          onPress,
          index: index2,
          item = false ? (
            /* istanbul ignore next */
            void 0
          ) : requiredProp("getItemProps", "item"),
          ...rest
        } = _temp7 === void 0 ? {} : _temp7;
        if (index2 === void 0) {
          _this.items.push(item);
          index2 = _this.items.indexOf(item);
        } else {
          _this.items[index2] = item;
        }
        const onSelectKey = "onClick";
        const customClickHandler = onClick;
        const enabledEventHandlers = {
          // onMouseMove is used over onMouseEnter here. onMouseMove
          // is only triggered on actual mouse movement while onMouseEnter
          // can fire on DOM changes, interrupting keyboard navigation
          onMouseMove: callAllEventHandlers(onMouseMove, () => {
            if (index2 === _this.getState().highlightedIndex) {
              return;
            }
            _this.setHighlightedIndex(index2, {
              type: itemMouseEnter
            });
            _this.avoidScrolling = true;
            _this.internalSetTimeout(() => _this.avoidScrolling = false, 250);
          }),
          onMouseDown: callAllEventHandlers(onMouseDown, (event) => {
            event.preventDefault();
          }),
          [onSelectKey]: callAllEventHandlers(customClickHandler, () => {
            _this.selectItemAtIndex(index2, {
              type: clickItem
            });
          })
        };
        const eventHandlers = rest.disabled ? {
          onMouseDown: enabledEventHandlers.onMouseDown
        } : enabledEventHandlers;
        return {
          id: _this.getItemId(index2),
          role: "option",
          "aria-selected": _this.getState().highlightedIndex === index2,
          ...eventHandlers,
          ...rest
        };
      };
      this.clearItems = () => {
        this.items = [];
      };
      this.reset = function(otherStateToSet, cb) {
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState((_ref) => {
          let {
            selectedItem
          } = _ref;
          return {
            isOpen: _this.props.defaultIsOpen,
            highlightedIndex: _this.props.defaultHighlightedIndex,
            inputValue: _this.props.itemToString(selectedItem),
            ...otherStateToSet
          };
        }, cb);
      };
      this.toggleMenu = function(otherStateToSet, cb) {
        if (otherStateToSet === void 0) {
          otherStateToSet = {};
        }
        otherStateToSet = pickState(otherStateToSet);
        _this.internalSetState((_ref2) => {
          let {
            isOpen
          } = _ref2;
          return {
            isOpen: !isOpen,
            ...isOpen && {
              highlightedIndex: _this.props.defaultHighlightedIndex
            },
            ...otherStateToSet
          };
        }, () => {
          const {
            isOpen,
            highlightedIndex
          } = _this.getState();
          if (isOpen) {
            if (_this.getItemCount() > 0 && typeof highlightedIndex === "number") {
              _this.setHighlightedIndex(highlightedIndex, otherStateToSet);
            }
          }
          cbToCb(cb)();
        });
      };
      this.openMenu = (cb) => {
        this.internalSetState({
          isOpen: true
        }, cb);
      };
      this.closeMenu = (cb) => {
        this.internalSetState({
          isOpen: false
        }, cb);
      };
      this.updateStatus = debounce2(() => {
        const state = this.getState();
        const item = this.items[state.highlightedIndex];
        const resultCount = this.getItemCount();
        const status = this.props.getA11yStatusMessage({
          itemToString: this.props.itemToString,
          previousResultCount: this.previousResultCount,
          resultCount,
          highlightedItem: item,
          ...state
        });
        this.previousResultCount = resultCount;
        setStatus(status, this.props.environment.document);
      }, 200);
      const {
        defaultHighlightedIndex,
        initialHighlightedIndex: _highlightedIndex = defaultHighlightedIndex,
        defaultIsOpen,
        initialIsOpen: _isOpen = defaultIsOpen,
        initialInputValue: _inputValue = "",
        initialSelectedItem: _selectedItem = null
      } = this.props;
      const _state = this.getState({
        highlightedIndex: _highlightedIndex,
        isOpen: _isOpen,
        inputValue: _inputValue,
        selectedItem: _selectedItem
      });
      if (_state.selectedItem != null && this.props.initialInputValue === void 0) {
        _state.inputValue = this.props.itemToString(_state.selectedItem);
      }
      this.state = _state;
    }
    /**
     * Clear all running timeouts
     */
    internalClearTimeouts() {
      this.timeoutIds.forEach((id) => {
        clearTimeout(id);
      });
      this.timeoutIds = [];
    }
    /**
     * Gets the state based on internal state or props
     * If a state value is passed via props, then that
     * is the value given, otherwise it's retrieved from
     * stateToMerge
     *
     * @param {Object} stateToMerge defaults to this.state
     * @return {Object} the state
     */
    getState(stateToMerge) {
      if (stateToMerge === void 0) {
        stateToMerge = this.state;
      }
      return getState(stateToMerge, this.props);
    }
    getItemCount() {
      let itemCount = this.items.length;
      if (this.itemCount != null) {
        itemCount = this.itemCount;
      } else if (this.props.itemCount !== void 0) {
        itemCount = this.props.itemCount;
      }
      return itemCount;
    }
    getItemNodeFromIndex(index2) {
      return this.props.environment.document.getElementById(this.getItemId(index2));
    }
    scrollHighlightedItemIntoView() {
      {
        const node = this.getItemNodeFromIndex(this.getState().highlightedIndex);
        this.props.scrollIntoView(node, this._menuNode);
      }
    }
    moveHighlightedIndex(amount, otherStateToSet) {
      const itemCount = this.getItemCount();
      const {
        highlightedIndex
      } = this.getState();
      if (itemCount > 0) {
        const nextHighlightedIndex = getNextWrappingIndex(amount, highlightedIndex, itemCount, (index2) => this.getItemNodeFromIndex(index2));
        this.setHighlightedIndex(nextHighlightedIndex, otherStateToSet);
      }
    }
    getStateAndHelpers() {
      const {
        highlightedIndex,
        inputValue,
        selectedItem,
        isOpen
      } = this.getState();
      const {
        itemToString: itemToString2
      } = this.props;
      const {
        id
      } = this;
      const {
        getRootProps,
        getToggleButtonProps,
        getLabelProps,
        getMenuProps,
        getInputProps,
        getItemProps,
        openMenu,
        closeMenu,
        toggleMenu,
        selectItem,
        selectItemAtIndex,
        selectHighlightedItem,
        setHighlightedIndex,
        clearSelection,
        clearItems,
        reset,
        setItemCount,
        unsetItemCount,
        internalSetState: setState
      } = this;
      return {
        // prop getters
        getRootProps,
        getToggleButtonProps,
        getLabelProps,
        getMenuProps,
        getInputProps,
        getItemProps,
        // actions
        reset,
        openMenu,
        closeMenu,
        toggleMenu,
        selectItem,
        selectItemAtIndex,
        selectHighlightedItem,
        setHighlightedIndex,
        clearSelection,
        clearItems,
        setItemCount,
        unsetItemCount,
        setState,
        // props
        itemToString: itemToString2,
        // derived
        id,
        // state
        highlightedIndex,
        inputValue,
        isOpen,
        selectedItem
      };
    }
    //////////////////////////// ROOT
    componentDidMount() {
      if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
        validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
      }
      {
        const onMouseDown = () => {
          this.isMouseDown = true;
        };
        const onMouseUp = (event) => {
          this.isMouseDown = false;
          const contextWithinDownshift = targetWithinDownshift(event.target, [this._rootNode, this._menuNode], this.props.environment);
          if (!contextWithinDownshift && this.getState().isOpen) {
            this.reset({
              type: mouseUp
            }, () => this.props.onOuterClick(this.getStateAndHelpers()));
          }
        };
        const onTouchStart = () => {
          this.isTouchMove = false;
        };
        const onTouchMove = () => {
          this.isTouchMove = true;
        };
        const onTouchEnd = (event) => {
          const contextWithinDownshift = targetWithinDownshift(event.target, [this._rootNode, this._menuNode], this.props.environment, false);
          if (!this.isTouchMove && !contextWithinDownshift && this.getState().isOpen) {
            this.reset({
              type: touchEnd
            }, () => this.props.onOuterClick(this.getStateAndHelpers()));
          }
        };
        const {
          environment
        } = this.props;
        environment.addEventListener("mousedown", onMouseDown);
        environment.addEventListener("mouseup", onMouseUp);
        environment.addEventListener("touchstart", onTouchStart);
        environment.addEventListener("touchmove", onTouchMove);
        environment.addEventListener("touchend", onTouchEnd);
        this.cleanup = () => {
          this.internalClearTimeouts();
          this.updateStatus.cancel();
          environment.removeEventListener("mousedown", onMouseDown);
          environment.removeEventListener("mouseup", onMouseUp);
          environment.removeEventListener("touchstart", onTouchStart);
          environment.removeEventListener("touchmove", onTouchMove);
          environment.removeEventListener("touchend", onTouchEnd);
        };
      }
    }
    shouldScroll(prevState, prevProps) {
      const {
        highlightedIndex: currentHighlightedIndex
      } = this.props.highlightedIndex === void 0 ? this.getState() : this.props;
      const {
        highlightedIndex: prevHighlightedIndex
      } = prevProps.highlightedIndex === void 0 ? prevState : prevProps;
      const scrollWhenOpen = currentHighlightedIndex && this.getState().isOpen && !prevState.isOpen;
      const scrollWhenNavigating = currentHighlightedIndex !== prevHighlightedIndex;
      return scrollWhenOpen || scrollWhenNavigating;
    }
    componentDidUpdate(prevProps, prevState) {
      if (true) {
        validateControlledUnchanged(this.state, prevProps, this.props);
        if (this.getMenuProps.called && !this.getMenuProps.suppressRefError) {
          validateGetMenuPropsCalledCorrectly(this._menuNode, this.getMenuProps);
        }
      }
      if (isControlledProp(this.props, "selectedItem") && this.props.selectedItemChanged(prevProps.selectedItem, this.props.selectedItem)) {
        this.internalSetState({
          type: controlledPropUpdatedSelectedItem,
          inputValue: this.props.itemToString(this.props.selectedItem)
        });
      }
      if (!this.avoidScrolling && this.shouldScroll(prevState, prevProps)) {
        this.scrollHighlightedItemIntoView();
      }
      {
        this.updateStatus();
      }
    }
    componentWillUnmount() {
      this.cleanup();
    }
    render() {
      const children = unwrapArray(this.props.children, noop);
      this.clearItems();
      this.getRootProps.called = false;
      this.getRootProps.refKey = void 0;
      this.getRootProps.suppressRefError = void 0;
      this.getMenuProps.called = false;
      this.getMenuProps.refKey = void 0;
      this.getMenuProps.suppressRefError = void 0;
      this.getLabelProps.called = false;
      this.getInputProps.called = false;
      const element = unwrapArray(children(this.getStateAndHelpers()));
      if (!element) {
        return null;
      }
      if (this.getRootProps.called || this.props.suppressRefError) {
        if (!this.getRootProps.suppressRefError && !this.props.suppressRefError) {
          validateGetRootPropsCalledCorrectly(element, this.getRootProps);
        }
        return element;
      } else if (isDOMElement2(element)) {
        return (0, import_react8.cloneElement)(element, this.getRootProps(getElementProps(element)));
      }
      if (true) {
        throw new Error("downshift: If you return a non-DOM element, you must apply the getRootProps function");
      }
      return void 0;
    }
  }
  Downshift2.defaultProps = {
    defaultHighlightedIndex: null,
    defaultIsOpen: false,
    getA11yStatusMessage: getA11yStatusMessage$1,
    itemToString: (i15) => {
      if (i15 == null) {
        return "";
      }
      if (isPlainObject3(i15) && !i15.hasOwnProperty("toString")) {
        console.warn("downshift: An object was passed to the default implementation of `itemToString`. You should probably provide your own `itemToString` implementation. Please refer to the `itemToString` API documentation.", "The object that was passed:", i15);
      }
      return String(i15);
    },
    onStateChange: noop,
    onInputValueChange: noop,
    onUserAction: noop,
    onChange: noop,
    onSelect: noop,
    onOuterClick: noop,
    selectedItemChanged: (prevItem, item) => prevItem !== item,
    environment: (
      /* istanbul ignore next (ssr) */
      typeof window === "undefined" ? {} : window
    ),
    stateReducer: (state, stateToSet) => stateToSet,
    suppressRefError: false,
    scrollIntoView: scrollIntoView2
  };
  Downshift2.stateChangeTypes = stateChangeTypes$3;
  return Downshift2;
})();
true ? Downshift.propTypes = {
  children: import_prop_types.default.func,
  defaultHighlightedIndex: import_prop_types.default.number,
  defaultIsOpen: import_prop_types.default.bool,
  initialHighlightedIndex: import_prop_types.default.number,
  initialSelectedItem: import_prop_types.default.any,
  initialInputValue: import_prop_types.default.string,
  initialIsOpen: import_prop_types.default.bool,
  getA11yStatusMessage: import_prop_types.default.func,
  itemToString: import_prop_types.default.func,
  onChange: import_prop_types.default.func,
  onSelect: import_prop_types.default.func,
  onStateChange: import_prop_types.default.func,
  onInputValueChange: import_prop_types.default.func,
  onUserAction: import_prop_types.default.func,
  onOuterClick: import_prop_types.default.func,
  selectedItemChanged: import_prop_types.default.func,
  stateReducer: import_prop_types.default.func,
  itemCount: import_prop_types.default.number,
  id: import_prop_types.default.string,
  environment: import_prop_types.default.shape({
    addEventListener: import_prop_types.default.func,
    removeEventListener: import_prop_types.default.func,
    document: import_prop_types.default.shape({
      getElementById: import_prop_types.default.func,
      activeElement: import_prop_types.default.any,
      body: import_prop_types.default.any
    })
  }),
  suppressRefError: import_prop_types.default.bool,
  scrollIntoView: import_prop_types.default.func,
  // things we keep in state for uncontrolled components
  // but can accept as props for controlled components
  /* eslint-disable react/no-unused-prop-types */
  selectedItem: import_prop_types.default.any,
  isOpen: import_prop_types.default.bool,
  inputValue: import_prop_types.default.string,
  highlightedIndex: import_prop_types.default.number,
  labelId: import_prop_types.default.string,
  inputId: import_prop_types.default.string,
  menuId: import_prop_types.default.string,
  getItemId: import_prop_types.default.func
  /* eslint-enable react/no-unused-prop-types */
} : void 0;
function validateGetMenuPropsCalledCorrectly(node, _ref3) {
  let {
    refKey
  } = _ref3;
  if (!node) {
    console.error(`downshift: The ref prop "${refKey}" from getMenuProps was not applied correctly on your menu element.`);
  }
}
function validateGetRootPropsCalledCorrectly(element, _ref4) {
  let {
    refKey
  } = _ref4;
  const refKeySpecified = refKey !== "ref";
  const isComposite = !isDOMElement2(element);
  if (isComposite && !refKeySpecified && !(0, import_react_is.isForwardRef)(element)) {
    console.error("downshift: You returned a non-DOM element. You must specify a refKey in getRootProps");
  } else if (!isComposite && refKeySpecified) {
    console.error(`downshift: You returned a DOM element. You should not specify a refKey in getRootProps. You specified "${refKey}"`);
  }
  if (!(0, import_react_is.isForwardRef)(element) && !getElementProps(element)[refKey]) {
    console.error(`downshift: You must apply the ref prop "${refKey}" from getRootProps onto your root element.`);
  }
}
var dropdownDefaultStateValues = {
  highlightedIndex: -1,
  isOpen: false,
  selectedItem: null,
  inputValue: ""
};
function callOnChangeProps(action, state, newState) {
  const {
    props,
    type
  } = action;
  const changes = {};
  Object.keys(state).forEach((key) => {
    invokeOnChangeHandler(key, action, state, newState);
    if (newState[key] !== state[key]) {
      changes[key] = newState[key];
    }
  });
  if (props.onStateChange && Object.keys(changes).length) {
    props.onStateChange({
      type,
      ...changes
    });
  }
}
function invokeOnChangeHandler(key, action, state, newState) {
  const {
    props,
    type
  } = action;
  const handler = `on${capitalizeString(key)}Change`;
  if (props[handler] && newState[key] !== void 0 && newState[key] !== state[key]) {
    props[handler]({
      type,
      ...newState
    });
  }
}
function stateReducer(s20, a13) {
  return a13.changes;
}
function getA11ySelectionMessage(selectionParameters) {
  const {
    selectedItem,
    itemToString: itemToStringLocal
  } = selectionParameters;
  return selectedItem ? `${itemToStringLocal(selectedItem)} has been selected.` : "";
}
var updateA11yStatus = debounce2((getA11yMessage, document2) => {
  setStatus(getA11yMessage(), document2);
}, 200);
var useIsomorphicLayoutEffect3 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? import_react8.useLayoutEffect : import_react8.useEffect;
function useElementIds(_ref) {
  let {
    id = `downshift-${generateId()}`,
    labelId,
    menuId,
    getItemId,
    toggleButtonId,
    inputId
  } = _ref;
  const elementIdsRef = (0, import_react8.useRef)({
    labelId: labelId || `${id}-label`,
    menuId: menuId || `${id}-menu`,
    getItemId: getItemId || ((index2) => `${id}-item-${index2}`),
    toggleButtonId: toggleButtonId || `${id}-toggle-button`,
    inputId: inputId || `${id}-input`
  });
  return elementIdsRef.current;
}
function getItemIndex(index2, item, items) {
  if (index2 !== void 0) {
    return index2;
  }
  if (items.length === 0) {
    return -1;
  }
  return items.indexOf(item);
}
function itemToString(item) {
  return item ? String(item) : "";
}
function isAcceptedCharacterKey(key) {
  return /^\S{1}$/.test(key);
}
function capitalizeString(string2) {
  return `${string2.slice(0, 1).toUpperCase()}${string2.slice(1)}`;
}
function useLatestRef(val) {
  const ref2 = (0, import_react8.useRef)(val);
  ref2.current = val;
  return ref2;
}
function useEnhancedReducer(reducer3, initialState2, props) {
  const prevStateRef = (0, import_react8.useRef)();
  const actionRef = (0, import_react8.useRef)();
  const enhancedReducer = (0, import_react8.useCallback)((state2, action2) => {
    actionRef.current = action2;
    state2 = getState(state2, action2.props);
    const changes = reducer3(state2, action2);
    const newState = action2.props.stateReducer(state2, {
      ...action2,
      changes
    });
    return newState;
  }, [reducer3]);
  const [state, dispatch] = (0, import_react8.useReducer)(enhancedReducer, initialState2);
  const propsRef = useLatestRef(props);
  const dispatchWithProps = (0, import_react8.useCallback)((action2) => dispatch({
    props: propsRef.current,
    ...action2
  }), [propsRef]);
  const action = actionRef.current;
  (0, import_react8.useEffect)(() => {
    if (action && prevStateRef.current && prevStateRef.current !== state) {
      callOnChangeProps(action, getState(prevStateRef.current, action.props), state);
    }
    prevStateRef.current = state;
  }, [state, props, action]);
  return [state, dispatchWithProps];
}
function useControlledReducer$1(reducer3, initialState2, props) {
  const [state, dispatch] = useEnhancedReducer(reducer3, initialState2, props);
  return [getState(state, props), dispatch];
}
var defaultProps$3 = {
  itemToString,
  stateReducer,
  getA11ySelectionMessage,
  scrollIntoView: scrollIntoView2,
  circularNavigation: false,
  environment: (
    /* istanbul ignore next (ssr) */
    typeof window === "undefined" ? {} : window
  )
};
function getDefaultValue$1(props, propKey, defaultStateValues2) {
  if (defaultStateValues2 === void 0) {
    defaultStateValues2 = dropdownDefaultStateValues;
  }
  const defaultValue = props[`default${capitalizeString(propKey)}`];
  if (defaultValue !== void 0) {
    return defaultValue;
  }
  return defaultStateValues2[propKey];
}
function getInitialValue$1(props, propKey, defaultStateValues2) {
  if (defaultStateValues2 === void 0) {
    defaultStateValues2 = dropdownDefaultStateValues;
  }
  const value = props[propKey];
  if (value !== void 0) {
    return value;
  }
  const initialValue = props[`initial${capitalizeString(propKey)}`];
  if (initialValue !== void 0) {
    return initialValue;
  }
  return getDefaultValue$1(props, propKey, defaultStateValues2);
}
function getInitialState$2(props) {
  const selectedItem = getInitialValue$1(props, "selectedItem");
  const isOpen = getInitialValue$1(props, "isOpen");
  const highlightedIndex = getInitialValue$1(props, "highlightedIndex");
  const inputValue = getInitialValue$1(props, "inputValue");
  return {
    highlightedIndex: highlightedIndex < 0 && selectedItem && isOpen ? props.items.indexOf(selectedItem) : highlightedIndex,
    isOpen,
    selectedItem,
    inputValue
  };
}
function getHighlightedIndexOnOpen(props, state, offset5, getItemNodeFromIndex) {
  const {
    items,
    initialHighlightedIndex,
    defaultHighlightedIndex
  } = props;
  const {
    selectedItem,
    highlightedIndex
  } = state;
  if (items.length === 0) {
    return -1;
  }
  if (initialHighlightedIndex !== void 0 && highlightedIndex === initialHighlightedIndex) {
    return initialHighlightedIndex;
  }
  if (defaultHighlightedIndex !== void 0) {
    return defaultHighlightedIndex;
  }
  if (selectedItem) {
    if (offset5 === 0) {
      return items.indexOf(selectedItem);
    }
    return getNextWrappingIndex(offset5, items.indexOf(selectedItem), items.length, getItemNodeFromIndex, false);
  }
  if (offset5 === 0) {
    return -1;
  }
  return offset5 < 0 ? items.length - 1 : 0;
}
function useMouseAndTouchTracker(isOpen, downshiftElementRefs, environment, handleBlur) {
  const mouseAndTouchTrackersRef = (0, import_react8.useRef)({
    isMouseDown: false,
    isTouchMove: false
  });
  (0, import_react8.useEffect)(() => {
    const onMouseDown = () => {
      mouseAndTouchTrackersRef.current.isMouseDown = true;
    };
    const onMouseUp = (event) => {
      mouseAndTouchTrackersRef.current.isMouseDown = false;
      if (isOpen && !targetWithinDownshift(event.target, downshiftElementRefs.map((ref2) => ref2.current), environment)) {
        handleBlur();
      }
    };
    const onTouchStart = () => {
      mouseAndTouchTrackersRef.current.isTouchMove = false;
    };
    const onTouchMove = () => {
      mouseAndTouchTrackersRef.current.isTouchMove = true;
    };
    const onTouchEnd = (event) => {
      if (isOpen && !mouseAndTouchTrackersRef.current.isTouchMove && !targetWithinDownshift(event.target, downshiftElementRefs.map((ref2) => ref2.current), environment, false)) {
        handleBlur();
      }
    };
    environment.addEventListener("mousedown", onMouseDown);
    environment.addEventListener("mouseup", onMouseUp);
    environment.addEventListener("touchstart", onTouchStart);
    environment.addEventListener("touchmove", onTouchMove);
    environment.addEventListener("touchend", onTouchEnd);
    return function cleanup() {
      environment.removeEventListener("mousedown", onMouseDown);
      environment.removeEventListener("mouseup", onMouseUp);
      environment.removeEventListener("touchstart", onTouchStart);
      environment.removeEventListener("touchmove", onTouchMove);
      environment.removeEventListener("touchend", onTouchEnd);
    };
  }, [isOpen, environment]);
  return mouseAndTouchTrackersRef;
}
var useGetterPropsCalledChecker = () => noop;
if (true) {
  useGetterPropsCalledChecker = function() {
    const isInitialMountRef = (0, import_react8.useRef)(true);
    for (var _len = arguments.length, propKeys = new Array(_len), _key = 0; _key < _len; _key++) {
      propKeys[_key] = arguments[_key];
    }
    const getterPropsCalledRef = (0, import_react8.useRef)(propKeys.reduce((acc, propKey) => {
      acc[propKey] = {};
      return acc;
    }, {}));
    (0, import_react8.useEffect)(() => {
      Object.keys(getterPropsCalledRef.current).forEach((propKey) => {
        const propCallInfo = getterPropsCalledRef.current[propKey];
        if (isInitialMountRef.current) {
          if (!Object.keys(propCallInfo).length) {
            console.error(`downshift: You forgot to call the ${propKey} getter function on your component / element.`);
            return;
          }
        }
        const {
          suppressRefError,
          refKey,
          elementRef
        } = propCallInfo;
        if ((!elementRef || !elementRef.current) && !suppressRefError) {
          console.error(`downshift: The ref prop "${refKey}" from ${propKey} was not applied correctly on your element.`);
        }
      });
      isInitialMountRef.current = false;
    });
    const setGetterPropCallInfo = (0, import_react8.useCallback)((propKey, suppressRefError, refKey, elementRef) => {
      getterPropsCalledRef.current[propKey] = {
        suppressRefError,
        refKey,
        elementRef
      };
    }, []);
    return setGetterPropCallInfo;
  };
}
function useA11yMessageSetter(getA11yMessage, dependencyArray, _ref2) {
  let {
    isInitialMount,
    highlightedIndex,
    items,
    environment,
    ...rest
  } = _ref2;
  (0, import_react8.useEffect)(() => {
    if (isInitialMount || false) {
      return;
    }
    updateA11yStatus(() => getA11yMessage({
      highlightedIndex,
      highlightedItem: items[highlightedIndex],
      resultCount: items.length,
      ...rest
    }), environment.document);
  }, dependencyArray);
}
function useScrollIntoView(_ref3) {
  let {
    highlightedIndex,
    isOpen,
    itemRefs,
    getItemNodeFromIndex,
    menuElement,
    scrollIntoView: scrollIntoViewProp
  } = _ref3;
  const shouldScrollRef = (0, import_react8.useRef)(true);
  useIsomorphicLayoutEffect3(() => {
    if (highlightedIndex < 0 || !isOpen || !Object.keys(itemRefs.current).length) {
      return;
    }
    if (shouldScrollRef.current === false) {
      shouldScrollRef.current = true;
    } else {
      scrollIntoViewProp(getItemNodeFromIndex(highlightedIndex), menuElement);
    }
  }, [highlightedIndex]);
  return shouldScrollRef;
}
var useControlPropsValidator = noop;
if (true) {
  useControlPropsValidator = (_ref4) => {
    let {
      isInitialMount,
      props,
      state
    } = _ref4;
    const prevPropsRef = (0, import_react8.useRef)(props);
    (0, import_react8.useEffect)(() => {
      if (isInitialMount) {
        return;
      }
      validateControlledUnchanged(state, prevPropsRef.current, props);
      prevPropsRef.current = props;
    }, [state, props, isInitialMount]);
  };
}
function downshiftCommonReducer(state, action, stateChangeTypes2) {
  const {
    type,
    props
  } = action;
  let changes;
  switch (type) {
    case stateChangeTypes2.ItemMouseMove:
      changes = {
        highlightedIndex: action.disabled ? -1 : action.index
      };
      break;
    case stateChangeTypes2.MenuMouseLeave:
      changes = {
        highlightedIndex: -1
      };
      break;
    case stateChangeTypes2.ToggleButtonClick:
    case stateChangeTypes2.FunctionToggleMenu:
      changes = {
        isOpen: !state.isOpen,
        highlightedIndex: state.isOpen ? -1 : getHighlightedIndexOnOpen(props, state, 0)
      };
      break;
    case stateChangeTypes2.FunctionOpenMenu:
      changes = {
        isOpen: true,
        highlightedIndex: getHighlightedIndexOnOpen(props, state, 0)
      };
      break;
    case stateChangeTypes2.FunctionCloseMenu:
      changes = {
        isOpen: false
      };
      break;
    case stateChangeTypes2.FunctionSetHighlightedIndex:
      changes = {
        highlightedIndex: action.highlightedIndex
      };
      break;
    case stateChangeTypes2.FunctionSetInputValue:
      changes = {
        inputValue: action.inputValue
      };
      break;
    case stateChangeTypes2.FunctionReset:
      changes = {
        highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
        isOpen: getDefaultValue$1(props, "isOpen"),
        selectedItem: getDefaultValue$1(props, "selectedItem"),
        inputValue: getDefaultValue$1(props, "inputValue")
      };
      break;
    default:
      throw new Error("Reducer called without proper action type.");
  }
  return {
    ...state,
    ...changes
  };
}
function getItemIndexByCharacterKey(_a) {
  var keysSoFar = _a.keysSoFar, highlightedIndex = _a.highlightedIndex, items = _a.items, itemToString2 = _a.itemToString, getItemNodeFromIndex = _a.getItemNodeFromIndex;
  var lowerCasedKeysSoFar = keysSoFar.toLowerCase();
  for (var index2 = 0; index2 < items.length; index2++) {
    var offsetIndex = (index2 + highlightedIndex + 1) % items.length;
    var item = items[offsetIndex];
    if (item !== void 0 && itemToString2(item).toLowerCase().startsWith(lowerCasedKeysSoFar)) {
      var element = getItemNodeFromIndex(offsetIndex);
      if (!(element === null || element === void 0 ? void 0 : element.hasAttribute("disabled"))) {
        return offsetIndex;
      }
    }
  }
  return highlightedIndex;
}
var propTypes$2 = {
  items: import_prop_types.default.array.isRequired,
  itemToString: import_prop_types.default.func,
  getA11yStatusMessage: import_prop_types.default.func,
  getA11ySelectionMessage: import_prop_types.default.func,
  circularNavigation: import_prop_types.default.bool,
  highlightedIndex: import_prop_types.default.number,
  defaultHighlightedIndex: import_prop_types.default.number,
  initialHighlightedIndex: import_prop_types.default.number,
  isOpen: import_prop_types.default.bool,
  defaultIsOpen: import_prop_types.default.bool,
  initialIsOpen: import_prop_types.default.bool,
  selectedItem: import_prop_types.default.any,
  initialSelectedItem: import_prop_types.default.any,
  defaultSelectedItem: import_prop_types.default.any,
  id: import_prop_types.default.string,
  labelId: import_prop_types.default.string,
  menuId: import_prop_types.default.string,
  getItemId: import_prop_types.default.func,
  toggleButtonId: import_prop_types.default.string,
  stateReducer: import_prop_types.default.func,
  onSelectedItemChange: import_prop_types.default.func,
  onHighlightedIndexChange: import_prop_types.default.func,
  onStateChange: import_prop_types.default.func,
  onIsOpenChange: import_prop_types.default.func,
  environment: import_prop_types.default.shape({
    addEventListener: import_prop_types.default.func,
    removeEventListener: import_prop_types.default.func,
    document: import_prop_types.default.shape({
      getElementById: import_prop_types.default.func,
      activeElement: import_prop_types.default.any,
      body: import_prop_types.default.any
    })
  })
};
function getA11yStatusMessage(_a) {
  var isOpen = _a.isOpen, resultCount = _a.resultCount, previousResultCount = _a.previousResultCount;
  if (!isOpen) {
    return "";
  }
  if (!resultCount) {
    return "No results are available.";
  }
  if (resultCount !== previousResultCount) {
    return "".concat(resultCount, " result").concat(resultCount === 1 ? " is" : "s are", " available, use up and down arrow keys to navigate. Press Enter or Space Bar keys to select.");
  }
  return "";
}
var defaultProps$2 = __assign(__assign({}, defaultProps$3), { getA11yStatusMessage });
var validatePropTypes$2 = noop;
if (true) {
  validatePropTypes$2 = function(options, caller) {
    import_prop_types.default.checkPropTypes(propTypes$2, options, "prop", caller.name);
  };
}
var MenuKeyDownArrowDown = true ? "__menu_keydown_arrow_down__" : 0;
var MenuKeyDownArrowUp = true ? "__menu_keydown_arrow_up__" : 1;
var MenuKeyDownEscape = true ? "__menu_keydown_escape__" : 2;
var MenuKeyDownHome = true ? "__menu_keydown_home__" : 3;
var MenuKeyDownEnd = true ? "__menu_keydown_end__" : 4;
var MenuKeyDownEnter = true ? "__menu_keydown_enter__" : 5;
var MenuKeyDownSpaceButton = true ? "__menu_keydown_space_button__" : 6;
var MenuKeyDownCharacter = true ? "__menu_keydown_character__" : 7;
var MenuBlur = true ? "__menu_blur__" : 8;
var MenuMouseLeave$1 = true ? "__menu_mouse_leave__" : 9;
var ItemMouseMove$1 = true ? "__item_mouse_move__" : 10;
var ItemClick$1 = true ? "__item_click__" : 11;
var ToggleButtonClick$1 = true ? "__togglebutton_click__" : 12;
var ToggleButtonKeyDownArrowDown = true ? "__togglebutton_keydown_arrow_down__" : 13;
var ToggleButtonKeyDownArrowUp = true ? "__togglebutton_keydown_arrow_up__" : 14;
var ToggleButtonKeyDownCharacter = true ? "__togglebutton_keydown_character__" : 15;
var FunctionToggleMenu$1 = true ? "__function_toggle_menu__" : 16;
var FunctionOpenMenu$1 = true ? "__function_open_menu__" : 17;
var FunctionCloseMenu$1 = true ? "__function_close_menu__" : 18;
var FunctionSetHighlightedIndex$1 = true ? "__function_set_highlighted_index__" : 19;
var FunctionSelectItem$1 = true ? "__function_select_item__" : 20;
var FunctionSetInputValue$1 = true ? "__function_set_input_value__" : 21;
var FunctionReset$2 = true ? "__function_reset__" : 22;
var stateChangeTypes$2 = Object.freeze({
  __proto__: null,
  MenuKeyDownArrowDown,
  MenuKeyDownArrowUp,
  MenuKeyDownEscape,
  MenuKeyDownHome,
  MenuKeyDownEnd,
  MenuKeyDownEnter,
  MenuKeyDownSpaceButton,
  MenuKeyDownCharacter,
  MenuBlur,
  MenuMouseLeave: MenuMouseLeave$1,
  ItemMouseMove: ItemMouseMove$1,
  ItemClick: ItemClick$1,
  ToggleButtonClick: ToggleButtonClick$1,
  ToggleButtonKeyDownArrowDown,
  ToggleButtonKeyDownArrowUp,
  ToggleButtonKeyDownCharacter,
  FunctionToggleMenu: FunctionToggleMenu$1,
  FunctionOpenMenu: FunctionOpenMenu$1,
  FunctionCloseMenu: FunctionCloseMenu$1,
  FunctionSetHighlightedIndex: FunctionSetHighlightedIndex$1,
  FunctionSelectItem: FunctionSelectItem$1,
  FunctionSetInputValue: FunctionSetInputValue$1,
  FunctionReset: FunctionReset$2
});
function downshiftSelectReducer(state, action) {
  const {
    type,
    props,
    shiftKey
  } = action;
  let changes;
  switch (type) {
    case ItemClick$1:
      changes = {
        isOpen: getDefaultValue$1(props, "isOpen"),
        highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
        selectedItem: props.items[action.index]
      };
      break;
    case ToggleButtonKeyDownCharacter:
      {
        const lowercasedKey = action.key;
        const inputValue = `${state.inputValue}${lowercasedKey}`;
        const itemIndex = getItemIndexByCharacterKey({
          keysSoFar: inputValue,
          highlightedIndex: state.selectedItem ? props.items.indexOf(state.selectedItem) : -1,
          items: props.items,
          itemToString: props.itemToString,
          getItemNodeFromIndex: action.getItemNodeFromIndex
        });
        changes = {
          inputValue,
          ...itemIndex >= 0 && {
            selectedItem: props.items[itemIndex]
          }
        };
      }
      break;
    case ToggleButtonKeyDownArrowDown:
      changes = {
        highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),
        isOpen: true
      };
      break;
    case ToggleButtonKeyDownArrowUp:
      changes = {
        highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),
        isOpen: true
      };
      break;
    case MenuKeyDownEnter:
    case MenuKeyDownSpaceButton:
      changes = {
        isOpen: getDefaultValue$1(props, "isOpen"),
        highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
        ...state.highlightedIndex >= 0 && {
          selectedItem: props.items[state.highlightedIndex]
        }
      };
      break;
    case MenuKeyDownHome:
      changes = {
        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)
      };
      break;
    case MenuKeyDownEnd:
      changes = {
        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)
      };
      break;
    case MenuKeyDownEscape:
      changes = {
        isOpen: false,
        highlightedIndex: -1
      };
      break;
    case MenuBlur:
      changes = {
        isOpen: false,
        highlightedIndex: -1
      };
      break;
    case MenuKeyDownCharacter:
      {
        const lowercasedKey = action.key;
        const inputValue = `${state.inputValue}${lowercasedKey}`;
        const highlightedIndex = getItemIndexByCharacterKey({
          keysSoFar: inputValue,
          highlightedIndex: state.highlightedIndex,
          items: props.items,
          itemToString: props.itemToString,
          getItemNodeFromIndex: action.getItemNodeFromIndex
        });
        changes = {
          inputValue,
          ...highlightedIndex >= 0 && {
            highlightedIndex
          }
        };
      }
      break;
    case MenuKeyDownArrowDown:
      changes = {
        highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
      };
      break;
    case MenuKeyDownArrowUp:
      changes = {
        highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
      };
      break;
    case FunctionSelectItem$1:
      changes = {
        selectedItem: action.selectedItem
      };
      break;
    default:
      return downshiftCommonReducer(state, action, stateChangeTypes$2);
  }
  return {
    ...state,
    ...changes
  };
}
useSelect.stateChangeTypes = stateChangeTypes$2;
function useSelect(userProps) {
  if (userProps === void 0) {
    userProps = {};
  }
  validatePropTypes$2(userProps, useSelect);
  const props = {
    ...defaultProps$2,
    ...userProps
  };
  const {
    items,
    scrollIntoView: scrollIntoView3,
    environment,
    initialIsOpen,
    defaultIsOpen,
    itemToString: itemToString2,
    getA11ySelectionMessage: getA11ySelectionMessage2,
    getA11yStatusMessage: getA11yStatusMessage2
  } = props;
  const initialState2 = getInitialState$2(props);
  const [state, dispatch] = useControlledReducer$1(downshiftSelectReducer, initialState2, props);
  const {
    isOpen,
    highlightedIndex,
    selectedItem,
    inputValue
  } = state;
  const toggleButtonRef = (0, import_react8.useRef)(null);
  const menuRef = (0, import_react8.useRef)(null);
  const itemRefs = (0, import_react8.useRef)({});
  const shouldBlurRef = (0, import_react8.useRef)(true);
  const clearTimeoutRef = (0, import_react8.useRef)(null);
  const elementIds = useElementIds(props);
  const previousResultCountRef = (0, import_react8.useRef)();
  const isInitialMountRef = (0, import_react8.useRef)(true);
  const latest = useLatestRef({
    state,
    props
  });
  const getItemNodeFromIndex = (0, import_react8.useCallback)((index2) => itemRefs.current[elementIds.getItemId(index2)], [elementIds]);
  useA11yMessageSetter(getA11yStatusMessage2, [isOpen, highlightedIndex, inputValue, items], {
    isInitialMount: isInitialMountRef.current,
    previousResultCount: previousResultCountRef.current,
    items,
    environment,
    itemToString: itemToString2,
    ...state
  });
  useA11yMessageSetter(getA11ySelectionMessage2, [selectedItem], {
    isInitialMount: isInitialMountRef.current,
    previousResultCount: previousResultCountRef.current,
    items,
    environment,
    itemToString: itemToString2,
    ...state
  });
  const shouldScrollRef = useScrollIntoView({
    menuElement: menuRef.current,
    highlightedIndex,
    isOpen,
    itemRefs,
    scrollIntoView: scrollIntoView3,
    getItemNodeFromIndex
  });
  (0, import_react8.useEffect)(() => {
    clearTimeoutRef.current = debounce2((outerDispatch) => {
      outerDispatch({
        type: FunctionSetInputValue$1,
        inputValue: ""
      });
    }, 500);
    return () => {
      clearTimeoutRef.current.cancel();
    };
  }, []);
  (0, import_react8.useEffect)(() => {
    if (!inputValue) {
      return;
    }
    clearTimeoutRef.current(dispatch);
  }, [dispatch, inputValue]);
  useControlPropsValidator({
    isInitialMount: isInitialMountRef.current,
    props,
    state
  });
  (0, import_react8.useEffect)(() => {
    if (isInitialMountRef.current) {
      if ((initialIsOpen || defaultIsOpen || isOpen) && menuRef.current) {
        menuRef.current.focus();
      }
      return;
    }
    if (isOpen) {
      if (menuRef.current) {
        menuRef.current.focus();
      }
      return;
    }
    if (environment.document.activeElement === menuRef.current) {
      if (toggleButtonRef.current) {
        shouldBlurRef.current = false;
        toggleButtonRef.current.focus();
      }
    }
  }, [isOpen]);
  (0, import_react8.useEffect)(() => {
    if (isInitialMountRef.current) {
      return;
    }
    previousResultCountRef.current = items.length;
  });
  const mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [menuRef, toggleButtonRef], environment, () => {
    dispatch({
      type: MenuBlur
    });
  });
  const setGetterPropCallInfo = useGetterPropsCalledChecker("getMenuProps", "getToggleButtonProps");
  (0, import_react8.useEffect)(() => {
    isInitialMountRef.current = false;
  }, []);
  (0, import_react8.useEffect)(() => {
    if (!isOpen) {
      itemRefs.current = {};
    }
  }, [isOpen]);
  const toggleButtonKeyDownHandlers = (0, import_react8.useMemo)(() => ({
    ArrowDown(event) {
      event.preventDefault();
      dispatch({
        type: ToggleButtonKeyDownArrowDown,
        getItemNodeFromIndex,
        shiftKey: event.shiftKey
      });
    },
    ArrowUp(event) {
      event.preventDefault();
      dispatch({
        type: ToggleButtonKeyDownArrowUp,
        getItemNodeFromIndex,
        shiftKey: event.shiftKey
      });
    }
  }), [dispatch, getItemNodeFromIndex]);
  const menuKeyDownHandlers = (0, import_react8.useMemo)(() => ({
    ArrowDown(event) {
      event.preventDefault();
      dispatch({
        type: MenuKeyDownArrowDown,
        getItemNodeFromIndex,
        shiftKey: event.shiftKey
      });
    },
    ArrowUp(event) {
      event.preventDefault();
      dispatch({
        type: MenuKeyDownArrowUp,
        getItemNodeFromIndex,
        shiftKey: event.shiftKey
      });
    },
    Home(event) {
      event.preventDefault();
      dispatch({
        type: MenuKeyDownHome,
        getItemNodeFromIndex
      });
    },
    End(event) {
      event.preventDefault();
      dispatch({
        type: MenuKeyDownEnd,
        getItemNodeFromIndex
      });
    },
    Escape() {
      dispatch({
        type: MenuKeyDownEscape
      });
    },
    Enter(event) {
      event.preventDefault();
      dispatch({
        type: MenuKeyDownEnter
      });
    },
    " "(event) {
      event.preventDefault();
      dispatch({
        type: MenuKeyDownSpaceButton
      });
    }
  }), [dispatch, getItemNodeFromIndex]);
  const toggleMenu = (0, import_react8.useCallback)(() => {
    dispatch({
      type: FunctionToggleMenu$1
    });
  }, [dispatch]);
  const closeMenu = (0, import_react8.useCallback)(() => {
    dispatch({
      type: FunctionCloseMenu$1
    });
  }, [dispatch]);
  const openMenu = (0, import_react8.useCallback)(() => {
    dispatch({
      type: FunctionOpenMenu$1
    });
  }, [dispatch]);
  const setHighlightedIndex = (0, import_react8.useCallback)((newHighlightedIndex) => {
    dispatch({
      type: FunctionSetHighlightedIndex$1,
      highlightedIndex: newHighlightedIndex
    });
  }, [dispatch]);
  const selectItem = (0, import_react8.useCallback)((newSelectedItem) => {
    dispatch({
      type: FunctionSelectItem$1,
      selectedItem: newSelectedItem
    });
  }, [dispatch]);
  const reset = (0, import_react8.useCallback)(() => {
    dispatch({
      type: FunctionReset$2
    });
  }, [dispatch]);
  const setInputValue = (0, import_react8.useCallback)((newInputValue) => {
    dispatch({
      type: FunctionSetInputValue$1,
      inputValue: newInputValue
    });
  }, [dispatch]);
  const getLabelProps = (0, import_react8.useCallback)((labelProps) => ({
    id: elementIds.labelId,
    htmlFor: elementIds.toggleButtonId,
    ...labelProps
  }), [elementIds]);
  const getMenuProps = (0, import_react8.useCallback)(function(_temp, _temp2) {
    let {
      onMouseLeave,
      refKey = "ref",
      onKeyDown,
      onBlur,
      ref: ref2,
      ...rest
    } = _temp === void 0 ? {} : _temp;
    let {
      suppressRefError = false
    } = _temp2 === void 0 ? {} : _temp2;
    const latestState = latest.current.state;
    const menuHandleKeyDown = (event) => {
      const key = normalizeArrowKey(event);
      if (key && menuKeyDownHandlers[key]) {
        menuKeyDownHandlers[key](event);
      } else if (isAcceptedCharacterKey(key)) {
        dispatch({
          type: MenuKeyDownCharacter,
          key,
          getItemNodeFromIndex
        });
      }
    };
    const menuHandleBlur = () => {
      if (shouldBlurRef.current === false) {
        shouldBlurRef.current = true;
        return;
      }
      const shouldBlur = !mouseAndTouchTrackersRef.current.isMouseDown;
      if (shouldBlur) {
        dispatch({
          type: MenuBlur
        });
      }
    };
    const menuHandleMouseLeave = () => {
      dispatch({
        type: MenuMouseLeave$1
      });
    };
    setGetterPropCallInfo("getMenuProps", suppressRefError, refKey, menuRef);
    return {
      [refKey]: handleRefs(ref2, (menuNode) => {
        menuRef.current = menuNode;
      }),
      id: elementIds.menuId,
      role: "listbox",
      "aria-labelledby": elementIds.labelId,
      tabIndex: -1,
      ...latestState.isOpen && latestState.highlightedIndex > -1 && {
        "aria-activedescendant": elementIds.getItemId(latestState.highlightedIndex)
      },
      onMouseLeave: callAllEventHandlers(onMouseLeave, menuHandleMouseLeave),
      onKeyDown: callAllEventHandlers(onKeyDown, menuHandleKeyDown),
      onBlur: callAllEventHandlers(onBlur, menuHandleBlur),
      ...rest
    };
  }, [dispatch, latest, menuKeyDownHandlers, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds, getItemNodeFromIndex]);
  const getToggleButtonProps = (0, import_react8.useCallback)(function(_temp3, _temp4) {
    let {
      onClick,
      onKeyDown,
      refKey = "ref",
      ref: ref2,
      ...rest
    } = _temp3 === void 0 ? {} : _temp3;
    let {
      suppressRefError = false
    } = _temp4 === void 0 ? {} : _temp4;
    const toggleButtonHandleClick = () => {
      dispatch({
        type: ToggleButtonClick$1
      });
    };
    const toggleButtonHandleKeyDown = (event) => {
      const key = normalizeArrowKey(event);
      if (key && toggleButtonKeyDownHandlers[key]) {
        toggleButtonKeyDownHandlers[key](event);
      } else if (isAcceptedCharacterKey(key)) {
        dispatch({
          type: ToggleButtonKeyDownCharacter,
          key,
          getItemNodeFromIndex
        });
      }
    };
    const toggleProps = {
      [refKey]: handleRefs(ref2, (toggleButtonNode) => {
        toggleButtonRef.current = toggleButtonNode;
      }),
      id: elementIds.toggleButtonId,
      "aria-haspopup": "listbox",
      "aria-expanded": latest.current.state.isOpen,
      "aria-labelledby": `${elementIds.labelId} ${elementIds.toggleButtonId}`,
      ...rest
    };
    if (!rest.disabled) {
      toggleProps.onClick = callAllEventHandlers(onClick, toggleButtonHandleClick);
      toggleProps.onKeyDown = callAllEventHandlers(onKeyDown, toggleButtonHandleKeyDown);
    }
    setGetterPropCallInfo("getToggleButtonProps", suppressRefError, refKey, toggleButtonRef);
    return toggleProps;
  }, [dispatch, latest, toggleButtonKeyDownHandlers, setGetterPropCallInfo, elementIds, getItemNodeFromIndex]);
  const getItemProps = (0, import_react8.useCallback)(function(_temp5) {
    let {
      item,
      index: index2,
      onMouseMove,
      onClick,
      refKey = "ref",
      ref: ref2,
      disabled,
      ...rest
    } = _temp5 === void 0 ? {} : _temp5;
    const {
      state: latestState,
      props: latestProps
    } = latest.current;
    const itemHandleMouseMove = () => {
      if (index2 === latestState.highlightedIndex) {
        return;
      }
      shouldScrollRef.current = false;
      dispatch({
        type: ItemMouseMove$1,
        index: index2,
        disabled
      });
    };
    const itemHandleClick = () => {
      dispatch({
        type: ItemClick$1,
        index: index2
      });
    };
    const itemIndex = getItemIndex(index2, item, latestProps.items);
    if (itemIndex < 0) {
      throw new Error("Pass either item or item index in getItemProps!");
    }
    const itemProps = {
      disabled,
      role: "option",
      "aria-selected": `${itemIndex === latestState.highlightedIndex}`,
      id: elementIds.getItemId(itemIndex),
      [refKey]: handleRefs(ref2, (itemNode) => {
        if (itemNode) {
          itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;
        }
      }),
      ...rest
    };
    if (!disabled) {
      itemProps.onClick = callAllEventHandlers(onClick, itemHandleClick);
    }
    itemProps.onMouseMove = callAllEventHandlers(onMouseMove, itemHandleMouseMove);
    return itemProps;
  }, [dispatch, latest, shouldScrollRef, elementIds]);
  return {
    // prop getters.
    getToggleButtonProps,
    getLabelProps,
    getMenuProps,
    getItemProps,
    // actions.
    toggleMenu,
    openMenu,
    closeMenu,
    setHighlightedIndex,
    selectItem,
    reset,
    setInputValue,
    // state.
    highlightedIndex,
    isOpen,
    selectedItem,
    inputValue
  };
}
var InputKeyDownArrowDown = true ? "__input_keydown_arrow_down__" : 0;
var InputKeyDownArrowUp = true ? "__input_keydown_arrow_up__" : 1;
var InputKeyDownEscape = true ? "__input_keydown_escape__" : 2;
var InputKeyDownHome = true ? "__input_keydown_home__" : 3;
var InputKeyDownEnd = true ? "__input_keydown_end__" : 4;
var InputKeyDownEnter = true ? "__input_keydown_enter__" : 5;
var InputChange = true ? "__input_change__" : 6;
var InputBlur = true ? "__input_blur__" : 7;
var MenuMouseLeave = true ? "__menu_mouse_leave__" : 8;
var ItemMouseMove = true ? "__item_mouse_move__" : 9;
var ItemClick = true ? "__item_click__" : 10;
var ToggleButtonClick = true ? "__togglebutton_click__" : 11;
var FunctionToggleMenu = true ? "__function_toggle_menu__" : 12;
var FunctionOpenMenu = true ? "__function_open_menu__" : 13;
var FunctionCloseMenu = true ? "__function_close_menu__" : 14;
var FunctionSetHighlightedIndex = true ? "__function_set_highlighted_index__" : 15;
var FunctionSelectItem = true ? "__function_select_item__" : 16;
var FunctionSetInputValue = true ? "__function_set_input_value__" : 17;
var FunctionReset$1 = true ? "__function_reset__" : 18;
var ControlledPropUpdatedSelectedItem = true ? "__controlled_prop_updated_selected_item__" : 19;
var stateChangeTypes$1 = Object.freeze({
  __proto__: null,
  InputKeyDownArrowDown,
  InputKeyDownArrowUp,
  InputKeyDownEscape,
  InputKeyDownHome,
  InputKeyDownEnd,
  InputKeyDownEnter,
  InputChange,
  InputBlur,
  MenuMouseLeave,
  ItemMouseMove,
  ItemClick,
  ToggleButtonClick,
  FunctionToggleMenu,
  FunctionOpenMenu,
  FunctionCloseMenu,
  FunctionSetHighlightedIndex,
  FunctionSelectItem,
  FunctionSetInputValue,
  FunctionReset: FunctionReset$1,
  ControlledPropUpdatedSelectedItem
});
function getInitialState$1(props) {
  const initialState2 = getInitialState$2(props);
  const {
    selectedItem
  } = initialState2;
  let {
    inputValue
  } = initialState2;
  if (inputValue === "" && selectedItem && props.defaultInputValue === void 0 && props.initialInputValue === void 0 && props.inputValue === void 0) {
    inputValue = props.itemToString(selectedItem);
  }
  return {
    ...initialState2,
    inputValue
  };
}
var propTypes$1 = {
  items: import_prop_types.default.array.isRequired,
  itemToString: import_prop_types.default.func,
  getA11yStatusMessage: import_prop_types.default.func,
  getA11ySelectionMessage: import_prop_types.default.func,
  circularNavigation: import_prop_types.default.bool,
  highlightedIndex: import_prop_types.default.number,
  defaultHighlightedIndex: import_prop_types.default.number,
  initialHighlightedIndex: import_prop_types.default.number,
  isOpen: import_prop_types.default.bool,
  defaultIsOpen: import_prop_types.default.bool,
  initialIsOpen: import_prop_types.default.bool,
  selectedItem: import_prop_types.default.any,
  initialSelectedItem: import_prop_types.default.any,
  defaultSelectedItem: import_prop_types.default.any,
  inputValue: import_prop_types.default.string,
  defaultInputValue: import_prop_types.default.string,
  initialInputValue: import_prop_types.default.string,
  id: import_prop_types.default.string,
  labelId: import_prop_types.default.string,
  menuId: import_prop_types.default.string,
  getItemId: import_prop_types.default.func,
  inputId: import_prop_types.default.string,
  toggleButtonId: import_prop_types.default.string,
  stateReducer: import_prop_types.default.func,
  onSelectedItemChange: import_prop_types.default.func,
  onHighlightedIndexChange: import_prop_types.default.func,
  onStateChange: import_prop_types.default.func,
  onIsOpenChange: import_prop_types.default.func,
  onInputValueChange: import_prop_types.default.func,
  environment: import_prop_types.default.shape({
    addEventListener: import_prop_types.default.func,
    removeEventListener: import_prop_types.default.func,
    document: import_prop_types.default.shape({
      getElementById: import_prop_types.default.func,
      activeElement: import_prop_types.default.any,
      body: import_prop_types.default.any
    })
  })
};
function useControlledReducer(reducer3, initialState2, props) {
  const previousSelectedItemRef = (0, import_react8.useRef)();
  const [state, dispatch] = useEnhancedReducer(reducer3, initialState2, props);
  (0, import_react8.useEffect)(() => {
    if (isControlledProp(props, "selectedItem")) {
      if (previousSelectedItemRef.current !== props.selectedItem) {
        dispatch({
          type: ControlledPropUpdatedSelectedItem,
          inputValue: props.itemToString(props.selectedItem)
        });
      }
      previousSelectedItemRef.current = state.selectedItem === previousSelectedItemRef.current ? props.selectedItem : state.selectedItem;
    }
  });
  return [getState(state, props), dispatch];
}
var validatePropTypes$1 = noop;
if (true) {
  validatePropTypes$1 = (options, caller) => {
    import_prop_types.default.checkPropTypes(propTypes$1, options, "prop", caller.name);
  };
}
var defaultProps$1 = {
  ...defaultProps$3,
  getA11yStatusMessage: getA11yStatusMessage$1,
  circularNavigation: true
};
function downshiftUseComboboxReducer(state, action) {
  const {
    type,
    props,
    shiftKey
  } = action;
  let changes;
  switch (type) {
    case ItemClick:
      changes = {
        isOpen: getDefaultValue$1(props, "isOpen"),
        highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
        selectedItem: props.items[action.index],
        inputValue: props.itemToString(props.items[action.index])
      };
      break;
    case InputKeyDownArrowDown:
      if (state.isOpen) {
        changes = {
          highlightedIndex: getNextWrappingIndex(shiftKey ? 5 : 1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
        };
      } else {
        changes = {
          highlightedIndex: getHighlightedIndexOnOpen(props, state, 1, action.getItemNodeFromIndex),
          isOpen: props.items.length >= 0
        };
      }
      break;
    case InputKeyDownArrowUp:
      if (state.isOpen) {
        changes = {
          highlightedIndex: getNextWrappingIndex(shiftKey ? -5 : -1, state.highlightedIndex, props.items.length, action.getItemNodeFromIndex, props.circularNavigation)
        };
      } else {
        changes = {
          highlightedIndex: getHighlightedIndexOnOpen(props, state, -1, action.getItemNodeFromIndex),
          isOpen: props.items.length >= 0
        };
      }
      break;
    case InputKeyDownEnter:
      changes = {
        ...state.isOpen && state.highlightedIndex >= 0 && {
          selectedItem: props.items[state.highlightedIndex],
          isOpen: getDefaultValue$1(props, "isOpen"),
          highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
          inputValue: props.itemToString(props.items[state.highlightedIndex])
        }
      };
      break;
    case InputKeyDownEscape:
      changes = {
        isOpen: false,
        highlightedIndex: -1,
        ...!state.isOpen && {
          selectedItem: null,
          inputValue: ""
        }
      };
      break;
    case InputKeyDownHome:
      changes = {
        highlightedIndex: getNextNonDisabledIndex(1, 0, props.items.length, action.getItemNodeFromIndex, false)
      };
      break;
    case InputKeyDownEnd:
      changes = {
        highlightedIndex: getNextNonDisabledIndex(-1, props.items.length - 1, props.items.length, action.getItemNodeFromIndex, false)
      };
      break;
    case InputBlur:
      changes = {
        isOpen: false,
        highlightedIndex: -1,
        ...state.highlightedIndex >= 0 && action.selectItem && {
          selectedItem: props.items[state.highlightedIndex],
          inputValue: props.itemToString(props.items[state.highlightedIndex])
        }
      };
      break;
    case InputChange:
      changes = {
        isOpen: true,
        highlightedIndex: getDefaultValue$1(props, "highlightedIndex"),
        inputValue: action.inputValue
      };
      break;
    case FunctionSelectItem:
      changes = {
        selectedItem: action.selectedItem,
        inputValue: props.itemToString(action.selectedItem)
      };
      break;
    case ControlledPropUpdatedSelectedItem:
      changes = {
        inputValue: action.inputValue
      };
      break;
    default:
      return downshiftCommonReducer(state, action, stateChangeTypes$1);
  }
  return {
    ...state,
    ...changes
  };
}
useCombobox.stateChangeTypes = stateChangeTypes$1;
function useCombobox(userProps) {
  if (userProps === void 0) {
    userProps = {};
  }
  validatePropTypes$1(userProps, useCombobox);
  const props = {
    ...defaultProps$1,
    ...userProps
  };
  const {
    initialIsOpen,
    defaultIsOpen,
    items,
    scrollIntoView: scrollIntoView3,
    environment,
    getA11yStatusMessage: getA11yStatusMessage2,
    getA11ySelectionMessage: getA11ySelectionMessage2,
    itemToString: itemToString2
  } = props;
  const initialState2 = getInitialState$1(props);
  const [state, dispatch] = useControlledReducer(downshiftUseComboboxReducer, initialState2, props);
  const {
    isOpen,
    highlightedIndex,
    selectedItem,
    inputValue
  } = state;
  const menuRef = (0, import_react8.useRef)(null);
  const itemRefs = (0, import_react8.useRef)({});
  const inputRef = (0, import_react8.useRef)(null);
  const toggleButtonRef = (0, import_react8.useRef)(null);
  const comboboxRef = (0, import_react8.useRef)(null);
  const isInitialMountRef = (0, import_react8.useRef)(true);
  const elementIds = useElementIds(props);
  const previousResultCountRef = (0, import_react8.useRef)();
  const latest = useLatestRef({
    state,
    props
  });
  const getItemNodeFromIndex = (0, import_react8.useCallback)((index2) => itemRefs.current[elementIds.getItemId(index2)], [elementIds]);
  useA11yMessageSetter(getA11yStatusMessage2, [isOpen, highlightedIndex, inputValue, items], {
    isInitialMount: isInitialMountRef.current,
    previousResultCount: previousResultCountRef.current,
    items,
    environment,
    itemToString: itemToString2,
    ...state
  });
  useA11yMessageSetter(getA11ySelectionMessage2, [selectedItem], {
    isInitialMount: isInitialMountRef.current,
    previousResultCount: previousResultCountRef.current,
    items,
    environment,
    itemToString: itemToString2,
    ...state
  });
  const shouldScrollRef = useScrollIntoView({
    menuElement: menuRef.current,
    highlightedIndex,
    isOpen,
    itemRefs,
    scrollIntoView: scrollIntoView3,
    getItemNodeFromIndex
  });
  useControlPropsValidator({
    isInitialMount: isInitialMountRef.current,
    props,
    state
  });
  (0, import_react8.useEffect)(() => {
    const focusOnOpen = initialIsOpen || defaultIsOpen || isOpen;
    if (focusOnOpen && inputRef.current) {
      inputRef.current.focus();
    }
  }, []);
  (0, import_react8.useEffect)(() => {
    if (isInitialMountRef.current) {
      return;
    }
    previousResultCountRef.current = items.length;
  });
  const mouseAndTouchTrackersRef = useMouseAndTouchTracker(isOpen, [comboboxRef, menuRef, toggleButtonRef], environment, () => {
    dispatch({
      type: InputBlur,
      selectItem: false
    });
  });
  const setGetterPropCallInfo = useGetterPropsCalledChecker("getInputProps", "getComboboxProps", "getMenuProps");
  (0, import_react8.useEffect)(() => {
    isInitialMountRef.current = false;
  }, []);
  (0, import_react8.useEffect)(() => {
    if (!isOpen) {
      itemRefs.current = {};
    }
  }, [isOpen]);
  const inputKeyDownHandlers = (0, import_react8.useMemo)(() => ({
    ArrowDown(event) {
      event.preventDefault();
      dispatch({
        type: InputKeyDownArrowDown,
        shiftKey: event.shiftKey,
        getItemNodeFromIndex
      });
    },
    ArrowUp(event) {
      event.preventDefault();
      dispatch({
        type: InputKeyDownArrowUp,
        shiftKey: event.shiftKey,
        getItemNodeFromIndex
      });
    },
    Home(event) {
      if (!latest.current.state.isOpen) {
        return;
      }
      event.preventDefault();
      dispatch({
        type: InputKeyDownHome,
        getItemNodeFromIndex
      });
    },
    End(event) {
      if (!latest.current.state.isOpen) {
        return;
      }
      event.preventDefault();
      dispatch({
        type: InputKeyDownEnd,
        getItemNodeFromIndex
      });
    },
    Escape(event) {
      const latestState = latest.current.state;
      if (latestState.isOpen || latestState.inputValue || latestState.selectedItem || latestState.highlightedIndex > -1) {
        event.preventDefault();
        dispatch({
          type: InputKeyDownEscape
        });
      }
    },
    Enter(event) {
      const latestState = latest.current.state;
      if (!latestState.isOpen || latestState.highlightedIndex < 0 || event.which === 229) {
        return;
      }
      event.preventDefault();
      dispatch({
        type: InputKeyDownEnter,
        getItemNodeFromIndex
      });
    }
  }), [dispatch, latest, getItemNodeFromIndex]);
  const getLabelProps = (0, import_react8.useCallback)((labelProps) => ({
    id: elementIds.labelId,
    htmlFor: elementIds.inputId,
    ...labelProps
  }), [elementIds]);
  const getMenuProps = (0, import_react8.useCallback)(function(_temp, _temp2) {
    let {
      onMouseLeave,
      refKey = "ref",
      ref: ref2,
      ...rest
    } = _temp === void 0 ? {} : _temp;
    let {
      suppressRefError = false
    } = _temp2 === void 0 ? {} : _temp2;
    setGetterPropCallInfo("getMenuProps", suppressRefError, refKey, menuRef);
    return {
      [refKey]: handleRefs(ref2, (menuNode) => {
        menuRef.current = menuNode;
      }),
      id: elementIds.menuId,
      role: "listbox",
      "aria-labelledby": elementIds.labelId,
      onMouseLeave: callAllEventHandlers(onMouseLeave, () => {
        dispatch({
          type: MenuMouseLeave
        });
      }),
      ...rest
    };
  }, [dispatch, setGetterPropCallInfo, elementIds]);
  const getItemProps = (0, import_react8.useCallback)(function(_temp3) {
    let {
      item,
      index: index2,
      refKey = "ref",
      ref: ref2,
      onMouseMove,
      onMouseDown,
      onClick,
      onPress,
      disabled,
      ...rest
    } = _temp3 === void 0 ? {} : _temp3;
    const {
      props: latestProps,
      state: latestState
    } = latest.current;
    const itemIndex = getItemIndex(index2, item, latestProps.items);
    if (itemIndex < 0) {
      throw new Error("Pass either item or item index in getItemProps!");
    }
    const onSelectKey = "onClick";
    const customClickHandler = onClick;
    const itemHandleMouseMove = () => {
      if (index2 === latestState.highlightedIndex) {
        return;
      }
      shouldScrollRef.current = false;
      dispatch({
        type: ItemMouseMove,
        index: index2,
        disabled
      });
    };
    const itemHandleClick = () => {
      dispatch({
        type: ItemClick,
        index: index2
      });
    };
    const itemHandleMouseDown = (e9) => e9.preventDefault();
    return {
      [refKey]: handleRefs(ref2, (itemNode) => {
        if (itemNode) {
          itemRefs.current[elementIds.getItemId(itemIndex)] = itemNode;
        }
      }),
      disabled,
      role: "option",
      "aria-selected": `${itemIndex === latestState.highlightedIndex}`,
      id: elementIds.getItemId(itemIndex),
      ...!disabled && {
        [onSelectKey]: callAllEventHandlers(customClickHandler, itemHandleClick)
      },
      onMouseMove: callAllEventHandlers(onMouseMove, itemHandleMouseMove),
      onMouseDown: callAllEventHandlers(onMouseDown, itemHandleMouseDown),
      ...rest
    };
  }, [dispatch, latest, shouldScrollRef, elementIds]);
  const getToggleButtonProps = (0, import_react8.useCallback)(function(_temp4) {
    let {
      onClick,
      onPress,
      refKey = "ref",
      ref: ref2,
      ...rest
    } = _temp4 === void 0 ? {} : _temp4;
    const toggleButtonHandleClick = () => {
      dispatch({
        type: ToggleButtonClick
      });
      if (!latest.current.state.isOpen && inputRef.current) {
        inputRef.current.focus();
      }
    };
    return {
      [refKey]: handleRefs(ref2, (toggleButtonNode) => {
        toggleButtonRef.current = toggleButtonNode;
      }),
      id: elementIds.toggleButtonId,
      tabIndex: -1,
      ...!rest.disabled && {
        ...{
          onClick: callAllEventHandlers(onClick, toggleButtonHandleClick)
        }
      },
      ...rest
    };
  }, [dispatch, latest, elementIds]);
  const getInputProps = (0, import_react8.useCallback)(function(_temp5, _temp6) {
    let {
      onKeyDown,
      onChange,
      onInput,
      onBlur,
      onChangeText,
      refKey = "ref",
      ref: ref2,
      ...rest
    } = _temp5 === void 0 ? {} : _temp5;
    let {
      suppressRefError = false
    } = _temp6 === void 0 ? {} : _temp6;
    setGetterPropCallInfo("getInputProps", suppressRefError, refKey, inputRef);
    const latestState = latest.current.state;
    const inputHandleKeyDown = (event) => {
      const key = normalizeArrowKey(event);
      if (key && inputKeyDownHandlers[key]) {
        inputKeyDownHandlers[key](event);
      }
    };
    const inputHandleChange = (event) => {
      dispatch({
        type: InputChange,
        inputValue: event.target.value
      });
    };
    const inputHandleBlur = () => {
      if (latestState.isOpen && !mouseAndTouchTrackersRef.current.isMouseDown) {
        dispatch({
          type: InputBlur,
          selectItem: true
        });
      }
    };
    const onChangeKey = "onChange";
    let eventHandlers = {};
    if (!rest.disabled) {
      eventHandlers = {
        [onChangeKey]: callAllEventHandlers(onChange, onInput, inputHandleChange),
        onKeyDown: callAllEventHandlers(onKeyDown, inputHandleKeyDown),
        onBlur: callAllEventHandlers(onBlur, inputHandleBlur)
      };
    }
    return {
      [refKey]: handleRefs(ref2, (inputNode) => {
        inputRef.current = inputNode;
      }),
      id: elementIds.inputId,
      "aria-autocomplete": "list",
      "aria-controls": elementIds.menuId,
      ...latestState.isOpen && latestState.highlightedIndex > -1 && {
        "aria-activedescendant": elementIds.getItemId(latestState.highlightedIndex)
      },
      "aria-labelledby": elementIds.labelId,
      // https://developer.mozilla.org/en-US/docs/Web/Security/Securing_your_site/Turning_off_form_autocompletion
      // revert back since autocomplete="nope" is ignored on latest Chrome and Opera
      autoComplete: "off",
      value: latestState.inputValue,
      ...eventHandlers,
      ...rest
    };
  }, [dispatch, inputKeyDownHandlers, latest, mouseAndTouchTrackersRef, setGetterPropCallInfo, elementIds]);
  const getComboboxProps = (0, import_react8.useCallback)(function(_temp7, _temp8) {
    let {
      refKey = "ref",
      ref: ref2,
      ...rest
    } = _temp7 === void 0 ? {} : _temp7;
    let {
      suppressRefError = false
    } = _temp8 === void 0 ? {} : _temp8;
    setGetterPropCallInfo("getComboboxProps", suppressRefError, refKey, comboboxRef);
    return {
      [refKey]: handleRefs(ref2, (comboboxNode) => {
        comboboxRef.current = comboboxNode;
      }),
      role: "combobox",
      "aria-haspopup": "listbox",
      "aria-owns": elementIds.menuId,
      "aria-expanded": latest.current.state.isOpen,
      ...rest
    };
  }, [latest, setGetterPropCallInfo, elementIds]);
  const toggleMenu = (0, import_react8.useCallback)(() => {
    dispatch({
      type: FunctionToggleMenu
    });
  }, [dispatch]);
  const closeMenu = (0, import_react8.useCallback)(() => {
    dispatch({
      type: FunctionCloseMenu
    });
  }, [dispatch]);
  const openMenu = (0, import_react8.useCallback)(() => {
    dispatch({
      type: FunctionOpenMenu
    });
  }, [dispatch]);
  const setHighlightedIndex = (0, import_react8.useCallback)((newHighlightedIndex) => {
    dispatch({
      type: FunctionSetHighlightedIndex,
      highlightedIndex: newHighlightedIndex
    });
  }, [dispatch]);
  const selectItem = (0, import_react8.useCallback)((newSelectedItem) => {
    dispatch({
      type: FunctionSelectItem,
      selectedItem: newSelectedItem
    });
  }, [dispatch]);
  const setInputValue = (0, import_react8.useCallback)((newInputValue) => {
    dispatch({
      type: FunctionSetInputValue,
      inputValue: newInputValue
    });
  }, [dispatch]);
  const reset = (0, import_react8.useCallback)(() => {
    dispatch({
      type: FunctionReset$1
    });
  }, [dispatch]);
  return {
    // prop getters.
    getItemProps,
    getLabelProps,
    getMenuProps,
    getInputProps,
    getComboboxProps,
    getToggleButtonProps,
    // actions.
    toggleMenu,
    openMenu,
    closeMenu,
    setHighlightedIndex,
    setInputValue,
    selectItem,
    reset,
    // state.
    highlightedIndex,
    isOpen,
    selectedItem,
    inputValue
  };
}
var defaultStateValues = {
  activeIndex: -1,
  selectedItems: []
};
function getInitialValue(props, propKey) {
  return getInitialValue$1(props, propKey, defaultStateValues);
}
function getDefaultValue(props, propKey) {
  return getDefaultValue$1(props, propKey, defaultStateValues);
}
function getInitialState(props) {
  const activeIndex = getInitialValue(props, "activeIndex");
  const selectedItems = getInitialValue(props, "selectedItems");
  return {
    activeIndex,
    selectedItems
  };
}
function isKeyDownOperationPermitted(event) {
  if (event.shiftKey || event.metaKey || event.ctrlKey || event.altKey) {
    return false;
  }
  const element = event.target;
  if (element instanceof HTMLInputElement && // if element is a text input
  element.value !== "" && // and we have text in it
  // and cursor is either not at the start or is currently highlighting text.
  (element.selectionStart !== 0 || element.selectionEnd !== 0)) {
    return false;
  }
  return true;
}
function getA11yRemovalMessage(selectionParameters) {
  const {
    removedSelectedItem,
    itemToString: itemToStringLocal
  } = selectionParameters;
  return `${itemToStringLocal(removedSelectedItem)} has been removed.`;
}
var propTypes = {
  selectedItems: import_prop_types.default.array,
  initialSelectedItems: import_prop_types.default.array,
  defaultSelectedItems: import_prop_types.default.array,
  itemToString: import_prop_types.default.func,
  getA11yRemovalMessage: import_prop_types.default.func,
  stateReducer: import_prop_types.default.func,
  activeIndex: import_prop_types.default.number,
  initialActiveIndex: import_prop_types.default.number,
  defaultActiveIndex: import_prop_types.default.number,
  onActiveIndexChange: import_prop_types.default.func,
  onSelectedItemsChange: import_prop_types.default.func,
  keyNavigationNext: import_prop_types.default.string,
  keyNavigationPrevious: import_prop_types.default.string,
  environment: import_prop_types.default.shape({
    addEventListener: import_prop_types.default.func,
    removeEventListener: import_prop_types.default.func,
    document: import_prop_types.default.shape({
      getElementById: import_prop_types.default.func,
      activeElement: import_prop_types.default.any,
      body: import_prop_types.default.any
    })
  })
};
var defaultProps = {
  itemToString: defaultProps$3.itemToString,
  stateReducer: defaultProps$3.stateReducer,
  environment: defaultProps$3.environment,
  getA11yRemovalMessage,
  keyNavigationNext: "ArrowRight",
  keyNavigationPrevious: "ArrowLeft"
};
var validatePropTypes = noop;
if (true) {
  validatePropTypes = (options, caller) => {
    import_prop_types.default.checkPropTypes(propTypes, options, "prop", caller.name);
  };
}
var SelectedItemClick = true ? "__selected_item_click__" : 0;
var SelectedItemKeyDownDelete = true ? "__selected_item_keydown_delete__" : 1;
var SelectedItemKeyDownBackspace = true ? "__selected_item_keydown_backspace__" : 2;
var SelectedItemKeyDownNavigationNext = true ? "__selected_item_keydown_navigation_next__" : 3;
var SelectedItemKeyDownNavigationPrevious = true ? "__selected_item_keydown_navigation_previous__" : 4;
var DropdownKeyDownNavigationPrevious = true ? "__dropdown_keydown_navigation_previous__" : 5;
var DropdownKeyDownBackspace = true ? "__dropdown_keydown_backspace__" : 6;
var DropdownClick = true ? "__dropdown_click__" : 7;
var FunctionAddSelectedItem = true ? "__function_add_selected_item__" : 8;
var FunctionRemoveSelectedItem = true ? "__function_remove_selected_item__" : 9;
var FunctionSetSelectedItems = true ? "__function_set_selected_items__" : 10;
var FunctionSetActiveIndex = true ? "__function_set_active_index__" : 11;
var FunctionReset = true ? "__function_reset__" : 12;
var stateChangeTypes = Object.freeze({
  __proto__: null,
  SelectedItemClick,
  SelectedItemKeyDownDelete,
  SelectedItemKeyDownBackspace,
  SelectedItemKeyDownNavigationNext,
  SelectedItemKeyDownNavigationPrevious,
  DropdownKeyDownNavigationPrevious,
  DropdownKeyDownBackspace,
  DropdownClick,
  FunctionAddSelectedItem,
  FunctionRemoveSelectedItem,
  FunctionSetSelectedItems,
  FunctionSetActiveIndex,
  FunctionReset
});
function downshiftMultipleSelectionReducer(state, action) {
  const {
    type,
    index: index2,
    props,
    selectedItem
  } = action;
  const {
    activeIndex,
    selectedItems
  } = state;
  let changes;
  switch (type) {
    case SelectedItemClick:
      changes = {
        activeIndex: index2
      };
      break;
    case SelectedItemKeyDownNavigationPrevious:
      changes = {
        activeIndex: activeIndex - 1 < 0 ? 0 : activeIndex - 1
      };
      break;
    case SelectedItemKeyDownNavigationNext:
      changes = {
        activeIndex: activeIndex + 1 >= selectedItems.length ? -1 : activeIndex + 1
      };
      break;
    case SelectedItemKeyDownBackspace:
    case SelectedItemKeyDownDelete: {
      let newActiveIndex = activeIndex;
      if (selectedItems.length === 1) {
        newActiveIndex = -1;
      } else if (activeIndex === selectedItems.length - 1) {
        newActiveIndex = selectedItems.length - 2;
      }
      changes = {
        selectedItems: [...selectedItems.slice(0, activeIndex), ...selectedItems.slice(activeIndex + 1)],
        ...{
          activeIndex: newActiveIndex
        }
      };
      break;
    }
    case DropdownKeyDownNavigationPrevious:
      changes = {
        activeIndex: selectedItems.length - 1
      };
      break;
    case DropdownKeyDownBackspace:
      changes = {
        selectedItems: selectedItems.slice(0, selectedItems.length - 1)
      };
      break;
    case FunctionAddSelectedItem:
      changes = {
        selectedItems: [...selectedItems, selectedItem]
      };
      break;
    case DropdownClick:
      changes = {
        activeIndex: -1
      };
      break;
    case FunctionRemoveSelectedItem: {
      let newActiveIndex = activeIndex;
      const selectedItemIndex = selectedItems.indexOf(selectedItem);
      if (selectedItemIndex >= 0) {
        if (selectedItems.length === 1) {
          newActiveIndex = -1;
        } else if (selectedItemIndex === selectedItems.length - 1) {
          newActiveIndex = selectedItems.length - 2;
        }
        changes = {
          selectedItems: [...selectedItems.slice(0, selectedItemIndex), ...selectedItems.slice(selectedItemIndex + 1)],
          activeIndex: newActiveIndex
        };
      }
      break;
    }
    case FunctionSetSelectedItems: {
      const {
        selectedItems: newSelectedItems
      } = action;
      changes = {
        selectedItems: newSelectedItems
      };
      break;
    }
    case FunctionSetActiveIndex: {
      const {
        activeIndex: newActiveIndex
      } = action;
      changes = {
        activeIndex: newActiveIndex
      };
      break;
    }
    case FunctionReset:
      changes = {
        activeIndex: getDefaultValue(props, "activeIndex"),
        selectedItems: getDefaultValue(props, "selectedItems")
      };
      break;
    default:
      throw new Error("Reducer called without proper action type.");
  }
  return {
    ...state,
    ...changes
  };
}
useMultipleSelection.stateChangeTypes = stateChangeTypes;
function useMultipleSelection(userProps) {
  if (userProps === void 0) {
    userProps = {};
  }
  validatePropTypes(userProps, useMultipleSelection);
  const props = {
    ...defaultProps,
    ...userProps
  };
  const {
    getA11yRemovalMessage: getA11yRemovalMessage2,
    itemToString: itemToString2,
    environment,
    keyNavigationNext,
    keyNavigationPrevious
  } = props;
  const [state, dispatch] = useControlledReducer$1(downshiftMultipleSelectionReducer, getInitialState(props), props);
  const {
    activeIndex,
    selectedItems
  } = state;
  const isInitialMountRef = (0, import_react8.useRef)(true);
  const dropdownRef = (0, import_react8.useRef)(null);
  const previousSelectedItemsRef = (0, import_react8.useRef)(selectedItems);
  const selectedItemRefs = (0, import_react8.useRef)();
  selectedItemRefs.current = [];
  const latest = useLatestRef({
    state,
    props
  });
  (0, import_react8.useEffect)(() => {
    if (isInitialMountRef.current) {
      return;
    }
    if (selectedItems.length < previousSelectedItemsRef.current.length) {
      const removedSelectedItem = previousSelectedItemsRef.current.find((item) => selectedItems.indexOf(item) < 0);
      setStatus(getA11yRemovalMessage2({
        itemToString: itemToString2,
        resultCount: selectedItems.length,
        removedSelectedItem,
        activeIndex,
        activeSelectedItem: selectedItems[activeIndex]
      }), environment.document);
    }
    previousSelectedItemsRef.current = selectedItems;
  }, [selectedItems.length]);
  (0, import_react8.useEffect)(() => {
    if (isInitialMountRef.current) {
      return;
    }
    if (activeIndex === -1 && dropdownRef.current) {
      dropdownRef.current.focus();
    } else if (selectedItemRefs.current[activeIndex]) {
      selectedItemRefs.current[activeIndex].focus();
    }
  }, [activeIndex]);
  useControlPropsValidator({
    isInitialMount: isInitialMountRef.current,
    props,
    state
  });
  const setGetterPropCallInfo = useGetterPropsCalledChecker("getDropdownProps");
  (0, import_react8.useEffect)(() => {
    isInitialMountRef.current = false;
  }, []);
  const selectedItemKeyDownHandlers = (0, import_react8.useMemo)(() => ({
    [keyNavigationPrevious]() {
      dispatch({
        type: SelectedItemKeyDownNavigationPrevious
      });
    },
    [keyNavigationNext]() {
      dispatch({
        type: SelectedItemKeyDownNavigationNext
      });
    },
    Delete() {
      dispatch({
        type: SelectedItemKeyDownDelete
      });
    },
    Backspace() {
      dispatch({
        type: SelectedItemKeyDownBackspace
      });
    }
  }), [dispatch, keyNavigationNext, keyNavigationPrevious]);
  const dropdownKeyDownHandlers = (0, import_react8.useMemo)(() => ({
    [keyNavigationPrevious](event) {
      if (isKeyDownOperationPermitted(event)) {
        dispatch({
          type: DropdownKeyDownNavigationPrevious
        });
      }
    },
    Backspace(event) {
      if (isKeyDownOperationPermitted(event)) {
        dispatch({
          type: DropdownKeyDownBackspace
        });
      }
    }
  }), [dispatch, keyNavigationPrevious]);
  const getSelectedItemProps = (0, import_react8.useCallback)(function(_temp) {
    let {
      refKey = "ref",
      ref: ref2,
      onClick,
      onKeyDown,
      selectedItem,
      index: index2,
      ...rest
    } = _temp === void 0 ? {} : _temp;
    const {
      state: latestState
    } = latest.current;
    const itemIndex = getItemIndex(index2, selectedItem, latestState.selectedItems);
    if (itemIndex < 0) {
      throw new Error("Pass either selectedItem or index in getSelectedItemProps!");
    }
    const selectedItemHandleClick = () => {
      dispatch({
        type: SelectedItemClick,
        index: index2
      });
    };
    const selectedItemHandleKeyDown = (event) => {
      const key = normalizeArrowKey(event);
      if (key && selectedItemKeyDownHandlers[key]) {
        selectedItemKeyDownHandlers[key](event);
      }
    };
    return {
      [refKey]: handleRefs(ref2, (selectedItemNode) => {
        if (selectedItemNode) {
          selectedItemRefs.current.push(selectedItemNode);
        }
      }),
      tabIndex: index2 === latestState.activeIndex ? 0 : -1,
      onClick: callAllEventHandlers(onClick, selectedItemHandleClick),
      onKeyDown: callAllEventHandlers(onKeyDown, selectedItemHandleKeyDown),
      ...rest
    };
  }, [dispatch, latest, selectedItemKeyDownHandlers]);
  const getDropdownProps = (0, import_react8.useCallback)(function(_temp2, _temp3) {
    let {
      refKey = "ref",
      ref: ref2,
      onKeyDown,
      onClick,
      preventKeyAction = false,
      ...rest
    } = _temp2 === void 0 ? {} : _temp2;
    let {
      suppressRefError = false
    } = _temp3 === void 0 ? {} : _temp3;
    setGetterPropCallInfo("getDropdownProps", suppressRefError, refKey, dropdownRef);
    const dropdownHandleKeyDown = (event) => {
      const key = normalizeArrowKey(event);
      if (key && dropdownKeyDownHandlers[key]) {
        dropdownKeyDownHandlers[key](event);
      }
    };
    const dropdownHandleClick = () => {
      dispatch({
        type: DropdownClick
      });
    };
    return {
      [refKey]: handleRefs(ref2, (dropdownNode) => {
        if (dropdownNode) {
          dropdownRef.current = dropdownNode;
        }
      }),
      ...!preventKeyAction && {
        onKeyDown: callAllEventHandlers(onKeyDown, dropdownHandleKeyDown),
        onClick: callAllEventHandlers(onClick, dropdownHandleClick)
      },
      ...rest
    };
  }, [dispatch, dropdownKeyDownHandlers, setGetterPropCallInfo]);
  const addSelectedItem = (0, import_react8.useCallback)((selectedItem) => {
    dispatch({
      type: FunctionAddSelectedItem,
      selectedItem
    });
  }, [dispatch]);
  const removeSelectedItem = (0, import_react8.useCallback)((selectedItem) => {
    dispatch({
      type: FunctionRemoveSelectedItem,
      selectedItem
    });
  }, [dispatch]);
  const setSelectedItems = (0, import_react8.useCallback)((newSelectedItems) => {
    dispatch({
      type: FunctionSetSelectedItems,
      selectedItems: newSelectedItems
    });
  }, [dispatch]);
  const setActiveIndex = (0, import_react8.useCallback)((newActiveIndex) => {
    dispatch({
      type: FunctionSetActiveIndex,
      activeIndex: newActiveIndex
    });
  }, [dispatch]);
  const reset = (0, import_react8.useCallback)(() => {
    dispatch({
      type: FunctionReset
    });
  }, [dispatch]);
  return {
    getSelectedItemProps,
    getDropdownProps,
    addSelectedItem,
    removeSelectedItem,
    setSelectedItems,
    setActiveIndex,
    reset,
    selectedItems,
    activeIndex
  };
}

// node_modules/@udecode/plate-combobox/dist/index.es.js
var createComboboxStore = (state) => createStore4(`combobox-${state.id}`)(state);
var comboboxStore = createStore4("combobox")({
  activeId: null,
  byId: {},
  highlightedIndex: 0,
  items: [],
  filteredItems: [],
  targetRange: null,
  text: null
}).extendActions((set3, get8) => ({
  setComboboxById: (state) => {
    if (get8.byId()[state.id])
      return;
    set3.state((draft) => {
      draft.byId[state.id] = createComboboxStore(state);
    });
  },
  open: (state) => {
    set3.mergeState(state);
  },
  reset: () => {
    set3.state((draft) => {
      draft.activeId = null;
      draft.highlightedIndex = 0;
      draft.items = [];
      draft.text = null;
      draft.targetRange = null;
    });
  }
})).extendSelectors((state) => ({
  isOpen: () => !!state.activeId
}));
var useComboboxSelectors = comboboxStore.use;
var comboboxSelectors = comboboxStore.get;
var comboboxActions = comboboxStore.set;
var getComboboxStoreById = (id) => id ? comboboxSelectors.byId()[id] : null;
var getTextFromTrigger = (editor, {
  at,
  trigger,
  searchPattern = `\\S+`
}) => {
  const escapedTrigger = escapeRegExp(trigger);
  const triggerRegex = new RegExp(`(?:^|\\s)${escapedTrigger}`);
  let start3 = at;
  let end2;
  while (true) {
    end2 = start3;
    if (!start3)
      break;
    start3 = getPointBefore(editor, start3);
    const charRange = start3 && getRange(editor, start3, end2);
    const charText = getEditorString(editor, charRange);
    if (!charText.match(searchPattern)) {
      start3 = end2;
      break;
    }
  }
  const range = start3 && getRange(editor, start3, at);
  const text = getEditorString(editor, range);
  if (!range || !text.match(triggerRegex))
    return;
  return {
    range,
    textAfterTrigger: text.substring(trigger.length)
  };
};
var onChangeCombobox = (editor) => () => {
  const byId2 = comboboxSelectors.byId();
  const activeId = comboboxSelectors.activeId();
  let shouldClose = true;
  for (const store of Object.values(byId2)) {
    var _store$get$controlled, _store$get, _store$get$searchPatt, _store$get2;
    const id = store.get.id();
    const controlled = (_store$get$controlled = (_store$get = store.get).controlled) === null || _store$get$controlled === void 0 ? void 0 : _store$get$controlled.call(_store$get);
    if (controlled) {
      if (activeId === id) {
        shouldClose = false;
        break;
      } else {
        continue;
      }
    }
    const {
      selection
    } = editor;
    if (!selection || !isCollapsed(selection)) {
      continue;
    }
    const trigger = store.get.trigger();
    const searchPattern = (_store$get$searchPatt = (_store$get2 = store.get).searchPattern) === null || _store$get$searchPatt === void 0 ? void 0 : _store$get$searchPatt.call(_store$get2);
    const isCursorAfterTrigger = getTextFromTrigger(editor, {
      at: Range.start(selection),
      trigger,
      searchPattern
    });
    if (!isCursorAfterTrigger) {
      continue;
    }
    const {
      range,
      textAfterTrigger
    } = isCursorAfterTrigger;
    comboboxActions.open({
      activeId: id,
      text: textAfterTrigger,
      targetRange: range
    });
    shouldClose = false;
    break;
  }
  if (shouldClose && comboboxSelectors.isOpen()) {
    comboboxActions.reset();
  }
};
function unwrapExports5(x7) {
  return x7 && x7.__esModule && Object.prototype.hasOwnProperty.call(x7, "default") ? x7["default"] : x7;
}
function createCommonjsModule6(fn2, module2) {
  return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
}
var lib5 = createCommonjsModule6(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var IS_MAC = () => typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
  var MODIFIERS = {
    alt: "altKey",
    control: "ctrlKey",
    meta: "metaKey",
    shift: "shiftKey"
  };
  var ALIASES = () => ({
    add: "+",
    break: "pause",
    cmd: "meta",
    command: "meta",
    ctl: "control",
    ctrl: "control",
    del: "delete",
    down: "arrowdown",
    esc: "escape",
    ins: "insert",
    left: "arrowleft",
    mod: IS_MAC() ? "meta" : "control",
    opt: "alt",
    option: "alt",
    return: "enter",
    right: "arrowright",
    space: " ",
    spacebar: " ",
    up: "arrowup",
    win: "meta",
    windows: "meta"
  });
  var CODES = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    control: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    " ": 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    insert: 45,
    delete: 46,
    meta: 91,
    numlock: 144,
    scrolllock: 145,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
  };
  for (var f16 = 1; f16 < 20; f16++) {
    CODES["f" + f16] = 111 + f16;
  }
  function isHotkey14(hotkey, options, event) {
    if (options && !("byKey" in options)) {
      event = options;
      options = null;
    }
    if (!Array.isArray(hotkey)) {
      hotkey = [hotkey];
    }
    var array2 = hotkey.map(function(string2) {
      return parseHotkey(string2, options);
    });
    var check = function check2(e9) {
      return array2.some(function(object2) {
        return compareHotkey(object2, e9);
      });
    };
    var ret = event == null ? check : check(event);
    return ret;
  }
  function isCodeHotkey(hotkey, event) {
    return isHotkey14(hotkey, event);
  }
  function isKeyHotkey2(hotkey, event) {
    return isHotkey14(hotkey, { byKey: true }, event);
  }
  function parseHotkey(hotkey, options) {
    var byKey = options && options.byKey;
    var ret = {};
    hotkey = hotkey.replace("++", "+add");
    var values3 = hotkey.split("+");
    var length = values3.length;
    for (var k3 in MODIFIERS) {
      ret[MODIFIERS[k3]] = false;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = void 0;
    try {
      for (var _iterator = values3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var value = _step.value;
        var optional = value.endsWith("?") && value.length > 1;
        if (optional) {
          value = value.slice(0, -1);
        }
        var name2 = toKeyName(value);
        var modifier = MODIFIERS[name2];
        if (length === 1 || !modifier) {
          if (byKey) {
            ret.key = name2;
          } else {
            ret.which = toKeyCode(value);
          }
        }
        if (modifier) {
          ret[modifier] = optional ? null : true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return ret;
  }
  function compareHotkey(object2, event) {
    for (var key in object2) {
      var expected = object2[key];
      var actual = void 0;
      if (expected == null) {
        continue;
      }
      if (key === "key" && event.key != null) {
        actual = event.key.toLowerCase();
      } else if (key === "which") {
        actual = expected === 91 && event.which === 93 ? 91 : event.which;
      } else {
        actual = event[key];
      }
      if (actual == null && expected === false) {
        continue;
      }
      if (actual !== expected) {
        return false;
      }
    }
    return true;
  }
  function toKeyCode(name2) {
    name2 = toKeyName(name2);
    var code = CODES[name2] || name2.toUpperCase().charCodeAt(0);
    return code;
  }
  function toKeyName(name2) {
    name2 = name2.toLowerCase();
    name2 = ALIASES()[name2] || name2;
    return name2;
  }
  exports2.default = isHotkey14;
  exports2.isHotkey = isHotkey14;
  exports2.isCodeHotkey = isCodeHotkey;
  exports2.isKeyHotkey = isKeyHotkey2;
  exports2.parseHotkey = parseHotkey;
  exports2.compareHotkey = compareHotkey;
  exports2.toKeyCode = toKeyCode;
  exports2.toKeyName = toKeyName;
});
var isHotkey5 = unwrapExports5(lib5);
lib5.isHotkey;
lib5.isCodeHotkey;
lib5.isKeyHotkey;
lib5.parseHotkey;
lib5.compareHotkey;
lib5.toKeyCode;
lib5.toKeyName;
var getNextNonDisabledIndex2 = (moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular) => {
  const currentElementNode = getItemNodeFromIndex(baseIndex);
  if (!currentElementNode || !currentElementNode.hasAttribute("disabled")) {
    return baseIndex;
  }
  if (moveAmount > 0) {
    for (let index2 = baseIndex + 1; index2 < itemCount; index2++) {
      if (!getItemNodeFromIndex(index2).hasAttribute("disabled")) {
        return index2;
      }
    }
  } else {
    for (let index2 = baseIndex - 1; index2 >= 0; index2--) {
      if (!getItemNodeFromIndex(index2).hasAttribute("disabled")) {
        return index2;
      }
    }
  }
  if (circular) {
    return moveAmount > 0 ? getNextNonDisabledIndex2(1, 0, itemCount, getItemNodeFromIndex, false) : getNextNonDisabledIndex2(-1, itemCount - 1, itemCount, getItemNodeFromIndex, false);
  }
  return -1;
};
var getNextWrappingIndex2 = (moveAmount, baseIndex, itemCount, getItemNodeFromIndex, circular = true) => {
  if (itemCount === 0) {
    return -1;
  }
  const itemsLastIndex = itemCount - 1;
  if (typeof baseIndex !== "number" || baseIndex < 0 || baseIndex >= itemCount) {
    baseIndex = moveAmount > 0 ? -1 : itemsLastIndex + 1;
  }
  let newIndex = baseIndex + moveAmount;
  if (newIndex < 0) {
    newIndex = circular ? itemsLastIndex : 0;
  } else if (newIndex > itemsLastIndex) {
    newIndex = circular ? 0 : itemsLastIndex;
  }
  const nonDisabledNewIndex = getNextNonDisabledIndex2(moveAmount, newIndex, itemCount, getItemNodeFromIndex, circular);
  if (nonDisabledNewIndex === -1) {
    return baseIndex >= itemCount ? -1 : baseIndex;
  }
  return nonDisabledNewIndex;
};
var onKeyDownCombobox = (editor) => (event) => {
  const {
    highlightedIndex,
    filteredItems,
    activeId
  } = comboboxSelectors.state();
  const isOpen = comboboxSelectors.isOpen();
  if (!isOpen)
    return;
  const store = getComboboxStoreById(activeId);
  if (!store)
    return;
  const onSelectItem = store.get.onSelectItem();
  if (isHotkey5("down", event)) {
    event.preventDefault();
    const newIndex = getNextWrappingIndex2(1, highlightedIndex, filteredItems.length, () => {
    }, true);
    comboboxActions.highlightedIndex(newIndex);
    return;
  }
  if (isHotkey5("up", event)) {
    event.preventDefault();
    const newIndex = getNextWrappingIndex2(-1, highlightedIndex, filteredItems.length, () => {
    }, true);
    comboboxActions.highlightedIndex(newIndex);
    return;
  }
  if (isHotkey5("escape", event)) {
    event.preventDefault();
    comboboxActions.reset();
    return;
  }
  if (Hotkeys2.isTab(editor, event) || isHotkey5("enter", event)) {
    event.preventDefault();
    event.stopPropagation();
    if (filteredItems[highlightedIndex]) {
      onSelectItem === null || onSelectItem === void 0 ? void 0 : onSelectItem(editor, filteredItems[highlightedIndex]);
    }
  }
};
var KEY_COMBOBOX = "combobox";
var createComboboxPlugin = createPluginFactory({
  key: KEY_COMBOBOX,
  handlers: {
    onChange: onChangeCombobox,
    onKeyDown: onKeyDownCombobox
  }
});

// node_modules/@udecode/plate-find-replace/dist/index.es.js
var decorateFindReplace = (editor, {
  key,
  type
}) => ([node, path]) => {
  const ranges = [];
  const {
    search
  } = editor.pluginsByKey[key].options;
  if (!search || !isText(node)) {
    return ranges;
  }
  const {
    text
  } = node;
  const parts = text.toLowerCase().split(search.toLowerCase());
  let offset5 = 0;
  parts.forEach((part, i15) => {
    if (i15 !== 0) {
      ranges.push({
        anchor: {
          path,
          offset: offset5 - search.length
        },
        focus: {
          path,
          offset: offset5
        },
        search,
        [type]: true
      });
    }
    offset5 = offset5 + part.length + search.length;
  });
  return ranges;
};
var MARK_SEARCH_HIGHLIGHT = "search_highlight";
var createFindReplacePlugin = createPluginFactory({
  key: MARK_SEARCH_HIGHLIGHT,
  isLeaf: true,
  decorate: decorateFindReplace
});

// node_modules/@udecode/plate-font/dist/index.es.js
var MARK_BG_COLOR = "backgroundColor";
var createFontBackgroundColorPlugin = createPluginFactory({
  key: MARK_BG_COLOR,
  inject: {
    props: {
      nodeKey: MARK_BG_COLOR
    }
  },
  then: (editor, {
    type
  }) => ({
    deserializeHtml: {
      isLeaf: true,
      getNode: (element) => ({
        [type]: element.style.backgroundColor
      }),
      rules: [{
        validStyle: {
          backgroundColor: "*"
        }
      }]
    }
  })
});
var MARK_COLOR = "color";
var createFontColorPlugin = createPluginFactory({
  key: MARK_COLOR,
  inject: {
    props: {
      nodeKey: MARK_COLOR,
      defaultNodeValue: "black"
    }
  },
  then: (editor, {
    type
  }) => ({
    deserializeHtml: {
      isLeaf: true,
      getNode(element) {
        if (element.style.color) {
          return {
            [type]: element.style.color
          };
        }
      },
      rules: [{
        validStyle: {
          color: "*"
        }
      }]
    }
  })
});
var MARK_FONT_FAMILY = "fontFamily";
var createFontFamilyPlugin = createPluginFactory({
  key: MARK_FONT_FAMILY,
  inject: {
    props: {
      nodeKey: MARK_FONT_FAMILY
    }
  },
  then: (editor, {
    type
  }) => ({
    deserializeHtml: {
      isLeaf: true,
      getNode: (element) => ({
        [type]: element.style.fontFamily
      }),
      rules: [{
        validStyle: {
          fontFamily: "*"
        }
      }]
    }
  })
});
var MARK_FONT_SIZE = "fontSize";
var createFontSizePlugin = createPluginFactory({
  key: MARK_FONT_SIZE,
  inject: {
    props: {
      nodeKey: MARK_FONT_SIZE
    }
  },
  then: (editor, {
    type
  }) => ({
    deserializeHtml: {
      isLeaf: true,
      getNode: (element) => ({
        [type]: element.style.fontSize
      }),
      rules: [{
        validStyle: {
          fontSize: "*"
        }
      }]
    }
  })
});
var MARK_FONT_WEIGHT = "fontWeight";
var createFontWeightPlugin = createPluginFactory({
  key: MARK_FONT_WEIGHT,
  inject: {
    props: {
      nodeKey: MARK_FONT_WEIGHT
    }
  },
  then: (editor, {
    type
  }) => ({
    deserializeHtml: {
      isLeaf: true,
      getNode: (element) => ({
        [type]: element.style.fontWeight
      }),
      rules: [{
        validStyle: {
          fontWeight: "*"
        }
      }]
    }
  })
});

// node_modules/@udecode/plate-highlight/dist/index.es.js
var MARK_HIGHLIGHT = "highlight";
var createHighlightPlugin = createPluginFactory({
  key: MARK_HIGHLIGHT,
  isLeaf: true,
  handlers: {
    onKeyDown: onKeyDownToggleMark
  },
  deserializeHtml: {
    rules: [{
      validNodeName: ["MARK"]
    }]
  },
  options: {
    hotkey: "mod+shift+h"
  }
});

// node_modules/@udecode/plate-horizontal-rule/dist/index.es.js
var ELEMENT_HR = "hr";
var createHorizontalRulePlugin = createPluginFactory({
  key: ELEMENT_HR,
  isElement: true,
  isVoid: true,
  deserializeHtml: {
    rules: [{
      validNodeName: "HR"
    }]
  }
});

// node_modules/@udecode/plate-image/dist/index.es.js
var import_react12 = __toESM(require_react());

// node_modules/react-textarea-autosize/dist/react-textarea-autosize.browser.esm.js
var import_react11 = __toESM(require_react());

// node_modules/use-latest/dist/use-latest.esm.js
var React4 = __toESM(require_react());
var useLatest = function useLatest2(value) {
  var ref2 = React4.useRef(value);
  use_isomorphic_layout_effect_browser_esm_default(function() {
    ref2.current = value;
  });
  return ref2;
};

// node_modules/use-composed-ref/dist/use-composed-ref.esm.js
var import_react10 = __toESM(require_react());
var updateRef = function updateRef2(ref2, value) {
  if (typeof ref2 === "function") {
    ref2(value);
    return;
  }
  ref2.current = value;
};
var useComposedRef2 = function useComposedRef3(libRef, userRef) {
  var prevUserRef = (0, import_react10.useRef)();
  return (0, import_react10.useCallback)(function(instance) {
    libRef.current = instance;
    if (prevUserRef.current) {
      updateRef(prevUserRef.current, null);
    }
    prevUserRef.current = userRef;
    if (!userRef) {
      return;
    }
    updateRef(userRef, instance);
  }, [userRef]);
};
var use_composed_ref_esm_default = useComposedRef2;

// node_modules/react-textarea-autosize/dist/react-textarea-autosize.browser.esm.js
var HIDDEN_TEXTAREA_STYLE = {
  "min-height": "0",
  "max-height": "none",
  height: "0",
  visibility: "hidden",
  overflow: "hidden",
  position: "absolute",
  "z-index": "-1000",
  top: "0",
  right: "0"
};
var forceHiddenStyles = function forceHiddenStyles2(node) {
  Object.keys(HIDDEN_TEXTAREA_STYLE).forEach(function(key) {
    node.style.setProperty(key, HIDDEN_TEXTAREA_STYLE[key], "important");
  });
};
var hiddenTextarea = null;
var getHeight = function getHeight2(node, sizingData) {
  var height = node.scrollHeight;
  if (sizingData.sizingStyle.boxSizing === "border-box") {
    return height + sizingData.borderSize;
  }
  return height - sizingData.paddingSize;
};
function calculateNodeHeight(sizingData, value, minRows, maxRows) {
  if (minRows === void 0) {
    minRows = 1;
  }
  if (maxRows === void 0) {
    maxRows = Infinity;
  }
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    hiddenTextarea.setAttribute("tabindex", "-1");
    hiddenTextarea.setAttribute("aria-hidden", "true");
    forceHiddenStyles(hiddenTextarea);
  }
  if (hiddenTextarea.parentNode === null) {
    document.body.appendChild(hiddenTextarea);
  }
  var paddingSize = sizingData.paddingSize, borderSize = sizingData.borderSize, sizingStyle = sizingData.sizingStyle;
  var boxSizing = sizingStyle.boxSizing;
  Object.keys(sizingStyle).forEach(function(_key) {
    var key = _key;
    hiddenTextarea.style[key] = sizingStyle[key];
  });
  forceHiddenStyles(hiddenTextarea);
  hiddenTextarea.value = value;
  var height = getHeight(hiddenTextarea, sizingData);
  hiddenTextarea.value = value;
  height = getHeight(hiddenTextarea, sizingData);
  hiddenTextarea.value = "x";
  var rowHeight = hiddenTextarea.scrollHeight - paddingSize;
  var minHeight = rowHeight * minRows;
  if (boxSizing === "border-box") {
    minHeight = minHeight + paddingSize + borderSize;
  }
  height = Math.max(minHeight, height);
  var maxHeight = rowHeight * maxRows;
  if (boxSizing === "border-box") {
    maxHeight = maxHeight + paddingSize + borderSize;
  }
  height = Math.min(maxHeight, height);
  return [height, rowHeight];
}
var noop2 = function noop3() {
};
var pick = function pick2(props, obj) {
  return props.reduce(function(acc, prop) {
    acc[prop] = obj[prop];
    return acc;
  }, {});
};
var SIZING_STYLE = [
  "borderBottomWidth",
  "borderLeftWidth",
  "borderRightWidth",
  "borderTopWidth",
  "boxSizing",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "lineHeight",
  "paddingBottom",
  "paddingLeft",
  "paddingRight",
  "paddingTop",
  // non-standard
  "tabSize",
  "textIndent",
  // non-standard
  "textRendering",
  "textTransform",
  "width",
  "wordBreak"
];
var isIE = !!document.documentElement.currentStyle;
var getSizingData = function getSizingData2(node) {
  var style2 = window.getComputedStyle(node);
  if (style2 === null) {
    return null;
  }
  var sizingStyle = pick(SIZING_STYLE, style2);
  var boxSizing = sizingStyle.boxSizing;
  if (boxSizing === "") {
    return null;
  }
  if (isIE && boxSizing === "border-box") {
    sizingStyle.width = parseFloat(sizingStyle.width) + parseFloat(sizingStyle.borderRightWidth) + parseFloat(sizingStyle.borderLeftWidth) + parseFloat(sizingStyle.paddingRight) + parseFloat(sizingStyle.paddingLeft) + "px";
  }
  var paddingSize = parseFloat(sizingStyle.paddingBottom) + parseFloat(sizingStyle.paddingTop);
  var borderSize = parseFloat(sizingStyle.borderBottomWidth) + parseFloat(sizingStyle.borderTopWidth);
  return {
    sizingStyle,
    paddingSize,
    borderSize
  };
};
function useListener(target, type, listener) {
  var latestListener = useLatest(listener);
  (0, import_react11.useLayoutEffect)(function() {
    var handler = function handler2(ev) {
      return latestListener.current(ev);
    };
    target.addEventListener(type, handler);
    return function() {
      return target.removeEventListener(type, handler);
    };
  }, []);
}
var useWindowResizeListener = function useWindowResizeListener2(listener) {
  useListener(window, "resize", listener);
};
var useFontsLoadedListener = function useFontsLoadedListener2(listener) {
  useListener(document.fonts, "loadingdone", listener);
};
var _excluded4 = ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"];
var TextareaAutosize = function TextareaAutosize2(_ref, userRef) {
  var cacheMeasurements = _ref.cacheMeasurements, maxRows = _ref.maxRows, minRows = _ref.minRows, _ref$onChange = _ref.onChange, onChange = _ref$onChange === void 0 ? noop2 : _ref$onChange, _ref$onHeightChange = _ref.onHeightChange, onHeightChange = _ref$onHeightChange === void 0 ? noop2 : _ref$onHeightChange, props = _objectWithoutPropertiesLoose(_ref, _excluded4);
  if (props.style) {
    if ("maxHeight" in props.style) {
      throw new Error("Using `style.maxHeight` for <TextareaAutosize/> is not supported. Please use `maxRows`.");
    }
    if ("minHeight" in props.style) {
      throw new Error("Using `style.minHeight` for <TextareaAutosize/> is not supported. Please use `minRows`.");
    }
  }
  var isControlled = props.value !== void 0;
  var libRef = (0, import_react11.useRef)(null);
  var ref2 = use_composed_ref_esm_default(libRef, userRef);
  var heightRef = (0, import_react11.useRef)(0);
  var measurementsCacheRef = (0, import_react11.useRef)();
  var resizeTextarea = function resizeTextarea2() {
    var node = libRef.current;
    var nodeSizingData = cacheMeasurements && measurementsCacheRef.current ? measurementsCacheRef.current : getSizingData(node);
    if (!nodeSizingData) {
      return;
    }
    measurementsCacheRef.current = nodeSizingData;
    var _calculateNodeHeight = calculateNodeHeight(nodeSizingData, node.value || node.placeholder || "x", minRows, maxRows), height = _calculateNodeHeight[0], rowHeight = _calculateNodeHeight[1];
    if (heightRef.current !== height) {
      heightRef.current = height;
      node.style.setProperty("height", height + "px", "important");
      onHeightChange(height, {
        rowHeight
      });
    }
  };
  var handleChange = function handleChange2(event) {
    if (!isControlled) {
      resizeTextarea();
    }
    onChange(event);
  };
  {
    (0, import_react11.useLayoutEffect)(resizeTextarea);
    useWindowResizeListener(resizeTextarea);
    useFontsLoadedListener(resizeTextarea);
  }
  return (0, import_react11.createElement)("textarea", _extends({}, props, {
    onChange: handleChange,
    ref: ref2
  }));
};
var index = (0, import_react11.forwardRef)(TextareaAutosize);
var react_textarea_autosize_browser_esm_default = index;

// node_modules/re-resizable/lib/index.js
var React6 = __toESM(require_react());
var import_react_dom3 = __toESM(require_react_dom());

// node_modules/re-resizable/lib/resizer.js
var React5 = __toESM(require_react());
var __extends = function() {
  var extendStatics = function(d17, b6) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d18, b7) {
      d18.__proto__ = b7;
    } || function(d18, b7) {
      for (var p12 in b7)
        if (Object.prototype.hasOwnProperty.call(b7, p12))
          d18[p12] = b7[p12];
    };
    return extendStatics(d17, b6);
  };
  return function(d17, b6) {
    extendStatics(d17, b6);
    function __() {
      this.constructor = d17;
    }
    d17.prototype = b6 === null ? Object.create(b6) : (__.prototype = b6.prototype, new __());
  };
}();
var __assign2 = function() {
  __assign2 = Object.assign || function(t20) {
    for (var s20, i15 = 1, n12 = arguments.length; i15 < n12; i15++) {
      s20 = arguments[i15];
      for (var p12 in s20)
        if (Object.prototype.hasOwnProperty.call(s20, p12))
          t20[p12] = s20[p12];
    }
    return t20;
  };
  return __assign2.apply(this, arguments);
};
var rowSizeBase = {
  width: "100%",
  height: "10px",
  top: "0px",
  left: "0px",
  cursor: "row-resize"
};
var colSizeBase = {
  width: "10px",
  height: "100%",
  top: "0px",
  left: "0px",
  cursor: "col-resize"
};
var edgeBase = {
  width: "20px",
  height: "20px",
  position: "absolute"
};
var styles = {
  top: __assign2(__assign2({}, rowSizeBase), { top: "-5px" }),
  right: __assign2(__assign2({}, colSizeBase), { left: void 0, right: "-5px" }),
  bottom: __assign2(__assign2({}, rowSizeBase), { top: void 0, bottom: "-5px" }),
  left: __assign2(__assign2({}, colSizeBase), { left: "-5px" }),
  topRight: __assign2(__assign2({}, edgeBase), { right: "-10px", top: "-10px", cursor: "ne-resize" }),
  bottomRight: __assign2(__assign2({}, edgeBase), { right: "-10px", bottom: "-10px", cursor: "se-resize" }),
  bottomLeft: __assign2(__assign2({}, edgeBase), { left: "-10px", bottom: "-10px", cursor: "sw-resize" }),
  topLeft: __assign2(__assign2({}, edgeBase), { left: "-10px", top: "-10px", cursor: "nw-resize" })
};
var Resizer = (
  /** @class */
  function(_super) {
    __extends(Resizer3, _super);
    function Resizer3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.onMouseDown = function(e9) {
        _this.props.onResizeStart(e9, _this.props.direction);
      };
      _this.onTouchStart = function(e9) {
        _this.props.onResizeStart(e9, _this.props.direction);
      };
      return _this;
    }
    Resizer3.prototype.render = function() {
      return React5.createElement("div", { className: this.props.className || "", style: __assign2(__assign2({ position: "absolute", userSelect: "none" }, styles[this.props.direction]), this.props.replaceStyles || {}), onMouseDown: this.onMouseDown, onTouchStart: this.onTouchStart }, this.props.children);
    };
    return Resizer3;
  }(React5.PureComponent)
);

// node_modules/re-resizable/lib/index.js
var __extends2 = function() {
  var extendStatics = function(d17, b6) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d18, b7) {
      d18.__proto__ = b7;
    } || function(d18, b7) {
      for (var p12 in b7)
        if (Object.prototype.hasOwnProperty.call(b7, p12))
          d18[p12] = b7[p12];
    };
    return extendStatics(d17, b6);
  };
  return function(d17, b6) {
    extendStatics(d17, b6);
    function __() {
      this.constructor = d17;
    }
    d17.prototype = b6 === null ? Object.create(b6) : (__.prototype = b6.prototype, new __());
  };
}();
var __assign3 = function() {
  __assign3 = Object.assign || function(t20) {
    for (var s20, i15 = 1, n12 = arguments.length; i15 < n12; i15++) {
      s20 = arguments[i15];
      for (var p12 in s20)
        if (Object.prototype.hasOwnProperty.call(s20, p12))
          t20[p12] = s20[p12];
    }
    return t20;
  };
  return __assign3.apply(this, arguments);
};
var DEFAULT_SIZE = {
  width: "auto",
  height: "auto"
};
var clamp = function(n12, min4, max4) {
  return Math.max(Math.min(n12, max4), min4);
};
var snap = function(n12, size2) {
  return Math.round(n12 / size2) * size2;
};
var hasDirection = function(dir, target) {
  return new RegExp(dir, "i").test(target);
};
var isTouchEvent = function(event) {
  return Boolean(event.touches && event.touches.length);
};
var isMouseEvent = function(event) {
  return Boolean((event.clientX || event.clientX === 0) && (event.clientY || event.clientY === 0));
};
var findClosestSnap = function(n12, snapArray, snapGap) {
  if (snapGap === void 0) {
    snapGap = 0;
  }
  var closestGapIndex = snapArray.reduce(function(prev, curr, index2) {
    return Math.abs(curr - n12) < Math.abs(snapArray[prev] - n12) ? index2 : prev;
  }, 0);
  var gap = Math.abs(snapArray[closestGapIndex] - n12);
  return snapGap === 0 || gap < snapGap ? snapArray[closestGapIndex] : n12;
};
var getStringSize = function(n12) {
  n12 = n12.toString();
  if (n12 === "auto") {
    return n12;
  }
  if (n12.endsWith("px")) {
    return n12;
  }
  if (n12.endsWith("%")) {
    return n12;
  }
  if (n12.endsWith("vh")) {
    return n12;
  }
  if (n12.endsWith("vw")) {
    return n12;
  }
  if (n12.endsWith("vmax")) {
    return n12;
  }
  if (n12.endsWith("vmin")) {
    return n12;
  }
  return n12 + "px";
};
var getPixelSize = function(size2, parentSize, innerWidth2, innerHeight2) {
  if (size2 && typeof size2 === "string") {
    if (size2.endsWith("px")) {
      return Number(size2.replace("px", ""));
    }
    if (size2.endsWith("%")) {
      var ratio = Number(size2.replace("%", "")) / 100;
      return parentSize * ratio;
    }
    if (size2.endsWith("vw")) {
      var ratio = Number(size2.replace("vw", "")) / 100;
      return innerWidth2 * ratio;
    }
    if (size2.endsWith("vh")) {
      var ratio = Number(size2.replace("vh", "")) / 100;
      return innerHeight2 * ratio;
    }
  }
  return size2;
};
var calculateNewMax = function(parentSize, innerWidth2, innerHeight2, maxWidth, maxHeight, minWidth, minHeight) {
  maxWidth = getPixelSize(maxWidth, parentSize.width, innerWidth2, innerHeight2);
  maxHeight = getPixelSize(maxHeight, parentSize.height, innerWidth2, innerHeight2);
  minWidth = getPixelSize(minWidth, parentSize.width, innerWidth2, innerHeight2);
  minHeight = getPixelSize(minHeight, parentSize.height, innerWidth2, innerHeight2);
  return {
    maxWidth: typeof maxWidth === "undefined" ? void 0 : Number(maxWidth),
    maxHeight: typeof maxHeight === "undefined" ? void 0 : Number(maxHeight),
    minWidth: typeof minWidth === "undefined" ? void 0 : Number(minWidth),
    minHeight: typeof minHeight === "undefined" ? void 0 : Number(minHeight)
  };
};
var definedProps = [
  "as",
  "style",
  "className",
  "grid",
  "snap",
  "bounds",
  "boundsByDirection",
  "size",
  "defaultSize",
  "minWidth",
  "minHeight",
  "maxWidth",
  "maxHeight",
  "lockAspectRatio",
  "lockAspectRatioExtraWidth",
  "lockAspectRatioExtraHeight",
  "enable",
  "handleStyles",
  "handleClasses",
  "handleWrapperStyle",
  "handleWrapperClass",
  "children",
  "onResizeStart",
  "onResize",
  "onResizeStop",
  "handleComponent",
  "scale",
  "resizeRatio",
  "snapGap"
];
var baseClassName = "__resizable_base__";
var Resizable = (
  /** @class */
  function(_super) {
    __extends2(Resizable3, _super);
    function Resizable3(props) {
      var _this = _super.call(this, props) || this;
      _this.ratio = 1;
      _this.resizable = null;
      _this.parentLeft = 0;
      _this.parentTop = 0;
      _this.resizableLeft = 0;
      _this.resizableRight = 0;
      _this.resizableTop = 0;
      _this.resizableBottom = 0;
      _this.targetLeft = 0;
      _this.targetTop = 0;
      _this.appendBase = function() {
        if (!_this.resizable || !_this.window) {
          return null;
        }
        var parent2 = _this.parentNode;
        if (!parent2) {
          return null;
        }
        var element = _this.window.document.createElement("div");
        element.style.width = "100%";
        element.style.height = "100%";
        element.style.position = "absolute";
        element.style.transform = "scale(0, 0)";
        element.style.left = "0";
        element.style.flex = "0 0 100%";
        if (element.classList) {
          element.classList.add(baseClassName);
        } else {
          element.className += baseClassName;
        }
        parent2.appendChild(element);
        return element;
      };
      _this.removeBase = function(base) {
        var parent2 = _this.parentNode;
        if (!parent2) {
          return;
        }
        parent2.removeChild(base);
      };
      _this.ref = function(c16) {
        if (c16) {
          _this.resizable = c16;
        }
      };
      _this.state = {
        isResizing: false,
        width: typeof (_this.propsSize && _this.propsSize.width) === "undefined" ? "auto" : _this.propsSize && _this.propsSize.width,
        height: typeof (_this.propsSize && _this.propsSize.height) === "undefined" ? "auto" : _this.propsSize && _this.propsSize.height,
        direction: "right",
        original: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        },
        backgroundStyle: {
          height: "100%",
          width: "100%",
          backgroundColor: "rgba(0,0,0,0)",
          cursor: "auto",
          opacity: 0,
          position: "fixed",
          zIndex: 9999,
          top: "0",
          left: "0",
          bottom: "0",
          right: "0"
        },
        flexBasis: void 0
      };
      _this.onResizeStart = _this.onResizeStart.bind(_this);
      _this.onMouseMove = _this.onMouseMove.bind(_this);
      _this.onMouseUp = _this.onMouseUp.bind(_this);
      return _this;
    }
    Object.defineProperty(Resizable3.prototype, "parentNode", {
      get: function() {
        if (!this.resizable) {
          return null;
        }
        return this.resizable.parentNode;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resizable3.prototype, "window", {
      get: function() {
        if (!this.resizable) {
          return null;
        }
        if (!this.resizable.ownerDocument) {
          return null;
        }
        return this.resizable.ownerDocument.defaultView;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resizable3.prototype, "propsSize", {
      get: function() {
        return this.props.size || this.props.defaultSize || DEFAULT_SIZE;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resizable3.prototype, "size", {
      get: function() {
        var width = 0;
        var height = 0;
        if (this.resizable && this.window) {
          var orgWidth = this.resizable.offsetWidth;
          var orgHeight = this.resizable.offsetHeight;
          var orgPosition = this.resizable.style.position;
          if (orgPosition !== "relative") {
            this.resizable.style.position = "relative";
          }
          width = this.resizable.style.width !== "auto" ? this.resizable.offsetWidth : orgWidth;
          height = this.resizable.style.height !== "auto" ? this.resizable.offsetHeight : orgHeight;
          this.resizable.style.position = orgPosition;
        }
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resizable3.prototype, "sizeStyle", {
      get: function() {
        var _this = this;
        var size2 = this.props.size;
        var getSize4 = function(key) {
          if (typeof _this.state[key] === "undefined" || _this.state[key] === "auto") {
            return "auto";
          }
          if (_this.propsSize && _this.propsSize[key] && _this.propsSize[key].toString().endsWith("%")) {
            if (_this.state[key].toString().endsWith("%")) {
              return _this.state[key].toString();
            }
            var parentSize = _this.getParentSize();
            var value = Number(_this.state[key].toString().replace("px", ""));
            var percent = value / parentSize[key] * 100;
            return percent + "%";
          }
          return getStringSize(_this.state[key]);
        };
        var width = size2 && typeof size2.width !== "undefined" && !this.state.isResizing ? getStringSize(size2.width) : getSize4("width");
        var height = size2 && typeof size2.height !== "undefined" && !this.state.isResizing ? getStringSize(size2.height) : getSize4("height");
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Resizable3.prototype.getParentSize = function() {
      if (!this.parentNode) {
        if (!this.window) {
          return { width: 0, height: 0 };
        }
        return { width: this.window.innerWidth, height: this.window.innerHeight };
      }
      var base = this.appendBase();
      if (!base) {
        return { width: 0, height: 0 };
      }
      var wrapChanged = false;
      var wrap = this.parentNode.style.flexWrap;
      if (wrap !== "wrap") {
        wrapChanged = true;
        this.parentNode.style.flexWrap = "wrap";
      }
      base.style.position = "relative";
      base.style.minWidth = "100%";
      base.style.minHeight = "100%";
      var size2 = {
        width: base.offsetWidth,
        height: base.offsetHeight
      };
      if (wrapChanged) {
        this.parentNode.style.flexWrap = wrap;
      }
      this.removeBase(base);
      return size2;
    };
    Resizable3.prototype.bindEvents = function() {
      if (this.window) {
        this.window.addEventListener("mouseup", this.onMouseUp);
        this.window.addEventListener("mousemove", this.onMouseMove);
        this.window.addEventListener("mouseleave", this.onMouseUp);
        this.window.addEventListener("touchmove", this.onMouseMove, {
          capture: true,
          passive: false
        });
        this.window.addEventListener("touchend", this.onMouseUp);
      }
    };
    Resizable3.prototype.unbindEvents = function() {
      if (this.window) {
        this.window.removeEventListener("mouseup", this.onMouseUp);
        this.window.removeEventListener("mousemove", this.onMouseMove);
        this.window.removeEventListener("mouseleave", this.onMouseUp);
        this.window.removeEventListener("touchmove", this.onMouseMove, true);
        this.window.removeEventListener("touchend", this.onMouseUp);
      }
    };
    Resizable3.prototype.componentDidMount = function() {
      if (!this.resizable || !this.window) {
        return;
      }
      var computedStyle = this.window.getComputedStyle(this.resizable);
      this.setState({
        width: this.state.width || this.size.width,
        height: this.state.height || this.size.height,
        flexBasis: computedStyle.flexBasis !== "auto" ? computedStyle.flexBasis : void 0
      });
    };
    Resizable3.prototype.componentWillUnmount = function() {
      if (this.window) {
        this.unbindEvents();
      }
    };
    Resizable3.prototype.createSizeForCssProperty = function(newSize, kind) {
      var propsSize = this.propsSize && this.propsSize[kind];
      return this.state[kind] === "auto" && this.state.original[kind] === newSize && (typeof propsSize === "undefined" || propsSize === "auto") ? "auto" : newSize;
    };
    Resizable3.prototype.calculateNewMaxFromBoundary = function(maxWidth, maxHeight) {
      var boundsByDirection = this.props.boundsByDirection;
      var direction = this.state.direction;
      var widthByDirection = boundsByDirection && hasDirection("left", direction);
      var heightByDirection = boundsByDirection && hasDirection("top", direction);
      var boundWidth;
      var boundHeight;
      if (this.props.bounds === "parent") {
        var parent_1 = this.parentNode;
        if (parent_1) {
          boundWidth = widthByDirection ? this.resizableRight - this.parentLeft : parent_1.offsetWidth + (this.parentLeft - this.resizableLeft);
          boundHeight = heightByDirection ? this.resizableBottom - this.parentTop : parent_1.offsetHeight + (this.parentTop - this.resizableTop);
        }
      } else if (this.props.bounds === "window") {
        if (this.window) {
          boundWidth = widthByDirection ? this.resizableRight : this.window.innerWidth - this.resizableLeft;
          boundHeight = heightByDirection ? this.resizableBottom : this.window.innerHeight - this.resizableTop;
        }
      } else if (this.props.bounds) {
        boundWidth = widthByDirection ? this.resizableRight - this.targetLeft : this.props.bounds.offsetWidth + (this.targetLeft - this.resizableLeft);
        boundHeight = heightByDirection ? this.resizableBottom - this.targetTop : this.props.bounds.offsetHeight + (this.targetTop - this.resizableTop);
      }
      if (boundWidth && Number.isFinite(boundWidth)) {
        maxWidth = maxWidth && maxWidth < boundWidth ? maxWidth : boundWidth;
      }
      if (boundHeight && Number.isFinite(boundHeight)) {
        maxHeight = maxHeight && maxHeight < boundHeight ? maxHeight : boundHeight;
      }
      return { maxWidth, maxHeight };
    };
    Resizable3.prototype.calculateNewSizeFromDirection = function(clientX, clientY) {
      var scale = this.props.scale || 1;
      var resizeRatio = this.props.resizeRatio || 1;
      var _a = this.state, direction = _a.direction, original = _a.original;
      var _b = this.props, lockAspectRatio = _b.lockAspectRatio, lockAspectRatioExtraHeight = _b.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _b.lockAspectRatioExtraWidth;
      var newWidth = original.width;
      var newHeight = original.height;
      var extraHeight = lockAspectRatioExtraHeight || 0;
      var extraWidth = lockAspectRatioExtraWidth || 0;
      if (hasDirection("right", direction)) {
        newWidth = original.width + (clientX - original.x) * resizeRatio / scale;
        if (lockAspectRatio) {
          newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;
        }
      }
      if (hasDirection("left", direction)) {
        newWidth = original.width - (clientX - original.x) * resizeRatio / scale;
        if (lockAspectRatio) {
          newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;
        }
      }
      if (hasDirection("bottom", direction)) {
        newHeight = original.height + (clientY - original.y) * resizeRatio / scale;
        if (lockAspectRatio) {
          newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;
        }
      }
      if (hasDirection("top", direction)) {
        newHeight = original.height - (clientY - original.y) * resizeRatio / scale;
        if (lockAspectRatio) {
          newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;
        }
      }
      return { newWidth, newHeight };
    };
    Resizable3.prototype.calculateNewSizeFromAspectRatio = function(newWidth, newHeight, max4, min4) {
      var _a = this.props, lockAspectRatio = _a.lockAspectRatio, lockAspectRatioExtraHeight = _a.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _a.lockAspectRatioExtraWidth;
      var computedMinWidth = typeof min4.width === "undefined" ? 10 : min4.width;
      var computedMaxWidth = typeof max4.width === "undefined" || max4.width < 0 ? newWidth : max4.width;
      var computedMinHeight = typeof min4.height === "undefined" ? 10 : min4.height;
      var computedMaxHeight = typeof max4.height === "undefined" || max4.height < 0 ? newHeight : max4.height;
      var extraHeight = lockAspectRatioExtraHeight || 0;
      var extraWidth = lockAspectRatioExtraWidth || 0;
      if (lockAspectRatio) {
        var extraMinWidth = (computedMinHeight - extraHeight) * this.ratio + extraWidth;
        var extraMaxWidth = (computedMaxHeight - extraHeight) * this.ratio + extraWidth;
        var extraMinHeight = (computedMinWidth - extraWidth) / this.ratio + extraHeight;
        var extraMaxHeight = (computedMaxWidth - extraWidth) / this.ratio + extraHeight;
        var lockedMinWidth = Math.max(computedMinWidth, extraMinWidth);
        var lockedMaxWidth = Math.min(computedMaxWidth, extraMaxWidth);
        var lockedMinHeight = Math.max(computedMinHeight, extraMinHeight);
        var lockedMaxHeight = Math.min(computedMaxHeight, extraMaxHeight);
        newWidth = clamp(newWidth, lockedMinWidth, lockedMaxWidth);
        newHeight = clamp(newHeight, lockedMinHeight, lockedMaxHeight);
      } else {
        newWidth = clamp(newWidth, computedMinWidth, computedMaxWidth);
        newHeight = clamp(newHeight, computedMinHeight, computedMaxHeight);
      }
      return { newWidth, newHeight };
    };
    Resizable3.prototype.setBoundingClientRect = function() {
      if (this.props.bounds === "parent") {
        var parent_2 = this.parentNode;
        if (parent_2) {
          var parentRect = parent_2.getBoundingClientRect();
          this.parentLeft = parentRect.left;
          this.parentTop = parentRect.top;
        }
      }
      if (this.props.bounds && typeof this.props.bounds !== "string") {
        var targetRect = this.props.bounds.getBoundingClientRect();
        this.targetLeft = targetRect.left;
        this.targetTop = targetRect.top;
      }
      if (this.resizable) {
        var _a = this.resizable.getBoundingClientRect(), left = _a.left, top_1 = _a.top, right = _a.right, bottom = _a.bottom;
        this.resizableLeft = left;
        this.resizableRight = right;
        this.resizableTop = top_1;
        this.resizableBottom = bottom;
      }
    };
    Resizable3.prototype.onResizeStart = function(event, direction) {
      if (!this.resizable || !this.window) {
        return;
      }
      var clientX = 0;
      var clientY = 0;
      if (event.nativeEvent && isMouseEvent(event.nativeEvent)) {
        clientX = event.nativeEvent.clientX;
        clientY = event.nativeEvent.clientY;
      } else if (event.nativeEvent && isTouchEvent(event.nativeEvent)) {
        clientX = event.nativeEvent.touches[0].clientX;
        clientY = event.nativeEvent.touches[0].clientY;
      }
      if (this.props.onResizeStart) {
        if (this.resizable) {
          var startResize = this.props.onResizeStart(event, direction, this.resizable);
          if (startResize === false) {
            return;
          }
        }
      }
      if (this.props.size) {
        if (typeof this.props.size.height !== "undefined" && this.props.size.height !== this.state.height) {
          this.setState({ height: this.props.size.height });
        }
        if (typeof this.props.size.width !== "undefined" && this.props.size.width !== this.state.width) {
          this.setState({ width: this.props.size.width });
        }
      }
      this.ratio = typeof this.props.lockAspectRatio === "number" ? this.props.lockAspectRatio : this.size.width / this.size.height;
      var flexBasis;
      var computedStyle = this.window.getComputedStyle(this.resizable);
      if (computedStyle.flexBasis !== "auto") {
        var parent_3 = this.parentNode;
        if (parent_3) {
          var dir = this.window.getComputedStyle(parent_3).flexDirection;
          this.flexDir = dir.startsWith("row") ? "row" : "column";
          flexBasis = computedStyle.flexBasis;
        }
      }
      this.setBoundingClientRect();
      this.bindEvents();
      var state = {
        original: {
          x: clientX,
          y: clientY,
          width: this.size.width,
          height: this.size.height
        },
        isResizing: true,
        backgroundStyle: __assign3(__assign3({}, this.state.backgroundStyle), { cursor: this.window.getComputedStyle(event.target).cursor || "auto" }),
        direction,
        flexBasis
      };
      this.setState(state);
    };
    Resizable3.prototype.onMouseMove = function(event) {
      var _this = this;
      if (!this.state.isResizing || !this.resizable || !this.window) {
        return;
      }
      if (this.window.TouchEvent && isTouchEvent(event)) {
        try {
          event.preventDefault();
          event.stopPropagation();
        } catch (e9) {
        }
      }
      var _a = this.props, maxWidth = _a.maxWidth, maxHeight = _a.maxHeight, minWidth = _a.minWidth, minHeight = _a.minHeight;
      var clientX = isTouchEvent(event) ? event.touches[0].clientX : event.clientX;
      var clientY = isTouchEvent(event) ? event.touches[0].clientY : event.clientY;
      var _b = this.state, direction = _b.direction, original = _b.original, width = _b.width, height = _b.height;
      var parentSize = this.getParentSize();
      var max4 = calculateNewMax(parentSize, this.window.innerWidth, this.window.innerHeight, maxWidth, maxHeight, minWidth, minHeight);
      maxWidth = max4.maxWidth;
      maxHeight = max4.maxHeight;
      minWidth = max4.minWidth;
      minHeight = max4.minHeight;
      var _c = this.calculateNewSizeFromDirection(clientX, clientY), newHeight = _c.newHeight, newWidth = _c.newWidth;
      var boundaryMax = this.calculateNewMaxFromBoundary(maxWidth, maxHeight);
      if (this.props.snap && this.props.snap.x) {
        newWidth = findClosestSnap(newWidth, this.props.snap.x, this.props.snapGap);
      }
      if (this.props.snap && this.props.snap.y) {
        newHeight = findClosestSnap(newHeight, this.props.snap.y, this.props.snapGap);
      }
      var newSize = this.calculateNewSizeFromAspectRatio(newWidth, newHeight, { width: boundaryMax.maxWidth, height: boundaryMax.maxHeight }, { width: minWidth, height: minHeight });
      newWidth = newSize.newWidth;
      newHeight = newSize.newHeight;
      if (this.props.grid) {
        var newGridWidth = snap(newWidth, this.props.grid[0]);
        var newGridHeight = snap(newHeight, this.props.grid[1]);
        var gap = this.props.snapGap || 0;
        newWidth = gap === 0 || Math.abs(newGridWidth - newWidth) <= gap ? newGridWidth : newWidth;
        newHeight = gap === 0 || Math.abs(newGridHeight - newHeight) <= gap ? newGridHeight : newHeight;
      }
      var delta = {
        width: newWidth - original.width,
        height: newHeight - original.height
      };
      if (width && typeof width === "string") {
        if (width.endsWith("%")) {
          var percent = newWidth / parentSize.width * 100;
          newWidth = percent + "%";
        } else if (width.endsWith("vw")) {
          var vw = newWidth / this.window.innerWidth * 100;
          newWidth = vw + "vw";
        } else if (width.endsWith("vh")) {
          var vh = newWidth / this.window.innerHeight * 100;
          newWidth = vh + "vh";
        }
      }
      if (height && typeof height === "string") {
        if (height.endsWith("%")) {
          var percent = newHeight / parentSize.height * 100;
          newHeight = percent + "%";
        } else if (height.endsWith("vw")) {
          var vw = newHeight / this.window.innerWidth * 100;
          newHeight = vw + "vw";
        } else if (height.endsWith("vh")) {
          var vh = newHeight / this.window.innerHeight * 100;
          newHeight = vh + "vh";
        }
      }
      var newState = {
        width: this.createSizeForCssProperty(newWidth, "width"),
        height: this.createSizeForCssProperty(newHeight, "height")
      };
      if (this.flexDir === "row") {
        newState.flexBasis = newState.width;
      } else if (this.flexDir === "column") {
        newState.flexBasis = newState.height;
      }
      (0, import_react_dom3.flushSync)(function() {
        _this.setState(newState);
      });
      if (this.props.onResize) {
        this.props.onResize(event, direction, this.resizable, delta);
      }
    };
    Resizable3.prototype.onMouseUp = function(event) {
      var _a = this.state, isResizing = _a.isResizing, direction = _a.direction, original = _a.original;
      if (!isResizing || !this.resizable) {
        return;
      }
      var delta = {
        width: this.size.width - original.width,
        height: this.size.height - original.height
      };
      if (this.props.onResizeStop) {
        this.props.onResizeStop(event, direction, this.resizable, delta);
      }
      if (this.props.size) {
        this.setState(this.props.size);
      }
      this.unbindEvents();
      this.setState({
        isResizing: false,
        backgroundStyle: __assign3(__assign3({}, this.state.backgroundStyle), { cursor: "auto" })
      });
    };
    Resizable3.prototype.updateSize = function(size2) {
      this.setState({ width: size2.width, height: size2.height });
    };
    Resizable3.prototype.renderResizer = function() {
      var _this = this;
      var _a = this.props, enable = _a.enable, handleStyles = _a.handleStyles, handleClasses = _a.handleClasses, handleWrapperStyle = _a.handleWrapperStyle, handleWrapperClass = _a.handleWrapperClass, handleComponent = _a.handleComponent;
      if (!enable) {
        return null;
      }
      var resizers = Object.keys(enable).map(function(dir) {
        if (enable[dir] !== false) {
          return React6.createElement(Resizer, { key: dir, direction: dir, onResizeStart: _this.onResizeStart, replaceStyles: handleStyles && handleStyles[dir], className: handleClasses && handleClasses[dir] }, handleComponent && handleComponent[dir] ? handleComponent[dir] : null);
        }
        return null;
      });
      return React6.createElement("div", { className: handleWrapperClass, style: handleWrapperStyle }, resizers);
    };
    Resizable3.prototype.render = function() {
      var _this = this;
      var extendsProps = Object.keys(this.props).reduce(function(acc, key) {
        if (definedProps.indexOf(key) !== -1) {
          return acc;
        }
        acc[key] = _this.props[key];
        return acc;
      }, {});
      var style2 = __assign3(__assign3(__assign3({ position: "relative", userSelect: this.state.isResizing ? "none" : "auto" }, this.props.style), this.sizeStyle), { maxWidth: this.props.maxWidth, maxHeight: this.props.maxHeight, minWidth: this.props.minWidth, minHeight: this.props.minHeight, boxSizing: "border-box", flexShrink: 0 });
      if (this.state.flexBasis) {
        style2.flexBasis = this.state.flexBasis;
      }
      var Wrapper2 = this.props.as || "div";
      return React6.createElement(
        Wrapper2,
        __assign3({ ref: this.ref, style: style2, className: this.props.className }, extendsProps),
        this.state.isResizing && React6.createElement("div", { style: this.state.backgroundStyle }),
        this.props.children,
        this.renderResizer()
      );
    };
    Resizable3.defaultProps = {
      as: "div",
      onResizeStart: function() {
      },
      onResize: function() {
      },
      onResizeStop: function() {
      },
      enable: {
        top: true,
        right: true,
        bottom: true,
        left: true,
        topRight: true,
        bottomRight: true,
        bottomLeft: true,
        topLeft: true
      },
      style: {},
      grid: [1, 1],
      lockAspectRatio: false,
      lockAspectRatioExtraWidth: 0,
      lockAspectRatioExtraHeight: 0,
      scale: 1,
      resizeRatio: 1,
      snapGap: 0
    };
    return Resizable3;
  }(React6.PureComponent)
);

// node_modules/@udecode/plate-image/dist/index.es.js
function unwrapExports6(x7) {
  return x7 && x7.__esModule && Object.prototype.hasOwnProperty.call(x7, "default") ? x7["default"] : x7;
}
function createCommonjsModule7(fn2, module2) {
  return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
}
var lib6 = createCommonjsModule7(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var IS_MAC = () => typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
  var MODIFIERS = {
    alt: "altKey",
    control: "ctrlKey",
    meta: "metaKey",
    shift: "shiftKey"
  };
  var ALIASES = () => ({
    add: "+",
    break: "pause",
    cmd: "meta",
    command: "meta",
    ctl: "control",
    ctrl: "control",
    del: "delete",
    down: "arrowdown",
    esc: "escape",
    ins: "insert",
    left: "arrowleft",
    mod: IS_MAC() ? "meta" : "control",
    opt: "alt",
    option: "alt",
    return: "enter",
    right: "arrowright",
    space: " ",
    spacebar: " ",
    up: "arrowup",
    win: "meta",
    windows: "meta"
  });
  var CODES = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    control: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    " ": 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    insert: 45,
    delete: 46,
    meta: 91,
    numlock: 144,
    scrolllock: 145,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
  };
  for (var f16 = 1; f16 < 20; f16++) {
    CODES["f" + f16] = 111 + f16;
  }
  function isHotkey14(hotkey, options, event) {
    if (options && !("byKey" in options)) {
      event = options;
      options = null;
    }
    if (!Array.isArray(hotkey)) {
      hotkey = [hotkey];
    }
    var array2 = hotkey.map(function(string2) {
      return parseHotkey(string2, options);
    });
    var check = function check2(e9) {
      return array2.some(function(object2) {
        return compareHotkey(object2, e9);
      });
    };
    var ret = event == null ? check : check(event);
    return ret;
  }
  function isCodeHotkey(hotkey, event) {
    return isHotkey14(hotkey, event);
  }
  function isKeyHotkey2(hotkey, event) {
    return isHotkey14(hotkey, { byKey: true }, event);
  }
  function parseHotkey(hotkey, options) {
    var byKey = options && options.byKey;
    var ret = {};
    hotkey = hotkey.replace("++", "+add");
    var values3 = hotkey.split("+");
    var length = values3.length;
    for (var k3 in MODIFIERS) {
      ret[MODIFIERS[k3]] = false;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = void 0;
    try {
      for (var _iterator = values3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var value = _step.value;
        var optional = value.endsWith("?") && value.length > 1;
        if (optional) {
          value = value.slice(0, -1);
        }
        var name2 = toKeyName(value);
        var modifier = MODIFIERS[name2];
        if (length === 1 || !modifier) {
          if (byKey) {
            ret.key = name2;
          } else {
            ret.which = toKeyCode(value);
          }
        }
        if (modifier) {
          ret[modifier] = optional ? null : true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return ret;
  }
  function compareHotkey(object2, event) {
    for (var key in object2) {
      var expected = object2[key];
      var actual = void 0;
      if (expected == null) {
        continue;
      }
      if (key === "key" && event.key != null) {
        actual = event.key.toLowerCase();
      } else if (key === "which") {
        actual = expected === 91 && event.which === 93 ? 91 : event.which;
      } else {
        actual = event[key];
      }
      if (actual == null && expected === false) {
        continue;
      }
      if (actual !== expected) {
        return false;
      }
    }
    return true;
  }
  function toKeyCode(name2) {
    name2 = toKeyName(name2);
    var code = CODES[name2] || name2.toUpperCase().charCodeAt(0);
    return code;
  }
  function toKeyName(name2) {
    name2 = name2.toLowerCase();
    name2 = ALIASES()[name2] || name2;
    return name2;
  }
  exports2.default = isHotkey14;
  exports2.isHotkey = isHotkey14;
  exports2.isCodeHotkey = isCodeHotkey;
  exports2.isKeyHotkey = isKeyHotkey2;
  exports2.parseHotkey = parseHotkey;
  exports2.compareHotkey = compareHotkey;
  exports2.toKeyCode = toKeyCode;
  exports2.toKeyName = toKeyName;
});
var isHotkey6 = unwrapExports6(lib6);
lib6.isHotkey;
lib6.isCodeHotkey;
lib6.isKeyHotkey;
lib6.parseHotkey;
lib6.compareHotkey;
lib6.toKeyCode;
lib6.toKeyName;
var useImageElement = () => useElement(ELEMENT_IMAGE);
var useImageCaptionString = () => {
  const {
    caption: nodeCaption = [{
      children: [{
        text: ""
      }]
    }]
  } = useImageElement();
  return (0, import_react12.useMemo)(() => {
    return getNodeString(nodeCaption[0]) || "";
  }, [nodeCaption]);
};
var useImageCaption = ({
  readOnly,
  ...props
} = {}) => {
  const width = useImageStore().get.width();
  return {
    style: {
      width
    },
    ...props
  };
};
var useImageCaptionState = (props) => {
  const captionString = useImageCaptionString();
  const selected = useSelected();
  const _readOnly = useReadOnly();
  const readOnly = props.readOnly || _readOnly;
  return {
    captionString,
    selected,
    readOnly
  };
};
var ImageCaption = createComponentAs((props) => {
  const htmlProps = useImageCaption(props);
  const {
    captionString,
    selected,
    readOnly
  } = useImageCaptionState(props);
  if (!captionString.length && (readOnly || !selected)) {
    return null;
  }
  return createElementAs("figcaption", htmlProps);
});
function _extends3() {
  _extends3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i15 = 1; i15 < arguments.length; i15++) {
      var source = arguments[i15];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends3.apply(this, arguments);
}
var TextareaAutosize3 = (0, import_react12.forwardRef)((props, ref2) => {
  const [isRerendered, setIsRerendered] = (0, import_react12.useState)(false);
  (0, import_react12.useLayoutEffect)(() => setIsRerendered(true), []);
  return isRerendered ? import_react12.default.createElement(react_textarea_autosize_browser_esm_default, _extends3({}, props, {
    ref: ref2
  })) : null;
});
var useImageCaptionTextareaFocus = (textareaRef) => {
  const editor = useEditorRef();
  const element = useImageElement();
  const focusCaptionPath = imageGlobalStore.use.focusEndCaptionPath();
  (0, import_react12.useEffect)(() => {
    if (focusCaptionPath && textareaRef.current) {
      const path = findNodePath(editor, element);
      if (path && Path.equals(path, focusCaptionPath)) {
        textareaRef.current.focus();
        imageGlobalStore.set.focusEndCaptionPath(null);
      }
    }
  }, [editor, element, focusCaptionPath, textareaRef]);
};
var useImageCaptionTextarea = (props) => {
  const element = useImageElement();
  const {
    caption: nodeCaption = [{
      children: [{
        text: ""
      }]
    }]
  } = element;
  const [captionValue, setCaptionValue] = (0, import_react12.useState)(getNodeString(nodeCaption[0]));
  const editor = useEditorRef();
  const readOnly = useReadOnly();
  const textareaRef = (0, import_react12.useRef)(null);
  const ref2 = useComposedRef(textareaRef, props.ref);
  useImageCaptionTextareaFocus(textareaRef);
  const onChange = (0, import_react12.useCallback)((e9) => {
    const newValue = e9.target.value;
    setCaptionValue(newValue);
    const path = findNodePath(editor, element);
    if (!path)
      return;
    setNodes(editor, {
      caption: [{
        text: newValue
      }]
    }, {
      at: path
    });
  }, [editor, element]);
  const onKeyDown = (e9) => {
    if (isHotkey6("up", e9)) {
      const path = findNodePath(editor, element);
      if (!path)
        return;
      e9.preventDefault();
      focusEditor(editor, path);
    }
    if (isHotkey6("down", e9)) {
      const path = findNodePath(editor, element);
      if (!path)
        return;
      const nextNodePath = getPointAfter(editor, path);
      if (!nextNodePath)
        return;
      e9.preventDefault();
      focusEditor(editor, nextNodePath);
    }
  };
  return {
    value: captionValue,
    readOnly,
    onChange,
    onKeyDown,
    ...props,
    ref: ref2
  };
};
var ImageCaptionTextarea = createComponentAs(({
  as: as2,
  ...props
}) => {
  const htmlProps = useImageCaptionTextarea({
    as: as2,
    ...props
  });
  return import_react12.default.createElement(TextareaAutosize3, htmlProps);
});
var useImageImg = (props) => {
  const {
    url
  } = useImageElement();
  const captionString = useImageCaptionString();
  return {
    src: url,
    alt: captionString,
    draggable: true,
    ...props
  };
};
var ImageImg = createComponentAs((props) => {
  const htmlProps = useImageImg(props);
  return createElementAs("img", htmlProps);
});
var useImageResizable = ({
  align = "center",
  readOnly,
  ...props
}) => {
  const element = useImageElement();
  const editor = useEditorRef();
  const _readOnly = useReadOnly();
  readOnly = isDefined(readOnly) ? readOnly : _readOnly;
  const {
    width: nodeWidth = "100%"
  } = element !== null && element !== void 0 ? element : {};
  const [width, setWidth] = useImageStore().use.width();
  const setNodeWidth = (0, import_react12.useCallback)((w7) => {
    const path = findNodePath(editor, element);
    if (!path)
      return;
    if (w7 === nodeWidth) {
      select(editor, path);
    } else {
      setNodes(editor, {
        width: w7
      }, {
        at: path
      });
    }
  }, [editor, element, nodeWidth]);
  (0, import_react12.useEffect)(() => {
    setWidth(nodeWidth);
  }, [nodeWidth, setWidth]);
  const defaultProps4 = {
    minWidth: 92,
    size: {
      width,
      height: "100%"
    },
    maxWidth: "100%",
    lockAspectRatio: true,
    resizeRatio: align === "center" ? 2 : 1,
    enable: {
      left: ["center", "left"].includes(align),
      right: ["center", "right"].includes(align)
    },
    handleStyles: {
      left: {
        left: 0
      },
      right: {
        right: 0
      }
    },
    onResize: (e9, direction, ref2) => {
      setWidth(ref2.offsetWidth);
    },
    onResizeStop: (e9, direction, ref2) => setNodeWidth(ref2.offsetWidth)
  };
  if (readOnly) {
    return {
      ...defaultProps4,
      ...props,
      enable: {
        left: false,
        right: false,
        top: false,
        bottom: false,
        topLeft: false,
        bottomLeft: false,
        topRight: false,
        bottomRight: false
      }
    };
  }
  return {
    ...defaultProps4,
    ...props
  };
};
var ImageResizable = createComponentAs((props) => {
  const resizableProps = useImageResizable(props);
  return import_react12.default.createElement(Resizable, resizableProps);
});
var {
  imageStore,
  useImageStore
} = createAtomStore({
  width: 0
}, {
  name: "image",
  scope: "img"
});
var imageGlobalStore = createStore4("image")({
  /**
   * When defined, focus end of caption textarea of the image with the same path.
   */
  focusEndCaptionPath: null,
  /**
   * When defined, focus start of caption textarea of the image with the same path.
   */
  focusStartCaptionPath: null
});
var useElementProps = ({
  attributes,
  nodeProps,
  element,
  editor,
  ...props
}) => {
  return {
    ...attributes,
    ...props,
    ...nodeProps,
    ref: useComposedRef(props.ref, attributes.ref)
  };
};
var ImageRoot = createComponentAs((props) => {
  const htmlProps = useElementProps(props);
  return createElementAs("div", htmlProps);
});
var insertImage = (editor, url) => {
  const text = {
    text: ""
  };
  const image = {
    type: getPluginType(editor, ELEMENT_IMAGE),
    url,
    children: [text]
  };
  insertNodes(editor, image);
};
var withImageUpload = (editor, plugin) => {
  const {
    options: {
      uploadImage
    }
  } = plugin;
  const {
    insertData
  } = editor;
  editor.insertData = (dataTransfer) => {
    const text = dataTransfer.getData("text/plain");
    const {
      files
    } = dataTransfer;
    if (files && files.length > 0) {
      const injectedPlugins = getInjectedPlugins(editor, plugin);
      if (!pipeInsertDataQuery(injectedPlugins, {
        data: text,
        dataTransfer
      })) {
        return insertData(dataTransfer);
      }
      for (const file of files) {
        const reader = new FileReader();
        const [mime] = file.type.split("/");
        if (mime === "image") {
          reader.addEventListener("load", async () => {
            if (!reader.result) {
              return;
            }
            const uploadedUrl = uploadImage ? await uploadImage(reader.result) : reader.result;
            insertImage(editor, uploadedUrl);
          });
          reader.readAsDataURL(file);
        }
      }
    } else {
      insertData(dataTransfer);
    }
  };
  return editor;
};
var ELEMENT_IMAGE = "img";
var createImagePlugin = createPluginFactory({
  key: ELEMENT_IMAGE,
  isElement: true,
  isVoid: true,
  withOverrides: withImageUpload,
  handlers: {
    onKeyDown: (editor) => (e9) => {
      if (isHotkey6("down", e9)) {
        const entry = getBlockAbove(editor, {
          match: {
            type: getPluginType(editor, ELEMENT_IMAGE)
          }
        });
        if (!entry)
          return;
        imageGlobalStore.set.focusEndCaptionPath(entry[1]);
      }
    }
  },
  then: (editor, {
    type
  }) => ({
    deserializeHtml: {
      rules: [{
        validNodeName: "IMG"
      }],
      getNode: (el) => ({
        type,
        url: el.getAttribute("src")
      })
    }
  })
});

// node_modules/@udecode/plate-indent/dist/index.es.js
var setIndent = (editor, {
  offset: offset5 = 1,
  getNodesOptions,
  setNodesProps,
  unsetNodesProps = []
}) => {
  const {
    nodeKey
  } = getPluginInjectProps(editor, KEY_INDENT);
  const _nodes = getNodeEntries(editor, {
    block: true,
    ...getNodesOptions
  });
  const nodes = Array.from(_nodes);
  withoutNormalizing(editor, () => {
    nodes.forEach(([node, path]) => {
      var _ref, _setNodesProps;
      const blockIndent = (_ref = node[nodeKey]) !== null && _ref !== void 0 ? _ref : 0;
      const newIndent = blockIndent + offset5;
      const props = (_setNodesProps = setNodesProps === null || setNodesProps === void 0 ? void 0 : setNodesProps({
        indent: newIndent
      })) !== null && _setNodesProps !== void 0 ? _setNodesProps : {};
      if (newIndent <= 0) {
        unsetNodes(editor, [nodeKey, ...unsetNodesProps], {
          at: path
        });
      } else {
        setElements(editor, {
          [nodeKey]: newIndent,
          ...props
        }, {
          at: path
        });
      }
    });
  });
};
var indent = (editor, options) => {
  setIndent(editor, {
    offset: 1,
    ...options
  });
};
var outdent = (editor, options) => {
  setIndent(editor, {
    offset: -1,
    ...options
  });
};
var onKeyDownIndent = (editor) => (e9) => {
  if (Hotkeys2.isTab(editor, e9)) {
    e9.preventDefault();
    indent(editor);
  }
  if (Hotkeys2.isUntab(editor, e9)) {
    e9.preventDefault();
    outdent(editor);
  }
};
var withIndent = (editor, {
  inject: {
    props: {
      validTypes
    } = {}
  },
  options: {
    indentMax
  }
}) => {
  const {
    normalizeNode
  } = editor;
  editor.normalizeNode = ([node, path]) => {
    const element = node;
    const {
      type
    } = element;
    if (type) {
      if (validTypes.includes(type)) {
        if (indentMax && element.indent && element.indent > indentMax) {
          setElements(editor, {
            indent: indentMax
          }, {
            at: path
          });
          return;
        }
      } else if (element.indent) {
        unsetNodes(editor, "indent", {
          at: path
        });
        return;
      }
    }
    return normalizeNode([node, path]);
  };
  return editor;
};
var KEY_INDENT = "indent";
var createIndentPlugin = createPluginFactory({
  key: KEY_INDENT,
  withOverrides: withIndent,
  handlers: {
    onKeyDown: onKeyDownIndent
  },
  options: {
    offset: 24,
    unit: "px"
  },
  then: (editor, {
    options: {
      offset: offset5,
      unit
    } = {}
  }) => ({
    inject: {
      props: {
        nodeKey: KEY_INDENT,
        styleKey: "marginLeft",
        validTypes: [getPluginType(editor, ELEMENT_DEFAULT)],
        transformNodeValue: ({
          nodeValue
        }) => nodeValue * offset5 + unit
      }
    }
  })
});
var KEY_TEXT_INDENT = "textIndent";
var createTextIndentPlugin = createPluginFactory({
  key: KEY_TEXT_INDENT,
  options: {
    offset: 24,
    unit: "px"
  },
  then: (editor, {
    options: {
      offset: offset5,
      unit
    } = {}
  }) => ({
    inject: {
      props: {
        nodeKey: KEY_TEXT_INDENT,
        styleKey: "textIndent",
        validTypes: [getPluginType(editor, ELEMENT_DEFAULT)],
        transformNodeValue({
          nodeValue
        }) {
          return nodeValue * offset5 + unit;
        }
      }
    }
  })
});

// node_modules/@udecode/plate-indent-list/dist/index.es.js
var import_react13 = __toESM(require_react());
function toVal(mix) {
  var k3, y9, str = "";
  if (typeof mix === "string" || typeof mix === "number") {
    str += mix;
  } else if (typeof mix === "object") {
    if (Array.isArray(mix)) {
      for (k3 = 0; k3 < mix.length; k3++) {
        if (mix[k3]) {
          if (y9 = toVal(mix[k3])) {
            str && (str += " ");
            str += y9;
          }
        }
      }
    } else {
      for (k3 in mix) {
        if (mix[k3]) {
          str && (str += " ");
          str += k3;
        }
      }
    }
  }
  return str;
}
function clsx2() {
  var i15 = 0, tmp, x7, str = "";
  while (i15 < arguments.length) {
    if (tmp = arguments[i15++]) {
      if (x7 = toVal(tmp)) {
        str && (str += " ");
        str += x7;
      }
    }
  }
  return str;
}
var ListStyleType;
(function(ListStyleType2) {
  ListStyleType2["Armenian"] = "armenian";
  ListStyleType2["Circle"] = "circle";
  ListStyleType2["CjkIdeographic"] = "cjk-ideographic";
  ListStyleType2["Decimal"] = "decimal";
  ListStyleType2["DecimalLeadingZero"] = "decimal-leading-zero";
  ListStyleType2["Disc"] = "disc";
  ListStyleType2["Georgian"] = "georgian";
  ListStyleType2["Hebrew"] = "hebrew";
  ListStyleType2["Hiragana"] = "hiragana";
  ListStyleType2["HiraganaIroha"] = "hiragana-iroha";
  ListStyleType2["Katakana"] = "katakana";
  ListStyleType2["KatakanaIroha"] = "katakana-iroha";
  ListStyleType2["LowerAlpha"] = "lower-alpha";
  ListStyleType2["LowerGreek"] = "lower-greek";
  ListStyleType2["LowerLatin"] = "lower-latin";
  ListStyleType2["LowerRoman"] = "lower-roman";
  ListStyleType2["None"] = "none";
  ListStyleType2["Square"] = "square";
  ListStyleType2["UpperAlpha"] = "upper-alpha";
  ListStyleType2["UpperLatin"] = "upper-latin";
  ListStyleType2["UpperRoman"] = "upper-roman";
  ListStyleType2["Initial"] = "initial";
  ListStyleType2["Inherit"] = "inherit";
})(ListStyleType || (ListStyleType = {}));
var injectIndentListComponent = (props) => {
  const {
    element
  } = props;
  const listStyleType = element[KEY_LIST_STYLE_TYPE];
  const listStart = element[KEY_LIST_START];
  if (listStyleType) {
    let className = clsx2(`slate-${KEY_LIST_STYLE_TYPE}-${listStyleType}`);
    const style2 = {
      padding: 0,
      margin: 0,
      listStyleType
    };
    if ([ListStyleType.Disc, ListStyleType.Circle, ListStyleType.Square].includes(listStyleType)) {
      className = clsx2(className, "slate-list-bullet");
      return ({
        children
      }) => import_react13.default.createElement("ul", {
        style: style2,
        className
      }, import_react13.default.createElement("li", null, children));
    }
    className = clsx2(className, "slate-list-number");
    return ({
      children
    }) => import_react13.default.createElement("ol", {
      style: style2,
      className,
      start: listStart
    }, import_react13.default.createElement("li", null, children));
  }
};
var getSiblingIndentList = (editor, [node, path], {
  getPreviousEntry,
  getNextEntry,
  query,
  eqIndent = true,
  breakQuery,
  breakOnLowerIndent = true,
  breakOnEqIndentNeqListStyleType = true
}) => {
  if (!getPreviousEntry && !getNextEntry)
    return;
  const getSiblingEntry = getNextEntry !== null && getNextEntry !== void 0 ? getNextEntry : getPreviousEntry;
  let nextEntry = getSiblingEntry([node, path]);
  while (true) {
    if (!nextEntry)
      return;
    const [nextNode, nextPath] = nextEntry;
    const indent2 = node[KEY_INDENT];
    const nextIndent = nextNode[KEY_INDENT];
    if (!nextIndent)
      return;
    if (breakQuery && breakQuery(nextNode))
      return;
    if (breakOnLowerIndent && nextIndent < indent2)
      return;
    if (breakOnEqIndentNeqListStyleType && nextIndent === indent2 && nextNode[KEY_LIST_STYLE_TYPE] !== node[KEY_LIST_STYLE_TYPE])
      return;
    let valid = !query || query(nextNode);
    if (valid) {
      valid = !eqIndent || nextIndent === indent2;
      if (valid)
        return [nextNode, nextPath];
    }
    nextEntry = getSiblingEntry(nextEntry);
  }
};
var getNextIndentList = (editor, entry, options) => {
  return getSiblingIndentList(editor, entry, {
    getNextEntry: ([, currPath]) => {
      const nextPath = Path.next(currPath);
      const nextNode = getNode(editor, nextPath);
      if (!nextNode)
        return;
      return [nextNode, nextPath];
    },
    ...options,
    getPreviousEntry: void 0
  });
};
var getPreviousIndentList = (editor, entry, options) => {
  return getSiblingIndentList(editor, entry, {
    getPreviousEntry: ([, currPath]) => {
      const prevPath = getPreviousPath(currPath);
      if (!prevPath)
        return;
      const prevNode = getNode(editor, prevPath);
      if (!prevNode)
        return;
      return [prevNode, prevPath];
    },
    ...options,
    getNextEntry: void 0
  });
};
var normalizeFirstIndentListStart = (editor, [node, path]) => {
  if (isDefined(node[KEY_LIST_START])) {
    unsetNodes(editor, KEY_LIST_START, {
      at: path
    });
    return true;
  }
};
var normalizeNextIndentListStart = (editor, entry, prevEntry) => {
  var _ref, _ref2;
  const [node, path] = entry;
  const [prevNode] = prevEntry !== null && prevEntry !== void 0 ? prevEntry : [null];
  const prevListStart = (_ref = prevNode === null || prevNode === void 0 ? void 0 : prevNode[KEY_LIST_START]) !== null && _ref !== void 0 ? _ref : 1;
  const currListStart = (_ref2 = node[KEY_LIST_START]) !== null && _ref2 !== void 0 ? _ref2 : 1;
  const listStart = prevListStart + 1;
  if (currListStart !== listStart) {
    setElements(editor, {
      [KEY_LIST_START]: listStart
    }, {
      at: path
    });
    return true;
  }
  return false;
};
var normalizeIndentListStart = (editor, entry, options) => {
  return withoutNormalizing(editor, () => {
    const [node] = entry;
    const listStyleType = node[KEY_LIST_STYLE_TYPE];
    if (!listStyleType)
      return;
    let normalized = false;
    let prevEntry = getPreviousIndentList(editor, entry, options);
    if (!prevEntry) {
      normalized = normalizeFirstIndentListStart(editor, entry);
      if (!normalized)
        return;
    }
    let normalizeNext = true;
    let currEntry = entry;
    while (normalizeNext) {
      normalizeNext = normalizeNextIndentListStart(editor, currEntry, prevEntry) || normalized;
      if (normalizeNext)
        normalized = true;
      prevEntry = [getNode(editor, currEntry[1]), currEntry[1]];
      currEntry = getNextIndentList(editor, currEntry, options);
      if (!currEntry)
        break;
    }
    return normalized;
  });
};
var normalizeIndentListNotIndented = (editor, [node, path]) => {
  if (!node[KEY_INDENT] && (node[KEY_LIST_STYLE_TYPE] || node[KEY_LIST_START])) {
    unsetNodes(editor, [KEY_LIST_STYLE_TYPE, KEY_LIST_START], {
      at: path
    });
    return true;
  }
};
var normalizeIndentList = (editor, {
  getSiblingIndentListOptions
} = {}) => {
  const {
    normalizeNode
  } = editor;
  return ([node, path]) => {
    const normalized = withoutNormalizing(editor, () => {
      if (normalizeIndentListNotIndented(editor, [node, path]))
        return true;
      if (normalizeIndentListStart(editor, [node, path], getSiblingIndentListOptions))
        return true;
    });
    if (normalized)
      return;
    return normalizeNode([node, path]);
  };
};
var withIndentList = (editor, {
  options
}) => {
  const {
    apply: apply5
  } = editor;
  const {
    getSiblingIndentListOptions
  } = options;
  editor.normalizeNode = normalizeIndentList(editor, options);
  editor.apply = (operation) => {
    const {
      path
    } = operation;
    let nodeBefore = null;
    if (operation.type === "set_node") {
      nodeBefore = getNode(editor, path);
    }
    if (operation.type === "insert_node") {
      const listStyleType = operation.node[KEY_LIST_STYLE_TYPE];
      if (listStyleType && ["lower-roman", "upper-roman"].includes(listStyleType)) {
        const prevNodeEntry = getPreviousIndentList(editor, [operation.node, path], {
          eqIndent: false,
          breakOnEqIndentNeqListStyleType: false,
          ...getSiblingIndentListOptions
        });
        if (prevNodeEntry) {
          const prevListStyleType = prevNodeEntry[0][KEY_LIST_STYLE_TYPE];
          if (prevListStyleType === ListStyleType.LowerAlpha && listStyleType === ListStyleType.LowerRoman) {
            operation.node[KEY_LIST_STYLE_TYPE] = ListStyleType.LowerAlpha;
          } else if (prevListStyleType === ListStyleType.UpperAlpha && listStyleType === ListStyleType.UpperRoman) {
            operation.node[KEY_LIST_STYLE_TYPE] = ListStyleType.UpperAlpha;
          }
        }
      }
    }
    let nextIndentListPathRef = null;
    if (operation.type === "merge_node" && operation.properties[KEY_LIST_STYLE_TYPE]) {
      const node = getNode(editor, path);
      if (node) {
        const nextNodeEntryBefore = getNextIndentList(editor, [node, path], getSiblingIndentListOptions);
        if (nextNodeEntryBefore) {
          nextIndentListPathRef = createPathRef(editor, nextNodeEntryBefore[1]);
        }
      }
    }
    apply5(operation);
    if (operation.type === "merge_node") {
      const {
        properties
      } = operation;
      if (properties[KEY_LIST_STYLE_TYPE]) {
        const node = getNode(editor, path);
        if (!node)
          return;
        normalizeIndentListStart(editor, [node, path], getSiblingIndentListOptions);
        if (nextIndentListPathRef) {
          const nextPath = nextIndentListPathRef.unref();
          if (nextPath) {
            const nextNode = getNode(editor, nextPath);
            if (nextNode) {
              normalizeIndentListStart(editor, [nextNode, nextPath], getSiblingIndentListOptions);
            }
          }
        }
      }
    }
    if (nodeBefore) {
      if (operation.type === "set_node") {
        const prevListStyleType = operation.properties[KEY_LIST_STYLE_TYPE];
        const listStyleType = operation.newProperties[KEY_LIST_STYLE_TYPE];
        if (prevListStyleType && !listStyleType) {
          const node = getNode(editor, path);
          if (!node)
            return;
          const nextNodeEntry = getNextIndentList(editor, [nodeBefore, path], getSiblingIndentListOptions);
          if (!nextNodeEntry)
            return;
          normalizeIndentListStart(editor, nextNodeEntry, getSiblingIndentListOptions);
        }
        if ((prevListStyleType || listStyleType) && prevListStyleType !== listStyleType) {
          const node = getNode(editor, path);
          if (!node)
            return;
          let nextNodeEntry = getNextIndentList(editor, [nodeBefore, path], getSiblingIndentListOptions);
          if (nextNodeEntry) {
            normalizeIndentListStart(editor, nextNodeEntry, getSiblingIndentListOptions);
          }
          nextNodeEntry = getNextIndentList(editor, [node, path], getSiblingIndentListOptions);
          if (nextNodeEntry) {
            normalizeIndentListStart(editor, nextNodeEntry, getSiblingIndentListOptions);
          }
        }
        const prevIndent = operation.properties[KEY_INDENT];
        const indent2 = operation.newProperties[KEY_INDENT];
        if (prevIndent !== indent2) {
          const node = getNode(editor, path);
          if (!node)
            return;
          let prevNodeEntry = getPreviousIndentList(editor, [nodeBefore, path], {
            eqIndent: false,
            breakOnLowerIndent: false,
            breakOnEqIndentNeqListStyleType: false,
            ...getSiblingIndentListOptions
          });
          if (prevNodeEntry) {
            normalizeIndentListStart(editor, prevNodeEntry, getSiblingIndentListOptions);
          }
          prevNodeEntry = getPreviousIndentList(editor, [node, path], {
            eqIndent: false,
            breakOnLowerIndent: false,
            breakOnEqIndentNeqListStyleType: false,
            ...getSiblingIndentListOptions
          });
          if (prevNodeEntry) {
            normalizeIndentListStart(editor, prevNodeEntry, getSiblingIndentListOptions);
          }
          let nextNodeEntry = getNextIndentList(editor, [nodeBefore, path], {
            eqIndent: false,
            breakOnLowerIndent: false,
            breakOnEqIndentNeqListStyleType: false
          });
          if (nextNodeEntry) {
            normalizeIndentListStart(editor, nextNodeEntry, getSiblingIndentListOptions);
          }
          nextNodeEntry = getNextIndentList(editor, [node, path], {
            eqIndent: false,
            breakOnLowerIndent: false,
            breakOnEqIndentNeqListStyleType: false
          });
          if (nextNodeEntry) {
            normalizeIndentListStart(editor, nextNodeEntry, getSiblingIndentListOptions);
          }
        }
      }
    }
  };
  return editor;
};
var KEY_LIST_STYLE_TYPE = "listStyleType";
var KEY_LIST_START = "listStart";
var createIndentListPlugin = createPluginFactory({
  key: KEY_LIST_STYLE_TYPE,
  inject: {
    belowComponent: injectIndentListComponent
  },
  withOverrides: withIndentList
});

// node_modules/@udecode/plate-kbd/dist/index.es.js
var MARK_KBD = "kbd";
var createKbdPlugin = createPluginFactory({
  key: MARK_KBD,
  isLeaf: true,
  handlers: {
    onKeyDown: onKeyDownToggleMark
  },
  deserializeHtml: {
    rules: [{
      validNodeName: ["KBD"]
    }, {
      validStyle: {
        wordWrap: "break-word"
      }
    }]
  }
});

// node_modules/@udecode/plate-line-height/dist/index.es.js
var KEY_LINE_HEIGHT = "lineHeight";
var createLineHeightPlugin = createPluginFactory({
  key: KEY_LINE_HEIGHT,
  inject: {
    props: {
      nodeKey: KEY_LINE_HEIGHT,
      defaultNodeValue: 1.5
    }
  },
  then: (editor) => ({
    inject: {
      props: {
        validTypes: [getPluginType(editor, ELEMENT_DEFAULT)]
      }
    },
    then: (_7, plugin) => mapInjectPropsToPlugin(editor, plugin, {
      deserializeHtml: {
        getNode: (el, node) => {
          if (el.style.lineHeight) {
            node[plugin.key] = el.style.lineHeight;
          }
        }
      }
    })
  })
});

// node_modules/@udecode/plate-normalizers/dist/index.es.js
var withNormalizeTypes = (editor, {
  options: {
    rules,
    onError
  }
}) => {
  const {
    normalizeNode
  } = editor;
  editor.normalizeNode = ([currentNode, currentPath]) => {
    if (!currentPath.length) {
      const endCurrentNormalizationPass = rules.some(({
        strictType,
        type,
        path
      }) => {
        const node = getNode(editor, path);
        if (node) {
          if (strictType && isElement2(node) && node.type !== strictType) {
            setElements(editor, {
              type: strictType
            }, {
              at: path
            });
            return true;
          }
        } else {
          try {
            insertElements(editor, {
              type: strictType !== null && strictType !== void 0 ? strictType : type,
              children: [{
                text: ""
              }]
            }, {
              at: path
            });
            return true;
          } catch (err) {
            onError === null || onError === void 0 ? void 0 : onError(err);
          }
        }
        return false;
      });
      if (endCurrentNormalizationPass) {
        return;
      }
    }
    return normalizeNode([currentNode, currentPath]);
  };
  return editor;
};
var KEY_NORMALIZE_TYPES = "normalizeTypes";
var createNormalizeTypesPlugin = createPluginFactory({
  key: KEY_NORMALIZE_TYPES,
  withOverrides: withNormalizeTypes,
  options: {
    rules: []
  }
});
var isArray4 = Array.isArray;
var isArray_13 = isArray4;
function castArray3() {
  if (!arguments.length) {
    return [];
  }
  var value = arguments[0];
  return isArray_13(value) ? value : [value];
}
var castArray_13 = castArray3;
var withRemoveEmptyNodes = (editor, {
  options: {
    types: _types
  }
}) => {
  const types = castArray_13(_types);
  const {
    normalizeNode
  } = editor;
  editor.normalizeNode = ([node, path]) => {
    if (isElement2(node) && node.type && types.includes(node.type) && getNodeString(node) === "") {
      removeNodes(editor, {
        at: path
      });
      return;
    }
    normalizeNode([node, path]);
  };
  return editor;
};
var createRemoveEmptyNodesPlugin = createPluginFactory({
  key: "removeEmptyNodes",
  withOverrides: withRemoveEmptyNodes
});

// node_modules/@udecode/plate-link/dist/index.es.js
function unwrapExports7(x7) {
  return x7 && x7.__esModule && Object.prototype.hasOwnProperty.call(x7, "default") ? x7["default"] : x7;
}
function createCommonjsModule8(fn2, module2) {
  return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
}
var lib7 = createCommonjsModule8(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var IS_MAC = () => typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
  var MODIFIERS = {
    alt: "altKey",
    control: "ctrlKey",
    meta: "metaKey",
    shift: "shiftKey"
  };
  var ALIASES = () => ({
    add: "+",
    break: "pause",
    cmd: "meta",
    command: "meta",
    ctl: "control",
    ctrl: "control",
    del: "delete",
    down: "arrowdown",
    esc: "escape",
    ins: "insert",
    left: "arrowleft",
    mod: IS_MAC() ? "meta" : "control",
    opt: "alt",
    option: "alt",
    return: "enter",
    right: "arrowright",
    space: " ",
    spacebar: " ",
    up: "arrowup",
    win: "meta",
    windows: "meta"
  });
  var CODES = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    control: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    " ": 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    insert: 45,
    delete: 46,
    meta: 91,
    numlock: 144,
    scrolllock: 145,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
  };
  for (var f16 = 1; f16 < 20; f16++) {
    CODES["f" + f16] = 111 + f16;
  }
  function isHotkey14(hotkey, options, event) {
    if (options && !("byKey" in options)) {
      event = options;
      options = null;
    }
    if (!Array.isArray(hotkey)) {
      hotkey = [hotkey];
    }
    var array2 = hotkey.map(function(string2) {
      return parseHotkey(string2, options);
    });
    var check = function check2(e9) {
      return array2.some(function(object2) {
        return compareHotkey(object2, e9);
      });
    };
    var ret = event == null ? check : check(event);
    return ret;
  }
  function isCodeHotkey(hotkey, event) {
    return isHotkey14(hotkey, event);
  }
  function isKeyHotkey2(hotkey, event) {
    return isHotkey14(hotkey, { byKey: true }, event);
  }
  function parseHotkey(hotkey, options) {
    var byKey = options && options.byKey;
    var ret = {};
    hotkey = hotkey.replace("++", "+add");
    var values3 = hotkey.split("+");
    var length = values3.length;
    for (var k3 in MODIFIERS) {
      ret[MODIFIERS[k3]] = false;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = void 0;
    try {
      for (var _iterator = values3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var value = _step.value;
        var optional = value.endsWith("?") && value.length > 1;
        if (optional) {
          value = value.slice(0, -1);
        }
        var name2 = toKeyName(value);
        var modifier = MODIFIERS[name2];
        if (length === 1 || !modifier) {
          if (byKey) {
            ret.key = name2;
          } else {
            ret.which = toKeyCode(value);
          }
        }
        if (modifier) {
          ret[modifier] = optional ? null : true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return ret;
  }
  function compareHotkey(object2, event) {
    for (var key in object2) {
      var expected = object2[key];
      var actual = void 0;
      if (expected == null) {
        continue;
      }
      if (key === "key" && event.key != null) {
        actual = event.key.toLowerCase();
      } else if (key === "which") {
        actual = expected === 91 && event.which === 93 ? 91 : event.which;
      } else {
        actual = event[key];
      }
      if (actual == null && expected === false) {
        continue;
      }
      if (actual !== expected) {
        return false;
      }
    }
    return true;
  }
  function toKeyCode(name2) {
    name2 = toKeyName(name2);
    var code = CODES[name2] || name2.toUpperCase().charCodeAt(0);
    return code;
  }
  function toKeyName(name2) {
    name2 = name2.toLowerCase();
    name2 = ALIASES()[name2] || name2;
    return name2;
  }
  exports2.default = isHotkey14;
  exports2.isHotkey = isHotkey14;
  exports2.isCodeHotkey = isCodeHotkey;
  exports2.isKeyHotkey = isKeyHotkey2;
  exports2.parseHotkey = parseHotkey;
  exports2.compareHotkey = compareHotkey;
  exports2.toKeyCode = toKeyCode;
  exports2.toKeyName = toKeyName;
});
var isHotkey7 = unwrapExports7(lib7);
lib7.isHotkey;
lib7.isCodeHotkey;
lib7.isKeyHotkey;
lib7.parseHotkey;
lib7.compareHotkey;
lib7.toKeyCode;
lib7.toKeyName;
var wrapLink = (editor, {
  at,
  url
}) => {
  wrapNodes(editor, {
    type: getPluginType(editor, ELEMENT_LINK),
    url,
    children: []
  }, {
    at,
    split: true
  });
};
var upsertLinkAtSelection = (editor, {
  url,
  wrap
}) => {
  if (!editor.selection)
    return;
  const type = getPluginType(editor, ELEMENT_LINK);
  if (!wrap && isCollapsed(editor.selection)) {
    return insertNodes(editor, {
      type,
      url,
      children: [{
        text: url
      }]
    });
  }
  if (wrap && isCollapsed(editor.selection)) {
    const linkLeaf = getLeafNode(editor, editor.selection);
    const [, inlinePath] = linkLeaf;
    select(editor, inlinePath);
  }
  unwrapNodes(editor, {
    at: editor.selection,
    match: {
      type
    }
  });
  wrapLink(editor, {
    at: editor.selection,
    url
  });
  collapseSelection(editor, {
    edge: "end"
  });
};
var getAndUpsertLink = async (editor, getLinkUrl) => {
  const type = getPluginType(editor, ELEMENT_LINK);
  let prevUrl = "";
  const linkNode = getAboveNode(editor, {
    match: {
      type
    }
  });
  if (linkNode) {
    prevUrl = linkNode[0].url;
  }
  let url;
  if (getLinkUrl) {
    url = await getLinkUrl(prevUrl);
  } else {
    url = window.prompt(`Enter the URL of the link:`, prevUrl);
  }
  if (!url) {
    linkNode && editor.selection && unwrapNodes(editor, {
      at: editor.selection,
      match: {
        type: getPluginType(editor, ELEMENT_LINK)
      }
    });
    return;
  }
  const shouldWrap = linkNode !== void 0 && isCollapsed(editor.selection);
  upsertLinkAtSelection(editor, {
    url,
    wrap: shouldWrap
  });
};
var onKeyDownLink = (editor, {
  options: {
    getLinkUrl,
    hotkey
  }
}) => (e9) => {
  if (!hotkey)
    return;
  if (isHotkey7(hotkey, e9)) {
    e9.preventDefault();
    e9.stopPropagation();
    getAndUpsertLink(editor, getLinkUrl);
  }
};
var upsertLink = (editor, {
  url,
  at
}) => {
  unwrapNodes(editor, {
    at,
    match: {
      type: getPluginType(editor, ELEMENT_LINK)
    }
  });
  const newSelection = editor.selection;
  wrapLink(editor, {
    at: {
      ...at,
      focus: newSelection.focus
    },
    url
  });
};
var upsertLinkIfValid = (editor, {
  isUrl: isUrl2,
  getUrlHref
}) => {
  const rangeFromBlockStart = getRangeFromBlockStart(editor);
  const textFromBlockStart = getEditorString(editor, rangeFromBlockStart);
  const hrefFromBlockStart = getUrlHref === null || getUrlHref === void 0 ? void 0 : getUrlHref(textFromBlockStart);
  if (rangeFromBlockStart && isUrl2(textFromBlockStart)) {
    upsertLink(editor, {
      url: hrefFromBlockStart || textFromBlockStart,
      at: rangeFromBlockStart
    });
    return true;
  }
};
var withLink = (editor, {
  type,
  options: {
    isUrl: isUrl2,
    getUrlHref,
    rangeBeforeOptions
  }
}) => {
  const {
    insertData,
    insertText: insertText2
  } = editor;
  editor.insertText = (text) => {
    if (text === " " && isCollapsed(editor.selection)) {
      const selection = editor.selection;
      if (upsertLinkIfValid(editor, {
        isUrl: isUrl2,
        getUrlHref
      })) {
        moveSelection(editor, {
          unit: "offset"
        });
        return insertText2(text);
      }
      const beforeWordRange = getRangeBefore(editor, selection, rangeBeforeOptions);
      if (beforeWordRange) {
        const beforeWordText = getEditorString(editor, beforeWordRange);
        const beforeWordHref = getUrlHref === null || getUrlHref === void 0 ? void 0 : getUrlHref(beforeWordText);
        if (isUrl2(beforeWordText)) {
          upsertLink(editor, {
            url: beforeWordHref || beforeWordText,
            at: beforeWordRange
          });
          moveSelection(editor, {
            unit: "offset"
          });
        }
      }
    }
    insertText2(text);
  };
  editor.insertData = (data) => {
    const text = data.getData("text/plain");
    const textHref = getUrlHref === null || getUrlHref === void 0 ? void 0 : getUrlHref(text);
    if (text) {
      if (isUrl2(text)) {
        return upsertLinkAtSelection(editor, {
          url: textHref || text
        });
      }
      if (someNode(editor, {
        match: {
          type
        }
      })) {
        return insertText2(text);
      }
    }
    insertData(data);
  };
  editor = withRemoveEmptyNodes(editor, mockPlugin({
    options: {
      types: type
    }
  }));
  return editor;
};
var ELEMENT_LINK = "a";
var createLinkPlugin = createPluginFactory({
  key: ELEMENT_LINK,
  isElement: true,
  isInline: true,
  props: ({
    element
  }) => ({
    nodeProps: {
      url: element === null || element === void 0 ? void 0 : element.url
    }
  }),
  handlers: {
    onKeyDown: onKeyDownLink
  },
  withOverrides: withLink,
  options: {
    isUrl,
    rangeBeforeOptions: {
      matchString: " ",
      skipInvalid: true,
      afterMatch: true
    },
    hotkey: "mod+k"
  },
  then: (editor, {
    type
  }) => ({
    deserializeHtml: {
      rules: [{
        validNodeName: "A"
      }],
      getNode: (el) => ({
        type,
        url: el.getAttribute("href")
      })
    }
  })
});

// node_modules/@udecode/plate-reset-node/dist/index.es.js
function unwrapExports8(x7) {
  return x7 && x7.__esModule && Object.prototype.hasOwnProperty.call(x7, "default") ? x7["default"] : x7;
}
function createCommonjsModule9(fn2, module2) {
  return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
}
var lib8 = createCommonjsModule9(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var IS_MAC = () => typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
  var MODIFIERS = {
    alt: "altKey",
    control: "ctrlKey",
    meta: "metaKey",
    shift: "shiftKey"
  };
  var ALIASES = () => ({
    add: "+",
    break: "pause",
    cmd: "meta",
    command: "meta",
    ctl: "control",
    ctrl: "control",
    del: "delete",
    down: "arrowdown",
    esc: "escape",
    ins: "insert",
    left: "arrowleft",
    mod: IS_MAC() ? "meta" : "control",
    opt: "alt",
    option: "alt",
    return: "enter",
    right: "arrowright",
    space: " ",
    spacebar: " ",
    up: "arrowup",
    win: "meta",
    windows: "meta"
  });
  var CODES = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    control: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    " ": 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    insert: 45,
    delete: 46,
    meta: 91,
    numlock: 144,
    scrolllock: 145,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
  };
  for (var f16 = 1; f16 < 20; f16++) {
    CODES["f" + f16] = 111 + f16;
  }
  function isHotkey14(hotkey, options, event) {
    if (options && !("byKey" in options)) {
      event = options;
      options = null;
    }
    if (!Array.isArray(hotkey)) {
      hotkey = [hotkey];
    }
    var array2 = hotkey.map(function(string2) {
      return parseHotkey(string2, options);
    });
    var check = function check2(e9) {
      return array2.some(function(object2) {
        return compareHotkey(object2, e9);
      });
    };
    var ret = event == null ? check : check(event);
    return ret;
  }
  function isCodeHotkey(hotkey, event) {
    return isHotkey14(hotkey, event);
  }
  function isKeyHotkey2(hotkey, event) {
    return isHotkey14(hotkey, { byKey: true }, event);
  }
  function parseHotkey(hotkey, options) {
    var byKey = options && options.byKey;
    var ret = {};
    hotkey = hotkey.replace("++", "+add");
    var values3 = hotkey.split("+");
    var length = values3.length;
    for (var k3 in MODIFIERS) {
      ret[MODIFIERS[k3]] = false;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = void 0;
    try {
      for (var _iterator = values3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var value = _step.value;
        var optional = value.endsWith("?") && value.length > 1;
        if (optional) {
          value = value.slice(0, -1);
        }
        var name2 = toKeyName(value);
        var modifier = MODIFIERS[name2];
        if (length === 1 || !modifier) {
          if (byKey) {
            ret.key = name2;
          } else {
            ret.which = toKeyCode(value);
          }
        }
        if (modifier) {
          ret[modifier] = optional ? null : true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return ret;
  }
  function compareHotkey(object2, event) {
    for (var key in object2) {
      var expected = object2[key];
      var actual = void 0;
      if (expected == null) {
        continue;
      }
      if (key === "key" && event.key != null) {
        actual = event.key.toLowerCase();
      } else if (key === "which") {
        actual = expected === 91 && event.which === 93 ? 91 : event.which;
      } else {
        actual = event[key];
      }
      if (actual == null && expected === false) {
        continue;
      }
      if (actual !== expected) {
        return false;
      }
    }
    return true;
  }
  function toKeyCode(name2) {
    name2 = toKeyName(name2);
    var code = CODES[name2] || name2.toUpperCase().charCodeAt(0);
    return code;
  }
  function toKeyName(name2) {
    name2 = name2.toLowerCase();
    name2 = ALIASES()[name2] || name2;
    return name2;
  }
  exports2.default = isHotkey14;
  exports2.isHotkey = isHotkey14;
  exports2.isCodeHotkey = isCodeHotkey;
  exports2.isKeyHotkey = isKeyHotkey2;
  exports2.parseHotkey = parseHotkey;
  exports2.compareHotkey = compareHotkey;
  exports2.toKeyCode = toKeyCode;
  exports2.toKeyName = toKeyName;
});
var isHotkey8 = unwrapExports8(lib8);
lib8.isHotkey;
lib8.isCodeHotkey;
lib8.isKeyHotkey;
lib8.parseHotkey;
lib8.compareHotkey;
lib8.toKeyCode;
lib8.toKeyName;
var SIMULATE_BACKSPACE = {
  key: "",
  which: 8
};
var onKeyDownResetNode = (editor, {
  options: {
    rules
  }
}) => (event) => {
  let reset;
  if (editor.selection && isCollapsed(editor.selection)) {
    rules.forEach(({
      types,
      defaultType,
      hotkey,
      predicate,
      onReset
    }) => {
      if (hotkey && isHotkey8(hotkey, event)) {
        if (predicate(editor) && someNode(editor, {
          match: {
            type: types
          }
        })) {
          var _event$preventDefault;
          (_event$preventDefault = event.preventDefault) === null || _event$preventDefault === void 0 ? void 0 : _event$preventDefault.call(event);
          setElements(editor, {
            type: defaultType
          });
          if (onReset) {
            onReset(editor);
          }
          reset = true;
        }
      }
    });
  }
  return reset;
};
var KEY_RESET_NODE = "resetNode";
var createResetNodePlugin = createPluginFactory({
  key: KEY_RESET_NODE,
  handlers: {
    onKeyDown: onKeyDownResetNode
  },
  options: {
    rules: []
  }
});

// node_modules/@udecode/plate-list/dist/index.es.js
var isArray5 = Array.isArray;
var isArray_14 = isArray5;
function castArray4() {
  if (!arguments.length) {
    return [];
  }
  var value = arguments[0];
  return isArray_14(value) ? value : [value];
}
var castArray_14 = castArray4;
function unwrapExports9(x7) {
  return x7 && x7.__esModule && Object.prototype.hasOwnProperty.call(x7, "default") ? x7["default"] : x7;
}
function createCommonjsModule10(fn2, module2) {
  return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
}
var lib9 = createCommonjsModule10(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var IS_MAC = () => typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
  var MODIFIERS = {
    alt: "altKey",
    control: "ctrlKey",
    meta: "metaKey",
    shift: "shiftKey"
  };
  var ALIASES = () => ({
    add: "+",
    break: "pause",
    cmd: "meta",
    command: "meta",
    ctl: "control",
    ctrl: "control",
    del: "delete",
    down: "arrowdown",
    esc: "escape",
    ins: "insert",
    left: "arrowleft",
    mod: IS_MAC() ? "meta" : "control",
    opt: "alt",
    option: "alt",
    return: "enter",
    right: "arrowright",
    space: " ",
    spacebar: " ",
    up: "arrowup",
    win: "meta",
    windows: "meta"
  });
  var CODES = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    control: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    " ": 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    insert: 45,
    delete: 46,
    meta: 91,
    numlock: 144,
    scrolllock: 145,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
  };
  for (var f16 = 1; f16 < 20; f16++) {
    CODES["f" + f16] = 111 + f16;
  }
  function isHotkey14(hotkey, options, event) {
    if (options && !("byKey" in options)) {
      event = options;
      options = null;
    }
    if (!Array.isArray(hotkey)) {
      hotkey = [hotkey];
    }
    var array2 = hotkey.map(function(string2) {
      return parseHotkey(string2, options);
    });
    var check = function check2(e9) {
      return array2.some(function(object2) {
        return compareHotkey(object2, e9);
      });
    };
    var ret = event == null ? check : check(event);
    return ret;
  }
  function isCodeHotkey(hotkey, event) {
    return isHotkey14(hotkey, event);
  }
  function isKeyHotkey2(hotkey, event) {
    return isHotkey14(hotkey, { byKey: true }, event);
  }
  function parseHotkey(hotkey, options) {
    var byKey = options && options.byKey;
    var ret = {};
    hotkey = hotkey.replace("++", "+add");
    var values3 = hotkey.split("+");
    var length = values3.length;
    for (var k3 in MODIFIERS) {
      ret[MODIFIERS[k3]] = false;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = void 0;
    try {
      for (var _iterator = values3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var value = _step.value;
        var optional = value.endsWith("?") && value.length > 1;
        if (optional) {
          value = value.slice(0, -1);
        }
        var name2 = toKeyName(value);
        var modifier = MODIFIERS[name2];
        if (length === 1 || !modifier) {
          if (byKey) {
            ret.key = name2;
          } else {
            ret.which = toKeyCode(value);
          }
        }
        if (modifier) {
          ret[modifier] = optional ? null : true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return ret;
  }
  function compareHotkey(object2, event) {
    for (var key in object2) {
      var expected = object2[key];
      var actual = void 0;
      if (expected == null) {
        continue;
      }
      if (key === "key" && event.key != null) {
        actual = event.key.toLowerCase();
      } else if (key === "which") {
        actual = expected === 91 && event.which === 93 ? 91 : event.which;
      } else {
        actual = event[key];
      }
      if (actual == null && expected === false) {
        continue;
      }
      if (actual !== expected) {
        return false;
      }
    }
    return true;
  }
  function toKeyCode(name2) {
    name2 = toKeyName(name2);
    var code = CODES[name2] || name2.toUpperCase().charCodeAt(0);
    return code;
  }
  function toKeyName(name2) {
    name2 = name2.toLowerCase();
    name2 = ALIASES()[name2] || name2;
    return name2;
  }
  exports2.default = isHotkey14;
  exports2.isHotkey = isHotkey14;
  exports2.isCodeHotkey = isCodeHotkey;
  exports2.isKeyHotkey = isKeyHotkey2;
  exports2.parseHotkey = parseHotkey;
  exports2.compareHotkey = compareHotkey;
  exports2.toKeyCode = toKeyCode;
  exports2.toKeyName = toKeyName;
});
var isHotkey9 = unwrapExports9(lib9);
lib9.isHotkey;
lib9.isCodeHotkey;
lib9.isKeyHotkey;
lib9.parseHotkey;
lib9.compareHotkey;
lib9.toKeyCode;
lib9.toKeyName;
var isListNested = (editor, listPath) => {
  var _getParentNode;
  const listParentNode = (_getParentNode = getParentNode(editor, listPath)) === null || _getParentNode === void 0 ? void 0 : _getParentNode[0];
  return (listParentNode === null || listParentNode === void 0 ? void 0 : listParentNode.type) === getPluginType(editor, ELEMENT_LI);
};
var getUnorderedListType = (editor) => {
  return getPluginType(editor, ELEMENT_UL);
};
var getOrderedListType = (editor) => {
  return getPluginType(editor, ELEMENT_OL);
};
var getListTypes = (editor) => {
  return [getOrderedListType(editor), getUnorderedListType(editor)];
};
var getListItemType = (editor) => {
  return getPluginType(editor, ELEMENT_LI);
};
var getListItemContentType = (editor) => {
  return getPluginType(editor, ELEMENT_LIC);
};
var getHighestEmptyList = (editor, {
  diffListPath,
  liPath
}) => {
  const list = getAboveNode(editor, {
    at: liPath,
    match: {
      type: getListTypes(editor)
    }
  });
  if (!list)
    return;
  const [listNode, listPath] = list;
  if (!diffListPath || !Path.equals(listPath, diffListPath)) {
    if (listNode.children.length < 2) {
      const liParent = getAboveNode(editor, {
        at: listPath,
        match: {
          type: getPluginType(editor, ELEMENT_LI)
        }
      });
      if (liParent) {
        return getHighestEmptyList(editor, {
          liPath: liParent[1],
          diffListPath
        }) || listPath;
      }
    }
    return liPath;
  }
};
var getListItemEntry = (editor, {
  at = editor.selection
} = {}) => {
  const liType = getPluginType(editor, ELEMENT_LI);
  let _at;
  if (Range.isRange(at) && !isCollapsed(at)) {
    _at = at.focus.path;
  } else if (Range.isRange(at)) {
    _at = at.anchor.path;
  } else {
    _at = at;
  }
  if (_at) {
    const node = getNode(editor, _at);
    if (node) {
      const listItem = getAboveNode(editor, {
        at: _at,
        match: {
          type: liType
        }
      });
      if (listItem) {
        const list = getParentNode(editor, listItem[1]);
        return {
          list,
          listItem
        };
      }
    }
  }
};
var getListRoot = (editor, at = editor.selection) => {
  if (!at)
    return;
  const parentList = getAboveNode(editor, {
    at,
    match: {
      type: [getPluginType(editor, ELEMENT_UL), getPluginType(editor, ELEMENT_OL)]
    }
  });
  if (parentList) {
    var _getListRoot;
    const [, parentListPath] = parentList;
    return (_getListRoot = getListRoot(editor, parentListPath)) !== null && _getListRoot !== void 0 ? _getListRoot : parentList;
  }
};
var hasListChild = (editor, node) => node.children.some((n12) => match(n12, [], {
  type: getListTypes(editor)
}));
var isAcrossListItems = (editor) => {
  const {
    selection
  } = editor;
  if (!selection || isCollapsed(selection)) {
    return false;
  }
  const isAcrossBlocks = isRangeAcrossBlocks(editor);
  if (!isAcrossBlocks)
    return false;
  return someNode(editor, {
    match: {
      type: getPluginType(editor, ELEMENT_LI)
    }
  });
};
var isListRoot = (editor, node) => isElement2(node) && getListTypes(editor).includes(node.type);
var moveListItemDown = (editor, {
  list,
  listItem
}) => {
  const [listNode] = list;
  const [, listItemPath] = listItem;
  let previousListItemPath;
  try {
    previousListItemPath = Path.previous(listItemPath);
  } catch (e9) {
    return;
  }
  const previousSiblingItem = getNodeEntry(editor, previousListItemPath);
  if (previousSiblingItem) {
    const [previousNode, previousPath] = previousSiblingItem;
    const sublist = previousNode.children.find((n12) => match(n12, [], {
      type: getListTypes(editor)
    }));
    const newPath = previousPath.concat(sublist ? [1, sublist.children.length] : [1]);
    withoutNormalizing(editor, () => {
      if (!sublist) {
        wrapNodes(editor, {
          type: listNode.type,
          children: []
        }, {
          at: listItemPath
        });
      }
      moveNodes(editor, {
        at: listItemPath,
        to: newPath
      });
    });
  }
};
var moveListItemsToList = (editor, {
  fromList: fromList2,
  fromListItem,
  fromStartIndex,
  to: _to,
  toList,
  toListIndex = null,
  deleteFromList = true
}) => {
  let fromListPath;
  let moved;
  withoutNormalizing(editor, () => {
    if (fromListItem) {
      const fromListItemSublist = findDescendant(editor, {
        at: fromListItem[1],
        match: {
          type: getListTypes(editor)
        }
      });
      if (!fromListItemSublist)
        return;
      fromListPath = fromListItemSublist === null || fromListItemSublist === void 0 ? void 0 : fromListItemSublist[1];
    } else if (fromList2) {
      fromListPath = fromList2[1];
    } else {
      return;
    }
    let to4 = null;
    if (_to)
      to4 = _to;
    if (toList) {
      if (toListIndex !== null)
        to4 = toList[1].concat([toListIndex]);
      else {
        const lastChildPath = getLastChildPath(toList);
        to4 = Path.next(lastChildPath);
      }
    }
    if (!to4)
      return;
    moved = moveChildren(editor, {
      at: fromListPath,
      to: to4,
      fromStartIndex
    });
    if (deleteFromList) {
      deleteText(editor, {
        at: fromListPath
      });
    }
  });
  return moved;
};
var unwrapList = (editor, {
  at
} = {}) => {
  const ancestorListTypeCheck = () => {
    if (getAboveNode(editor, {
      match: {
        type: getListTypes(editor),
        at
      }
    })) {
      return true;
    }
    if (!at && editor.selection) {
      const commonNode = getCommonNode(editor, editor.selection.anchor.path, editor.selection.focus.path);
      if (isElement2(commonNode[0]) && getListTypes(editor).includes(commonNode[0].type)) {
        return true;
      }
    }
    return false;
  };
  withoutNormalizing(editor, () => {
    do {
      setElements(editor, {
        type: getPluginType(editor, ELEMENT_DEFAULT)
      });
      unwrapNodes(editor, {
        at,
        match: {
          type: getPluginType(editor, ELEMENT_LI)
        },
        split: true
      });
      unwrapNodes(editor, {
        at,
        match: {
          type: [getPluginType(editor, ELEMENT_UL), getPluginType(editor, ELEMENT_OL)]
        },
        split: true
      });
    } while (ancestorListTypeCheck());
  });
};
var moveListItemUp = (editor, {
  list,
  listItem
}) => {
  const move5 = () => {
    const [listNode, listPath] = list;
    const [liNode, liPath] = listItem;
    const liParent = getAboveNode(editor, {
      at: listPath,
      match: {
        type: getPluginType(editor, ELEMENT_LI)
      }
    });
    if (!liParent) {
      let toListPath2;
      try {
        toListPath2 = Path.next(listPath);
      } catch (err) {
        return;
      }
      const condA = hasListChild(editor, liNode);
      const condB = !isLastChild(list, liPath);
      if (condA || condB) {
        insertElements(editor, {
          type: listNode.type,
          children: []
        }, {
          at: toListPath2
        });
      }
      if (condA) {
        const toListNode = getNode(editor, toListPath2);
        if (!toListNode)
          return;
        moveListItemsToList(editor, {
          fromListItem: listItem,
          toList: [toListNode, toListPath2]
        });
      }
      if (condB) {
        const toListNode = getNode(editor, toListPath2);
        if (!toListNode)
          return;
        moveListItemsToList(editor, {
          fromList: list,
          fromStartIndex: liPath[liPath.length - 1] + 1,
          toList: [toListNode, toListPath2],
          deleteFromList: false
        });
      }
      unwrapList(editor, {
        at: liPath.concat(0)
      });
      return true;
    }
    const [, liParentPath] = liParent;
    const toListPath = liPath.concat([1]);
    if (!isLastChild(list, liPath)) {
      if (!hasListChild(editor, liNode)) {
        insertElements(editor, {
          type: listNode.type,
          children: []
        }, {
          at: toListPath
        });
      }
      const toListNode = getNode(editor, toListPath);
      if (!toListNode)
        return;
      moveListItemsToList(editor, {
        fromListItem: liParent,
        toList: [toListNode, toListPath],
        fromStartIndex: liPath[liPath.length - 1] + 1,
        deleteFromList: false
      });
    }
    const movedUpLiPath = Path.next(liParentPath);
    moveNodes(editor, {
      at: liPath,
      to: movedUpLiPath
    });
    return true;
  };
  let moved = false;
  withoutNormalizing(editor, () => {
    moved = move5();
  });
  return moved;
};
var removeFirstListItem = (editor, {
  list,
  listItem
}) => {
  const [, listPath] = list;
  if (!isListNested(editor, listPath)) {
    moveListItemUp(editor, {
      list,
      listItem
    });
    return true;
  }
  return false;
};
var moveListItems = (editor, {
  increase: increase3 = true,
  at = (() => {
    var _editor$selection;
    return (_editor$selection = editor.selection) !== null && _editor$selection !== void 0 ? _editor$selection : void 0;
  })(),
  enableResetOnShiftTab
} = {}) => {
  const _nodes = getNodeEntries(editor, {
    at,
    match: {
      type: getPluginType(editor, ELEMENT_LIC)
    }
  });
  const lics = Array.from(_nodes);
  if (!lics.length)
    return;
  const highestLicPaths = [];
  const highestLicPathRefs = [];
  lics.forEach((lic) => {
    const licPath = lic[1];
    const liPath = Path.parent(licPath);
    const isAncestor2 = highestLicPaths.some((path) => {
      const highestLiPath = Path.parent(path);
      return Path.isAncestor(highestLiPath, liPath);
    });
    if (!isAncestor2) {
      highestLicPaths.push(licPath);
      highestLicPathRefs.push(createPathRef(editor, licPath));
    }
  });
  const licPathRefsToMove = increase3 ? highestLicPathRefs : highestLicPathRefs.reverse();
  withoutNormalizing(editor, () => {
    licPathRefsToMove.forEach((licPathRef) => {
      const licPath = licPathRef.unref();
      if (!licPath)
        return;
      const listItem = getParentNode(editor, licPath);
      if (!listItem)
        return;
      const parentList = getParentNode(editor, listItem[1]);
      if (!parentList)
        return;
      if (increase3) {
        moveListItemDown(editor, {
          list: parentList,
          listItem
        });
      } else if (isListNested(editor, parentList[1])) {
        moveListItemUp(editor, {
          list: parentList,
          listItem
        });
      } else if (enableResetOnShiftTab) {
        removeFirstListItem(editor, {
          list: parentList,
          listItem
        });
      }
    });
  });
};
var insertListItem = (editor) => {
  const liType = getPluginType(editor, ELEMENT_LI);
  const licType = getPluginType(editor, ELEMENT_LIC);
  if (!editor.selection) {
    return false;
  }
  const licEntry = getAboveNode(editor, {
    match: {
      type: licType
    }
  });
  if (!licEntry)
    return false;
  const [, paragraphPath] = licEntry;
  const listItemEntry = getParentNode(editor, paragraphPath);
  if (!listItemEntry)
    return false;
  const [listItemNode, listItemPath] = listItemEntry;
  if (listItemNode.type !== liType)
    return false;
  let success = false;
  withoutNormalizing(editor, () => {
    if (!Range.isCollapsed(editor.selection)) {
      deleteText(editor);
    }
    const isStart = isStartPoint(editor, editor.selection.focus, paragraphPath);
    const isEnd = isBlockTextEmptyAfterSelection(editor);
    const nextParagraphPath = Path.next(paragraphPath);
    const nextListItemPath = Path.next(listItemPath);
    if (isStart) {
      insertElements(editor, {
        type: liType,
        children: [{
          type: licType,
          children: [{
            text: ""
          }]
        }]
      }, {
        at: listItemPath
      });
      success = true;
      return;
    }
    if (!isEnd) {
      withoutNormalizing(editor, () => {
        splitNodes(editor);
        wrapNodes(editor, {
          type: liType,
          children: []
        }, {
          at: nextParagraphPath
        });
        moveNodes(editor, {
          at: nextParagraphPath,
          to: nextListItemPath
        });
        select(editor, nextListItemPath);
        collapseSelection(editor, {
          edge: "start"
        });
      });
    } else {
      const marks = getMarks(editor) || {};
      insertElements(editor, {
        type: liType,
        children: [{
          type: licType,
          children: [{
            text: "",
            ...marks
          }]
        }]
      }, {
        at: nextListItemPath
      });
      select(editor, nextListItemPath);
    }
    if (listItemNode.children.length > 1) {
      moveNodes(editor, {
        at: nextParagraphPath,
        to: nextListItemPath.concat(1)
      });
    }
    success = true;
  });
  return success;
};
var moveListItemSublistItemsToListItemSublist = (editor, {
  fromListItem,
  toListItem,
  start: start3
}) => {
  const [, fromListItemPath] = fromListItem;
  const [, toListItemPath] = toListItem;
  let moved = 0;
  withoutNormalizing(editor, () => {
    const fromListItemSublist = findDescendant(editor, {
      at: fromListItemPath,
      match: {
        type: getListTypes(editor)
      }
    });
    if (!fromListItemSublist)
      return;
    const [, fromListItemSublistPath] = fromListItemSublist;
    const toListItemSublist = findDescendant(editor, {
      at: toListItemPath,
      match: {
        type: getListTypes(editor)
      }
    });
    let to4;
    if (!toListItemSublist) {
      const fromList2 = getParentNode(editor, fromListItemPath);
      if (!fromList2)
        return;
      const [fromListNode] = fromList2;
      const fromListType = fromListNode.type;
      const toListItemSublistPath = toListItemPath.concat([1]);
      insertElements(editor, {
        type: fromListType,
        children: []
      }, {
        at: toListItemSublistPath
      });
      to4 = toListItemSublistPath.concat([0]);
    } else if (start3) {
      const [, toListItemSublistPath] = toListItemSublist;
      to4 = toListItemSublistPath.concat([0]);
    } else {
      to4 = Path.next(getLastChildPath(toListItemSublist));
    }
    moved = moveChildren(editor, {
      at: fromListItemSublistPath,
      to: to4
    });
    deleteText(editor, {
      at: fromListItemSublistPath
    });
  });
  return moved;
};
var removeListItem = (editor, {
  list,
  listItem,
  reverse = true
}) => {
  const [liNode, liPath] = listItem;
  if (isExpanded(editor.selection) || !hasListChild(editor, liNode)) {
    return false;
  }
  const previousLiPath = getPreviousPath(liPath);
  let success = false;
  withoutNormalizing(editor, () => {
    if (previousLiPath) {
      const previousLi = getNodeEntry(editor, previousLiPath);
      let tempLiPath = Path.next(liPath);
      insertElements(editor, {
        type: getPluginType(editor, ELEMENT_LI),
        children: [{
          type: getPluginType(editor, ELEMENT_LIC),
          children: [{
            text: ""
          }]
        }]
      }, {
        at: tempLiPath
      });
      const tempLi = getNodeEntry(editor, tempLiPath);
      const tempLiPathRef = createPathRef(editor, tempLi[1]);
      moveListItemSublistItemsToListItemSublist(editor, {
        fromListItem: listItem,
        toListItem: tempLi
      });
      deleteMerge(editor, {
        reverse
      });
      tempLiPath = tempLiPathRef.unref();
      moveListItemSublistItemsToListItemSublist(editor, {
        fromListItem: [tempLi[0], tempLiPath],
        toListItem: previousLi
      });
      removeNodes(editor, {
        at: tempLiPath
      });
      success = true;
      return;
    }
    moveListItemsToList(editor, {
      fromListItem: listItem,
      toList: list,
      toListIndex: 1
    });
  });
  return success;
};
var toggleList = (editor, {
  type
}) => withoutNormalizing(editor, () => {
  if (!editor.selection) {
    return;
  }
  if (isCollapsed(editor.selection) || !isRangeAcrossBlocks(editor)) {
    const res = getListItemEntry(editor);
    if (res) {
      const {
        list
      } = res;
      if (list[0].type !== type) {
        setElements(editor, {
          type
        }, {
          at: editor.selection,
          match: (n12) => isElement2(n12) && getListTypes(editor).includes(n12.type),
          mode: "lowest"
        });
      } else {
        unwrapList(editor);
      }
    } else {
      const list = {
        type,
        children: []
      };
      wrapNodes(editor, list);
      const _nodes = getNodeEntries(editor, {
        match: {
          type: getPluginType(editor, ELEMENT_DEFAULT)
        }
      });
      const nodes = Array.from(_nodes);
      setElements(editor, {
        type: getPluginType(editor, ELEMENT_LIC)
      });
      const listItem = {
        type: getPluginType(editor, ELEMENT_LI),
        children: []
      };
      for (const [, path] of nodes) {
        wrapNodes(editor, listItem, {
          at: path
        });
      }
    }
  } else {
    const [startPoint, endPoint] = Range.edges(editor.selection);
    const commonEntry = getCommonNode(editor, startPoint.path, endPoint.path);
    if (getListTypes(editor).includes(commonEntry[0].type) || commonEntry[0].type === getPluginType(editor, ELEMENT_LI)) {
      if (commonEntry[0].type !== type) {
        const startList = findNode(editor, {
          at: Range.start(editor.selection),
          match: {
            type: getListTypes(editor)
          },
          mode: "lowest"
        });
        const endList = findNode(editor, {
          at: Range.end(editor.selection),
          match: {
            type: getListTypes(editor)
          },
          mode: "lowest"
        });
        const rangeLength = Math.min(startList[1].length, endList[1].length);
        setElements(editor, {
          type
        }, {
          at: editor.selection,
          match: (n12, path) => isElement2(n12) && getListTypes(editor).includes(n12.type) && path.length >= rangeLength,
          mode: "all"
        });
      } else {
        unwrapList(editor);
      }
    } else {
      const rootPathLength = commonEntry[1].length;
      const _nodes = getNodeEntries(editor, {
        mode: "all"
      });
      const nodes = Array.from(_nodes).filter(([, path]) => path.length === rootPathLength + 1).reverse();
      nodes.forEach((n12) => {
        if (getListTypes(editor).includes(n12[0].type)) {
          setElements(editor, {
            type
          }, {
            at: n12[1],
            match: (_n) => isElement2(_n) && getListTypes(editor).includes(_n.type),
            mode: "all"
          });
        } else {
          setElements(editor, {
            type: getPluginType(editor, ELEMENT_LIC)
          }, {
            at: n12[1]
          });
          const listItem = {
            type: getPluginType(editor, ELEMENT_LI),
            children: []
          };
          wrapNodes(editor, listItem, {
            at: n12[1]
          });
          const list = {
            type,
            children: []
          };
          wrapNodes(editor, list, {
            at: n12[1]
          });
        }
      });
    }
  }
});
var onKeyDownList = (editor, {
  type,
  options: {
    hotkey,
    enableResetOnShiftTab
  }
}) => (e9) => {
  const isTab = Hotkeys2.isTab(editor, e9);
  const isUntab = Hotkeys2.isUntab(editor, e9);
  let workRange = editor.selection;
  if (editor.selection && (isTab || isUntab)) {
    const {
      selection
    } = editor;
    if (!isCollapsed(editor.selection)) {
      const {
        anchor,
        focus: focus2
      } = Range.isBackward(selection) ? {
        anchor: selection.focus,
        focus: selection.anchor
      } : {
        anchor: selection.anchor,
        focus: selection.focus
      };
      anchor.offset = 0;
      const unHungRange = unhangRange(editor, {
        anchor,
        focus: focus2
      });
      if (unHungRange) {
        workRange = unHungRange;
        select(editor, unHungRange);
      }
    }
    const listSelected = someNode(editor, {
      match: {
        type: getPluginType(editor, ELEMENT_LIC)
      }
    });
    if (workRange && listSelected) {
      e9.preventDefault();
      moveListItems(editor, {
        at: workRange,
        increase: isTab,
        enableResetOnShiftTab
      });
      return true;
    }
  }
  if (!hotkey)
    return;
  const hotkeys = castArray_14(hotkey);
  for (const _hotkey of hotkeys) {
    if (isHotkey9(_hotkey)(e9)) {
      toggleList(editor, {
        type
      });
    }
  }
};
var deleteBackwardList = (editor, unit) => {
  const res = getListItemEntry(editor, {});
  let moved = false;
  if (res) {
    const {
      list,
      listItem
    } = res;
    if (isSelectionAtBlockStart(editor, {
      match: (node) => node.type === getPluginType(editor, ELEMENT_LI)
    })) {
      withoutNormalizing(editor, () => {
        moved = removeFirstListItem(editor, {
          list,
          listItem
        });
        if (moved)
          return true;
        moved = removeListItem(editor, {
          list,
          listItem
        });
        if (moved)
          return true;
        if (isFirstChild(listItem[1]) && !isListNested(editor, list[1])) {
          onKeyDownResetNode(editor, mockPlugin({
            options: {
              rules: [{
                types: [getPluginType(editor, ELEMENT_LI)],
                defaultType: getPluginType(editor, ELEMENT_DEFAULT),
                hotkey: "backspace",
                predicate: () => isSelectionAtBlockStart(editor),
                onReset: (e9) => unwrapList(e9)
              }]
            }
          }))(SIMULATE_BACKSPACE);
          moved = true;
          return;
        }
        deleteMerge(editor, {
          unit,
          reverse: true
        });
        moved = true;
      });
    }
  }
  return moved;
};
var selectionIsNotInAListHandler = (editor) => {
  const pointAfterSelection = getPointAfter(editor, editor.selection.focus.path);
  if (pointAfterSelection) {
    const nextSiblingListRes = getListItemEntry(editor, {
      at: pointAfterSelection
    });
    if (nextSiblingListRes) {
      const {
        listItem
      } = nextSiblingListRes;
      const parentBlockEntity = getBlockAbove(editor, {
        at: editor.selection.anchor
      });
      if (!getEditorString(editor, parentBlockEntity[1])) {
        removeNodes(editor);
        return true;
      }
      if (hasListChild(editor, listItem[0])) {
        const sublistRes = getListItemEntry(editor, {
          at: [...listItem[1], 1, 0, 0]
        });
        moveListItemUp(editor, sublistRes);
      }
    }
  }
  return false;
};
var selectionIsInAListHandler = (editor, res) => {
  const {
    listItem
  } = res;
  if (!hasListChild(editor, listItem[0])) {
    const liType = getPluginType(editor, ELEMENT_LI);
    const _nodes = getNodeEntries(editor, {
      at: listItem[1],
      mode: "lowest",
      match: (node, path) => {
        var _getNode;
        if (path.length === 0) {
          return false;
        }
        const isNodeLi = node.type === liType;
        const isSiblingOfNodeLi = ((_getNode = getNode(editor, Path.next(path))) === null || _getNode === void 0 ? void 0 : _getNode.type) === liType;
        return isNodeLi && isSiblingOfNodeLi;
      }
    });
    const liWithSiblings = Array.from(_nodes, (entry) => entry[1])[0];
    if (!liWithSiblings) {
      const pointAfterListItem = getPointAfter(editor, listItem[1]);
      if (pointAfterListItem) {
        const nextSiblingListRes = getListItemEntry(editor, {
          at: pointAfterListItem
        });
        if (nextSiblingListRes) {
          const listRoot = getListRoot(editor, listItem[1]);
          moveListItemsToList(editor, {
            fromList: nextSiblingListRes.list,
            toList: listRoot,
            deleteFromList: true
          });
          return true;
        }
      }
      return false;
    }
    const siblingListItem = getNodeEntry(editor, Path.next(liWithSiblings));
    const siblingList = getParentNode(editor, siblingListItem[1]);
    if (siblingList && removeListItem(editor, {
      list: siblingList,
      listItem: siblingListItem,
      reverse: false
    })) {
      return true;
    }
    return false;
  }
  const nestedList = getNodeEntry(editor, Path.next([...listItem[1], 0]));
  const nestedListItem = getChildren(nestedList)[0];
  if (removeFirstListItem(editor, {
    list: nestedList,
    listItem: nestedListItem
  })) {
    return true;
  }
  if (removeListItem(editor, {
    list: nestedList,
    listItem: nestedListItem
  })) {
    return true;
  }
  return false;
};
var deleteForwardList = (editor) => {
  let skipDefaultDelete = false;
  if (!(editor !== null && editor !== void 0 && editor.selection)) {
    return skipDefaultDelete;
  }
  if (!isSelectionAtBlockEnd(editor)) {
    return skipDefaultDelete;
  }
  withoutNormalizing(editor, () => {
    const res = getListItemEntry(editor, {});
    if (!res) {
      skipDefaultDelete = selectionIsNotInAListHandler(editor);
      return;
    }
    skipDefaultDelete = selectionIsInAListHandler(editor, res);
  });
  return skipDefaultDelete;
};
var deleteFragmentList = (editor) => {
  let deleted = false;
  withoutNormalizing(editor, () => {
    if (!isAcrossListItems(editor))
      return;
    const end2 = getEndPoint(editor, editor.selection);
    const liEnd = getAboveNode(editor, {
      at: end2,
      match: {
        type: getPluginType(editor, ELEMENT_LI)
      }
    });
    const liEndCanBeDeleted = liEnd && !hasListChild(editor, liEnd[0]);
    const liEndPathRef = liEndCanBeDeleted ? createPathRef(editor, liEnd[1]) : void 0;
    deleteMerge(editor);
    const start3 = getStartPoint(editor, editor.selection);
    const liStart = getAboveNode(editor, {
      at: start3,
      match: {
        type: getPluginType(editor, ELEMENT_LI)
      }
    });
    if (liEndPathRef) {
      const liEndPath = liEndPathRef.unref();
      const listStart = liStart && getParentNode(editor, liStart[1]);
      const deletePath = getHighestEmptyList(editor, {
        liPath: liEndPath,
        diffListPath: listStart === null || listStart === void 0 ? void 0 : listStart[1]
      });
      if (deletePath) {
        removeNodes(editor, {
          at: deletePath
        });
      }
      deleted = true;
    }
  });
  return deleted;
};
var insertBreakList = (editor) => {
  if (!editor.selection)
    return;
  const res = getListItemEntry(editor, {});
  let moved;
  if (res) {
    const {
      list,
      listItem
    } = res;
    if (isBlockAboveEmpty(editor)) {
      moved = moveListItemUp(editor, {
        list,
        listItem
      });
      if (moved)
        return true;
    }
  }
  const didReset = onKeyDownResetNode(editor, mockPlugin({
    options: {
      rules: [{
        types: [getPluginType(editor, ELEMENT_LI)],
        defaultType: getPluginType(editor, ELEMENT_DEFAULT),
        predicate: () => !moved && isBlockAboveEmpty(editor),
        onReset: (_editor) => unwrapList(_editor)
      }]
    }
  }))(SIMULATE_BACKSPACE);
  if (didReset)
    return true;
  if (!moved) {
    const inserted = insertListItem(editor);
    if (inserted)
      return true;
  }
};
var insertFragmentList = (editor) => {
  const {
    insertFragment: _insertFragment
  } = editor;
  const listItemPlugin = getPlugin(editor, ELEMENT_LI);
  const listItemType = getListItemType(editor);
  const listItemContentType = getListItemContentType(editor);
  const getFirstAncestorOfType = (root6, entry, {
    type
  }) => {
    let ancestor = Path.parent(entry[1]);
    while (getNode(root6, ancestor).type !== type) {
      ancestor = Path.parent(ancestor);
    }
    return [getNode(root6, ancestor), ancestor];
  };
  const findListItemsWithContent = (first) => {
    let prev = null;
    let node = first;
    while (isListRoot(editor, node) || node.type === listItemType && node.children[0].type !== listItemContentType) {
      prev = node;
      [node] = node.children;
    }
    return prev ? prev.children : [node];
  };
  const trimList = (listRoot) => {
    if (!isListRoot(editor, listRoot)) {
      return [listRoot];
    }
    const _texts = getNodeTexts(listRoot);
    const textEntries = Array.from(_texts);
    const commonAncestorEntry = textEntries.reduce(
      (commonAncestor, textEntry) => Path.isAncestor(commonAncestor[1], textEntry[1]) ? commonAncestor : getCommonNode(listRoot, textEntry[1], commonAncestor[1]),
      // any list item would do, we grab the first one
      getFirstAncestorOfType(listRoot, textEntries[0], listItemPlugin)
    );
    const [first, ...rest] = isListRoot(editor, commonAncestorEntry[0]) ? commonAncestorEntry[0].children : [commonAncestorEntry[0]];
    return [...findListItemsWithContent(first), ...rest];
  };
  const wrapNodeIntoListItem = (node) => {
    return node.type === listItemType ? node : {
      type: listItemType,
      children: [node]
    };
  };
  const isSingleLic = (fragment) => {
    const isFragmentOnlyListRoot = fragment.length === 1 && isListRoot(editor, fragment[0]);
    return isFragmentOnlyListRoot && [...getNodes({
      children: fragment
    })].filter((entry) => isElement2(entry[0])).filter(([node]) => node.type === listItemContentType).length === 1;
  };
  const getTextAndListItemNodes = (fragment, liEntry, licEntry) => {
    const [, liPath] = liEntry;
    const [licNode, licPath] = licEntry;
    const isEmptyNode = !getNodeString(licNode);
    const [first, ...rest] = fragment.flatMap(trimList).map(wrapNodeIntoListItem);
    let textNode;
    let listItemNodes;
    if (isListRoot(editor, fragment[0])) {
      if (isSingleLic(fragment)) {
        textNode = first;
        listItemNodes = rest;
      } else if (isEmptyNode) {
        const li = getNode(editor, liPath);
        const [, ...currentSublists] = li.children;
        const [newLic, ...newSublists] = first.children;
        insertElements(editor, newLic, {
          at: Path.next(licPath),
          select: true
        });
        removeNodes(editor, {
          at: licPath
        });
        if (newSublists !== null && newSublists !== void 0 && newSublists.length) {
          if (currentSublists !== null && currentSublists !== void 0 && currentSublists.length) {
            const path = [...liPath, 1, 0];
            insertElements(editor, newSublists[0].children, {
              at: path,
              select: true
            });
          } else {
            insertElements(editor, newSublists, {
              at: Path.next(licPath),
              select: true
            });
          }
        }
        textNode = {
          text: ""
        };
        listItemNodes = rest;
      } else {
        textNode = {
          text: ""
        };
        listItemNodes = [first, ...rest];
      }
    } else {
      textNode = first;
      listItemNodes = rest;
    }
    return {
      textNode,
      listItemNodes
    };
  };
  return (fragment) => {
    let liEntry = findNode(editor, {
      match: {
        type: listItemType
      },
      mode: "lowest"
    });
    if (!liEntry) {
      return _insertFragment(isListRoot(editor, fragment[0]) ? [{
        text: ""
      }, ...fragment] : fragment);
    }
    insertFragment(editor, [{
      text: ""
    }]);
    liEntry = findNode(editor, {
      match: {
        type: listItemType
      },
      mode: "lowest"
    });
    const licEntry = findNode(editor, {
      match: {
        type: listItemContentType
      },
      mode: "lowest"
    });
    if (!licEntry) {
      return _insertFragment(isListRoot(editor, fragment[0]) ? [{
        text: ""
      }, ...fragment] : fragment);
    }
    const {
      textNode,
      listItemNodes
    } = getTextAndListItemNodes(fragment, liEntry, licEntry);
    insertFragment(editor, [textNode]);
    const [, liPath] = liEntry;
    return insertElements(editor, listItemNodes, {
      at: Path.next(liPath),
      select: true
    });
  };
};
var getDeepInlineChildren = (editor, {
  children
}) => {
  const inlineChildren = [];
  for (const child of children) {
    if (isBlock(editor, child[0])) {
      inlineChildren.push(...getDeepInlineChildren(editor, {
        children: getChildren(child)
      }));
    } else {
      inlineChildren.push(child);
    }
  }
  return inlineChildren;
};
var normalizeListItem = (editor, {
  listItem,
  validLiChildrenTypes = []
}) => {
  let changed = false;
  const allValidLiChildrenTypes = [getPluginType(editor, ELEMENT_UL), getPluginType(editor, ELEMENT_OL), getPluginType(editor, ELEMENT_LIC), ...validLiChildrenTypes];
  const [, liPath] = listItem;
  const liChildren = getChildren(listItem);
  const invalidLiChildrenPathRefs = liChildren.filter(([child]) => !allValidLiChildrenTypes.includes(child.type)).map(([, childPath]) => createPathRef(editor, childPath));
  const firstLiChild = liChildren[0];
  const [firstLiChildNode, firstLiChildPath] = firstLiChild !== null && firstLiChild !== void 0 ? firstLiChild : [];
  if (!firstLiChild || !isBlock(editor, firstLiChildNode)) {
    insertEmptyElement(editor, getPluginType(editor, ELEMENT_LIC), {
      at: liPath.concat([0])
    });
    return true;
  }
  if (isBlock(editor, firstLiChildNode) && !match(firstLiChildNode, [], {
    type: getPluginType(editor, ELEMENT_LIC)
  })) {
    if (match(firstLiChildNode, [], {
      type: getListTypes(editor)
    })) {
      const parent2 = getParentNode(editor, listItem[1]);
      const sublist = firstLiChild;
      const children = getChildren(firstLiChild).reverse();
      children.forEach((c16) => {
        moveListItemUp(editor, {
          list: sublist,
          listItem: c16
        });
      });
      removeNodes(editor, {
        at: [...parent2[1], 0]
      });
      return true;
    }
    if (validLiChildrenTypes.includes(firstLiChildNode.type)) {
      return true;
    }
    setElements(editor, {
      type: getPluginType(editor, ELEMENT_LIC)
    }, {
      at: firstLiChildPath
    });
    changed = true;
  }
  const licChildren = getChildren(firstLiChild);
  if (licChildren.length) {
    var _licChildren;
    const blockPathRefs = [];
    const inlineChildren = [];
    for (const licChild of licChildren) {
      if (!isBlock(editor, licChild[0])) {
        break;
      }
      blockPathRefs.push(createPathRef(editor, licChild[1]));
      inlineChildren.push(...getDeepInlineChildren(editor, {
        children: getChildren(licChild)
      }));
    }
    const to4 = Path.next((_licChildren = licChildren[licChildren.length - 1]) === null || _licChildren === void 0 ? void 0 : _licChildren[1]);
    inlineChildren.reverse().forEach(([, path]) => {
      moveNodes(editor, {
        at: path,
        to: to4
      });
    });
    blockPathRefs.forEach((pathRef) => {
      const path = pathRef.unref();
      path && removeNodes(editor, {
        at: path
      });
    });
    if (blockPathRefs.length) {
      changed = true;
    }
  }
  if (changed)
    return true;
  invalidLiChildrenPathRefs.reverse().forEach((ref2) => {
    const path = ref2.unref();
    path && moveNodes(editor, {
      at: path,
      to: firstLiChildPath.concat([0])
    });
  });
  return !!invalidLiChildrenPathRefs.length;
};
var normalizeNestedList = (editor, {
  nestedListItem
}) => {
  const [, path] = nestedListItem;
  const parentNode = getParentNode(editor, path);
  const hasParentList = parentNode && match(parentNode[0], [], {
    type: getListTypes(editor)
  });
  if (!hasParentList) {
    return false;
  }
  let previousListItemPath;
  try {
    previousListItemPath = Path.previous(path);
  } catch (e9) {
    return false;
  }
  const previousSiblingItem = getNodeEntry(editor, previousListItemPath);
  if (previousSiblingItem) {
    const [, previousPath] = previousSiblingItem;
    const newPath = previousPath.concat([1]);
    moveNodes(editor, {
      at: path,
      to: newPath
    });
    return true;
  }
};
var normalizeList = (editor, {
  validLiChildrenTypes
}) => {
  const {
    normalizeNode
  } = editor;
  const liType = getPluginType(editor, ELEMENT_LI);
  const licType = getPluginType(editor, ELEMENT_LIC);
  const defaultType = getPluginType(editor, ELEMENT_DEFAULT);
  return ([node, path]) => {
    if (!isElement2(node)) {
      return normalizeNode([node, path]);
    }
    if (isListRoot(editor, node)) {
      const nonLiChild = getChildren([node, path]).find(([child]) => child.type !== liType);
      if (nonLiChild) {
        return wrapNodes(editor, {
          type: liType,
          children: []
        }, {
          at: nonLiChild[1]
        });
      }
    }
    if (match(node, [], {
      type: getListTypes(editor)
    })) {
      if (!node.children.length || !node.children.find((item) => item.type === liType)) {
        return removeNodes(editor, {
          at: path
        });
      }
      const nextPath = Path.next(path);
      const nextNode = getNode(editor, nextPath);
      if ((nextNode === null || nextNode === void 0 ? void 0 : nextNode.type) === node.type) {
        moveListItemsToList(editor, {
          fromList: [nextNode, nextPath],
          toList: [node, path],
          deleteFromList: true
        });
      }
      const prevPath = getPreviousPath(path);
      const prevNode = getNode(editor, prevPath);
      if ((prevNode === null || prevNode === void 0 ? void 0 : prevNode.type) === node.type) {
        editor.normalizeNode([prevNode, prevPath]);
        return;
      }
      if (normalizeNestedList(editor, {
        nestedListItem: [node, path]
      })) {
        return;
      }
    }
    if (node.type === getPluginType(editor, ELEMENT_LI)) {
      if (normalizeListItem(editor, {
        listItem: [node, path],
        validLiChildrenTypes
      })) {
        return;
      }
    }
    if (node.type === licType && licType !== defaultType) {
      var _getParentNode;
      if (((_getParentNode = getParentNode(editor, path)) === null || _getParentNode === void 0 ? void 0 : _getParentNode[0].type) !== liType) {
        setElements(editor, {
          type: defaultType
        }, {
          at: path
        });
        return;
      }
    }
    normalizeNode([node, path]);
  };
};
var withList = (editor, {
  options: {
    validLiChildrenTypes
  }
}) => {
  const {
    insertBreak,
    deleteBackward: deleteBackward2,
    deleteForward,
    deleteFragment
  } = editor;
  editor.insertBreak = () => {
    if (insertBreakList(editor))
      return;
    insertBreak();
  };
  editor.deleteBackward = (unit) => {
    if (deleteBackwardList(editor, unit))
      return;
    deleteBackward2(unit);
  };
  editor.deleteForward = (unit) => {
    if (deleteForwardList(editor))
      return;
    deleteForward(unit);
  };
  editor.deleteFragment = () => {
    if (deleteFragmentList(editor))
      return;
    deleteFragment();
  };
  editor.insertFragment = insertFragmentList(editor);
  editor.normalizeNode = normalizeList(editor, {
    validLiChildrenTypes
  });
  return editor;
};
var ELEMENT_UL = "ul";
var ELEMENT_OL = "ol";
var ELEMENT_LI = "li";
var ELEMENT_LIC = "lic";
var createListPlugin = createPluginFactory({
  key: "list",
  plugins: [{
    key: ELEMENT_UL,
    isElement: true,
    handlers: {
      onKeyDown: onKeyDownList
    },
    withOverrides: withList,
    deserializeHtml: {
      rules: [{
        validNodeName: "UL"
      }]
    }
  }, {
    key: ELEMENT_OL,
    isElement: true,
    handlers: {
      onKeyDown: onKeyDownList
    },
    deserializeHtml: {
      rules: [{
        validNodeName: "OL"
      }]
    }
  }, {
    key: ELEMENT_LI,
    isElement: true,
    deserializeHtml: {
      rules: [{
        validNodeName: "LI"
      }]
    },
    then: (editor, {
      type
    }) => ({
      inject: {
        pluginsByKey: {
          [KEY_DESERIALIZE_HTML]: {
            editor: {
              insertData: {
                preInsert: () => {
                  return someNode(editor, {
                    match: {
                      type
                    }
                  });
                }
              }
            }
          }
        }
      }
    })
  }, {
    key: ELEMENT_LIC,
    isElement: true
  }]
});
var ELEMENT_TODO_LI = "action_item";
var createTodoListPlugin = createPluginFactory({
  key: ELEMENT_TODO_LI,
  isElement: true,
  handlers: {
    onKeyDown: onKeyDownToggleElement
  },
  options: {
    hotkey: ["mod+opt+4", "mod+shift+4"]
  }
});

// node_modules/@udecode/plate-media-embed/dist/index.es.js
var ELEMENT_MEDIA_EMBED = "media_embed";
var createMediaEmbedPlugin = createPluginFactory({
  key: ELEMENT_MEDIA_EMBED,
  isElement: true,
  isVoid: true,
  then: (editor, {
    type
  }) => ({
    deserializeHtml: {
      rules: [{
        validNodeName: "IFRAME"
      }],
      getNode: (el) => {
        const url = el.getAttribute("src");
        if (url) {
          return {
            type,
            url
          };
        }
      }
    }
  })
});

// node_modules/@udecode/plate-mention/dist/index.es.js
function unwrapExports10(x7) {
  return x7 && x7.__esModule && Object.prototype.hasOwnProperty.call(x7, "default") ? x7["default"] : x7;
}
function createCommonjsModule11(fn2, module2) {
  return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
}
var lib10 = createCommonjsModule11(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var IS_MAC = () => typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
  var MODIFIERS = {
    alt: "altKey",
    control: "ctrlKey",
    meta: "metaKey",
    shift: "shiftKey"
  };
  var ALIASES = () => ({
    add: "+",
    break: "pause",
    cmd: "meta",
    command: "meta",
    ctl: "control",
    ctrl: "control",
    del: "delete",
    down: "arrowdown",
    esc: "escape",
    ins: "insert",
    left: "arrowleft",
    mod: IS_MAC() ? "meta" : "control",
    opt: "alt",
    option: "alt",
    return: "enter",
    right: "arrowright",
    space: " ",
    spacebar: " ",
    up: "arrowup",
    win: "meta",
    windows: "meta"
  });
  var CODES = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    control: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    " ": 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    insert: 45,
    delete: 46,
    meta: 91,
    numlock: 144,
    scrolllock: 145,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
  };
  for (var f16 = 1; f16 < 20; f16++) {
    CODES["f" + f16] = 111 + f16;
  }
  function isHotkey14(hotkey, options, event) {
    if (options && !("byKey" in options)) {
      event = options;
      options = null;
    }
    if (!Array.isArray(hotkey)) {
      hotkey = [hotkey];
    }
    var array2 = hotkey.map(function(string2) {
      return parseHotkey(string2, options);
    });
    var check = function check2(e9) {
      return array2.some(function(object2) {
        return compareHotkey(object2, e9);
      });
    };
    var ret = event == null ? check : check(event);
    return ret;
  }
  function isCodeHotkey(hotkey, event) {
    return isHotkey14(hotkey, event);
  }
  function isKeyHotkey2(hotkey, event) {
    return isHotkey14(hotkey, { byKey: true }, event);
  }
  function parseHotkey(hotkey, options) {
    var byKey = options && options.byKey;
    var ret = {};
    hotkey = hotkey.replace("++", "+add");
    var values3 = hotkey.split("+");
    var length = values3.length;
    for (var k3 in MODIFIERS) {
      ret[MODIFIERS[k3]] = false;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = void 0;
    try {
      for (var _iterator = values3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var value = _step.value;
        var optional = value.endsWith("?") && value.length > 1;
        if (optional) {
          value = value.slice(0, -1);
        }
        var name2 = toKeyName(value);
        var modifier = MODIFIERS[name2];
        if (length === 1 || !modifier) {
          if (byKey) {
            ret.key = name2;
          } else {
            ret.which = toKeyCode(value);
          }
        }
        if (modifier) {
          ret[modifier] = optional ? null : true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return ret;
  }
  function compareHotkey(object2, event) {
    for (var key in object2) {
      var expected = object2[key];
      var actual = void 0;
      if (expected == null) {
        continue;
      }
      if (key === "key" && event.key != null) {
        actual = event.key.toLowerCase();
      } else if (key === "which") {
        actual = expected === 91 && event.which === 93 ? 91 : event.which;
      } else {
        actual = event[key];
      }
      if (actual == null && expected === false) {
        continue;
      }
      if (actual !== expected) {
        return false;
      }
    }
    return true;
  }
  function toKeyCode(name2) {
    name2 = toKeyName(name2);
    var code = CODES[name2] || name2.toUpperCase().charCodeAt(0);
    return code;
  }
  function toKeyName(name2) {
    name2 = name2.toLowerCase();
    name2 = ALIASES()[name2] || name2;
    return name2;
  }
  exports2.default = isHotkey14;
  exports2.isHotkey = isHotkey14;
  exports2.isCodeHotkey = isCodeHotkey;
  exports2.isKeyHotkey = isKeyHotkey2;
  exports2.parseHotkey = parseHotkey;
  exports2.compareHotkey = compareHotkey;
  exports2.toKeyCode = toKeyCode;
  exports2.toKeyName = toKeyName;
});
var isHotkey10 = unwrapExports10(lib10);
lib10.isHotkey;
lib10.isCodeHotkey;
lib10.isKeyHotkey;
lib10.parseHotkey;
lib10.compareHotkey;
lib10.toKeyCode;
lib10.toKeyName;
var findMentionInput = (editor, options) => findNode(editor, {
  ...options,
  match: {
    type: getPluginType(editor, ELEMENT_MENTION_INPUT)
  }
});
var isNodeMentionInput = (editor, node) => {
  return node.type === getPluginType(editor, ELEMENT_MENTION_INPUT);
};
var isSelectionInMentionInput = (editor) => findMentionInput(editor) !== void 0;
var removeMentionInput = (editor, path) => withoutNormalizing(editor, () => {
  const node = getNode(editor, path);
  if (!node)
    return;
  const {
    trigger
  } = node;
  insertText(editor, trigger, {
    at: {
      path: [...path, 0],
      offset: 0
    }
  });
  unwrapNodes(editor, {
    at: path
  });
});
var moveSelectionByOffset = (editor, {
  query = () => true
} = {}) => (event) => {
  const {
    selection
  } = editor;
  if (!selection || Range.isExpanded(selection) || !query(editor)) {
    return false;
  }
  if (isHotkey10("left", event)) {
    event.preventDefault();
    moveSelection(editor, {
      unit: "offset",
      reverse: true
    });
    return true;
  }
  if (isHotkey10("right", event)) {
    event.preventDefault();
    moveSelection(editor, {
      unit: "offset"
    });
    return true;
  }
};
var mentionOnKeyDownHandler = (options) => (editor) => (event) => {
  if (isHotkey10("escape", event)) {
    event.preventDefault();
    const currentMentionInput = findMentionInput(editor);
    if (currentMentionInput) {
      removeMentionInput(editor, currentMentionInput[1]);
    }
    return true;
  }
  return moveSelectionByOffset(editor, options)(event);
};
var withMention = (editor, {
  options: {
    id,
    trigger,
    inputCreation
  }
}) => {
  const {
    type
  } = getPlugin(editor, ELEMENT_MENTION_INPUT);
  const {
    apply: apply5,
    insertBreak,
    insertText: _insertText,
    deleteBackward: deleteBackward2,
    insertFragment: _insertFragment,
    insertTextData
  } = editor;
  const stripNewLineAndTrim = (text) => {
    return text.split(/\r\n|\r|\n/).map((line) => line.trim()).join("");
  };
  editor.insertFragment = (fragment) => {
    const inMentionInput = findMentionInput(editor) !== void 0;
    if (!inMentionInput) {
      return _insertFragment(fragment);
    }
    return insertText(editor, fragment.map((node) => stripNewLineAndTrim(getNodeString(node))).join(""));
  };
  editor.insertTextData = (data) => {
    const inMentionInput = findMentionInput(editor) !== void 0;
    if (!inMentionInput) {
      return insertTextData(data);
    }
    const text = data.getData("text/plain");
    if (!text) {
      return false;
    }
    editor.insertText(stripNewLineAndTrim(text));
    return true;
  };
  editor.deleteBackward = (unit) => {
    const currentMentionInput = findMentionInput(editor);
    if (currentMentionInput && getNodeString(currentMentionInput[0]) === "") {
      return removeMentionInput(editor, currentMentionInput[1]);
    }
    deleteBackward2(unit);
  };
  editor.insertBreak = () => {
    if (isSelectionInMentionInput(editor)) {
      return;
    }
    insertBreak();
  };
  editor.insertText = (text) => {
    if (!editor.selection || text !== trigger || isSelectionInMentionInput(editor)) {
      return _insertText(text);
    }
    const previousChar = getEditorString(editor, getRange(editor, editor.selection, getPointBefore(editor, editor.selection)));
    const nextChar = getEditorString(editor, getRange(editor, editor.selection, getPointAfter(editor, editor.selection)));
    const beginningOfLine = previousChar === "";
    const endOfLine = nextChar === "";
    const precededByWhitespace = previousChar === " ";
    const followedByWhitespace = nextChar === " ";
    if ((beginningOfLine || precededByWhitespace) && (endOfLine || followedByWhitespace)) {
      const data = {
        type,
        children: [{
          text: ""
        }],
        trigger
      };
      if (inputCreation) {
        data[inputCreation.key] = inputCreation.value;
      }
      return insertNodes(editor, data);
    }
    return _insertText(text);
  };
  editor.apply = (operation) => {
    apply5(operation);
    if (operation.type === "insert_text" || operation.type === "remove_text") {
      const currentMentionInput = findMentionInput(editor);
      if (currentMentionInput) {
        comboboxActions.text(getNodeString(currentMentionInput[0]));
      }
    } else if (operation.type === "set_selection") {
      var _findMentionInput, _findMentionInput2;
      const previousMentionInputPath = Range.isRange(operation.properties) ? (_findMentionInput = findMentionInput(editor, {
        at: operation.properties
      })) === null || _findMentionInput === void 0 ? void 0 : _findMentionInput[1] : void 0;
      const currentMentionInputPath = Range.isRange(operation.newProperties) ? (_findMentionInput2 = findMentionInput(editor, {
        at: operation.newProperties
      })) === null || _findMentionInput2 === void 0 ? void 0 : _findMentionInput2[1] : void 0;
      if (previousMentionInputPath && !currentMentionInputPath) {
        removeMentionInput(editor, previousMentionInputPath);
      }
      if (currentMentionInputPath) {
        comboboxActions.targetRange(editor.selection);
      }
    } else if (operation.type === "insert_node" && isNodeMentionInput(editor, operation.node)) {
      var _$text, _7;
      if (operation.node.trigger !== trigger) {
        return;
      }
      const text = (_$text = (_7 = operation.node.children[0]) === null || _7 === void 0 ? void 0 : _7.text) !== null && _$text !== void 0 ? _$text : "";
      if (inputCreation === void 0 || operation.node[inputCreation.key] === inputCreation.value) {
        setSelection(editor, {
          anchor: {
            path: operation.path.concat([0]),
            offset: text.length
          },
          focus: {
            path: operation.path.concat([0]),
            offset: text.length
          }
        });
        comboboxActions.open({
          activeId: id,
          text,
          targetRange: editor.selection
        });
      }
    } else if (operation.type === "remove_node" && isNodeMentionInput(editor, operation.node)) {
      if (operation.node.trigger !== trigger) {
        return;
      }
      comboboxActions.reset();
    }
  };
  return editor;
};
var ELEMENT_MENTION = "mention";
var ELEMENT_MENTION_INPUT = "mention_input";
var createMentionPlugin = createPluginFactory({
  key: ELEMENT_MENTION,
  isElement: true,
  isInline: true,
  isVoid: true,
  handlers: {
    onKeyDown: mentionOnKeyDownHandler({
      query: isSelectionInMentionInput
    })
  },
  withOverrides: withMention,
  options: {
    trigger: "@",
    createMentionNode: (item) => ({
      value: item.text
    })
  },
  plugins: [{
    key: ELEMENT_MENTION_INPUT,
    isElement: true,
    isInline: true
  }],
  then: (editor, {
    key
  }) => ({
    options: {
      id: key
    }
  })
});

// node_modules/@udecode/plate-node-id/dist/index.es.js
function listCacheClear3() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear3 = listCacheClear3;
function eq3(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_13 = eq3;
function assocIndexOf3(array2, key) {
  var length = array2.length;
  while (length--) {
    if (eq_13(array2[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf3 = assocIndexOf3;
var arrayProto3 = Array.prototype;
var splice3 = arrayProto3.splice;
function listCacheDelete3(key) {
  var data = this.__data__, index2 = _assocIndexOf3(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice3.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete3 = listCacheDelete3;
function listCacheGet3(key) {
  var data = this.__data__, index2 = _assocIndexOf3(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet3 = listCacheGet3;
function listCacheHas3(key) {
  return _assocIndexOf3(this.__data__, key) > -1;
}
var _listCacheHas3 = listCacheHas3;
function listCacheSet3(key, value) {
  var data = this.__data__, index2 = _assocIndexOf3(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var _listCacheSet3 = listCacheSet3;
function ListCache3(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache3.prototype.clear = _listCacheClear3;
ListCache3.prototype["delete"] = _listCacheDelete3;
ListCache3.prototype.get = _listCacheGet3;
ListCache3.prototype.has = _listCacheHas3;
ListCache3.prototype.set = _listCacheSet3;
var _ListCache3 = ListCache3;
function stackClear3() {
  this.__data__ = new _ListCache3();
  this.size = 0;
}
var _stackClear3 = stackClear3;
function stackDelete3(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete3 = stackDelete3;
function stackGet3(key) {
  return this.__data__.get(key);
}
var _stackGet3 = stackGet3;
function stackHas3(key) {
  return this.__data__.has(key);
}
var _stackHas3 = stackHas3;
var commonjsGlobal3 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function createCommonjsModule12(fn2, module2) {
  return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
}
var freeGlobal3 = typeof commonjsGlobal3 == "object" && commonjsGlobal3 && commonjsGlobal3.Object === Object && commonjsGlobal3;
var _freeGlobal3 = freeGlobal3;
var freeSelf3 = typeof self == "object" && self && self.Object === Object && self;
var root3 = _freeGlobal3 || freeSelf3 || Function("return this")();
var _root3 = root3;
var Symbol3 = _root3.Symbol;
var _Symbol3 = Symbol3;
var objectProto$c2 = Object.prototype;
var hasOwnProperty$92 = objectProto$c2.hasOwnProperty;
var nativeObjectToString$13 = objectProto$c2.toString;
var symToStringTag$13 = _Symbol3 ? _Symbol3.toStringTag : void 0;
function getRawTag3(value) {
  var isOwn = hasOwnProperty$92.call(value, symToStringTag$13), tag = value[symToStringTag$13];
  try {
    value[symToStringTag$13] = void 0;
    var unmasked = true;
  } catch (e9) {
  }
  var result = nativeObjectToString$13.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$13] = tag;
    } else {
      delete value[symToStringTag$13];
    }
  }
  return result;
}
var _getRawTag3 = getRawTag3;
var objectProto$b3 = Object.prototype;
var nativeObjectToString3 = objectProto$b3.toString;
function objectToString3(value) {
  return nativeObjectToString3.call(value);
}
var _objectToString3 = objectToString3;
var nullTag3 = "[object Null]";
var undefinedTag3 = "[object Undefined]";
var symToStringTag3 = _Symbol3 ? _Symbol3.toStringTag : void 0;
function baseGetTag3(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag3 : nullTag3;
  }
  return symToStringTag3 && symToStringTag3 in Object(value) ? _getRawTag3(value) : _objectToString3(value);
}
var _baseGetTag3 = baseGetTag3;
function isObject4(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_13 = isObject4;
var asyncTag3 = "[object AsyncFunction]";
var funcTag$22 = "[object Function]";
var genTag$12 = "[object GeneratorFunction]";
var proxyTag3 = "[object Proxy]";
function isFunction3(value) {
  if (!isObject_13(value)) {
    return false;
  }
  var tag = _baseGetTag3(value);
  return tag == funcTag$22 || tag == genTag$12 || tag == asyncTag3 || tag == proxyTag3;
}
var isFunction_13 = isFunction3;
var coreJsData3 = _root3["__core-js_shared__"];
var _coreJsData3 = coreJsData3;
var maskSrcKey3 = function() {
  var uid2 = /[^.]+$/.exec(_coreJsData3 && _coreJsData3.keys && _coreJsData3.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked3(func) {
  return !!maskSrcKey3 && maskSrcKey3 in func;
}
var _isMasked3 = isMasked3;
var funcProto$13 = Function.prototype;
var funcToString$13 = funcProto$13.toString;
function toSource3(func) {
  if (func != null) {
    try {
      return funcToString$13.call(func);
    } catch (e9) {
    }
    try {
      return func + "";
    } catch (e9) {
    }
  }
  return "";
}
var _toSource3 = toSource3;
var reRegExpChar3 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor3 = /^\[object .+?Constructor\]$/;
var funcProto3 = Function.prototype;
var objectProto$a3 = Object.prototype;
var funcToString3 = funcProto3.toString;
var hasOwnProperty$83 = objectProto$a3.hasOwnProperty;
var reIsNative3 = RegExp(
  "^" + funcToString3.call(hasOwnProperty$83).replace(reRegExpChar3, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative3(value) {
  if (!isObject_13(value) || _isMasked3(value)) {
    return false;
  }
  var pattern = isFunction_13(value) ? reIsNative3 : reIsHostCtor3;
  return pattern.test(_toSource3(value));
}
var _baseIsNative3 = baseIsNative3;
function getValue3(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
var _getValue3 = getValue3;
function getNative3(object2, key) {
  var value = _getValue3(object2, key);
  return _baseIsNative3(value) ? value : void 0;
}
var _getNative3 = getNative3;
var Map4 = _getNative3(_root3, "Map");
var _Map3 = Map4;
var nativeCreate3 = _getNative3(Object, "create");
var _nativeCreate3 = nativeCreate3;
function hashClear3() {
  this.__data__ = _nativeCreate3 ? _nativeCreate3(null) : {};
  this.size = 0;
}
var _hashClear3 = hashClear3;
function hashDelete3(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete3 = hashDelete3;
var HASH_UNDEFINED$13 = "__lodash_hash_undefined__";
var objectProto$93 = Object.prototype;
var hasOwnProperty$73 = objectProto$93.hasOwnProperty;
function hashGet3(key) {
  var data = this.__data__;
  if (_nativeCreate3) {
    var result = data[key];
    return result === HASH_UNDEFINED$13 ? void 0 : result;
  }
  return hasOwnProperty$73.call(data, key) ? data[key] : void 0;
}
var _hashGet3 = hashGet3;
var objectProto$83 = Object.prototype;
var hasOwnProperty$63 = objectProto$83.hasOwnProperty;
function hashHas3(key) {
  var data = this.__data__;
  return _nativeCreate3 ? data[key] !== void 0 : hasOwnProperty$63.call(data, key);
}
var _hashHas3 = hashHas3;
var HASH_UNDEFINED3 = "__lodash_hash_undefined__";
function hashSet3(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = _nativeCreate3 && value === void 0 ? HASH_UNDEFINED3 : value;
  return this;
}
var _hashSet3 = hashSet3;
function Hash3(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash3.prototype.clear = _hashClear3;
Hash3.prototype["delete"] = _hashDelete3;
Hash3.prototype.get = _hashGet3;
Hash3.prototype.has = _hashHas3;
Hash3.prototype.set = _hashSet3;
var _Hash3 = Hash3;
function mapCacheClear3() {
  this.size = 0;
  this.__data__ = {
    "hash": new _Hash3(),
    "map": new (_Map3 || _ListCache3)(),
    "string": new _Hash3()
  };
}
var _mapCacheClear3 = mapCacheClear3;
function isKeyable3(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable3 = isKeyable3;
function getMapData3(map5, key) {
  var data = map5.__data__;
  return _isKeyable3(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData3 = getMapData3;
function mapCacheDelete3(key) {
  var result = _getMapData3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete3 = mapCacheDelete3;
function mapCacheGet3(key) {
  return _getMapData3(this, key).get(key);
}
var _mapCacheGet3 = mapCacheGet3;
function mapCacheHas3(key) {
  return _getMapData3(this, key).has(key);
}
var _mapCacheHas3 = mapCacheHas3;
function mapCacheSet3(key, value) {
  var data = _getMapData3(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var _mapCacheSet3 = mapCacheSet3;
function MapCache3(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache3.prototype.clear = _mapCacheClear3;
MapCache3.prototype["delete"] = _mapCacheDelete3;
MapCache3.prototype.get = _mapCacheGet3;
MapCache3.prototype.has = _mapCacheHas3;
MapCache3.prototype.set = _mapCacheSet3;
var _MapCache3 = MapCache3;
var LARGE_ARRAY_SIZE3 = 200;
function stackSet3(key, value) {
  var data = this.__data__;
  if (data instanceof _ListCache3) {
    var pairs = data.__data__;
    if (!_Map3 || pairs.length < LARGE_ARRAY_SIZE3 - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new _MapCache3(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet3 = stackSet3;
function Stack3(entries) {
  var data = this.__data__ = new _ListCache3(entries);
  this.size = data.size;
}
Stack3.prototype.clear = _stackClear3;
Stack3.prototype["delete"] = _stackDelete3;
Stack3.prototype.get = _stackGet3;
Stack3.prototype.has = _stackHas3;
Stack3.prototype.set = _stackSet3;
var _Stack2 = Stack3;
function arrayEach2(array2, iteratee) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (iteratee(array2[index2], index2, array2) === false) {
      break;
    }
  }
  return array2;
}
var _arrayEach2 = arrayEach2;
var defineProperty3 = function() {
  try {
    var func = _getNative3(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e9) {
  }
}();
var _defineProperty4 = defineProperty3;
function baseAssignValue2(object2, key, value) {
  if (key == "__proto__" && _defineProperty4) {
    _defineProperty4(object2, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object2[key] = value;
  }
}
var _baseAssignValue2 = baseAssignValue2;
var objectProto$73 = Object.prototype;
var hasOwnProperty$53 = objectProto$73.hasOwnProperty;
function assignValue2(object2, key, value) {
  var objValue = object2[key];
  if (!(hasOwnProperty$53.call(object2, key) && eq_13(objValue, value)) || value === void 0 && !(key in object2)) {
    _baseAssignValue2(object2, key, value);
  }
}
var _assignValue2 = assignValue2;
function copyObject2(source, props, object2, customizer) {
  var isNew = !object2;
  object2 || (object2 = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      _baseAssignValue2(object2, key, newValue);
    } else {
      _assignValue2(object2, key, newValue);
    }
  }
  return object2;
}
var _copyObject2 = copyObject2;
function baseTimes2(n12, iteratee) {
  var index2 = -1, result = Array(n12);
  while (++index2 < n12) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes2 = baseTimes2;
function isObjectLike3(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_13 = isObjectLike3;
var argsTag$23 = "[object Arguments]";
function baseIsArguments3(value) {
  return isObjectLike_13(value) && _baseGetTag3(value) == argsTag$23;
}
var _baseIsArguments3 = baseIsArguments3;
var objectProto$63 = Object.prototype;
var hasOwnProperty$43 = objectProto$63.hasOwnProperty;
var propertyIsEnumerable$13 = objectProto$63.propertyIsEnumerable;
var isArguments3 = _baseIsArguments3(function() {
  return arguments;
}()) ? _baseIsArguments3 : function(value) {
  return isObjectLike_13(value) && hasOwnProperty$43.call(value, "callee") && !propertyIsEnumerable$13.call(value, "callee");
};
var isArguments_12 = isArguments3;
var isArray6 = Array.isArray;
var isArray_15 = isArray6;
function stubFalse3() {
  return false;
}
var stubFalse_13 = stubFalse3;
var isBuffer_13 = createCommonjsModule12(function(module2, exports2) {
  var freeExports4 = exports2 && !exports2.nodeType && exports2;
  var freeModule4 = freeExports4 && true && module2 && !module2.nodeType && module2;
  var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
  var Buffer3 = moduleExports4 ? _root3.Buffer : void 0;
  var nativeIsBuffer2 = Buffer3 ? Buffer3.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer2 || stubFalse_13;
  module2.exports = isBuffer2;
});
var MAX_SAFE_INTEGER$12 = 9007199254740991;
var reIsUint2 = /^(?:0|[1-9]\d*)$/;
function isIndex2(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$12 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint2.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex2 = isIndex2;
var MAX_SAFE_INTEGER3 = 9007199254740991;
function isLength3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER3;
}
var isLength_13 = isLength3;
var argsTag$13 = "[object Arguments]";
var arrayTag$13 = "[object Array]";
var boolTag$22 = "[object Boolean]";
var dateTag$22 = "[object Date]";
var errorTag$13 = "[object Error]";
var funcTag$13 = "[object Function]";
var mapTag$42 = "[object Map]";
var numberTag$22 = "[object Number]";
var objectTag$23 = "[object Object]";
var regexpTag$22 = "[object RegExp]";
var setTag$42 = "[object Set]";
var stringTag$22 = "[object String]";
var weakMapTag$22 = "[object WeakMap]";
var arrayBufferTag$22 = "[object ArrayBuffer]";
var dataViewTag$32 = "[object DataView]";
var float32Tag$22 = "[object Float32Array]";
var float64Tag$22 = "[object Float64Array]";
var int8Tag$22 = "[object Int8Array]";
var int16Tag$22 = "[object Int16Array]";
var int32Tag$22 = "[object Int32Array]";
var uint8Tag$22 = "[object Uint8Array]";
var uint8ClampedTag$22 = "[object Uint8ClampedArray]";
var uint16Tag$22 = "[object Uint16Array]";
var uint32Tag$22 = "[object Uint32Array]";
var typedArrayTags3 = {};
typedArrayTags3[float32Tag$22] = typedArrayTags3[float64Tag$22] = typedArrayTags3[int8Tag$22] = typedArrayTags3[int16Tag$22] = typedArrayTags3[int32Tag$22] = typedArrayTags3[uint8Tag$22] = typedArrayTags3[uint8ClampedTag$22] = typedArrayTags3[uint16Tag$22] = typedArrayTags3[uint32Tag$22] = true;
typedArrayTags3[argsTag$13] = typedArrayTags3[arrayTag$13] = typedArrayTags3[arrayBufferTag$22] = typedArrayTags3[boolTag$22] = typedArrayTags3[dataViewTag$32] = typedArrayTags3[dateTag$22] = typedArrayTags3[errorTag$13] = typedArrayTags3[funcTag$13] = typedArrayTags3[mapTag$42] = typedArrayTags3[numberTag$22] = typedArrayTags3[objectTag$23] = typedArrayTags3[regexpTag$22] = typedArrayTags3[setTag$42] = typedArrayTags3[stringTag$22] = typedArrayTags3[weakMapTag$22] = false;
function baseIsTypedArray3(value) {
  return isObjectLike_13(value) && isLength_13(value.length) && !!typedArrayTags3[_baseGetTag3(value)];
}
var _baseIsTypedArray3 = baseIsTypedArray3;
function baseUnary3(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary3 = baseUnary3;
var _nodeUtil3 = createCommonjsModule12(function(module2, exports2) {
  var freeExports4 = exports2 && !exports2.nodeType && exports2;
  var freeModule4 = freeExports4 && true && module2 && !module2.nodeType && module2;
  var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
  var freeProcess2 = moduleExports4 && _freeGlobal3.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule4 && freeModule4.require && freeModule4.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
    } catch (e9) {
    }
  }();
  module2.exports = nodeUtil2;
});
var nodeIsTypedArray3 = _nodeUtil3 && _nodeUtil3.isTypedArray;
var isTypedArray3 = nodeIsTypedArray3 ? _baseUnary3(nodeIsTypedArray3) : _baseIsTypedArray3;
var isTypedArray_12 = isTypedArray3;
var objectProto$53 = Object.prototype;
var hasOwnProperty$33 = objectProto$53.hasOwnProperty;
function arrayLikeKeys2(value, inherited) {
  var isArr = isArray_15(value), isArg = !isArr && isArguments_12(value), isBuff = !isArr && !isArg && isBuffer_13(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray_12(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? _baseTimes2(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$33.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    _isIndex2(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys2 = arrayLikeKeys2;
var objectProto$43 = Object.prototype;
function isPrototype2(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$43;
  return value === proto2;
}
var _isPrototype2 = isPrototype2;
function overArg3(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg3 = overArg3;
var nativeKeys3 = _overArg3(Object.keys, Object);
var _nativeKeys2 = nativeKeys3;
var objectProto$33 = Object.prototype;
var hasOwnProperty$23 = objectProto$33.hasOwnProperty;
function baseKeys2(object2) {
  if (!_isPrototype2(object2)) {
    return _nativeKeys2(object2);
  }
  var result = [];
  for (var key in Object(object2)) {
    if (hasOwnProperty$23.call(object2, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys2 = baseKeys2;
function isArrayLike2(value) {
  return value != null && isLength_13(value.length) && !isFunction_13(value);
}
var isArrayLike_12 = isArrayLike2;
function keys2(object2) {
  return isArrayLike_12(object2) ? _arrayLikeKeys2(object2) : _baseKeys2(object2);
}
var keys_12 = keys2;
function baseAssign2(object2, source) {
  return object2 && _copyObject2(source, keys_12(source), object2);
}
var _baseAssign2 = baseAssign2;
function nativeKeysIn2(object2) {
  var result = [];
  if (object2 != null) {
    for (var key in Object(object2)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn2 = nativeKeysIn2;
var objectProto$23 = Object.prototype;
var hasOwnProperty$13 = objectProto$23.hasOwnProperty;
function baseKeysIn2(object2) {
  if (!isObject_13(object2)) {
    return _nativeKeysIn2(object2);
  }
  var isProto = _isPrototype2(object2), result = [];
  for (var key in object2) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$13.call(object2, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn2 = baseKeysIn2;
function keysIn2(object2) {
  return isArrayLike_12(object2) ? _arrayLikeKeys2(object2, true) : _baseKeysIn2(object2);
}
var keysIn_12 = keysIn2;
function baseAssignIn2(object2, source) {
  return object2 && _copyObject2(source, keysIn_12(source), object2);
}
var _baseAssignIn2 = baseAssignIn2;
var _cloneBuffer2 = createCommonjsModule12(function(module2, exports2) {
  var freeExports4 = exports2 && !exports2.nodeType && exports2;
  var freeModule4 = freeExports4 && true && module2 && !module2.nodeType && module2;
  var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
  var Buffer3 = moduleExports4 ? _root3.Buffer : void 0, allocUnsafe2 = Buffer3 ? Buffer3.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe2 ? allocUnsafe2(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module2.exports = cloneBuffer2;
});
function copyArray2(source, array2) {
  var index2 = -1, length = source.length;
  array2 || (array2 = Array(length));
  while (++index2 < length) {
    array2[index2] = source[index2];
  }
  return array2;
}
var _copyArray2 = copyArray2;
function arrayFilter2(array2, predicate) {
  var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array2[index2];
    if (predicate(value, index2, array2)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter2 = arrayFilter2;
function stubArray2() {
  return [];
}
var stubArray_12 = stubArray2;
var objectProto$13 = Object.prototype;
var propertyIsEnumerable3 = objectProto$13.propertyIsEnumerable;
var nativeGetSymbols$12 = Object.getOwnPropertySymbols;
var getSymbols2 = !nativeGetSymbols$12 ? stubArray_12 : function(object2) {
  if (object2 == null) {
    return [];
  }
  object2 = Object(object2);
  return _arrayFilter2(nativeGetSymbols$12(object2), function(symbol) {
    return propertyIsEnumerable3.call(object2, symbol);
  });
};
var _getSymbols2 = getSymbols2;
function copySymbols2(source, object2) {
  return _copyObject2(source, _getSymbols2(source), object2);
}
var _copySymbols2 = copySymbols2;
function arrayPush2(array2, values3) {
  var index2 = -1, length = values3.length, offset5 = array2.length;
  while (++index2 < length) {
    array2[offset5 + index2] = values3[index2];
  }
  return array2;
}
var _arrayPush2 = arrayPush2;
var getPrototype2 = _overArg3(Object.getPrototypeOf, Object);
var _getPrototype2 = getPrototype2;
var nativeGetSymbols2 = Object.getOwnPropertySymbols;
var getSymbolsIn2 = !nativeGetSymbols2 ? stubArray_12 : function(object2) {
  var result = [];
  while (object2) {
    _arrayPush2(result, _getSymbols2(object2));
    object2 = _getPrototype2(object2);
  }
  return result;
};
var _getSymbolsIn2 = getSymbolsIn2;
function copySymbolsIn2(source, object2) {
  return _copyObject2(source, _getSymbolsIn2(source), object2);
}
var _copySymbolsIn2 = copySymbolsIn2;
function baseGetAllKeys2(object2, keysFunc, symbolsFunc) {
  var result = keysFunc(object2);
  return isArray_15(object2) ? result : _arrayPush2(result, symbolsFunc(object2));
}
var _baseGetAllKeys2 = baseGetAllKeys2;
function getAllKeys2(object2) {
  return _baseGetAllKeys2(object2, keys_12, _getSymbols2);
}
var _getAllKeys2 = getAllKeys2;
function getAllKeysIn2(object2) {
  return _baseGetAllKeys2(object2, keysIn_12, _getSymbolsIn2);
}
var _getAllKeysIn2 = getAllKeysIn2;
var DataView3 = _getNative3(_root3, "DataView");
var _DataView3 = DataView3;
var Promise$13 = _getNative3(_root3, "Promise");
var _Promise3 = Promise$13;
var Set4 = _getNative3(_root3, "Set");
var _Set3 = Set4;
var WeakMap3 = _getNative3(_root3, "WeakMap");
var _WeakMap3 = WeakMap3;
var mapTag$32 = "[object Map]";
var objectTag$13 = "[object Object]";
var promiseTag3 = "[object Promise]";
var setTag$32 = "[object Set]";
var weakMapTag$13 = "[object WeakMap]";
var dataViewTag$23 = "[object DataView]";
var dataViewCtorString3 = _toSource3(_DataView3);
var mapCtorString3 = _toSource3(_Map3);
var promiseCtorString3 = _toSource3(_Promise3);
var setCtorString3 = _toSource3(_Set3);
var weakMapCtorString3 = _toSource3(_WeakMap3);
var getTag3 = _baseGetTag3;
if (_DataView3 && getTag3(new _DataView3(new ArrayBuffer(1))) != dataViewTag$23 || _Map3 && getTag3(new _Map3()) != mapTag$32 || _Promise3 && getTag3(_Promise3.resolve()) != promiseTag3 || _Set3 && getTag3(new _Set3()) != setTag$32 || _WeakMap3 && getTag3(new _WeakMap3()) != weakMapTag$13) {
  getTag3 = function(value) {
    var result = _baseGetTag3(value), Ctor = result == objectTag$13 ? value.constructor : void 0, ctorString = Ctor ? _toSource3(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString3:
          return dataViewTag$23;
        case mapCtorString3:
          return mapTag$32;
        case promiseCtorString3:
          return promiseTag3;
        case setCtorString3:
          return setTag$32;
        case weakMapCtorString3:
          return weakMapTag$13;
      }
    }
    return result;
  };
}
var _getTag2 = getTag3;
var objectProto3 = Object.prototype;
var hasOwnProperty3 = objectProto3.hasOwnProperty;
function initCloneArray2(array2) {
  var length = array2.length, result = new array2.constructor(length);
  if (length && typeof array2[0] == "string" && hasOwnProperty3.call(array2, "index")) {
    result.index = array2.index;
    result.input = array2.input;
  }
  return result;
}
var _initCloneArray2 = initCloneArray2;
var Uint8Array4 = _root3.Uint8Array;
var _Uint8Array2 = Uint8Array4;
function cloneArrayBuffer2(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _Uint8Array2(result).set(new _Uint8Array2(arrayBuffer));
  return result;
}
var _cloneArrayBuffer2 = cloneArrayBuffer2;
function cloneDataView2(dataView, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer2(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView2 = cloneDataView2;
var reFlags2 = /\w*$/;
function cloneRegExp2(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags2.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp2 = cloneRegExp2;
var symbolProto3 = _Symbol3 ? _Symbol3.prototype : void 0;
var symbolValueOf3 = symbolProto3 ? symbolProto3.valueOf : void 0;
function cloneSymbol2(symbol) {
  return symbolValueOf3 ? Object(symbolValueOf3.call(symbol)) : {};
}
var _cloneSymbol2 = cloneSymbol2;
function cloneTypedArray2(typedArray, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer2(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray2 = cloneTypedArray2;
var boolTag$13 = "[object Boolean]";
var dateTag$13 = "[object Date]";
var mapTag$23 = "[object Map]";
var numberTag$13 = "[object Number]";
var regexpTag$13 = "[object RegExp]";
var setTag$23 = "[object Set]";
var stringTag$13 = "[object String]";
var symbolTag$12 = "[object Symbol]";
var arrayBufferTag$13 = "[object ArrayBuffer]";
var dataViewTag$12 = "[object DataView]";
var float32Tag$12 = "[object Float32Array]";
var float64Tag$12 = "[object Float64Array]";
var int8Tag$12 = "[object Int8Array]";
var int16Tag$12 = "[object Int16Array]";
var int32Tag$12 = "[object Int32Array]";
var uint8Tag$12 = "[object Uint8Array]";
var uint8ClampedTag$12 = "[object Uint8ClampedArray]";
var uint16Tag$12 = "[object Uint16Array]";
var uint32Tag$12 = "[object Uint32Array]";
function initCloneByTag2(object2, tag, isDeep) {
  var Ctor = object2.constructor;
  switch (tag) {
    case arrayBufferTag$13:
      return _cloneArrayBuffer2(object2);
    case boolTag$13:
    case dateTag$13:
      return new Ctor(+object2);
    case dataViewTag$12:
      return _cloneDataView2(object2, isDeep);
    case float32Tag$12:
    case float64Tag$12:
    case int8Tag$12:
    case int16Tag$12:
    case int32Tag$12:
    case uint8Tag$12:
    case uint8ClampedTag$12:
    case uint16Tag$12:
    case uint32Tag$12:
      return _cloneTypedArray2(object2, isDeep);
    case mapTag$23:
      return new Ctor();
    case numberTag$13:
    case stringTag$13:
      return new Ctor(object2);
    case regexpTag$13:
      return _cloneRegExp2(object2);
    case setTag$23:
      return new Ctor();
    case symbolTag$12:
      return _cloneSymbol2(object2);
  }
}
var _initCloneByTag2 = initCloneByTag2;
var objectCreate2 = Object.create;
var baseCreate2 = function() {
  function object2() {
  }
  return function(proto2) {
    if (!isObject_13(proto2)) {
      return {};
    }
    if (objectCreate2) {
      return objectCreate2(proto2);
    }
    object2.prototype = proto2;
    var result = new object2();
    object2.prototype = void 0;
    return result;
  };
}();
var _baseCreate2 = baseCreate2;
function initCloneObject2(object2) {
  return typeof object2.constructor == "function" && !_isPrototype2(object2) ? _baseCreate2(_getPrototype2(object2)) : {};
}
var _initCloneObject2 = initCloneObject2;
var mapTag$12 = "[object Map]";
function baseIsMap2(value) {
  return isObjectLike_13(value) && _getTag2(value) == mapTag$12;
}
var _baseIsMap2 = baseIsMap2;
var nodeIsMap2 = _nodeUtil3 && _nodeUtil3.isMap;
var isMap2 = nodeIsMap2 ? _baseUnary3(nodeIsMap2) : _baseIsMap2;
var isMap_12 = isMap2;
var setTag$12 = "[object Set]";
function baseIsSet2(value) {
  return isObjectLike_13(value) && _getTag2(value) == setTag$12;
}
var _baseIsSet2 = baseIsSet2;
var nodeIsSet2 = _nodeUtil3 && _nodeUtil3.isSet;
var isSet2 = nodeIsSet2 ? _baseUnary3(nodeIsSet2) : _baseIsSet2;
var isSet_12 = isSet2;
var CLONE_DEEP_FLAG$12 = 1;
var CLONE_FLAT_FLAG2 = 2;
var CLONE_SYMBOLS_FLAG$12 = 4;
var argsTag2 = "[object Arguments]";
var arrayTag2 = "[object Array]";
var boolTag2 = "[object Boolean]";
var dateTag2 = "[object Date]";
var errorTag2 = "[object Error]";
var funcTag3 = "[object Function]";
var genTag3 = "[object GeneratorFunction]";
var mapTag3 = "[object Map]";
var numberTag2 = "[object Number]";
var objectTag2 = "[object Object]";
var regexpTag2 = "[object RegExp]";
var setTag3 = "[object Set]";
var stringTag2 = "[object String]";
var symbolTag2 = "[object Symbol]";
var weakMapTag3 = "[object WeakMap]";
var arrayBufferTag2 = "[object ArrayBuffer]";
var dataViewTag3 = "[object DataView]";
var float32Tag3 = "[object Float32Array]";
var float64Tag3 = "[object Float64Array]";
var int8Tag3 = "[object Int8Array]";
var int16Tag3 = "[object Int16Array]";
var int32Tag3 = "[object Int32Array]";
var uint8Tag3 = "[object Uint8Array]";
var uint8ClampedTag3 = "[object Uint8ClampedArray]";
var uint16Tag3 = "[object Uint16Array]";
var uint32Tag3 = "[object Uint32Array]";
var cloneableTags2 = {};
cloneableTags2[argsTag2] = cloneableTags2[arrayTag2] = cloneableTags2[arrayBufferTag2] = cloneableTags2[dataViewTag3] = cloneableTags2[boolTag2] = cloneableTags2[dateTag2] = cloneableTags2[float32Tag3] = cloneableTags2[float64Tag3] = cloneableTags2[int8Tag3] = cloneableTags2[int16Tag3] = cloneableTags2[int32Tag3] = cloneableTags2[mapTag3] = cloneableTags2[numberTag2] = cloneableTags2[objectTag2] = cloneableTags2[regexpTag2] = cloneableTags2[setTag3] = cloneableTags2[stringTag2] = cloneableTags2[symbolTag2] = cloneableTags2[uint8Tag3] = cloneableTags2[uint8ClampedTag3] = cloneableTags2[uint16Tag3] = cloneableTags2[uint32Tag3] = true;
cloneableTags2[errorTag2] = cloneableTags2[funcTag3] = cloneableTags2[weakMapTag3] = false;
function baseClone2(value, bitmask, customizer, key, object2, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$12, isFlat = bitmask & CLONE_FLAT_FLAG2, isFull = bitmask & CLONE_SYMBOLS_FLAG$12;
  if (customizer) {
    result = object2 ? customizer(value, key, object2, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject_13(value)) {
    return value;
  }
  var isArr = isArray_15(value);
  if (isArr) {
    result = _initCloneArray2(value);
    if (!isDeep) {
      return _copyArray2(value, result);
    }
  } else {
    var tag = _getTag2(value), isFunc = tag == funcTag3 || tag == genTag3;
    if (isBuffer_13(value)) {
      return _cloneBuffer2(value, isDeep);
    }
    if (tag == objectTag2 || tag == argsTag2 || isFunc && !object2) {
      result = isFlat || isFunc ? {} : _initCloneObject2(value);
      if (!isDeep) {
        return isFlat ? _copySymbolsIn2(value, _baseAssignIn2(result, value)) : _copySymbols2(value, _baseAssign2(result, value));
      }
    } else {
      if (!cloneableTags2[tag]) {
        return object2 ? value : {};
      }
      result = _initCloneByTag2(value, tag, isDeep);
    }
  }
  stack || (stack = new _Stack2());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet_12(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone2(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_12(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone2(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? _getAllKeysIn2 : _getAllKeys2 : isFlat ? keysIn_12 : keys_12;
  var props = isArr ? void 0 : keysFunc(value);
  _arrayEach2(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    _assignValue2(result, key2, baseClone2(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone2 = baseClone2;
var CLONE_DEEP_FLAG2 = 1;
var CLONE_SYMBOLS_FLAG2 = 4;
function cloneDeep2(value) {
  return _baseClone2(value, CLONE_DEEP_FLAG2 | CLONE_SYMBOLS_FLAG2);
}
var cloneDeep_12 = cloneDeep2;
var withNodeId = (editor, {
  options: {
    idKey = "",
    idCreator,
    filterText,
    filter,
    reuseId,
    allow,
    exclude
  }
}) => {
  const {
    apply: apply5
  } = editor;
  const idPropsCreator = () => ({
    [idKey]: idCreator()
  });
  const filterNode = (nodeEntry) => {
    var _nodeEntry$;
    return filter(nodeEntry) && (!filterText || ((_nodeEntry$ = nodeEntry[0]) === null || _nodeEntry$ === void 0 ? void 0 : _nodeEntry$.type) !== void 0);
  };
  const query = {
    filter: filterNode,
    allow,
    exclude
  };
  editor.apply = (operation) => {
    if (operation.type === "insert_node") {
      const node = cloneDeep_12(operation.node);
      if (!reuseId || someNode(editor, {
        match: {
          [idKey]: node[idKey]
        },
        at: []
      })) {
        delete node[idKey];
      }
      defaultsDeepToNodes({
        node,
        source: idPropsCreator,
        query
      });
      return apply5({
        ...operation,
        node
      });
    }
    if (operation.type === "split_node") {
      const node = operation.properties;
      if (queryNode([node, []], query)) {
        let id = operation.properties[idKey];
        if (!reuseId || id === void 0 || someNode(editor, {
          match: {
            [idKey]: id
          },
          at: []
        })) {
          id = idCreator();
        }
        return apply5({
          ...operation,
          properties: {
            ...operation.properties,
            [idKey]: id
          }
        });
      }
    }
    return apply5(operation);
  };
  return editor;
};
var KEY_NODE_ID = "nodeId";
var createNodeIdPlugin = createPluginFactory({
  key: KEY_NODE_ID,
  withOverrides: withNodeId,
  options: {
    idKey: "id",
    idCreator: () => Date.now(),
    filterText: true,
    filter: () => true
  }
});

// node_modules/@udecode/plate-select/dist/index.es.js
var withSelectOnBackspace = (editor, {
  options: {
    query
  }
}) => {
  const {
    deleteBackward: deleteBackward2
  } = editor;
  editor.deleteBackward = (unit) => {
    const {
      selection
    } = editor;
    if (unit === "character" && isCollapsed(selection)) {
      const pointBefore = getPointBefore(editor, selection, {
        unit
      });
      if (pointBefore) {
        const [prevCell] = getNodeEntries(editor, {
          match: (node) => queryNode([node, pointBefore.path], query),
          at: pointBefore
        });
        if (!!prevCell && pointBefore) {
          select(editor, pointBefore);
        } else {
          deleteBackward2(unit);
        }
      } else {
        deleteBackward2(unit);
      }
    } else {
      deleteBackward2(unit);
    }
  };
  return editor;
};
var KEY_SELECT_ON_BACKSPACE = "selectOnBackspace";
var createSelectOnBackspacePlugin = createPluginFactory({
  key: KEY_SELECT_ON_BACKSPACE,
  withOverrides: withSelectOnBackspace
});

// node_modules/@udecode/plate-table/dist/index.es.js
var getEmptyCellNode = (editor, {
  header,
  newCellChildren = [{
    type: getPluginType(editor, ELEMENT_DEFAULT),
    children: [{
      text: ""
    }]
  }]
}) => {
  return {
    type: header ? getPluginType(editor, ELEMENT_TH) : getPluginType(editor, ELEMENT_TD),
    children: newCellChildren
  };
};
var getEmptyRowNode = (editor, {
  colCount,
  ...options
} = {}) => {
  return {
    type: getPluginType(editor, ELEMENT_TR),
    children: Array(colCount).fill(colCount).map(() => getEmptyCellNode(editor, options))
  };
};
var getEmptyTableNode = (editor, {
  header,
  rowCount = 0,
  colCount,
  newCellChildren
} = {}) => {
  const rows = Array(rowCount).fill(rowCount).map(() => getEmptyRowNode(editor, {
    header,
    colCount,
    newCellChildren
  }));
  return {
    type: getPluginType(editor, ELEMENT_TABLE),
    children: rows
  };
};
var getCellTypes = (editor) => getPluginTypes(editor, [ELEMENT_TD, ELEMENT_TH]);
var insertTableColumn = (editor, {
  disableSelect,
  fromCell,
  header
} = {}) => {
  const cellEntry = fromCell ? findNode(editor, {
    at: fromCell,
    match: {
      type: getCellTypes(editor)
    }
  }) : getBlockAbove(editor, {
    match: {
      type: getCellTypes(editor)
    }
  });
  if (!cellEntry)
    return;
  const [, cellPath] = cellEntry;
  const tableEntry = getBlockAbove(editor, {
    match: {
      type: getPluginType(editor, ELEMENT_TABLE)
    },
    at: cellPath
  });
  if (!tableEntry)
    return;
  const [tableNode] = tableEntry;
  const nextCellPath = Path.next(cellPath);
  const currentRowIndex = cellPath[cellPath.length - 2];
  const {
    newCellChildren
  } = getPluginOptions(editor, ELEMENT_TABLE);
  withoutNormalizing(editor, () => {
    tableNode.children.forEach((row, rowIndex) => {
      const insertCellPath = [...nextCellPath];
      insertCellPath[cellPath.length - 2] = rowIndex;
      const isHeaderRow = header === void 0 ? row.children[0].type === getPluginType(editor, ELEMENT_TH) : header;
      insertElements(editor, getEmptyCellNode(editor, {
        header: isHeaderRow,
        newCellChildren
      }), {
        at: insertCellPath,
        select: !disableSelect && rowIndex === currentRowIndex
      });
    });
  });
};
var insertTableRow = (editor, {
  header,
  fromRow,
  disableSelect
} = {}) => {
  const trEntry = fromRow ? findNode(editor, {
    at: fromRow,
    match: {
      type: getPluginType(editor, ELEMENT_TR)
    }
  }) : getBlockAbove(editor, {
    match: {
      type: getPluginType(editor, ELEMENT_TR)
    }
  });
  if (!trEntry)
    return;
  const [trNode, trPath] = trEntry;
  const tableEntry = getBlockAbove(editor, {
    match: {
      type: getPluginType(editor, ELEMENT_TABLE)
    },
    at: trPath
  });
  if (!tableEntry)
    return;
  const {
    newCellChildren
  } = getPluginOptions(editor, ELEMENT_TABLE);
  withoutNormalizing(editor, () => {
    insertElements(editor, getEmptyRowNode(editor, {
      header,
      colCount: trNode.children.length,
      newCellChildren
    }), {
      at: Path.next(trPath)
    });
  });
  if (!disableSelect) {
    const cellEntry = getBlockAbove(editor, {
      match: {
        type: getCellTypes(editor)
      }
    });
    if (!cellEntry)
      return;
    const [, nextCellPath] = cellEntry;
    nextCellPath[nextCellPath.length - 2] += 1;
    select(editor, nextCellPath);
  }
};
var getTableGridByRange = (editor, {
  at,
  format: format3 = "table"
}) => {
  const startCellPath = at.anchor.path;
  const endCellPath = at.focus.path;
  const _startRowIndex = startCellPath[startCellPath.length - 2];
  const _endRowIndex = endCellPath[endCellPath.length - 2];
  const _startColIndex = startCellPath[startCellPath.length - 1];
  const _endColIndex = endCellPath[endCellPath.length - 1];
  const startRowIndex = Math.min(_startRowIndex, _endRowIndex);
  const endRowIndex = Math.max(_startRowIndex, _endRowIndex);
  const startColIndex = Math.min(_startColIndex, _endColIndex);
  const endColIndex = Math.max(_startColIndex, _endColIndex);
  const tablePath = startCellPath.slice(0, -2);
  const relativeRowIndex = endRowIndex - startRowIndex;
  const relativeColIndex = endColIndex - startColIndex;
  const table = getEmptyTableNode(editor, {
    rowCount: relativeRowIndex + 1,
    colCount: relativeColIndex + 1,
    newCellChildren: []
  });
  let rowIndex = startRowIndex;
  let colIndex = startColIndex;
  const cellEntries = [];
  while (true) {
    const cellPath = tablePath.concat([rowIndex, colIndex]);
    const cell = getNode(editor, cellPath);
    if (!cell)
      break;
    const rows = table.children[rowIndex - startRowIndex].children;
    rows[colIndex - startColIndex] = cell;
    cellEntries.push([cell, cellPath]);
    if (colIndex + 1 <= endColIndex) {
      colIndex += 1;
    } else if (rowIndex + 1 <= endRowIndex) {
      colIndex = startColIndex;
      rowIndex += 1;
    } else {
      break;
    }
  }
  if (format3 === "cell") {
    return cellEntries;
  }
  return [[table, tablePath]];
};
var getTableGridAbove = (editor, {
  format: format3 = "table",
  ...options
} = {}) => {
  const edges = getEdgeBlocksAbove(editor, {
    match: {
      type: getCellTypes(editor)
    },
    ...options
  });
  if (edges) {
    const [start3, end2] = edges;
    if (!Path.equals(start3[1], end2[1])) {
      return getTableGridByRange(editor, {
        at: {
          anchor: {
            path: start3[1],
            offset: 0
          },
          focus: {
            path: end2[1],
            offset: 0
          }
        },
        format: format3
      });
    }
    if (format3 === "table") {
      const table = getEmptyTableNode(editor, {
        rowCount: 1
      });
      table.children[0].children = [start3[0]];
      return [[table, start3[1].slice(0, -2)]];
    }
    return [start3];
  }
  return [];
};
var moveSelectionFromCell = (editor, {
  reverse,
  edge
} = {}) => {
  if (edge) {
    const cellEntries = getTableGridAbove(editor, {
      format: "cell"
    });
    if (cellEntries.length > 0) {
      const [, firstCellPath] = cellEntries[0];
      const [, lastCellPath] = cellEntries[cellEntries.length - 1];
      const anchorPath = [...firstCellPath];
      const focusPath = [...lastCellPath];
      if (edge === "bottom") {
        focusPath[focusPath.length - 2] += 1;
      } else if (edge === "top") {
        anchorPath[anchorPath.length - 2] -= 1;
      } else if (edge === "right") {
        focusPath[focusPath.length - 1] += 1;
      } else if (edge === "left") {
        anchorPath[anchorPath.length - 1] -= 1;
      }
      if (hasNode(editor, anchorPath) && hasNode(editor, focusPath)) {
        select(editor, {
          anchor: getStartPoint(editor, anchorPath),
          focus: getStartPoint(editor, focusPath)
        });
      }
      return true;
    }
    return;
  }
  const cellEntry = getBlockAbove(editor, {
    match: {
      type: getCellTypes(editor)
    }
  });
  if (cellEntry) {
    const [, cellPath] = cellEntry;
    const nextCellPath = [...cellPath];
    const offset5 = reverse ? -1 : 1;
    nextCellPath[nextCellPath.length - 2] += offset5;
    if (hasNode(editor, nextCellPath)) {
      select(editor, getStartPoint(editor, nextCellPath));
    } else {
      const tablePath = cellPath.slice(0, -2);
      if (reverse) {
        withoutNormalizing(editor, () => {
          select(editor, getStartPoint(editor, tablePath));
          moveSelection(editor, {
            reverse: true
          });
        });
      } else {
        withoutNormalizing(editor, () => {
          select(editor, getEndPoint(editor, tablePath));
          moveSelection(editor);
        });
      }
    }
    return true;
  }
};
var commonjsGlobal4 = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function unwrapExports11(x7) {
  return x7 && x7.__esModule && Object.prototype.hasOwnProperty.call(x7, "default") ? x7["default"] : x7;
}
function createCommonjsModule13(fn2, module2) {
  return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
}
var lib11 = createCommonjsModule13(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var IS_MAC = () => typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
  var MODIFIERS = {
    alt: "altKey",
    control: "ctrlKey",
    meta: "metaKey",
    shift: "shiftKey"
  };
  var ALIASES = () => ({
    add: "+",
    break: "pause",
    cmd: "meta",
    command: "meta",
    ctl: "control",
    ctrl: "control",
    del: "delete",
    down: "arrowdown",
    esc: "escape",
    ins: "insert",
    left: "arrowleft",
    mod: IS_MAC() ? "meta" : "control",
    opt: "alt",
    option: "alt",
    return: "enter",
    right: "arrowright",
    space: " ",
    spacebar: " ",
    up: "arrowup",
    win: "meta",
    windows: "meta"
  });
  var CODES = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    control: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    " ": 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    insert: 45,
    delete: 46,
    meta: 91,
    numlock: 144,
    scrolllock: 145,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
  };
  for (var f16 = 1; f16 < 20; f16++) {
    CODES["f" + f16] = 111 + f16;
  }
  function isHotkey14(hotkey, options, event) {
    if (options && !("byKey" in options)) {
      event = options;
      options = null;
    }
    if (!Array.isArray(hotkey)) {
      hotkey = [hotkey];
    }
    var array2 = hotkey.map(function(string2) {
      return parseHotkey(string2, options);
    });
    var check = function check2(e9) {
      return array2.some(function(object2) {
        return compareHotkey(object2, e9);
      });
    };
    var ret = event == null ? check : check(event);
    return ret;
  }
  function isCodeHotkey(hotkey, event) {
    return isHotkey14(hotkey, event);
  }
  function isKeyHotkey2(hotkey, event) {
    return isHotkey14(hotkey, { byKey: true }, event);
  }
  function parseHotkey(hotkey, options) {
    var byKey = options && options.byKey;
    var ret = {};
    hotkey = hotkey.replace("++", "+add");
    var values3 = hotkey.split("+");
    var length = values3.length;
    for (var k3 in MODIFIERS) {
      ret[MODIFIERS[k3]] = false;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = void 0;
    try {
      for (var _iterator = values3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var value = _step.value;
        var optional = value.endsWith("?") && value.length > 1;
        if (optional) {
          value = value.slice(0, -1);
        }
        var name2 = toKeyName(value);
        var modifier = MODIFIERS[name2];
        if (length === 1 || !modifier) {
          if (byKey) {
            ret.key = name2;
          } else {
            ret.which = toKeyCode(value);
          }
        }
        if (modifier) {
          ret[modifier] = optional ? null : true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return ret;
  }
  function compareHotkey(object2, event) {
    for (var key in object2) {
      var expected = object2[key];
      var actual = void 0;
      if (expected == null) {
        continue;
      }
      if (key === "key" && event.key != null) {
        actual = event.key.toLowerCase();
      } else if (key === "which") {
        actual = expected === 91 && event.which === 93 ? 91 : event.which;
      } else {
        actual = event[key];
      }
      if (actual == null && expected === false) {
        continue;
      }
      if (actual !== expected) {
        return false;
      }
    }
    return true;
  }
  function toKeyCode(name2) {
    name2 = toKeyName(name2);
    var code = CODES[name2] || name2.toUpperCase().charCodeAt(0);
    return code;
  }
  function toKeyName(name2) {
    name2 = name2.toLowerCase();
    name2 = ALIASES()[name2] || name2;
    return name2;
  }
  exports2.default = isHotkey14;
  exports2.isHotkey = isHotkey14;
  exports2.isCodeHotkey = isCodeHotkey;
  exports2.isKeyHotkey = isKeyHotkey2;
  exports2.parseHotkey = parseHotkey;
  exports2.compareHotkey = compareHotkey;
  exports2.toKeyCode = toKeyCode;
  exports2.toKeyName = toKeyName;
});
var isHotkey11 = unwrapExports11(lib11);
lib11.isHotkey;
lib11.isCodeHotkey;
lib11.isKeyHotkey;
lib11.parseHotkey;
lib11.compareHotkey;
lib11.toKeyCode;
lib11.toKeyName;
var getCellInNextTableRow = (editor, currentRowPath) => {
  try {
    var _nextRowNode$children;
    const nextRow = getNodeEntry(editor, Path.next(currentRowPath));
    const [nextRowNode, nextRowPath] = nextRow;
    const nextCell = nextRowNode === null || nextRowNode === void 0 ? void 0 : (_nextRowNode$children = nextRowNode.children) === null || _nextRowNode$children === void 0 ? void 0 : _nextRowNode$children[0];
    const nextCellPath = nextRowPath.concat(0);
    if (nextCell && nextCellPath) {
      return getNodeEntry(editor, nextCellPath);
    }
  } catch (err) {
  }
};
var getCellInPreviousTableRow = (editor, currentRowPath) => {
  try {
    var _previousRowNode$chil;
    const previousRow = getNodeEntry(editor, Path.previous(currentRowPath));
    const [previousRowNode, previousRowPath] = previousRow;
    const previousCell = previousRowNode === null || previousRowNode === void 0 ? void 0 : (_previousRowNode$chil = previousRowNode.children) === null || _previousRowNode$chil === void 0 ? void 0 : _previousRowNode$chil[previousRowNode.children.length - 1];
    const previousCellPath = previousRowPath.concat(previousRowNode.children.length - 1);
    if (previousCell && previousCellPath) {
      return getNodeEntry(editor, previousCellPath);
    }
  } catch (err) {
  }
};
var getNextTableCell = (editor, currentCell, currentPath, currentRow) => {
  try {
    return getNodeEntry(editor, Path.next(currentPath));
  } catch (err) {
    const [, currentRowPath] = currentRow;
    return getCellInNextTableRow(editor, currentRowPath);
  }
};
var getPreviousTableCell = (editor, currentCell, currentPath, currentRow) => {
  try {
    return getNodeEntry(editor, Path.previous(currentPath));
  } catch (err) {
    const [, currentRowPath] = currentRow;
    return getCellInPreviousTableRow(editor, currentRowPath);
  }
};
var getTableCellEntry = (editor, {
  at = editor.selection
} = {}) => {
  if (at && someNode(editor, {
    at,
    match: {
      type: [getPluginType(editor, ELEMENT_TD), getPluginType(editor, ELEMENT_TH)]
    }
  })) {
    const selectionParent = getParentNode(editor, at);
    if (!selectionParent)
      return;
    const [, paragraphPath] = selectionParent;
    const tableCell = getAboveNode(editor, {
      at,
      match: {
        type: [getPluginType(editor, ELEMENT_TD), getPluginType(editor, ELEMENT_TH)]
      }
    }) || getParentNode(editor, paragraphPath);
    if (!tableCell)
      return;
    const [tableCellNode, tableCellPath] = tableCell;
    if (tableCellNode.type !== getPluginType(editor, ELEMENT_TD) && tableCellNode.type !== getPluginType(editor, ELEMENT_TH))
      return;
    const tableRow = getParentNode(editor, tableCellPath);
    if (!tableRow)
      return;
    const [tableRowNode, tableRowPath] = tableRow;
    if (tableRowNode.type !== getPluginType(editor, ELEMENT_TR))
      return;
    const tableElement = getParentNode(editor, tableRowPath);
    if (!tableElement)
      return;
    return {
      tableElement,
      tableRow,
      tableCell
    };
  }
};
var onKeyDownTable = (editor, {
  type
}) => (e9) => {
  const isShiftUp = isHotkey11("shift+up", e9);
  if (isHotkey11("up", e9) || isShiftUp) {
    if (moveSelectionFromCell(editor, {
      reverse: true,
      edge: isShiftUp ? "top" : void 0
    })) {
      e9.preventDefault();
      e9.stopPropagation();
    }
  }
  const isShiftDown = isHotkey11("shift+down", e9);
  if (isHotkey11("down", e9) || isShiftDown) {
    if (moveSelectionFromCell(editor, {
      edge: isShiftDown ? "bottom" : void 0
    })) {
      e9.preventDefault();
      e9.stopPropagation();
    }
  }
  if (isHotkey11("shift+left", e9)) {
    if (moveSelectionFromCell(editor, {
      edge: "left"
    })) {
      e9.preventDefault();
      e9.stopPropagation();
    }
  }
  if (isHotkey11("shift+right", e9)) {
    if (moveSelectionFromCell(editor, {
      edge: "right"
    })) {
      e9.preventDefault();
      e9.stopPropagation();
    }
  }
  const isTab = Hotkeys2.isTab(editor, e9);
  const isUntab = Hotkeys2.isUntab(editor, e9);
  if (isTab || isUntab) {
    const res = getTableCellEntry(editor, {});
    if (!res)
      return;
    const {
      tableRow,
      tableCell
    } = res;
    const [, tableCellPath] = tableCell;
    if (isUntab) {
      const previousCell = getPreviousTableCell(editor, tableCell, tableCellPath, tableRow);
      if (previousCell) {
        const [, previousCellPath] = previousCell;
        select(editor, previousCellPath);
        e9.preventDefault();
        e9.stopPropagation();
      }
    } else if (isTab) {
      const nextCell = getNextTableCell(editor, tableCell, tableCellPath, tableRow);
      if (nextCell) {
        const [, nextCellPath] = nextCell;
        select(editor, nextCellPath);
        e9.preventDefault();
        e9.stopPropagation();
      }
    }
  }
  if (isHotkey11("mod+a", e9)) {
    const res = getAboveNode(editor, {
      match: {
        type
      }
    });
    if (!res)
      return;
    const [, tablePath] = res;
    select(editor, tablePath);
    e9.preventDefault();
    e9.stopPropagation();
  }
};
var preventDeleteTableCell = (editor, {
  unit,
  reverse
}) => {
  const {
    selection
  } = editor;
  const getPoint2 = !reverse ? getStartPoint : getEndPoint;
  const getNextPoint = !reverse ? getPointBefore : getPointAfter;
  if (isCollapsed(selection)) {
    const cellEntry = getBlockAbove(editor, {
      match: {
        type: getCellTypes(editor)
      }
    });
    if (cellEntry) {
      const [, cellPath] = cellEntry;
      const start3 = getPoint2(editor, cellPath);
      if (selection && Point.equals(selection.anchor, start3)) {
        return true;
      }
    } else {
      const nextPoint = getNextPoint(editor, selection, {
        unit
      });
      const nextCellEntry = getBlockAbove(editor, {
        match: {
          type: getCellTypes(editor)
        },
        at: nextPoint
      });
      if (nextCellEntry) {
        moveSelection(editor, {
          reverse: !reverse
        });
        return true;
      }
    }
  }
};
var withDeleteTable = (editor) => {
  const {
    deleteBackward: deleteBackward2,
    deleteForward,
    deleteFragment
  } = editor;
  editor.deleteBackward = (unit) => {
    if (preventDeleteTableCell(editor, {
      unit
    }))
      return;
    return deleteBackward2(unit);
  };
  editor.deleteForward = (unit) => {
    if (preventDeleteTableCell(editor, {
      unit,
      reverse: true
    }))
      return;
    return deleteForward(unit);
  };
  editor.deleteFragment = () => {
    const cellEntries = getTableGridAbove(editor, {
      format: "cell"
    });
    if (cellEntries.length > 1) {
      withoutNormalizing(editor, () => {
        cellEntries.forEach(([, cellPath]) => {
          for (const [, childPath] of getNodeChildren(editor, cellPath, {
            reverse: true
          })) {
            removeNodes(editor, {
              at: childPath
            });
          }
        });
      });
      select(editor, cellEntries[0][1]);
      return;
    }
    deleteFragment();
  };
  return editor;
};
var withGetFragmentTable = (editor) => {
  const {
    getFragment
  } = editor;
  editor.getFragment = () => {
    let fragment = getFragment();
    fragment = fragment.map((node) => {
      if (node.type === getPluginType(editor, ELEMENT_TABLE)) {
        const subTable = getTableGridAbove(editor);
        if (subTable.length) {
          return subTable[0][0];
        }
      }
      return node;
    });
    return fragment;
  };
  return editor;
};
function listCacheClear4() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear4 = listCacheClear4;
function eq4(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_14 = eq4;
function assocIndexOf4(array2, key) {
  var length = array2.length;
  while (length--) {
    if (eq_14(array2[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf4 = assocIndexOf4;
var arrayProto4 = Array.prototype;
var splice4 = arrayProto4.splice;
function listCacheDelete4(key) {
  var data = this.__data__, index2 = _assocIndexOf4(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice4.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete4 = listCacheDelete4;
function listCacheGet4(key) {
  var data = this.__data__, index2 = _assocIndexOf4(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var _listCacheGet4 = listCacheGet4;
function listCacheHas4(key) {
  return _assocIndexOf4(this.__data__, key) > -1;
}
var _listCacheHas4 = listCacheHas4;
function listCacheSet4(key, value) {
  var data = this.__data__, index2 = _assocIndexOf4(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var _listCacheSet4 = listCacheSet4;
function ListCache4(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache4.prototype.clear = _listCacheClear4;
ListCache4.prototype["delete"] = _listCacheDelete4;
ListCache4.prototype.get = _listCacheGet4;
ListCache4.prototype.has = _listCacheHas4;
ListCache4.prototype.set = _listCacheSet4;
var _ListCache4 = ListCache4;
function stackClear4() {
  this.__data__ = new _ListCache4();
  this.size = 0;
}
var _stackClear4 = stackClear4;
function stackDelete4(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete4 = stackDelete4;
function stackGet4(key) {
  return this.__data__.get(key);
}
var _stackGet4 = stackGet4;
function stackHas4(key) {
  return this.__data__.has(key);
}
var _stackHas4 = stackHas4;
var freeGlobal4 = typeof commonjsGlobal4 == "object" && commonjsGlobal4 && commonjsGlobal4.Object === Object && commonjsGlobal4;
var _freeGlobal4 = freeGlobal4;
var freeSelf4 = typeof self == "object" && self && self.Object === Object && self;
var root4 = _freeGlobal4 || freeSelf4 || Function("return this")();
var _root4 = root4;
var Symbol$12 = _root4.Symbol;
var _Symbol4 = Symbol$12;
var objectProto$c3 = Object.prototype;
var hasOwnProperty$93 = objectProto$c3.hasOwnProperty;
var nativeObjectToString$14 = objectProto$c3.toString;
var symToStringTag$14 = _Symbol4 ? _Symbol4.toStringTag : void 0;
function getRawTag4(value) {
  var isOwn = hasOwnProperty$93.call(value, symToStringTag$14), tag = value[symToStringTag$14];
  try {
    value[symToStringTag$14] = void 0;
    var unmasked = true;
  } catch (e9) {
  }
  var result = nativeObjectToString$14.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$14] = tag;
    } else {
      delete value[symToStringTag$14];
    }
  }
  return result;
}
var _getRawTag4 = getRawTag4;
var objectProto$b4 = Object.prototype;
var nativeObjectToString4 = objectProto$b4.toString;
function objectToString4(value) {
  return nativeObjectToString4.call(value);
}
var _objectToString4 = objectToString4;
var nullTag4 = "[object Null]";
var undefinedTag4 = "[object Undefined]";
var symToStringTag4 = _Symbol4 ? _Symbol4.toStringTag : void 0;
function baseGetTag4(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag4 : nullTag4;
  }
  return symToStringTag4 && symToStringTag4 in Object(value) ? _getRawTag4(value) : _objectToString4(value);
}
var _baseGetTag4 = baseGetTag4;
function isObject5(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_14 = isObject5;
var asyncTag4 = "[object AsyncFunction]";
var funcTag$23 = "[object Function]";
var genTag$13 = "[object GeneratorFunction]";
var proxyTag4 = "[object Proxy]";
function isFunction4(value) {
  if (!isObject_14(value)) {
    return false;
  }
  var tag = _baseGetTag4(value);
  return tag == funcTag$23 || tag == genTag$13 || tag == asyncTag4 || tag == proxyTag4;
}
var isFunction_14 = isFunction4;
var coreJsData4 = _root4["__core-js_shared__"];
var _coreJsData4 = coreJsData4;
var maskSrcKey4 = function() {
  var uid2 = /[^.]+$/.exec(_coreJsData4 && _coreJsData4.keys && _coreJsData4.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked4(func) {
  return !!maskSrcKey4 && maskSrcKey4 in func;
}
var _isMasked4 = isMasked4;
var funcProto$14 = Function.prototype;
var funcToString$14 = funcProto$14.toString;
function toSource4(func) {
  if (func != null) {
    try {
      return funcToString$14.call(func);
    } catch (e9) {
    }
    try {
      return func + "";
    } catch (e9) {
    }
  }
  return "";
}
var _toSource4 = toSource4;
var reRegExpChar4 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor4 = /^\[object .+?Constructor\]$/;
var funcProto4 = Function.prototype;
var objectProto$a4 = Object.prototype;
var funcToString4 = funcProto4.toString;
var hasOwnProperty$84 = objectProto$a4.hasOwnProperty;
var reIsNative4 = RegExp(
  "^" + funcToString4.call(hasOwnProperty$84).replace(reRegExpChar4, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative4(value) {
  if (!isObject_14(value) || _isMasked4(value)) {
    return false;
  }
  var pattern = isFunction_14(value) ? reIsNative4 : reIsHostCtor4;
  return pattern.test(_toSource4(value));
}
var _baseIsNative4 = baseIsNative4;
function getValue4(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
var _getValue4 = getValue4;
function getNative4(object2, key) {
  var value = _getValue4(object2, key);
  return _baseIsNative4(value) ? value : void 0;
}
var _getNative4 = getNative4;
var Map5 = _getNative4(_root4, "Map");
var _Map4 = Map5;
var nativeCreate4 = _getNative4(Object, "create");
var _nativeCreate4 = nativeCreate4;
function hashClear4() {
  this.__data__ = _nativeCreate4 ? _nativeCreate4(null) : {};
  this.size = 0;
}
var _hashClear4 = hashClear4;
function hashDelete4(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete4 = hashDelete4;
var HASH_UNDEFINED$14 = "__lodash_hash_undefined__";
var objectProto$94 = Object.prototype;
var hasOwnProperty$74 = objectProto$94.hasOwnProperty;
function hashGet4(key) {
  var data = this.__data__;
  if (_nativeCreate4) {
    var result = data[key];
    return result === HASH_UNDEFINED$14 ? void 0 : result;
  }
  return hasOwnProperty$74.call(data, key) ? data[key] : void 0;
}
var _hashGet4 = hashGet4;
var objectProto$84 = Object.prototype;
var hasOwnProperty$64 = objectProto$84.hasOwnProperty;
function hashHas4(key) {
  var data = this.__data__;
  return _nativeCreate4 ? data[key] !== void 0 : hasOwnProperty$64.call(data, key);
}
var _hashHas4 = hashHas4;
var HASH_UNDEFINED4 = "__lodash_hash_undefined__";
function hashSet4(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = _nativeCreate4 && value === void 0 ? HASH_UNDEFINED4 : value;
  return this;
}
var _hashSet4 = hashSet4;
function Hash4(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash4.prototype.clear = _hashClear4;
Hash4.prototype["delete"] = _hashDelete4;
Hash4.prototype.get = _hashGet4;
Hash4.prototype.has = _hashHas4;
Hash4.prototype.set = _hashSet4;
var _Hash4 = Hash4;
function mapCacheClear4() {
  this.size = 0;
  this.__data__ = {
    "hash": new _Hash4(),
    "map": new (_Map4 || _ListCache4)(),
    "string": new _Hash4()
  };
}
var _mapCacheClear4 = mapCacheClear4;
function isKeyable4(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable4 = isKeyable4;
function getMapData4(map5, key) {
  var data = map5.__data__;
  return _isKeyable4(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData4 = getMapData4;
function mapCacheDelete4(key) {
  var result = _getMapData4(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete4 = mapCacheDelete4;
function mapCacheGet4(key) {
  return _getMapData4(this, key).get(key);
}
var _mapCacheGet4 = mapCacheGet4;
function mapCacheHas4(key) {
  return _getMapData4(this, key).has(key);
}
var _mapCacheHas4 = mapCacheHas4;
function mapCacheSet4(key, value) {
  var data = _getMapData4(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var _mapCacheSet4 = mapCacheSet4;
function MapCache4(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache4.prototype.clear = _mapCacheClear4;
MapCache4.prototype["delete"] = _mapCacheDelete4;
MapCache4.prototype.get = _mapCacheGet4;
MapCache4.prototype.has = _mapCacheHas4;
MapCache4.prototype.set = _mapCacheSet4;
var _MapCache4 = MapCache4;
var LARGE_ARRAY_SIZE4 = 200;
function stackSet4(key, value) {
  var data = this.__data__;
  if (data instanceof _ListCache4) {
    var pairs = data.__data__;
    if (!_Map4 || pairs.length < LARGE_ARRAY_SIZE4 - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new _MapCache4(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet4 = stackSet4;
function Stack4(entries) {
  var data = this.__data__ = new _ListCache4(entries);
  this.size = data.size;
}
Stack4.prototype.clear = _stackClear4;
Stack4.prototype["delete"] = _stackDelete4;
Stack4.prototype.get = _stackGet4;
Stack4.prototype.has = _stackHas4;
Stack4.prototype.set = _stackSet4;
var _Stack3 = Stack4;
function arrayEach3(array2, iteratee) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (iteratee(array2[index2], index2, array2) === false) {
      break;
    }
  }
  return array2;
}
var _arrayEach3 = arrayEach3;
var defineProperty4 = function() {
  try {
    var func = _getNative4(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e9) {
  }
}();
var _defineProperty5 = defineProperty4;
function baseAssignValue3(object2, key, value) {
  if (key == "__proto__" && _defineProperty5) {
    _defineProperty5(object2, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object2[key] = value;
  }
}
var _baseAssignValue3 = baseAssignValue3;
var objectProto$74 = Object.prototype;
var hasOwnProperty$54 = objectProto$74.hasOwnProperty;
function assignValue3(object2, key, value) {
  var objValue = object2[key];
  if (!(hasOwnProperty$54.call(object2, key) && eq_14(objValue, value)) || value === void 0 && !(key in object2)) {
    _baseAssignValue3(object2, key, value);
  }
}
var _assignValue3 = assignValue3;
function copyObject3(source, props, object2, customizer) {
  var isNew = !object2;
  object2 || (object2 = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      _baseAssignValue3(object2, key, newValue);
    } else {
      _assignValue3(object2, key, newValue);
    }
  }
  return object2;
}
var _copyObject3 = copyObject3;
function baseTimes3(n12, iteratee) {
  var index2 = -1, result = Array(n12);
  while (++index2 < n12) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var _baseTimes3 = baseTimes3;
function isObjectLike4(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_14 = isObjectLike4;
var argsTag$24 = "[object Arguments]";
function baseIsArguments4(value) {
  return isObjectLike_14(value) && _baseGetTag4(value) == argsTag$24;
}
var _baseIsArguments4 = baseIsArguments4;
var objectProto$64 = Object.prototype;
var hasOwnProperty$44 = objectProto$64.hasOwnProperty;
var propertyIsEnumerable$14 = objectProto$64.propertyIsEnumerable;
var isArguments4 = _baseIsArguments4(function() {
  return arguments;
}()) ? _baseIsArguments4 : function(value) {
  return isObjectLike_14(value) && hasOwnProperty$44.call(value, "callee") && !propertyIsEnumerable$14.call(value, "callee");
};
var isArguments_13 = isArguments4;
var isArray7 = Array.isArray;
var isArray_16 = isArray7;
function stubFalse4() {
  return false;
}
var stubFalse_14 = stubFalse4;
var isBuffer_14 = createCommonjsModule13(function(module2, exports2) {
  var freeExports4 = exports2 && !exports2.nodeType && exports2;
  var freeModule4 = freeExports4 && true && module2 && !module2.nodeType && module2;
  var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
  var Buffer3 = moduleExports4 ? _root4.Buffer : void 0;
  var nativeIsBuffer2 = Buffer3 ? Buffer3.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer2 || stubFalse_14;
  module2.exports = isBuffer2;
});
var MAX_SAFE_INTEGER$13 = 9007199254740991;
var reIsUint3 = /^(?:0|[1-9]\d*)$/;
function isIndex3(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$13 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint3.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex3 = isIndex3;
var MAX_SAFE_INTEGER4 = 9007199254740991;
function isLength4(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER4;
}
var isLength_14 = isLength4;
var argsTag$14 = "[object Arguments]";
var arrayTag$14 = "[object Array]";
var boolTag$23 = "[object Boolean]";
var dateTag$23 = "[object Date]";
var errorTag$14 = "[object Error]";
var funcTag$14 = "[object Function]";
var mapTag$43 = "[object Map]";
var numberTag$23 = "[object Number]";
var objectTag$24 = "[object Object]";
var regexpTag$23 = "[object RegExp]";
var setTag$43 = "[object Set]";
var stringTag$23 = "[object String]";
var weakMapTag$23 = "[object WeakMap]";
var arrayBufferTag$23 = "[object ArrayBuffer]";
var dataViewTag$33 = "[object DataView]";
var float32Tag$23 = "[object Float32Array]";
var float64Tag$23 = "[object Float64Array]";
var int8Tag$23 = "[object Int8Array]";
var int16Tag$23 = "[object Int16Array]";
var int32Tag$23 = "[object Int32Array]";
var uint8Tag$23 = "[object Uint8Array]";
var uint8ClampedTag$23 = "[object Uint8ClampedArray]";
var uint16Tag$23 = "[object Uint16Array]";
var uint32Tag$23 = "[object Uint32Array]";
var typedArrayTags4 = {};
typedArrayTags4[float32Tag$23] = typedArrayTags4[float64Tag$23] = typedArrayTags4[int8Tag$23] = typedArrayTags4[int16Tag$23] = typedArrayTags4[int32Tag$23] = typedArrayTags4[uint8Tag$23] = typedArrayTags4[uint8ClampedTag$23] = typedArrayTags4[uint16Tag$23] = typedArrayTags4[uint32Tag$23] = true;
typedArrayTags4[argsTag$14] = typedArrayTags4[arrayTag$14] = typedArrayTags4[arrayBufferTag$23] = typedArrayTags4[boolTag$23] = typedArrayTags4[dataViewTag$33] = typedArrayTags4[dateTag$23] = typedArrayTags4[errorTag$14] = typedArrayTags4[funcTag$14] = typedArrayTags4[mapTag$43] = typedArrayTags4[numberTag$23] = typedArrayTags4[objectTag$24] = typedArrayTags4[regexpTag$23] = typedArrayTags4[setTag$43] = typedArrayTags4[stringTag$23] = typedArrayTags4[weakMapTag$23] = false;
function baseIsTypedArray4(value) {
  return isObjectLike_14(value) && isLength_14(value.length) && !!typedArrayTags4[_baseGetTag4(value)];
}
var _baseIsTypedArray4 = baseIsTypedArray4;
function baseUnary4(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary4 = baseUnary4;
var _nodeUtil4 = createCommonjsModule13(function(module2, exports2) {
  var freeExports4 = exports2 && !exports2.nodeType && exports2;
  var freeModule4 = freeExports4 && true && module2 && !module2.nodeType && module2;
  var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
  var freeProcess2 = moduleExports4 && _freeGlobal4.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule4 && freeModule4.require && freeModule4.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess2 && freeProcess2.binding && freeProcess2.binding("util");
    } catch (e9) {
    }
  }();
  module2.exports = nodeUtil2;
});
var nodeIsTypedArray4 = _nodeUtil4 && _nodeUtil4.isTypedArray;
var isTypedArray4 = nodeIsTypedArray4 ? _baseUnary4(nodeIsTypedArray4) : _baseIsTypedArray4;
var isTypedArray_13 = isTypedArray4;
var objectProto$54 = Object.prototype;
var hasOwnProperty$34 = objectProto$54.hasOwnProperty;
function arrayLikeKeys3(value, inherited) {
  var isArr = isArray_16(value), isArg = !isArr && isArguments_13(value), isBuff = !isArr && !isArg && isBuffer_14(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray_13(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? _baseTimes3(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$34.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    _isIndex3(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys3 = arrayLikeKeys3;
var objectProto$44 = Object.prototype;
function isPrototype3(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto$44;
  return value === proto2;
}
var _isPrototype3 = isPrototype3;
function overArg4(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg4 = overArg4;
var nativeKeys4 = _overArg4(Object.keys, Object);
var _nativeKeys3 = nativeKeys4;
var objectProto$34 = Object.prototype;
var hasOwnProperty$24 = objectProto$34.hasOwnProperty;
function baseKeys3(object2) {
  if (!_isPrototype3(object2)) {
    return _nativeKeys3(object2);
  }
  var result = [];
  for (var key in Object(object2)) {
    if (hasOwnProperty$24.call(object2, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys3 = baseKeys3;
function isArrayLike3(value) {
  return value != null && isLength_14(value.length) && !isFunction_14(value);
}
var isArrayLike_13 = isArrayLike3;
function keys3(object2) {
  return isArrayLike_13(object2) ? _arrayLikeKeys3(object2) : _baseKeys3(object2);
}
var keys_13 = keys3;
function baseAssign3(object2, source) {
  return object2 && _copyObject3(source, keys_13(source), object2);
}
var _baseAssign3 = baseAssign3;
function nativeKeysIn3(object2) {
  var result = [];
  if (object2 != null) {
    for (var key in Object(object2)) {
      result.push(key);
    }
  }
  return result;
}
var _nativeKeysIn3 = nativeKeysIn3;
var objectProto$24 = Object.prototype;
var hasOwnProperty$14 = objectProto$24.hasOwnProperty;
function baseKeysIn3(object2) {
  if (!isObject_14(object2)) {
    return _nativeKeysIn3(object2);
  }
  var isProto = _isPrototype3(object2), result = [];
  for (var key in object2) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty$14.call(object2, key)))) {
      result.push(key);
    }
  }
  return result;
}
var _baseKeysIn3 = baseKeysIn3;
function keysIn3(object2) {
  return isArrayLike_13(object2) ? _arrayLikeKeys3(object2, true) : _baseKeysIn3(object2);
}
var keysIn_13 = keysIn3;
function baseAssignIn3(object2, source) {
  return object2 && _copyObject3(source, keysIn_13(source), object2);
}
var _baseAssignIn3 = baseAssignIn3;
var _cloneBuffer3 = createCommonjsModule13(function(module2, exports2) {
  var freeExports4 = exports2 && !exports2.nodeType && exports2;
  var freeModule4 = freeExports4 && true && module2 && !module2.nodeType && module2;
  var moduleExports4 = freeModule4 && freeModule4.exports === freeExports4;
  var Buffer3 = moduleExports4 ? _root4.Buffer : void 0, allocUnsafe2 = Buffer3 ? Buffer3.allocUnsafe : void 0;
  function cloneBuffer2(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe2 ? allocUnsafe2(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  module2.exports = cloneBuffer2;
});
function copyArray3(source, array2) {
  var index2 = -1, length = source.length;
  array2 || (array2 = Array(length));
  while (++index2 < length) {
    array2[index2] = source[index2];
  }
  return array2;
}
var _copyArray3 = copyArray3;
function arrayFilter3(array2, predicate) {
  var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array2[index2];
    if (predicate(value, index2, array2)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter3 = arrayFilter3;
function stubArray3() {
  return [];
}
var stubArray_13 = stubArray3;
var objectProto$14 = Object.prototype;
var propertyIsEnumerable4 = objectProto$14.propertyIsEnumerable;
var nativeGetSymbols$13 = Object.getOwnPropertySymbols;
var getSymbols3 = !nativeGetSymbols$13 ? stubArray_13 : function(object2) {
  if (object2 == null) {
    return [];
  }
  object2 = Object(object2);
  return _arrayFilter3(nativeGetSymbols$13(object2), function(symbol) {
    return propertyIsEnumerable4.call(object2, symbol);
  });
};
var _getSymbols3 = getSymbols3;
function copySymbols3(source, object2) {
  return _copyObject3(source, _getSymbols3(source), object2);
}
var _copySymbols3 = copySymbols3;
function arrayPush3(array2, values3) {
  var index2 = -1, length = values3.length, offset5 = array2.length;
  while (++index2 < length) {
    array2[offset5 + index2] = values3[index2];
  }
  return array2;
}
var _arrayPush3 = arrayPush3;
var getPrototype3 = _overArg4(Object.getPrototypeOf, Object);
var _getPrototype3 = getPrototype3;
var nativeGetSymbols3 = Object.getOwnPropertySymbols;
var getSymbolsIn3 = !nativeGetSymbols3 ? stubArray_13 : function(object2) {
  var result = [];
  while (object2) {
    _arrayPush3(result, _getSymbols3(object2));
    object2 = _getPrototype3(object2);
  }
  return result;
};
var _getSymbolsIn3 = getSymbolsIn3;
function copySymbolsIn3(source, object2) {
  return _copyObject3(source, _getSymbolsIn3(source), object2);
}
var _copySymbolsIn3 = copySymbolsIn3;
function baseGetAllKeys3(object2, keysFunc, symbolsFunc) {
  var result = keysFunc(object2);
  return isArray_16(object2) ? result : _arrayPush3(result, symbolsFunc(object2));
}
var _baseGetAllKeys3 = baseGetAllKeys3;
function getAllKeys3(object2) {
  return _baseGetAllKeys3(object2, keys_13, _getSymbols3);
}
var _getAllKeys3 = getAllKeys3;
function getAllKeysIn3(object2) {
  return _baseGetAllKeys3(object2, keysIn_13, _getSymbolsIn3);
}
var _getAllKeysIn3 = getAllKeysIn3;
var DataView4 = _getNative4(_root4, "DataView");
var _DataView4 = DataView4;
var Promise$14 = _getNative4(_root4, "Promise");
var _Promise4 = Promise$14;
var Set5 = _getNative4(_root4, "Set");
var _Set4 = Set5;
var WeakMap4 = _getNative4(_root4, "WeakMap");
var _WeakMap4 = WeakMap4;
var mapTag$33 = "[object Map]";
var objectTag$14 = "[object Object]";
var promiseTag4 = "[object Promise]";
var setTag$33 = "[object Set]";
var weakMapTag$14 = "[object WeakMap]";
var dataViewTag$24 = "[object DataView]";
var dataViewCtorString4 = _toSource4(_DataView4);
var mapCtorString4 = _toSource4(_Map4);
var promiseCtorString4 = _toSource4(_Promise4);
var setCtorString4 = _toSource4(_Set4);
var weakMapCtorString4 = _toSource4(_WeakMap4);
var getTag4 = _baseGetTag4;
if (_DataView4 && getTag4(new _DataView4(new ArrayBuffer(1))) != dataViewTag$24 || _Map4 && getTag4(new _Map4()) != mapTag$33 || _Promise4 && getTag4(_Promise4.resolve()) != promiseTag4 || _Set4 && getTag4(new _Set4()) != setTag$33 || _WeakMap4 && getTag4(new _WeakMap4()) != weakMapTag$14) {
  getTag4 = function(value) {
    var result = _baseGetTag4(value), Ctor = result == objectTag$14 ? value.constructor : void 0, ctorString = Ctor ? _toSource4(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString4:
          return dataViewTag$24;
        case mapCtorString4:
          return mapTag$33;
        case promiseCtorString4:
          return promiseTag4;
        case setCtorString4:
          return setTag$33;
        case weakMapCtorString4:
          return weakMapTag$14;
      }
    }
    return result;
  };
}
var _getTag3 = getTag4;
var objectProto4 = Object.prototype;
var hasOwnProperty4 = objectProto4.hasOwnProperty;
function initCloneArray3(array2) {
  var length = array2.length, result = new array2.constructor(length);
  if (length && typeof array2[0] == "string" && hasOwnProperty4.call(array2, "index")) {
    result.index = array2.index;
    result.input = array2.input;
  }
  return result;
}
var _initCloneArray3 = initCloneArray3;
var Uint8Array5 = _root4.Uint8Array;
var _Uint8Array3 = Uint8Array5;
function cloneArrayBuffer3(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _Uint8Array3(result).set(new _Uint8Array3(arrayBuffer));
  return result;
}
var _cloneArrayBuffer3 = cloneArrayBuffer3;
function cloneDataView3(dataView, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer3(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}
var _cloneDataView3 = cloneDataView3;
var reFlags3 = /\w*$/;
function cloneRegExp3(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags3.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}
var _cloneRegExp3 = cloneRegExp3;
var symbolProto4 = _Symbol4 ? _Symbol4.prototype : void 0;
var symbolValueOf4 = symbolProto4 ? symbolProto4.valueOf : void 0;
function cloneSymbol3(symbol) {
  return symbolValueOf4 ? Object(symbolValueOf4.call(symbol)) : {};
}
var _cloneSymbol3 = cloneSymbol3;
function cloneTypedArray3(typedArray, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer3(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var _cloneTypedArray3 = cloneTypedArray3;
var boolTag$14 = "[object Boolean]";
var dateTag$14 = "[object Date]";
var mapTag$24 = "[object Map]";
var numberTag$14 = "[object Number]";
var regexpTag$14 = "[object RegExp]";
var setTag$24 = "[object Set]";
var stringTag$14 = "[object String]";
var symbolTag$13 = "[object Symbol]";
var arrayBufferTag$14 = "[object ArrayBuffer]";
var dataViewTag$13 = "[object DataView]";
var float32Tag$13 = "[object Float32Array]";
var float64Tag$13 = "[object Float64Array]";
var int8Tag$13 = "[object Int8Array]";
var int16Tag$13 = "[object Int16Array]";
var int32Tag$13 = "[object Int32Array]";
var uint8Tag$13 = "[object Uint8Array]";
var uint8ClampedTag$13 = "[object Uint8ClampedArray]";
var uint16Tag$13 = "[object Uint16Array]";
var uint32Tag$13 = "[object Uint32Array]";
function initCloneByTag3(object2, tag, isDeep) {
  var Ctor = object2.constructor;
  switch (tag) {
    case arrayBufferTag$14:
      return _cloneArrayBuffer3(object2);
    case boolTag$14:
    case dateTag$14:
      return new Ctor(+object2);
    case dataViewTag$13:
      return _cloneDataView3(object2, isDeep);
    case float32Tag$13:
    case float64Tag$13:
    case int8Tag$13:
    case int16Tag$13:
    case int32Tag$13:
    case uint8Tag$13:
    case uint8ClampedTag$13:
    case uint16Tag$13:
    case uint32Tag$13:
      return _cloneTypedArray3(object2, isDeep);
    case mapTag$24:
      return new Ctor();
    case numberTag$14:
    case stringTag$14:
      return new Ctor(object2);
    case regexpTag$14:
      return _cloneRegExp3(object2);
    case setTag$24:
      return new Ctor();
    case symbolTag$13:
      return _cloneSymbol3(object2);
  }
}
var _initCloneByTag3 = initCloneByTag3;
var objectCreate3 = Object.create;
var baseCreate3 = function() {
  function object2() {
  }
  return function(proto2) {
    if (!isObject_14(proto2)) {
      return {};
    }
    if (objectCreate3) {
      return objectCreate3(proto2);
    }
    object2.prototype = proto2;
    var result = new object2();
    object2.prototype = void 0;
    return result;
  };
}();
var _baseCreate3 = baseCreate3;
function initCloneObject3(object2) {
  return typeof object2.constructor == "function" && !_isPrototype3(object2) ? _baseCreate3(_getPrototype3(object2)) : {};
}
var _initCloneObject3 = initCloneObject3;
var mapTag$13 = "[object Map]";
function baseIsMap3(value) {
  return isObjectLike_14(value) && _getTag3(value) == mapTag$13;
}
var _baseIsMap3 = baseIsMap3;
var nodeIsMap3 = _nodeUtil4 && _nodeUtil4.isMap;
var isMap3 = nodeIsMap3 ? _baseUnary4(nodeIsMap3) : _baseIsMap3;
var isMap_13 = isMap3;
var setTag$13 = "[object Set]";
function baseIsSet3(value) {
  return isObjectLike_14(value) && _getTag3(value) == setTag$13;
}
var _baseIsSet3 = baseIsSet3;
var nodeIsSet3 = _nodeUtil4 && _nodeUtil4.isSet;
var isSet3 = nodeIsSet3 ? _baseUnary4(nodeIsSet3) : _baseIsSet3;
var isSet_13 = isSet3;
var CLONE_DEEP_FLAG$13 = 1;
var CLONE_FLAT_FLAG3 = 2;
var CLONE_SYMBOLS_FLAG$13 = 4;
var argsTag3 = "[object Arguments]";
var arrayTag3 = "[object Array]";
var boolTag3 = "[object Boolean]";
var dateTag3 = "[object Date]";
var errorTag3 = "[object Error]";
var funcTag4 = "[object Function]";
var genTag4 = "[object GeneratorFunction]";
var mapTag4 = "[object Map]";
var numberTag3 = "[object Number]";
var objectTag3 = "[object Object]";
var regexpTag3 = "[object RegExp]";
var setTag4 = "[object Set]";
var stringTag3 = "[object String]";
var symbolTag3 = "[object Symbol]";
var weakMapTag4 = "[object WeakMap]";
var arrayBufferTag3 = "[object ArrayBuffer]";
var dataViewTag4 = "[object DataView]";
var float32Tag4 = "[object Float32Array]";
var float64Tag4 = "[object Float64Array]";
var int8Tag4 = "[object Int8Array]";
var int16Tag4 = "[object Int16Array]";
var int32Tag4 = "[object Int32Array]";
var uint8Tag4 = "[object Uint8Array]";
var uint8ClampedTag4 = "[object Uint8ClampedArray]";
var uint16Tag4 = "[object Uint16Array]";
var uint32Tag4 = "[object Uint32Array]";
var cloneableTags3 = {};
cloneableTags3[argsTag3] = cloneableTags3[arrayTag3] = cloneableTags3[arrayBufferTag3] = cloneableTags3[dataViewTag4] = cloneableTags3[boolTag3] = cloneableTags3[dateTag3] = cloneableTags3[float32Tag4] = cloneableTags3[float64Tag4] = cloneableTags3[int8Tag4] = cloneableTags3[int16Tag4] = cloneableTags3[int32Tag4] = cloneableTags3[mapTag4] = cloneableTags3[numberTag3] = cloneableTags3[objectTag3] = cloneableTags3[regexpTag3] = cloneableTags3[setTag4] = cloneableTags3[stringTag3] = cloneableTags3[symbolTag3] = cloneableTags3[uint8Tag4] = cloneableTags3[uint8ClampedTag4] = cloneableTags3[uint16Tag4] = cloneableTags3[uint32Tag4] = true;
cloneableTags3[errorTag3] = cloneableTags3[funcTag4] = cloneableTags3[weakMapTag4] = false;
function baseClone3(value, bitmask, customizer, key, object2, stack) {
  var result, isDeep = bitmask & CLONE_DEEP_FLAG$13, isFlat = bitmask & CLONE_FLAT_FLAG3, isFull = bitmask & CLONE_SYMBOLS_FLAG$13;
  if (customizer) {
    result = object2 ? customizer(value, key, object2, stack) : customizer(value);
  }
  if (result !== void 0) {
    return result;
  }
  if (!isObject_14(value)) {
    return value;
  }
  var isArr = isArray_16(value);
  if (isArr) {
    result = _initCloneArray3(value);
    if (!isDeep) {
      return _copyArray3(value, result);
    }
  } else {
    var tag = _getTag3(value), isFunc = tag == funcTag4 || tag == genTag4;
    if (isBuffer_14(value)) {
      return _cloneBuffer3(value, isDeep);
    }
    if (tag == objectTag3 || tag == argsTag3 || isFunc && !object2) {
      result = isFlat || isFunc ? {} : _initCloneObject3(value);
      if (!isDeep) {
        return isFlat ? _copySymbolsIn3(value, _baseAssignIn3(result, value)) : _copySymbols3(value, _baseAssign3(result, value));
      }
    } else {
      if (!cloneableTags3[tag]) {
        return object2 ? value : {};
      }
      result = _initCloneByTag3(value, tag, isDeep);
    }
  }
  stack || (stack = new _Stack3());
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);
  if (isSet_13(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone3(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (isMap_13(value)) {
    value.forEach(function(subValue, key2) {
      result.set(key2, baseClone3(subValue, bitmask, customizer, key2, value, stack));
    });
  }
  var keysFunc = isFull ? isFlat ? _getAllKeysIn3 : _getAllKeys3 : isFlat ? keysIn_13 : keys_13;
  var props = isArr ? void 0 : keysFunc(value);
  _arrayEach3(props || value, function(subValue, key2) {
    if (props) {
      key2 = subValue;
      subValue = value[key2];
    }
    _assignValue3(result, key2, baseClone3(subValue, bitmask, customizer, key2, value, stack));
  });
  return result;
}
var _baseClone3 = baseClone3;
var CLONE_DEEP_FLAG3 = 1;
var CLONE_SYMBOLS_FLAG3 = 4;
function cloneDeep3(value) {
  return _baseClone3(value, CLONE_DEEP_FLAG3 | CLONE_SYMBOLS_FLAG3);
}
var cloneDeep_13 = cloneDeep3;
var withInsertFragmentTable = (editor, {
  options
}) => {
  const {
    insertFragment: insertFragment2
  } = editor;
  const {
    disableExpandOnInsert,
    insertColumn,
    insertRow
  } = options;
  editor.insertFragment = (fragment) => {
    const insertedTable = fragment.find((n12) => n12.type === getPluginType(editor, ELEMENT_TABLE));
    if (insertedTable) {
      var _editor$selection;
      const tableEntry = getBlockAbove(editor, {
        at: (_editor$selection = editor.selection) === null || _editor$selection === void 0 ? void 0 : _editor$selection.anchor,
        match: {
          type: getPluginType(editor, ELEMENT_TABLE)
        }
      });
      if (tableEntry) {
        const [cellEntry] = getTableGridAbove(editor, {
          format: "cell"
        });
        if (cellEntry) {
          withoutNormalizing(editor, () => {
            const [, startCellPath] = cellEntry;
            const cellPath = [...startCellPath];
            const startColIndex = cellPath[cellPath.length - 1];
            let lastCellPath = null;
            let initRow = true;
            const insertedRows = insertedTable.children;
            insertedRows.forEach((row) => {
              cellPath[cellPath.length - 1] = startColIndex;
              if (!initRow) {
                const fromRow = cellPath.slice(0, -1);
                cellPath[cellPath.length - 2] += 1;
                if (!hasNode(editor, cellPath)) {
                  if (!disableExpandOnInsert) {
                    insertRow === null || insertRow === void 0 ? void 0 : insertRow(editor, {
                      fromRow
                    });
                  } else {
                    return;
                  }
                }
              }
              initRow = false;
              const insertedCells = row.children;
              let initCell = true;
              insertedCells.forEach((cell) => {
                if (!initCell) {
                  const fromCell = [...cellPath];
                  cellPath[cellPath.length - 1] += 1;
                  if (!hasNode(editor, cellPath)) {
                    if (!disableExpandOnInsert) {
                      insertColumn === null || insertColumn === void 0 ? void 0 : insertColumn(editor, {
                        fromCell
                      });
                    } else {
                      return;
                    }
                  }
                }
                initCell = false;
                removeNodes(editor, {
                  at: cellPath
                });
                insertNodes(editor, cloneDeep_13(cell), {
                  at: cellPath
                });
                lastCellPath = [...cellPath];
              });
            });
            if (lastCellPath) {
              select(editor, {
                anchor: {
                  offset: 0,
                  path: startCellPath
                },
                focus: {
                  offset: 0,
                  path: lastCellPath
                }
              });
            }
          });
          return;
        }
      }
    }
    insertFragment2(fragment);
  };
  return editor;
};
var withTable = (editor, plugin) => {
  editor = withDeleteTable(editor);
  editor = withGetFragmentTable(editor);
  editor = withInsertFragmentTable(editor, plugin);
  return editor;
};
var ELEMENT_TABLE = "table";
var ELEMENT_TH = "th";
var ELEMENT_TR = "tr";
var ELEMENT_TD = "td";
var createTablePlugin = createPluginFactory({
  key: ELEMENT_TABLE,
  isElement: true,
  handlers: {
    onKeyDown: onKeyDownTable
  },
  deserializeHtml: {
    rules: [{
      validNodeName: "TABLE"
    }]
  },
  options: {
    insertColumn: (e9, {
      fromCell
    }) => {
      insertTableColumn(e9, {
        fromCell,
        disableSelect: true
      });
    },
    insertRow: (e9, {
      fromRow
    }) => {
      insertTableRow(e9, {
        fromRow,
        disableSelect: true
      });
    }
  },
  withOverrides: withTable,
  plugins: [{
    key: ELEMENT_TR,
    isElement: true,
    deserializeHtml: {
      rules: [{
        validNodeName: "TR"
      }]
    }
  }, {
    key: ELEMENT_TD,
    isElement: true,
    deserializeHtml: {
      attributeNames: ["rowspan", "colspan"],
      rules: [{
        validNodeName: "TD"
      }]
    },
    props: ({
      element
    }) => {
      var _element$attributes, _element$attributes2;
      return {
        nodeProps: {
          colSpan: element === null || element === void 0 ? void 0 : (_element$attributes = element.attributes) === null || _element$attributes === void 0 ? void 0 : _element$attributes.colspan,
          rowSpan: element === null || element === void 0 ? void 0 : (_element$attributes2 = element.attributes) === null || _element$attributes2 === void 0 ? void 0 : _element$attributes2.rowspan
        }
      };
    }
  }, {
    key: ELEMENT_TH,
    isElement: true,
    deserializeHtml: {
      attributeNames: ["rowspan", "colspan"],
      rules: [{
        validNodeName: "TH"
      }]
    },
    props: ({
      element
    }) => {
      var _element$attributes3, _element$attributes4;
      return {
        nodeProps: {
          colSpan: element === null || element === void 0 ? void 0 : (_element$attributes3 = element.attributes) === null || _element$attributes3 === void 0 ? void 0 : _element$attributes3.colspan,
          rowSpan: element === null || element === void 0 ? void 0 : (_element$attributes4 = element.attributes) === null || _element$attributes4 === void 0 ? void 0 : _element$attributes4.rowspan
        }
      };
    }
  }]
});

// node_modules/@udecode/plate-serializer-csv/dist/index.es.js
var import_papaparse = __toESM(require_papaparse_min());
var isValidCsv = (data, errors, errorTolerance) => {
  if (errorTolerance < 0)
    errorTolerance = 0;
  return !(!data || data.length < 2 || data[0].length < 2 || data[1].length < 2 || errors.length && errors.length > errorTolerance * data.length);
};
var deserializeCsv = (editor, {
  data,
  header = false
}) => {
  const {
    options: {
      errorTolerance
    }
  } = getPlugin(editor, KEY_DESERIALIZE_CSV);
  const testCsv = (0, import_papaparse.parse)(data, {
    preview: 2
  });
  if (testCsv.errors.length === 0) {
    const csv = (0, import_papaparse.parse)(data, {
      header
    });
    if (!isValidCsv(csv.data, csv.errors, errorTolerance))
      return;
    const paragraph = getPluginType(editor, ELEMENT_DEFAULT);
    const table = getPluginType(editor, ELEMENT_TABLE);
    const th = getPluginType(editor, ELEMENT_TH);
    const tr = getPluginType(editor, ELEMENT_TR);
    const td = getPluginType(editor, ELEMENT_TD);
    const ast = {
      type: table,
      children: []
    };
    if (csv.meta.fields) {
      ast.children.push({
        type: tr,
        children: csv.meta.fields.map((field) => ({
          type: th,
          children: [{
            type: paragraph,
            children: [{
              text: field
            }]
          }]
        }))
      });
      for (const row of csv.data) {
        ast.children.push({
          type: tr,
          children: csv.meta.fields.map((field) => ({
            type: td,
            children: [{
              type: paragraph,
              children: [{
                text: row[field] || ""
              }]
            }]
          }))
        });
      }
    } else {
      for (const row of csv.data) {
        ast.children.push({
          type: tr,
          children: []
        });
        for (const cell of row) {
          ast.children[ast.children.length - 1].children.push({
            type: td,
            children: [{
              type: paragraph,
              children: [{
                text: cell
              }]
            }]
          });
        }
      }
    }
    return [{
      type: paragraph,
      children: [{
        text: ""
      }]
    }, ast, {
      type: paragraph,
      children: [{
        text: ""
      }]
    }];
  }
};
var KEY_DESERIALIZE_CSV = "deserializeCsv";
var createDeserializeCsvPlugin = createPluginFactory({
  key: KEY_DESERIALIZE_CSV,
  options: {
    errorTolerance: 0.25
  },
  then: (editor) => ({
    editor: {
      insertData: {
        format: "text/plain",
        getFragment: ({
          data
        }) => deserializeCsv(editor, {
          data,
          header: true
        })
      }
    }
  })
});

// node_modules/@udecode/plate-serializer-docx/dist/index.es.js
var cleanDocxBrComments = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    if (element.tagName !== "BR") {
      return true;
    }
    if (element.nextSibling && isHtmlComment(element.nextSibling) && element.nextSibling.data === "[if !supportLineBreakNewLine]") {
      removeHtmlNodesBetweenComments(element.nextSibling, "[if !supportLineBreakNewLine]", "[endif]");
    }
    return false;
  });
};
var isHtmlOpEmpty = (element) => element.nodeName === "O:P" && element.textContent === NO_BREAK_SPACE;
var isHtmlElementEmpty = (element) => element.children.length === 1 && element.firstElementChild !== null && (isHtmlOpEmpty(element.firstElementChild) || isHtmlElementEmpty(element.firstElementChild));
var cleanDocxEmptyParagraphs = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    if (element.tagName === "P" && isHtmlElementEmpty(element)) {
      element.innerHTML = "";
    }
    return true;
  });
};
var isDocxFootnote = (element) => {
  return element.tagName === "SPAN" && element.classList.contains("MsoFootnoteReference");
};
var extractFootnoteNumber = (footnote) => {
  return (footnote.textContent || "").trim().replace(/[[\]]/g, "");
};
var cleanDocxFootnotes = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    if (isDocxFootnote(element)) {
      const footnoteReplacement = document.createElement("sup");
      footnoteReplacement.textContent = extractFootnoteNumber(element);
      if (element.parentElement) {
        element.parentElement.replaceChild(footnoteReplacement, element);
      }
      return true;
    }
    return true;
  });
};
function unwrapExports12(x7) {
  return x7 && x7.__esModule && Object.prototype.hasOwnProperty.call(x7, "default") ? x7["default"] : x7;
}
function createCommonjsModule14(fn2, module2) {
  return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
}
var assertString_1 = createCommonjsModule14(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = assertString;
  function _typeof3(obj) {
    "@babel/helpers - typeof";
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof3 = function _typeof4(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof3 = function _typeof4(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof3(obj);
  }
  function assertString(input) {
    var isString2 = typeof input === "string" || input instanceof String;
    if (!isString2) {
      var invalidType = _typeof3(input);
      if (input === null)
        invalidType = "null";
      else if (invalidType === "object")
        invalidType = input.constructor.name;
      throw new TypeError("Expected a string but received a ".concat(invalidType));
    }
  }
  module2.exports = exports2.default;
  module2.exports.default = exports2.default;
});
unwrapExports12(assertString_1);
var merge_12 = createCommonjsModule14(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = merge3;
  function merge3() {
    var obj = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    var defaults4 = arguments.length > 1 ? arguments[1] : void 0;
    for (var key in defaults4) {
      if (typeof obj[key] === "undefined") {
        obj[key] = defaults4[key];
      }
    }
    return obj;
  }
  module2.exports = exports2.default;
  module2.exports.default = exports2.default;
});
unwrapExports12(merge_12);
var isFQDN_1 = createCommonjsModule14(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isFQDN;
  var _assertString = _interopRequireDefault(assertString_1);
  var _merge = _interopRequireDefault(merge_12);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var default_fqdn_options = {
    require_tld: true,
    allow_underscores: false,
    allow_trailing_dot: false,
    allow_numeric_tld: false,
    allow_wildcard: false
  };
  function isFQDN(str, options) {
    (0, _assertString.default)(str);
    options = (0, _merge.default)(options, default_fqdn_options);
    if (options.allow_trailing_dot && str[str.length - 1] === ".") {
      str = str.substring(0, str.length - 1);
    }
    if (options.allow_wildcard === true && str.indexOf("*.") === 0) {
      str = str.substring(2);
    }
    var parts = str.split(".");
    var tld = parts[parts.length - 1];
    if (options.require_tld) {
      if (parts.length < 2) {
        return false;
      }
      if (!/^([a-z\u00A1-\u00A8\u00AA-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}|xn[a-z0-9-]{2,})$/i.test(tld)) {
        return false;
      }
      if (/\s/.test(tld)) {
        return false;
      }
    }
    if (!options.allow_numeric_tld && /^\d+$/.test(tld)) {
      return false;
    }
    return parts.every(function(part) {
      if (part.length > 63) {
        return false;
      }
      if (!/^[a-z_\u00a1-\uffff0-9-]+$/i.test(part)) {
        return false;
      }
      if (/[\uff01-\uff5e]/.test(part)) {
        return false;
      }
      if (/^-|-$/.test(part)) {
        return false;
      }
      if (!options.allow_underscores && /_/.test(part)) {
        return false;
      }
      return true;
    });
  }
  module2.exports = exports2.default;
  module2.exports.default = exports2.default;
});
unwrapExports12(isFQDN_1);
var isIP_1 = createCommonjsModule14(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isIP;
  var _assertString = _interopRequireDefault(assertString_1);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var IPv4SegmentFormat = "(?:[0-9]|[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])";
  var IPv4AddressFormat = "(".concat(IPv4SegmentFormat, "[.]){3}").concat(IPv4SegmentFormat);
  var IPv4AddressRegExp = new RegExp("^".concat(IPv4AddressFormat, "$"));
  var IPv6SegmentFormat = "(?:[0-9a-fA-F]{1,4})";
  var IPv6AddressRegExp = new RegExp("^(" + "(?:".concat(IPv6SegmentFormat, ":){7}(?:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){6}(?:").concat(IPv4AddressFormat, "|:").concat(IPv6SegmentFormat, "|:)|") + "(?:".concat(IPv6SegmentFormat, ":){5}(?::").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,2}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){4}(?:(:").concat(IPv6SegmentFormat, "){0,1}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,3}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){3}(?:(:").concat(IPv6SegmentFormat, "){0,2}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,4}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){2}(?:(:").concat(IPv6SegmentFormat, "){0,3}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,5}|:)|") + "(?:".concat(IPv6SegmentFormat, ":){1}(?:(:").concat(IPv6SegmentFormat, "){0,4}:").concat(IPv4AddressFormat, "|(:").concat(IPv6SegmentFormat, "){1,6}|:)|") + "(?::((?::".concat(IPv6SegmentFormat, "){0,5}:").concat(IPv4AddressFormat, "|(?::").concat(IPv6SegmentFormat, "){1,7}|:))") + ")(%[0-9a-zA-Z-.:]{1,})?$");
  function isIP(str) {
    var version3 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    (0, _assertString.default)(str);
    version3 = String(version3);
    if (!version3) {
      return isIP(str, 4) || isIP(str, 6);
    }
    if (version3 === "4") {
      if (!IPv4AddressRegExp.test(str)) {
        return false;
      }
      var parts = str.split(".").sort(function(a13, b6) {
        return a13 - b6;
      });
      return parts[3] <= 255;
    }
    if (version3 === "6") {
      return !!IPv6AddressRegExp.test(str);
    }
    return false;
  }
  module2.exports = exports2.default;
  module2.exports.default = exports2.default;
});
unwrapExports12(isIP_1);
var isURL_1 = createCommonjsModule14(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = isURL2;
  var _assertString = _interopRequireDefault(assertString_1);
  var _isFQDN = _interopRequireDefault(isFQDN_1);
  var _isIP = _interopRequireDefault(isIP_1);
  var _merge = _interopRequireDefault(merge_12);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function _slicedToArray3(arr, i15) {
    return _arrayWithHoles3(arr) || _iterableToArrayLimit3(arr, i15) || _unsupportedIterableToArray3(arr, i15) || _nonIterableRest3();
  }
  function _nonIterableRest3() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  function _unsupportedIterableToArray3(o16, minLen) {
    if (!o16)
      return;
    if (typeof o16 === "string")
      return _arrayLikeToArray3(o16, minLen);
    var n12 = Object.prototype.toString.call(o16).slice(8, -1);
    if (n12 === "Object" && o16.constructor)
      n12 = o16.constructor.name;
    if (n12 === "Map" || n12 === "Set")
      return Array.from(o16);
    if (n12 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n12))
      return _arrayLikeToArray3(o16, minLen);
  }
  function _arrayLikeToArray3(arr, len) {
    if (len == null || len > arr.length)
      len = arr.length;
    for (var i15 = 0, arr2 = new Array(len); i15 < len; i15++) {
      arr2[i15] = arr[i15];
    }
    return arr2;
  }
  function _iterableToArrayLimit3(arr, i15) {
    if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
      return;
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e4 = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i15 && _arr.length === i15)
          break;
      }
    } catch (err) {
      _d = true;
      _e4 = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e4;
      }
    }
    return _arr;
  }
  function _arrayWithHoles3(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  var default_url_options = {
    protocols: ["http", "https", "ftp"],
    require_tld: true,
    require_protocol: false,
    require_host: true,
    require_port: false,
    require_valid_protocol: true,
    allow_underscores: false,
    allow_trailing_dot: false,
    allow_protocol_relative_urls: false,
    allow_fragments: true,
    allow_query_components: true,
    validate_length: true
  };
  var wrapped_ipv6 = /^\[([^\]]+)\](?::([0-9]+))?$/;
  function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  }
  function checkHost(host, matches) {
    for (var i15 = 0; i15 < matches.length; i15++) {
      var match5 = matches[i15];
      if (host === match5 || isRegExp(match5) && match5.test(host)) {
        return true;
      }
    }
    return false;
  }
  function isURL2(url, options) {
    (0, _assertString.default)(url);
    if (!url || /[\s<>]/.test(url)) {
      return false;
    }
    if (url.indexOf("mailto:") === 0) {
      return false;
    }
    options = (0, _merge.default)(options, default_url_options);
    if (options.validate_length && url.length >= 2083) {
      return false;
    }
    if (!options.allow_fragments && url.includes("#")) {
      return false;
    }
    if (!options.allow_query_components && (url.includes("?") || url.includes("&"))) {
      return false;
    }
    var protocol, auth, host, hostname, port, port_str, split2, ipv6;
    split2 = url.split("#");
    url = split2.shift();
    split2 = url.split("?");
    url = split2.shift();
    split2 = url.split("://");
    if (split2.length > 1) {
      protocol = split2.shift().toLowerCase();
      if (options.require_valid_protocol && options.protocols.indexOf(protocol) === -1) {
        return false;
      }
    } else if (options.require_protocol) {
      return false;
    } else if (url.substr(0, 2) === "//") {
      if (!options.allow_protocol_relative_urls) {
        return false;
      }
      split2[0] = url.substr(2);
    }
    url = split2.join("://");
    if (url === "") {
      return false;
    }
    split2 = url.split("/");
    url = split2.shift();
    if (url === "" && !options.require_host) {
      return true;
    }
    split2 = url.split("@");
    if (split2.length > 1) {
      if (options.disallow_auth) {
        return false;
      }
      if (split2[0] === "") {
        return false;
      }
      auth = split2.shift();
      if (auth.indexOf(":") >= 0 && auth.split(":").length > 2) {
        return false;
      }
      var _auth$split = auth.split(":"), _auth$split2 = _slicedToArray3(_auth$split, 2), user = _auth$split2[0], password = _auth$split2[1];
      if (user === "" && password === "") {
        return false;
      }
    }
    hostname = split2.join("@");
    port_str = null;
    ipv6 = null;
    var ipv6_match = hostname.match(wrapped_ipv6);
    if (ipv6_match) {
      host = "";
      ipv6 = ipv6_match[1];
      port_str = ipv6_match[2] || null;
    } else {
      split2 = hostname.split(":");
      host = split2.shift();
      if (split2.length) {
        port_str = split2.join(":");
      }
    }
    if (port_str !== null && port_str.length > 0) {
      port = parseInt(port_str, 10);
      if (!/^[0-9]+$/.test(port_str) || port <= 0 || port > 65535) {
        return false;
      }
    } else if (options.require_port) {
      return false;
    }
    if (options.host_whitelist) {
      return checkHost(host, options.host_whitelist);
    }
    if (!(0, _isIP.default)(host) && !(0, _isFQDN.default)(host, options) && (!ipv6 || !(0, _isIP.default)(ipv6, 6))) {
      return false;
    }
    host = host || ipv6;
    if (options.host_blacklist && checkHost(host, options.host_blacklist)) {
      return false;
    }
    return true;
  }
  module2.exports = exports2.default;
  module2.exports.default = exports2.default;
});
var isURL = unwrapExports12(isURL_1);
var getRtfImageHex = (imageData) => {
  const [, bliptagData = ""] = imageData.split("bliptag");
  const bracketSplit = bliptagData.split("}");
  if (bracketSplit.length < 2) {
    return null;
  }
  const [beforeBracket, afterBracket] = bracketSplit;
  if (bracketSplit.length > 2 && beforeBracket.includes("blipuid")) {
    return afterBracket.split(SPACE2).join("");
  }
  const spaceSplit = beforeBracket.split(SPACE2);
  if (spaceSplit.length < 2) {
    return null;
  }
  return spaceSplit.slice(1).join("");
};
var getRtfImageMimeType = (imageData) => {
  const [bliptagMeta] = imageData.split("bliptag");
  if (bliptagMeta.includes("pngblip")) {
    return "image/png";
  }
  if (bliptagMeta.includes("jpegblip")) {
    return "image/jpeg";
  }
  return null;
};
var END_OF_ID_SEQUENCE_CHARACTERS = ["\\", "{", CARRIAGE_RETURN, LINE_FEED, SPACE2];
var getRtfImageSpid = (imageData, spidPrefix) => {
  const indexes = END_OF_ID_SEQUENCE_CHARACTERS.map((character) => imageData.indexOf(character));
  const foundIndexes = indexes.filter((index2) => index2 !== -1);
  const idLength = Math.min(imageData.length, ...foundIndexes);
  const id = imageData.substring(0, idLength);
  return id ? `${spidPrefix}${id}` : null;
};
var getRtfImagesByType = (rtf, spidPrefix, type) => {
  const [, ...images] = rtf.split(type);
  return images.reduce((rtfImages, image) => {
    const [, imageData = ""] = image.split("shplid");
    const spid = getRtfImageSpid(imageData, spidPrefix);
    const mimeType = getRtfImageMimeType(imageData);
    const hex = getRtfImageHex(imageData);
    if (spid && mimeType && hex) {
      rtfImages.push({
        hex,
        mimeType,
        spid
      });
    }
    return rtfImages;
  }, []);
};
var getRtfImagesMap = (rtf) => {
  const rtfImagesMap = {};
  const shppictRtfImages = getRtfImagesByType(rtf, "i", "\\shppict");
  for (const shppictRtfImage of shppictRtfImages) {
    rtfImagesMap[shppictRtfImage.spid] = shppictRtfImage;
  }
  const shpRtfImages = getRtfImagesByType(rtf, "s", "\\shp");
  for (const shpRtfImage of shpRtfImages) {
    rtfImagesMap[shpRtfImage.spid] = shpRtfImage;
  }
  return rtfImagesMap;
};
var getVShapes = (document2) => {
  const comments = getHtmlComments(document2);
  return comments.reduce((vShapesMap, comment) => {
    try {
      const xmlDocument = new DOMParser().parseFromString(comment, "text/html");
      const vShapes = Array.from(xmlDocument.getElementsByTagName("V:SHAPE"));
      vShapes.forEach((vShape) => {
        const {
          id
        } = vShape;
        const spid = vShape.getAttribute("o:spid");
        if (typeof id === "string" && typeof spid === "string") {
          vShapesMap[id] = spid;
        }
      });
    } catch (error2) {
    }
    return vShapesMap;
  }, {});
};
var normalizeSpid = (spid) => {
  const [, , id] = spid.split("_");
  return id;
};
var getVShapeSpid = (document2, element) => {
  if (element.tagName === "IMG") {
    const vShapeId = element.getAttribute("v:shapes");
    const vShapes = getVShapes(document2);
    if (!vShapeId) {
      return null;
    }
    const vShapeSpid = vShapes[vShapeId];
    if (vShapeSpid) {
      return normalizeSpid(vShapeSpid);
    }
    if (element.parentElement && element.parentElement.parentElement && element.parentElement.parentElement.innerHTML.indexOf("msEquation") >= 0) {
      return null;
    }
    return normalizeSpid(vShapeId);
  }
  if (!element.parentElement) {
    return null;
  }
  const spid = element.parentElement.getAttribute("o:spid");
  if (spid) {
    return normalizeSpid(spid);
  }
  return spid;
};
var cleanDocxImageElements = (document2, rtf, rootNode) => {
  if (!rtf) {
    return;
  }
  traverseHtmlElements(rootNode, (element) => {
    if (!["IMG", "V:IMAGEDATA"].includes(element.tagName)) {
      return true;
    }
    if (element.tagName === "IMG") {
      const src = element.getAttribute("src");
      if (!src || !src.startsWith("file://")) {
        return true;
      }
      const alt = element.getAttribute("alt");
      if (typeof alt === "string" && isURL(alt, {
        require_protocol: true
      })) {
        element.setAttribute("src", alt);
        return true;
      }
    }
    const vShapeSpid = getVShapeSpid(document2, element);
    if (!vShapeSpid) {
      return true;
    }
    const rtfImagesMap = getRtfImagesMap(rtf);
    const rtfImage = rtfImagesMap[vShapeSpid];
    if (!rtfImage) {
      element.remove();
      return true;
    }
    const dataUri = `data:${rtfImage.mimeType};base64,${hexToBase64(rtfImage.hex)}`;
    if (element.tagName === "IMG") {
      element.setAttribute("src", dataUri);
    } else if (element.parentNode && element.parentNode.parentNode) {
      const imageElement = document2.createElement("img");
      imageElement.setAttribute("src", dataUri);
      element.parentNode.parentNode.replaceChild(imageElement, element.parentNode);
    }
    return true;
  });
};
var cleanDocxListElements = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    const styleAttribute = element.getAttribute("style");
    if (styleAttribute) {
      element.setAttribute("style", styleAttribute.replace(/mso-list:\s*Ignore/gim, "mso-list:Ignore"));
    }
    return true;
  });
};
var getDocxListContentHtml = (rootElement) => {
  const clonedElement = rootElement.cloneNode(true);
  removeHtmlNodesBetweenComments(clonedElement, "[if !supportLists]", "[endif]");
  traverseHtmlElements(clonedElement, (element) => {
    const styleAttribute = element.getAttribute("style");
    if (styleAttribute === "mso-list:Ignore") {
      element.remove();
    }
    return true;
  });
  return clonedElement.innerHTML;
};
var getDocxListIndent = (element) => {
  const styleAttribute = element.getAttribute("style") || "";
  const matches = styleAttribute.match(/level(\d+)/im);
  if (matches && matches.length >= 1) {
    const [, level] = matches;
    return parseInt(level, 10);
  }
  return 1;
};
var isDocxList = (element) => {
  const styleAttribute = element.getAttribute("style");
  if (!styleAttribute) {
    return false;
  }
  const hasMsoListInStyle = /mso-list:\s*l/gim.test(styleAttribute);
  if (!hasMsoListInStyle) {
    return false;
  }
  const hasMsoListIgnoreChild = Boolean(element.querySelector('[style="mso-list:Ignore"]'));
  if (hasMsoListIgnoreChild) {
    return true;
  }
  return element.outerHTML.includes("<!--[if !supportLists]-->");
};
var cleanDocxQuotes = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    if (element.parentNode && element.tagName === "P" && element.classList.contains("MsoQuote")) {
      replaceTagName(element, "blockquote");
    }
    return true;
  });
};
var generateSpaces = (count2) => Array.from({
  length: count2
}, () => SPACE2).join("");
var generateTabs = (count2) => Array.from({
  length: count2
}, () => TAB).join("");
var cleanDocxSpacerun = (element) => {
  const styleAttribute = element.getAttribute("style");
  if (!(styleAttribute && ["mso-spacerun:yes", "mso-spacerun: yes"].includes(styleAttribute))) {
    return;
  }
  const spacesCount = (element.textContent || "").length;
  const replacementNode = document.createTextNode(generateSpaces(spacesCount));
  if (element.parentNode) {
    element.parentNode.replaceChild(replacementNode, element);
  }
};
var cleanDocxTabCount = (element) => {
  const styleAttribute = element.getAttribute("style") || "";
  if (!styleAttribute.startsWith("mso-tab-count:")) {
    return;
  }
  const [, countString] = styleAttribute.split(":");
  const count2 = parseInt(countString, 10);
  const replacementNode = document.createTextNode(generateTabs(count2));
  if (element.parentNode) {
    element.parentNode.replaceChild(replacementNode, element);
  }
};
var cleanDocxSpans = (rootNode) => {
  traverseHtmlElements(rootNode, (element) => {
    if (element.nodeName !== "SPAN") {
      return true;
    }
    cleanDocxSpacerun(element);
    cleanDocxTabCount(element);
    return true;
  });
};
var DOCX_INDENT_STEP = 36;
var extractNumber = (str) => {
  if (str[0] === "-")
    return 0;
  let number2 = str.replace(/[^\d.,]+/, "");
  if (number2[0] === ".") {
    number2 = `0${number2}`;
  }
  return parseFloat(number2);
};
var styleToIndent = (style2, indentStep = DOCX_INDENT_STEP) => {
  const indent2 = extractNumber(style2);
  if (indent2) {
    if (style2.includes("in")) {
      return Math.round(indent2 * 72 / indentStep);
    }
    return Math.round(indent2 / indentStep);
  }
  return 0;
};
var getDocxSpacing = (element, cssProp) => {
  const el = element;
  const spacing = el.style[cssProp];
  if (!spacing)
    return 0;
  return styleToIndent(spacing) || 0;
};
var getDocxIndent = (element) => getDocxSpacing(element, "marginLeft");
var getDocxTextIndent = (element) => getDocxSpacing(element, "textIndent");
var getTextListStyleType = (text) => {
  var _text$match, _text$match2, _text$match3, _text$match4, _text$match5;
  text = text.trimStart();
  if ((_text$match = text.match(/^\d+[\\.]/)) !== null && _text$match !== void 0 && _text$match[0]) {
    if (text[0] === "0") {
      return ListStyleType.DecimalLeadingZero;
    }
    return ListStyleType.Decimal;
  }
  if ((_text$match2 = text.match(/^[ivmcldx]+\./)) !== null && _text$match2 !== void 0 && _text$match2[0]) {
    return ListStyleType.LowerRoman;
  }
  if ((_text$match3 = text.match(/^[a-z]+\./)) !== null && _text$match3 !== void 0 && _text$match3[0]) {
    return ListStyleType.LowerAlpha;
  }
  if ((_text$match4 = text.match(/^[IVMCLDX]+\./)) !== null && _text$match4 !== void 0 && _text$match4[0]) {
    return ListStyleType.UpperRoman;
  }
  if ((_text$match5 = text.match(/^[A-Z]+\./)) !== null && _text$match5 !== void 0 && _text$match5[0]) {
    return ListStyleType.UpperAlpha;
  }
};
var isDocxContent = (body) => {
  let result = false;
  traverseHtmlElements(body, (element) => {
    const styleAttribute = element.getAttribute("style") || "";
    const classList = Array.from(element.classList);
    const isMsoElement = styleAttribute.includes("mso-") || classList.some((className) => className.startsWith("Mso"));
    result = result || isMsoElement;
    return !result;
  });
  return result;
};
var cleanDocx = (html, rtf) => {
  const document2 = new DOMParser().parseFromString(preCleanHtml(html), "text/html");
  const {
    body
  } = document2;
  if (!rtf && !isDocxContent(body)) {
    return html;
  }
  cleanDocxFootnotes(body);
  cleanDocxImageElements(document2, rtf, body);
  cleanHtmlEmptyElements(body);
  cleanDocxEmptyParagraphs(body);
  cleanDocxQuotes(body);
  cleanDocxSpans(body);
  cleanHtmlTextNodes(body);
  cleanDocxBrComments(body);
  cleanHtmlBrElements(body);
  cleanHtmlLinkElements(body);
  cleanHtmlFontElements(body);
  cleanDocxListElements(body);
  copyBlockMarksToSpanChild(body);
  return postCleanHtml(body.innerHTML);
};
var KEY_DESERIALIZE_DOCX = "deserializeDocx";
var getListNode = (type) => (element) => {
  const node = {
    type
  };
  if (isDocxList(element)) {
    var _element$textContent, _getTextListStyleType;
    node[KEY_INDENT] = getDocxListIndent(element);
    const text = (_element$textContent = element.textContent) !== null && _element$textContent !== void 0 ? _element$textContent : "";
    node[KEY_LIST_STYLE_TYPE] = (_getTextListStyleType = getTextListStyleType(text)) !== null && _getTextListStyleType !== void 0 ? _getTextListStyleType : ListStyleType.Disc;
    element.innerHTML = getDocxListContentHtml(element);
  } else {
    const indent2 = getDocxIndent(element);
    if (indent2) {
      node[KEY_INDENT] = indent2;
    }
    const textIndent = getDocxTextIndent(element);
    if (textIndent) {
      node[KEY_TEXT_INDENT] = textIndent;
    }
  }
  return node;
};
var KEYS = [ELEMENT_PARAGRAPH, ELEMENT_H1, ELEMENT_H2, ELEMENT_H3, ELEMENT_H4, ELEMENT_H5, ELEMENT_H6];
var overrideByKey = {};
KEYS.forEach((key) => {
  overrideByKey[key] = {
    then: (editor, {
      type
    }) => ({
      deserializeHtml: {
        getNode: getListNode(type)
      }
    })
  };
});
var createDeserializeDocxPlugin = createPluginFactory({
  key: KEY_DESERIALIZE_DOCX,
  inject: {
    pluginsByKey: {
      [KEY_DESERIALIZE_HTML]: {
        editor: {
          insertData: {
            transformData: (data, {
              dataTransfer
            }) => {
              const rtf = dataTransfer.getData("text/rtf");
              return cleanDocx(data, rtf);
            }
          }
        }
      }
    }
  },
  overrideByKey: {
    ...overrideByKey,
    [ELEMENT_IMAGE]: {
      editor: {
        insertData: {
          query: ({
            dataTransfer
          }) => {
            const data = dataTransfer.getData("text/html");
            const {
              body
            } = new DOMParser().parseFromString(data, "text/html");
            return !isDocxContent(body);
          }
        }
      }
    }
  }
});

// node_modules/@udecode/plate-serializer-html/dist/index.es.js
var import_server = __toESM(require_server_browser());
var import_html_entities = __toESM(require_lib2());
var import_react14 = __toESM(require_react());

// node_modules/@udecode/plate-serializer-md/dist/index.es.js
var React10 = __toESM(require_react());
var import_react15 = __toESM(require_react());
var import_react_dom4 = __toESM(require_react_dom());
var import_remark_parse = __toESM(require_remark_parse());

// node_modules/remark-slate/dist/remark-slate.esm.js
var import_escape_html = __toESM(require_escape_html());

// node_modules/@udecode/plate-serializer-md/dist/index.es.js
var import_unified = __toESM(require_unified());
var KEY_DESERIALIZE_MD = "deserializeMd";
var createDeserializeMdPlugin = createPluginFactory({
  key: KEY_DESERIALIZE_MD,
  then: () => ({
    editor: {
      insertData: {
        format: "text/plain",
        query: ({
          data,
          dataTransfer
        }) => {
          const htmlData = dataTransfer.getData("text/html");
          if (htmlData)
            return false;
          const {
            files
          } = dataTransfer;
          if (!(files !== null && files !== void 0 && files.length)) {
            if (isUrl(data)) {
              return false;
            }
          }
          return true;
        }
        // getFragment: ({ data }) => deserializeMd(editor, data),
      }
    }
  })
});
var MARK_BOLD2 = "bold";
var createBoldPlugin2 = createPluginFactory({
  key: MARK_BOLD2,
  isLeaf: true,
  deserializeHtml: {
    rules: [{
      validNodeName: ["STRONG", "B"]
    }, {
      validStyle: {
        fontWeight: ["600", "700", "bold"]
      }
    }],
    query: (el) => !someHtmlElement(el, (node) => node.style.fontWeight === "normal")
  },
  handlers: {
    onKeyDown: onKeyDownToggleMark
  },
  options: {
    hotkey: "mod+b"
  }
});
var MARK_CODE2 = "code";
var createCodePlugin2 = createPluginFactory({
  key: MARK_CODE2,
  isLeaf: true,
  deserializeHtml: {
    rules: [{
      validNodeName: ["CODE"]
    }, {
      validStyle: {
        wordWrap: "break-word"
      }
    }, {
      validStyle: {
        fontFamily: "Consolas"
      }
    }],
    query(el) {
      const blockAbove = findHtmlParentElement(el, "P");
      if ((blockAbove === null || blockAbove === void 0 ? void 0 : blockAbove.style.fontFamily) === "Consolas")
        return false;
      return !findHtmlParentElement(el, "PRE");
    }
  },
  handlers: {
    onKeyDown: onKeyDownToggleMark
  },
  options: {
    hotkey: "mod+e"
  }
});
var MARK_ITALIC2 = "italic";
var createItalicPlugin2 = createPluginFactory({
  key: MARK_ITALIC2,
  isLeaf: true,
  handlers: {
    onKeyDown: onKeyDownToggleMark
  },
  options: {
    hotkey: "mod+i"
  },
  deserializeHtml: {
    rules: [{
      validNodeName: ["EM", "I"]
    }, {
      validStyle: {
        fontStyle: "italic"
      }
    }],
    query: (el) => !someHtmlElement(el, (node) => node.style.fontStyle === "normal")
  }
});
var MARK_STRIKETHROUGH2 = "strikethrough";
var createStrikethroughPlugin2 = createPluginFactory({
  key: MARK_STRIKETHROUGH2,
  isLeaf: true,
  handlers: {
    onKeyDown: onKeyDownToggleMark
  },
  options: {
    hotkey: "mod+shift+x"
  },
  deserializeHtml: {
    rules: [{
      validNodeName: ["S", "DEL", "STRIKE"]
    }, {
      validStyle: {
        textDecoration: "line-through"
      }
    }],
    query: (el) => !someHtmlElement(el, (node) => node.style.textDecoration === "none")
  }
});
var MARK_SUBSCRIPT$12 = "subscript";
var MARK_SUPERSCRIPT$12 = "superscript";
var createSubscriptPlugin2 = createPluginFactory({
  key: MARK_SUBSCRIPT$12,
  isLeaf: true,
  handlers: {
    onKeyDown: onKeyDownToggleMark
  },
  options: {
    hotkey: "mod+,",
    clear: MARK_SUPERSCRIPT$12
  },
  deserializeHtml: {
    rules: [{
      validNodeName: ["SUB"]
    }, {
      validStyle: {
        verticalAlign: "sub"
      }
    }]
  }
});
var MARK_SUPERSCRIPT2 = "superscript";
var MARK_SUBSCRIPT2 = "subscript";
var createSuperscriptPlugin2 = createPluginFactory({
  key: MARK_SUPERSCRIPT2,
  isLeaf: true,
  handlers: {
    onKeyDown: onKeyDownToggleMark
  },
  options: {
    hotkey: "mod+.",
    clear: MARK_SUBSCRIPT2
  },
  deserializeHtml: {
    rules: [{
      validNodeName: ["SUP"]
    }, {
      validStyle: {
        verticalAlign: "super"
      }
    }]
  }
});
var MARK_UNDERLINE2 = "underline";
var createUnderlinePlugin2 = createPluginFactory({
  key: MARK_UNDERLINE2,
  isLeaf: true,
  handlers: {
    onKeyDown: onKeyDownToggleMark
  },
  options: {
    hotkey: "mod+u"
  },
  deserializeHtml: {
    rules: [{
      validNodeName: ["U"]
    }, {
      validStyle: {
        textDecoration: ["underline"]
      }
    }],
    query: (el) => !someHtmlElement(el, (node) => node.style.textDecoration === "none")
  }
});
createPluginFactory({
  key: "basicMarks",
  plugins: [createBoldPlugin2(), createCodePlugin2(), createItalicPlugin2(), createStrikethroughPlugin2(), createSubscriptPlugin2(), createSuperscriptPlugin2(), createUnderlinePlugin2()]
});
var ELEMENT_HR2 = "hr";
createPluginFactory({
  key: ELEMENT_HR2,
  isElement: true,
  isVoid: true,
  deserializeHtml: {
    rules: [{
      validNodeName: "HR"
    }]
  }
});
var __extends$1 = function() {
  var extendStatics = function(d17, b6) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d18, b7) {
      d18.__proto__ = b7;
    } || function(d18, b7) {
      for (var p12 in b7)
        if (Object.prototype.hasOwnProperty.call(b7, p12))
          d18[p12] = b7[p12];
    };
    return extendStatics(d17, b6);
  };
  return function(d17, b6) {
    extendStatics(d17, b6);
    function __() {
      this.constructor = d17;
    }
    d17.prototype = b6 === null ? Object.create(b6) : (__.prototype = b6.prototype, new __());
  };
}();
var __assign$1 = function() {
  __assign$1 = Object.assign || function(t20) {
    for (var s20, i15 = 1, n12 = arguments.length; i15 < n12; i15++) {
      s20 = arguments[i15];
      for (var p12 in s20)
        if (Object.prototype.hasOwnProperty.call(s20, p12))
          t20[p12] = s20[p12];
    }
    return t20;
  };
  return __assign$1.apply(this, arguments);
};
var rowSizeBase2 = {
  width: "100%",
  height: "10px",
  top: "0px",
  left: "0px",
  cursor: "row-resize"
};
var colSizeBase2 = {
  width: "10px",
  height: "100%",
  top: "0px",
  left: "0px",
  cursor: "col-resize"
};
var edgeBase2 = {
  width: "20px",
  height: "20px",
  position: "absolute"
};
var styles2 = {
  top: __assign$1(__assign$1({}, rowSizeBase2), { top: "-5px" }),
  right: __assign$1(__assign$1({}, colSizeBase2), { left: void 0, right: "-5px" }),
  bottom: __assign$1(__assign$1({}, rowSizeBase2), { top: void 0, bottom: "-5px" }),
  left: __assign$1(__assign$1({}, colSizeBase2), { left: "-5px" }),
  topRight: __assign$1(__assign$1({}, edgeBase2), { right: "-10px", top: "-10px", cursor: "ne-resize" }),
  bottomRight: __assign$1(__assign$1({}, edgeBase2), { right: "-10px", bottom: "-10px", cursor: "se-resize" }),
  bottomLeft: __assign$1(__assign$1({}, edgeBase2), { left: "-10px", bottom: "-10px", cursor: "sw-resize" }),
  topLeft: __assign$1(__assign$1({}, edgeBase2), { left: "-10px", top: "-10px", cursor: "nw-resize" })
};
var Resizer2 = (
  /** @class */
  function(_super) {
    __extends$1(Resizer3, _super);
    function Resizer3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.onMouseDown = function(e9) {
        _this.props.onResizeStart(e9, _this.props.direction);
      };
      _this.onTouchStart = function(e9) {
        _this.props.onResizeStart(e9, _this.props.direction);
      };
      return _this;
    }
    Resizer3.prototype.render = function() {
      return React10.createElement("div", { className: this.props.className || "", style: __assign$1(__assign$1({ position: "absolute", userSelect: "none" }, styles2[this.props.direction]), this.props.replaceStyles || {}), onMouseDown: this.onMouseDown, onTouchStart: this.onTouchStart }, this.props.children);
    };
    return Resizer3;
  }(React10.PureComponent)
);
var __extends3 = function() {
  var extendStatics = function(d17, b6) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d18, b7) {
      d18.__proto__ = b7;
    } || function(d18, b7) {
      for (var p12 in b7)
        if (Object.prototype.hasOwnProperty.call(b7, p12))
          d18[p12] = b7[p12];
    };
    return extendStatics(d17, b6);
  };
  return function(d17, b6) {
    extendStatics(d17, b6);
    function __() {
      this.constructor = d17;
    }
    d17.prototype = b6 === null ? Object.create(b6) : (__.prototype = b6.prototype, new __());
  };
}();
var __assign4 = function() {
  __assign4 = Object.assign || function(t20) {
    for (var s20, i15 = 1, n12 = arguments.length; i15 < n12; i15++) {
      s20 = arguments[i15];
      for (var p12 in s20)
        if (Object.prototype.hasOwnProperty.call(s20, p12))
          t20[p12] = s20[p12];
    }
    return t20;
  };
  return __assign4.apply(this, arguments);
};
var DEFAULT_SIZE2 = {
  width: "auto",
  height: "auto"
};
var clamp2 = function(n12, min4, max4) {
  return Math.max(Math.min(n12, max4), min4);
};
var snap2 = function(n12, size2) {
  return Math.round(n12 / size2) * size2;
};
var hasDirection2 = function(dir, target) {
  return new RegExp(dir, "i").test(target);
};
var isTouchEvent2 = function(event) {
  return Boolean(event.touches && event.touches.length);
};
var isMouseEvent2 = function(event) {
  return Boolean((event.clientX || event.clientX === 0) && (event.clientY || event.clientY === 0));
};
var findClosestSnap2 = function(n12, snapArray, snapGap) {
  if (snapGap === void 0) {
    snapGap = 0;
  }
  var closestGapIndex = snapArray.reduce(function(prev, curr, index2) {
    return Math.abs(curr - n12) < Math.abs(snapArray[prev] - n12) ? index2 : prev;
  }, 0);
  var gap = Math.abs(snapArray[closestGapIndex] - n12);
  return snapGap === 0 || gap < snapGap ? snapArray[closestGapIndex] : n12;
};
var getStringSize2 = function(n12) {
  n12 = n12.toString();
  if (n12 === "auto") {
    return n12;
  }
  if (n12.endsWith("px")) {
    return n12;
  }
  if (n12.endsWith("%")) {
    return n12;
  }
  if (n12.endsWith("vh")) {
    return n12;
  }
  if (n12.endsWith("vw")) {
    return n12;
  }
  if (n12.endsWith("vmax")) {
    return n12;
  }
  if (n12.endsWith("vmin")) {
    return n12;
  }
  return n12 + "px";
};
var getPixelSize2 = function(size2, parentSize, innerWidth2, innerHeight2) {
  if (size2 && typeof size2 === "string") {
    if (size2.endsWith("px")) {
      return Number(size2.replace("px", ""));
    }
    if (size2.endsWith("%")) {
      var ratio = Number(size2.replace("%", "")) / 100;
      return parentSize * ratio;
    }
    if (size2.endsWith("vw")) {
      var ratio = Number(size2.replace("vw", "")) / 100;
      return innerWidth2 * ratio;
    }
    if (size2.endsWith("vh")) {
      var ratio = Number(size2.replace("vh", "")) / 100;
      return innerHeight2 * ratio;
    }
  }
  return size2;
};
var calculateNewMax2 = function(parentSize, innerWidth2, innerHeight2, maxWidth, maxHeight, minWidth, minHeight) {
  maxWidth = getPixelSize2(maxWidth, parentSize.width, innerWidth2, innerHeight2);
  maxHeight = getPixelSize2(maxHeight, parentSize.height, innerWidth2, innerHeight2);
  minWidth = getPixelSize2(minWidth, parentSize.width, innerWidth2, innerHeight2);
  minHeight = getPixelSize2(minHeight, parentSize.height, innerWidth2, innerHeight2);
  return {
    maxWidth: typeof maxWidth === "undefined" ? void 0 : Number(maxWidth),
    maxHeight: typeof maxHeight === "undefined" ? void 0 : Number(maxHeight),
    minWidth: typeof minWidth === "undefined" ? void 0 : Number(minWidth),
    minHeight: typeof minHeight === "undefined" ? void 0 : Number(minHeight)
  };
};
var definedProps2 = [
  "as",
  "style",
  "className",
  "grid",
  "snap",
  "bounds",
  "boundsByDirection",
  "size",
  "defaultSize",
  "minWidth",
  "minHeight",
  "maxWidth",
  "maxHeight",
  "lockAspectRatio",
  "lockAspectRatioExtraWidth",
  "lockAspectRatioExtraHeight",
  "enable",
  "handleStyles",
  "handleClasses",
  "handleWrapperStyle",
  "handleWrapperClass",
  "children",
  "onResizeStart",
  "onResize",
  "onResizeStop",
  "handleComponent",
  "scale",
  "resizeRatio",
  "snapGap"
];
var baseClassName2 = "__resizable_base__";
var Resizable2 = (
  /** @class */
  function(_super) {
    __extends3(Resizable3, _super);
    function Resizable3(props) {
      var _this = _super.call(this, props) || this;
      _this.ratio = 1;
      _this.resizable = null;
      _this.parentLeft = 0;
      _this.parentTop = 0;
      _this.resizableLeft = 0;
      _this.resizableRight = 0;
      _this.resizableTop = 0;
      _this.resizableBottom = 0;
      _this.targetLeft = 0;
      _this.targetTop = 0;
      _this.appendBase = function() {
        if (!_this.resizable || !_this.window) {
          return null;
        }
        var parent2 = _this.parentNode;
        if (!parent2) {
          return null;
        }
        var element = _this.window.document.createElement("div");
        element.style.width = "100%";
        element.style.height = "100%";
        element.style.position = "absolute";
        element.style.transform = "scale(0, 0)";
        element.style.left = "0";
        element.style.flex = "0 0 100%";
        if (element.classList) {
          element.classList.add(baseClassName2);
        } else {
          element.className += baseClassName2;
        }
        parent2.appendChild(element);
        return element;
      };
      _this.removeBase = function(base) {
        var parent2 = _this.parentNode;
        if (!parent2) {
          return;
        }
        parent2.removeChild(base);
      };
      _this.ref = function(c16) {
        if (c16) {
          _this.resizable = c16;
        }
      };
      _this.state = {
        isResizing: false,
        width: typeof (_this.propsSize && _this.propsSize.width) === "undefined" ? "auto" : _this.propsSize && _this.propsSize.width,
        height: typeof (_this.propsSize && _this.propsSize.height) === "undefined" ? "auto" : _this.propsSize && _this.propsSize.height,
        direction: "right",
        original: {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        },
        backgroundStyle: {
          height: "100%",
          width: "100%",
          backgroundColor: "rgba(0,0,0,0)",
          cursor: "auto",
          opacity: 0,
          position: "fixed",
          zIndex: 9999,
          top: "0",
          left: "0",
          bottom: "0",
          right: "0"
        },
        flexBasis: void 0
      };
      _this.onResizeStart = _this.onResizeStart.bind(_this);
      _this.onMouseMove = _this.onMouseMove.bind(_this);
      _this.onMouseUp = _this.onMouseUp.bind(_this);
      return _this;
    }
    Object.defineProperty(Resizable3.prototype, "parentNode", {
      get: function() {
        if (!this.resizable) {
          return null;
        }
        return this.resizable.parentNode;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resizable3.prototype, "window", {
      get: function() {
        if (!this.resizable) {
          return null;
        }
        if (!this.resizable.ownerDocument) {
          return null;
        }
        return this.resizable.ownerDocument.defaultView;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resizable3.prototype, "propsSize", {
      get: function() {
        return this.props.size || this.props.defaultSize || DEFAULT_SIZE2;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resizable3.prototype, "size", {
      get: function() {
        var width = 0;
        var height = 0;
        if (this.resizable && this.window) {
          var orgWidth = this.resizable.offsetWidth;
          var orgHeight = this.resizable.offsetHeight;
          var orgPosition = this.resizable.style.position;
          if (orgPosition !== "relative") {
            this.resizable.style.position = "relative";
          }
          width = this.resizable.style.width !== "auto" ? this.resizable.offsetWidth : orgWidth;
          height = this.resizable.style.height !== "auto" ? this.resizable.offsetHeight : orgHeight;
          this.resizable.style.position = orgPosition;
        }
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Resizable3.prototype, "sizeStyle", {
      get: function() {
        var _this = this;
        var size2 = this.props.size;
        var getSize4 = function(key) {
          if (typeof _this.state[key] === "undefined" || _this.state[key] === "auto") {
            return "auto";
          }
          if (_this.propsSize && _this.propsSize[key] && _this.propsSize[key].toString().endsWith("%")) {
            if (_this.state[key].toString().endsWith("%")) {
              return _this.state[key].toString();
            }
            var parentSize = _this.getParentSize();
            var value = Number(_this.state[key].toString().replace("px", ""));
            var percent = value / parentSize[key] * 100;
            return percent + "%";
          }
          return getStringSize2(_this.state[key]);
        };
        var width = size2 && typeof size2.width !== "undefined" && !this.state.isResizing ? getStringSize2(size2.width) : getSize4("width");
        var height = size2 && typeof size2.height !== "undefined" && !this.state.isResizing ? getStringSize2(size2.height) : getSize4("height");
        return { width, height };
      },
      enumerable: false,
      configurable: true
    });
    Resizable3.prototype.getParentSize = function() {
      if (!this.parentNode) {
        if (!this.window) {
          return { width: 0, height: 0 };
        }
        return { width: this.window.innerWidth, height: this.window.innerHeight };
      }
      var base = this.appendBase();
      if (!base) {
        return { width: 0, height: 0 };
      }
      var wrapChanged = false;
      var wrap = this.parentNode.style.flexWrap;
      if (wrap !== "wrap") {
        wrapChanged = true;
        this.parentNode.style.flexWrap = "wrap";
      }
      base.style.position = "relative";
      base.style.minWidth = "100%";
      base.style.minHeight = "100%";
      var size2 = {
        width: base.offsetWidth,
        height: base.offsetHeight
      };
      if (wrapChanged) {
        this.parentNode.style.flexWrap = wrap;
      }
      this.removeBase(base);
      return size2;
    };
    Resizable3.prototype.bindEvents = function() {
      if (this.window) {
        this.window.addEventListener("mouseup", this.onMouseUp);
        this.window.addEventListener("mousemove", this.onMouseMove);
        this.window.addEventListener("mouseleave", this.onMouseUp);
        this.window.addEventListener("touchmove", this.onMouseMove, {
          capture: true,
          passive: false
        });
        this.window.addEventListener("touchend", this.onMouseUp);
      }
    };
    Resizable3.prototype.unbindEvents = function() {
      if (this.window) {
        this.window.removeEventListener("mouseup", this.onMouseUp);
        this.window.removeEventListener("mousemove", this.onMouseMove);
        this.window.removeEventListener("mouseleave", this.onMouseUp);
        this.window.removeEventListener("touchmove", this.onMouseMove, true);
        this.window.removeEventListener("touchend", this.onMouseUp);
      }
    };
    Resizable3.prototype.componentDidMount = function() {
      if (!this.resizable || !this.window) {
        return;
      }
      var computedStyle = this.window.getComputedStyle(this.resizable);
      this.setState({
        width: this.state.width || this.size.width,
        height: this.state.height || this.size.height,
        flexBasis: computedStyle.flexBasis !== "auto" ? computedStyle.flexBasis : void 0
      });
    };
    Resizable3.prototype.componentWillUnmount = function() {
      if (this.window) {
        this.unbindEvents();
      }
    };
    Resizable3.prototype.createSizeForCssProperty = function(newSize, kind) {
      var propsSize = this.propsSize && this.propsSize[kind];
      return this.state[kind] === "auto" && this.state.original[kind] === newSize && (typeof propsSize === "undefined" || propsSize === "auto") ? "auto" : newSize;
    };
    Resizable3.prototype.calculateNewMaxFromBoundary = function(maxWidth, maxHeight) {
      var boundsByDirection = this.props.boundsByDirection;
      var direction = this.state.direction;
      var widthByDirection = boundsByDirection && hasDirection2("left", direction);
      var heightByDirection = boundsByDirection && hasDirection2("top", direction);
      var boundWidth;
      var boundHeight;
      if (this.props.bounds === "parent") {
        var parent_1 = this.parentNode;
        if (parent_1) {
          boundWidth = widthByDirection ? this.resizableRight - this.parentLeft : parent_1.offsetWidth + (this.parentLeft - this.resizableLeft);
          boundHeight = heightByDirection ? this.resizableBottom - this.parentTop : parent_1.offsetHeight + (this.parentTop - this.resizableTop);
        }
      } else if (this.props.bounds === "window") {
        if (this.window) {
          boundWidth = widthByDirection ? this.resizableRight : this.window.innerWidth - this.resizableLeft;
          boundHeight = heightByDirection ? this.resizableBottom : this.window.innerHeight - this.resizableTop;
        }
      } else if (this.props.bounds) {
        boundWidth = widthByDirection ? this.resizableRight - this.targetLeft : this.props.bounds.offsetWidth + (this.targetLeft - this.resizableLeft);
        boundHeight = heightByDirection ? this.resizableBottom - this.targetTop : this.props.bounds.offsetHeight + (this.targetTop - this.resizableTop);
      }
      if (boundWidth && Number.isFinite(boundWidth)) {
        maxWidth = maxWidth && maxWidth < boundWidth ? maxWidth : boundWidth;
      }
      if (boundHeight && Number.isFinite(boundHeight)) {
        maxHeight = maxHeight && maxHeight < boundHeight ? maxHeight : boundHeight;
      }
      return { maxWidth, maxHeight };
    };
    Resizable3.prototype.calculateNewSizeFromDirection = function(clientX, clientY) {
      var scale = this.props.scale || 1;
      var resizeRatio = this.props.resizeRatio || 1;
      var _a = this.state, direction = _a.direction, original = _a.original;
      var _b = this.props, lockAspectRatio = _b.lockAspectRatio, lockAspectRatioExtraHeight = _b.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _b.lockAspectRatioExtraWidth;
      var newWidth = original.width;
      var newHeight = original.height;
      var extraHeight = lockAspectRatioExtraHeight || 0;
      var extraWidth = lockAspectRatioExtraWidth || 0;
      if (hasDirection2("right", direction)) {
        newWidth = original.width + (clientX - original.x) * resizeRatio / scale;
        if (lockAspectRatio) {
          newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;
        }
      }
      if (hasDirection2("left", direction)) {
        newWidth = original.width - (clientX - original.x) * resizeRatio / scale;
        if (lockAspectRatio) {
          newHeight = (newWidth - extraWidth) / this.ratio + extraHeight;
        }
      }
      if (hasDirection2("bottom", direction)) {
        newHeight = original.height + (clientY - original.y) * resizeRatio / scale;
        if (lockAspectRatio) {
          newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;
        }
      }
      if (hasDirection2("top", direction)) {
        newHeight = original.height - (clientY - original.y) * resizeRatio / scale;
        if (lockAspectRatio) {
          newWidth = (newHeight - extraHeight) * this.ratio + extraWidth;
        }
      }
      return { newWidth, newHeight };
    };
    Resizable3.prototype.calculateNewSizeFromAspectRatio = function(newWidth, newHeight, max4, min4) {
      var _a = this.props, lockAspectRatio = _a.lockAspectRatio, lockAspectRatioExtraHeight = _a.lockAspectRatioExtraHeight, lockAspectRatioExtraWidth = _a.lockAspectRatioExtraWidth;
      var computedMinWidth = typeof min4.width === "undefined" ? 10 : min4.width;
      var computedMaxWidth = typeof max4.width === "undefined" || max4.width < 0 ? newWidth : max4.width;
      var computedMinHeight = typeof min4.height === "undefined" ? 10 : min4.height;
      var computedMaxHeight = typeof max4.height === "undefined" || max4.height < 0 ? newHeight : max4.height;
      var extraHeight = lockAspectRatioExtraHeight || 0;
      var extraWidth = lockAspectRatioExtraWidth || 0;
      if (lockAspectRatio) {
        var extraMinWidth = (computedMinHeight - extraHeight) * this.ratio + extraWidth;
        var extraMaxWidth = (computedMaxHeight - extraHeight) * this.ratio + extraWidth;
        var extraMinHeight = (computedMinWidth - extraWidth) / this.ratio + extraHeight;
        var extraMaxHeight = (computedMaxWidth - extraWidth) / this.ratio + extraHeight;
        var lockedMinWidth = Math.max(computedMinWidth, extraMinWidth);
        var lockedMaxWidth = Math.min(computedMaxWidth, extraMaxWidth);
        var lockedMinHeight = Math.max(computedMinHeight, extraMinHeight);
        var lockedMaxHeight = Math.min(computedMaxHeight, extraMaxHeight);
        newWidth = clamp2(newWidth, lockedMinWidth, lockedMaxWidth);
        newHeight = clamp2(newHeight, lockedMinHeight, lockedMaxHeight);
      } else {
        newWidth = clamp2(newWidth, computedMinWidth, computedMaxWidth);
        newHeight = clamp2(newHeight, computedMinHeight, computedMaxHeight);
      }
      return { newWidth, newHeight };
    };
    Resizable3.prototype.setBoundingClientRect = function() {
      if (this.props.bounds === "parent") {
        var parent_2 = this.parentNode;
        if (parent_2) {
          var parentRect = parent_2.getBoundingClientRect();
          this.parentLeft = parentRect.left;
          this.parentTop = parentRect.top;
        }
      }
      if (this.props.bounds && typeof this.props.bounds !== "string") {
        var targetRect = this.props.bounds.getBoundingClientRect();
        this.targetLeft = targetRect.left;
        this.targetTop = targetRect.top;
      }
      if (this.resizable) {
        var _a = this.resizable.getBoundingClientRect(), left = _a.left, top_1 = _a.top, right = _a.right, bottom = _a.bottom;
        this.resizableLeft = left;
        this.resizableRight = right;
        this.resizableTop = top_1;
        this.resizableBottom = bottom;
      }
    };
    Resizable3.prototype.onResizeStart = function(event, direction) {
      if (!this.resizable || !this.window) {
        return;
      }
      var clientX = 0;
      var clientY = 0;
      if (event.nativeEvent && isMouseEvent2(event.nativeEvent)) {
        clientX = event.nativeEvent.clientX;
        clientY = event.nativeEvent.clientY;
      } else if (event.nativeEvent && isTouchEvent2(event.nativeEvent)) {
        clientX = event.nativeEvent.touches[0].clientX;
        clientY = event.nativeEvent.touches[0].clientY;
      }
      if (this.props.onResizeStart) {
        if (this.resizable) {
          var startResize = this.props.onResizeStart(event, direction, this.resizable);
          if (startResize === false) {
            return;
          }
        }
      }
      if (this.props.size) {
        if (typeof this.props.size.height !== "undefined" && this.props.size.height !== this.state.height) {
          this.setState({ height: this.props.size.height });
        }
        if (typeof this.props.size.width !== "undefined" && this.props.size.width !== this.state.width) {
          this.setState({ width: this.props.size.width });
        }
      }
      this.ratio = typeof this.props.lockAspectRatio === "number" ? this.props.lockAspectRatio : this.size.width / this.size.height;
      var flexBasis;
      var computedStyle = this.window.getComputedStyle(this.resizable);
      if (computedStyle.flexBasis !== "auto") {
        var parent_3 = this.parentNode;
        if (parent_3) {
          var dir = this.window.getComputedStyle(parent_3).flexDirection;
          this.flexDir = dir.startsWith("row") ? "row" : "column";
          flexBasis = computedStyle.flexBasis;
        }
      }
      this.setBoundingClientRect();
      this.bindEvents();
      var state = {
        original: {
          x: clientX,
          y: clientY,
          width: this.size.width,
          height: this.size.height
        },
        isResizing: true,
        backgroundStyle: __assign4(__assign4({}, this.state.backgroundStyle), { cursor: this.window.getComputedStyle(event.target).cursor || "auto" }),
        direction,
        flexBasis
      };
      this.setState(state);
    };
    Resizable3.prototype.onMouseMove = function(event) {
      var _this = this;
      if (!this.state.isResizing || !this.resizable || !this.window) {
        return;
      }
      if (this.window.TouchEvent && isTouchEvent2(event)) {
        try {
          event.preventDefault();
          event.stopPropagation();
        } catch (e9) {
        }
      }
      var _a = this.props, maxWidth = _a.maxWidth, maxHeight = _a.maxHeight, minWidth = _a.minWidth, minHeight = _a.minHeight;
      var clientX = isTouchEvent2(event) ? event.touches[0].clientX : event.clientX;
      var clientY = isTouchEvent2(event) ? event.touches[0].clientY : event.clientY;
      var _b = this.state, direction = _b.direction, original = _b.original, width = _b.width, height = _b.height;
      var parentSize = this.getParentSize();
      var max4 = calculateNewMax2(parentSize, this.window.innerWidth, this.window.innerHeight, maxWidth, maxHeight, minWidth, minHeight);
      maxWidth = max4.maxWidth;
      maxHeight = max4.maxHeight;
      minWidth = max4.minWidth;
      minHeight = max4.minHeight;
      var _c = this.calculateNewSizeFromDirection(clientX, clientY), newHeight = _c.newHeight, newWidth = _c.newWidth;
      var boundaryMax = this.calculateNewMaxFromBoundary(maxWidth, maxHeight);
      if (this.props.snap && this.props.snap.x) {
        newWidth = findClosestSnap2(newWidth, this.props.snap.x, this.props.snapGap);
      }
      if (this.props.snap && this.props.snap.y) {
        newHeight = findClosestSnap2(newHeight, this.props.snap.y, this.props.snapGap);
      }
      var newSize = this.calculateNewSizeFromAspectRatio(newWidth, newHeight, { width: boundaryMax.maxWidth, height: boundaryMax.maxHeight }, { width: minWidth, height: minHeight });
      newWidth = newSize.newWidth;
      newHeight = newSize.newHeight;
      if (this.props.grid) {
        var newGridWidth = snap2(newWidth, this.props.grid[0]);
        var newGridHeight = snap2(newHeight, this.props.grid[1]);
        var gap = this.props.snapGap || 0;
        newWidth = gap === 0 || Math.abs(newGridWidth - newWidth) <= gap ? newGridWidth : newWidth;
        newHeight = gap === 0 || Math.abs(newGridHeight - newHeight) <= gap ? newGridHeight : newHeight;
      }
      var delta = {
        width: newWidth - original.width,
        height: newHeight - original.height
      };
      if (width && typeof width === "string") {
        if (width.endsWith("%")) {
          var percent = newWidth / parentSize.width * 100;
          newWidth = percent + "%";
        } else if (width.endsWith("vw")) {
          var vw = newWidth / this.window.innerWidth * 100;
          newWidth = vw + "vw";
        } else if (width.endsWith("vh")) {
          var vh = newWidth / this.window.innerHeight * 100;
          newWidth = vh + "vh";
        }
      }
      if (height && typeof height === "string") {
        if (height.endsWith("%")) {
          var percent = newHeight / parentSize.height * 100;
          newHeight = percent + "%";
        } else if (height.endsWith("vw")) {
          var vw = newHeight / this.window.innerWidth * 100;
          newHeight = vw + "vw";
        } else if (height.endsWith("vh")) {
          var vh = newHeight / this.window.innerHeight * 100;
          newHeight = vh + "vh";
        }
      }
      var newState = {
        width: this.createSizeForCssProperty(newWidth, "width"),
        height: this.createSizeForCssProperty(newHeight, "height")
      };
      if (this.flexDir === "row") {
        newState.flexBasis = newState.width;
      } else if (this.flexDir === "column") {
        newState.flexBasis = newState.height;
      }
      (0, import_react_dom4.flushSync)(function() {
        _this.setState(newState);
      });
      if (this.props.onResize) {
        this.props.onResize(event, direction, this.resizable, delta);
      }
    };
    Resizable3.prototype.onMouseUp = function(event) {
      var _a = this.state, isResizing = _a.isResizing, direction = _a.direction, original = _a.original;
      if (!isResizing || !this.resizable) {
        return;
      }
      var delta = {
        width: this.size.width - original.width,
        height: this.size.height - original.height
      };
      if (this.props.onResizeStop) {
        this.props.onResizeStop(event, direction, this.resizable, delta);
      }
      if (this.props.size) {
        this.setState(this.props.size);
      }
      this.unbindEvents();
      this.setState({
        isResizing: false,
        backgroundStyle: __assign4(__assign4({}, this.state.backgroundStyle), { cursor: "auto" })
      });
    };
    Resizable3.prototype.updateSize = function(size2) {
      this.setState({ width: size2.width, height: size2.height });
    };
    Resizable3.prototype.renderResizer = function() {
      var _this = this;
      var _a = this.props, enable = _a.enable, handleStyles = _a.handleStyles, handleClasses = _a.handleClasses, handleWrapperStyle = _a.handleWrapperStyle, handleWrapperClass = _a.handleWrapperClass, handleComponent = _a.handleComponent;
      if (!enable) {
        return null;
      }
      var resizers = Object.keys(enable).map(function(dir) {
        if (enable[dir] !== false) {
          return React10.createElement(Resizer2, { key: dir, direction: dir, onResizeStart: _this.onResizeStart, replaceStyles: handleStyles && handleStyles[dir], className: handleClasses && handleClasses[dir] }, handleComponent && handleComponent[dir] ? handleComponent[dir] : null);
        }
        return null;
      });
      return React10.createElement("div", { className: handleWrapperClass, style: handleWrapperStyle }, resizers);
    };
    Resizable3.prototype.render = function() {
      var _this = this;
      var extendsProps = Object.keys(this.props).reduce(function(acc, key) {
        if (definedProps2.indexOf(key) !== -1) {
          return acc;
        }
        acc[key] = _this.props[key];
        return acc;
      }, {});
      var style2 = __assign4(__assign4(__assign4({ position: "relative", userSelect: this.state.isResizing ? "none" : "auto" }, this.props.style), this.sizeStyle), { maxWidth: this.props.maxWidth, maxHeight: this.props.maxHeight, minWidth: this.props.minWidth, minHeight: this.props.minHeight, boxSizing: "border-box", flexShrink: 0 });
      if (this.state.flexBasis) {
        style2.flexBasis = this.state.flexBasis;
      }
      var Wrapper2 = this.props.as || "div";
      return React10.createElement(
        Wrapper2,
        __assign4({ ref: this.ref, style: style2, className: this.props.className }, extendsProps),
        this.state.isResizing && React10.createElement("div", { style: this.state.backgroundStyle }),
        this.props.children,
        this.renderResizer()
      );
    };
    Resizable3.defaultProps = {
      as: "div",
      onResizeStart: function() {
      },
      onResize: function() {
      },
      onResizeStop: function() {
      },
      enable: {
        top: true,
        right: true,
        bottom: true,
        left: true,
        topRight: true,
        bottomRight: true,
        bottomLeft: true,
        topLeft: true
      },
      style: {},
      grid: [1, 1],
      lockAspectRatio: false,
      lockAspectRatioExtraWidth: 0,
      lockAspectRatioExtraHeight: 0,
      scale: 1,
      resizeRatio: 1,
      snapGap: 0
    };
    return Resizable3;
  }(React10.PureComponent)
);
function unwrapExports13(x7) {
  return x7 && x7.__esModule && Object.prototype.hasOwnProperty.call(x7, "default") ? x7["default"] : x7;
}
function createCommonjsModule15(fn2, module2) {
  return module2 = {
    exports: {}
  }, fn2(module2, module2.exports), module2.exports;
}
var lib12 = createCommonjsModule15(function(module2, exports2) {
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var IS_MAC = () => typeof window != "undefined" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform);
  var MODIFIERS = {
    alt: "altKey",
    control: "ctrlKey",
    meta: "metaKey",
    shift: "shiftKey"
  };
  var ALIASES = () => ({
    add: "+",
    break: "pause",
    cmd: "meta",
    command: "meta",
    ctl: "control",
    ctrl: "control",
    del: "delete",
    down: "arrowdown",
    esc: "escape",
    ins: "insert",
    left: "arrowleft",
    mod: IS_MAC() ? "meta" : "control",
    opt: "alt",
    option: "alt",
    return: "enter",
    right: "arrowright",
    space: " ",
    spacebar: " ",
    up: "arrowup",
    win: "meta",
    windows: "meta"
  });
  var CODES = {
    backspace: 8,
    tab: 9,
    enter: 13,
    shift: 16,
    control: 17,
    alt: 18,
    pause: 19,
    capslock: 20,
    escape: 27,
    " ": 32,
    pageup: 33,
    pagedown: 34,
    end: 35,
    home: 36,
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    insert: 45,
    delete: 46,
    meta: 91,
    numlock: 144,
    scrolllock: 145,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
  };
  for (var f16 = 1; f16 < 20; f16++) {
    CODES["f" + f16] = 111 + f16;
  }
  function isHotkey14(hotkey, options, event) {
    if (options && !("byKey" in options)) {
      event = options;
      options = null;
    }
    if (!Array.isArray(hotkey)) {
      hotkey = [hotkey];
    }
    var array2 = hotkey.map(function(string2) {
      return parseHotkey(string2, options);
    });
    var check = function check2(e9) {
      return array2.some(function(object2) {
        return compareHotkey(object2, e9);
      });
    };
    var ret = event == null ? check : check(event);
    return ret;
  }
  function isCodeHotkey(hotkey, event) {
    return isHotkey14(hotkey, event);
  }
  function isKeyHotkey2(hotkey, event) {
    return isHotkey14(hotkey, {
      byKey: true
    }, event);
  }
  function parseHotkey(hotkey, options) {
    var byKey = options && options.byKey;
    var ret = {};
    hotkey = hotkey.replace("++", "+add");
    var values3 = hotkey.split("+");
    var length = values3.length;
    for (var k3 in MODIFIERS) {
      ret[MODIFIERS[k3]] = false;
    }
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = void 0;
    try {
      for (var _iterator = values3[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var value = _step.value;
        var optional = value.endsWith("?") && value.length > 1;
        if (optional) {
          value = value.slice(0, -1);
        }
        var name2 = toKeyName(value);
        var modifier = MODIFIERS[name2];
        if (length === 1 || !modifier) {
          if (byKey) {
            ret.key = name2;
          } else {
            ret.which = toKeyCode(value);
          }
        }
        if (modifier) {
          ret[modifier] = optional ? null : true;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return ret;
  }
  function compareHotkey(object2, event) {
    for (var key in object2) {
      var expected = object2[key];
      var actual = void 0;
      if (expected == null) {
        continue;
      }
      if (key === "key" && event.key != null) {
        actual = event.key.toLowerCase();
      } else if (key === "which") {
        actual = expected === 91 && event.which === 93 ? 91 : event.which;
      } else {
        actual = event[key];
      }
      if (actual == null && expected === false) {
        continue;
      }
      if (actual !== expected) {
        return false;
      }
    }
    return true;
  }
  function toKeyCode(name2) {
    name2 = toKeyName(name2);
    var code = CODES[name2] || name2.toUpperCase().charCodeAt(0);
    return code;
  }
  function toKeyName(name2) {
    name2 = name2.toLowerCase();
    name2 = ALIASES()[name2] || name2;
    return name2;
  }
  exports2.default = isHotkey14;
  exports2.isHotkey = isHotkey14;
  exports2.isCodeHotkey = isCodeHotkey;
  exports2.isKeyHotkey = isKeyHotkey2;
  exports2.parseHotkey = parseHotkey;
  exports2.compareHotkey = compareHotkey;
  exports2.toKeyCode = toKeyCode;
  exports2.toKeyName = toKeyName;
});
var isHotkey12 = unwrapExports13(lib12);
lib12.isHotkey;
lib12.isCodeHotkey;
lib12.isKeyHotkey;
lib12.parseHotkey;
lib12.compareHotkey;
lib12.toKeyCode;
lib12.toKeyName;
var useImageElement2 = () => useElement(ELEMENT_IMAGE2);
var useImageCaptionString2 = () => {
  const {
    caption: nodeCaption = [{
      children: [{
        text: ""
      }]
    }]
  } = useImageElement2();
  return (0, import_react15.useMemo)(() => {
    return getNodeString(nodeCaption[0]) || "";
  }, [nodeCaption]);
};
var useImageCaption2 = ({
  readOnly,
  ...props
} = {}) => {
  const width = useImageStore2().get.width();
  return {
    style: {
      width
    },
    ...props
  };
};
var useImageCaptionState2 = (props) => {
  const captionString = useImageCaptionString2();
  const selected = useSelected();
  const _readOnly = useReadOnly();
  const readOnly = props.readOnly || _readOnly;
  return {
    captionString,
    selected,
    readOnly
  };
};
createComponentAs((props) => {
  const htmlProps = useImageCaption2(props);
  const {
    captionString,
    selected,
    readOnly
  } = useImageCaptionState2(props);
  if (!captionString.length && (readOnly || !selected)) {
    return null;
  }
  return createElementAs("figcaption", htmlProps);
});
function _extends4() {
  _extends4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i15 = 1; i15 < arguments.length; i15++) {
      var source = arguments[i15];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends4.apply(this, arguments);
}
var TextareaAutosize4 = (0, import_react15.forwardRef)((props, ref2) => {
  const [isRerendered, setIsRerendered] = (0, import_react15.useState)(false);
  (0, import_react15.useLayoutEffect)(() => setIsRerendered(true), []);
  return isRerendered ? import_react15.default.createElement(react_textarea_autosize_browser_esm_default, _extends4({}, props, {
    ref: ref2
  })) : null;
});
var useImageCaptionTextareaFocus2 = (textareaRef) => {
  const editor = useEditorRef();
  const element = useImageElement2();
  const focusCaptionPath = imageGlobalStore2.use.focusEndCaptionPath();
  (0, import_react15.useEffect)(() => {
    if (focusCaptionPath && textareaRef.current) {
      const path = findNodePath(editor, element);
      if (path && Path.equals(path, focusCaptionPath)) {
        textareaRef.current.focus();
        imageGlobalStore2.set.focusEndCaptionPath(null);
      }
    }
  }, [editor, element, focusCaptionPath, textareaRef]);
};
var useImageCaptionTextarea2 = (props) => {
  const element = useImageElement2();
  const {
    caption: nodeCaption = [{
      children: [{
        text: ""
      }]
    }]
  } = element;
  const [captionValue, setCaptionValue] = (0, import_react15.useState)(getNodeString(nodeCaption[0]));
  const editor = useEditorRef();
  const readOnly = useReadOnly();
  const textareaRef = (0, import_react15.useRef)(null);
  const ref2 = useComposedRef(textareaRef, props.ref);
  useImageCaptionTextareaFocus2(textareaRef);
  const onChange = (0, import_react15.useCallback)((e9) => {
    const newValue = e9.target.value;
    setCaptionValue(newValue);
    const path = findNodePath(editor, element);
    if (!path)
      return;
    setNodes(editor, {
      caption: [{
        text: newValue
      }]
    }, {
      at: path
    });
  }, [editor, element]);
  const onKeyDown = (e9) => {
    if (isHotkey12("up", e9)) {
      const path = findNodePath(editor, element);
      if (!path)
        return;
      e9.preventDefault();
      focusEditor(editor, path);
    }
    if (isHotkey12("down", e9)) {
      const path = findNodePath(editor, element);
      if (!path)
        return;
      const nextNodePath = getPointAfter(editor, path);
      if (!nextNodePath)
        return;
      e9.preventDefault();
      focusEditor(editor, nextNodePath);
    }
  };
  return {
    value: captionValue,
    readOnly,
    onChange,
    onKeyDown,
    ...props,
    ref: ref2
  };
};
createComponentAs(({
  as: as2,
  ...props
}) => {
  const htmlProps = useImageCaptionTextarea2({
    as: as2,
    ...props
  });
  return import_react15.default.createElement(TextareaAutosize4, htmlProps);
});
var useImageImg2 = (props) => {
  const {
    url
  } = useImageElement2();
  const captionString = useImageCaptionString2();
  return {
    src: url,
    alt: captionString,
    draggable: true,
    ...props
  };
};
createComponentAs((props) => {
  const htmlProps = useImageImg2(props);
  return createElementAs("img", htmlProps);
});
var useImageResizable2 = ({
  align = "center",
  readOnly,
  ...props
}) => {
  const element = useImageElement2();
  const editor = useEditorRef();
  const _readOnly = useReadOnly();
  readOnly = isDefined(readOnly) ? readOnly : _readOnly;
  const {
    width: nodeWidth = "100%"
  } = element !== null && element !== void 0 ? element : {};
  const [width, setWidth] = useImageStore2().use.width();
  const setNodeWidth = (0, import_react15.useCallback)((w7) => {
    const path = findNodePath(editor, element);
    if (!path)
      return;
    if (w7 === nodeWidth) {
      select(editor, path);
    } else {
      setNodes(editor, {
        width: w7
      }, {
        at: path
      });
    }
  }, [editor, element, nodeWidth]);
  (0, import_react15.useEffect)(() => {
    setWidth(nodeWidth);
  }, [nodeWidth, setWidth]);
  const defaultProps4 = {
    minWidth: 92,
    size: {
      width,
      height: "100%"
    },
    maxWidth: "100%",
    lockAspectRatio: true,
    resizeRatio: align === "center" ? 2 : 1,
    enable: {
      left: ["center", "left"].includes(align),
      right: ["center", "right"].includes(align)
    },
    handleStyles: {
      left: {
        left: 0
      },
      right: {
        right: 0
      }
    },
    onResize: (e9, direction, ref2) => {
      setWidth(ref2.offsetWidth);
    },
    onResizeStop: (e9, direction, ref2) => setNodeWidth(ref2.offsetWidth)
  };
  if (readOnly) {
    return {
      ...defaultProps4,
      ...props,
      enable: {
        left: false,
        right: false,
        top: false,
        bottom: false,
        topLeft: false,
        bottomLeft: false,
        topRight: false,
        bottomRight: false
      }
    };
  }
  return {
    ...defaultProps4,
    ...props
  };
};
createComponentAs((props) => {
  const resizableProps = useImageResizable2(props);
  return import_react15.default.createElement(Resizable2, resizableProps);
});
var {
  imageStore: imageStore2,
  useImageStore: useImageStore2
} = createAtomStore({
  width: 0
}, {
  name: "image",
  scope: "img"
});
var imageGlobalStore2 = createStore4("image")({
  /**
   * When defined, focus end of caption textarea of the image with the same path.
   */
  focusEndCaptionPath: null,
  /**
   * When defined, focus start of caption textarea of the image with the same path.
   */
  focusStartCaptionPath: null
});
var useElementProps2 = ({
  attributes,
  nodeProps,
  element,
  editor,
  ...props
}) => {
  return {
    ...attributes,
    ...props,
    ...nodeProps,
    ref: useComposedRef(props.ref, attributes.ref)
  };
};
createComponentAs((props) => {
  const htmlProps = useElementProps2(props);
  return createElementAs("div", htmlProps);
});
var insertImage2 = (editor, url) => {
  const text = {
    text: ""
  };
  const image = {
    type: getPluginType(editor, ELEMENT_IMAGE2),
    url,
    children: [text]
  };
  insertNodes(editor, image);
};
var withImageUpload2 = (editor, plugin) => {
  const {
    options: {
      uploadImage
    }
  } = plugin;
  const {
    insertData
  } = editor;
  editor.insertData = (dataTransfer) => {
    const text = dataTransfer.getData("text/plain");
    const {
      files
    } = dataTransfer;
    if (files && files.length > 0) {
      const injectedPlugins = getInjectedPlugins(editor, plugin);
      if (!pipeInsertDataQuery(injectedPlugins, {
        data: text,
        dataTransfer
      })) {
        return insertData(dataTransfer);
      }
      for (const file of files) {
        const reader = new FileReader();
        const [mime] = file.type.split("/");
        if (mime === "image") {
          reader.addEventListener("load", async () => {
            if (!reader.result) {
              return;
            }
            const uploadedUrl = uploadImage ? await uploadImage(reader.result) : reader.result;
            insertImage2(editor, uploadedUrl);
          });
          reader.readAsDataURL(file);
        }
      }
    } else {
      insertData(dataTransfer);
    }
  };
  return editor;
};
var ELEMENT_IMAGE2 = "img";
createPluginFactory({
  key: ELEMENT_IMAGE2,
  isElement: true,
  isVoid: true,
  withOverrides: withImageUpload2,
  handlers: {
    onKeyDown: (editor) => (e9) => {
      if (isHotkey12("down", e9)) {
        const entry = getBlockAbove(editor, {
          match: {
            type: getPluginType(editor, ELEMENT_IMAGE2)
          }
        });
        if (!entry)
          return;
        imageGlobalStore2.set.focusEndCaptionPath(entry[1]);
      }
    }
  },
  then: (editor, {
    type
  }) => ({
    deserializeHtml: {
      rules: [{
        validNodeName: "IMG"
      }],
      getNode: (el) => ({
        type,
        url: el.getAttribute("src")
      })
    }
  })
});

// node_modules/@udecode/plate-trailing-block/dist/index.es.js
var withTrailingBlock = (editor, {
  type,
  options: {
    level,
    ...query
  }
}) => {
  const {
    normalizeNode
  } = editor;
  editor.normalizeNode = ([currentNode, currentPath]) => {
    if (!currentPath.length) {
      const lastChild = getLastNodeByLevel(editor, level);
      const lastChildNode = lastChild === null || lastChild === void 0 ? void 0 : lastChild[0];
      if (!lastChildNode || lastChildNode.type !== type && queryNode(lastChild, query)) {
        const at = lastChild ? Path.next(lastChild[1]) : [0];
        insertElements(editor, {
          type,
          children: [{
            text: ""
          }]
        }, {
          at
        });
        return;
      }
    }
    return normalizeNode([currentNode, currentPath]);
  };
  return editor;
};
var KEY_TRAILING_BLOCK = "trailingBlock";
var createTrailingBlockPlugin = createPluginFactory({
  key: KEY_TRAILING_BLOCK,
  withOverrides: withTrailingBlock,
  options: {
    level: 0
  },
  then: (editor) => ({
    type: getPluginType(editor, ELEMENT_DEFAULT)
  })
});

// node_modules/@headlessui/react/dist/components/combobox/combobox.js
var import_react33 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/hooks/use-computed.js
var import_react18 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
var import_react16 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/utils/env.js
var i5 = Object.defineProperty;
var d3 = (t20, e9, n12) => e9 in t20 ? i5(t20, e9, { enumerable: true, configurable: true, writable: true, value: n12 }) : t20[e9] = n12;
var r6 = (t20, e9, n12) => (d3(t20, typeof e9 != "symbol" ? e9 + "" : e9, n12), n12);
var o6 = class {
  constructor() {
    r6(this, "current", this.detect());
    r6(this, "handoffState", "pending");
    r6(this, "currentId", 0);
  }
  set(e9) {
    this.current !== e9 && (this.handoffState = "pending", this.currentId = 0, this.current = e9);
  }
  reset() {
    this.set(this.detect());
  }
  nextId() {
    return ++this.currentId;
  }
  get isServer() {
    return this.current === "server";
  }
  get isClient() {
    return this.current === "client";
  }
  detect() {
    return typeof window == "undefined" || typeof document == "undefined" ? "server" : "client";
  }
  handoff() {
    this.handoffState === "pending" && (this.handoffState = "complete");
  }
  get isHandoffComplete() {
    return this.handoffState === "complete";
  }
};
var s4 = new o6();

// node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js
var l5 = (e9, f16) => {
  s4.isServer ? (0, import_react16.useEffect)(e9, f16) : (0, import_react16.useLayoutEffect)(e9, f16);
};

// node_modules/@headlessui/react/dist/hooks/use-latest-value.js
var import_react17 = __toESM(require_react(), 1);
function s5(e9) {
  let r15 = (0, import_react17.useRef)(e9);
  return l5(() => {
    r15.current = e9;
  }, [e9]), r15;
}

// node_modules/@headlessui/react/dist/hooks/use-computed.js
function i6(e9, o16) {
  let [u11, t20] = (0, import_react18.useState)(e9), r15 = s5(e9);
  return l5(() => t20(r15.current), [r15, t20, ...o16]), u11;
}

// node_modules/@headlessui/react/dist/hooks/use-disposables.js
var import_react19 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/utils/micro-task.js
function t8(e9) {
  typeof queueMicrotask == "function" ? queueMicrotask(e9) : Promise.resolve().then(e9).catch((o16) => setTimeout(() => {
    throw o16;
  }));
}

// node_modules/@headlessui/react/dist/utils/disposables.js
function o7() {
  let n12 = [], r15 = { addEventListener(e9, t20, s20, a13) {
    return e9.addEventListener(t20, s20, a13), r15.add(() => e9.removeEventListener(t20, s20, a13));
  }, requestAnimationFrame(...e9) {
    let t20 = requestAnimationFrame(...e9);
    return r15.add(() => cancelAnimationFrame(t20));
  }, nextFrame(...e9) {
    return r15.requestAnimationFrame(() => r15.requestAnimationFrame(...e9));
  }, setTimeout(...e9) {
    let t20 = setTimeout(...e9);
    return r15.add(() => clearTimeout(t20));
  }, microTask(...e9) {
    let t20 = { current: true };
    return t8(() => {
      t20.current && e9[0]();
    }), r15.add(() => {
      t20.current = false;
    });
  }, style(e9, t20, s20) {
    let a13 = e9.style.getPropertyValue(t20);
    return Object.assign(e9.style, { [t20]: s20 }), this.add(() => {
      Object.assign(e9.style, { [t20]: a13 });
    });
  }, group(e9) {
    let t20 = o7();
    return e9(t20), this.add(() => t20.dispose());
  }, add(e9) {
    return n12.push(e9), () => {
      let t20 = n12.indexOf(e9);
      if (t20 >= 0)
        for (let s20 of n12.splice(t20, 1))
          s20();
    };
  }, dispose() {
    for (let e9 of n12.splice(0))
      e9();
  } };
  return r15;
}

// node_modules/@headlessui/react/dist/hooks/use-disposables.js
function p4() {
  let [e9] = (0, import_react19.useState)(o7);
  return (0, import_react19.useEffect)(() => () => e9.dispose(), [e9]), e9;
}

// node_modules/@headlessui/react/dist/hooks/use-event.js
var import_react20 = __toESM(require_react(), 1);
var o9 = function(t20) {
  let e9 = s5(t20);
  return import_react20.default.useCallback((...r15) => e9.current(...r15), [e9]);
};

// node_modules/@headlessui/react/dist/hooks/use-id.js
var import_react22 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/hooks/use-server-handoff-complete.js
var import_react21 = __toESM(require_react(), 1);
function l6() {
  let [e9, f16] = (0, import_react21.useState)(s4.isHandoffComplete);
  return e9 && s4.isHandoffComplete === false && f16(false), (0, import_react21.useEffect)(() => {
    e9 !== true && f16(true);
  }, [e9]), (0, import_react21.useEffect)(() => s4.handoff(), []), e9;
}

// node_modules/@headlessui/react/dist/hooks/use-id.js
var o11;
var I2 = (o11 = import_react22.default.useId) != null ? o11 : function() {
  let n12 = l6(), [e9, u11] = import_react22.default.useState(n12 ? () => s4.nextId() : null);
  return l5(() => {
    e9 === null && u11(s4.nextId());
  }, [e9]), e9 != null ? "" + e9 : void 0;
};

// node_modules/@headlessui/react/dist/hooks/use-outside-click.js
var import_react24 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/utils/match.js
function u4(r15, n12, ...a13) {
  if (r15 in n12) {
    let e9 = n12[r15];
    return typeof e9 == "function" ? e9(...a13) : e9;
  }
  let t20 = new Error(`Tried to handle "${r15}" but there is no handler defined. Only defined handlers are: ${Object.keys(n12).map((e9) => `"${e9}"`).join(", ")}.`);
  throw Error.captureStackTrace && Error.captureStackTrace(t20, u4), t20;
}

// node_modules/@headlessui/react/dist/utils/owner.js
function e4(r15) {
  return s4.isServer ? null : r15 instanceof Node ? r15.ownerDocument : r15 != null && r15.hasOwnProperty("current") && r15.current instanceof Node ? r15.current.ownerDocument : document;
}

// node_modules/@headlessui/react/dist/utils/focus-management.js
var c5 = ["[contentEditable=true]", "[tabindex]", "a[href]", "area[href]", "button:not([disabled])", "iframe", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].map((e9) => `${e9}:not([tabindex='-1'])`).join(",");
var M2 = ((n12) => (n12[n12.First = 1] = "First", n12[n12.Previous = 2] = "Previous", n12[n12.Next = 4] = "Next", n12[n12.Last = 8] = "Last", n12[n12.WrapAround = 16] = "WrapAround", n12[n12.NoScroll = 32] = "NoScroll", n12))(M2 || {});
var N2 = ((o16) => (o16[o16.Error = 0] = "Error", o16[o16.Overflow = 1] = "Overflow", o16[o16.Success = 2] = "Success", o16[o16.Underflow = 3] = "Underflow", o16))(N2 || {});
var F = ((t20) => (t20[t20.Previous = -1] = "Previous", t20[t20.Next = 1] = "Next", t20))(F || {});
function f4(e9 = document.body) {
  return e9 == null ? [] : Array.from(e9.querySelectorAll(c5)).sort((r15, t20) => Math.sign((r15.tabIndex || Number.MAX_SAFE_INTEGER) - (t20.tabIndex || Number.MAX_SAFE_INTEGER)));
}
var T = ((t20) => (t20[t20.Strict = 0] = "Strict", t20[t20.Loose = 1] = "Loose", t20))(T || {});
function h3(e9, r15 = 0) {
  var t20;
  return e9 === ((t20 = e4(e9)) == null ? void 0 : t20.body) ? false : u4(r15, { [0]() {
    return e9.matches(c5);
  }, [1]() {
    let l14 = e9;
    for (; l14 !== null; ) {
      if (l14.matches(c5))
        return true;
      l14 = l14.parentElement;
    }
    return false;
  } });
}
function D2(e9) {
  let r15 = e4(e9);
  o7().nextFrame(() => {
    r15 && !h3(r15.activeElement, 0) && y3(e9);
  });
}
var w3 = ((t20) => (t20[t20.Keyboard = 0] = "Keyboard", t20[t20.Mouse = 1] = "Mouse", t20))(w3 || {});
typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("keydown", (e9) => {
  e9.metaKey || e9.altKey || e9.ctrlKey || (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true), document.addEventListener("click", (e9) => {
  e9.detail === 1 ? delete document.documentElement.dataset.headlessuiFocusVisible : e9.detail === 0 && (document.documentElement.dataset.headlessuiFocusVisible = "");
}, true));
function y3(e9) {
  e9 == null || e9.focus({ preventScroll: true });
}
var S2 = ["textarea", "input"].join(",");
function H2(e9) {
  var r15, t20;
  return (t20 = (r15 = e9 == null ? void 0 : e9.matches) == null ? void 0 : r15.call(e9, S2)) != null ? t20 : false;
}
function I3(e9, r15 = (t20) => t20) {
  return e9.slice().sort((t20, l14) => {
    let o16 = r15(t20), i15 = r15(l14);
    if (o16 === null || i15 === null)
      return 0;
    let n12 = o16.compareDocumentPosition(i15);
    return n12 & Node.DOCUMENT_POSITION_FOLLOWING ? -1 : n12 & Node.DOCUMENT_POSITION_PRECEDING ? 1 : 0;
  });
}
function _2(e9, r15) {
  return O2(f4(), r15, { relativeTo: e9 });
}
function O2(e9, r15, { sorted: t20 = true, relativeTo: l14 = null, skipElements: o16 = [] } = {}) {
  let i15 = Array.isArray(e9) ? e9.length > 0 ? e9[0].ownerDocument : document : e9.ownerDocument, n12 = Array.isArray(e9) ? t20 ? I3(e9) : e9 : f4(e9);
  o16.length > 0 && n12.length > 1 && (n12 = n12.filter((s20) => !o16.includes(s20))), l14 = l14 != null ? l14 : i15.activeElement;
  let E8 = (() => {
    if (r15 & 5)
      return 1;
    if (r15 & 10)
      return -1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), x7 = (() => {
    if (r15 & 1)
      return 0;
    if (r15 & 2)
      return Math.max(0, n12.indexOf(l14)) - 1;
    if (r15 & 4)
      return Math.max(0, n12.indexOf(l14)) + 1;
    if (r15 & 8)
      return n12.length - 1;
    throw new Error("Missing Focus.First, Focus.Previous, Focus.Next or Focus.Last");
  })(), p12 = r15 & 32 ? { preventScroll: true } : {}, d17 = 0, a13 = n12.length, u11;
  do {
    if (d17 >= a13 || d17 + a13 <= 0)
      return 0;
    let s20 = x7 + d17;
    if (r15 & 16)
      s20 = (s20 + a13) % a13;
    else {
      if (s20 < 0)
        return 3;
      if (s20 >= a13)
        return 1;
    }
    u11 = n12[s20], u11 == null || u11.focus(p12), d17 += E8;
  } while (u11 !== i15.activeElement);
  return r15 & 6 && H2(u11) && u11.select(), 2;
}

// node_modules/@headlessui/react/dist/hooks/use-document-event.js
var import_react23 = __toESM(require_react(), 1);
function d4(e9, r15, n12) {
  let o16 = s5(r15);
  (0, import_react23.useEffect)(() => {
    function t20(u11) {
      o16.current(u11);
    }
    return document.addEventListener(e9, t20, n12), () => document.removeEventListener(e9, t20, n12);
  }, [e9, n12]);
}

// node_modules/@headlessui/react/dist/hooks/use-outside-click.js
function L2(m10, E8, c16 = true) {
  let i15 = (0, import_react24.useRef)(false);
  (0, import_react24.useEffect)(() => {
    requestAnimationFrame(() => {
      i15.current = c16;
    });
  }, [c16]);
  function f16(e9, o16) {
    if (!i15.current || e9.defaultPrevented)
      return;
    let l14 = function r15(t20) {
      return typeof t20 == "function" ? r15(t20()) : Array.isArray(t20) || t20 instanceof Set ? t20 : [t20];
    }(m10), n12 = o16(e9);
    if (n12 !== null && n12.getRootNode().contains(n12)) {
      for (let r15 of l14) {
        if (r15 === null)
          continue;
        let t20 = r15 instanceof HTMLElement ? r15 : r15.current;
        if (t20 != null && t20.contains(n12) || e9.composed && e9.composedPath().includes(t20))
          return;
      }
      return !h3(n12, T.Loose) && n12.tabIndex !== -1 && e9.preventDefault(), E8(e9, n12);
    }
  }
  let u11 = (0, import_react24.useRef)(null);
  d4("mousedown", (e9) => {
    var o16, l14;
    i15.current && (u11.current = ((l14 = (o16 = e9.composedPath) == null ? void 0 : o16.call(e9)) == null ? void 0 : l14[0]) || e9.target);
  }, true), d4("click", (e9) => {
    u11.current && (f16(e9, () => u11.current), u11.current = null);
  }, true), d4("blur", (e9) => f16(e9, () => window.document.activeElement instanceof HTMLIFrameElement ? window.document.activeElement : null), true);
}

// node_modules/@headlessui/react/dist/hooks/use-resolve-button-type.js
var import_react25 = __toESM(require_react(), 1);
function i7(t20) {
  var n12;
  if (t20.type)
    return t20.type;
  let e9 = (n12 = t20.as) != null ? n12 : "button";
  if (typeof e9 == "string" && e9.toLowerCase() === "button")
    return "button";
}
function s9(t20, e9) {
  let [n12, u11] = (0, import_react25.useState)(() => i7(t20));
  return l5(() => {
    u11(i7(t20));
  }, [t20.type, t20.as]), l5(() => {
    n12 || e9.current && e9.current instanceof HTMLButtonElement && !e9.current.hasAttribute("type") && u11("button");
  }, [n12, e9]), n12;
}

// node_modules/@headlessui/react/dist/hooks/use-sync-refs.js
var import_react26 = __toESM(require_react(), 1);
var u5 = Symbol();
function T2(t20, n12 = true) {
  return Object.assign(t20, { [u5]: n12 });
}
function y4(...t20) {
  let n12 = (0, import_react26.useRef)(t20);
  (0, import_react26.useEffect)(() => {
    n12.current = t20;
  }, [t20]);
  let c16 = o9((e9) => {
    for (let o16 of n12.current)
      o16 != null && (typeof o16 == "function" ? o16(e9) : o16.current = e9);
  });
  return t20.every((e9) => e9 == null || (e9 == null ? void 0 : e9[u5])) ? void 0 : c16;
}

// node_modules/@headlessui/react/dist/hooks/use-tree-walker.js
var import_react27 = __toESM(require_react(), 1);
function F2({ container: e9, accept: t20, walk: r15, enabled: c16 = true }) {
  let o16 = (0, import_react27.useRef)(t20), l14 = (0, import_react27.useRef)(r15);
  (0, import_react27.useEffect)(() => {
    o16.current = t20, l14.current = r15;
  }, [t20, r15]), l5(() => {
    if (!e9 || !c16)
      return;
    let n12 = e4(e9);
    if (!n12)
      return;
    let f16 = o16.current, p12 = l14.current, d17 = Object.assign((i15) => f16(i15), { acceptNode: f16 }), u11 = n12.createTreeWalker(e9, NodeFilter.SHOW_ELEMENT, d17, false);
    for (; u11.nextNode(); )
      p12(u11.currentNode);
  }, [e9, c16, o16, l14]);
}

// node_modules/@headlessui/react/dist/utils/calculate-active-index.js
function f5(r15) {
  throw new Error("Unexpected object: " + r15);
}
var a4 = ((e9) => (e9[e9.First = 0] = "First", e9[e9.Previous = 1] = "Previous", e9[e9.Next = 2] = "Next", e9[e9.Last = 3] = "Last", e9[e9.Specific = 4] = "Specific", e9[e9.Nothing = 5] = "Nothing", e9))(a4 || {});
function x2(r15, n12) {
  let t20 = n12.resolveItems();
  if (t20.length <= 0)
    return null;
  let l14 = n12.resolveActiveIndex(), s20 = l14 != null ? l14 : -1, d17 = (() => {
    switch (r15.focus) {
      case 0:
        return t20.findIndex((e9) => !n12.resolveDisabled(e9));
      case 1: {
        let e9 = t20.slice().reverse().findIndex((i15, c16, u11) => s20 !== -1 && u11.length - c16 - 1 >= s20 ? false : !n12.resolveDisabled(i15));
        return e9 === -1 ? e9 : t20.length - 1 - e9;
      }
      case 2:
        return t20.findIndex((e9, i15) => i15 <= s20 ? false : !n12.resolveDisabled(e9));
      case 3: {
        let e9 = t20.slice().reverse().findIndex((i15) => !n12.resolveDisabled(i15));
        return e9 === -1 ? e9 : t20.length - 1 - e9;
      }
      case 4:
        return t20.findIndex((e9) => n12.resolveId(e9) === r15.id);
      case 5:
        return null;
      default:
        f5(r15);
    }
  })();
  return d17 === -1 ? l14 : d17;
}

// node_modules/@headlessui/react/dist/utils/render.js
var import_react28 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/utils/class-names.js
function e5(...n12) {
  return n12.filter(Boolean).join(" ");
}

// node_modules/@headlessui/react/dist/utils/render.js
var S3 = ((a13) => (a13[a13.None = 0] = "None", a13[a13.RenderStrategy = 1] = "RenderStrategy", a13[a13.Static = 2] = "Static", a13))(S3 || {});
var j2 = ((e9) => (e9[e9.Unmount = 0] = "Unmount", e9[e9.Hidden = 1] = "Hidden", e9))(j2 || {});
function X2({ ourProps: r15, theirProps: t20, slot: e9, defaultTag: a13, features: s20, visible: n12 = true, name: f16 }) {
  let o16 = N3(t20, r15);
  if (n12)
    return c6(o16, e9, a13, f16);
  let u11 = s20 != null ? s20 : 0;
  if (u11 & 2) {
    let { static: l14 = false, ...p12 } = o16;
    if (l14)
      return c6(p12, e9, a13, f16);
  }
  if (u11 & 1) {
    let { unmount: l14 = true, ...p12 } = o16;
    return u4(l14 ? 0 : 1, { [0]() {
      return null;
    }, [1]() {
      return c6({ ...p12, hidden: true, style: { display: "none" } }, e9, a13, f16);
    } });
  }
  return c6(o16, e9, a13, f16);
}
function c6(r15, t20 = {}, e9, a13) {
  let { as: s20 = e9, children: n12, refName: f16 = "ref", ...o16 } = g3(r15, ["unmount", "static"]), u11 = r15.ref !== void 0 ? { [f16]: r15.ref } : {}, l14 = typeof n12 == "function" ? n12(t20) : n12;
  "className" in o16 && o16.className && typeof o16.className == "function" && (o16.className = o16.className(t20));
  let p12 = {};
  if (t20) {
    let i15 = false, m10 = [];
    for (let [y9, d17] of Object.entries(t20))
      typeof d17 == "boolean" && (i15 = true), d17 === true && m10.push(y9);
    i15 && (p12["data-headlessui-state"] = m10.join(" "));
  }
  if (s20 === import_react28.Fragment && Object.keys(R2(o16)).length > 0) {
    if (!(0, import_react28.isValidElement)(l14) || Array.isArray(l14) && l14.length > 1)
      throw new Error(['Passing props on "Fragment"!', "", `The current component <${a13} /> is rendering a "Fragment".`, "However we need to passthrough the following props:", Object.keys(o16).map((d17) => `  - ${d17}`).join(`
`), "", "You can apply a few solutions:", ['Add an `as="..."` prop, to ensure that we render an actual element instead of a "Fragment".', "Render a single element as the child so that we can forward the props onto that element."].map((d17) => `  - ${d17}`).join(`
`)].join(`
`));
    let i15 = l14.props, m10 = typeof (i15 == null ? void 0 : i15.className) == "function" ? (...d17) => e5(i15 == null ? void 0 : i15.className(...d17), o16.className) : e5(i15 == null ? void 0 : i15.className, o16.className), y9 = m10 ? { className: m10 } : {};
    return (0, import_react28.cloneElement)(l14, Object.assign({}, N3(l14.props, R2(g3(o16, ["ref"]))), p12, u11, w4(l14.ref, u11.ref), y9));
  }
  return (0, import_react28.createElement)(s20, Object.assign({}, g3(o16, ["ref"]), s20 !== import_react28.Fragment && u11, s20 !== import_react28.Fragment && p12), l14);
}
function w4(...r15) {
  return { ref: r15.every((t20) => t20 == null) ? void 0 : (t20) => {
    for (let e9 of r15)
      e9 != null && (typeof e9 == "function" ? e9(t20) : e9.current = t20);
  } };
}
function N3(...r15) {
  var a13;
  if (r15.length === 0)
    return {};
  if (r15.length === 1)
    return r15[0];
  let t20 = {}, e9 = {};
  for (let s20 of r15)
    for (let n12 in s20)
      n12.startsWith("on") && typeof s20[n12] == "function" ? ((a13 = e9[n12]) != null || (e9[n12] = []), e9[n12].push(s20[n12])) : t20[n12] = s20[n12];
  if (t20.disabled || t20["aria-disabled"])
    return Object.assign(t20, Object.fromEntries(Object.keys(e9).map((s20) => [s20, void 0])));
  for (let s20 in e9)
    Object.assign(t20, { [s20](n12, ...f16) {
      let o16 = e9[s20];
      for (let u11 of o16) {
        if ((n12 instanceof Event || (n12 == null ? void 0 : n12.nativeEvent) instanceof Event) && n12.defaultPrevented)
          return;
        u11(n12, ...f16);
      }
    } });
  return t20;
}
function D3(r15) {
  var t20;
  return Object.assign((0, import_react28.forwardRef)(r15), { displayName: (t20 = r15.displayName) != null ? t20 : r15.name });
}
function R2(r15) {
  let t20 = Object.assign({}, r15);
  for (let e9 in t20)
    t20[e9] === void 0 && delete t20[e9];
  return t20;
}
function g3(r15, t20 = []) {
  let e9 = Object.assign({}, r15);
  for (let a13 of t20)
    a13 in e9 && delete e9[a13];
  return e9;
}

// node_modules/@headlessui/react/dist/utils/bugs.js
function r8(n12) {
  let e9 = n12.parentElement, l14 = null;
  for (; e9 && !(e9 instanceof HTMLFieldSetElement); )
    e9 instanceof HTMLLegendElement && (l14 = e9), e9 = e9.parentElement;
  let t20 = (e9 == null ? void 0 : e9.getAttribute("disabled")) === "";
  return t20 && i9(l14) ? false : t20;
}
function i9(n12) {
  if (!n12)
    return false;
  let e9 = n12.previousElementSibling;
  for (; e9 !== null; ) {
    if (e9 instanceof HTMLLegendElement)
      return false;
    e9 = e9.previousElementSibling;
  }
  return true;
}

// node_modules/@headlessui/react/dist/utils/form.js
function e6(n12 = {}, r15 = null, t20 = []) {
  for (let [i15, o16] of Object.entries(n12))
    f6(t20, s10(r15, i15), o16);
  return t20;
}
function s10(n12, r15) {
  return n12 ? n12 + "[" + r15 + "]" : r15;
}
function f6(n12, r15, t20) {
  if (Array.isArray(t20))
    for (let [i15, o16] of t20.entries())
      f6(n12, s10(r15, i15.toString()), o16);
  else
    t20 instanceof Date ? n12.push([r15, t20.toISOString()]) : typeof t20 == "boolean" ? n12.push([r15, t20 ? "1" : "0"]) : typeof t20 == "string" ? n12.push([r15, t20]) : typeof t20 == "number" ? n12.push([r15, `${t20}`]) : t20 == null ? n12.push([r15, ""]) : e6(t20, r15, n12);
}
function p5(n12) {
  var t20;
  let r15 = (t20 = n12 == null ? void 0 : n12.form) != null ? t20 : n12.closest("form");
  if (r15) {
    for (let i15 of r15.elements)
      if (i15.tagName === "INPUT" && i15.type === "submit" || i15.tagName === "BUTTON" && i15.type === "submit" || i15.nodeName === "INPUT" && i15.type === "image") {
        i15.click();
        return;
      }
  }
}

// node_modules/@headlessui/react/dist/internal/hidden.js
var a5 = "div";
var p6 = ((e9) => (e9[e9.None = 1] = "None", e9[e9.Focusable = 2] = "Focusable", e9[e9.Hidden = 4] = "Hidden", e9))(p6 || {});
function s11(t20, o16) {
  let { features: n12 = 1, ...e9 } = t20, d17 = { ref: o16, "aria-hidden": (n12 & 2) === 2 ? true : void 0, style: { position: "fixed", top: 1, left: 1, width: 1, height: 0, padding: 0, margin: -1, overflow: "hidden", clip: "rect(0, 0, 0, 0)", whiteSpace: "nowrap", borderWidth: "0", ...(n12 & 4) === 4 && (n12 & 2) !== 2 && { display: "none" } } };
  return X2({ ourProps: d17, theirProps: e9, slot: {}, defaultTag: a5, name: "Hidden" });
}
var c7 = D3(s11);

// node_modules/@headlessui/react/dist/internal/open-closed.js
var import_react29 = __toESM(require_react(), 1);
var n7 = (0, import_react29.createContext)(null);
n7.displayName = "OpenClosedContext";
var d6 = ((e9) => (e9[e9.Open = 1] = "Open", e9[e9.Closed = 2] = "Closed", e9[e9.Closing = 4] = "Closing", e9[e9.Opening = 8] = "Opening", e9))(d6 || {});
function C2() {
  return (0, import_react29.useContext)(n7);
}
function c8({ value: o16, children: r15 }) {
  return import_react29.default.createElement(n7.Provider, { value: o16 }, r15);
}

// node_modules/@headlessui/react/dist/components/keyboard.js
var o13 = ((r15) => (r15.Space = " ", r15.Enter = "Enter", r15.Escape = "Escape", r15.Backspace = "Backspace", r15.Delete = "Delete", r15.ArrowLeft = "ArrowLeft", r15.ArrowUp = "ArrowUp", r15.ArrowRight = "ArrowRight", r15.ArrowDown = "ArrowDown", r15.Home = "Home", r15.End = "End", r15.PageUp = "PageUp", r15.PageDown = "PageDown", r15.Tab = "Tab", r15))(o13 || {});

// node_modules/@headlessui/react/dist/hooks/use-controllable.js
var import_react30 = __toESM(require_react(), 1);
function T4(l14, r15, c16) {
  let [i15, s20] = (0, import_react30.useState)(c16), e9 = l14 !== void 0, t20 = (0, import_react30.useRef)(e9), u11 = (0, import_react30.useRef)(false), d17 = (0, import_react30.useRef)(false);
  return e9 && !t20.current && !u11.current ? (u11.current = true, t20.current = e9, console.error("A component is changing from uncontrolled to controlled. This may be caused by the value changing from undefined to a defined value, which should not happen.")) : !e9 && t20.current && !d17.current && (d17.current = true, t20.current = e9, console.error("A component is changing from controlled to uncontrolled. This may be caused by the value changing from a defined value to undefined, which should not happen.")), [e9 ? l14 : i15, o9((n12) => (e9 || s20(n12), r15 == null ? void 0 : r15(n12)))];
}

// node_modules/@headlessui/react/dist/hooks/use-watch.js
var import_react31 = __toESM(require_react(), 1);
function m4(u11, t20) {
  let e9 = (0, import_react31.useRef)([]), r15 = o9(u11);
  (0, import_react31.useEffect)(() => {
    let o16 = [...e9.current];
    for (let [n12, a13] of t20.entries())
      if (e9.current[n12] !== a13) {
        let l14 = r15(t20, o16);
        return e9.current = t20, l14;
      }
  }, [r15, ...t20]);
}

// node_modules/@headlessui/react/dist/hooks/use-tracked-pointer.js
var import_react32 = __toESM(require_react(), 1);
function t11(e9) {
  return [e9.screenX, e9.screenY];
}
function u6() {
  let e9 = (0, import_react32.useRef)([-1, -1]);
  return { wasMoved(r15) {
    let n12 = t11(r15);
    return e9.current[0] === n12[0] && e9.current[1] === n12[1] ? false : (e9.current = n12, true);
  }, update(r15) {
    e9.current = t11(r15);
  } };
}

// node_modules/@headlessui/react/dist/utils/platform.js
function t12() {
  return /iPhone/gi.test(window.navigator.platform) || /Mac/gi.test(window.navigator.platform) && window.navigator.maxTouchPoints > 0;
}
function i10() {
  return /Android/gi.test(window.navigator.userAgent);
}
function n8() {
  return t12() || i10();
}

// node_modules/@headlessui/react/dist/components/combobox/combobox.js
var ke = ((e9) => (e9[e9.Open = 0] = "Open", e9[e9.Closed = 1] = "Closed", e9))(ke || {});
var we = ((e9) => (e9[e9.Single = 0] = "Single", e9[e9.Multi = 1] = "Multi", e9))(we || {});
var Ue = ((e9) => (e9[e9.Pointer = 0] = "Pointer", e9[e9.Other = 1] = "Other", e9))(Ue || {});
var Ne = ((n12) => (n12[n12.OpenCombobox = 0] = "OpenCombobox", n12[n12.CloseCombobox = 1] = "CloseCombobox", n12[n12.GoToOption = 2] = "GoToOption", n12[n12.RegisterOption = 3] = "RegisterOption", n12[n12.UnregisterOption = 4] = "UnregisterOption", n12[n12.RegisterLabel = 5] = "RegisterLabel", n12))(Ne || {});
function re(t20, l14 = (e9) => e9) {
  let e9 = t20.activeOptionIndex !== null ? t20.options[t20.activeOptionIndex] : null, r15 = I3(l14(t20.options.slice()), (b6) => b6.dataRef.current.domRef.current), i15 = e9 ? r15.indexOf(e9) : null;
  return i15 === -1 && (i15 = null), { options: r15, activeOptionIndex: i15 };
}
var He = { [1](t20) {
  var l14;
  return (l14 = t20.dataRef.current) != null && l14.disabled || t20.comboboxState === 1 ? t20 : { ...t20, activeOptionIndex: null, comboboxState: 1 };
}, [0](t20) {
  var e9;
  if ((e9 = t20.dataRef.current) != null && e9.disabled || t20.comboboxState === 0)
    return t20;
  let l14 = t20.activeOptionIndex;
  if (t20.dataRef.current) {
    let { isSelected: r15 } = t20.dataRef.current, i15 = t20.options.findIndex((b6) => r15(b6.dataRef.current.value));
    i15 !== -1 && (l14 = i15);
  }
  return { ...t20, comboboxState: 0, activeOptionIndex: l14 };
}, [2](t20, l14) {
  var i15, b6, n12, d17;
  if ((i15 = t20.dataRef.current) != null && i15.disabled || (b6 = t20.dataRef.current) != null && b6.optionsRef.current && !((n12 = t20.dataRef.current) != null && n12.optionsPropsRef.current.static) && t20.comboboxState === 1)
    return t20;
  let e9 = re(t20);
  if (e9.activeOptionIndex === null) {
    let o16 = e9.options.findIndex((u11) => !u11.dataRef.current.disabled);
    o16 !== -1 && (e9.activeOptionIndex = o16);
  }
  let r15 = x2(l14, { resolveItems: () => e9.options, resolveActiveIndex: () => e9.activeOptionIndex, resolveId: (o16) => o16.id, resolveDisabled: (o16) => o16.dataRef.current.disabled });
  return { ...t20, ...e9, activeOptionIndex: r15, activationTrigger: (d17 = l14.trigger) != null ? d17 : 1 };
}, [3]: (t20, l14) => {
  var b6, n12;
  let e9 = { id: l14.id, dataRef: l14.dataRef }, r15 = re(t20, (d17) => [...d17, e9]);
  t20.activeOptionIndex === null && (b6 = t20.dataRef.current) != null && b6.isSelected(l14.dataRef.current.value) && (r15.activeOptionIndex = r15.options.indexOf(e9));
  let i15 = { ...t20, ...r15, activationTrigger: 1 };
  return (n12 = t20.dataRef.current) != null && n12.__demoMode && t20.dataRef.current.value === void 0 && (i15.activeOptionIndex = 0), i15;
}, [4]: (t20, l14) => {
  let e9 = re(t20, (r15) => {
    let i15 = r15.findIndex((b6) => b6.id === l14.id);
    return i15 !== -1 && r15.splice(i15, 1), r15;
  });
  return { ...t20, ...e9, activationTrigger: 1 };
}, [5]: (t20, l14) => ({ ...t20, labelId: l14.id }) };
var ae = (0, import_react33.createContext)(null);
ae.displayName = "ComboboxActionsContext";
function $(t20) {
  let l14 = (0, import_react33.useContext)(ae);
  if (l14 === null) {
    let e9 = new Error(`<${t20} /> is missing a parent <Combobox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(e9, $), e9;
  }
  return l14;
}
var le = (0, import_react33.createContext)(null);
le.displayName = "ComboboxDataContext";
function H3(t20) {
  let l14 = (0, import_react33.useContext)(le);
  if (l14 === null) {
    let e9 = new Error(`<${t20} /> is missing a parent <Combobox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(e9, H3), e9;
  }
  return l14;
}
function Ge(t20, l14) {
  return u4(l14.type, He, t20, l14);
}
var Xe = import_react33.Fragment;
function je(t20, l14) {
  let { value: e9, defaultValue: r15, onChange: i15, form: b6, name: n12, by: d17 = (p12, T7) => p12 === T7, disabled: o16 = false, __demoMode: u11 = false, nullable: P6 = false, multiple: f16 = false, ...E8 } = t20, [c16 = f16 ? [] : void 0, g6] = T4(e9, i15, r15), [m10, x7] = (0, import_react33.useReducer)(Ge, { dataRef: (0, import_react33.createRef)(), comboboxState: u11 ? 0 : 1, options: [], activeOptionIndex: null, activationTrigger: 1, labelId: null }), L6 = (0, import_react33.useRef)(false), F9 = (0, import_react33.useRef)({ static: false, hold: false }), h11 = (0, import_react33.useRef)(null), B5 = (0, import_react33.useRef)(null), k3 = (0, import_react33.useRef)(null), G5 = (0, import_react33.useRef)(null), V7 = o9(typeof d17 == "string" ? (p12, T7) => {
    let R4 = d17;
    return (p12 == null ? void 0 : p12[R4]) === (T7 == null ? void 0 : T7[R4]);
  } : d17), M10 = (0, import_react33.useCallback)((p12) => u4(s20.mode, { [1]: () => c16.some((T7) => V7(T7, p12)), [0]: () => V7(c16, p12) }), [c16]), s20 = (0, import_react33.useMemo)(() => ({ ...m10, optionsPropsRef: F9, labelRef: h11, inputRef: B5, buttonRef: k3, optionsRef: G5, value: c16, defaultValue: r15, disabled: o16, mode: f16 ? 1 : 0, get activeOptionIndex() {
    if (L6.current && m10.activeOptionIndex === null && m10.options.length > 0) {
      let p12 = m10.options.findIndex((T7) => !T7.dataRef.current.disabled);
      if (p12 !== -1)
        return p12;
    }
    return m10.activeOptionIndex;
  }, compare: V7, isSelected: M10, nullable: P6, __demoMode: u11 }), [c16, r15, o16, f16, P6, u11, m10]), O5 = (0, import_react33.useRef)(s20.activeOptionIndex !== null ? s20.options[s20.activeOptionIndex] : null);
  (0, import_react33.useEffect)(() => {
    let p12 = s20.activeOptionIndex !== null ? s20.options[s20.activeOptionIndex] : null;
    O5.current !== p12 && (O5.current = p12);
  }), l5(() => {
    m10.dataRef.current = s20;
  }, [s20]), L2([s20.buttonRef, s20.inputRef, s20.optionsRef], () => oe4.closeCombobox(), s20.comboboxState === 0);
  let a13 = (0, import_react33.useMemo)(() => ({ open: s20.comboboxState === 0, disabled: o16, activeIndex: s20.activeOptionIndex, activeOption: s20.activeOptionIndex === null ? null : s20.options[s20.activeOptionIndex].dataRef.current.value, value: c16 }), [s20, o16, c16]), I9 = o9((p12) => {
    let T7 = s20.options.find((R4) => R4.id === p12);
    T7 && j6(T7.dataRef.current.value);
  }), S11 = o9(() => {
    if (s20.activeOptionIndex !== null) {
      let { dataRef: p12, id: T7 } = s20.options[s20.activeOptionIndex];
      j6(p12.current.value), oe4.goToOption(a4.Specific, T7);
    }
  }), X10 = o9(() => {
    x7({ type: 0 }), L6.current = true;
  }), q7 = o9(() => {
    x7({ type: 1 }), L6.current = false;
  }), Q7 = o9((p12, T7, R4) => (L6.current = false, p12 === a4.Specific ? x7({ type: 2, focus: a4.Specific, id: T7, trigger: R4 }) : x7({ type: 2, focus: p12, trigger: R4 }))), Y8 = o9((p12, T7) => (x7({ type: 3, id: p12, dataRef: T7 }), () => {
    var R4;
    ((R4 = O5.current) == null ? void 0 : R4.id) === p12 && (L6.current = true), x7({ type: 4, id: p12 });
  })), ce4 = o9((p12) => (x7({ type: 5, id: p12 }), () => x7({ type: 5, id: null }))), j6 = o9((p12) => u4(s20.mode, { [0]() {
    return g6 == null ? void 0 : g6(p12);
  }, [1]() {
    let T7 = s20.value.slice(), R4 = T7.findIndex((J4) => V7(J4, p12));
    return R4 === -1 ? T7.push(p12) : T7.splice(R4, 1), g6 == null ? void 0 : g6(T7);
  } })), oe4 = (0, import_react33.useMemo)(() => ({ onChange: j6, registerOption: Y8, registerLabel: ce4, goToOption: Q7, closeCombobox: q7, openCombobox: X10, selectActiveOption: S11, selectOption: I9 }), []), Te4 = l14 === null ? {} : { ref: l14 }, Z7 = (0, import_react33.useRef)(null), me4 = p4();
  return (0, import_react33.useEffect)(() => {
    Z7.current && r15 !== void 0 && me4.addEventListener(Z7.current, "reset", () => {
      j6(r15);
    });
  }, [Z7, j6]), import_react33.default.createElement(ae.Provider, { value: oe4 }, import_react33.default.createElement(le.Provider, { value: s20 }, import_react33.default.createElement(c8, { value: u4(s20.comboboxState, { [0]: d6.Open, [1]: d6.Closed }) }, n12 != null && c16 != null && e6({ [n12]: c16 }).map(([p12, T7], R4) => import_react33.default.createElement(c7, { features: p6.Hidden, ref: R4 === 0 ? (J4) => {
    var ie4;
    Z7.current = (ie4 = J4 == null ? void 0 : J4.closest("form")) != null ? ie4 : null;
  } : void 0, ...R2({ key: p12, as: "input", type: "hidden", hidden: true, readOnly: true, form: b6, name: p12, value: T7 }) })), X2({ ourProps: Te4, theirProps: E8, slot: a13, defaultTag: Xe, name: "Combobox" }))));
}
var Je = "input";
function Ke(t20, l14) {
  var V7, M10, s20, O5;
  let e9 = I2(), { id: r15 = `headlessui-combobox-input-${e9}`, onChange: i15, displayValue: b6, type: n12 = "text", ...d17 } = t20, o16 = H3("Combobox.Input"), u11 = $("Combobox.Input"), P6 = y4(o16.inputRef, l14), f16 = (0, import_react33.useRef)(false), E8 = p4(), c16 = function() {
    var a13;
    return typeof b6 == "function" && o16.value !== void 0 ? (a13 = b6(o16.value)) != null ? a13 : "" : typeof o16.value == "string" ? o16.value : "";
  }();
  m4(([a13, I9], [S11, X10]) => {
    f16.current || o16.inputRef.current && (X10 === 0 && I9 === 1 || a13 !== S11) && (o16.inputRef.current.value = a13);
  }, [c16, o16.comboboxState]), m4(([a13], [I9]) => {
    if (a13 === 0 && I9 === 1) {
      let S11 = o16.inputRef.current;
      if (!S11)
        return;
      let X10 = S11.value, { selectionStart: q7, selectionEnd: Q7, selectionDirection: Y8 } = S11;
      S11.value = "", S11.value = X10, Y8 !== null ? S11.setSelectionRange(q7, Q7, Y8) : S11.setSelectionRange(q7, Q7);
    }
  }, [o16.comboboxState]);
  let g6 = (0, import_react33.useRef)(false), m10 = o9(() => {
    g6.current = true;
  }), x7 = o9(() => {
    setTimeout(() => {
      g6.current = false;
    });
  }), L6 = o9((a13) => {
    switch (f16.current = true, a13.key) {
      case o13.Backspace:
      case o13.Delete:
        if (o16.mode !== 0 || !o16.nullable)
          return;
        let I9 = a13.currentTarget;
        E8.requestAnimationFrame(() => {
          I9.value === "" && (u11.onChange(null), o16.optionsRef.current && (o16.optionsRef.current.scrollTop = 0), u11.goToOption(a4.Nothing));
        });
        break;
      case o13.Enter:
        if (f16.current = false, o16.comboboxState !== 0 || g6.current)
          return;
        if (a13.preventDefault(), a13.stopPropagation(), o16.activeOptionIndex === null) {
          u11.closeCombobox();
          return;
        }
        u11.selectActiveOption(), o16.mode === 0 && u11.closeCombobox();
        break;
      case o13.ArrowDown:
        return f16.current = false, a13.preventDefault(), a13.stopPropagation(), u4(o16.comboboxState, { [0]: () => {
          u11.goToOption(a4.Next);
        }, [1]: () => {
          u11.openCombobox();
        } });
      case o13.ArrowUp:
        return f16.current = false, a13.preventDefault(), a13.stopPropagation(), u4(o16.comboboxState, { [0]: () => {
          u11.goToOption(a4.Previous);
        }, [1]: () => {
          u11.openCombobox(), E8.nextFrame(() => {
            o16.value || u11.goToOption(a4.Last);
          });
        } });
      case o13.Home:
        if (a13.shiftKey)
          break;
        return f16.current = false, a13.preventDefault(), a13.stopPropagation(), u11.goToOption(a4.First);
      case o13.PageUp:
        return f16.current = false, a13.preventDefault(), a13.stopPropagation(), u11.goToOption(a4.First);
      case o13.End:
        if (a13.shiftKey)
          break;
        return f16.current = false, a13.preventDefault(), a13.stopPropagation(), u11.goToOption(a4.Last);
      case o13.PageDown:
        return f16.current = false, a13.preventDefault(), a13.stopPropagation(), u11.goToOption(a4.Last);
      case o13.Escape:
        return f16.current = false, o16.comboboxState !== 0 ? void 0 : (a13.preventDefault(), o16.optionsRef.current && !o16.optionsPropsRef.current.static && a13.stopPropagation(), u11.closeCombobox());
      case o13.Tab:
        if (f16.current = false, o16.comboboxState !== 0)
          return;
        o16.mode === 0 && u11.selectActiveOption(), u11.closeCombobox();
        break;
    }
  }), F9 = o9((a13) => {
    u11.openCombobox(), i15 == null || i15(a13);
  }), h11 = o9(() => {
    f16.current = false;
  }), B5 = i6(() => {
    if (o16.labelId)
      return [o16.labelId].join(" ");
  }, [o16.labelId]), k3 = (0, import_react33.useMemo)(() => ({ open: o16.comboboxState === 0, disabled: o16.disabled }), [o16]), G5 = { ref: P6, id: r15, role: "combobox", type: n12, "aria-controls": (V7 = o16.optionsRef.current) == null ? void 0 : V7.id, "aria-expanded": o16.disabled ? void 0 : o16.comboboxState === 0, "aria-activedescendant": o16.activeOptionIndex === null || (M10 = o16.options[o16.activeOptionIndex]) == null ? void 0 : M10.id, "aria-labelledby": B5, "aria-autocomplete": "list", defaultValue: (O5 = (s20 = t20.defaultValue) != null ? s20 : o16.defaultValue !== void 0 ? b6 == null ? void 0 : b6(o16.defaultValue) : null) != null ? O5 : o16.defaultValue, disabled: o16.disabled, onCompositionStart: m10, onCompositionEnd: x7, onKeyDown: L6, onChange: F9, onBlur: h11 };
  return X2({ ourProps: G5, theirProps: d17, slot: k3, defaultTag: Je, name: "Combobox.Input" });
}
var We = "button";
function $e(t20, l14) {
  var g6;
  let e9 = H3("Combobox.Button"), r15 = $("Combobox.Button"), i15 = y4(e9.buttonRef, l14), b6 = I2(), { id: n12 = `headlessui-combobox-button-${b6}`, ...d17 } = t20, o16 = p4(), u11 = o9((m10) => {
    switch (m10.key) {
      case o13.ArrowDown:
        return m10.preventDefault(), m10.stopPropagation(), e9.comboboxState === 1 && r15.openCombobox(), o16.nextFrame(() => {
          var x7;
          return (x7 = e9.inputRef.current) == null ? void 0 : x7.focus({ preventScroll: true });
        });
      case o13.ArrowUp:
        return m10.preventDefault(), m10.stopPropagation(), e9.comboboxState === 1 && (r15.openCombobox(), o16.nextFrame(() => {
          e9.value || r15.goToOption(a4.Last);
        })), o16.nextFrame(() => {
          var x7;
          return (x7 = e9.inputRef.current) == null ? void 0 : x7.focus({ preventScroll: true });
        });
      case o13.Escape:
        return e9.comboboxState !== 0 ? void 0 : (m10.preventDefault(), e9.optionsRef.current && !e9.optionsPropsRef.current.static && m10.stopPropagation(), r15.closeCombobox(), o16.nextFrame(() => {
          var x7;
          return (x7 = e9.inputRef.current) == null ? void 0 : x7.focus({ preventScroll: true });
        }));
      default:
        return;
    }
  }), P6 = o9((m10) => {
    if (r8(m10.currentTarget))
      return m10.preventDefault();
    e9.comboboxState === 0 ? r15.closeCombobox() : (m10.preventDefault(), r15.openCombobox()), o16.nextFrame(() => {
      var x7;
      return (x7 = e9.inputRef.current) == null ? void 0 : x7.focus({ preventScroll: true });
    });
  }), f16 = i6(() => {
    if (e9.labelId)
      return [e9.labelId, n12].join(" ");
  }, [e9.labelId, n12]), E8 = (0, import_react33.useMemo)(() => ({ open: e9.comboboxState === 0, disabled: e9.disabled, value: e9.value }), [e9]), c16 = { ref: i15, id: n12, type: s9(t20, e9.buttonRef), tabIndex: -1, "aria-haspopup": "listbox", "aria-controls": (g6 = e9.optionsRef.current) == null ? void 0 : g6.id, "aria-expanded": e9.disabled ? void 0 : e9.comboboxState === 0, "aria-labelledby": f16, disabled: e9.disabled, onClick: P6, onKeyDown: u11 };
  return X2({ ourProps: c16, theirProps: d17, slot: E8, defaultTag: We, name: "Combobox.Button" });
}
var qe = "label";
function Qe(t20, l14) {
  let e9 = I2(), { id: r15 = `headlessui-combobox-label-${e9}`, ...i15 } = t20, b6 = H3("Combobox.Label"), n12 = $("Combobox.Label"), d17 = y4(b6.labelRef, l14);
  l5(() => n12.registerLabel(r15), [r15]);
  let o16 = o9(() => {
    var f16;
    return (f16 = b6.inputRef.current) == null ? void 0 : f16.focus({ preventScroll: true });
  }), u11 = (0, import_react33.useMemo)(() => ({ open: b6.comboboxState === 0, disabled: b6.disabled }), [b6]);
  return X2({ ourProps: { ref: d17, id: r15, onClick: o16 }, theirProps: i15, slot: u11, defaultTag: qe, name: "Combobox.Label" });
}
var Ye = "ul";
var Ze = S3.RenderStrategy | S3.Static;
function ze(t20, l14) {
  let e9 = I2(), { id: r15 = `headlessui-combobox-options-${e9}`, hold: i15 = false, ...b6 } = t20, n12 = H3("Combobox.Options"), d17 = y4(n12.optionsRef, l14), o16 = C2(), u11 = (() => o16 !== null ? (o16 & d6.Open) === d6.Open : n12.comboboxState === 0)();
  l5(() => {
    var c16;
    n12.optionsPropsRef.current.static = (c16 = t20.static) != null ? c16 : false;
  }, [n12.optionsPropsRef, t20.static]), l5(() => {
    n12.optionsPropsRef.current.hold = i15;
  }, [n12.optionsPropsRef, i15]), F2({ container: n12.optionsRef.current, enabled: n12.comboboxState === 0, accept(c16) {
    return c16.getAttribute("role") === "option" ? NodeFilter.FILTER_REJECT : c16.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(c16) {
    c16.setAttribute("role", "none");
  } });
  let P6 = i6(() => {
    var c16, g6;
    return (g6 = n12.labelId) != null ? g6 : (c16 = n12.buttonRef.current) == null ? void 0 : c16.id;
  }, [n12.labelId, n12.buttonRef.current]), f16 = (0, import_react33.useMemo)(() => ({ open: n12.comboboxState === 0 }), [n12]), E8 = { "aria-labelledby": P6, role: "listbox", "aria-multiselectable": n12.mode === 1 ? true : void 0, id: r15, ref: d17 };
  return X2({ ourProps: E8, theirProps: b6, slot: f16, defaultTag: Ye, features: Ze, visible: u11, name: "Combobox.Options" });
}
var eo = "li";
function oo(t20, l14) {
  var M10, s20;
  let e9 = I2(), { id: r15 = `headlessui-combobox-option-${e9}`, disabled: i15 = false, value: b6, ...n12 } = t20, d17 = H3("Combobox.Option"), o16 = $("Combobox.Option"), u11 = d17.activeOptionIndex !== null ? d17.options[d17.activeOptionIndex].id === r15 : false, P6 = d17.isSelected(b6), f16 = (0, import_react33.useRef)(null), E8 = s5({ disabled: i15, value: b6, domRef: f16, textValue: (s20 = (M10 = f16.current) == null ? void 0 : M10.textContent) == null ? void 0 : s20.toLowerCase() }), c16 = y4(l14, f16), g6 = o9(() => o16.selectOption(r15));
  l5(() => o16.registerOption(r15, E8), [E8, r15]);
  let m10 = (0, import_react33.useRef)(!d17.__demoMode);
  l5(() => {
    if (!d17.__demoMode)
      return;
    let O5 = o7();
    return O5.requestAnimationFrame(() => {
      m10.current = true;
    }), O5.dispose;
  }, []), l5(() => {
    if (d17.comboboxState !== 0 || !u11 || !m10.current || d17.activationTrigger === 0)
      return;
    let O5 = o7();
    return O5.requestAnimationFrame(() => {
      var a13, I9;
      (I9 = (a13 = f16.current) == null ? void 0 : a13.scrollIntoView) == null || I9.call(a13, { block: "nearest" });
    }), O5.dispose;
  }, [f16, u11, d17.comboboxState, d17.activationTrigger, d17.activeOptionIndex]);
  let x7 = o9((O5) => {
    if (i15)
      return O5.preventDefault();
    g6(), d17.mode === 0 && o16.closeCombobox(), n8() || requestAnimationFrame(() => {
      var a13;
      return (a13 = d17.inputRef.current) == null ? void 0 : a13.focus();
    });
  }), L6 = o9(() => {
    if (i15)
      return o16.goToOption(a4.Nothing);
    o16.goToOption(a4.Specific, r15);
  }), F9 = u6(), h11 = o9((O5) => F9.update(O5)), B5 = o9((O5) => {
    F9.wasMoved(O5) && (i15 || u11 || o16.goToOption(a4.Specific, r15, 0));
  }), k3 = o9((O5) => {
    F9.wasMoved(O5) && (i15 || u11 && (d17.optionsPropsRef.current.hold || o16.goToOption(a4.Nothing)));
  }), G5 = (0, import_react33.useMemo)(() => ({ active: u11, selected: P6, disabled: i15 }), [u11, P6, i15]);
  return X2({ ourProps: { id: r15, ref: c16, role: "option", tabIndex: i15 === true ? void 0 : -1, "aria-disabled": i15 === true ? true : void 0, "aria-selected": P6, disabled: void 0, onClick: x7, onFocus: L6, onPointerEnter: h11, onMouseEnter: h11, onPointerMove: B5, onMouseMove: B5, onPointerLeave: k3, onMouseLeave: k3 }, theirProps: n12, slot: G5, defaultTag: eo, name: "Combobox.Option" });
}
var to = D3(je);
var no = D3($e);
var ro = D3(Ke);
var ao = D3(Qe);
var lo = D3(ze);
var io = D3(oo);
var Wo = Object.assign(to, { Input: ro, Button: no, Label: ao, Options: lo, Option: io });

// node_modules/@headlessui/react/dist/components/dialog/dialog.js
var import_react44 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/components/focus-trap/focus-trap.js
var import_react39 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/hooks/use-tab-direction.js
var import_react35 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/hooks/use-window-event.js
var import_react34 = __toESM(require_react(), 1);
function s13(e9, r15, n12) {
  let o16 = s5(r15);
  (0, import_react34.useEffect)(() => {
    function t20(i15) {
      o16.current(i15);
    }
    return window.addEventListener(e9, t20, n12), () => window.removeEventListener(e9, t20, n12);
  }, [e9, n12]);
}

// node_modules/@headlessui/react/dist/hooks/use-tab-direction.js
var s14 = ((r15) => (r15[r15.Forwards = 0] = "Forwards", r15[r15.Backwards = 1] = "Backwards", r15))(s14 || {});
function n9() {
  let e9 = (0, import_react35.useRef)(0);
  return s13("keydown", (o16) => {
    o16.key === "Tab" && (e9.current = o16.shiftKey ? 1 : 0);
  }, true), e9;
}

// node_modules/@headlessui/react/dist/hooks/use-is-mounted.js
var import_react36 = __toESM(require_react(), 1);
function f9() {
  let e9 = (0, import_react36.useRef)(false);
  return l5(() => (e9.current = true, () => {
    e9.current = false;
  }), []), e9;
}

// node_modules/@headlessui/react/dist/hooks/use-owner.js
var import_react37 = __toESM(require_react(), 1);
function n10(...e9) {
  return (0, import_react37.useMemo)(() => e4(...e9), [...e9]);
}

// node_modules/@headlessui/react/dist/hooks/use-event-listener.js
var import_react38 = __toESM(require_react(), 1);
function E5(n12, e9, a13, t20) {
  let i15 = s5(a13);
  (0, import_react38.useEffect)(() => {
    n12 = n12 != null ? n12 : window;
    function r15(o16) {
      i15.current(o16);
    }
    return n12.addEventListener(e9, r15, t20), () => n12.removeEventListener(e9, r15, t20);
  }, [n12, e9, t20]);
}

// node_modules/@headlessui/react/dist/utils/document-ready.js
function t15(n12) {
  function e9() {
    document.readyState !== "loading" && (n12(), document.removeEventListener("DOMContentLoaded", e9));
  }
  typeof window != "undefined" && typeof document != "undefined" && (document.addEventListener("DOMContentLoaded", e9), e9());
}

// node_modules/@headlessui/react/dist/components/focus-trap/focus-trap.js
function P2(t20) {
  if (!t20)
    return /* @__PURE__ */ new Set();
  if (typeof t20 == "function")
    return new Set(t20());
  let n12 = /* @__PURE__ */ new Set();
  for (let e9 of t20.current)
    e9.current instanceof HTMLElement && n12.add(e9.current);
  return n12;
}
var J = "div";
var h5 = ((r15) => (r15[r15.None = 1] = "None", r15[r15.InitialFocus = 2] = "InitialFocus", r15[r15.TabLock = 4] = "TabLock", r15[r15.FocusLock = 8] = "FocusLock", r15[r15.RestoreFocus = 16] = "RestoreFocus", r15[r15.All = 30] = "All", r15))(h5 || {});
function X3(t20, n12) {
  let e9 = (0, import_react39.useRef)(null), o16 = y4(e9, n12), { initialFocus: u11, containers: i15, features: r15 = 30, ...l14 } = t20;
  l6() || (r15 = 1);
  let m10 = n10(e9);
  Y2({ ownerDocument: m10 }, Boolean(r15 & 16));
  let c16 = Z2({ ownerDocument: m10, container: e9, initialFocus: u11 }, Boolean(r15 & 2));
  $2({ ownerDocument: m10, container: e9, containers: i15, previousActiveElement: c16 }, Boolean(r15 & 8));
  let v6 = n9(), R4 = o9((s20) => {
    let T7 = e9.current;
    if (!T7)
      return;
    ((B5) => B5())(() => {
      u4(v6.current, { [s14.Forwards]: () => {
        O2(T7, M2.First, { skipElements: [s20.relatedTarget] });
      }, [s14.Backwards]: () => {
        O2(T7, M2.Last, { skipElements: [s20.relatedTarget] });
      } });
    });
  }), _7 = p4(), H9 = (0, import_react39.useRef)(false), j6 = { ref: o16, onKeyDown(s20) {
    s20.key == "Tab" && (H9.current = true, _7.requestAnimationFrame(() => {
      H9.current = false;
    }));
  }, onBlur(s20) {
    let T7 = P2(i15);
    e9.current instanceof HTMLElement && T7.add(e9.current);
    let E8 = s20.relatedTarget;
    E8 instanceof HTMLElement && E8.dataset.headlessuiFocusGuard !== "true" && (S4(T7, E8) || (H9.current ? O2(e9.current, u4(v6.current, { [s14.Forwards]: () => M2.Next, [s14.Backwards]: () => M2.Previous }) | M2.WrapAround, { relativeTo: s20.target }) : s20.target instanceof HTMLElement && y3(s20.target)));
  } };
  return import_react39.default.createElement(import_react39.default.Fragment, null, Boolean(r15 & 4) && import_react39.default.createElement(c7, { as: "button", type: "button", "data-headlessui-focus-guard": true, onFocus: R4, features: p6.Focusable }), X2({ ourProps: j6, theirProps: l14, defaultTag: J, name: "FocusTrap" }), Boolean(r15 & 4) && import_react39.default.createElement(c7, { as: "button", type: "button", "data-headlessui-focus-guard": true, onFocus: R4, features: p6.Focusable }));
}
var z4 = D3(X3);
var Re = Object.assign(z4, { features: h5 });
var a6 = [];
t15(() => {
  function t20(n12) {
    n12.target instanceof HTMLElement && n12.target !== document.body && a6[0] !== n12.target && (a6.unshift(n12.target), a6 = a6.filter((e9) => e9 != null && e9.isConnected), a6.splice(10));
  }
  window.addEventListener("click", t20, { capture: true }), window.addEventListener("mousedown", t20, { capture: true }), window.addEventListener("focus", t20, { capture: true }), document.body.addEventListener("click", t20, { capture: true }), document.body.addEventListener("mousedown", t20, { capture: true }), document.body.addEventListener("focus", t20, { capture: true });
});
function Q2(t20 = true) {
  let n12 = (0, import_react39.useRef)(a6.slice());
  return m4(([e9], [o16]) => {
    o16 === true && e9 === false && t8(() => {
      n12.current.splice(0);
    }), o16 === false && e9 === true && (n12.current = a6.slice());
  }, [t20, a6, n12]), o9(() => {
    var e9;
    return (e9 = n12.current.find((o16) => o16 != null && o16.isConnected)) != null ? e9 : null;
  });
}
function Y2({ ownerDocument: t20 }, n12) {
  let e9 = Q2(n12);
  m4(() => {
    n12 || (t20 == null ? void 0 : t20.activeElement) === (t20 == null ? void 0 : t20.body) && y3(e9());
  }, [n12]);
  let o16 = (0, import_react39.useRef)(false);
  (0, import_react39.useEffect)(() => (o16.current = false, () => {
    o16.current = true, t8(() => {
      o16.current && y3(e9());
    });
  }), []);
}
function Z2({ ownerDocument: t20, container: n12, initialFocus: e9 }, o16) {
  let u11 = (0, import_react39.useRef)(null), i15 = f9();
  return m4(() => {
    if (!o16)
      return;
    let r15 = n12.current;
    r15 && t8(() => {
      if (!i15.current)
        return;
      let l14 = t20 == null ? void 0 : t20.activeElement;
      if (e9 != null && e9.current) {
        if ((e9 == null ? void 0 : e9.current) === l14) {
          u11.current = l14;
          return;
        }
      } else if (r15.contains(l14)) {
        u11.current = l14;
        return;
      }
      e9 != null && e9.current ? y3(e9.current) : O2(r15, M2.First) === N2.Error && console.warn("There are no focusable elements inside the <FocusTrap />"), u11.current = t20 == null ? void 0 : t20.activeElement;
    });
  }, [o16]), u11;
}
function $2({ ownerDocument: t20, container: n12, containers: e9, previousActiveElement: o16 }, u11) {
  let i15 = f9();
  E5(t20 == null ? void 0 : t20.defaultView, "focus", (r15) => {
    if (!u11 || !i15.current)
      return;
    let l14 = P2(e9);
    n12.current instanceof HTMLElement && l14.add(n12.current);
    let m10 = o16.current;
    if (!m10)
      return;
    let c16 = r15.target;
    c16 && c16 instanceof HTMLElement ? S4(l14, c16) ? (o16.current = c16, y3(c16)) : (r15.preventDefault(), r15.stopPropagation(), y3(m10)) : y3(o16.current);
  }, true);
}
function S4(t20, n12) {
  for (let e9 of t20)
    if (e9.contains(n12))
      return true;
  return false;
}

// node_modules/@headlessui/react/dist/components/portal/portal.js
var import_react41 = __toESM(require_react(), 1);
var import_react_dom5 = __toESM(require_react_dom(), 1);

// node_modules/@headlessui/react/dist/internal/portal-force-root.js
var import_react40 = __toESM(require_react(), 1);
var e7 = (0, import_react40.createContext)(false);
function l9() {
  return (0, import_react40.useContext)(e7);
}
function P3(o16) {
  return import_react40.default.createElement(e7.Provider, { value: o16.force }, o16.children);
}

// node_modules/@headlessui/react/dist/components/portal/portal.js
function H4(u11) {
  let a13 = l9(), o16 = (0, import_react41.useContext)(c10), e9 = n10(u11), [l14, n12] = (0, import_react41.useState)(() => {
    if (!a13 && o16 !== null || s4.isServer)
      return null;
    let t20 = e9 == null ? void 0 : e9.getElementById("headlessui-portal-root");
    if (t20)
      return t20;
    if (e9 === null)
      return null;
    let r15 = e9.createElement("div");
    return r15.setAttribute("id", "headlessui-portal-root"), e9.body.appendChild(r15);
  });
  return (0, import_react41.useEffect)(() => {
    l14 !== null && (e9 != null && e9.body.contains(l14) || e9 == null || e9.body.appendChild(l14));
  }, [l14, e9]), (0, import_react41.useEffect)(() => {
    a13 || o16 !== null && n12(o16.current);
  }, [o16, n12, a13]), l14;
}
var O3 = import_react41.Fragment;
function _3(u11, a13) {
  let o16 = u11, e9 = (0, import_react41.useRef)(null), l14 = y4(T2((p12) => {
    e9.current = p12;
  }), a13), n12 = n10(e9), t20 = H4(e9), [r15] = (0, import_react41.useState)(() => {
    var p12;
    return s4.isServer ? null : (p12 = n12 == null ? void 0 : n12.createElement("div")) != null ? p12 : null;
  }), y9 = l6(), f16 = (0, import_react41.useRef)(false);
  return l5(() => {
    if (f16.current = false, !(!t20 || !r15))
      return t20.contains(r15) || (r15.setAttribute("data-headlessui-portal", ""), t20.appendChild(r15)), () => {
        f16.current = true, t8(() => {
          var p12;
          f16.current && (!t20 || !r15 || (r15 instanceof Node && t20.contains(r15) && t20.removeChild(r15), t20.childNodes.length <= 0 && ((p12 = t20.parentElement) == null || p12.removeChild(t20))));
        });
      };
  }, [t20, r15]), y9 ? !t20 || !r15 ? null : (0, import_react_dom5.createPortal)(X2({ ourProps: { ref: l14 }, theirProps: o16, defaultTag: O3, name: "Portal" }), r15) : null;
}
var F3 = import_react41.Fragment;
var c10 = (0, import_react41.createContext)(null);
function U3(u11, a13) {
  let { target: o16, ...e9 } = u11, n12 = { ref: y4(a13) };
  return import_react41.default.createElement(c10.Provider, { value: o16 }, X2({ ourProps: n12, theirProps: e9, defaultTag: F3, name: "Popover.Group" }));
}
var S5 = D3(_3);
var j3 = D3(U3);
var te = Object.assign(S5, { Group: j3 });

// node_modules/@headlessui/react/dist/components/description/description.js
var import_react42 = __toESM(require_react(), 1);
var d10 = (0, import_react42.createContext)(null);
function f10() {
  let r15 = (0, import_react42.useContext)(d10);
  if (r15 === null) {
    let t20 = new Error("You used a <Description /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(t20, f10), t20;
  }
  return r15;
}
function M3() {
  let [r15, t20] = (0, import_react42.useState)([]);
  return [r15.length > 0 ? r15.join(" ") : void 0, (0, import_react42.useMemo)(() => function(e9) {
    let i15 = o9((s20) => (t20((o16) => [...o16, s20]), () => t20((o16) => {
      let p12 = o16.slice(), c16 = p12.indexOf(s20);
      return c16 !== -1 && p12.splice(c16, 1), p12;
    }))), n12 = (0, import_react42.useMemo)(() => ({ register: i15, slot: e9.slot, name: e9.name, props: e9.props }), [i15, e9.slot, e9.name, e9.props]);
    return import_react42.default.createElement(d10.Provider, { value: n12 }, e9.children);
  }, [t20])];
}
var S6 = "p";
function h6(r15, t20) {
  let a13 = I2(), { id: e9 = `headlessui-description-${a13}`, ...i15 } = r15, n12 = f10(), s20 = y4(t20);
  l5(() => n12.register(e9), [e9, n12.register]);
  let o16 = { ref: s20, ...n12.props, id: e9 };
  return X2({ ourProps: o16, theirProps: i15, slot: n12.slot || {}, defaultTag: S6, name: n12.name || "Description" });
}
var y5 = D3(h6);
var b4 = Object.assign(y5, {});

// node_modules/@headlessui/react/dist/internal/stack-context.js
var import_react43 = __toESM(require_react(), 1);
var a7 = (0, import_react43.createContext)(() => {
});
a7.displayName = "StackContext";
var s16 = ((e9) => (e9[e9.Add = 0] = "Add", e9[e9.Remove = 1] = "Remove", e9))(s16 || {});
function x5() {
  return (0, import_react43.useContext)(a7);
}
function M4({ children: i15, onUpdate: r15, type: e9, element: n12, enabled: u11 }) {
  let l14 = x5(), o16 = o9((...t20) => {
    r15 == null || r15(...t20), l14(...t20);
  });
  return l5(() => {
    let t20 = u11 === void 0 || u11 === true;
    return t20 && o16(0, e9, n12), () => {
      t20 && o16(1, e9, n12);
    };
  }, [o16, e9, n12, u11]), import_react43.default.createElement(a7.Provider, { value: o16 }, i15);
}

// node_modules/@headlessui/react/dist/use-sync-external-store-shim/index.js
var e8 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/use-sync-external-store-shim/useSyncExternalStoreShimClient.js
var l11 = __toESM(require_react(), 1);
function i12(e9, t20) {
  return e9 === t20 && (e9 !== 0 || 1 / e9 === 1 / t20) || e9 !== e9 && t20 !== t20;
}
var d12 = typeof Object.is == "function" ? Object.is : i12;
var { useState: u8, useEffect: h7, useLayoutEffect: f11, useDebugValue: p8 } = l11;
function y6(e9, t20, c16) {
  const a13 = t20(), [{ inst: n12 }, o16] = u8({ inst: { value: a13, getSnapshot: t20 } });
  return f11(() => {
    n12.value = a13, n12.getSnapshot = t20, r11(n12) && o16({ inst: n12 });
  }, [e9, a13, t20]), h7(() => (r11(n12) && o16({ inst: n12 }), e9(() => {
    r11(n12) && o16({ inst: n12 });
  })), [e9]), p8(a13), a13;
}
function r11(e9) {
  const t20 = e9.getSnapshot, c16 = e9.value;
  try {
    const a13 = t20();
    return !d12(c16, a13);
  } catch {
    return true;
  }
}

// node_modules/@headlessui/react/dist/use-sync-external-store-shim/useSyncExternalStoreShimServer.js
function t17(r15, e9, n12) {
  return e9();
}

// node_modules/@headlessui/react/dist/use-sync-external-store-shim/index.js
var r12 = typeof window != "undefined" && typeof window.document != "undefined" && typeof window.document.createElement != "undefined";
var s17 = !r12;
var c12 = s17 ? t17 : y6;
var a8 = "useSyncExternalStore" in e8 ? ((n12) => n12.useSyncExternalStore)(e8) : c12;

// node_modules/@headlessui/react/dist/hooks/use-store.js
function S7(t20) {
  return a8(t20.subscribe, t20.getSnapshot, t20.getSnapshot);
}

// node_modules/@headlessui/react/dist/utils/store.js
function a9(o16, r15) {
  let t20 = o16(), n12 = /* @__PURE__ */ new Set();
  return { getSnapshot() {
    return t20;
  }, subscribe(e9) {
    return n12.add(e9), () => n12.delete(e9);
  }, dispatch(e9, ...s20) {
    let i15 = r15[e9].call(t20, ...s20);
    i15 && (t20 = i15, n12.forEach((c16) => c16()));
  } };
}

// node_modules/@headlessui/react/dist/hooks/document-overflow/adjust-scrollbar-padding.js
function c13() {
  let o16;
  return { before({ doc: e9 }) {
    var l14;
    let n12 = e9.documentElement;
    o16 = ((l14 = e9.defaultView) != null ? l14 : window).innerWidth - n12.clientWidth;
  }, after({ doc: e9, d: n12 }) {
    let t20 = e9.documentElement, l14 = t20.clientWidth - t20.offsetWidth, r15 = o16 - l14;
    n12.style(t20, "paddingRight", `${r15}px`);
  } };
}

// node_modules/@headlessui/react/dist/hooks/document-overflow/handle-ios-locking.js
function p9() {
  if (!t12())
    return {};
  let o16;
  return { before() {
    o16 = window.pageYOffset;
  }, after({ doc: r15, d: l14, meta: s20 }) {
    function i15(e9) {
      return s20.containers.flatMap((t20) => t20()).some((t20) => t20.contains(e9));
    }
    l14.style(r15.body, "marginTop", `-${o16}px`), window.scrollTo(0, 0);
    let n12 = null;
    l14.addEventListener(r15, "click", (e9) => {
      if (e9.target instanceof HTMLElement)
        try {
          let t20 = e9.target.closest("a");
          if (!t20)
            return;
          let { hash: c16 } = new URL(t20.href), a13 = r15.querySelector(c16);
          a13 && !i15(a13) && (n12 = a13);
        } catch {
        }
    }, true), l14.addEventListener(r15, "touchmove", (e9) => {
      e9.target instanceof HTMLElement && !i15(e9.target) && e9.preventDefault();
    }, { passive: false }), l14.add(() => {
      window.scrollTo(0, window.pageYOffset + o16), n12 && n12.isConnected && (n12.scrollIntoView({ block: "nearest" }), n12 = null);
    });
  } };
}

// node_modules/@headlessui/react/dist/hooks/document-overflow/prevent-scroll.js
function l12() {
  return { before({ doc: e9, d: o16 }) {
    o16.style(e9.documentElement, "overflow", "hidden");
  } };
}

// node_modules/@headlessui/react/dist/hooks/document-overflow/overflow-store.js
function m8(e9) {
  let n12 = {};
  for (let t20 of e9)
    Object.assign(n12, t20(n12));
  return n12;
}
var a10 = a9(() => /* @__PURE__ */ new Map(), { PUSH(e9, n12) {
  var o16;
  let t20 = (o16 = this.get(e9)) != null ? o16 : { doc: e9, count: 0, d: o7(), meta: /* @__PURE__ */ new Set() };
  return t20.count++, t20.meta.add(n12), this.set(e9, t20), this;
}, POP(e9, n12) {
  let t20 = this.get(e9);
  return t20 && (t20.count--, t20.meta.delete(n12)), this;
}, SCROLL_PREVENT({ doc: e9, d: n12, meta: t20 }) {
  let o16 = { doc: e9, d: n12, meta: m8(t20) }, c16 = [p9(), c13(), l12()];
  c16.forEach(({ before: r15 }) => r15 == null ? void 0 : r15(o16)), c16.forEach(({ after: r15 }) => r15 == null ? void 0 : r15(o16));
}, SCROLL_ALLOW({ d: e9 }) {
  e9.dispose();
}, TEARDOWN({ doc: e9 }) {
  this.delete(e9);
} });
a10.subscribe(() => {
  let e9 = a10.getSnapshot(), n12 = /* @__PURE__ */ new Map();
  for (let [t20] of e9)
    n12.set(t20, t20.documentElement.style.overflow);
  for (let t20 of e9.values()) {
    let o16 = n12.get(t20.doc) === "hidden", c16 = t20.count !== 0;
    (c16 && !o16 || !c16 && o16) && a10.dispatch(t20.count > 0 ? "SCROLL_PREVENT" : "SCROLL_ALLOW", t20), t20.count === 0 && a10.dispatch("TEARDOWN", t20);
  }
});

// node_modules/@headlessui/react/dist/hooks/document-overflow/use-document-overflow.js
function p10(e9, r15, n12) {
  let f16 = S7(a10), o16 = e9 ? f16.get(e9) : void 0, i15 = o16 ? o16.count > 0 : false;
  return l5(() => {
    if (!(!e9 || !r15))
      return a10.dispatch("PUSH", e9, n12), () => a10.dispatch("POP", e9, n12);
  }, [r15, e9]), i15;
}

// node_modules/@headlessui/react/dist/hooks/use-inert.js
var u9 = /* @__PURE__ */ new Map();
var t18 = /* @__PURE__ */ new Map();
function h8(r15, l14 = true) {
  l5(() => {
    var o16;
    if (!l14)
      return;
    let e9 = typeof r15 == "function" ? r15() : r15.current;
    if (!e9)
      return;
    function a13() {
      var d17;
      if (!e9)
        return;
      let i15 = (d17 = t18.get(e9)) != null ? d17 : 1;
      if (i15 === 1 ? t18.delete(e9) : t18.set(e9, i15 - 1), i15 !== 1)
        return;
      let n12 = u9.get(e9);
      n12 && (n12["aria-hidden"] === null ? e9.removeAttribute("aria-hidden") : e9.setAttribute("aria-hidden", n12["aria-hidden"]), e9.inert = n12.inert, u9.delete(e9));
    }
    let f16 = (o16 = t18.get(e9)) != null ? o16 : 0;
    return t18.set(e9, f16 + 1), f16 !== 0 || (u9.set(e9, { "aria-hidden": e9.getAttribute("aria-hidden"), inert: e9.inert }), e9.setAttribute("aria-hidden", "true"), e9.inert = true), a13;
  }, [r15, l14]);
}

// node_modules/@headlessui/react/dist/components/dialog/dialog.js
var Se = ((o16) => (o16[o16.Open = 0] = "Open", o16[o16.Closed = 1] = "Closed", o16))(Se || {});
var Fe = ((e9) => (e9[e9.SetTitleId = 0] = "SetTitleId", e9))(Fe || {});
var ke2 = { [0](t20, e9) {
  return t20.titleId === e9.id ? t20 : { ...t20, titleId: e9.id };
} };
var M5 = (0, import_react44.createContext)(null);
M5.displayName = "DialogContext";
function S8(t20) {
  let e9 = (0, import_react44.useContext)(M5);
  if (e9 === null) {
    let o16 = new Error(`<${t20} /> is missing a parent <Dialog /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o16, S8), o16;
  }
  return e9;
}
function xe2(t20, e9, o16 = () => [document.body]) {
  p10(t20, e9, (s20) => {
    var n12;
    return { containers: [...(n12 = s20.containers) != null ? n12 : [], o16] };
  });
}
function _e(t20, e9) {
  return u4(e9.type, ke2, t20, e9);
}
var Me = "div";
var He2 = S3.RenderStrategy | S3.Static;
function Ie(t20, e9) {
  let o16 = I2(), { id: s20 = `headlessui-dialog-${o16}`, open: n12, onClose: l14, initialFocus: d17, __demoMode: c16 = false, ...D9 } = t20, [P6, F9] = (0, import_react44.useState)(0), i15 = C2();
  n12 === void 0 && i15 !== null && (n12 = (i15 & d6.Open) === d6.Open);
  let m10 = (0, import_react44.useRef)(null), Q7 = y4(m10, e9), y9 = (0, import_react44.useRef)(null), p12 = n10(m10), U6 = t20.hasOwnProperty("open") || i15 !== null, N6 = t20.hasOwnProperty("onClose");
  if (!U6 && !N6)
    throw new Error("You have to provide an `open` and an `onClose` prop to the `Dialog` component.");
  if (!U6)
    throw new Error("You provided an `onClose` prop to the `Dialog`, but forgot an `open` prop.");
  if (!N6)
    throw new Error("You provided an `open` prop to the `Dialog`, but forgot an `onClose` prop.");
  if (typeof n12 != "boolean")
    throw new Error(`You provided an \`open\` prop to the \`Dialog\`, but the value is not a boolean. Received: ${n12}`);
  if (typeof l14 != "function")
    throw new Error(`You provided an \`onClose\` prop to the \`Dialog\`, but the value is not a function. Received: ${l14}`);
  let u11 = n12 ? 0 : 1, [E8, Z7] = (0, import_react44.useReducer)(_e, { titleId: null, descriptionId: null, panelRef: (0, import_react44.createRef)() }), A8 = o9(() => l14(false)), Y8 = o9((r15) => Z7({ type: 0, id: r15 })), k3 = l6() ? c16 ? false : u11 === 0 : false, x7 = P6 > 1, $7 = (0, import_react44.useContext)(M5) !== null, ee4 = x7 ? "parent" : "leaf", W2 = i15 !== null ? (i15 & d6.Closing) === d6.Closing : false, te4 = (() => $7 || W2 ? false : k3)(), oe4 = (0, import_react44.useCallback)(() => {
    var r15, f16;
    return (f16 = Array.from((r15 = p12 == null ? void 0 : p12.querySelectorAll("body > *")) != null ? r15 : []).find((a13) => a13.id === "headlessui-portal-root" ? false : a13.contains(y9.current) && a13 instanceof HTMLElement)) != null ? f16 : null;
  }, [y9]);
  h8(oe4, te4);
  let re6 = (() => x7 ? true : k3)(), ne6 = (0, import_react44.useCallback)(() => {
    var r15, f16;
    return (f16 = Array.from((r15 = p12 == null ? void 0 : p12.querySelectorAll("[data-headlessui-portal]")) != null ? r15 : []).find((a13) => a13.contains(y9.current) && a13 instanceof HTMLElement)) != null ? f16 : null;
  }, [y9]);
  h8(ne6, re6);
  let H9 = o9(() => {
    var f16, a13;
    return [...Array.from((f16 = p12 == null ? void 0 : p12.querySelectorAll("html > *, body > *, [data-headlessui-portal]")) != null ? f16 : []).filter((T7) => !(T7 === document.body || T7 === document.head || !(T7 instanceof HTMLElement) || T7.contains(y9.current) || E8.panelRef.current && T7.contains(E8.panelRef.current))), (a13 = E8.panelRef.current) != null ? a13 : m10.current];
  }), le4 = (() => !(!k3 || x7))();
  L2(() => H9(), A8, le4);
  let ae3 = (() => !(x7 || u11 !== 0))();
  E5(p12 == null ? void 0 : p12.defaultView, "keydown", (r15) => {
    ae3 && (r15.defaultPrevented || r15.key === o13.Escape && (r15.preventDefault(), r15.stopPropagation(), A8()));
  });
  let ie4 = (() => !(W2 || u11 !== 0 || $7))();
  xe2(p12, ie4, H9), (0, import_react44.useEffect)(() => {
    if (u11 !== 0 || !m10.current)
      return;
    let r15 = new ResizeObserver((f16) => {
      for (let a13 of f16) {
        let T7 = a13.target.getBoundingClientRect();
        T7.x === 0 && T7.y === 0 && T7.width === 0 && T7.height === 0 && A8();
      }
    });
    return r15.observe(m10.current), () => r15.disconnect();
  }, [u11, m10, A8]);
  let [se5, pe4] = M3(), de3 = (0, import_react44.useMemo)(() => [{ dialogState: u11, close: A8, setTitleId: Y8 }, E8], [u11, E8, A8, Y8]), J4 = (0, import_react44.useMemo)(() => ({ open: u11 === 0 }), [u11]), ue6 = { ref: Q7, id: s20, role: "dialog", "aria-modal": u11 === 0 ? true : void 0, "aria-labelledby": E8.titleId, "aria-describedby": se5 };
  return import_react44.default.createElement(M4, { type: "Dialog", enabled: u11 === 0, element: m10, onUpdate: o9((r15, f16) => {
    f16 === "Dialog" && u4(r15, { [s16.Add]: () => F9((a13) => a13 + 1), [s16.Remove]: () => F9((a13) => a13 - 1) });
  }) }, import_react44.default.createElement(P3, { force: true }, import_react44.default.createElement(te, null, import_react44.default.createElement(M5.Provider, { value: de3 }, import_react44.default.createElement(te.Group, { target: m10 }, import_react44.default.createElement(P3, { force: false }, import_react44.default.createElement(pe4, { slot: J4, name: "Dialog.Description" }, import_react44.default.createElement(Re, { initialFocus: d17, containers: H9, features: k3 ? u4(ee4, { parent: Re.features.RestoreFocus, leaf: Re.features.All & ~Re.features.FocusLock }) : Re.features.None }, X2({ ourProps: ue6, theirProps: D9, slot: J4, defaultTag: Me, features: He2, visible: u11 === 0, name: "Dialog" })))))))), import_react44.default.createElement(c7, { features: p6.Hidden, ref: y9 }));
}
var we2 = "div";
function Be(t20, e9) {
  let o16 = I2(), { id: s20 = `headlessui-dialog-overlay-${o16}`, ...n12 } = t20, [{ dialogState: l14, close: d17 }] = S8("Dialog.Overlay"), c16 = y4(e9), D9 = o9((i15) => {
    if (i15.target === i15.currentTarget) {
      if (r8(i15.currentTarget))
        return i15.preventDefault();
      i15.preventDefault(), i15.stopPropagation(), d17();
    }
  }), P6 = (0, import_react44.useMemo)(() => ({ open: l14 === 0 }), [l14]);
  return X2({ ourProps: { ref: c16, id: s20, "aria-hidden": true, onClick: D9 }, theirProps: n12, slot: P6, defaultTag: we2, name: "Dialog.Overlay" });
}
var Ge2 = "div";
function Ue2(t20, e9) {
  let o16 = I2(), { id: s20 = `headlessui-dialog-backdrop-${o16}`, ...n12 } = t20, [{ dialogState: l14 }, d17] = S8("Dialog.Backdrop"), c16 = y4(e9);
  (0, import_react44.useEffect)(() => {
    if (d17.panelRef.current === null)
      throw new Error("A <Dialog.Backdrop /> component is being used, but a <Dialog.Panel /> component is missing.");
  }, [d17.panelRef]);
  let D9 = (0, import_react44.useMemo)(() => ({ open: l14 === 0 }), [l14]);
  return import_react44.default.createElement(P3, { force: true }, import_react44.default.createElement(te, null, X2({ ourProps: { ref: c16, id: s20, "aria-hidden": true }, theirProps: n12, slot: D9, defaultTag: Ge2, name: "Dialog.Backdrop" })));
}
var Ne2 = "div";
function Ye2(t20, e9) {
  let o16 = I2(), { id: s20 = `headlessui-dialog-panel-${o16}`, ...n12 } = t20, [{ dialogState: l14 }, d17] = S8("Dialog.Panel"), c16 = y4(e9, d17.panelRef), D9 = (0, import_react44.useMemo)(() => ({ open: l14 === 0 }), [l14]), P6 = o9((i15) => {
    i15.stopPropagation();
  });
  return X2({ ourProps: { ref: c16, id: s20, onClick: P6 }, theirProps: n12, slot: D9, defaultTag: Ne2, name: "Dialog.Panel" });
}
var $e2 = "h2";
function We2(t20, e9) {
  let o16 = I2(), { id: s20 = `headlessui-dialog-title-${o16}`, ...n12 } = t20, [{ dialogState: l14, setTitleId: d17 }] = S8("Dialog.Title"), c16 = y4(e9);
  (0, import_react44.useEffect)(() => (d17(s20), () => d17(null)), [s20, d17]);
  let D9 = (0, import_react44.useMemo)(() => ({ open: l14 === 0 }), [l14]);
  return X2({ ourProps: { ref: c16, id: s20 }, theirProps: n12, slot: D9, defaultTag: $e2, name: "Dialog.Title" });
}
var Je2 = D3(Ie);
var Xe2 = D3(Ue2);
var je2 = D3(Ye2);
var Ke2 = D3(Be);
var Ve = D3(We2);
var St = Object.assign(Je2, { Backdrop: Xe2, Panel: je2, Overlay: Ke2, Title: Ve, Description: b4 });

// node_modules/@headlessui/react/dist/components/disclosure/disclosure.js
var import_react46 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/utils/start-transition.js
var import_react45 = __toESM(require_react(), 1);
var t19;
var a11 = (t19 = import_react45.default.startTransition) != null ? t19 : function(i15) {
  i15();
};

// node_modules/@headlessui/react/dist/components/disclosure/disclosure.js
var q2 = ((o16) => (o16[o16.Open = 0] = "Open", o16[o16.Closed = 1] = "Closed", o16))(q2 || {});
var z5 = ((t20) => (t20[t20.ToggleDisclosure = 0] = "ToggleDisclosure", t20[t20.CloseDisclosure = 1] = "CloseDisclosure", t20[t20.SetButtonId = 2] = "SetButtonId", t20[t20.SetPanelId = 3] = "SetPanelId", t20[t20.LinkPanel = 4] = "LinkPanel", t20[t20.UnlinkPanel = 5] = "UnlinkPanel", t20))(z5 || {});
var Q3 = { [0]: (e9) => ({ ...e9, disclosureState: u4(e9.disclosureState, { [0]: 1, [1]: 0 }) }), [1]: (e9) => e9.disclosureState === 1 ? e9 : { ...e9, disclosureState: 1 }, [4](e9) {
  return e9.linkedPanel === true ? e9 : { ...e9, linkedPanel: true };
}, [5](e9) {
  return e9.linkedPanel === false ? e9 : { ...e9, linkedPanel: false };
}, [2](e9, n12) {
  return e9.buttonId === n12.buttonId ? e9 : { ...e9, buttonId: n12.buttonId };
}, [3](e9, n12) {
  return e9.panelId === n12.panelId ? e9 : { ...e9, panelId: n12.panelId };
} };
var k2 = (0, import_react46.createContext)(null);
k2.displayName = "DisclosureContext";
function M6(e9) {
  let n12 = (0, import_react46.useContext)(k2);
  if (n12 === null) {
    let o16 = new Error(`<${e9} /> is missing a parent <Disclosure /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o16, M6), o16;
  }
  return n12;
}
var v3 = (0, import_react46.createContext)(null);
v3.displayName = "DisclosureAPIContext";
function w5(e9) {
  let n12 = (0, import_react46.useContext)(v3);
  if (n12 === null) {
    let o16 = new Error(`<${e9} /> is missing a parent <Disclosure /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o16, w5), o16;
  }
  return n12;
}
var H5 = (0, import_react46.createContext)(null);
H5.displayName = "DisclosurePanelContext";
function V2() {
  return (0, import_react46.useContext)(H5);
}
function Y3(e9, n12) {
  return u4(n12.type, Q3, e9, n12);
}
var Z3 = import_react46.Fragment;
function ee(e9, n12) {
  let { defaultOpen: o16 = false, ...u11 } = e9, T7 = (0, import_react46.useRef)(null), l14 = y4(n12, T2((a13) => {
    T7.current = a13;
  }, e9.as === void 0 || e9.as === import_react46.Fragment)), t20 = (0, import_react46.useRef)(null), f16 = (0, import_react46.useRef)(null), s20 = (0, import_react46.useReducer)(Y3, { disclosureState: o16 ? 0 : 1, linkedPanel: false, buttonRef: f16, panelRef: t20, buttonId: null, panelId: null }), [{ disclosureState: i15, buttonId: c16 }, D9] = s20, d17 = o9((a13) => {
    D9({ type: 1 });
    let r15 = e4(T7);
    if (!r15 || !c16)
      return;
    let p12 = (() => a13 ? a13 instanceof HTMLElement ? a13 : a13.current instanceof HTMLElement ? a13.current : r15.getElementById(c16) : r15.getElementById(c16))();
    p12 == null || p12.focus();
  }), P6 = (0, import_react46.useMemo)(() => ({ close: d17 }), [d17]), b6 = (0, import_react46.useMemo)(() => ({ open: i15 === 0, close: d17 }), [i15, d17]), y9 = { ref: l14 };
  return import_react46.default.createElement(k2.Provider, { value: s20 }, import_react46.default.createElement(v3.Provider, { value: P6 }, import_react46.default.createElement(c8, { value: u4(i15, { [0]: d6.Open, [1]: d6.Closed }) }, X2({ ourProps: y9, theirProps: u11, slot: b6, defaultTag: Z3, name: "Disclosure" }))));
}
var te2 = "button";
function ne(e9, n12) {
  let o16 = I2(), { id: u11 = `headlessui-disclosure-button-${o16}`, ...T7 } = e9, [l14, t20] = M6("Disclosure.Button"), f16 = V2(), s20 = f16 === null ? false : f16 === l14.panelId, i15 = (0, import_react46.useRef)(null), c16 = y4(i15, n12, s20 ? null : l14.buttonRef);
  (0, import_react46.useEffect)(() => {
    if (!s20)
      return t20({ type: 2, buttonId: u11 }), () => {
        t20({ type: 2, buttonId: null });
      };
  }, [u11, t20, s20]);
  let D9 = o9((r15) => {
    var p12;
    if (s20) {
      if (l14.disclosureState === 1)
        return;
      switch (r15.key) {
        case o13.Space:
        case o13.Enter:
          r15.preventDefault(), r15.stopPropagation(), t20({ type: 0 }), (p12 = l14.buttonRef.current) == null || p12.focus();
          break;
      }
    } else
      switch (r15.key) {
        case o13.Space:
        case o13.Enter:
          r15.preventDefault(), r15.stopPropagation(), t20({ type: 0 });
          break;
      }
  }), d17 = o9((r15) => {
    switch (r15.key) {
      case o13.Space:
        r15.preventDefault();
        break;
    }
  }), P6 = o9((r15) => {
    var p12;
    r8(r15.currentTarget) || e9.disabled || (s20 ? (t20({ type: 0 }), (p12 = l14.buttonRef.current) == null || p12.focus()) : t20({ type: 0 }));
  }), b6 = (0, import_react46.useMemo)(() => ({ open: l14.disclosureState === 0 }), [l14]), y9 = s9(e9, i15), a13 = s20 ? { ref: c16, type: y9, onKeyDown: D9, onClick: P6 } : { ref: c16, id: u11, type: y9, "aria-expanded": e9.disabled ? void 0 : l14.disclosureState === 0, "aria-controls": l14.linkedPanel ? l14.panelId : void 0, onKeyDown: D9, onKeyUp: d17, onClick: P6 };
  return X2({ ourProps: a13, theirProps: T7, slot: b6, defaultTag: te2, name: "Disclosure.Button" });
}
var le2 = "div";
var oe = S3.RenderStrategy | S3.Static;
function re2(e9, n12) {
  let o16 = I2(), { id: u11 = `headlessui-disclosure-panel-${o16}`, ...T7 } = e9, [l14, t20] = M6("Disclosure.Panel"), { close: f16 } = w5("Disclosure.Panel"), s20 = y4(n12, l14.panelRef, (P6) => {
    a11(() => t20({ type: P6 ? 4 : 5 }));
  });
  (0, import_react46.useEffect)(() => (t20({ type: 3, panelId: u11 }), () => {
    t20({ type: 3, panelId: null });
  }), [u11, t20]);
  let i15 = C2(), c16 = (() => i15 !== null ? (i15 & d6.Open) === d6.Open : l14.disclosureState === 0)(), D9 = (0, import_react46.useMemo)(() => ({ open: l14.disclosureState === 0, close: f16 }), [l14, f16]), d17 = { ref: s20, id: u11 };
  return import_react46.default.createElement(H5.Provider, { value: l14.panelId }, X2({ ourProps: d17, theirProps: T7, slot: D9, defaultTag: le2, features: oe, visible: c16, name: "Disclosure.Panel" }));
}
var se2 = D3(ee);
var ue2 = D3(ne);
var ie = D3(re2);
var ve = Object.assign(se2, { Button: ue2, Panel: ie });

// node_modules/@headlessui/react/dist/components/listbox/listbox.js
var import_react47 = __toESM(require_react(), 1);
var Ue3 = ((o16) => (o16[o16.Open = 0] = "Open", o16[o16.Closed = 1] = "Closed", o16))(Ue3 || {});
var Be2 = ((o16) => (o16[o16.Single = 0] = "Single", o16[o16.Multi = 1] = "Multi", o16))(Be2 || {});
var He3 = ((o16) => (o16[o16.Pointer = 0] = "Pointer", o16[o16.Other = 1] = "Other", o16))(He3 || {});
var Ge3 = ((i15) => (i15[i15.OpenListbox = 0] = "OpenListbox", i15[i15.CloseListbox = 1] = "CloseListbox", i15[i15.GoToOption = 2] = "GoToOption", i15[i15.Search = 3] = "Search", i15[i15.ClearSearch = 4] = "ClearSearch", i15[i15.RegisterOption = 5] = "RegisterOption", i15[i15.UnregisterOption = 6] = "UnregisterOption", i15[i15.RegisterLabel = 7] = "RegisterLabel", i15))(Ge3 || {});
function X5(e9, a13 = (o16) => o16) {
  let o16 = e9.activeOptionIndex !== null ? e9.options[e9.activeOptionIndex] : null, r15 = I3(a13(e9.options.slice()), (t20) => t20.dataRef.current.domRef.current), l14 = o16 ? r15.indexOf(o16) : null;
  return l14 === -1 && (l14 = null), { options: r15, activeOptionIndex: l14 };
}
var Ne3 = { [1](e9) {
  return e9.dataRef.current.disabled || e9.listboxState === 1 ? e9 : { ...e9, activeOptionIndex: null, listboxState: 1 };
}, [0](e9) {
  if (e9.dataRef.current.disabled || e9.listboxState === 0)
    return e9;
  let a13 = e9.activeOptionIndex, { isSelected: o16 } = e9.dataRef.current, r15 = e9.options.findIndex((l14) => o16(l14.dataRef.current.value));
  return r15 !== -1 && (a13 = r15), { ...e9, listboxState: 0, activeOptionIndex: a13 };
}, [2](e9, a13) {
  var l14;
  if (e9.dataRef.current.disabled || e9.listboxState === 1)
    return e9;
  let o16 = X5(e9), r15 = x2(a13, { resolveItems: () => o16.options, resolveActiveIndex: () => o16.activeOptionIndex, resolveId: (t20) => t20.id, resolveDisabled: (t20) => t20.dataRef.current.disabled });
  return { ...e9, ...o16, searchQuery: "", activeOptionIndex: r15, activationTrigger: (l14 = a13.trigger) != null ? l14 : 1 };
}, [3]: (e9, a13) => {
  if (e9.dataRef.current.disabled || e9.listboxState === 1)
    return e9;
  let r15 = e9.searchQuery !== "" ? 0 : 1, l14 = e9.searchQuery + a13.value.toLowerCase(), p12 = (e9.activeOptionIndex !== null ? e9.options.slice(e9.activeOptionIndex + r15).concat(e9.options.slice(0, e9.activeOptionIndex + r15)) : e9.options).find((i15) => {
    var b6;
    return !i15.dataRef.current.disabled && ((b6 = i15.dataRef.current.textValue) == null ? void 0 : b6.startsWith(l14));
  }), u11 = p12 ? e9.options.indexOf(p12) : -1;
  return u11 === -1 || u11 === e9.activeOptionIndex ? { ...e9, searchQuery: l14 } : { ...e9, searchQuery: l14, activeOptionIndex: u11, activationTrigger: 1 };
}, [4](e9) {
  return e9.dataRef.current.disabled || e9.listboxState === 1 || e9.searchQuery === "" ? e9 : { ...e9, searchQuery: "" };
}, [5]: (e9, a13) => {
  let o16 = { id: a13.id, dataRef: a13.dataRef }, r15 = X5(e9, (l14) => [...l14, o16]);
  return e9.activeOptionIndex === null && e9.dataRef.current.isSelected(a13.dataRef.current.value) && (r15.activeOptionIndex = r15.options.indexOf(o16)), { ...e9, ...r15 };
}, [6]: (e9, a13) => {
  let o16 = X5(e9, (r15) => {
    let l14 = r15.findIndex((t20) => t20.id === a13.id);
    return l14 !== -1 && r15.splice(l14, 1), r15;
  });
  return { ...e9, ...o16, activationTrigger: 1 };
}, [7]: (e9, a13) => ({ ...e9, labelId: a13.id }) };
var $3 = (0, import_react47.createContext)(null);
$3.displayName = "ListboxActionsContext";
function U4(e9) {
  let a13 = (0, import_react47.useContext)($3);
  if (a13 === null) {
    let o16 = new Error(`<${e9} /> is missing a parent <Listbox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o16, U4), o16;
  }
  return a13;
}
var z6 = (0, import_react47.createContext)(null);
z6.displayName = "ListboxDataContext";
function B2(e9) {
  let a13 = (0, import_react47.useContext)(z6);
  if (a13 === null) {
    let o16 = new Error(`<${e9} /> is missing a parent <Listbox /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(o16, B2), o16;
  }
  return a13;
}
function je3(e9, a13) {
  return u4(a13.type, Ne3, e9, a13);
}
var Ve2 = import_react47.Fragment;
function Ke3(e9, a13) {
  let { value: o16, defaultValue: r15, form: l14, name: t20, onChange: p12, by: u11 = (s20, d17) => s20 === d17, disabled: i15 = false, horizontal: b6 = false, multiple: R4 = false, ...m10 } = e9;
  const P6 = b6 ? "horizontal" : "vertical";
  let E8 = y4(a13), [L6 = R4 ? [] : void 0, v6] = T4(o16, p12, r15), [c16, n12] = (0, import_react47.useReducer)(je3, { dataRef: (0, import_react47.createRef)(), listboxState: 1, options: [], searchQuery: "", labelId: null, activeOptionIndex: null, activationTrigger: 1 }), x7 = (0, import_react47.useRef)({ static: false, hold: false }), h11 = (0, import_react47.useRef)(null), Q7 = (0, import_react47.useRef)(null), J4 = (0, import_react47.useRef)(null), y9 = o9(typeof u11 == "string" ? (s20, d17) => {
    let O5 = u11;
    return (s20 == null ? void 0 : s20[O5]) === (d17 == null ? void 0 : d17[O5]);
  } : u11), S11 = (0, import_react47.useCallback)((s20) => u4(T7.mode, { [1]: () => L6.some((d17) => y9(d17, s20)), [0]: () => y9(L6, s20) }), [L6]), T7 = (0, import_react47.useMemo)(() => ({ ...c16, value: L6, disabled: i15, mode: R4 ? 1 : 0, orientation: P6, compare: y9, isSelected: S11, optionsPropsRef: x7, labelRef: h11, buttonRef: Q7, optionsRef: J4 }), [L6, i15, R4, c16]);
  l5(() => {
    c16.dataRef.current = T7;
  }, [T7]), L2([T7.buttonRef, T7.optionsRef], (s20, d17) => {
    var O5;
    n12({ type: 1 }), h3(d17, T.Loose) || (s20.preventDefault(), (O5 = T7.buttonRef.current) == null || O5.focus());
  }, T7.listboxState === 0);
  let ne6 = (0, import_react47.useMemo)(() => ({ open: T7.listboxState === 0, disabled: i15, value: L6 }), [T7, i15, L6]), ie4 = o9((s20) => {
    let d17 = T7.options.find((O5) => O5.id === s20);
    d17 && F9(d17.dataRef.current.value);
  }), re6 = o9(() => {
    if (T7.activeOptionIndex !== null) {
      let { dataRef: s20, id: d17 } = T7.options[T7.activeOptionIndex];
      F9(s20.current.value), n12({ type: 2, focus: a4.Specific, id: d17 });
    }
  }), ae3 = o9(() => n12({ type: 0 })), le4 = o9(() => n12({ type: 1 })), se5 = o9((s20, d17, O5) => s20 === a4.Specific ? n12({ type: 2, focus: a4.Specific, id: d17, trigger: O5 }) : n12({ type: 2, focus: s20, trigger: O5 })), pe4 = o9((s20, d17) => (n12({ type: 5, id: s20, dataRef: d17 }), () => n12({ type: 6, id: s20 }))), ue6 = o9((s20) => (n12({ type: 7, id: s20 }), () => n12({ type: 7, id: null }))), F9 = o9((s20) => u4(T7.mode, { [0]() {
    return v6 == null ? void 0 : v6(s20);
  }, [1]() {
    let d17 = T7.value.slice(), O5 = d17.findIndex((M10) => y9(M10, s20));
    return O5 === -1 ? d17.push(s20) : d17.splice(O5, 1), v6 == null ? void 0 : v6(d17);
  } })), de3 = o9((s20) => n12({ type: 3, value: s20 })), ce4 = o9(() => n12({ type: 4 })), fe4 = (0, import_react47.useMemo)(() => ({ onChange: F9, registerOption: pe4, registerLabel: ue6, goToOption: se5, closeListbox: le4, openListbox: ae3, selectActiveOption: re6, selectOption: ie4, search: de3, clearSearch: ce4 }), []), Te4 = { ref: E8 }, H9 = (0, import_react47.useRef)(null), be4 = p4();
  return (0, import_react47.useEffect)(() => {
    H9.current && r15 !== void 0 && be4.addEventListener(H9.current, "reset", () => {
      F9(r15);
    });
  }, [H9, F9]), import_react47.default.createElement($3.Provider, { value: fe4 }, import_react47.default.createElement(z6.Provider, { value: T7 }, import_react47.default.createElement(c8, { value: u4(T7.listboxState, { [0]: d6.Open, [1]: d6.Closed }) }, t20 != null && L6 != null && e6({ [t20]: L6 }).map(([s20, d17], O5) => import_react47.default.createElement(c7, { features: p6.Hidden, ref: O5 === 0 ? (M10) => {
    var q7;
    H9.current = (q7 = M10 == null ? void 0 : M10.closest("form")) != null ? q7 : null;
  } : void 0, ...R2({ key: s20, as: "input", type: "hidden", hidden: true, readOnly: true, form: l14, name: s20, value: d17 }) })), X2({ ourProps: Te4, theirProps: m10, slot: ne6, defaultTag: Ve2, name: "Listbox" }))));
}
var Qe2 = "button";
function We3(e9, a13) {
  var v6;
  let o16 = I2(), { id: r15 = `headlessui-listbox-button-${o16}`, ...l14 } = e9, t20 = B2("Listbox.Button"), p12 = U4("Listbox.Button"), u11 = y4(t20.buttonRef, a13), i15 = p4(), b6 = o9((c16) => {
    switch (c16.key) {
      case o13.Space:
      case o13.Enter:
      case o13.ArrowDown:
        c16.preventDefault(), p12.openListbox(), i15.nextFrame(() => {
          t20.value || p12.goToOption(a4.First);
        });
        break;
      case o13.ArrowUp:
        c16.preventDefault(), p12.openListbox(), i15.nextFrame(() => {
          t20.value || p12.goToOption(a4.Last);
        });
        break;
    }
  }), R4 = o9((c16) => {
    switch (c16.key) {
      case o13.Space:
        c16.preventDefault();
        break;
    }
  }), m10 = o9((c16) => {
    if (r8(c16.currentTarget))
      return c16.preventDefault();
    t20.listboxState === 0 ? (p12.closeListbox(), i15.nextFrame(() => {
      var n12;
      return (n12 = t20.buttonRef.current) == null ? void 0 : n12.focus({ preventScroll: true });
    })) : (c16.preventDefault(), p12.openListbox());
  }), P6 = i6(() => {
    if (t20.labelId)
      return [t20.labelId, r15].join(" ");
  }, [t20.labelId, r15]), E8 = (0, import_react47.useMemo)(() => ({ open: t20.listboxState === 0, disabled: t20.disabled, value: t20.value }), [t20]), L6 = { ref: u11, id: r15, type: s9(e9, t20.buttonRef), "aria-haspopup": "listbox", "aria-controls": (v6 = t20.optionsRef.current) == null ? void 0 : v6.id, "aria-expanded": t20.disabled ? void 0 : t20.listboxState === 0, "aria-labelledby": P6, disabled: t20.disabled, onKeyDown: b6, onKeyUp: R4, onClick: m10 };
  return X2({ ourProps: L6, theirProps: l14, slot: E8, defaultTag: Qe2, name: "Listbox.Button" });
}
var Xe3 = "label";
function $e3(e9, a13) {
  let o16 = I2(), { id: r15 = `headlessui-listbox-label-${o16}`, ...l14 } = e9, t20 = B2("Listbox.Label"), p12 = U4("Listbox.Label"), u11 = y4(t20.labelRef, a13);
  l5(() => p12.registerLabel(r15), [r15]);
  let i15 = o9(() => {
    var m10;
    return (m10 = t20.buttonRef.current) == null ? void 0 : m10.focus({ preventScroll: true });
  }), b6 = (0, import_react47.useMemo)(() => ({ open: t20.listboxState === 0, disabled: t20.disabled }), [t20]);
  return X2({ ourProps: { ref: u11, id: r15, onClick: i15 }, theirProps: l14, slot: b6, defaultTag: Xe3, name: "Listbox.Label" });
}
var ze2 = "ul";
var Je3 = S3.RenderStrategy | S3.Static;
function qe2(e9, a13) {
  var c16;
  let o16 = I2(), { id: r15 = `headlessui-listbox-options-${o16}`, ...l14 } = e9, t20 = B2("Listbox.Options"), p12 = U4("Listbox.Options"), u11 = y4(t20.optionsRef, a13), i15 = p4(), b6 = p4(), R4 = C2(), m10 = (() => R4 !== null ? (R4 & d6.Open) === d6.Open : t20.listboxState === 0)();
  (0, import_react47.useEffect)(() => {
    var x7;
    let n12 = t20.optionsRef.current;
    n12 && t20.listboxState === 0 && n12 !== ((x7 = e4(n12)) == null ? void 0 : x7.activeElement) && n12.focus({ preventScroll: true });
  }, [t20.listboxState, t20.optionsRef]);
  let P6 = o9((n12) => {
    switch (b6.dispose(), n12.key) {
      case o13.Space:
        if (t20.searchQuery !== "")
          return n12.preventDefault(), n12.stopPropagation(), p12.search(n12.key);
      case o13.Enter:
        if (n12.preventDefault(), n12.stopPropagation(), t20.activeOptionIndex !== null) {
          let { dataRef: x7 } = t20.options[t20.activeOptionIndex];
          p12.onChange(x7.current.value);
        }
        t20.mode === 0 && (p12.closeListbox(), o7().nextFrame(() => {
          var x7;
          return (x7 = t20.buttonRef.current) == null ? void 0 : x7.focus({ preventScroll: true });
        }));
        break;
      case u4(t20.orientation, { vertical: o13.ArrowDown, horizontal: o13.ArrowRight }):
        return n12.preventDefault(), n12.stopPropagation(), p12.goToOption(a4.Next);
      case u4(t20.orientation, { vertical: o13.ArrowUp, horizontal: o13.ArrowLeft }):
        return n12.preventDefault(), n12.stopPropagation(), p12.goToOption(a4.Previous);
      case o13.Home:
      case o13.PageUp:
        return n12.preventDefault(), n12.stopPropagation(), p12.goToOption(a4.First);
      case o13.End:
      case o13.PageDown:
        return n12.preventDefault(), n12.stopPropagation(), p12.goToOption(a4.Last);
      case o13.Escape:
        return n12.preventDefault(), n12.stopPropagation(), p12.closeListbox(), i15.nextFrame(() => {
          var x7;
          return (x7 = t20.buttonRef.current) == null ? void 0 : x7.focus({ preventScroll: true });
        });
      case o13.Tab:
        n12.preventDefault(), n12.stopPropagation();
        break;
      default:
        n12.key.length === 1 && (p12.search(n12.key), b6.setTimeout(() => p12.clearSearch(), 350));
        break;
    }
  }), E8 = i6(() => {
    var n12, x7, h11;
    return (h11 = (n12 = t20.labelRef.current) == null ? void 0 : n12.id) != null ? h11 : (x7 = t20.buttonRef.current) == null ? void 0 : x7.id;
  }, [t20.labelRef.current, t20.buttonRef.current]), L6 = (0, import_react47.useMemo)(() => ({ open: t20.listboxState === 0 }), [t20]), v6 = { "aria-activedescendant": t20.activeOptionIndex === null || (c16 = t20.options[t20.activeOptionIndex]) == null ? void 0 : c16.id, "aria-multiselectable": t20.mode === 1 ? true : void 0, "aria-labelledby": E8, "aria-orientation": t20.orientation, id: r15, onKeyDown: P6, role: "listbox", tabIndex: 0, ref: u11 };
  return X2({ ourProps: v6, theirProps: l14, slot: L6, defaultTag: ze2, features: Je3, visible: m10, name: "Listbox.Options" });
}
var Ye3 = "li";
function Ze2(e9, a13) {
  let o16 = I2(), { id: r15 = `headlessui-listbox-option-${o16}`, disabled: l14 = false, value: t20, ...p12 } = e9, u11 = B2("Listbox.Option"), i15 = U4("Listbox.Option"), b6 = u11.activeOptionIndex !== null ? u11.options[u11.activeOptionIndex].id === r15 : false, R4 = u11.isSelected(t20), m10 = (0, import_react47.useRef)(null), P6 = s5({ disabled: l14, value: t20, domRef: m10, get textValue() {
    var y9, S11;
    return (S11 = (y9 = m10.current) == null ? void 0 : y9.textContent) == null ? void 0 : S11.toLowerCase();
  } }), E8 = y4(a13, m10);
  l5(() => {
    if (u11.listboxState !== 0 || !b6 || u11.activationTrigger === 0)
      return;
    let y9 = o7();
    return y9.requestAnimationFrame(() => {
      var S11, T7;
      (T7 = (S11 = m10.current) == null ? void 0 : S11.scrollIntoView) == null || T7.call(S11, { block: "nearest" });
    }), y9.dispose;
  }, [m10, b6, u11.listboxState, u11.activationTrigger, u11.activeOptionIndex]), l5(() => i15.registerOption(r15, P6), [P6, r15]);
  let L6 = o9((y9) => {
    if (l14)
      return y9.preventDefault();
    i15.onChange(t20), u11.mode === 0 && (i15.closeListbox(), o7().nextFrame(() => {
      var S11;
      return (S11 = u11.buttonRef.current) == null ? void 0 : S11.focus({ preventScroll: true });
    }));
  }), v6 = o9(() => {
    if (l14)
      return i15.goToOption(a4.Nothing);
    i15.goToOption(a4.Specific, r15);
  }), c16 = u6(), n12 = o9((y9) => c16.update(y9)), x7 = o9((y9) => {
    c16.wasMoved(y9) && (l14 || b6 || i15.goToOption(a4.Specific, r15, 0));
  }), h11 = o9((y9) => {
    c16.wasMoved(y9) && (l14 || b6 && i15.goToOption(a4.Nothing));
  }), Q7 = (0, import_react47.useMemo)(() => ({ active: b6, selected: R4, disabled: l14 }), [b6, R4, l14]);
  return X2({ ourProps: { id: r15, ref: E8, role: "option", tabIndex: l14 === true ? void 0 : -1, "aria-disabled": l14 === true ? true : void 0, "aria-selected": R4, disabled: void 0, onClick: L6, onFocus: v6, onPointerEnter: n12, onMouseEnter: n12, onPointerMove: x7, onMouseMove: x7, onPointerLeave: h11, onMouseLeave: h11 }, theirProps: p12, slot: Q7, defaultTag: Ye3, name: "Listbox.Option" });
}
var et = D3(Ke3);
var tt = D3(We3);
var ot = D3($e3);
var nt = D3(qe2);
var it = D3(Ze2);
var Ht = Object.assign(et, { Button: tt, Label: ot, Options: nt, Option: it });

// node_modules/@headlessui/react/dist/components/menu/menu.js
var import_react48 = __toESM(require_react(), 1);
var pe2 = ((r15) => (r15[r15.Open = 0] = "Open", r15[r15.Closed = 1] = "Closed", r15))(pe2 || {});
var ce2 = ((r15) => (r15[r15.Pointer = 0] = "Pointer", r15[r15.Other = 1] = "Other", r15))(ce2 || {});
var me = ((a13) => (a13[a13.OpenMenu = 0] = "OpenMenu", a13[a13.CloseMenu = 1] = "CloseMenu", a13[a13.GoToItem = 2] = "GoToItem", a13[a13.Search = 3] = "Search", a13[a13.ClearSearch = 4] = "ClearSearch", a13[a13.RegisterItem = 5] = "RegisterItem", a13[a13.UnregisterItem = 6] = "UnregisterItem", a13))(me || {});
function w6(e9, u11 = (r15) => r15) {
  let r15 = e9.activeItemIndex !== null ? e9.items[e9.activeItemIndex] : null, i15 = I3(u11(e9.items.slice()), (t20) => t20.dataRef.current.domRef.current), s20 = r15 ? i15.indexOf(r15) : null;
  return s20 === -1 && (s20 = null), { items: i15, activeItemIndex: s20 };
}
var de = { [1](e9) {
  return e9.menuState === 1 ? e9 : { ...e9, activeItemIndex: null, menuState: 1 };
}, [0](e9) {
  return e9.menuState === 0 ? e9 : { ...e9, menuState: 0 };
}, [2]: (e9, u11) => {
  var s20;
  let r15 = w6(e9), i15 = x2(u11, { resolveItems: () => r15.items, resolveActiveIndex: () => r15.activeItemIndex, resolveId: (t20) => t20.id, resolveDisabled: (t20) => t20.dataRef.current.disabled });
  return { ...e9, ...r15, searchQuery: "", activeItemIndex: i15, activationTrigger: (s20 = u11.trigger) != null ? s20 : 1 };
}, [3]: (e9, u11) => {
  let i15 = e9.searchQuery !== "" ? 0 : 1, s20 = e9.searchQuery + u11.value.toLowerCase(), o16 = (e9.activeItemIndex !== null ? e9.items.slice(e9.activeItemIndex + i15).concat(e9.items.slice(0, e9.activeItemIndex + i15)) : e9.items).find((l14) => {
    var m10;
    return ((m10 = l14.dataRef.current.textValue) == null ? void 0 : m10.startsWith(s20)) && !l14.dataRef.current.disabled;
  }), a13 = o16 ? e9.items.indexOf(o16) : -1;
  return a13 === -1 || a13 === e9.activeItemIndex ? { ...e9, searchQuery: s20 } : { ...e9, searchQuery: s20, activeItemIndex: a13, activationTrigger: 1 };
}, [4](e9) {
  return e9.searchQuery === "" ? e9 : { ...e9, searchQuery: "", searchActiveItemIndex: null };
}, [5]: (e9, u11) => {
  let r15 = w6(e9, (i15) => [...i15, { id: u11.id, dataRef: u11.dataRef }]);
  return { ...e9, ...r15 };
}, [6]: (e9, u11) => {
  let r15 = w6(e9, (i15) => {
    let s20 = i15.findIndex((t20) => t20.id === u11.id);
    return s20 !== -1 && i15.splice(s20, 1), i15;
  });
  return { ...e9, ...r15, activationTrigger: 1 };
} };
var U5 = (0, import_react48.createContext)(null);
U5.displayName = "MenuContext";
function F5(e9) {
  let u11 = (0, import_react48.useContext)(U5);
  if (u11 === null) {
    let r15 = new Error(`<${e9} /> is missing a parent <Menu /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(r15, F5), r15;
  }
  return u11;
}
function fe2(e9, u11) {
  return u4(u11.type, de, e9, u11);
}
var Te2 = import_react48.Fragment;
function ye2(e9, u11) {
  let r15 = (0, import_react48.useReducer)(fe2, { menuState: 1, buttonRef: (0, import_react48.createRef)(), itemsRef: (0, import_react48.createRef)(), items: [], searchQuery: "", activeItemIndex: null, activationTrigger: 1 }), [{ menuState: i15, itemsRef: s20, buttonRef: t20 }, o16] = r15, a13 = y4(u11);
  L2([t20, s20], (g6, A8) => {
    var I9;
    o16({ type: 1 }), h3(A8, T.Loose) || (g6.preventDefault(), (I9 = t20.current) == null || I9.focus());
  }, i15 === 0);
  let l14 = o9(() => {
    o16({ type: 1 });
  }), m10 = (0, import_react48.useMemo)(() => ({ open: i15 === 0, close: l14 }), [i15, l14]), M10 = e9, f16 = { ref: a13 };
  return import_react48.default.createElement(U5.Provider, { value: r15 }, import_react48.default.createElement(c8, { value: u4(i15, { [0]: d6.Open, [1]: d6.Closed }) }, X2({ ourProps: f16, theirProps: M10, slot: m10, defaultTag: Te2, name: "Menu" })));
}
var Ie2 = "button";
function Me2(e9, u11) {
  var I9;
  let r15 = I2(), { id: i15 = `headlessui-menu-button-${r15}`, ...s20 } = e9, [t20, o16] = F5("Menu.Button"), a13 = y4(t20.buttonRef, u11), l14 = p4(), m10 = o9((p12) => {
    switch (p12.key) {
      case o13.Space:
      case o13.Enter:
      case o13.ArrowDown:
        p12.preventDefault(), p12.stopPropagation(), o16({ type: 0 }), l14.nextFrame(() => o16({ type: 2, focus: a4.First }));
        break;
      case o13.ArrowUp:
        p12.preventDefault(), p12.stopPropagation(), o16({ type: 0 }), l14.nextFrame(() => o16({ type: 2, focus: a4.Last }));
        break;
    }
  }), M10 = o9((p12) => {
    switch (p12.key) {
      case o13.Space:
        p12.preventDefault();
        break;
    }
  }), f16 = o9((p12) => {
    if (r8(p12.currentTarget))
      return p12.preventDefault();
    e9.disabled || (t20.menuState === 0 ? (o16({ type: 1 }), l14.nextFrame(() => {
      var R4;
      return (R4 = t20.buttonRef.current) == null ? void 0 : R4.focus({ preventScroll: true });
    })) : (p12.preventDefault(), o16({ type: 0 })));
  }), g6 = (0, import_react48.useMemo)(() => ({ open: t20.menuState === 0 }), [t20]), A8 = { ref: a13, id: i15, type: s9(e9, t20.buttonRef), "aria-haspopup": "menu", "aria-controls": (I9 = t20.itemsRef.current) == null ? void 0 : I9.id, "aria-expanded": e9.disabled ? void 0 : t20.menuState === 0, onKeyDown: m10, onKeyUp: M10, onClick: f16 };
  return X2({ ourProps: A8, theirProps: s20, slot: g6, defaultTag: Ie2, name: "Menu.Button" });
}
var ge4 = "div";
var Re2 = S3.RenderStrategy | S3.Static;
function Ae(e9, u11) {
  var R4, E8;
  let r15 = I2(), { id: i15 = `headlessui-menu-items-${r15}`, ...s20 } = e9, [t20, o16] = F5("Menu.Items"), a13 = y4(t20.itemsRef, u11), l14 = n10(t20.itemsRef), m10 = p4(), M10 = C2(), f16 = (() => M10 !== null ? (M10 & d6.Open) === d6.Open : t20.menuState === 0)();
  (0, import_react48.useEffect)(() => {
    let n12 = t20.itemsRef.current;
    n12 && t20.menuState === 0 && n12 !== (l14 == null ? void 0 : l14.activeElement) && n12.focus({ preventScroll: true });
  }, [t20.menuState, t20.itemsRef, l14]), F2({ container: t20.itemsRef.current, enabled: t20.menuState === 0, accept(n12) {
    return n12.getAttribute("role") === "menuitem" ? NodeFilter.FILTER_REJECT : n12.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(n12) {
    n12.setAttribute("role", "none");
  } });
  let g6 = o9((n12) => {
    var S11, O5;
    switch (m10.dispose(), n12.key) {
      case o13.Space:
        if (t20.searchQuery !== "")
          return n12.preventDefault(), n12.stopPropagation(), o16({ type: 3, value: n12.key });
      case o13.Enter:
        if (n12.preventDefault(), n12.stopPropagation(), o16({ type: 1 }), t20.activeItemIndex !== null) {
          let { dataRef: c16 } = t20.items[t20.activeItemIndex];
          (O5 = (S11 = c16.current) == null ? void 0 : S11.domRef.current) == null || O5.click();
        }
        D2(t20.buttonRef.current);
        break;
      case o13.ArrowDown:
        return n12.preventDefault(), n12.stopPropagation(), o16({ type: 2, focus: a4.Next });
      case o13.ArrowUp:
        return n12.preventDefault(), n12.stopPropagation(), o16({ type: 2, focus: a4.Previous });
      case o13.Home:
      case o13.PageUp:
        return n12.preventDefault(), n12.stopPropagation(), o16({ type: 2, focus: a4.First });
      case o13.End:
      case o13.PageDown:
        return n12.preventDefault(), n12.stopPropagation(), o16({ type: 2, focus: a4.Last });
      case o13.Escape:
        n12.preventDefault(), n12.stopPropagation(), o16({ type: 1 }), o7().nextFrame(() => {
          var c16;
          return (c16 = t20.buttonRef.current) == null ? void 0 : c16.focus({ preventScroll: true });
        });
        break;
      case o13.Tab:
        n12.preventDefault(), n12.stopPropagation(), o16({ type: 1 }), o7().nextFrame(() => {
          _2(t20.buttonRef.current, n12.shiftKey ? M2.Previous : M2.Next);
        });
        break;
      default:
        n12.key.length === 1 && (o16({ type: 3, value: n12.key }), m10.setTimeout(() => o16({ type: 4 }), 350));
        break;
    }
  }), A8 = o9((n12) => {
    switch (n12.key) {
      case o13.Space:
        n12.preventDefault();
        break;
    }
  }), I9 = (0, import_react48.useMemo)(() => ({ open: t20.menuState === 0 }), [t20]), p12 = { "aria-activedescendant": t20.activeItemIndex === null || (R4 = t20.items[t20.activeItemIndex]) == null ? void 0 : R4.id, "aria-labelledby": (E8 = t20.buttonRef.current) == null ? void 0 : E8.id, id: i15, onKeyDown: g6, onKeyUp: A8, role: "menu", tabIndex: 0, ref: a13 };
  return X2({ ourProps: p12, theirProps: s20, slot: I9, defaultTag: ge4, features: Re2, visible: f16, name: "Menu.Items" });
}
var be = import_react48.Fragment;
function Ee(e9, u11) {
  let r15 = I2(), { id: i15 = `headlessui-menu-item-${r15}`, disabled: s20 = false, ...t20 } = e9, [o16, a13] = F5("Menu.Item"), l14 = o16.activeItemIndex !== null ? o16.items[o16.activeItemIndex].id === i15 : false, m10 = (0, import_react48.useRef)(null), M10 = y4(u11, m10);
  l5(() => {
    if (o16.menuState !== 0 || !l14 || o16.activationTrigger === 0)
      return;
    let c16 = o7();
    return c16.requestAnimationFrame(() => {
      var b6, _7;
      (_7 = (b6 = m10.current) == null ? void 0 : b6.scrollIntoView) == null || _7.call(b6, { block: "nearest" });
    }), c16.dispose;
  }, [m10, l14, o16.menuState, o16.activationTrigger, o16.activeItemIndex]);
  let f16 = (0, import_react48.useRef)({ disabled: s20, domRef: m10 });
  l5(() => {
    f16.current.disabled = s20;
  }, [f16, s20]), l5(() => {
    var c16, b6;
    f16.current.textValue = (b6 = (c16 = m10.current) == null ? void 0 : c16.textContent) == null ? void 0 : b6.toLowerCase();
  }, [f16, m10]), l5(() => (a13({ type: 5, id: i15, dataRef: f16 }), () => a13({ type: 6, id: i15 })), [f16, i15]);
  let g6 = o9(() => {
    a13({ type: 1 });
  }), A8 = o9((c16) => {
    if (s20)
      return c16.preventDefault();
    a13({ type: 1 }), D2(o16.buttonRef.current);
  }), I9 = o9(() => {
    if (s20)
      return a13({ type: 2, focus: a4.Nothing });
    a13({ type: 2, focus: a4.Specific, id: i15 });
  }), p12 = u6(), R4 = o9((c16) => p12.update(c16)), E8 = o9((c16) => {
    p12.wasMoved(c16) && (s20 || l14 || a13({ type: 2, focus: a4.Specific, id: i15, trigger: 0 }));
  }), n12 = o9((c16) => {
    p12.wasMoved(c16) && (s20 || l14 && a13({ type: 2, focus: a4.Nothing }));
  }), S11 = (0, import_react48.useMemo)(() => ({ active: l14, disabled: s20, close: g6 }), [l14, s20, g6]);
  return X2({ ourProps: { id: i15, ref: M10, role: "menuitem", tabIndex: s20 === true ? void 0 : -1, "aria-disabled": s20 === true ? true : void 0, disabled: void 0, onClick: A8, onFocus: I9, onPointerEnter: R4, onMouseEnter: R4, onPointerMove: E8, onMouseMove: E8, onPointerLeave: n12, onMouseLeave: n12 }, theirProps: t20, slot: S11, defaultTag: be, name: "Menu.Item" });
}
var Se2 = D3(ye2);
var Pe = D3(Me2);
var ve2 = D3(Ae);
var xe4 = D3(Ee);
var ot2 = Object.assign(Se2, { Button: Pe, Items: ve2, Item: xe4 });

// node_modules/@headlessui/react/dist/components/popover/popover.js
var import_react49 = __toESM(require_react(), 1);
var Fe2 = ((s20) => (s20[s20.Open = 0] = "Open", s20[s20.Closed = 1] = "Closed", s20))(Fe2 || {});
var Ie3 = ((t20) => (t20[t20.TogglePopover = 0] = "TogglePopover", t20[t20.ClosePopover = 1] = "ClosePopover", t20[t20.SetButton = 2] = "SetButton", t20[t20.SetButtonId = 3] = "SetButtonId", t20[t20.SetPanel = 4] = "SetPanel", t20[t20.SetPanelId = 5] = "SetPanelId", t20))(Ie3 || {});
var xe5 = { [0]: (o16) => ({ ...o16, popoverState: u4(o16.popoverState, { [0]: 1, [1]: 0 }) }), [1](o16) {
  return o16.popoverState === 1 ? o16 : { ...o16, popoverState: 1 };
}, [2](o16, l14) {
  return o16.button === l14.button ? o16 : { ...o16, button: l14.button };
}, [3](o16, l14) {
  return o16.buttonId === l14.buttonId ? o16 : { ...o16, buttonId: l14.buttonId };
}, [4](o16, l14) {
  return o16.panel === l14.panel ? o16 : { ...o16, panel: l14.panel };
}, [5](o16, l14) {
  return o16.panelId === l14.panelId ? o16 : { ...o16, panelId: l14.panelId };
} };
var le3 = (0, import_react49.createContext)(null);
le3.displayName = "PopoverContext";
function Q4(o16) {
  let l14 = (0, import_react49.useContext)(le3);
  if (l14 === null) {
    let s20 = new Error(`<${o16} /> is missing a parent <Popover /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(s20, Q4), s20;
  }
  return l14;
}
var ae2 = (0, import_react49.createContext)(null);
ae2.displayName = "PopoverAPIContext";
function pe3(o16) {
  let l14 = (0, import_react49.useContext)(ae2);
  if (l14 === null) {
    let s20 = new Error(`<${o16} /> is missing a parent <Popover /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(s20, pe3), s20;
  }
  return l14;
}
var se3 = (0, import_react49.createContext)(null);
se3.displayName = "PopoverGroupContext";
function ve3() {
  return (0, import_react49.useContext)(se3);
}
var Z5 = (0, import_react49.createContext)(null);
Z5.displayName = "PopoverPanelContext";
function Le2() {
  return (0, import_react49.useContext)(Z5);
}
function Me3(o16, l14) {
  return u4(l14.type, xe5, o16, l14);
}
var Be3 = "div";
function De(o16, l14) {
  var B5;
  let s20 = (0, import_react49.useRef)(null), R4 = y4(l14, T2((e9) => {
    s20.current = e9;
  })), C5 = (0, import_react49.useRef)([]), r15 = (0, import_react49.useReducer)(Me3, { popoverState: 1, buttons: C5, button: null, buttonId: null, panel: null, panelId: null, beforePanelSentinel: (0, import_react49.createRef)(), afterPanelSentinel: (0, import_react49.createRef)() }), [{ popoverState: t20, button: a13, buttonId: v6, panel: f16, panelId: F9, beforePanelSentinel: T7, afterPanelSentinel: d17 }, i15] = r15, p12 = n10((B5 = s20.current) != null ? B5 : a13), P6 = (0, import_react49.useMemo)(() => {
    if (!a13 || !f16)
      return false;
    for (let N6 of document.querySelectorAll("body > *"))
      if (Number(N6 == null ? void 0 : N6.contains(a13)) ^ Number(N6 == null ? void 0 : N6.contains(f16)))
        return true;
    let e9 = f4(), n12 = e9.indexOf(a13), A8 = (n12 + e9.length - 1) % e9.length, g6 = (n12 + 1) % e9.length, G5 = e9[A8], Te4 = e9[g6];
    return !f16.contains(G5) && !f16.contains(Te4);
  }, [a13, f16]), S11 = s5(v6), y9 = s5(F9), x7 = (0, import_react49.useMemo)(() => ({ buttonId: S11, panelId: y9, close: () => i15({ type: 1 }) }), [S11, y9, i15]), O5 = ve3(), L6 = O5 == null ? void 0 : O5.registerPopover, j6 = o9(() => {
    var e9;
    return (e9 = O5 == null ? void 0 : O5.isFocusWithinPopoverGroup()) != null ? e9 : (p12 == null ? void 0 : p12.activeElement) && ((a13 == null ? void 0 : a13.contains(p12.activeElement)) || (f16 == null ? void 0 : f16.contains(p12.activeElement)));
  });
  (0, import_react49.useEffect)(() => L6 == null ? void 0 : L6(x7), [L6, x7]), E5(p12 == null ? void 0 : p12.defaultView, "focus", (e9) => {
    var n12, A8, g6, G5;
    t20 === 0 && (j6() || a13 && f16 && e9.target !== window && ((A8 = (n12 = T7.current) == null ? void 0 : n12.contains) != null && A8.call(n12, e9.target) || (G5 = (g6 = d17.current) == null ? void 0 : g6.contains) != null && G5.call(g6, e9.target) || i15({ type: 1 })));
  }, true), L2([a13, f16], (e9, n12) => {
    i15({ type: 1 }), h3(n12, T.Loose) || (e9.preventDefault(), a13 == null || a13.focus());
  }, t20 === 0);
  let M10 = o9((e9) => {
    i15({ type: 1 });
    let n12 = (() => e9 ? e9 instanceof HTMLElement ? e9 : "current" in e9 && e9.current instanceof HTMLElement ? e9.current : a13 : a13)();
    n12 == null || n12.focus();
  }), u11 = (0, import_react49.useMemo)(() => ({ close: M10, isPortalled: P6 }), [M10, P6]), m10 = (0, import_react49.useMemo)(() => ({ open: t20 === 0, close: M10 }), [t20, M10]), E8 = o16, c16 = { ref: R4 };
  return import_react49.default.createElement(Z5.Provider, { value: null }, import_react49.default.createElement(le3.Provider, { value: r15 }, import_react49.default.createElement(ae2.Provider, { value: u11 }, import_react49.default.createElement(c8, { value: u4(t20, { [0]: d6.Open, [1]: d6.Closed }) }, X2({ ourProps: c16, theirProps: E8, slot: m10, defaultTag: Be3, name: "Popover" })))));
}
var he = "button";
function He4(o16, l14) {
  let s20 = I2(), { id: R4 = `headlessui-popover-button-${s20}`, ...C5 } = o16, [r15, t20] = Q4("Popover.Button"), { isPortalled: a13 } = pe3("Popover.Button"), v6 = (0, import_react49.useRef)(null), f16 = `headlessui-focus-sentinel-${I2()}`, F9 = ve3(), T7 = F9 == null ? void 0 : F9.closeOthers, i15 = Le2() !== null;
  (0, import_react49.useEffect)(() => {
    if (!i15)
      return t20({ type: 3, buttonId: R4 }), () => {
        t20({ type: 3, buttonId: null });
      };
  }, [i15, R4, t20]);
  let [p12] = (0, import_react49.useState)(() => Symbol()), P6 = y4(v6, l14, i15 ? null : (e9) => {
    if (e9)
      r15.buttons.current.push(p12);
    else {
      let n12 = r15.buttons.current.indexOf(p12);
      n12 !== -1 && r15.buttons.current.splice(n12, 1);
    }
    r15.buttons.current.length > 1 && console.warn("You are already using a <Popover.Button /> but only 1 <Popover.Button /> is supported."), e9 && t20({ type: 2, button: e9 });
  }), S11 = y4(v6, l14), y9 = n10(v6), x7 = o9((e9) => {
    var n12, A8, g6;
    if (i15) {
      if (r15.popoverState === 1)
        return;
      switch (e9.key) {
        case o13.Space:
        case o13.Enter:
          e9.preventDefault(), (A8 = (n12 = e9.target).click) == null || A8.call(n12), t20({ type: 1 }), (g6 = r15.button) == null || g6.focus();
          break;
      }
    } else
      switch (e9.key) {
        case o13.Space:
        case o13.Enter:
          e9.preventDefault(), e9.stopPropagation(), r15.popoverState === 1 && (T7 == null || T7(r15.buttonId)), t20({ type: 0 });
          break;
        case o13.Escape:
          if (r15.popoverState !== 0)
            return T7 == null ? void 0 : T7(r15.buttonId);
          if (!v6.current || y9 != null && y9.activeElement && !v6.current.contains(y9.activeElement))
            return;
          e9.preventDefault(), e9.stopPropagation(), t20({ type: 1 });
          break;
      }
  }), O5 = o9((e9) => {
    i15 || e9.key === o13.Space && e9.preventDefault();
  }), L6 = o9((e9) => {
    var n12, A8;
    r8(e9.currentTarget) || o16.disabled || (i15 ? (t20({ type: 1 }), (n12 = r15.button) == null || n12.focus()) : (e9.preventDefault(), e9.stopPropagation(), r15.popoverState === 1 && (T7 == null || T7(r15.buttonId)), t20({ type: 0 }), (A8 = r15.button) == null || A8.focus()));
  }), j6 = o9((e9) => {
    e9.preventDefault(), e9.stopPropagation();
  }), M10 = r15.popoverState === 0, u11 = (0, import_react49.useMemo)(() => ({ open: M10 }), [M10]), m10 = s9(o16, v6), E8 = i15 ? { ref: S11, type: m10, onKeyDown: x7, onClick: L6 } : { ref: P6, id: r15.buttonId, type: m10, "aria-expanded": o16.disabled ? void 0 : r15.popoverState === 0, "aria-controls": r15.panel ? r15.panelId : void 0, onKeyDown: x7, onKeyUp: O5, onClick: L6, onMouseDown: j6 }, c16 = n9(), B5 = o9(() => {
    let e9 = r15.panel;
    if (!e9)
      return;
    function n12() {
      u4(c16.current, { [s14.Forwards]: () => O2(e9, M2.First), [s14.Backwards]: () => O2(e9, M2.Last) }) === N2.Error && O2(f4().filter((g6) => g6.dataset.headlessuiFocusGuard !== "true"), u4(c16.current, { [s14.Forwards]: M2.Next, [s14.Backwards]: M2.Previous }), { relativeTo: r15.button });
    }
    n12();
  });
  return import_react49.default.createElement(import_react49.default.Fragment, null, X2({ ourProps: E8, theirProps: C5, slot: u11, defaultTag: he, name: "Popover.Button" }), M10 && !i15 && a13 && import_react49.default.createElement(c7, { id: f16, features: p6.Focusable, "data-headlessui-focus-guard": true, as: "button", type: "button", onFocus: B5 }));
}
var Ge4 = "div";
var _e2 = S3.RenderStrategy | S3.Static;
function ke3(o16, l14) {
  let s20 = I2(), { id: R4 = `headlessui-popover-overlay-${s20}`, ...C5 } = o16, [{ popoverState: r15 }, t20] = Q4("Popover.Overlay"), a13 = y4(l14), v6 = C2(), f16 = (() => v6 !== null ? (v6 & d6.Open) === d6.Open : r15 === 0)(), F9 = o9((i15) => {
    if (r8(i15.currentTarget))
      return i15.preventDefault();
    t20({ type: 1 });
  }), T7 = (0, import_react49.useMemo)(() => ({ open: r15 === 0 }), [r15]);
  return X2({ ourProps: { ref: a13, id: R4, "aria-hidden": true, onClick: F9 }, theirProps: C5, slot: T7, defaultTag: Ge4, features: _e2, visible: f16, name: "Popover.Overlay" });
}
var we3 = "div";
var Ne4 = S3.RenderStrategy | S3.Static;
function Ue4(o16, l14) {
  let s20 = I2(), { id: R4 = `headlessui-popover-panel-${s20}`, focus: C5 = false, ...r15 } = o16, [t20, a13] = Q4("Popover.Panel"), { close: v6, isPortalled: f16 } = pe3("Popover.Panel"), F9 = `headlessui-focus-sentinel-before-${I2()}`, T7 = `headlessui-focus-sentinel-after-${I2()}`, d17 = (0, import_react49.useRef)(null), i15 = y4(d17, l14, (u11) => {
    a13({ type: 4, panel: u11 });
  }), p12 = n10(d17);
  l5(() => (a13({ type: 5, panelId: R4 }), () => {
    a13({ type: 5, panelId: null });
  }), [R4, a13]);
  let P6 = C2(), S11 = (() => P6 !== null ? (P6 & d6.Open) === d6.Open : t20.popoverState === 0)(), y9 = o9((u11) => {
    var m10;
    switch (u11.key) {
      case o13.Escape:
        if (t20.popoverState !== 0 || !d17.current || p12 != null && p12.activeElement && !d17.current.contains(p12.activeElement))
          return;
        u11.preventDefault(), u11.stopPropagation(), a13({ type: 1 }), (m10 = t20.button) == null || m10.focus();
        break;
    }
  });
  (0, import_react49.useEffect)(() => {
    var u11;
    o16.static || t20.popoverState === 1 && ((u11 = o16.unmount) == null || u11) && a13({ type: 4, panel: null });
  }, [t20.popoverState, o16.unmount, o16.static, a13]), (0, import_react49.useEffect)(() => {
    if (!C5 || t20.popoverState !== 0 || !d17.current)
      return;
    let u11 = p12 == null ? void 0 : p12.activeElement;
    d17.current.contains(u11) || O2(d17.current, M2.First);
  }, [C5, d17, t20.popoverState]);
  let x7 = (0, import_react49.useMemo)(() => ({ open: t20.popoverState === 0, close: v6 }), [t20, v6]), O5 = { ref: i15, id: R4, onKeyDown: y9, onBlur: C5 && t20.popoverState === 0 ? (u11) => {
    var E8, c16, B5, e9, n12;
    let m10 = u11.relatedTarget;
    m10 && d17.current && ((E8 = d17.current) != null && E8.contains(m10) || (a13({ type: 1 }), ((B5 = (c16 = t20.beforePanelSentinel.current) == null ? void 0 : c16.contains) != null && B5.call(c16, m10) || (n12 = (e9 = t20.afterPanelSentinel.current) == null ? void 0 : e9.contains) != null && n12.call(e9, m10)) && m10.focus({ preventScroll: true })));
  } : void 0, tabIndex: -1 }, L6 = n9(), j6 = o9(() => {
    let u11 = d17.current;
    if (!u11)
      return;
    function m10() {
      u4(L6.current, { [s14.Forwards]: () => {
        var c16;
        O2(u11, M2.First) === N2.Error && ((c16 = t20.afterPanelSentinel.current) == null || c16.focus());
      }, [s14.Backwards]: () => {
        var E8;
        (E8 = t20.button) == null || E8.focus({ preventScroll: true });
      } });
    }
    m10();
  }), M10 = o9(() => {
    let u11 = d17.current;
    if (!u11)
      return;
    function m10() {
      u4(L6.current, { [s14.Forwards]: () => {
        var A8;
        if (!t20.button)
          return;
        let E8 = f4(), c16 = E8.indexOf(t20.button), B5 = E8.slice(0, c16 + 1), n12 = [...E8.slice(c16 + 1), ...B5];
        for (let g6 of n12.slice())
          if (g6.dataset.headlessuiFocusGuard === "true" || (A8 = t20.panel) != null && A8.contains(g6)) {
            let G5 = n12.indexOf(g6);
            G5 !== -1 && n12.splice(G5, 1);
          }
        O2(n12, M2.First, { sorted: false });
      }, [s14.Backwards]: () => {
        var c16;
        O2(u11, M2.Previous) === N2.Error && ((c16 = t20.button) == null || c16.focus());
      } });
    }
    m10();
  });
  return import_react49.default.createElement(Z5.Provider, { value: R4 }, S11 && f16 && import_react49.default.createElement(c7, { id: F9, ref: t20.beforePanelSentinel, features: p6.Focusable, "data-headlessui-focus-guard": true, as: "button", type: "button", onFocus: j6 }), X2({ ourProps: O5, theirProps: r15, slot: x7, defaultTag: we3, features: Ne4, visible: S11, name: "Popover.Panel" }), S11 && f16 && import_react49.default.createElement(c7, { id: T7, ref: t20.afterPanelSentinel, features: p6.Focusable, "data-headlessui-focus-guard": true, as: "button", type: "button", onFocus: M10 }));
}
var Ke4 = "div";
function We4(o16, l14) {
  let s20 = (0, import_react49.useRef)(null), R4 = y4(s20, l14), [C5, r15] = (0, import_react49.useState)([]), t20 = o9((p12) => {
    r15((P6) => {
      let S11 = P6.indexOf(p12);
      if (S11 !== -1) {
        let y9 = P6.slice();
        return y9.splice(S11, 1), y9;
      }
      return P6;
    });
  }), a13 = o9((p12) => (r15((P6) => [...P6, p12]), () => t20(p12))), v6 = o9(() => {
    var S11;
    let p12 = e4(s20);
    if (!p12)
      return false;
    let P6 = p12.activeElement;
    return (S11 = s20.current) != null && S11.contains(P6) ? true : C5.some((y9) => {
      var x7, O5;
      return ((x7 = p12.getElementById(y9.buttonId.current)) == null ? void 0 : x7.contains(P6)) || ((O5 = p12.getElementById(y9.panelId.current)) == null ? void 0 : O5.contains(P6));
    });
  }), f16 = o9((p12) => {
    for (let P6 of C5)
      P6.buttonId.current !== p12 && P6.close();
  }), F9 = (0, import_react49.useMemo)(() => ({ registerPopover: a13, unregisterPopover: t20, isFocusWithinPopoverGroup: v6, closeOthers: f16 }), [a13, t20, v6, f16]), T7 = (0, import_react49.useMemo)(() => ({}), []), d17 = o16, i15 = { ref: R4 };
  return import_react49.default.createElement(se3.Provider, { value: F9 }, X2({ ourProps: i15, theirProps: d17, slot: T7, defaultTag: Ke4, name: "Popover.Group" }));
}
var je4 = D3(De);
var Ve3 = D3(He4);
var $e4 = D3(ke3);
var Je4 = D3(Ue4);
var Xe4 = D3(We4);
var Lt = Object.assign(je4, { Button: Ve3, Overlay: $e4, Panel: Je4, Group: Xe4 });

// node_modules/@headlessui/react/dist/components/radio-group/radio-group.js
var import_react52 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/hooks/use-flags.js
var import_react50 = __toESM(require_react(), 1);
function c14(a13 = 0) {
  let [l14, r15] = (0, import_react50.useState)(a13), t20 = f9(), o16 = (0, import_react50.useCallback)((e9) => {
    t20.current && r15((u11) => u11 | e9);
  }, [l14, t20]), m10 = (0, import_react50.useCallback)((e9) => Boolean(l14 & e9), [l14]), s20 = (0, import_react50.useCallback)((e9) => {
    t20.current && r15((u11) => u11 & ~e9);
  }, [r15, t20]), g6 = (0, import_react50.useCallback)((e9) => {
    t20.current && r15((u11) => u11 ^ e9);
  }, [r15]);
  return { flags: l14, addFlag: o16, hasFlag: m10, removeFlag: s20, toggleFlag: g6 };
}

// node_modules/@headlessui/react/dist/components/label/label.js
var import_react51 = __toESM(require_react(), 1);
var d13 = (0, import_react51.createContext)(null);
function u10() {
  let o16 = (0, import_react51.useContext)(d13);
  if (o16 === null) {
    let t20 = new Error("You used a <Label /> component, but it is not inside a relevant parent.");
    throw Error.captureStackTrace && Error.captureStackTrace(t20, u10), t20;
  }
  return o16;
}
function H7() {
  let [o16, t20] = (0, import_react51.useState)([]);
  return [o16.length > 0 ? o16.join(" ") : void 0, (0, import_react51.useMemo)(() => function(e9) {
    let s20 = o9((r15) => (t20((l14) => [...l14, r15]), () => t20((l14) => {
      let n12 = l14.slice(), p12 = n12.indexOf(r15);
      return p12 !== -1 && n12.splice(p12, 1), n12;
    }))), a13 = (0, import_react51.useMemo)(() => ({ register: s20, slot: e9.slot, name: e9.name, props: e9.props }), [s20, e9.slot, e9.name, e9.props]);
    return import_react51.default.createElement(d13.Provider, { value: a13 }, e9.children);
  }, [t20])];
}
var A4 = "label";
function h10(o16, t20) {
  let i15 = I2(), { id: e9 = `headlessui-label-${i15}`, passive: s20 = false, ...a13 } = o16, r15 = u10(), l14 = y4(t20);
  l5(() => r15.register(e9), [e9, r15.register]);
  let n12 = { ref: l14, ...r15.props, id: e9 };
  return s20 && ("onClick" in n12 && (delete n12.htmlFor, delete n12.onClick), "onClick" in a13 && delete a13.onClick), X2({ ourProps: n12, theirProps: a13, slot: r15.slot || {}, defaultTag: A4, name: r15.name || "Label" });
}
var v4 = D3(h10);
var M7 = Object.assign(v4, {});

// node_modules/@headlessui/react/dist/components/radio-group/radio-group.js
var Ce2 = ((t20) => (t20[t20.RegisterOption = 0] = "RegisterOption", t20[t20.UnregisterOption = 1] = "UnregisterOption", t20))(Ce2 || {});
var ke4 = { [0](r15, o16) {
  let t20 = [...r15.options, { id: o16.id, element: o16.element, propsRef: o16.propsRef }];
  return { ...r15, options: I3(t20, (p12) => p12.element.current) };
}, [1](r15, o16) {
  let t20 = r15.options.slice(), p12 = r15.options.findIndex((T7) => T7.id === o16.id);
  return p12 === -1 ? r15 : (t20.splice(p12, 1), { ...r15, options: t20 });
} };
var B4 = (0, import_react52.createContext)(null);
B4.displayName = "RadioGroupDataContext";
function oe2(r15) {
  let o16 = (0, import_react52.useContext)(B4);
  if (o16 === null) {
    let t20 = new Error(`<${r15} /> is missing a parent <RadioGroup /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t20, oe2), t20;
  }
  return o16;
}
var $5 = (0, import_react52.createContext)(null);
$5.displayName = "RadioGroupActionsContext";
function ne2(r15) {
  let o16 = (0, import_react52.useContext)($5);
  if (o16 === null) {
    let t20 = new Error(`<${r15} /> is missing a parent <RadioGroup /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t20, ne2), t20;
  }
  return o16;
}
function Le3(r15, o16) {
  return u4(o16.type, ke4, r15, o16);
}
var he2 = "div";
function Fe3(r15, o16) {
  let t20 = I2(), { id: p12 = `headlessui-radiogroup-${t20}`, value: T7, defaultValue: v6, form: S11, name: m10, onChange: M10, by: G5 = (e9, i15) => e9 === i15, disabled: C5 = false, ...H9 } = r15, y9 = o9(typeof G5 == "string" ? (e9, i15) => {
    let n12 = G5;
    return (e9 == null ? void 0 : e9[n12]) === (i15 == null ? void 0 : i15[n12]);
  } : G5), [P6, h11] = (0, import_react52.useReducer)(Le3, { options: [] }), a13 = P6.options, [N6, R4] = H7(), [k3, U6] = M3(), L6 = (0, import_react52.useRef)(null), W2 = y4(L6, o16), [l14, s20] = T4(T7, M10, v6), b6 = (0, import_react52.useMemo)(() => a13.find((e9) => !e9.propsRef.current.disabled), [a13]), F9 = (0, import_react52.useMemo)(() => a13.some((e9) => y9(e9.propsRef.current.value, l14)), [a13, l14]), d17 = o9((e9) => {
    var n12;
    if (C5 || y9(e9, l14))
      return false;
    let i15 = (n12 = a13.find((f16) => y9(f16.propsRef.current.value, e9))) == null ? void 0 : n12.propsRef.current;
    return i15 != null && i15.disabled ? false : (s20 == null || s20(e9), true);
  });
  F2({ container: L6.current, accept(e9) {
    return e9.getAttribute("role") === "radio" ? NodeFilter.FILTER_REJECT : e9.hasAttribute("role") ? NodeFilter.FILTER_SKIP : NodeFilter.FILTER_ACCEPT;
  }, walk(e9) {
    e9.setAttribute("role", "none");
  } });
  let x7 = o9((e9) => {
    let i15 = L6.current;
    if (!i15)
      return;
    let n12 = e4(i15), f16 = a13.filter((u11) => u11.propsRef.current.disabled === false).map((u11) => u11.element.current);
    switch (e9.key) {
      case o13.Enter:
        p5(e9.currentTarget);
        break;
      case o13.ArrowLeft:
      case o13.ArrowUp:
        if (e9.preventDefault(), e9.stopPropagation(), O2(f16, M2.Previous | M2.WrapAround) === N2.Success) {
          let g6 = a13.find((K4) => K4.element.current === (n12 == null ? void 0 : n12.activeElement));
          g6 && d17(g6.propsRef.current.value);
        }
        break;
      case o13.ArrowRight:
      case o13.ArrowDown:
        if (e9.preventDefault(), e9.stopPropagation(), O2(f16, M2.Next | M2.WrapAround) === N2.Success) {
          let g6 = a13.find((K4) => K4.element.current === (n12 == null ? void 0 : n12.activeElement));
          g6 && d17(g6.propsRef.current.value);
        }
        break;
      case o13.Space:
        {
          e9.preventDefault(), e9.stopPropagation();
          let u11 = a13.find((g6) => g6.element.current === (n12 == null ? void 0 : n12.activeElement));
          u11 && d17(u11.propsRef.current.value);
        }
        break;
    }
  }), c16 = o9((e9) => (h11({ type: 0, ...e9 }), () => h11({ type: 1, id: e9.id }))), _7 = (0, import_react52.useMemo)(() => ({ value: l14, firstOption: b6, containsCheckedOption: F9, disabled: C5, compare: y9, ...P6 }), [l14, b6, F9, C5, y9, P6]), ie4 = (0, import_react52.useMemo)(() => ({ registerOption: c16, change: d17 }), [c16, d17]), ae3 = { ref: W2, id: p12, role: "radiogroup", "aria-labelledby": N6, "aria-describedby": k3, onKeyDown: x7 }, pe4 = (0, import_react52.useMemo)(() => ({ value: l14 }), [l14]), w7 = (0, import_react52.useRef)(null), le4 = p4();
  return (0, import_react52.useEffect)(() => {
    w7.current && v6 !== void 0 && le4.addEventListener(w7.current, "reset", () => {
      d17(v6);
    });
  }, [w7, d17]), import_react52.default.createElement(U6, { name: "RadioGroup.Description" }, import_react52.default.createElement(R4, { name: "RadioGroup.Label" }, import_react52.default.createElement($5.Provider, { value: ie4 }, import_react52.default.createElement(B4.Provider, { value: _7 }, m10 != null && l14 != null && e6({ [m10]: l14 }).map(([e9, i15], n12) => import_react52.default.createElement(c7, { features: p6.Hidden, ref: n12 === 0 ? (f16) => {
    var u11;
    w7.current = (u11 = f16 == null ? void 0 : f16.closest("form")) != null ? u11 : null;
  } : void 0, ...R2({ key: e9, as: "input", type: "radio", checked: i15 != null, hidden: true, readOnly: true, form: S11, name: e9, value: i15 }) })), X2({ ourProps: ae3, theirProps: H9, slot: pe4, defaultTag: he2, name: "RadioGroup" })))));
}
var xe6 = ((t20) => (t20[t20.Empty = 1] = "Empty", t20[t20.Active = 2] = "Active", t20))(xe6 || {});
var _e3 = "div";
function we4(r15, o16) {
  var x7;
  let t20 = I2(), { id: p12 = `headlessui-radiogroup-option-${t20}`, value: T7, disabled: v6 = false, ...S11 } = r15, m10 = (0, import_react52.useRef)(null), M10 = y4(m10, o16), [G5, C5] = H7(), [H9, y9] = M3(), { addFlag: P6, removeFlag: h11, hasFlag: a13 } = c14(1), N6 = s5({ value: T7, disabled: v6 }), R4 = oe2("RadioGroup.Option"), k3 = ne2("RadioGroup.Option");
  l5(() => k3.registerOption({ id: p12, element: m10, propsRef: N6 }), [p12, k3, m10, r15]);
  let U6 = o9((c16) => {
    var _7;
    if (r8(c16.currentTarget))
      return c16.preventDefault();
    k3.change(T7) && (P6(2), (_7 = m10.current) == null || _7.focus());
  }), L6 = o9((c16) => {
    if (r8(c16.currentTarget))
      return c16.preventDefault();
    P6(2);
  }), W2 = o9(() => h11(2)), l14 = ((x7 = R4.firstOption) == null ? void 0 : x7.id) === p12, s20 = R4.disabled || v6, b6 = R4.compare(R4.value, T7), F9 = { ref: M10, id: p12, role: "radio", "aria-checked": b6 ? "true" : "false", "aria-labelledby": G5, "aria-describedby": H9, "aria-disabled": s20 ? true : void 0, tabIndex: (() => s20 ? -1 : b6 || !R4.containsCheckedOption && l14 ? 0 : -1)(), onClick: s20 ? void 0 : U6, onFocus: s20 ? void 0 : L6, onBlur: s20 ? void 0 : W2 }, d17 = (0, import_react52.useMemo)(() => ({ checked: b6, disabled: s20, active: a13(2) }), [b6, s20, a13]);
  return import_react52.default.createElement(y9, { name: "RadioGroup.Description" }, import_react52.default.createElement(C5, { name: "RadioGroup.Label" }, X2({ ourProps: F9, theirProps: S11, slot: d17, defaultTag: _e3, name: "RadioGroup.Option" })));
}
var Ie4 = D3(Fe3);
var Se3 = D3(we4);
var yt = Object.assign(Ie4, { Option: Se3, Label: M7, Description: b4 });

// node_modules/@headlessui/react/dist/components/switch/switch.js
var import_react53 = __toESM(require_react(), 1);
var y7 = (0, import_react53.createContext)(null);
y7.displayName = "GroupContext";
var Y6 = import_react53.Fragment;
function Z6(s20) {
  var d17;
  let [n12, p12] = (0, import_react53.useState)(null), [c16, f16] = H7(), [r15, h11] = M3(), l14 = (0, import_react53.useMemo)(() => ({ switch: n12, setSwitch: p12, labelledby: c16, describedby: r15 }), [n12, p12, c16, r15]), T7 = {}, b6 = s20;
  return import_react53.default.createElement(h11, { name: "Switch.Description" }, import_react53.default.createElement(f16, { name: "Switch.Label", props: { htmlFor: (d17 = l14.switch) == null ? void 0 : d17.id, onClick(t20) {
    n12 && (t20.currentTarget.tagName === "LABEL" && t20.preventDefault(), n12.click(), n12.focus({ preventScroll: true }));
  } } }, import_react53.default.createElement(y7.Provider, { value: l14 }, X2({ ourProps: T7, theirProps: b6, defaultTag: Y6, name: "Switch.Group" }))));
}
var ee3 = "button";
function te3(s20, n12) {
  let p12 = I2(), { id: c16 = `headlessui-switch-${p12}`, checked: f16, defaultChecked: r15 = false, onChange: h11, name: l14, value: T7, form: b6, ...d17 } = s20, t20 = (0, import_react53.useContext)(y7), u11 = (0, import_react53.useRef)(null), D9 = y4(u11, n12, t20 === null ? null : t20.setSwitch), [o16, a13] = T4(f16, h11, r15), S11 = o9(() => a13 == null ? void 0 : a13(!o16)), C5 = o9((e9) => {
    if (r8(e9.currentTarget))
      return e9.preventDefault();
    e9.preventDefault(), S11();
  }), L6 = o9((e9) => {
    e9.key === o13.Space ? (e9.preventDefault(), S11()) : e9.key === o13.Enter && p5(e9.currentTarget);
  }), v6 = o9((e9) => e9.preventDefault()), G5 = (0, import_react53.useMemo)(() => ({ checked: o16 }), [o16]), R4 = { id: c16, ref: D9, role: "switch", type: s9(s20, u11), tabIndex: 0, "aria-checked": o16, "aria-labelledby": t20 == null ? void 0 : t20.labelledby, "aria-describedby": t20 == null ? void 0 : t20.describedby, onClick: C5, onKeyUp: L6, onKeyPress: v6 }, k3 = p4();
  return (0, import_react53.useEffect)(() => {
    var w7;
    let e9 = (w7 = u11.current) == null ? void 0 : w7.closest("form");
    e9 && r15 !== void 0 && k3.addEventListener(e9, "reset", () => {
      a13(r15);
    });
  }, [u11, a13]), import_react53.default.createElement(import_react53.default.Fragment, null, l14 != null && o16 && import_react53.default.createElement(c7, { features: p6.Hidden, ...R2({ as: "input", type: "checkbox", hidden: true, readOnly: true, form: b6, checked: o16, name: l14, value: T7 }) }), X2({ ourProps: R4, theirProps: d17, slot: G5, defaultTag: ee3, name: "Switch" }));
}
var ne3 = D3(te3);
var re3 = Z6;
var Ge5 = Object.assign(ne3, { Group: re3, Label: M7, Description: b4 });

// node_modules/@headlessui/react/dist/components/tabs/tabs.js
var import_react55 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/internal/focus-sentinel.js
var import_react54 = __toESM(require_react(), 1);
function p11({ onFocus: n12 }) {
  let [r15, o16] = (0, import_react54.useState)(true);
  return r15 ? import_react54.default.createElement(c7, { as: "button", type: "button", features: p6.Focusable, onFocus: (a13) => {
    a13.preventDefault();
    let e9, u11 = 50;
    function t20() {
      if (u11-- <= 0) {
        e9 && cancelAnimationFrame(e9);
        return;
      }
      if (n12()) {
        o16(false), cancelAnimationFrame(e9);
        return;
      }
      e9 = requestAnimationFrame(t20);
    }
    e9 = requestAnimationFrame(t20);
  } }) : null;
}

// node_modules/@headlessui/react/dist/utils/stable-collection.js
var r14 = __toESM(require_react(), 1);
var s19 = r14.createContext(null);
function a12() {
  return { groups: /* @__PURE__ */ new Map(), get(n12, t20) {
    var c16;
    let e9 = this.groups.get(n12);
    e9 || (e9 = /* @__PURE__ */ new Map(), this.groups.set(n12, e9));
    let l14 = (c16 = e9.get(t20)) != null ? c16 : 0;
    e9.set(t20, l14 + 1);
    let o16 = Array.from(e9.keys()).indexOf(t20);
    function i15() {
      let u11 = e9.get(t20);
      u11 > 1 ? e9.set(t20, u11 - 1) : e9.delete(t20);
    }
    return [o16, i15];
  } };
}
function C4({ children: n12 }) {
  let t20 = r14.useRef(a12());
  return r14.createElement(s19.Provider, { value: t20 }, n12);
}
function d14(n12) {
  let t20 = r14.useContext(s19);
  if (!t20)
    throw new Error("You must wrap your component in a <StableCollection>");
  let e9 = f14(), [l14, o16] = t20.current.get(n12, e9);
  return r14.useEffect(() => o16, []), l14;
}
function f14() {
  var l14, o16, i15;
  let n12 = (i15 = (o16 = (l14 = r14.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) == null ? void 0 : l14.ReactCurrentOwner) == null ? void 0 : o16.current) != null ? i15 : null;
  if (!n12)
    return Symbol();
  let t20 = [], e9 = n12;
  for (; e9; )
    t20.push(e9.index), e9 = e9.return;
  return "$." + t20.join(".");
}

// node_modules/@headlessui/react/dist/components/tabs/tabs.js
var ue5 = ((t20) => (t20[t20.Forwards = 0] = "Forwards", t20[t20.Backwards = 1] = "Backwards", t20))(ue5 || {});
var Te3 = ((o16) => (o16[o16.Less = -1] = "Less", o16[o16.Equal = 0] = "Equal", o16[o16.Greater = 1] = "Greater", o16))(Te3 || {});
var de2 = ((r15) => (r15[r15.SetSelectedIndex = 0] = "SetSelectedIndex", r15[r15.RegisterTab = 1] = "RegisterTab", r15[r15.UnregisterTab = 2] = "UnregisterTab", r15[r15.RegisterPanel = 3] = "RegisterPanel", r15[r15.UnregisterPanel = 4] = "UnregisterPanel", r15))(de2 || {});
var ce3 = { [0](e9, n12) {
  var u11;
  let t20 = I3(e9.tabs, (T7) => T7.current), o16 = I3(e9.panels, (T7) => T7.current), s20 = t20.filter((T7) => {
    var l14;
    return !((l14 = T7.current) != null && l14.hasAttribute("disabled"));
  }), r15 = { ...e9, tabs: t20, panels: o16 };
  if (n12.index < 0 || n12.index > t20.length - 1) {
    let T7 = u4(Math.sign(n12.index - e9.selectedIndex), { [-1]: () => 1, [0]: () => u4(Math.sign(n12.index), { [-1]: () => 0, [0]: () => 0, [1]: () => 1 }), [1]: () => 0 });
    return s20.length === 0 ? r15 : { ...r15, selectedIndex: u4(T7, { [0]: () => t20.indexOf(s20[0]), [1]: () => t20.indexOf(s20[s20.length - 1]) }) };
  }
  let i15 = t20.slice(0, n12.index), b6 = [...t20.slice(n12.index), ...i15].find((T7) => s20.includes(T7));
  if (!b6)
    return r15;
  let c16 = (u11 = t20.indexOf(b6)) != null ? u11 : e9.selectedIndex;
  return c16 === -1 && (c16 = e9.selectedIndex), { ...r15, selectedIndex: c16 };
}, [1](e9, n12) {
  var r15;
  if (e9.tabs.includes(n12.tab))
    return e9;
  let t20 = e9.tabs[e9.selectedIndex], o16 = I3([...e9.tabs, n12.tab], (i15) => i15.current), s20 = (r15 = o16.indexOf(t20)) != null ? r15 : e9.selectedIndex;
  return s20 === -1 && (s20 = e9.selectedIndex), { ...e9, tabs: o16, selectedIndex: s20 };
}, [2](e9, n12) {
  return { ...e9, tabs: e9.tabs.filter((t20) => t20 !== n12.tab) };
}, [3](e9, n12) {
  return e9.panels.includes(n12.panel) ? e9 : { ...e9, panels: I3([...e9.panels, n12.panel], (t20) => t20.current) };
}, [4](e9, n12) {
  return { ...e9, panels: e9.panels.filter((t20) => t20 !== n12.panel) };
} };
var X8 = (0, import_react55.createContext)(null);
X8.displayName = "TabsDataContext";
function M9(e9) {
  let n12 = (0, import_react55.useContext)(X8);
  if (n12 === null) {
    let t20 = new Error(`<${e9} /> is missing a parent <Tab.Group /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t20, M9), t20;
  }
  return n12;
}
var $6 = (0, import_react55.createContext)(null);
$6.displayName = "TabsActionsContext";
function q5(e9) {
  let n12 = (0, import_react55.useContext)($6);
  if (n12 === null) {
    let t20 = new Error(`<${e9} /> is missing a parent <Tab.Group /> component.`);
    throw Error.captureStackTrace && Error.captureStackTrace(t20, q5), t20;
  }
  return n12;
}
function fe3(e9, n12) {
  return u4(n12.type, ce3, e9, n12);
}
var be2 = import_react55.Fragment;
function me3(e9, n12) {
  let { defaultIndex: t20 = 0, vertical: o16 = false, manual: s20 = false, onChange: r15, selectedIndex: i15 = null, ...R4 } = e9;
  const b6 = o16 ? "vertical" : "horizontal", c16 = s20 ? "manual" : "auto";
  let u11 = i15 !== null, T7 = y4(n12), [l14, d17] = (0, import_react55.useReducer)(fe3, { selectedIndex: i15 != null ? i15 : t20, tabs: [], panels: [] }), y9 = (0, import_react55.useMemo)(() => ({ selectedIndex: l14.selectedIndex }), [l14.selectedIndex]), m10 = s5(r15 || (() => {
  })), x7 = s5(l14.tabs), E8 = (0, import_react55.useMemo)(() => ({ orientation: b6, activation: c16, ...l14 }), [b6, c16, l14]), S11 = o9((p12) => (d17({ type: 1, tab: p12 }), () => d17({ type: 2, tab: p12 }))), A8 = o9((p12) => (d17({ type: 3, panel: p12 }), () => d17({ type: 4, panel: p12 }))), L6 = o9((p12) => {
    C5.current !== p12 && m10.current(p12), u11 || d17({ type: 0, index: p12 });
  }), C5 = s5(u11 ? e9.selectedIndex : l14.selectedIndex), N6 = (0, import_react55.useMemo)(() => ({ registerTab: S11, registerPanel: A8, change: L6 }), []);
  l5(() => {
    d17({ type: 0, index: i15 != null ? i15 : t20 });
  }, [i15]), l5(() => {
    if (C5.current === void 0 || l14.tabs.length <= 0)
      return;
    let p12 = I3(l14.tabs, (a13) => a13.current);
    p12.some((a13, f16) => l14.tabs[f16] !== a13) && L6(p12.indexOf(l14.tabs[C5.current]));
  });
  let B5 = { ref: T7 };
  return import_react55.default.createElement(C4, null, import_react55.default.createElement($6.Provider, { value: N6 }, import_react55.default.createElement(X8.Provider, { value: E8 }, E8.tabs.length <= 0 && import_react55.default.createElement(p11, { onFocus: () => {
    var p12, I9;
    for (let a13 of x7.current)
      if (((p12 = a13.current) == null ? void 0 : p12.tabIndex) === 0)
        return (I9 = a13.current) == null || I9.focus(), true;
    return false;
  } }), X2({ ourProps: B5, theirProps: R4, slot: y9, defaultTag: be2, name: "Tabs" }))));
}
var Pe2 = "div";
function ge5(e9, n12) {
  let { orientation: t20, selectedIndex: o16 } = M9("Tab.List"), s20 = y4(n12);
  return X2({ ourProps: { ref: s20, role: "tablist", "aria-orientation": t20 }, theirProps: e9, slot: { selectedIndex: o16 }, defaultTag: Pe2, name: "Tabs.List" });
}
var ye3 = "button";
function xe7(e9, n12) {
  var p12, I9;
  let t20 = I2(), { id: o16 = `headlessui-tabs-tab-${t20}`, ...s20 } = e9, { orientation: r15, activation: i15, selectedIndex: R4, tabs: b6, panels: c16 } = M9("Tab"), u11 = q5("Tab"), T7 = M9("Tab"), l14 = (0, import_react55.useRef)(null), d17 = y4(l14, n12);
  l5(() => u11.registerTab(l14), [u11, l14]);
  let y9 = d14("tabs"), m10 = b6.indexOf(l14);
  m10 === -1 && (m10 = y9);
  let x7 = m10 === R4, E8 = o9((a13) => {
    var j6;
    let f16 = a13();
    if (f16 === N2.Success && i15 === "auto") {
      let W2 = (j6 = e4(l14)) == null ? void 0 : j6.activeElement, z7 = T7.tabs.findIndex((te4) => te4.current === W2);
      z7 !== -1 && u11.change(z7);
    }
    return f16;
  }), S11 = o9((a13) => {
    let f16 = b6.map((W2) => W2.current).filter(Boolean);
    if (a13.key === o13.Space || a13.key === o13.Enter) {
      a13.preventDefault(), a13.stopPropagation(), u11.change(m10);
      return;
    }
    switch (a13.key) {
      case o13.Home:
      case o13.PageUp:
        return a13.preventDefault(), a13.stopPropagation(), E8(() => O2(f16, M2.First));
      case o13.End:
      case o13.PageDown:
        return a13.preventDefault(), a13.stopPropagation(), E8(() => O2(f16, M2.Last));
    }
    if (E8(() => u4(r15, { vertical() {
      return a13.key === o13.ArrowUp ? O2(f16, M2.Previous | M2.WrapAround) : a13.key === o13.ArrowDown ? O2(f16, M2.Next | M2.WrapAround) : N2.Error;
    }, horizontal() {
      return a13.key === o13.ArrowLeft ? O2(f16, M2.Previous | M2.WrapAround) : a13.key === o13.ArrowRight ? O2(f16, M2.Next | M2.WrapAround) : N2.Error;
    } })) === N2.Success)
      return a13.preventDefault();
  }), A8 = (0, import_react55.useRef)(false), L6 = o9(() => {
    var a13;
    A8.current || (A8.current = true, (a13 = l14.current) == null || a13.focus(), u11.change(m10), t8(() => {
      A8.current = false;
    }));
  }), C5 = o9((a13) => {
    a13.preventDefault();
  }), N6 = (0, import_react55.useMemo)(() => ({ selected: x7 }), [x7]), B5 = { ref: d17, onKeyDown: S11, onMouseDown: C5, onClick: L6, id: o16, role: "tab", type: s9(e9, l14), "aria-controls": (I9 = (p12 = c16[m10]) == null ? void 0 : p12.current) == null ? void 0 : I9.id, "aria-selected": x7, tabIndex: x7 ? 0 : -1 };
  return X2({ ourProps: B5, theirProps: s20, slot: N6, defaultTag: ye3, name: "Tabs.Tab" });
}
var Ee2 = "div";
function Ae2(e9, n12) {
  let { selectedIndex: t20 } = M9("Tab.Panels"), o16 = y4(n12), s20 = (0, import_react55.useMemo)(() => ({ selectedIndex: t20 }), [t20]);
  return X2({ ourProps: { ref: o16 }, theirProps: e9, slot: s20, defaultTag: Ee2, name: "Tabs.Panels" });
}
var Re3 = "div";
var Le4 = S3.RenderStrategy | S3.Static;
function De2(e9, n12) {
  var E8, S11, A8, L6;
  let t20 = I2(), { id: o16 = `headlessui-tabs-panel-${t20}`, tabIndex: s20 = 0, ...r15 } = e9, { selectedIndex: i15, tabs: R4, panels: b6 } = M9("Tab.Panel"), c16 = q5("Tab.Panel"), u11 = (0, import_react55.useRef)(null), T7 = y4(u11, n12);
  l5(() => c16.registerPanel(u11), [c16, u11]);
  let l14 = d14("panels"), d17 = b6.indexOf(u11);
  d17 === -1 && (d17 = l14);
  let y9 = d17 === i15, m10 = (0, import_react55.useMemo)(() => ({ selected: y9 }), [y9]), x7 = { ref: T7, id: o16, role: "tabpanel", "aria-labelledby": (S11 = (E8 = R4[d17]) == null ? void 0 : E8.current) == null ? void 0 : S11.id, tabIndex: y9 ? s20 : -1 };
  return !y9 && ((A8 = r15.unmount) == null || A8) && !((L6 = r15.static) != null && L6) ? import_react55.default.createElement(c7, { as: "span", ...x7 }) : X2({ ourProps: x7, theirProps: r15, slot: m10, defaultTag: Re3, features: Le4, visible: y9, name: "Tabs.Panel" });
}
var Se4 = D3(xe7);
var Ie5 = D3(me3);
var Fe4 = D3(ge5);
var he3 = D3(Ae2);
var Me4 = D3(De2);
var rt = Object.assign(Se4, { Group: Ie5, List: Fe4, Panels: he3, Panel: Me4 });

// node_modules/@headlessui/react/dist/components/transitions/transition.js
var import_react56 = __toESM(require_react(), 1);

// node_modules/@headlessui/react/dist/utils/once.js
function l13(r15) {
  let e9 = { called: false };
  return (...t20) => {
    if (!e9.called)
      return e9.called = true, r15(...t20);
  };
}

// node_modules/@headlessui/react/dist/components/transitions/utils/transition.js
function d15(t20, ...e9) {
  t20 && e9.length > 0 && t20.classList.add(...e9);
}
function v5(t20, ...e9) {
  t20 && e9.length > 0 && t20.classList.remove(...e9);
}
function F8(t20, e9) {
  let n12 = o7();
  if (!t20)
    return n12.dispose;
  let { transitionDuration: m10, transitionDelay: o16 } = getComputedStyle(t20), [u11, p12] = [m10, o16].map((a13) => {
    let [r15 = 0] = a13.split(",").filter(Boolean).map((i15) => i15.includes("ms") ? parseFloat(i15) : parseFloat(i15) * 1e3).sort((i15, f16) => f16 - i15);
    return r15;
  }), l14 = u11 + p12;
  if (l14 !== 0) {
    n12.group((r15) => {
      r15.setTimeout(() => {
        e9(), r15.dispose();
      }, l14), r15.addEventListener(t20, "transitionrun", (i15) => {
        i15.target === i15.currentTarget && r15.dispose();
      });
    });
    let a13 = n12.addEventListener(t20, "transitionend", (r15) => {
      r15.target === r15.currentTarget && (e9(), a13());
    });
  } else
    e9();
  return n12.add(() => e9()), n12.dispose;
}
function y8(t20, e9, n12, m10) {
  let o16 = n12 ? "enter" : "leave", u11 = o7(), p12 = m10 !== void 0 ? l13(m10) : () => {
  };
  o16 === "enter" && (t20.removeAttribute("hidden"), t20.style.display = "");
  let l14 = u4(o16, { enter: () => e9.enter, leave: () => e9.leave }), a13 = u4(o16, { enter: () => e9.enterTo, leave: () => e9.leaveTo }), r15 = u4(o16, { enter: () => e9.enterFrom, leave: () => e9.leaveFrom });
  return v5(t20, ...e9.enter, ...e9.enterTo, ...e9.enterFrom, ...e9.leave, ...e9.leaveFrom, ...e9.leaveTo, ...e9.entered), d15(t20, ...l14, ...r15), u11.nextFrame(() => {
    v5(t20, ...r15), d15(t20, ...a13), F8(t20, () => (v5(t20, ...l14), d15(t20, ...e9.entered), p12()));
  }), u11.dispose;
}

// node_modules/@headlessui/react/dist/hooks/use-transition.js
function D8({ container: i15, direction: t20, classes: o16, onStart: s20, onStop: u11 }) {
  let a13 = f9(), c16 = p4(), r15 = s5(t20);
  l5(() => {
    let e9 = o7();
    c16.add(e9.dispose);
    let n12 = i15.current;
    if (n12 && r15.current !== "idle" && a13.current)
      return e9.dispose(), s20.current(r15.current), e9.add(y8(n12, o16.current, r15.current === "enter", () => {
        e9.dispose(), u11.current(r15.current);
      })), e9.dispose;
  }, [t20]);
}

// node_modules/@headlessui/react/dist/components/transitions/transition.js
function S10(n12 = "") {
  return n12.split(" ").filter((t20) => t20.trim().length > 1);
}
var A7 = (0, import_react56.createContext)(null);
A7.displayName = "TransitionContext";
var Ce3 = ((r15) => (r15.Visible = "visible", r15.Hidden = "hidden", r15))(Ce3 || {});
function Ee3() {
  let n12 = (0, import_react56.useContext)(A7);
  if (n12 === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return n12;
}
function be3() {
  let n12 = (0, import_react56.useContext)(I8);
  if (n12 === null)
    throw new Error("A <Transition.Child /> is used but it is missing a parent <Transition /> or <Transition.Root />.");
  return n12;
}
var I8 = (0, import_react56.createContext)(null);
I8.displayName = "NestingContext";
function _6(n12) {
  return "children" in n12 ? _6(n12.children) : n12.current.filter(({ el: t20 }) => t20.current !== null).filter(({ state: t20 }) => t20 === "visible").length > 0;
}
function ne5(n12, t20) {
  let r15 = s5(n12), o16 = (0, import_react56.useRef)([]), y9 = f9(), N6 = p4(), p12 = o9((s20, e9 = j2.Hidden) => {
    let a13 = o16.current.findIndex(({ el: i15 }) => i15 === s20);
    a13 !== -1 && (u4(e9, { [j2.Unmount]() {
      o16.current.splice(a13, 1);
    }, [j2.Hidden]() {
      o16.current[a13].state = "hidden";
    } }), N6.microTask(() => {
      var i15;
      !_6(o16) && y9.current && ((i15 = r15.current) == null || i15.call(r15));
    }));
  }), x7 = o9((s20) => {
    let e9 = o16.current.find(({ el: a13 }) => a13 === s20);
    return e9 ? e9.state !== "visible" && (e9.state = "visible") : o16.current.push({ el: s20, state: "visible" }), () => p12(s20, j2.Unmount);
  }), m10 = (0, import_react56.useRef)([]), c16 = (0, import_react56.useRef)(Promise.resolve()), u11 = (0, import_react56.useRef)({ enter: [], leave: [], idle: [] }), h11 = o9((s20, e9, a13) => {
    m10.current.splice(0), t20 && (t20.chains.current[e9] = t20.chains.current[e9].filter(([i15]) => i15 !== s20)), t20 == null || t20.chains.current[e9].push([s20, new Promise((i15) => {
      m10.current.push(i15);
    })]), t20 == null || t20.chains.current[e9].push([s20, new Promise((i15) => {
      Promise.all(u11.current[e9].map(([l14, T7]) => T7)).then(() => i15());
    })]), e9 === "enter" ? c16.current = c16.current.then(() => t20 == null ? void 0 : t20.wait.current).then(() => a13(e9)) : a13(e9);
  }), v6 = o9((s20, e9, a13) => {
    Promise.all(u11.current[e9].splice(0).map(([i15, l14]) => l14)).then(() => {
      var i15;
      (i15 = m10.current.shift()) == null || i15();
    }).then(() => a13(e9));
  });
  return (0, import_react56.useMemo)(() => ({ children: o16, register: x7, unregister: p12, onStart: h11, onStop: v6, wait: c16, chains: u11 }), [x7, p12, o16, h11, v6, u11, c16]);
}
function Se5() {
}
var xe8 = ["beforeEnter", "afterEnter", "beforeLeave", "afterLeave"];
function re5(n12) {
  var r15;
  let t20 = {};
  for (let o16 of xe8)
    t20[o16] = (r15 = n12[o16]) != null ? r15 : Se5;
  return t20;
}
function Pe3(n12) {
  let t20 = (0, import_react56.useRef)(re5(n12));
  return (0, import_react56.useEffect)(() => {
    t20.current = re5(n12);
  }, [n12]), t20;
}
var Re4 = "div";
var ie3 = S3.RenderStrategy;
function ye4(n12, t20) {
  let { beforeEnter: r15, afterEnter: o16, beforeLeave: y9, afterLeave: N6, enter: p12, enterFrom: x7, enterTo: m10, entered: c16, leave: u11, leaveFrom: h11, leaveTo: v6, ...s20 } = n12, e9 = (0, import_react56.useRef)(null), a13 = y4(e9, t20), i15 = s20.unmount ? j2.Unmount : j2.Hidden, { show: l14, appear: T7, initial: se5 } = Ee3(), [g6, M10] = (0, import_react56.useState)(l14 ? "visible" : "hidden"), z7 = be3(), { register: F9, unregister: L6 } = z7, U6 = (0, import_react56.useRef)(null);
  (0, import_react56.useEffect)(() => F9(e9), [F9, e9]), (0, import_react56.useEffect)(() => {
    if (i15 === j2.Hidden && e9.current) {
      if (l14 && g6 !== "visible") {
        M10("visible");
        return;
      }
      return u4(g6, { ["hidden"]: () => L6(e9), ["visible"]: () => F9(e9) });
    }
  }, [g6, e9, F9, L6, l14, i15]);
  let j6 = s5({ enter: S10(p12), enterFrom: S10(x7), enterTo: S10(m10), entered: S10(c16), leave: S10(u11), leaveFrom: S10(h11), leaveTo: S10(v6) }), w7 = Pe3({ beforeEnter: r15, afterEnter: o16, beforeLeave: y9, afterLeave: N6 }), k3 = l6();
  (0, import_react56.useEffect)(() => {
    if (k3 && g6 === "visible" && e9.current === null)
      throw new Error("Did you forget to passthrough the `ref` to the actual DOM node?");
  }, [e9, g6, k3]);
  let G5 = se5 && !T7, ae3 = (() => !k3 || G5 || U6.current === l14 ? "idle" : l14 ? "enter" : "leave")(), H9 = c14(0), le4 = o9((C5) => u4(C5, { enter: () => {
    H9.addFlag(d6.Opening), w7.current.beforeEnter();
  }, leave: () => {
    H9.addFlag(d6.Closing), w7.current.beforeLeave();
  }, idle: () => {
  } })), ue6 = o9((C5) => u4(C5, { enter: () => {
    H9.removeFlag(d6.Opening), w7.current.afterEnter();
  }, leave: () => {
    H9.removeFlag(d6.Closing), w7.current.afterLeave();
  }, idle: () => {
  } })), O5 = ne5(() => {
    M10("hidden"), L6(e9);
  }, z7);
  D8({ container: e9, classes: j6, direction: ae3, onStart: s5((C5) => {
    O5.onStart(e9, C5, le4);
  }), onStop: s5((C5) => {
    O5.onStop(e9, C5, ue6), C5 === "leave" && !_6(O5) && (M10("hidden"), L6(e9));
  }) }), (0, import_react56.useEffect)(() => {
    G5 && (i15 === j2.Hidden ? U6.current = null : U6.current = l14);
  }, [l14, G5, g6]);
  let B5 = s20, Te4 = { ref: a13 };
  return T7 && l14 && (B5 = { ...B5, className: e5(s20.className, ...j6.current.enter, ...j6.current.enterFrom) }), import_react56.default.createElement(I8.Provider, { value: O5 }, import_react56.default.createElement(c8, { value: u4(g6, { ["visible"]: d6.Open, ["hidden"]: d6.Closed }) | H9.flags }, X2({ ourProps: Te4, theirProps: B5, defaultTag: Re4, features: ie3, visible: g6 === "visible", name: "Transition.Child" })));
}
function Ne5(n12, t20) {
  let { show: r15, appear: o16 = false, unmount: y9, ...N6 } = n12, p12 = (0, import_react56.useRef)(null), x7 = y4(p12, t20);
  l6();
  let m10 = C2();
  if (r15 === void 0 && m10 !== null && (r15 = (m10 & d6.Open) === d6.Open), ![true, false].includes(r15))
    throw new Error("A <Transition /> is used but it is missing a `show={true | false}` prop.");
  let [c16, u11] = (0, import_react56.useState)(r15 ? "visible" : "hidden"), h11 = ne5(() => {
    u11("hidden");
  }), [v6, s20] = (0, import_react56.useState)(true), e9 = (0, import_react56.useRef)([r15]);
  l5(() => {
    v6 !== false && e9.current[e9.current.length - 1] !== r15 && (e9.current.push(r15), s20(false));
  }, [e9, r15]);
  let a13 = (0, import_react56.useMemo)(() => ({ show: r15, appear: o16, initial: v6 }), [r15, o16, v6]);
  (0, import_react56.useEffect)(() => {
    if (r15)
      u11("visible");
    else if (!_6(h11))
      u11("hidden");
    else {
      let l14 = p12.current;
      if (!l14)
        return;
      let T7 = l14.getBoundingClientRect();
      T7.x === 0 && T7.y === 0 && T7.width === 0 && T7.height === 0 && u11("hidden");
    }
  }, [r15, h11]);
  let i15 = { unmount: y9 };
  return import_react56.default.createElement(I8.Provider, { value: h11 }, import_react56.default.createElement(A7.Provider, { value: a13 }, X2({ ourProps: { ...i15, as: import_react56.Fragment, children: import_react56.default.createElement(oe3, { ref: x7, ...i15, ...N6 }) }, theirProps: {}, defaultTag: import_react56.Fragment, features: ie3, visible: c16 === "visible", name: "Transition" })));
}
function He5(n12, t20) {
  let r15 = (0, import_react56.useContext)(A7) !== null, o16 = C2() !== null;
  return import_react56.default.createElement(import_react56.default.Fragment, null, !r15 && o16 ? import_react56.default.createElement(q6, { ref: t20, ...n12 }) : import_react56.default.createElement(oe3, { ref: t20, ...n12 }));
}
var q6 = D3(Ne5);
var oe3 = D3(ye4);
var De3 = D3(He5);
var tt2 = Object.assign(q6, { Child: De3, Root: q6 });

// node_modules/final-form-arrays/dist/final-form-arrays.es.js
function _extends5() {
  _extends5 = Object.assign || function(target) {
    for (var i15 = 1; i15 < arguments.length; i15++) {
      var source = arguments[i15];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends5.apply(this, arguments);
}
function copyField(oldFields, oldKey, newFields, newKey) {
  newFields[newKey] = _extends5({}, oldFields[oldKey], {
    name: newKey,
    // prevent functions from being overwritten
    // if the newFields[newKey] does not exist, it will be created
    // when that field gets registered, with its own change/blur/focus callbacks
    change: oldFields[newKey] && oldFields[newKey].change,
    blur: oldFields[newKey] && oldFields[newKey].blur,
    focus: oldFields[newKey] && oldFields[newKey].focus,
    lastFieldState: void 0
    // clearing lastFieldState forces renotification
  });
  if (!newFields[newKey].change) {
    delete newFields[newKey].change;
  }
  if (!newFields[newKey].blur) {
    delete newFields[newKey].blur;
  }
  if (!newFields[newKey].focus) {
    delete newFields[newKey].focus;
  }
}
var escapeRegexTokens = function escapeRegexTokens2(string2) {
  return string2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
};
var insert = function insert2(_ref, state, _ref2) {
  var name2 = _ref[0], index2 = _ref[1], value = _ref[2];
  var changeValue = _ref2.changeValue;
  changeValue(state, name2, function(array2) {
    var copy = [].concat(array2 || []);
    copy.splice(index2, 0, value);
    return copy;
  });
  var pattern = new RegExp("^" + escapeRegexTokens(name2) + "\\[(\\d+)\\](.*)");
  var newFields = {};
  Object.keys(state.fields).forEach(function(key) {
    var tokens2 = pattern.exec(key);
    if (tokens2) {
      var fieldIndex = Number(tokens2[1]);
      if (fieldIndex >= index2) {
        var incrementedKey = name2 + "[" + (fieldIndex + 1) + "]" + tokens2[2];
        copyField(state.fields, key, newFields, incrementedKey);
        return;
      }
    }
    newFields[key] = state.fields[key];
  });
  state.fields = newFields;
};
var concat = function concat2(_ref, state, _ref2) {
  var name2 = _ref[0], value = _ref[1];
  var changeValue = _ref2.changeValue;
  changeValue(state, name2, function(array2) {
    return array2 ? [].concat(array2, value) : value;
  });
};
var move = function move2(_ref, state, _ref2) {
  var name2 = _ref[0], from2 = _ref[1], to4 = _ref[2];
  var changeValue = _ref2.changeValue;
  if (from2 === to4) {
    return;
  }
  changeValue(state, name2, function(array2) {
    var copy = [].concat(array2 || []);
    var value = copy[from2];
    copy.splice(from2, 1);
    copy.splice(to4, 0, value);
    return copy;
  });
  var newFields = {};
  var pattern = new RegExp("^" + escapeRegexTokens(name2) + "\\[(\\d+)\\](.*)");
  var lowest;
  var highest;
  var increment;
  if (from2 > to4) {
    lowest = to4;
    highest = from2;
    increment = 1;
  } else {
    lowest = from2;
    highest = to4;
    increment = -1;
  }
  Object.keys(state.fields).forEach(function(key) {
    var tokens2 = pattern.exec(key);
    if (tokens2) {
      var fieldIndex = Number(tokens2[1]);
      if (fieldIndex === from2) {
        var newKey = name2 + "[" + to4 + "]" + tokens2[2];
        copyField(state.fields, key, newFields, newKey);
        return;
      }
      if (lowest <= fieldIndex && fieldIndex <= highest) {
        var _newKey = name2 + "[" + (fieldIndex + increment) + "]" + tokens2[2];
        copyField(state.fields, key, newFields, _newKey);
        return;
      }
    }
    newFields[key] = state.fields[key];
  });
  state.fields = newFields;
};
var remove = function remove2(_ref, state, _ref2) {
  var name2 = _ref[0], index2 = _ref[1];
  var changeValue = _ref2.changeValue, getIn4 = _ref2.getIn, setIn3 = _ref2.setIn;
  var returnValue;
  changeValue(state, name2, function(array2) {
    if (!array2) {
      return array2;
    }
    var copy = [].concat(array2);
    returnValue = copy[index2];
    copy.splice(index2, 1);
    return copy.length > 0 ? copy : void 0;
  });
  var pattern = new RegExp("^" + escapeRegexTokens(name2) + "\\[(\\d+)\\](.*)");
  var newFields = {};
  Object.keys(state.fields).forEach(function(key) {
    var tokens2 = pattern.exec(key);
    if (tokens2) {
      var fieldIndex = Number(tokens2[1]);
      if (fieldIndex === index2) {
        if (key === name2 + "[" + index2 + "]") {
          var path = "formState.submitErrors." + name2;
          var submitErrors = getIn4(state, path);
          if (Array.isArray(submitErrors)) {
            submitErrors.splice(index2, 1);
            state = setIn3(state, path, submitErrors);
          }
        }
        return;
      }
      if (fieldIndex > index2) {
        var decrementedKey = name2 + "[" + (fieldIndex - 1) + "]" + tokens2[2];
        copyField(state.fields, key, newFields, decrementedKey);
        return;
      }
    }
    newFields[key] = state.fields[key];
  });
  state.fields = newFields;
  return returnValue;
};
var pop = function pop2(_ref, state, tools) {
  var name2 = _ref[0];
  var getIn4 = tools.getIn;
  var array2 = getIn4(state.formState.values, name2);
  return array2 && array2.length > 0 ? remove([name2, array2.length - 1], state, tools) : void 0;
};
var push = function push2(_ref, state, _ref2) {
  var name2 = _ref[0], value = _ref[1];
  var changeValue = _ref2.changeValue;
  changeValue(state, name2, function(array2) {
    return array2 ? [].concat(array2, [value]) : [value];
  });
};
var binarySearch = function binarySearch2(list, value) {
  var first = 0;
  var last2 = list.length - 1;
  var middle = 0;
  while (first <= last2) {
    middle = Math.floor((first + last2) / 2);
    if (list[middle] === value) {
      return middle;
    }
    if (list[middle] > value) {
      last2 = middle - 1;
    } else {
      first = middle + 1;
    }
  }
  return ~first;
};
var removeBatch = function removeBatch2(_ref, state, _ref2) {
  var name2 = _ref[0], indexes = _ref[1];
  var changeValue = _ref2.changeValue;
  if (indexes.length === 0) {
    return [];
  }
  var sortedIndexes = [].concat(indexes);
  sortedIndexes.sort();
  for (var i15 = sortedIndexes.length - 1; i15 > 0; i15 -= 1) {
    if (sortedIndexes[i15] === sortedIndexes[i15 - 1]) {
      sortedIndexes.splice(i15, 1);
    }
  }
  var returnValue = [];
  changeValue(state, name2, function(array2) {
    returnValue = indexes.map(function(index3) {
      return array2 && array2[index3];
    });
    if (!array2) {
      return array2;
    }
    var copy = [].concat(array2);
    for (var _i = sortedIndexes.length - 1; _i >= 0; _i -= 1) {
      var index2 = sortedIndexes[_i];
      copy.splice(index2, 1);
    }
    return copy.length > 0 ? copy : void 0;
  });
  var pattern = new RegExp("^" + escapeRegexTokens(name2) + "\\[(\\d+)\\](.*)");
  var newFields = {};
  Object.keys(state.fields).forEach(function(key) {
    var tokens2 = pattern.exec(key);
    if (tokens2) {
      var fieldIndex = Number(tokens2[1]);
      var indexOfFieldIndex = binarySearch(sortedIndexes, fieldIndex);
      if (indexOfFieldIndex >= 0) {
        return;
      }
      if (fieldIndex > sortedIndexes[0]) {
        var decrementedKey = name2 + "[" + (fieldIndex - ~indexOfFieldIndex) + "]" + tokens2[2];
        copyField(state.fields, key, newFields, decrementedKey);
        return;
      }
    }
    newFields[key] = state.fields[key];
  });
  state.fields = newFields;
  return returnValue;
};
var shift = function shift2(_ref, state, tools) {
  var name2 = _ref[0];
  return remove([name2, 0], state, tools);
};
var swap = function swap2(_ref, state, _ref2) {
  var name2 = _ref[0], indexA = _ref[1], indexB = _ref[2];
  var changeValue = _ref2.changeValue;
  if (indexA === indexB) {
    return;
  }
  changeValue(state, name2, function(array2) {
    var copy = [].concat(array2 || []);
    var a13 = copy[indexA];
    copy[indexA] = copy[indexB];
    copy[indexB] = a13;
    return copy;
  });
  var aPrefix = name2 + "[" + indexA + "]";
  var bPrefix = name2 + "[" + indexB + "]";
  var newFields = {};
  Object.keys(state.fields).forEach(function(key) {
    if (key.substring(0, aPrefix.length) === aPrefix) {
      var suffix2 = key.substring(aPrefix.length);
      var newKey = bPrefix + suffix2;
      copyField(state.fields, key, newFields, newKey);
    } else if (key.substring(0, bPrefix.length) === bPrefix) {
      var _suffix = key.substring(bPrefix.length);
      var _newKey = aPrefix + _suffix;
      copyField(state.fields, key, newFields, _newKey);
    } else {
      newFields[key] = state.fields[key];
    }
  });
  state.fields = newFields;
};
var unshift = function unshift2(_ref, state, tools) {
  var name2 = _ref[0], value = _ref[1];
  return insert([name2, 0, value], state, tools);
};
var update = function update2(_ref, state, _ref2) {
  var name2 = _ref[0], index2 = _ref[1], value = _ref[2];
  var changeValue = _ref2.changeValue;
  changeValue(state, name2, function(array2) {
    var copy = [].concat(array2 || []);
    copy.splice(index2, 1, value);
    return copy;
  });
};
var mutators = {
  insert,
  concat,
  move,
  pop,
  push,
  remove,
  removeBatch,
  shift,
  swap,
  unshift,
  update
};
var final_form_arrays_es_default = mutators;

// node_modules/final-form-set-field-data/dist/final-form-set-field-data.es.js
function _extends6() {
  _extends6 = Object.assign || function(target) {
    for (var i15 = 1; i15 < arguments.length; i15++) {
      var source = arguments[i15];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends6.apply(this, arguments);
}
var setFieldData = function setFieldData2(args, state) {
  var name2 = args[0], data = args[1];
  var field = state.fields[name2];
  if (field) {
    field.data = _extends6({}, field.data, data);
  }
};
var final_form_set_field_data_es_default = setFieldData;

// node_modules/final-form/dist/final-form.es.js
var charCodeOfDot = ".".charCodeAt(0);
var reEscapeChar3 = /\\(\\)?/g;
var rePropName3 = RegExp(
  // Match anything that isn't a dot or bracket.
  `[^.[\\]]+|\\[(?:([^"'][^[]*)|(["'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))`,
  "g"
);
var stringToPath3 = function stringToPath4(string2) {
  var result = [];
  if (string2.charCodeAt(0) === charCodeOfDot) {
    result.push("");
  }
  string2.replace(rePropName3, function(match5, expression, quote, subString) {
    var key = match5;
    if (quote) {
      key = subString.replace(reEscapeChar3, "$1");
    } else if (expression) {
      key = expression.trim();
    }
    result.push(key);
  });
  return result;
};
var keysCache = {};
var keysRegex = /[.[\]]+/;
var toPath = function toPath2(key) {
  if (key === null || key === void 0 || !key.length) {
    return [];
  }
  if (typeof key !== "string") {
    throw new Error("toPath() expects a string");
  }
  if (keysCache[key] == null) {
    if (key.endsWith("[]")) {
      keysCache[key] = key.split(keysRegex).filter(Boolean);
    } else {
      keysCache[key] = stringToPath3(key);
    }
  }
  return keysCache[key];
};
var getIn = function getIn2(state, complexKey) {
  var path = toPath(complexKey);
  var current = state;
  for (var i15 = 0; i15 < path.length; i15++) {
    var key = path[i15];
    if (current === void 0 || current === null || typeof current !== "object" || Array.isArray(current) && isNaN(key)) {
      return void 0;
    }
    current = current[key];
  }
  return current;
};
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return typeof key === "symbol" ? key : String(key);
}
function _toPrimitive(input, hint) {
  if (typeof input !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (typeof res !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}
var setInRecursor = function setInRecursor2(current, index2, path, value, destroyArrays) {
  if (index2 >= path.length) {
    return value;
  }
  var key = path[index2];
  if (isNaN(key)) {
    var _extends24;
    if (current === void 0 || current === null) {
      var _ref;
      var _result2 = setInRecursor2(void 0, index2 + 1, path, value, destroyArrays);
      return _result2 === void 0 ? void 0 : (_ref = {}, _ref[key] = _result2, _ref);
    }
    if (Array.isArray(current)) {
      throw new Error("Cannot set a non-numeric property on an array");
    }
    var _result = setInRecursor2(current[key], index2 + 1, path, value, destroyArrays);
    if (_result === void 0) {
      var numKeys = Object.keys(current).length;
      if (current[key] === void 0 && numKeys === 0) {
        return void 0;
      }
      if (current[key] !== void 0 && numKeys <= 1) {
        if (!isNaN(path[index2 - 1]) && !destroyArrays) {
          return {};
        } else {
          return void 0;
        }
      }
      current[key];
      var _final = _objectWithoutPropertiesLoose(current, [key].map(_toPropertyKey));
      return _final;
    }
    return _extends({}, current, (_extends24 = {}, _extends24[key] = _result, _extends24));
  }
  var numericKey = Number(key);
  if (current === void 0 || current === null) {
    var _result3 = setInRecursor2(void 0, index2 + 1, path, value, destroyArrays);
    if (_result3 === void 0) {
      return void 0;
    }
    var _array = [];
    _array[numericKey] = _result3;
    return _array;
  }
  if (!Array.isArray(current)) {
    throw new Error("Cannot set a numeric property on an object");
  }
  var existingValue = current[numericKey];
  var result = setInRecursor2(existingValue, index2 + 1, path, value, destroyArrays);
  var array2 = [].concat(current);
  if (destroyArrays && result === void 0) {
    array2.splice(numericKey, 1);
    if (array2.length === 0) {
      return void 0;
    }
  } else {
    array2[numericKey] = result;
  }
  return array2;
};
var setIn = function setIn2(state, key, value, destroyArrays) {
  if (destroyArrays === void 0) {
    destroyArrays = false;
  }
  if (state === void 0 || state === null) {
    throw new Error("Cannot call setIn() with " + String(state) + " state");
  }
  if (key === void 0 || key === null) {
    throw new Error("Cannot call setIn() with " + String(key) + " key");
  }
  return setInRecursor(state, 0, toPath(key), value, destroyArrays);
};
var FORM_ERROR = "FINAL_FORM/form-error";
var ARRAY_ERROR = "FINAL_FORM/array-error";
function publishFieldState(formState, field) {
  var errors = formState.errors, initialValues = formState.initialValues, lastSubmittedValues = formState.lastSubmittedValues, submitErrors = formState.submitErrors, submitFailed = formState.submitFailed, submitSucceeded = formState.submitSucceeded, submitting = formState.submitting, values3 = formState.values;
  var active = field.active, blur = field.blur, change = field.change, data = field.data, focus2 = field.focus, modified = field.modified, modifiedSinceLastSubmit = field.modifiedSinceLastSubmit, name2 = field.name, touched = field.touched, validating = field.validating, visited = field.visited;
  var value = getIn(values3, name2);
  var error2 = getIn(errors, name2);
  if (error2 && error2[ARRAY_ERROR]) {
    error2 = error2[ARRAY_ERROR];
  }
  var submitError = submitErrors && getIn(submitErrors, name2);
  var initial = initialValues && getIn(initialValues, name2);
  var pristine = field.isEqual(initial, value);
  var dirtySinceLastSubmit = !!(lastSubmittedValues && !field.isEqual(getIn(lastSubmittedValues, name2), value));
  var valid = !error2 && !submitError;
  return {
    active,
    blur,
    change,
    data,
    dirty: !pristine,
    dirtySinceLastSubmit,
    error: error2,
    focus: focus2,
    initial,
    invalid: !valid,
    length: Array.isArray(value) ? value.length : void 0,
    modified,
    modifiedSinceLastSubmit,
    name: name2,
    pristine,
    submitError,
    submitFailed,
    submitSucceeded,
    submitting,
    touched,
    valid,
    value,
    visited,
    validating
  };
}
var fieldSubscriptionItems = ["active", "data", "dirty", "dirtySinceLastSubmit", "error", "initial", "invalid", "length", "modified", "modifiedSinceLastSubmit", "pristine", "submitError", "submitFailed", "submitSucceeded", "submitting", "touched", "valid", "value", "visited", "validating"];
var shallowEqual = function shallowEqual2(a13, b6) {
  if (a13 === b6) {
    return true;
  }
  if (typeof a13 !== "object" || !a13 || typeof b6 !== "object" || !b6) {
    return false;
  }
  var keysA = Object.keys(a13);
  var keysB = Object.keys(b6);
  if (keysA.length !== keysB.length) {
    return false;
  }
  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(b6);
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];
    if (!bHasOwnProperty(key) || a13[key] !== b6[key]) {
      return false;
    }
  }
  return true;
};
function subscriptionFilter(dest, src, previous, subscription, keys6, shallowEqualKeys2) {
  var different = false;
  keys6.forEach(function(key) {
    if (subscription[key]) {
      dest[key] = src[key];
      if (!previous || (~shallowEqualKeys2.indexOf(key) ? !shallowEqual(src[key], previous[key]) : src[key] !== previous[key])) {
        different = true;
      }
    }
  });
  return different;
}
var shallowEqualKeys$1 = ["data"];
var filterFieldState = function filterFieldState2(state, previousState, subscription, force) {
  var result = {
    blur: state.blur,
    change: state.change,
    focus: state.focus,
    name: state.name
  };
  var different = subscriptionFilter(result, state, previousState, subscription, fieldSubscriptionItems, shallowEqualKeys$1) || !previousState;
  return different || force ? result : void 0;
};
var formSubscriptionItems = ["active", "dirty", "dirtyFields", "dirtyFieldsSinceLastSubmit", "dirtySinceLastSubmit", "error", "errors", "hasSubmitErrors", "hasValidationErrors", "initialValues", "invalid", "modified", "modifiedSinceLastSubmit", "pristine", "submitting", "submitError", "submitErrors", "submitFailed", "submitSucceeded", "touched", "valid", "validating", "values", "visited"];
var shallowEqualKeys = ["touched", "visited"];
function filterFormState(state, previousState, subscription, force) {
  var result = {};
  var different = subscriptionFilter(result, state, previousState, subscription, formSubscriptionItems, shallowEqualKeys) || !previousState;
  return different || force ? result : void 0;
}
var memoize3 = function memoize4(fn2) {
  var lastArgs;
  var lastResult;
  return function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (!lastArgs || args.length !== lastArgs.length || args.some(function(arg, index2) {
      return !shallowEqual(lastArgs[index2], arg);
    })) {
      lastArgs = args;
      lastResult = fn2.apply(void 0, args);
    }
    return lastResult;
  };
};
var isPromise = function(obj) {
  return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
};
var version = "4.20.9";
var tripleEquals = function tripleEquals2(a13, b6) {
  return a13 === b6;
};
var hasAnyError = function hasAnyError2(errors) {
  return Object.keys(errors).some(function(key) {
    var value = errors[key];
    if (value && typeof value === "object" && !(value instanceof Error)) {
      return hasAnyError2(value);
    }
    return typeof value !== "undefined";
  });
};
function convertToExternalFormState(_ref) {
  var active = _ref.active, dirtySinceLastSubmit = _ref.dirtySinceLastSubmit, modifiedSinceLastSubmit = _ref.modifiedSinceLastSubmit, error2 = _ref.error, errors = _ref.errors, initialValues = _ref.initialValues, pristine = _ref.pristine, submitting = _ref.submitting, submitFailed = _ref.submitFailed, submitSucceeded = _ref.submitSucceeded, submitError = _ref.submitError, submitErrors = _ref.submitErrors, valid = _ref.valid, validating = _ref.validating, values3 = _ref.values;
  return {
    active,
    dirty: !pristine,
    dirtySinceLastSubmit,
    modifiedSinceLastSubmit,
    error: error2,
    errors,
    hasSubmitErrors: !!(submitError || submitErrors && hasAnyError(submitErrors)),
    hasValidationErrors: !!(error2 || hasAnyError(errors)),
    invalid: !valid,
    initialValues,
    pristine,
    submitting,
    submitFailed,
    submitSucceeded,
    submitError,
    submitErrors,
    valid,
    validating: validating > 0,
    values: values3
  };
}
function notifySubscriber(subscriber, subscription, state, lastState, filter, force) {
  var notification = filter(state, lastState, subscription, force);
  if (notification) {
    subscriber(notification);
    return true;
  }
  return false;
}
function notify(_ref2, state, lastState, filter, force) {
  var entries = _ref2.entries;
  Object.keys(entries).forEach(function(key) {
    var entry = entries[Number(key)];
    if (entry) {
      var subscription = entry.subscription, subscriber = entry.subscriber, notified = entry.notified;
      if (notifySubscriber(subscriber, subscription, state, lastState, filter, force || !notified)) {
        entry.notified = true;
      }
    }
  });
}
function createForm(config2) {
  if (!config2) {
    throw new Error("No config specified");
  }
  var debug = config2.debug, destroyOnUnregister = config2.destroyOnUnregister, keepDirtyOnReinitialize = config2.keepDirtyOnReinitialize, initialValues = config2.initialValues, mutators2 = config2.mutators, onSubmit = config2.onSubmit, validate3 = config2.validate, validateOnBlur = config2.validateOnBlur;
  if (!onSubmit) {
    throw new Error("No onSubmit function specified");
  }
  var state = {
    subscribers: {
      index: 0,
      entries: {}
    },
    fieldSubscribers: {},
    fields: {},
    formState: {
      asyncErrors: {},
      dirtySinceLastSubmit: false,
      modifiedSinceLastSubmit: false,
      errors: {},
      initialValues: initialValues && _extends({}, initialValues),
      invalid: false,
      pristine: true,
      submitting: false,
      submitFailed: false,
      submitSucceeded: false,
      resetWhileSubmitting: false,
      valid: true,
      validating: 0,
      values: initialValues ? _extends({}, initialValues) : {}
    },
    lastFormState: void 0
  };
  var inBatch = 0;
  var validationPaused = false;
  var validationBlocked = false;
  var preventNotificationWhileValidationPaused = false;
  var nextAsyncValidationKey = 0;
  var asyncValidationPromises = {};
  var clearAsyncValidationPromise = function clearAsyncValidationPromise2(key) {
    return function(result) {
      delete asyncValidationPromises[key];
      return result;
    };
  };
  var changeValue = function changeValue2(state2, name2, mutate) {
    var before = getIn(state2.formState.values, name2);
    var after = mutate(before);
    state2.formState.values = setIn(state2.formState.values, name2, after) || {};
  };
  var renameField = function renameField2(state2, from2, to4) {
    if (state2.fields[from2]) {
      var _extends24, _extends32;
      state2.fields = _extends({}, state2.fields, (_extends24 = {}, _extends24[to4] = _extends({}, state2.fields[from2], {
        name: to4,
        // rebind event handlers
        blur: function blur() {
          return api.blur(to4);
        },
        change: function change(value2) {
          return api.change(to4, value2);
        },
        focus: function focus2() {
          return api.focus(to4);
        },
        lastFieldState: void 0
      }), _extends24));
      delete state2.fields[from2];
      state2.fieldSubscribers = _extends({}, state2.fieldSubscribers, (_extends32 = {}, _extends32[to4] = state2.fieldSubscribers[from2], _extends32));
      delete state2.fieldSubscribers[from2];
      var value = getIn(state2.formState.values, from2);
      state2.formState.values = setIn(state2.formState.values, from2, void 0) || {};
      state2.formState.values = setIn(state2.formState.values, to4, value);
      delete state2.lastFormState;
    }
  };
  var getMutatorApi = function getMutatorApi2(key) {
    return function() {
      if (mutators2) {
        var mutatableState = {
          formState: state.formState,
          fields: state.fields,
          fieldSubscribers: state.fieldSubscribers,
          lastFormState: state.lastFormState
        };
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var returnValue = mutators2[key](args, mutatableState, {
          changeValue,
          getIn,
          renameField,
          resetFieldState: api.resetFieldState,
          setIn,
          shallowEqual
        });
        state.formState = mutatableState.formState;
        state.fields = mutatableState.fields;
        state.fieldSubscribers = mutatableState.fieldSubscribers;
        state.lastFormState = mutatableState.lastFormState;
        runValidation(void 0, function() {
          notifyFieldListeners();
          notifyFormListeners();
        });
        return returnValue;
      }
    };
  };
  var mutatorsApi = mutators2 ? Object.keys(mutators2).reduce(function(result, key) {
    result[key] = getMutatorApi(key);
    return result;
  }, {}) : {};
  var runRecordLevelValidation = function runRecordLevelValidation2(setErrors) {
    var promises = [];
    if (validate3) {
      var errorsOrPromise = validate3(_extends({}, state.formState.values));
      if (isPromise(errorsOrPromise)) {
        promises.push(errorsOrPromise.then(function(errors) {
          return setErrors(errors, true);
        }));
      } else {
        setErrors(errorsOrPromise, false);
      }
    }
    return promises;
  };
  var getValidators = function getValidators2(field) {
    return Object.keys(field.validators).reduce(function(result, index2) {
      var validator = field.validators[Number(index2)]();
      if (validator) {
        result.push(validator);
      }
      return result;
    }, []);
  };
  var runFieldLevelValidation = function runFieldLevelValidation2(field, setError) {
    var promises = [];
    var validators = getValidators(field);
    if (validators.length) {
      var error2;
      validators.forEach(function(validator) {
        var errorOrPromise = validator(getIn(state.formState.values, field.name), state.formState.values, validator.length === 0 || validator.length === 3 ? publishFieldState(state.formState, state.fields[field.name]) : void 0);
        if (errorOrPromise && isPromise(errorOrPromise)) {
          field.validating = true;
          var promise = errorOrPromise.then(function(error3) {
            if (state.fields[field.name]) {
              state.fields[field.name].validating = false;
              setError(error3);
            }
          });
          promises.push(promise);
        } else if (!error2) {
          error2 = errorOrPromise;
        }
      });
      setError(error2);
    }
    return promises;
  };
  var runValidation = function runValidation2(fieldChanged, callback) {
    if (validationPaused) {
      validationBlocked = true;
      callback();
      return;
    }
    var fields = state.fields, formState = state.formState;
    var safeFields = _extends({}, fields);
    var fieldKeys = Object.keys(safeFields);
    if (!validate3 && !fieldKeys.some(function(key) {
      return getValidators(safeFields[key]).length;
    })) {
      callback();
      return;
    }
    var limitedFieldLevelValidation = false;
    if (fieldChanged) {
      var changedField = safeFields[fieldChanged];
      if (changedField) {
        var validateFields = changedField.validateFields;
        if (validateFields) {
          limitedFieldLevelValidation = true;
          fieldKeys = validateFields.length ? validateFields.concat(fieldChanged) : [fieldChanged];
        }
      }
    }
    var recordLevelErrors = {};
    var asyncRecordLevelErrors = {};
    var fieldLevelErrors = {};
    var promises = [].concat(runRecordLevelValidation(function(errors, wasAsync) {
      if (wasAsync) {
        asyncRecordLevelErrors = errors || {};
      } else {
        recordLevelErrors = errors || {};
      }
    }), fieldKeys.reduce(function(result, name2) {
      return result.concat(runFieldLevelValidation(fields[name2], function(error2) {
        fieldLevelErrors[name2] = error2;
      }));
    }, []));
    var hasAsyncValidations = promises.length > 0;
    var asyncValidationPromiseKey = ++nextAsyncValidationKey;
    var promise = Promise.all(promises).then(clearAsyncValidationPromise(asyncValidationPromiseKey));
    if (hasAsyncValidations) {
      asyncValidationPromises[asyncValidationPromiseKey] = promise;
    }
    var processErrors = function processErrors2(afterAsync) {
      var merged = _extends({}, limitedFieldLevelValidation ? formState.errors : {}, recordLevelErrors, afterAsync ? asyncRecordLevelErrors : formState.asyncErrors);
      var forEachError = function forEachError2(fn2) {
        fieldKeys.forEach(function(name2) {
          if (fields[name2]) {
            var recordLevelError = getIn(recordLevelErrors, name2);
            var errorFromParent = getIn(merged, name2);
            var hasFieldLevelValidation = getValidators(safeFields[name2]).length;
            var fieldLevelError = fieldLevelErrors[name2];
            fn2(name2, hasFieldLevelValidation && fieldLevelError || validate3 && recordLevelError || (!recordLevelError && !limitedFieldLevelValidation ? errorFromParent : void 0));
          }
        });
      };
      forEachError(function(name2, error2) {
        merged = setIn(merged, name2, error2) || {};
      });
      forEachError(function(name2, error2) {
        if (error2 && error2[ARRAY_ERROR]) {
          var existing = getIn(merged, name2);
          var copy = [].concat(existing);
          copy[ARRAY_ERROR] = error2[ARRAY_ERROR];
          merged = setIn(merged, name2, copy);
        }
      });
      if (!shallowEqual(formState.errors, merged)) {
        formState.errors = merged;
      }
      if (afterAsync) {
        formState.asyncErrors = asyncRecordLevelErrors;
      }
      formState.error = recordLevelErrors[FORM_ERROR];
    };
    if (hasAsyncValidations) {
      state.formState.validating++;
      callback();
    }
    processErrors(false);
    callback();
    if (hasAsyncValidations) {
      var afterPromise = function afterPromise2() {
        state.formState.validating--;
        callback();
      };
      promise.then(function() {
        if (nextAsyncValidationKey > asyncValidationPromiseKey) {
          return;
        }
        processErrors(true);
      }).then(afterPromise, afterPromise);
    }
  };
  var notifyFieldListeners = function notifyFieldListeners2(name2) {
    if (inBatch) {
      return;
    }
    var fields = state.fields, fieldSubscribers = state.fieldSubscribers, formState = state.formState;
    var safeFields = _extends({}, fields);
    var notifyField = function notifyField2(name3) {
      var field = safeFields[name3];
      var fieldState = publishFieldState(formState, field);
      var lastFieldState = field.lastFieldState;
      field.lastFieldState = fieldState;
      var fieldSubscriber = fieldSubscribers[name3];
      if (fieldSubscriber) {
        notify(fieldSubscriber, fieldState, lastFieldState, filterFieldState, lastFieldState === void 0);
      }
    };
    if (name2) {
      notifyField(name2);
    } else {
      Object.keys(safeFields).forEach(notifyField);
    }
  };
  var markAllFieldsTouched = function markAllFieldsTouched2() {
    Object.keys(state.fields).forEach(function(key) {
      state.fields[key].touched = true;
    });
  };
  var hasSyncErrors = function hasSyncErrors2() {
    return !!(state.formState.error || hasAnyError(state.formState.errors));
  };
  var calculateNextFormState = function calculateNextFormState2() {
    var fields = state.fields, formState = state.formState, lastFormState = state.lastFormState;
    var safeFields = _extends({}, fields);
    var safeFieldKeys = Object.keys(safeFields);
    var foundDirty = false;
    var dirtyFields = safeFieldKeys.reduce(function(result, key) {
      var dirty = !safeFields[key].isEqual(getIn(formState.values, key), getIn(formState.initialValues || {}, key));
      if (dirty) {
        foundDirty = true;
        result[key] = true;
      }
      return result;
    }, {});
    var dirtyFieldsSinceLastSubmit = safeFieldKeys.reduce(function(result, key) {
      var nonNullLastSubmittedValues = formState.lastSubmittedValues || {};
      if (!safeFields[key].isEqual(getIn(formState.values, key), getIn(nonNullLastSubmittedValues, key))) {
        result[key] = true;
      }
      return result;
    }, {});
    formState.pristine = !foundDirty;
    formState.dirtySinceLastSubmit = !!(formState.lastSubmittedValues && Object.values(dirtyFieldsSinceLastSubmit).some(function(value) {
      return value;
    }));
    formState.modifiedSinceLastSubmit = !!(formState.lastSubmittedValues && // Object.values would treat values as mixed (facebook/flow#2221)
    Object.keys(safeFields).some(function(value) {
      return safeFields[value].modifiedSinceLastSubmit;
    }));
    formState.valid = !formState.error && !formState.submitError && !hasAnyError(formState.errors) && !(formState.submitErrors && hasAnyError(formState.submitErrors));
    var nextFormState = convertToExternalFormState(formState);
    var _safeFieldKeys$reduce = safeFieldKeys.reduce(function(result, key) {
      result.modified[key] = safeFields[key].modified;
      result.touched[key] = safeFields[key].touched;
      result.visited[key] = safeFields[key].visited;
      return result;
    }, {
      modified: {},
      touched: {},
      visited: {}
    }), modified = _safeFieldKeys$reduce.modified, touched = _safeFieldKeys$reduce.touched, visited = _safeFieldKeys$reduce.visited;
    nextFormState.dirtyFields = lastFormState && shallowEqual(lastFormState.dirtyFields, dirtyFields) ? lastFormState.dirtyFields : dirtyFields;
    nextFormState.dirtyFieldsSinceLastSubmit = lastFormState && shallowEqual(lastFormState.dirtyFieldsSinceLastSubmit, dirtyFieldsSinceLastSubmit) ? lastFormState.dirtyFieldsSinceLastSubmit : dirtyFieldsSinceLastSubmit;
    nextFormState.modified = lastFormState && shallowEqual(lastFormState.modified, modified) ? lastFormState.modified : modified;
    nextFormState.touched = lastFormState && shallowEqual(lastFormState.touched, touched) ? lastFormState.touched : touched;
    nextFormState.visited = lastFormState && shallowEqual(lastFormState.visited, visited) ? lastFormState.visited : visited;
    return lastFormState && shallowEqual(lastFormState, nextFormState) ? lastFormState : nextFormState;
  };
  var callDebug = function callDebug2() {
    return debug && true && debug(calculateNextFormState(), Object.keys(state.fields).reduce(function(result, key) {
      result[key] = state.fields[key];
      return result;
    }, {}));
  };
  var notifying = false;
  var scheduleNotification = false;
  var notifyFormListeners = function notifyFormListeners2() {
    if (notifying) {
      scheduleNotification = true;
    } else {
      notifying = true;
      callDebug();
      if (!inBatch && !(validationPaused && preventNotificationWhileValidationPaused)) {
        var lastFormState = state.lastFormState;
        var nextFormState = calculateNextFormState();
        if (nextFormState !== lastFormState) {
          state.lastFormState = nextFormState;
          notify(state.subscribers, nextFormState, lastFormState, filterFormState);
        }
      }
      notifying = false;
      if (scheduleNotification) {
        scheduleNotification = false;
        notifyFormListeners2();
      }
    }
  };
  var beforeSubmit = function beforeSubmit2() {
    return Object.keys(state.fields).some(function(name2) {
      return state.fields[name2].beforeSubmit && state.fields[name2].beforeSubmit() === false;
    });
  };
  var afterSubmit = function afterSubmit2() {
    return Object.keys(state.fields).forEach(function(name2) {
      return state.fields[name2].afterSubmit && state.fields[name2].afterSubmit();
    });
  };
  var resetModifiedAfterSubmit = function resetModifiedAfterSubmit2() {
    return Object.keys(state.fields).forEach(function(key) {
      return state.fields[key].modifiedSinceLastSubmit = false;
    });
  };
  runValidation(void 0, function() {
    notifyFormListeners();
  });
  var api = {
    batch: function batch2(fn2) {
      inBatch++;
      fn2();
      inBatch--;
      notifyFieldListeners();
      notifyFormListeners();
    },
    blur: function blur(name2) {
      var fields = state.fields, formState = state.formState;
      var previous = fields[name2];
      if (previous) {
        delete formState.active;
        fields[name2] = _extends({}, previous, {
          active: false,
          touched: true
        });
        if (validateOnBlur) {
          runValidation(name2, function() {
            notifyFieldListeners();
            notifyFormListeners();
          });
        } else {
          notifyFieldListeners();
          notifyFormListeners();
        }
      }
    },
    change: function change(name2, value) {
      var fields = state.fields, formState = state.formState;
      if (getIn(formState.values, name2) !== value) {
        changeValue(state, name2, function() {
          return value;
        });
        var previous = fields[name2];
        if (previous) {
          fields[name2] = _extends({}, previous, {
            modified: true,
            modifiedSinceLastSubmit: !!formState.lastSubmittedValues
          });
        }
        if (validateOnBlur) {
          notifyFieldListeners();
          notifyFormListeners();
        } else {
          runValidation(name2, function() {
            notifyFieldListeners();
            notifyFormListeners();
          });
        }
      }
    },
    get destroyOnUnregister() {
      return !!destroyOnUnregister;
    },
    set destroyOnUnregister(value) {
      destroyOnUnregister = value;
    },
    focus: function focus2(name2) {
      var field = state.fields[name2];
      if (field && !field.active) {
        state.formState.active = name2;
        field.active = true;
        field.visited = true;
        notifyFieldListeners();
        notifyFormListeners();
      }
    },
    mutators: mutatorsApi,
    getFieldState: function getFieldState(name2) {
      var field = state.fields[name2];
      return field && field.lastFieldState;
    },
    getRegisteredFields: function getRegisteredFields() {
      return Object.keys(state.fields);
    },
    getState: function getState2() {
      return calculateNextFormState();
    },
    initialize: function initialize(data) {
      var fields = state.fields, formState = state.formState;
      var safeFields = _extends({}, fields);
      var values3 = typeof data === "function" ? data(formState.values) : data;
      if (!keepDirtyOnReinitialize) {
        formState.values = values3;
      }
      var savedDirtyValues = keepDirtyOnReinitialize ? Object.keys(safeFields).reduce(function(result, key) {
        var field = safeFields[key];
        var pristine = field.isEqual(getIn(formState.values, key), getIn(formState.initialValues || {}, key));
        if (!pristine) {
          result[key] = getIn(formState.values, key);
        }
        return result;
      }, {}) : {};
      formState.initialValues = values3;
      formState.values = values3;
      Object.keys(savedDirtyValues).forEach(function(key) {
        formState.values = setIn(formState.values, key, savedDirtyValues[key]) || {};
      });
      runValidation(void 0, function() {
        notifyFieldListeners();
        notifyFormListeners();
      });
    },
    isValidationPaused: function isValidationPaused() {
      return validationPaused;
    },
    pauseValidation: function pauseValidation(preventNotification) {
      if (preventNotification === void 0) {
        preventNotification = true;
      }
      validationPaused = true;
      preventNotificationWhileValidationPaused = preventNotification;
    },
    registerField: function registerField(name2, subscriber, subscription, fieldConfig) {
      if (subscription === void 0) {
        subscription = {};
      }
      if (!state.fieldSubscribers[name2]) {
        state.fieldSubscribers[name2] = {
          index: 0,
          entries: {}
        };
      }
      var index2 = state.fieldSubscribers[name2].index++;
      state.fieldSubscribers[name2].entries[index2] = {
        subscriber: memoize3(subscriber),
        subscription,
        notified: false
      };
      var field = state.fields[name2] || {
        active: false,
        afterSubmit: fieldConfig && fieldConfig.afterSubmit,
        beforeSubmit: fieldConfig && fieldConfig.beforeSubmit,
        data: fieldConfig && fieldConfig.data || {},
        isEqual: fieldConfig && fieldConfig.isEqual || tripleEquals,
        lastFieldState: void 0,
        modified: false,
        modifiedSinceLastSubmit: false,
        name: name2,
        touched: false,
        valid: true,
        validateFields: fieldConfig && fieldConfig.validateFields,
        validators: {},
        validating: false,
        visited: false
      };
      field.blur = field.blur || function() {
        return api.blur(name2);
      };
      field.change = field.change || function(value) {
        return api.change(name2, value);
      };
      field.focus = field.focus || function() {
        return api.focus(name2);
      };
      state.fields[name2] = field;
      var haveValidator = false;
      var silent = fieldConfig && fieldConfig.silent;
      var notify3 = function notify4() {
        if (silent && state.fields[name2]) {
          notifyFieldListeners(name2);
        } else {
          notifyFormListeners();
          notifyFieldListeners();
        }
      };
      if (fieldConfig) {
        haveValidator = !!(fieldConfig.getValidator && fieldConfig.getValidator());
        if (fieldConfig.getValidator) {
          state.fields[name2].validators[index2] = fieldConfig.getValidator;
        }
        var noValueInFormState = getIn(state.formState.values, name2) === void 0;
        if (fieldConfig.initialValue !== void 0 && (noValueInFormState || getIn(state.formState.values, name2) === getIn(state.formState.initialValues, name2))) {
          state.formState.initialValues = setIn(state.formState.initialValues || {}, name2, fieldConfig.initialValue);
          state.formState.values = setIn(state.formState.values, name2, fieldConfig.initialValue);
          runValidation(void 0, notify3);
        }
        if (fieldConfig.defaultValue !== void 0 && fieldConfig.initialValue === void 0 && getIn(state.formState.initialValues, name2) === void 0 && noValueInFormState) {
          state.formState.values = setIn(state.formState.values, name2, fieldConfig.defaultValue);
        }
      }
      if (haveValidator) {
        runValidation(void 0, notify3);
      } else {
        notify3();
      }
      return function() {
        var validatorRemoved = false;
        if (state.fields[name2]) {
          validatorRemoved = !!(state.fields[name2].validators[index2] && state.fields[name2].validators[index2]());
          delete state.fields[name2].validators[index2];
        }
        var hasFieldSubscribers = !!state.fieldSubscribers[name2];
        if (hasFieldSubscribers) {
          delete state.fieldSubscribers[name2].entries[index2];
        }
        var lastOne = hasFieldSubscribers && !Object.keys(state.fieldSubscribers[name2].entries).length;
        if (lastOne) {
          delete state.fieldSubscribers[name2];
          delete state.fields[name2];
          if (validatorRemoved) {
            state.formState.errors = setIn(state.formState.errors, name2, void 0) || {};
          }
          if (destroyOnUnregister) {
            state.formState.values = setIn(state.formState.values, name2, void 0, true) || {};
          }
        }
        if (!silent) {
          if (validatorRemoved) {
            runValidation(void 0, function() {
              notifyFormListeners();
              notifyFieldListeners();
            });
          } else if (lastOne) {
            notifyFormListeners();
          }
        }
      };
    },
    reset: function reset(initialValues2) {
      if (initialValues2 === void 0) {
        initialValues2 = state.formState.initialValues;
      }
      if (state.formState.submitting) {
        state.formState.resetWhileSubmitting = true;
      }
      state.formState.submitFailed = false;
      state.formState.submitSucceeded = false;
      delete state.formState.submitError;
      delete state.formState.submitErrors;
      delete state.formState.lastSubmittedValues;
      api.initialize(initialValues2 || {});
    },
    /**
     * Resets all field flags (e.g. touched, visited, etc.) to their initial state
     */
    resetFieldState: function resetFieldState(name2) {
      state.fields[name2] = _extends({}, state.fields[name2], {
        active: false,
        lastFieldState: void 0,
        modified: false,
        touched: false,
        valid: true,
        validating: false,
        visited: false
      });
      runValidation(void 0, function() {
        notifyFieldListeners();
        notifyFormListeners();
      });
    },
    /**
     * Returns the form to a clean slate; that is:
     * - Clear all values
     * - Resets all fields to their initial state
     */
    restart: function restart(initialValues2) {
      if (initialValues2 === void 0) {
        initialValues2 = state.formState.initialValues;
      }
      api.batch(function() {
        for (var name2 in state.fields) {
          api.resetFieldState(name2);
          state.fields[name2] = _extends({}, state.fields[name2], {
            active: false,
            lastFieldState: void 0,
            modified: false,
            modifiedSinceLastSubmit: false,
            touched: false,
            valid: true,
            validating: false,
            visited: false
          });
        }
        api.reset(initialValues2);
      });
    },
    resumeValidation: function resumeValidation() {
      validationPaused = false;
      preventNotificationWhileValidationPaused = false;
      if (validationBlocked) {
        runValidation(void 0, function() {
          notifyFieldListeners();
          notifyFormListeners();
        });
      }
      validationBlocked = false;
    },
    setConfig: function setConfig(name2, value) {
      switch (name2) {
        case "debug":
          debug = value;
          break;
        case "destroyOnUnregister":
          destroyOnUnregister = value;
          break;
        case "initialValues":
          api.initialize(value);
          break;
        case "keepDirtyOnReinitialize":
          keepDirtyOnReinitialize = value;
          break;
        case "mutators":
          mutators2 = value;
          if (value) {
            Object.keys(mutatorsApi).forEach(function(key) {
              if (!(key in value)) {
                delete mutatorsApi[key];
              }
            });
            Object.keys(value).forEach(function(key) {
              mutatorsApi[key] = getMutatorApi(key);
            });
          } else {
            Object.keys(mutatorsApi).forEach(function(key) {
              delete mutatorsApi[key];
            });
          }
          break;
        case "onSubmit":
          onSubmit = value;
          break;
        case "validate":
          validate3 = value;
          runValidation(void 0, function() {
            notifyFieldListeners();
            notifyFormListeners();
          });
          break;
        case "validateOnBlur":
          validateOnBlur = value;
          break;
        default:
          throw new Error("Unrecognised option " + name2);
      }
    },
    submit: function submit() {
      var formState = state.formState;
      if (formState.submitting) {
        return;
      }
      delete formState.submitErrors;
      delete formState.submitError;
      formState.lastSubmittedValues = _extends({}, formState.values);
      if (hasSyncErrors()) {
        markAllFieldsTouched();
        resetModifiedAfterSubmit();
        state.formState.submitFailed = true;
        notifyFormListeners();
        notifyFieldListeners();
        return;
      }
      var asyncValidationPromisesKeys = Object.keys(asyncValidationPromises);
      if (asyncValidationPromisesKeys.length) {
        Promise.all(asyncValidationPromisesKeys.map(function(key) {
          return asyncValidationPromises[Number(key)];
        })).then(api.submit, console.error);
        return;
      }
      var submitIsBlocked = beforeSubmit();
      if (submitIsBlocked) {
        return;
      }
      var resolvePromise;
      var completeCalled = false;
      var complete = function complete2(errors) {
        formState.submitting = false;
        var resetWhileSubmitting = formState.resetWhileSubmitting;
        if (resetWhileSubmitting) {
          formState.resetWhileSubmitting = false;
        }
        if (errors && hasAnyError(errors)) {
          formState.submitFailed = true;
          formState.submitSucceeded = false;
          formState.submitErrors = errors;
          formState.submitError = errors[FORM_ERROR];
          markAllFieldsTouched();
        } else {
          if (!resetWhileSubmitting) {
            formState.submitFailed = false;
            formState.submitSucceeded = true;
          }
          afterSubmit();
        }
        notifyFormListeners();
        notifyFieldListeners();
        completeCalled = true;
        if (resolvePromise) {
          resolvePromise(errors);
        }
        return errors;
      };
      formState.submitting = true;
      formState.submitFailed = false;
      formState.submitSucceeded = false;
      formState.lastSubmittedValues = _extends({}, formState.values);
      resetModifiedAfterSubmit();
      var result = onSubmit(formState.values, api, complete);
      if (!completeCalled) {
        if (result && isPromise(result)) {
          notifyFormListeners();
          notifyFieldListeners();
          return result.then(complete, function(error2) {
            complete();
            throw error2;
          });
        } else if (onSubmit.length >= 3) {
          notifyFormListeners();
          notifyFieldListeners();
          return new Promise(function(resolve) {
            resolvePromise = resolve;
          });
        } else {
          complete(result);
        }
      }
    },
    subscribe: function subscribe(subscriber, subscription) {
      if (!subscriber) {
        throw new Error("No callback given.");
      }
      if (!subscription) {
        throw new Error("No subscription provided. What values do you want to listen to?");
      }
      var memoized = memoize3(subscriber);
      var subscribers = state.subscribers;
      var index2 = subscribers.index++;
      subscribers.entries[index2] = {
        subscriber: memoized,
        subscription,
        notified: false
      };
      var nextFormState = calculateNextFormState();
      notifySubscriber(memoized, subscription, nextFormState, nextFormState, filterFormState, true);
      return function() {
        delete subscribers.entries[index2];
      };
    }
  };
  return api;
}

// node_modules/react-final-form/dist/react-final-form.es.js
var React11 = __toESM(require_react());
var import_react57 = __toESM(require_react());
var _excluded$33 = ["render", "children", "component"];
function renderComponent(props, lazyProps, name2) {
  var render3 = props.render, children = props.children, component = props.component, rest = _objectWithoutPropertiesLoose(props, _excluded$33);
  if (component) {
    return React11.createElement(component, Object.assign(lazyProps, rest, {
      children,
      render: render3
    }));
  }
  if (render3) {
    return render3(children === void 0 ? Object.assign(lazyProps, rest) : (
      // inject children back in
      Object.assign(lazyProps, rest, {
        children
      })
    ));
  }
  if (typeof children !== "function") {
    throw new Error("Must specify either a render prop, a render function as children, or a component prop to " + name2);
  }
  return children(Object.assign(lazyProps, rest));
}
function useWhenValueChanges(value, callback, isEqual7) {
  if (isEqual7 === void 0) {
    isEqual7 = function isEqual8(a13, b6) {
      return a13 === b6;
    };
  }
  var previous = import_react57.default.useRef(value);
  import_react57.default.useEffect(function() {
    if (!isEqual7(value, previous.current)) {
      callback();
      previous.current = value;
    }
  });
}
function useConstant(init) {
  var ref2 = import_react57.default.useRef();
  if (!ref2.current) {
    ref2.current = init();
  }
  return ref2.current;
}
var shallowEqual3 = function shallowEqual4(a13, b6) {
  if (a13 === b6) {
    return true;
  }
  if (typeof a13 !== "object" || !a13 || typeof b6 !== "object" || !b6) {
    return false;
  }
  var keysA = Object.keys(a13);
  var keysB = Object.keys(b6);
  if (keysA.length !== keysB.length) {
    return false;
  }
  var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(b6);
  for (var idx = 0; idx < keysA.length; idx++) {
    var key = keysA[idx];
    if (!bHasOwnProperty(key) || a13[key] !== b6[key]) {
      return false;
    }
  }
  return true;
};
var isSyntheticEvent = function isSyntheticEvent2(candidate) {
  return !!(candidate && typeof candidate.stopPropagation === "function");
};
var ReactFinalFormContext = React11.createContext();
function useLatest3(value) {
  var ref2 = import_react57.default.useRef(value);
  import_react57.default.useEffect(function() {
    ref2.current = value;
  });
  return ref2;
}
var version2 = "6.5.8";
var addLazyState = function addLazyState2(dest, state, keys6) {
  keys6.forEach(function(key) {
    Object.defineProperty(dest, key, {
      get: function get8() {
        return state[key];
      },
      enumerable: true
    });
  });
};
var addLazyFormState = function addLazyFormState2(dest, state) {
  return addLazyState(dest, state, ["active", "dirty", "dirtyFields", "dirtySinceLastSubmit", "dirtyFieldsSinceLastSubmit", "error", "errors", "hasSubmitErrors", "hasValidationErrors", "initialValues", "invalid", "modified", "modifiedSinceLastSubmit", "pristine", "submitError", "submitErrors", "submitFailed", "submitSucceeded", "submitting", "touched", "valid", "validating", "values", "visited"]);
};
var addLazyFieldMetaState = function addLazyFieldMetaState2(dest, state) {
  return addLazyState(dest, state, ["active", "data", "dirty", "dirtySinceLastSubmit", "error", "initial", "invalid", "length", "modified", "modifiedSinceLastSubmit", "pristine", "submitError", "submitFailed", "submitSucceeded", "submitting", "touched", "valid", "validating", "visited"]);
};
var _excluded$23 = ["debug", "decorators", "destroyOnUnregister", "form", "initialValues", "initialValuesEqual", "keepDirtyOnReinitialize", "mutators", "onSubmit", "subscription", "validate", "validateOnBlur"];
var versions = {
  "final-form": version,
  "react-final-form": version2
};
var all$1 = formSubscriptionItems.reduce(function(result, key) {
  result[key] = true;
  return result;
}, {});
function ReactFinalForm(_ref) {
  var debug = _ref.debug, _ref$decorators = _ref.decorators, decorators = _ref$decorators === void 0 ? [] : _ref$decorators, destroyOnUnregister = _ref.destroyOnUnregister, alternateFormApi = _ref.form, initialValues = _ref.initialValues, initialValuesEqual = _ref.initialValuesEqual, keepDirtyOnReinitialize = _ref.keepDirtyOnReinitialize, mutators2 = _ref.mutators, onSubmit = _ref.onSubmit, _ref$subscription = _ref.subscription, subscription = _ref$subscription === void 0 ? all$1 : _ref$subscription, validate3 = _ref.validate, validateOnBlur = _ref.validateOnBlur, rest = _objectWithoutPropertiesLoose(_ref, _excluded$23);
  var config2 = {
    debug,
    destroyOnUnregister,
    initialValues,
    keepDirtyOnReinitialize,
    mutators: mutators2,
    onSubmit,
    validate: validate3,
    validateOnBlur
  };
  var form = useConstant(function() {
    var f16 = alternateFormApi || createForm(config2);
    f16.pauseValidation();
    return f16;
  });
  var _React$useState = React11.useState(function() {
    var initialState2 = {};
    form.subscribe(function(state2) {
      initialState2 = state2;
    }, subscription)();
    return initialState2;
  }), state = _React$useState[0], setState = _React$useState[1];
  var stateRef = useLatest3(state);
  React11.useEffect(function() {
    form.isValidationPaused() && form.resumeValidation();
    var unsubscriptions = [form.subscribe(function(s20) {
      if (!shallowEqual3(s20, stateRef.current)) {
        setState(s20);
      }
    }, subscription)].concat(decorators ? decorators.map(function(decorator) {
      return (
        // this noop ternary is to appease the flow gods
        // istanbul ignore next
        decorator(form)
      );
    }) : []);
    return function() {
      form.pauseValidation();
      unsubscriptions.reverse().forEach(function(unsubscribe) {
        return unsubscribe();
      });
    };
  }, decorators);
  if (true) {
    useWhenValueChanges(decorators, function() {
      console.error("Form decorators should not change from one render to the next as new values will be ignored");
    }, shallowEqual3);
  }
  useWhenValueChanges(debug, function() {
    form.setConfig("debug", debug);
  });
  useWhenValueChanges(destroyOnUnregister, function() {
    form.destroyOnUnregister = !!destroyOnUnregister;
  });
  useWhenValueChanges(keepDirtyOnReinitialize, function() {
    form.setConfig("keepDirtyOnReinitialize", keepDirtyOnReinitialize);
  });
  useWhenValueChanges(initialValues, function() {
    form.setConfig("initialValues", initialValues);
  }, initialValuesEqual || shallowEqual3);
  useWhenValueChanges(mutators2, function() {
    form.setConfig("mutators", mutators2);
  });
  useWhenValueChanges(onSubmit, function() {
    form.setConfig("onSubmit", onSubmit);
  });
  useWhenValueChanges(validate3, function() {
    form.setConfig("validate", validate3);
  });
  useWhenValueChanges(validateOnBlur, function() {
    form.setConfig("validateOnBlur", validateOnBlur);
  });
  var handleSubmit = function handleSubmit2(event) {
    if (event) {
      if (typeof event.preventDefault === "function") {
        event.preventDefault();
      }
      if (typeof event.stopPropagation === "function") {
        event.stopPropagation();
      }
    }
    return form.submit();
  };
  var renderProps = {
    form: _extends({}, form, {
      reset: function reset(eventOrValues) {
        if (isSyntheticEvent(eventOrValues)) {
          form.reset();
        } else {
          form.reset(eventOrValues);
        }
      }
    }),
    handleSubmit
  };
  addLazyFormState(renderProps, state);
  return React11.createElement(ReactFinalFormContext.Provider, {
    value: form
  }, renderComponent(_extends({}, rest, {
    __versions: versions
  }), renderProps, "ReactFinalForm"));
}
function useForm(componentName) {
  var form = React11.useContext(ReactFinalFormContext);
  if (!form) {
    throw new Error((componentName || "useForm") + " must be used inside of a <Form> component");
  }
  return form;
}
var isReactNative = typeof window !== "undefined" && window.navigator && window.navigator.product && window.navigator.product === "ReactNative";
var getSelectedValues = function getSelectedValues2(options) {
  var result = [];
  if (options) {
    for (var index2 = 0; index2 < options.length; index2++) {
      var option = options[index2];
      if (option.selected) {
        result.push(option.value);
      }
    }
  }
  return result;
};
var getValue5 = function getValue6(event, currentValue, valueProp, isReactNative2) {
  if (!isReactNative2 && event.nativeEvent && event.nativeEvent.text !== void 0) {
    return event.nativeEvent.text;
  }
  if (isReactNative2 && event.nativeEvent) {
    return event.nativeEvent.text;
  }
  var detypedEvent = event;
  var _detypedEvent$target = detypedEvent.target, type = _detypedEvent$target.type, value = _detypedEvent$target.value, checked = _detypedEvent$target.checked;
  switch (type) {
    case "checkbox":
      if (valueProp !== void 0) {
        if (checked) {
          return Array.isArray(currentValue) ? currentValue.concat(valueProp) : [valueProp];
        } else {
          if (!Array.isArray(currentValue)) {
            return currentValue;
          }
          var index2 = currentValue.indexOf(valueProp);
          if (index2 < 0) {
            return currentValue;
          } else {
            return currentValue.slice(0, index2).concat(currentValue.slice(index2 + 1));
          }
        }
      } else {
        return !!checked;
      }
    case "select-multiple":
      return getSelectedValues(event.target.options);
    default:
      return value;
  }
};
function useConstantCallback(callback) {
  var ref2 = React11.useRef(callback);
  React11.useEffect(function() {
    ref2.current = callback;
  });
  return React11.useCallback(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return ref2.current.apply(null, args);
  }, []);
}
var all = fieldSubscriptionItems.reduce(function(result, key) {
  result[key] = true;
  return result;
}, {});
var defaultFormat = function defaultFormat2(value, name2) {
  return value === void 0 ? "" : value;
};
var defaultParse = function defaultParse2(value, name2) {
  return value === "" ? void 0 : value;
};
var defaultIsEqual = function defaultIsEqual2(a13, b6) {
  return a13 === b6;
};
function useField(name2, config2) {
  if (config2 === void 0) {
    config2 = {};
  }
  var _config = config2, afterSubmit = _config.afterSubmit, allowNull = _config.allowNull, component = _config.component, data = _config.data, defaultValue = _config.defaultValue, _config$format = _config.format, format3 = _config$format === void 0 ? defaultFormat : _config$format, formatOnBlur = _config.formatOnBlur, initialValue = _config.initialValue, multiple = _config.multiple, _config$parse = _config.parse, parse6 = _config$parse === void 0 ? defaultParse : _config$parse, _config$subscription = _config.subscription, subscription = _config$subscription === void 0 ? all : _config$subscription, type = _config.type, validateFields = _config.validateFields, _value = _config.value;
  var form = useForm("useField");
  var configRef = useLatest3(config2);
  var register = function register2(callback, silent) {
    return (
      // avoid using `state` const in any closures created inside `register`
      // because they would refer `state` from current execution context
      // whereas actual `state` would defined in the subsequent `useField` hook
      // execution
      // (that would be caused by `setState` call performed in `register` callback)
      form.registerField(name2, callback, subscription, {
        afterSubmit,
        beforeSubmit: function beforeSubmit() {
          var _configRef$current = configRef.current, beforeSubmit2 = _configRef$current.beforeSubmit, formatOnBlur2 = _configRef$current.formatOnBlur, _configRef$current$fo = _configRef$current.format, format4 = _configRef$current$fo === void 0 ? defaultFormat : _configRef$current$fo;
          if (formatOnBlur2) {
            var _ref = form.getFieldState(name2), value = _ref.value;
            var formatted = format4(value, name2);
            if (formatted !== value) {
              form.change(name2, formatted);
            }
          }
          return beforeSubmit2 && beforeSubmit2();
        },
        data,
        defaultValue,
        getValidator: function getValidator() {
          return configRef.current.validate;
        },
        initialValue,
        isEqual: function isEqual7(a13, b6) {
          return (configRef.current.isEqual || defaultIsEqual)(a13, b6);
        },
        silent,
        validateFields
      })
    );
  };
  var firstRender = React11.useRef(true);
  var _React$useState = React11.useState(function() {
    var initialState2 = {};
    var destroyOnUnregister = form.destroyOnUnregister;
    form.destroyOnUnregister = false;
    register(function(state2) {
      initialState2 = state2;
    }, true)();
    form.destroyOnUnregister = destroyOnUnregister;
    return initialState2;
  }), state = _React$useState[0], setState = _React$useState[1];
  React11.useEffect(
    function() {
      return register(function(state2) {
        if (firstRender.current) {
          firstRender.current = false;
        } else {
          setState(state2);
        }
      }, false);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      name2,
      data,
      defaultValue,
      // If we want to allow inline fat-arrow field-level validation functions, we
      // cannot reregister field every time validate function !==.
      // validate,
      initialValue
      // The validateFields array is often passed as validateFields={[]}, creating
      // a !== new array every time. If it needs to be changed, a rerender/reregister
      // can be forced by changing the key prop
      // validateFields
    ]
  );
  var meta = {};
  addLazyFieldMetaState(meta, state);
  var input = {
    name: name2,
    get value() {
      var value = state.value;
      if (formatOnBlur) {
        if (component === "input") {
          value = defaultFormat(value);
        }
      } else {
        value = format3(value, name2);
      }
      if (value === null && !allowNull) {
        value = "";
      }
      if (type === "checkbox" || type === "radio") {
        return _value;
      } else if (component === "select" && multiple) {
        return value || [];
      }
      return value;
    },
    get checked() {
      var value = state.value;
      if (type === "checkbox") {
        value = format3(value, name2);
        if (_value === void 0) {
          return !!value;
        } else {
          return !!(Array.isArray(value) && ~value.indexOf(_value));
        }
      } else if (type === "radio") {
        return format3(value, name2) === _value;
      }
      return void 0;
    },
    onBlur: useConstantCallback(function(event) {
      state.blur();
      if (formatOnBlur) {
        var fieldState = form.getFieldState(state.name);
        state.change(format3(fieldState.value, state.name));
      }
    }),
    onChange: useConstantCallback(function(event) {
      if (event && event.target) {
        var targetType = event.target.type;
        var unknown3 = ~["checkbox", "radio", "select-multiple"].indexOf(targetType) && !type && component !== "select";
        var _value2 = targetType === "select-multiple" ? state.value : _value;
        if (unknown3) {
          console.error('You must pass `type="' + (targetType === "select-multiple" ? "select" : targetType) + '"` prop to your Field(' + name2 + ") component.\n" + ("Without it we don't know how to unpack your `value` prop - " + (Array.isArray(_value2) ? "[" + _value2 + "]" : '"' + _value2 + '"') + "."));
        }
      }
      var value = event && event.target ? getValue5(event, state.value, _value, isReactNative) : event;
      state.change(parse6(value, name2));
    }),
    onFocus: useConstantCallback(function(event) {
      return state.focus();
    })
  };
  if (multiple) {
    input.multiple = multiple;
  }
  if (type !== void 0) {
    input.type = type;
  }
  var renderProps = {
    input,
    meta
  };
  return renderProps;
}
var _excluded5 = ["afterSubmit", "allowNull", "beforeSubmit", "children", "component", "data", "defaultValue", "format", "formatOnBlur", "initialValue", "isEqual", "multiple", "name", "parse", "subscription", "type", "validate", "validateFields", "value"];
var Field = React11.forwardRef(function Field2(_ref, ref2) {
  var afterSubmit = _ref.afterSubmit, allowNull = _ref.allowNull, beforeSubmit = _ref.beforeSubmit, children = _ref.children, component = _ref.component, data = _ref.data, defaultValue = _ref.defaultValue, format3 = _ref.format, formatOnBlur = _ref.formatOnBlur, initialValue = _ref.initialValue, isEqual7 = _ref.isEqual, multiple = _ref.multiple, name2 = _ref.name, parse6 = _ref.parse, subscription = _ref.subscription, type = _ref.type, validate3 = _ref.validate, validateFields = _ref.validateFields, value = _ref.value, rest = _objectWithoutPropertiesLoose(_ref, _excluded5);
  var field = useField(name2, {
    afterSubmit,
    allowNull,
    beforeSubmit,
    children,
    component,
    data,
    defaultValue,
    format: format3,
    formatOnBlur,
    initialValue,
    isEqual: isEqual7,
    multiple,
    parse: parse6,
    subscription,
    type,
    validate: validate3,
    validateFields,
    value
  });
  if (typeof children === "function") {
    return children(_extends({}, field, rest));
  }
  if (typeof component === "string") {
    return React11.createElement(component, _extends({}, field.input, {
      children,
      ref: ref2
    }, rest));
  }
  if (!name2) {
    throw new Error("prop name cannot be undefined in <Field> component");
  }
  return renderComponent(_extends({
    children,
    component,
    ref: ref2
  }, rest), field, "Field(" + name2 + ")");
});

// node_modules/@tinacms/toolkit/dist/index.es.js
var import_prop_types20 = __toESM(require_prop_types2());

// node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js
var import_react66 = __toESM(require_react());

// node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o16, p12) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf3(o17, p13) {
    o17.__proto__ = p13;
    return o17;
  };
  return _setPrototypeOf(o16, p12);
}

// node_modules/@babel/runtime/helpers/esm/inheritsLoose.js
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}

// node_modules/@babel/runtime/helpers/esm/typeof.js
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}

// node_modules/@babel/runtime/helpers/esm/toPrimitive.js
function _toPrimitive2(input, hint) {
  if (_typeof(input) !== "object" || input === null)
    return input;
  var prim = input[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input);
}

// node_modules/@babel/runtime/helpers/esm/toPropertyKey.js
function _toPropertyKey2(arg) {
  var key = _toPrimitive2(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}

// node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty6(obj, key, value) {
  key = _toPropertyKey2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}

// node_modules/@babel/runtime/helpers/esm/objectSpread2.js
function ownKeys4(object2, enumerableOnly) {
  var keys6 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys6.push.apply(keys6, symbols);
  }
  return keys6;
}
function _objectSpread22(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = null != arguments[i15] ? arguments[i15] : {};
    i15 % 2 ? ownKeys4(Object(source), true).forEach(function(key) {
      _defineProperty6(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}

// node_modules/redux/es/redux.js
var $$observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var randomString = function randomString2() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
function isPlainObject4(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  var proto2 = obj;
  while (Object.getPrototypeOf(proto2) !== null) {
    proto2 = Object.getPrototypeOf(proto2);
  }
  return Object.getPrototypeOf(obj) === proto2;
}
function miniKindOf(val) {
  if (val === void 0)
    return "undefined";
  if (val === null)
    return "null";
  var type = typeof val;
  switch (type) {
    case "boolean":
    case "string":
    case "number":
    case "symbol":
    case "function": {
      return type;
    }
  }
  if (Array.isArray(val))
    return "array";
  if (isDate(val))
    return "date";
  if (isError(val))
    return "error";
  var constructorName = ctorName(val);
  switch (constructorName) {
    case "Symbol":
    case "Promise":
    case "WeakMap":
    case "WeakSet":
    case "Map":
    case "Set":
      return constructorName;
  }
  return type.slice(8, -1).toLowerCase().replace(/\s/g, "");
}
function ctorName(val) {
  return typeof val.constructor === "function" ? val.constructor.name : null;
}
function isError(val) {
  return val instanceof Error || typeof val.message === "string" && val.constructor && typeof val.constructor.stackTraceLimit === "number";
}
function isDate(val) {
  if (val instanceof Date)
    return true;
  return typeof val.toDateString === "function" && typeof val.getDate === "function" && typeof val.setDate === "function";
}
function kindOf(val) {
  var typeOfVal = typeof val;
  if (true) {
    typeOfVal = miniKindOf(val);
  }
  return typeOfVal;
}
function createStore5(reducer3, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(false ? formatProdErrorMessage(0) : "It looks like you are passing several store enhancers to createStore(). This is not supported. Instead, compose them together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.");
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(false ? formatProdErrorMessage(1) : "Expected the enhancer to be a function. Instead, received: '" + kindOf(enhancer) + "'");
    }
    return enhancer(createStore5)(reducer3, preloadedState);
  }
  if (typeof reducer3 !== "function") {
    throw new Error(false ? formatProdErrorMessage(2) : "Expected the root reducer to be a function. Instead, received: '" + kindOf(reducer3) + "'");
  }
  var currentReducer = reducer3;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState2() {
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(3) : "You may not call store.getState() while the reducer is executing. The reducer has already received the state as an argument. Pass it down from the top reducer instead of reading it from the store.");
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(false ? formatProdErrorMessage(4) : "Expected the listener to be a function. Instead, received: '" + kindOf(listener) + "'");
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(5) : "You may not call store.subscribe() while the reducer is executing. If you would like to be notified after the store has been updated, subscribe from a component and invoke store.getState() in the callback to access the latest state. See https://redux.js.org/api/store#subscribelistener for more details.");
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(false ? formatProdErrorMessage(6) : "You may not unsubscribe from a store listener while the reducer is executing. See https://redux.js.org/api/store#subscribelistener for more details.");
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index2 = nextListeners.indexOf(listener);
      nextListeners.splice(index2, 1);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject4(action)) {
      throw new Error(false ? formatProdErrorMessage(7) : "Actions must be plain objects. Instead, the actual type was: '" + kindOf(action) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
    }
    if (typeof action.type === "undefined") {
      throw new Error(false ? formatProdErrorMessage(8) : 'Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
    }
    if (isDispatching) {
      throw new Error(false ? formatProdErrorMessage(9) : "Reducers may not dispatch actions.");
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    var listeners = currentListeners = nextListeners;
    for (var i15 = 0; i15 < listeners.length; i15++) {
      var listener = listeners[i15];
      listener();
    }
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(false ? formatProdErrorMessage(10) : "Expected the nextReducer to be a function. Instead, received: '" + kindOf(nextReducer));
    }
    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  function observable() {
    var _ref;
    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe2(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(false ? formatProdErrorMessage(11) : "Expected the observer to be an object. Instead, received: '" + kindOf(observer) + "'");
        }
        function observeState() {
          if (observer.next) {
            observer.next(getState2());
          }
        }
        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      }
    }, _ref[$$observable] = function() {
      return this;
    }, _ref;
  }
  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch,
    subscribe,
    getState: getState2,
    replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
function bindActionCreator(actionCreator, dispatch) {
  return function() {
    return dispatch(actionCreator.apply(this, arguments));
  };
}
function bindActionCreators(actionCreators, dispatch) {
  if (typeof actionCreators === "function") {
    return bindActionCreator(actionCreators, dispatch);
  }
  if (typeof actionCreators !== "object" || actionCreators === null) {
    throw new Error(false ? formatProdErrorMessage(16) : "bindActionCreators expected an object or a function, but instead received: '" + kindOf(actionCreators) + `'. Did you write "import ActionCreators from" instead of "import * as ActionCreators from"?`);
  }
  var boundActionCreators = {};
  for (var key in actionCreators) {
    var actionCreator = actionCreators[key];
    if (typeof actionCreator === "function") {
      boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
    }
  }
  return boundActionCreators;
}
function compose() {
  for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
    funcs[_key] = arguments[_key];
  }
  if (funcs.length === 0) {
    return function(arg) {
      return arg;
    };
  }
  if (funcs.length === 1) {
    return funcs[0];
  }
  return funcs.reduce(function(a13, b6) {
    return function() {
      return a13(b6.apply(void 0, arguments));
    };
  });
}
function applyMiddleware() {
  for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
    middlewares[_key] = arguments[_key];
  }
  return function(createStore7) {
    return function() {
      var store = createStore7.apply(void 0, arguments);
      var _dispatch = function dispatch() {
        throw new Error(false ? formatProdErrorMessage(15) : "Dispatching while constructing your middleware is not allowed. Other middleware would not be applied to this dispatch.");
      };
      var middlewareAPI = {
        getState: store.getState,
        dispatch: function dispatch() {
          return _dispatch.apply(void 0, arguments);
        }
      };
      var chain = middlewares.map(function(middleware) {
        return middleware(middlewareAPI);
      });
      _dispatch = compose.apply(void 0, chain)(store.dispatch);
      return _objectSpread22(_objectSpread22({}, store), {}, {
        dispatch: _dispatch
      });
    };
  };
}

// node_modules/react-redux/es/components/Provider.js
var import_react60 = __toESM(require_react());
var import_prop_types2 = __toESM(require_prop_types());

// node_modules/react-redux/es/components/Context.js
var import_react58 = __toESM(require_react());
var ReactReduxContext = import_react58.default.createContext(null);
if (true) {
  ReactReduxContext.displayName = "ReactRedux";
}

// node_modules/react-redux/es/utils/batch.js
function defaultNoopBatch(callback) {
  callback();
}
var batch = defaultNoopBatch;
var setBatch = function setBatch2(newBatch) {
  return batch = newBatch;
};
var getBatch = function getBatch2() {
  return batch;
};

// node_modules/react-redux/es/utils/Subscription.js
function createListenerCollection() {
  var batch2 = getBatch();
  var first = null;
  var last2 = null;
  return {
    clear: function clear() {
      first = null;
      last2 = null;
    },
    notify: function notify3() {
      batch2(function() {
        var listener = first;
        while (listener) {
          listener.callback();
          listener = listener.next;
        }
      });
    },
    get: function get8() {
      var listeners = [];
      var listener = first;
      while (listener) {
        listeners.push(listener);
        listener = listener.next;
      }
      return listeners;
    },
    subscribe: function subscribe(callback) {
      var isSubscribed = true;
      var listener = last2 = {
        callback,
        next: null,
        prev: last2
      };
      if (listener.prev) {
        listener.prev.next = listener;
      } else {
        first = listener;
      }
      return function unsubscribe() {
        if (!isSubscribed || first === null)
          return;
        isSubscribed = false;
        if (listener.next) {
          listener.next.prev = listener.prev;
        } else {
          last2 = listener.prev;
        }
        if (listener.prev) {
          listener.prev.next = listener.next;
        } else {
          first = listener.next;
        }
      };
    }
  };
}
var nullListeners = {
  notify: function notify2() {
  },
  get: function get2() {
    return [];
  }
};
function createSubscription(store, parentSub) {
  var unsubscribe;
  var listeners = nullListeners;
  function addNestedSub(listener) {
    trySubscribe();
    return listeners.subscribe(listener);
  }
  function notifyNestedSubs() {
    listeners.notify();
  }
  function handleChangeWrapper() {
    if (subscription.onStateChange) {
      subscription.onStateChange();
    }
  }
  function isSubscribed() {
    return Boolean(unsubscribe);
  }
  function trySubscribe() {
    if (!unsubscribe) {
      unsubscribe = parentSub ? parentSub.addNestedSub(handleChangeWrapper) : store.subscribe(handleChangeWrapper);
      listeners = createListenerCollection();
    }
  }
  function tryUnsubscribe() {
    if (unsubscribe) {
      unsubscribe();
      unsubscribe = void 0;
      listeners.clear();
      listeners = nullListeners;
    }
  }
  var subscription = {
    addNestedSub,
    notifyNestedSubs,
    handleChangeWrapper,
    isSubscribed,
    trySubscribe,
    tryUnsubscribe,
    getListeners: function getListeners() {
      return listeners;
    }
  };
  return subscription;
}

// node_modules/react-redux/es/utils/useIsomorphicLayoutEffect.js
var import_react59 = __toESM(require_react());
var useIsomorphicLayoutEffect4 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? import_react59.useLayoutEffect : import_react59.useEffect;

// node_modules/react-redux/es/components/Provider.js
function Provider2(_ref) {
  var store = _ref.store, context = _ref.context, children = _ref.children;
  var contextValue = (0, import_react60.useMemo)(function() {
    var subscription = createSubscription(store);
    return {
      store,
      subscription
    };
  }, [store]);
  var previousState = (0, import_react60.useMemo)(function() {
    return store.getState();
  }, [store]);
  useIsomorphicLayoutEffect4(function() {
    var subscription = contextValue.subscription;
    subscription.onStateChange = subscription.notifyNestedSubs;
    subscription.trySubscribe();
    if (previousState !== store.getState()) {
      subscription.notifyNestedSubs();
    }
    return function() {
      subscription.tryUnsubscribe();
      subscription.onStateChange = null;
    };
  }, [contextValue, previousState]);
  var Context = context || ReactReduxContext;
  return import_react60.default.createElement(Context.Provider, {
    value: contextValue
  }, children);
}
if (true) {
  Provider2.propTypes = {
    store: import_prop_types2.default.shape({
      subscribe: import_prop_types2.default.func.isRequired,
      dispatch: import_prop_types2.default.func.isRequired,
      getState: import_prop_types2.default.func.isRequired
    }),
    context: import_prop_types2.default.object,
    children: import_prop_types2.default.any
  };
}
var Provider_default = Provider2;

// node_modules/react-redux/es/components/connectAdvanced.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
var import_react61 = __toESM(require_react());
var import_react_is2 = __toESM(require_react_is());
var _excluded6 = ["getDisplayName", "methodName", "renderCountProp", "shouldHandleStateChanges", "storeKey", "withRef", "forwardRef", "context"];
var _excluded23 = ["reactReduxForwardedRef"];
var EMPTY_ARRAY = [];
var NO_SUBSCRIPTION_ARRAY = [null, null];
var stringifyComponent = function stringifyComponent2(Comp) {
  try {
    return JSON.stringify(Comp);
  } catch (err) {
    return String(Comp);
  }
};
function storeStateUpdatesReducer(state, action) {
  var updateCount = state[1];
  return [action.payload, updateCount + 1];
}
function useIsomorphicLayoutEffectWithArgs(effectFunc, effectArgs, dependencies) {
  useIsomorphicLayoutEffect4(function() {
    return effectFunc.apply(void 0, effectArgs);
  }, dependencies);
}
function captureWrapperProps(lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs) {
  lastWrapperProps.current = wrapperProps;
  lastChildProps.current = actualChildProps;
  renderIsScheduled.current = false;
  if (childPropsFromStoreUpdate.current) {
    childPropsFromStoreUpdate.current = null;
    notifyNestedSubs();
  }
}
function subscribeUpdates(shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch) {
  if (!shouldHandleStateChanges)
    return;
  var didUnsubscribe = false;
  var lastThrownError = null;
  var checkForUpdates = function checkForUpdates2() {
    if (didUnsubscribe) {
      return;
    }
    var latestStoreState = store.getState();
    var newChildProps, error2;
    try {
      newChildProps = childPropsSelector(latestStoreState, lastWrapperProps.current);
    } catch (e9) {
      error2 = e9;
      lastThrownError = e9;
    }
    if (!error2) {
      lastThrownError = null;
    }
    if (newChildProps === lastChildProps.current) {
      if (!renderIsScheduled.current) {
        notifyNestedSubs();
      }
    } else {
      lastChildProps.current = newChildProps;
      childPropsFromStoreUpdate.current = newChildProps;
      renderIsScheduled.current = true;
      forceComponentUpdateDispatch({
        type: "STORE_UPDATED",
        payload: {
          error: error2
        }
      });
    }
  };
  subscription.onStateChange = checkForUpdates;
  subscription.trySubscribe();
  checkForUpdates();
  var unsubscribeWrapper = function unsubscribeWrapper2() {
    didUnsubscribe = true;
    subscription.tryUnsubscribe();
    subscription.onStateChange = null;
    if (lastThrownError) {
      throw lastThrownError;
    }
  };
  return unsubscribeWrapper;
}
var initStateUpdates = function initStateUpdates2() {
  return [null, 0];
};
function connectAdvanced(selectorFactory, _ref) {
  if (_ref === void 0) {
    _ref = {};
  }
  var _ref2 = _ref, _ref2$getDisplayName = _ref2.getDisplayName, getDisplayName = _ref2$getDisplayName === void 0 ? function(name2) {
    return "ConnectAdvanced(" + name2 + ")";
  } : _ref2$getDisplayName, _ref2$methodName = _ref2.methodName, methodName = _ref2$methodName === void 0 ? "connectAdvanced" : _ref2$methodName, _ref2$renderCountProp = _ref2.renderCountProp, renderCountProp = _ref2$renderCountProp === void 0 ? void 0 : _ref2$renderCountProp, _ref2$shouldHandleSta = _ref2.shouldHandleStateChanges, shouldHandleStateChanges = _ref2$shouldHandleSta === void 0 ? true : _ref2$shouldHandleSta, _ref2$storeKey = _ref2.storeKey, storeKey = _ref2$storeKey === void 0 ? "store" : _ref2$storeKey, _ref2$withRef = _ref2.withRef, withRef = _ref2$withRef === void 0 ? false : _ref2$withRef, _ref2$forwardRef = _ref2.forwardRef, forwardRef11 = _ref2$forwardRef === void 0 ? false : _ref2$forwardRef, _ref2$context = _ref2.context, context = _ref2$context === void 0 ? ReactReduxContext : _ref2$context, connectOptions = _objectWithoutPropertiesLoose(_ref2, _excluded6);
  if (true) {
    if (renderCountProp !== void 0) {
      throw new Error("renderCountProp is removed. render counting is built into the latest React Dev Tools profiling extension");
    }
    if (withRef) {
      throw new Error("withRef is removed. To access the wrapped instance, use a ref on the connected component");
    }
    var customStoreWarningMessage = "To use a custom Redux store for specific components, create a custom React context with React.createContext(), and pass the context object to React Redux's Provider and specific components like: <Provider context={MyContext}><ConnectedComponent context={MyContext} /></Provider>. You may also pass a {context : MyContext} option to connect";
    if (storeKey !== "store") {
      throw new Error("storeKey has been removed and does not do anything. " + customStoreWarningMessage);
    }
  }
  var Context = context;
  return function wrapWithConnect(WrappedComponent) {
    if (!(0, import_react_is2.isValidElementType)(WrappedComponent)) {
      throw new Error("You must pass a component to the function returned by " + (methodName + ". Instead received " + stringifyComponent(WrappedComponent)));
    }
    var wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
    var displayName = getDisplayName(wrappedComponentName);
    var selectorFactoryOptions = _extends({}, connectOptions, {
      getDisplayName,
      methodName,
      renderCountProp,
      shouldHandleStateChanges,
      storeKey,
      displayName,
      wrappedComponentName,
      WrappedComponent
    });
    var pure = connectOptions.pure;
    function createChildSelector(store) {
      return selectorFactory(store.dispatch, selectorFactoryOptions);
    }
    var usePureOnlyMemo = pure ? import_react61.useMemo : function(callback) {
      return callback();
    };
    function ConnectFunction(props) {
      var _useMemo = (0, import_react61.useMemo)(function() {
        var reactReduxForwardedRef2 = props.reactReduxForwardedRef, wrapperProps2 = _objectWithoutPropertiesLoose(props, _excluded23);
        return [props.context, reactReduxForwardedRef2, wrapperProps2];
      }, [props]), propsContext = _useMemo[0], reactReduxForwardedRef = _useMemo[1], wrapperProps = _useMemo[2];
      var ContextToUse = (0, import_react61.useMemo)(function() {
        return propsContext && propsContext.Consumer && (0, import_react_is2.isContextConsumer)(import_react61.default.createElement(propsContext.Consumer, null)) ? propsContext : Context;
      }, [propsContext, Context]);
      var contextValue = (0, import_react61.useContext)(ContextToUse);
      var didStoreComeFromProps = Boolean(props.store) && Boolean(props.store.getState) && Boolean(props.store.dispatch);
      var didStoreComeFromContext = Boolean(contextValue) && Boolean(contextValue.store);
      if (!didStoreComeFromProps && !didStoreComeFromContext) {
        throw new Error('Could not find "store" in the context of ' + ('"' + displayName + '". Either wrap the root component in a <Provider>, ') + "or pass a custom React context provider to <Provider> and the corresponding " + ("React context consumer to " + displayName + " in connect options."));
      }
      var store = didStoreComeFromProps ? props.store : contextValue.store;
      var childPropsSelector = (0, import_react61.useMemo)(function() {
        return createChildSelector(store);
      }, [store]);
      var _useMemo2 = (0, import_react61.useMemo)(function() {
        if (!shouldHandleStateChanges)
          return NO_SUBSCRIPTION_ARRAY;
        var subscription2 = createSubscription(store, didStoreComeFromProps ? null : contextValue.subscription);
        var notifyNestedSubs2 = subscription2.notifyNestedSubs.bind(subscription2);
        return [subscription2, notifyNestedSubs2];
      }, [store, didStoreComeFromProps, contextValue]), subscription = _useMemo2[0], notifyNestedSubs = _useMemo2[1];
      var overriddenContextValue = (0, import_react61.useMemo)(function() {
        if (didStoreComeFromProps) {
          return contextValue;
        }
        return _extends({}, contextValue, {
          subscription
        });
      }, [didStoreComeFromProps, contextValue, subscription]);
      var _useReducer = (0, import_react61.useReducer)(storeStateUpdatesReducer, EMPTY_ARRAY, initStateUpdates), _useReducer$ = _useReducer[0], previousStateUpdateResult = _useReducer$[0], forceComponentUpdateDispatch = _useReducer[1];
      if (previousStateUpdateResult && previousStateUpdateResult.error) {
        throw previousStateUpdateResult.error;
      }
      var lastChildProps = (0, import_react61.useRef)();
      var lastWrapperProps = (0, import_react61.useRef)(wrapperProps);
      var childPropsFromStoreUpdate = (0, import_react61.useRef)();
      var renderIsScheduled = (0, import_react61.useRef)(false);
      var actualChildProps = usePureOnlyMemo(function() {
        if (childPropsFromStoreUpdate.current && wrapperProps === lastWrapperProps.current) {
          return childPropsFromStoreUpdate.current;
        }
        return childPropsSelector(store.getState(), wrapperProps);
      }, [store, previousStateUpdateResult, wrapperProps]);
      useIsomorphicLayoutEffectWithArgs(captureWrapperProps, [lastWrapperProps, lastChildProps, renderIsScheduled, wrapperProps, actualChildProps, childPropsFromStoreUpdate, notifyNestedSubs]);
      useIsomorphicLayoutEffectWithArgs(subscribeUpdates, [shouldHandleStateChanges, store, subscription, childPropsSelector, lastWrapperProps, lastChildProps, renderIsScheduled, childPropsFromStoreUpdate, notifyNestedSubs, forceComponentUpdateDispatch], [store, subscription, childPropsSelector]);
      var renderedWrappedComponent = (0, import_react61.useMemo)(function() {
        return import_react61.default.createElement(WrappedComponent, _extends({}, actualChildProps, {
          ref: reactReduxForwardedRef
        }));
      }, [reactReduxForwardedRef, WrappedComponent, actualChildProps]);
      var renderedChild = (0, import_react61.useMemo)(function() {
        if (shouldHandleStateChanges) {
          return import_react61.default.createElement(ContextToUse.Provider, {
            value: overriddenContextValue
          }, renderedWrappedComponent);
        }
        return renderedWrappedComponent;
      }, [ContextToUse, renderedWrappedComponent, overriddenContextValue]);
      return renderedChild;
    }
    var Connect = pure ? import_react61.default.memo(ConnectFunction) : ConnectFunction;
    Connect.WrappedComponent = WrappedComponent;
    Connect.displayName = ConnectFunction.displayName = displayName;
    if (forwardRef11) {
      var forwarded = import_react61.default.forwardRef(function forwardConnectRef(props, ref2) {
        return import_react61.default.createElement(Connect, _extends({}, props, {
          reactReduxForwardedRef: ref2
        }));
      });
      forwarded.displayName = displayName;
      forwarded.WrappedComponent = WrappedComponent;
      return (0, import_hoist_non_react_statics.default)(forwarded, WrappedComponent);
    }
    return (0, import_hoist_non_react_statics.default)(Connect, WrappedComponent);
  };
}

// node_modules/react-redux/es/utils/shallowEqual.js
function is(x7, y9) {
  if (x7 === y9) {
    return x7 !== 0 || y9 !== 0 || 1 / x7 === 1 / y9;
  } else {
    return x7 !== x7 && y9 !== y9;
  }
}
function shallowEqual5(objA, objB) {
  if (is(objA, objB))
    return true;
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  var keysA = Object.keys(objA);
  var keysB = Object.keys(objB);
  if (keysA.length !== keysB.length)
    return false;
  for (var i15 = 0; i15 < keysA.length; i15++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i15]) || !is(objA[keysA[i15]], objB[keysA[i15]])) {
      return false;
    }
  }
  return true;
}

// node_modules/react-redux/es/utils/bindActionCreators.js
function bindActionCreators2(actionCreators, dispatch) {
  var boundActionCreators = {};
  var _loop = function _loop2(key2) {
    var actionCreator = actionCreators[key2];
    if (typeof actionCreator === "function") {
      boundActionCreators[key2] = function() {
        return dispatch(actionCreator.apply(void 0, arguments));
      };
    }
  };
  for (var key in actionCreators) {
    _loop(key);
  }
  return boundActionCreators;
}

// node_modules/react-redux/es/utils/isPlainObject.js
function isPlainObject5(obj) {
  if (typeof obj !== "object" || obj === null)
    return false;
  var proto2 = Object.getPrototypeOf(obj);
  if (proto2 === null)
    return true;
  var baseProto = proto2;
  while (Object.getPrototypeOf(baseProto) !== null) {
    baseProto = Object.getPrototypeOf(baseProto);
  }
  return proto2 === baseProto;
}

// node_modules/react-redux/es/utils/warning.js
function warning(message) {
  if (typeof console !== "undefined" && typeof console.error === "function") {
    console.error(message);
  }
  try {
    throw new Error(message);
  } catch (e9) {
  }
}

// node_modules/react-redux/es/utils/verifyPlainObject.js
function verifyPlainObject(value, displayName, methodName) {
  if (!isPlainObject5(value)) {
    warning(methodName + "() in " + displayName + " must return a plain object. Instead received " + value + ".");
  }
}

// node_modules/react-redux/es/connect/wrapMapToProps.js
function wrapMapToPropsConstant(getConstant) {
  return function initConstantSelector(dispatch, options) {
    var constant3 = getConstant(dispatch, options);
    function constantSelector() {
      return constant3;
    }
    constantSelector.dependsOnOwnProps = false;
    return constantSelector;
  };
}
function getDependsOnOwnProps(mapToProps) {
  return mapToProps.dependsOnOwnProps !== null && mapToProps.dependsOnOwnProps !== void 0 ? Boolean(mapToProps.dependsOnOwnProps) : mapToProps.length !== 1;
}
function wrapMapToPropsFunc(mapToProps, methodName) {
  return function initProxySelector(dispatch, _ref) {
    var displayName = _ref.displayName;
    var proxy = function mapToPropsProxy(stateOrDispatch, ownProps) {
      return proxy.dependsOnOwnProps ? proxy.mapToProps(stateOrDispatch, ownProps) : proxy.mapToProps(stateOrDispatch);
    };
    proxy.dependsOnOwnProps = true;
    proxy.mapToProps = function detectFactoryAndVerify(stateOrDispatch, ownProps) {
      proxy.mapToProps = mapToProps;
      proxy.dependsOnOwnProps = getDependsOnOwnProps(mapToProps);
      var props = proxy(stateOrDispatch, ownProps);
      if (typeof props === "function") {
        proxy.mapToProps = props;
        proxy.dependsOnOwnProps = getDependsOnOwnProps(props);
        props = proxy(stateOrDispatch, ownProps);
      }
      if (true)
        verifyPlainObject(props, displayName, methodName);
      return props;
    };
    return proxy;
  };
}

// node_modules/react-redux/es/connect/mapDispatchToProps.js
function whenMapDispatchToPropsIsFunction(mapDispatchToProps2) {
  return typeof mapDispatchToProps2 === "function" ? wrapMapToPropsFunc(mapDispatchToProps2, "mapDispatchToProps") : void 0;
}
function whenMapDispatchToPropsIsMissing(mapDispatchToProps2) {
  return !mapDispatchToProps2 ? wrapMapToPropsConstant(function(dispatch) {
    return {
      dispatch
    };
  }) : void 0;
}
function whenMapDispatchToPropsIsObject(mapDispatchToProps2) {
  return mapDispatchToProps2 && typeof mapDispatchToProps2 === "object" ? wrapMapToPropsConstant(function(dispatch) {
    return bindActionCreators2(mapDispatchToProps2, dispatch);
  }) : void 0;
}
var mapDispatchToProps_default = [whenMapDispatchToPropsIsFunction, whenMapDispatchToPropsIsMissing, whenMapDispatchToPropsIsObject];

// node_modules/react-redux/es/connect/mapStateToProps.js
function whenMapStateToPropsIsFunction(mapStateToProps) {
  return typeof mapStateToProps === "function" ? wrapMapToPropsFunc(mapStateToProps, "mapStateToProps") : void 0;
}
function whenMapStateToPropsIsMissing(mapStateToProps) {
  return !mapStateToProps ? wrapMapToPropsConstant(function() {
    return {};
  }) : void 0;
}
var mapStateToProps_default = [whenMapStateToPropsIsFunction, whenMapStateToPropsIsMissing];

// node_modules/react-redux/es/connect/mergeProps.js
function defaultMergeProps(stateProps, dispatchProps, ownProps) {
  return _extends({}, ownProps, stateProps, dispatchProps);
}
function wrapMergePropsFunc(mergeProps) {
  return function initMergePropsProxy(dispatch, _ref) {
    var displayName = _ref.displayName, pure = _ref.pure, areMergedPropsEqual = _ref.areMergedPropsEqual;
    var hasRunOnce = false;
    var mergedProps;
    return function mergePropsProxy(stateProps, dispatchProps, ownProps) {
      var nextMergedProps = mergeProps(stateProps, dispatchProps, ownProps);
      if (hasRunOnce) {
        if (!pure || !areMergedPropsEqual(nextMergedProps, mergedProps))
          mergedProps = nextMergedProps;
      } else {
        hasRunOnce = true;
        mergedProps = nextMergedProps;
        if (true)
          verifyPlainObject(mergedProps, displayName, "mergeProps");
      }
      return mergedProps;
    };
  };
}
function whenMergePropsIsFunction(mergeProps) {
  return typeof mergeProps === "function" ? wrapMergePropsFunc(mergeProps) : void 0;
}
function whenMergePropsIsOmitted(mergeProps) {
  return !mergeProps ? function() {
    return defaultMergeProps;
  } : void 0;
}
var mergeProps_default = [whenMergePropsIsFunction, whenMergePropsIsOmitted];

// node_modules/react-redux/es/connect/verifySubselectors.js
function verify(selector, methodName, displayName) {
  if (!selector) {
    throw new Error("Unexpected value for " + methodName + " in " + displayName + ".");
  } else if (methodName === "mapStateToProps" || methodName === "mapDispatchToProps") {
    if (!Object.prototype.hasOwnProperty.call(selector, "dependsOnOwnProps")) {
      warning("The selector for " + methodName + " of " + displayName + " did not specify a value for dependsOnOwnProps.");
    }
  }
}
function verifySubselectors(mapStateToProps, mapDispatchToProps2, mergeProps, displayName) {
  verify(mapStateToProps, "mapStateToProps", displayName);
  verify(mapDispatchToProps2, "mapDispatchToProps", displayName);
  verify(mergeProps, "mergeProps", displayName);
}

// node_modules/react-redux/es/connect/selectorFactory.js
var _excluded7 = ["initMapStateToProps", "initMapDispatchToProps", "initMergeProps"];
function impureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps2, mergeProps, dispatch) {
  return function impureFinalPropsSelector(state, ownProps) {
    return mergeProps(mapStateToProps(state, ownProps), mapDispatchToProps2(dispatch, ownProps), ownProps);
  };
}
function pureFinalPropsSelectorFactory(mapStateToProps, mapDispatchToProps2, mergeProps, dispatch, _ref) {
  var areStatesEqual = _ref.areStatesEqual, areOwnPropsEqual = _ref.areOwnPropsEqual, areStatePropsEqual = _ref.areStatePropsEqual;
  var hasRunAtLeastOnce = false;
  var state;
  var ownProps;
  var stateProps;
  var dispatchProps;
  var mergedProps;
  function handleFirstCall(firstState, firstOwnProps) {
    state = firstState;
    ownProps = firstOwnProps;
    stateProps = mapStateToProps(state, ownProps);
    dispatchProps = mapDispatchToProps2(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    hasRunAtLeastOnce = true;
    return mergedProps;
  }
  function handleNewPropsAndNewState() {
    stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps2.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps2(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewProps() {
    if (mapStateToProps.dependsOnOwnProps)
      stateProps = mapStateToProps(state, ownProps);
    if (mapDispatchToProps2.dependsOnOwnProps)
      dispatchProps = mapDispatchToProps2(dispatch, ownProps);
    mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleNewState() {
    var nextStateProps = mapStateToProps(state, ownProps);
    var statePropsChanged = !areStatePropsEqual(nextStateProps, stateProps);
    stateProps = nextStateProps;
    if (statePropsChanged)
      mergedProps = mergeProps(stateProps, dispatchProps, ownProps);
    return mergedProps;
  }
  function handleSubsequentCalls(nextState, nextOwnProps) {
    var propsChanged = !areOwnPropsEqual(nextOwnProps, ownProps);
    var stateChanged = !areStatesEqual(nextState, state, nextOwnProps, ownProps);
    state = nextState;
    ownProps = nextOwnProps;
    if (propsChanged && stateChanged)
      return handleNewPropsAndNewState();
    if (propsChanged)
      return handleNewProps();
    if (stateChanged)
      return handleNewState();
    return mergedProps;
  }
  return function pureFinalPropsSelector(nextState, nextOwnProps) {
    return hasRunAtLeastOnce ? handleSubsequentCalls(nextState, nextOwnProps) : handleFirstCall(nextState, nextOwnProps);
  };
}
function finalPropsSelectorFactory(dispatch, _ref2) {
  var initMapStateToProps = _ref2.initMapStateToProps, initMapDispatchToProps = _ref2.initMapDispatchToProps, initMergeProps = _ref2.initMergeProps, options = _objectWithoutPropertiesLoose(_ref2, _excluded7);
  var mapStateToProps = initMapStateToProps(dispatch, options);
  var mapDispatchToProps2 = initMapDispatchToProps(dispatch, options);
  var mergeProps = initMergeProps(dispatch, options);
  if (true) {
    verifySubselectors(mapStateToProps, mapDispatchToProps2, mergeProps, options.displayName);
  }
  var selectorFactory = options.pure ? pureFinalPropsSelectorFactory : impureFinalPropsSelectorFactory;
  return selectorFactory(mapStateToProps, mapDispatchToProps2, mergeProps, dispatch, options);
}

// node_modules/react-redux/es/connect/connect.js
var _excluded8 = ["pure", "areStatesEqual", "areOwnPropsEqual", "areStatePropsEqual", "areMergedPropsEqual"];
function match2(arg, factories, name2) {
  for (var i15 = factories.length - 1; i15 >= 0; i15--) {
    var result = factories[i15](arg);
    if (result)
      return result;
  }
  return function(dispatch, options) {
    throw new Error("Invalid value of type " + typeof arg + " for " + name2 + " argument when connecting component " + options.wrappedComponentName + ".");
  };
}
function strictEqual(a13, b6) {
  return a13 === b6;
}
function createConnect(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$connectHOC = _ref.connectHOC, connectHOC = _ref$connectHOC === void 0 ? connectAdvanced : _ref$connectHOC, _ref$mapStateToPropsF = _ref.mapStateToPropsFactories, mapStateToPropsFactories = _ref$mapStateToPropsF === void 0 ? mapStateToProps_default : _ref$mapStateToPropsF, _ref$mapDispatchToPro = _ref.mapDispatchToPropsFactories, mapDispatchToPropsFactories = _ref$mapDispatchToPro === void 0 ? mapDispatchToProps_default : _ref$mapDispatchToPro, _ref$mergePropsFactor = _ref.mergePropsFactories, mergePropsFactories = _ref$mergePropsFactor === void 0 ? mergeProps_default : _ref$mergePropsFactor, _ref$selectorFactory = _ref.selectorFactory, selectorFactory = _ref$selectorFactory === void 0 ? finalPropsSelectorFactory : _ref$selectorFactory;
  return function connect(mapStateToProps, mapDispatchToProps2, mergeProps, _ref2) {
    if (_ref2 === void 0) {
      _ref2 = {};
    }
    var _ref3 = _ref2, _ref3$pure = _ref3.pure, pure = _ref3$pure === void 0 ? true : _ref3$pure, _ref3$areStatesEqual = _ref3.areStatesEqual, areStatesEqual = _ref3$areStatesEqual === void 0 ? strictEqual : _ref3$areStatesEqual, _ref3$areOwnPropsEqua = _ref3.areOwnPropsEqual, areOwnPropsEqual = _ref3$areOwnPropsEqua === void 0 ? shallowEqual5 : _ref3$areOwnPropsEqua, _ref3$areStatePropsEq = _ref3.areStatePropsEqual, areStatePropsEqual = _ref3$areStatePropsEq === void 0 ? shallowEqual5 : _ref3$areStatePropsEq, _ref3$areMergedPropsE = _ref3.areMergedPropsEqual, areMergedPropsEqual = _ref3$areMergedPropsE === void 0 ? shallowEqual5 : _ref3$areMergedPropsE, extraOptions = _objectWithoutPropertiesLoose(_ref3, _excluded8);
    var initMapStateToProps = match2(mapStateToProps, mapStateToPropsFactories, "mapStateToProps");
    var initMapDispatchToProps = match2(mapDispatchToProps2, mapDispatchToPropsFactories, "mapDispatchToProps");
    var initMergeProps = match2(mergeProps, mergePropsFactories, "mergeProps");
    return connectHOC(selectorFactory, _extends({
      // used in error messages
      methodName: "connect",
      // used to compute Connect's displayName from the wrapped component's displayName.
      getDisplayName: function getDisplayName(name2) {
        return "Connect(" + name2 + ")";
      },
      // if mapStateToProps is falsy, the Connect component doesn't subscribe to store state changes
      shouldHandleStateChanges: Boolean(mapStateToProps),
      // passed through to selectorFactory
      initMapStateToProps,
      initMapDispatchToProps,
      initMergeProps,
      pure,
      areStatesEqual,
      areOwnPropsEqual,
      areStatePropsEqual,
      areMergedPropsEqual
    }, extraOptions));
  };
}
var connect_default = createConnect();

// node_modules/react-redux/es/hooks/useStore.js
var import_react63 = __toESM(require_react());

// node_modules/react-redux/es/hooks/useReduxContext.js
var import_react62 = __toESM(require_react());
function useReduxContext() {
  var contextValue = (0, import_react62.useContext)(ReactReduxContext);
  if (!contextValue) {
    throw new Error("could not find react-redux context value; please ensure the component is wrapped in a <Provider>");
  }
  return contextValue;
}

// node_modules/react-redux/es/hooks/useStore.js
function createStoreHook(context) {
  if (context === void 0) {
    context = ReactReduxContext;
  }
  var useReduxContext2 = context === ReactReduxContext ? useReduxContext : function() {
    return (0, import_react63.useContext)(context);
  };
  return function useStore2() {
    var _useReduxContext = useReduxContext2(), store = _useReduxContext.store;
    return store;
  };
}
var useStore = createStoreHook();

// node_modules/react-redux/es/hooks/useDispatch.js
function createDispatchHook(context) {
  if (context === void 0) {
    context = ReactReduxContext;
  }
  var useStore2 = context === ReactReduxContext ? useStore : createStoreHook(context);
  return function useDispatch2() {
    var store = useStore2();
    return store.dispatch;
  };
}
var useDispatch = createDispatchHook();

// node_modules/react-redux/es/hooks/useSelector.js
var import_react64 = __toESM(require_react());
var refEquality = function refEquality2(a13, b6) {
  return a13 === b6;
};
function useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub) {
  var _useReducer = (0, import_react64.useReducer)(function(s20) {
    return s20 + 1;
  }, 0), forceRender = _useReducer[1];
  var subscription = (0, import_react64.useMemo)(function() {
    return createSubscription(store, contextSub);
  }, [store, contextSub]);
  var latestSubscriptionCallbackError = (0, import_react64.useRef)();
  var latestSelector = (0, import_react64.useRef)();
  var latestStoreState = (0, import_react64.useRef)();
  var latestSelectedState = (0, import_react64.useRef)();
  var storeState = store.getState();
  var selectedState;
  try {
    if (selector !== latestSelector.current || storeState !== latestStoreState.current || latestSubscriptionCallbackError.current) {
      var newSelectedState = selector(storeState);
      if (latestSelectedState.current === void 0 || !equalityFn(newSelectedState, latestSelectedState.current)) {
        selectedState = newSelectedState;
      } else {
        selectedState = latestSelectedState.current;
      }
    } else {
      selectedState = latestSelectedState.current;
    }
  } catch (err) {
    if (latestSubscriptionCallbackError.current) {
      err.message += "\nThe error may be correlated with this previous error:\n" + latestSubscriptionCallbackError.current.stack + "\n\n";
    }
    throw err;
  }
  useIsomorphicLayoutEffect4(function() {
    latestSelector.current = selector;
    latestStoreState.current = storeState;
    latestSelectedState.current = selectedState;
    latestSubscriptionCallbackError.current = void 0;
  });
  useIsomorphicLayoutEffect4(function() {
    function checkForUpdates() {
      try {
        var newStoreState = store.getState();
        if (newStoreState === latestStoreState.current) {
          return;
        }
        var _newSelectedState = latestSelector.current(newStoreState);
        if (equalityFn(_newSelectedState, latestSelectedState.current)) {
          return;
        }
        latestSelectedState.current = _newSelectedState;
        latestStoreState.current = newStoreState;
      } catch (err) {
        latestSubscriptionCallbackError.current = err;
      }
      forceRender();
    }
    subscription.onStateChange = checkForUpdates;
    subscription.trySubscribe();
    checkForUpdates();
    return function() {
      return subscription.tryUnsubscribe();
    };
  }, [store, subscription]);
  return selectedState;
}
function createSelectorHook(context) {
  if (context === void 0) {
    context = ReactReduxContext;
  }
  var useReduxContext2 = context === ReactReduxContext ? useReduxContext : function() {
    return (0, import_react64.useContext)(context);
  };
  return function useSelector2(selector, equalityFn) {
    if (equalityFn === void 0) {
      equalityFn = refEquality;
    }
    if (true) {
      if (!selector) {
        throw new Error("You must pass a selector to useSelector");
      }
      if (typeof selector !== "function") {
        throw new Error("You must pass a function as a selector to useSelector");
      }
      if (typeof equalityFn !== "function") {
        throw new Error("You must pass a function as an equality function to useSelector");
      }
    }
    var _useReduxContext = useReduxContext2(), store = _useReduxContext.store, contextSub = _useReduxContext.subscription;
    var selectedState = useSelectorWithStoreAndSubscription(selector, equalityFn, store, contextSub);
    (0, import_react64.useDebugValue)(selectedState);
    return selectedState;
  };
}
var useSelector = createSelectorHook();

// node_modules/react-redux/es/utils/reactBatchedUpdates.js
var import_react_dom6 = __toESM(require_react_dom());

// node_modules/react-redux/es/index.js
setBatch(import_react_dom6.unstable_batchedUpdates);

// node_modules/use-memo-one/dist/use-memo-one.esm.js
var import_react65 = __toESM(require_react());
function areInputsEqual(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i15 = 0; i15 < newInputs.length; i15++) {
    if (newInputs[i15] !== lastInputs[i15]) {
      return false;
    }
  }
  return true;
}
function useMemoOne(getResult, inputs) {
  var initial = (0, import_react65.useState)(function() {
    return {
      inputs,
      result: getResult()
    };
  })[0];
  var isFirstRun = (0, import_react65.useRef)(true);
  var committed = (0, import_react65.useRef)(initial);
  var useCache = isFirstRun.current || Boolean(inputs && committed.current.inputs && areInputsEqual(inputs, committed.current.inputs));
  var cache = useCache ? committed.current : {
    inputs,
    result: getResult()
  };
  (0, import_react65.useEffect)(function() {
    isFirstRun.current = false;
    committed.current = cache;
  }, [cache]);
  return cache.result;
}
function useCallbackOne(callback, inputs) {
  return useMemoOne(function() {
    return callback;
  }, inputs);
}
var useMemo11 = useMemoOne;
var useCallback11 = useCallbackOne;

// node_modules/css-box-model/node_modules/tiny-invariant/dist/esm/tiny-invariant.js
var isProduction = false;
var prefix = "Invariant failed";
function invariant(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction) {
    throw new Error(prefix);
  }
  var provided = typeof message === "function" ? message() : message;
  var value = provided ? "".concat(prefix, ": ").concat(provided) : prefix;
  throw new Error(value);
}

// node_modules/css-box-model/dist/css-box-model.esm.js
var getRect = function getRect2(_ref) {
  var top = _ref.top, right = _ref.right, bottom = _ref.bottom, left = _ref.left;
  var width = right - left;
  var height = bottom - top;
  var rect = {
    top,
    right,
    bottom,
    left,
    width,
    height,
    x: left,
    y: top,
    center: {
      x: (right + left) / 2,
      y: (bottom + top) / 2
    }
  };
  return rect;
};
var expand = function expand2(target, expandBy) {
  return {
    top: target.top - expandBy.top,
    left: target.left - expandBy.left,
    bottom: target.bottom + expandBy.bottom,
    right: target.right + expandBy.right
  };
};
var shrink = function shrink2(target, shrinkBy) {
  return {
    top: target.top + shrinkBy.top,
    left: target.left + shrinkBy.left,
    bottom: target.bottom - shrinkBy.bottom,
    right: target.right - shrinkBy.right
  };
};
var shift3 = function shift4(target, shiftBy) {
  return {
    top: target.top + shiftBy.y,
    left: target.left + shiftBy.x,
    bottom: target.bottom + shiftBy.y,
    right: target.right + shiftBy.x
  };
};
var noSpacing = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var createBox = function createBox2(_ref2) {
  var borderBox = _ref2.borderBox, _ref2$margin = _ref2.margin, margin = _ref2$margin === void 0 ? noSpacing : _ref2$margin, _ref2$border = _ref2.border, border = _ref2$border === void 0 ? noSpacing : _ref2$border, _ref2$padding = _ref2.padding, padding = _ref2$padding === void 0 ? noSpacing : _ref2$padding;
  var marginBox = getRect(expand(borderBox, margin));
  var paddingBox = getRect(shrink(borderBox, border));
  var contentBox = getRect(shrink(paddingBox, padding));
  return {
    marginBox,
    borderBox: getRect(borderBox),
    paddingBox,
    contentBox,
    margin,
    border,
    padding
  };
};
var parse3 = function parse4(raw) {
  var value = raw.slice(0, -2);
  var suffix2 = raw.slice(-2);
  if (suffix2 !== "px") {
    return 0;
  }
  var result = Number(value);
  !!isNaN(result) ? true ? invariant(false, "Could not parse value [raw: " + raw + ", without suffix: " + value + "]") : invariant(false) : void 0;
  return result;
};
var getWindowScroll = function getWindowScroll2() {
  return {
    x: window.pageXOffset,
    y: window.pageYOffset
  };
};
var offset = function offset2(original, change) {
  var borderBox = original.borderBox, border = original.border, margin = original.margin, padding = original.padding;
  var shifted = shift3(borderBox, change);
  return createBox({
    borderBox: shifted,
    border,
    margin,
    padding
  });
};
var withScroll = function withScroll2(original, scroll3) {
  if (scroll3 === void 0) {
    scroll3 = getWindowScroll();
  }
  return offset(original, scroll3);
};
var calculateBox = function calculateBox2(borderBox, styles5) {
  var margin = {
    top: parse3(styles5.marginTop),
    right: parse3(styles5.marginRight),
    bottom: parse3(styles5.marginBottom),
    left: parse3(styles5.marginLeft)
  };
  var padding = {
    top: parse3(styles5.paddingTop),
    right: parse3(styles5.paddingRight),
    bottom: parse3(styles5.paddingBottom),
    left: parse3(styles5.paddingLeft)
  };
  var border = {
    top: parse3(styles5.borderTopWidth),
    right: parse3(styles5.borderRightWidth),
    bottom: parse3(styles5.borderBottomWidth),
    left: parse3(styles5.borderLeftWidth)
  };
  return createBox({
    borderBox,
    margin,
    padding,
    border
  });
};
var getBox = function getBox2(el) {
  var borderBox = el.getBoundingClientRect();
  var styles5 = window.getComputedStyle(el);
  return calculateBox(borderBox, styles5);
};

// node_modules/memoize-one/dist/memoize-one.esm.js
var safeIsNaN = Number.isNaN || function ponyfill(value) {
  return typeof value === "number" && value !== value;
};
function isEqual2(first, second) {
  if (first === second) {
    return true;
  }
  if (safeIsNaN(first) && safeIsNaN(second)) {
    return true;
  }
  return false;
}
function areInputsEqual2(newInputs, lastInputs) {
  if (newInputs.length !== lastInputs.length) {
    return false;
  }
  for (var i15 = 0; i15 < newInputs.length; i15++) {
    if (!isEqual2(newInputs[i15], lastInputs[i15])) {
      return false;
    }
  }
  return true;
}
function memoizeOne(resultFn, isEqual7) {
  if (isEqual7 === void 0) {
    isEqual7 = areInputsEqual2;
  }
  var lastThis;
  var lastArgs = [];
  var lastResult;
  var calledOnce = false;
  function memoized() {
    var newArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      newArgs[_i] = arguments[_i];
    }
    if (calledOnce && lastThis === this && isEqual7(newArgs, lastArgs)) {
      return lastResult;
    }
    lastResult = resultFn.apply(this, newArgs);
    calledOnce = true;
    lastThis = this;
    lastArgs = newArgs;
    return lastResult;
  }
  return memoized;
}
var memoize_one_esm_default = memoizeOne;

// node_modules/raf-schd/dist/raf-schd.esm.js
var rafSchd = function rafSchd2(fn2) {
  var lastArgs = [];
  var frameId = null;
  var wrapperFn = function wrapperFn2() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    lastArgs = args;
    if (frameId) {
      return;
    }
    frameId = requestAnimationFrame(function() {
      frameId = null;
      fn2.apply(void 0, lastArgs);
    });
  };
  wrapperFn.cancel = function() {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
  };
  return wrapperFn;
};
var raf_schd_esm_default = rafSchd;

// node_modules/react-beautiful-dnd/dist/react-beautiful-dnd.esm.js
var import_react_dom7 = __toESM(require_react_dom());
var isProduction2 = false;
var spacesAndTabs = /[ \t]{2,}/g;
var lineStartWithSpaces = /^[ \t]*/gm;
var clean = function clean2(value) {
  return value.replace(spacesAndTabs, " ").replace(lineStartWithSpaces, "").trim();
};
var getDevMessage = function getDevMessage2(message) {
  return clean("\n  %creact-beautiful-dnd\n\n  %c" + clean(message) + "\n\n  %c👷‍ This is a development only message. It will be removed in production builds.\n");
};
var getFormattedMessage = function getFormattedMessage2(message) {
  return [getDevMessage(message), "color: #00C584; font-size: 1.2em; font-weight: bold;", "line-height: 1.5", "color: #723874;"];
};
var isDisabledFlag = "__react-beautiful-dnd-disable-dev-warnings";
function log(type, message) {
  var _console;
  if (isProduction2) {
    return;
  }
  if (typeof window !== "undefined" && window[isDisabledFlag]) {
    return;
  }
  (_console = console)[type].apply(_console, getFormattedMessage(message));
}
var warning2 = log.bind(null, "warn");
var error = log.bind(null, "error");
function noop4() {
}
function getOptions2(shared2, fromBinding) {
  return _extends({}, shared2, {}, fromBinding);
}
function bindEvents(el, bindings, sharedOptions) {
  var unbindings = bindings.map(function(binding) {
    var options = getOptions2(sharedOptions, binding.options);
    el.addEventListener(binding.eventName, binding.fn, options);
    return function unbind() {
      el.removeEventListener(binding.eventName, binding.fn, options);
    };
  });
  return function unbindAll() {
    unbindings.forEach(function(unbind) {
      unbind();
    });
  };
}
var isProduction$1 = false;
var prefix2 = "Invariant failed";
function RbdInvariant(message) {
  this.message = message;
}
RbdInvariant.prototype.toString = function toString2() {
  return this.message;
};
function invariant2(condition, message) {
  if (condition) {
    return;
  }
  if (isProduction$1) {
    throw new RbdInvariant(prefix2);
  } else {
    throw new RbdInvariant(prefix2 + ": " + (message || ""));
  }
}
var ErrorBoundary = function(_React$Component) {
  _inheritsLoose(ErrorBoundary3, _React$Component);
  function ErrorBoundary3() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$Component.call.apply(_React$Component, [this].concat(args)) || this;
    _this.callbacks = null;
    _this.unbind = noop4;
    _this.onWindowError = function(event) {
      var callbacks = _this.getCallbacks();
      if (callbacks.isDragging()) {
        callbacks.tryAbort();
        true ? warning2("\n        An error was caught by our window 'error' event listener while a drag was occurring.\n        The active drag has been aborted.\n      ") : void 0;
      }
      var err = event.error;
      if (err instanceof RbdInvariant) {
        event.preventDefault();
        if (true) {
          error(err.message);
        }
      }
    };
    _this.getCallbacks = function() {
      if (!_this.callbacks) {
        throw new Error("Unable to find AppCallbacks in <ErrorBoundary/>");
      }
      return _this.callbacks;
    };
    _this.setCallbacks = function(callbacks) {
      _this.callbacks = callbacks;
    };
    return _this;
  }
  var _proto = ErrorBoundary3.prototype;
  _proto.componentDidMount = function componentDidMount() {
    this.unbind = bindEvents(window, [{
      eventName: "error",
      fn: this.onWindowError
    }]);
  };
  _proto.componentDidCatch = function componentDidCatch(err) {
    if (err instanceof RbdInvariant) {
      if (true) {
        error(err.message);
      }
      this.setState({});
      return;
    }
    throw err;
  };
  _proto.componentWillUnmount = function componentWillUnmount() {
    this.unbind();
  };
  _proto.render = function render3() {
    return this.props.children(this.setCallbacks);
  };
  return ErrorBoundary3;
}(import_react66.default.Component);
var dragHandleUsageInstructions = "\n  Press space bar to start a drag.\n  When dragging you can use the arrow keys to move the item around and escape to cancel.\n  Some screen readers may require you to be in focus mode or to use your pass through key\n";
var position = function position2(index2) {
  return index2 + 1;
};
var onDragStart = function onDragStart2(start3) {
  return "\n  You have lifted an item in position " + position(start3.source.index) + "\n";
};
var withLocation = function withLocation2(source, destination) {
  var isInHomeList = source.droppableId === destination.droppableId;
  var startPosition = position(source.index);
  var endPosition = position(destination.index);
  if (isInHomeList) {
    return "\n      You have moved the item from position " + startPosition + "\n      to position " + endPosition + "\n    ";
  }
  return "\n    You have moved the item from position " + startPosition + "\n    in list " + source.droppableId + "\n    to list " + destination.droppableId + "\n    in position " + endPosition + "\n  ";
};
var withCombine = function withCombine2(id, source, combine2) {
  var inHomeList = source.droppableId === combine2.droppableId;
  if (inHomeList) {
    return "\n      The item " + id + "\n      has been combined with " + combine2.draggableId;
  }
  return "\n      The item " + id + "\n      in list " + source.droppableId + "\n      has been combined with " + combine2.draggableId + "\n      in list " + combine2.droppableId + "\n    ";
};
var onDragUpdate = function onDragUpdate2(update4) {
  var location = update4.destination;
  if (location) {
    return withLocation(update4.source, location);
  }
  var combine2 = update4.combine;
  if (combine2) {
    return withCombine(update4.draggableId, update4.source, combine2);
  }
  return "You are over an area that cannot be dropped on";
};
var returnedToStart = function returnedToStart2(source) {
  return "\n  The item has returned to its starting position\n  of " + position(source.index) + "\n";
};
var onDragEnd = function onDragEnd2(result) {
  if (result.reason === "CANCEL") {
    return "\n      Movement cancelled.\n      " + returnedToStart(result.source) + "\n    ";
  }
  var location = result.destination;
  var combine2 = result.combine;
  if (location) {
    return "\n      You have dropped the item.\n      " + withLocation(result.source, location) + "\n    ";
  }
  if (combine2) {
    return "\n      You have dropped the item.\n      " + withCombine(result.draggableId, result.source, combine2) + "\n    ";
  }
  return "\n    The item has been dropped while not over a drop area.\n    " + returnedToStart(result.source) + "\n  ";
};
var preset = {
  dragHandleUsageInstructions,
  onDragStart,
  onDragUpdate,
  onDragEnd
};
var origin = {
  x: 0,
  y: 0
};
var add = function add2(point1, point2) {
  return {
    x: point1.x + point2.x,
    y: point1.y + point2.y
  };
};
var subtract = function subtract2(point1, point2) {
  return {
    x: point1.x - point2.x,
    y: point1.y - point2.y
  };
};
var isEqual3 = function isEqual4(point1, point2) {
  return point1.x === point2.x && point1.y === point2.y;
};
var negate = function negate2(point) {
  return {
    x: point.x !== 0 ? -point.x : 0,
    y: point.y !== 0 ? -point.y : 0
  };
};
var patch = function patch2(line, value, otherValue) {
  var _ref;
  if (otherValue === void 0) {
    otherValue = 0;
  }
  return _ref = {}, _ref[line] = value, _ref[line === "x" ? "y" : "x"] = otherValue, _ref;
};
var distance = function distance2(point1, point2) {
  return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
};
var closest = function closest2(target, points) {
  return Math.min.apply(Math, points.map(function(point) {
    return distance(target, point);
  }));
};
var apply2 = function apply3(fn2) {
  return function(point) {
    return {
      x: fn2(point.x),
      y: fn2(point.y)
    };
  };
};
var executeClip = function(frame, subject) {
  var result = getRect({
    top: Math.max(subject.top, frame.top),
    right: Math.min(subject.right, frame.right),
    bottom: Math.min(subject.bottom, frame.bottom),
    left: Math.max(subject.left, frame.left)
  });
  if (result.width <= 0 || result.height <= 0) {
    return null;
  }
  return result;
};
var offsetByPosition = function offsetByPosition2(spacing, point) {
  return {
    top: spacing.top + point.y,
    left: spacing.left + point.x,
    bottom: spacing.bottom + point.y,
    right: spacing.right + point.x
  };
};
var getCorners = function getCorners2(spacing) {
  return [{
    x: spacing.left,
    y: spacing.top
  }, {
    x: spacing.right,
    y: spacing.top
  }, {
    x: spacing.left,
    y: spacing.bottom
  }, {
    x: spacing.right,
    y: spacing.bottom
  }];
};
var noSpacing2 = {
  top: 0,
  right: 0,
  bottom: 0,
  left: 0
};
var scroll = function scroll2(target, frame) {
  if (!frame) {
    return target;
  }
  return offsetByPosition(target, frame.scroll.diff.displacement);
};
var increase = function increase2(target, axis, withPlaceholder) {
  if (withPlaceholder && withPlaceholder.increasedBy) {
    var _extends24;
    return _extends({}, target, (_extends24 = {}, _extends24[axis.end] = target[axis.end] + withPlaceholder.increasedBy[axis.line], _extends24));
  }
  return target;
};
var clip = function clip2(target, frame) {
  if (frame && frame.shouldClipSubject) {
    return executeClip(frame.pageMarginBox, target);
  }
  return getRect(target);
};
var getSubject = function(_ref) {
  var page = _ref.page, withPlaceholder = _ref.withPlaceholder, axis = _ref.axis, frame = _ref.frame;
  var scrolled = scroll(page.marginBox, frame);
  var increased = increase(scrolled, axis, withPlaceholder);
  var clipped = clip(increased, frame);
  return {
    page,
    withPlaceholder,
    active: clipped
  };
};
var scrollDroppable = function(droppable2, newScroll) {
  !droppable2.frame ? true ? invariant2(false) : invariant2(false) : void 0;
  var scrollable = droppable2.frame;
  var scrollDiff = subtract(newScroll, scrollable.scroll.initial);
  var scrollDisplacement = negate(scrollDiff);
  var frame = _extends({}, scrollable, {
    scroll: {
      initial: scrollable.scroll.initial,
      current: newScroll,
      diff: {
        value: scrollDiff,
        displacement: scrollDisplacement
      },
      max: scrollable.scroll.max
    }
  });
  var subject = getSubject({
    page: droppable2.subject.page,
    withPlaceholder: droppable2.subject.withPlaceholder,
    axis: droppable2.axis,
    frame
  });
  var result = _extends({}, droppable2, {
    frame,
    subject
  });
  return result;
};
function isInteger(value) {
  if (Number.isInteger) {
    return Number.isInteger(value);
  }
  return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
}
function values2(map5) {
  if (Object.values) {
    return Object.values(map5);
  }
  return Object.keys(map5).map(function(key) {
    return map5[key];
  });
}
function findIndex(list, predicate) {
  if (list.findIndex) {
    return list.findIndex(predicate);
  }
  for (var i15 = 0; i15 < list.length; i15++) {
    if (predicate(list[i15])) {
      return i15;
    }
  }
  return -1;
}
function find(list, predicate) {
  if (list.find) {
    return list.find(predicate);
  }
  var index2 = findIndex(list, predicate);
  if (index2 !== -1) {
    return list[index2];
  }
  return void 0;
}
function toArray(list) {
  return Array.prototype.slice.call(list);
}
var toDroppableMap = memoize_one_esm_default(function(droppables) {
  return droppables.reduce(function(previous, current) {
    previous[current.descriptor.id] = current;
    return previous;
  }, {});
});
var toDraggableMap = memoize_one_esm_default(function(draggables) {
  return draggables.reduce(function(previous, current) {
    previous[current.descriptor.id] = current;
    return previous;
  }, {});
});
var toDroppableList = memoize_one_esm_default(function(droppables) {
  return values2(droppables);
});
var toDraggableList = memoize_one_esm_default(function(draggables) {
  return values2(draggables);
});
var getDraggablesInsideDroppable = memoize_one_esm_default(function(droppableId, draggables) {
  var result = toDraggableList(draggables).filter(function(draggable2) {
    return droppableId === draggable2.descriptor.droppableId;
  }).sort(function(a13, b6) {
    return a13.descriptor.index - b6.descriptor.index;
  });
  return result;
});
function tryGetDestination(impact) {
  if (impact.at && impact.at.type === "REORDER") {
    return impact.at.destination;
  }
  return null;
}
function tryGetCombine(impact) {
  if (impact.at && impact.at.type === "COMBINE") {
    return impact.at.combine;
  }
  return null;
}
var removeDraggableFromList = memoize_one_esm_default(function(remove3, list) {
  return list.filter(function(item) {
    return item.descriptor.id !== remove3.descriptor.id;
  });
});
var moveToNextCombine = function(_ref) {
  var isMovingForward = _ref.isMovingForward, draggable2 = _ref.draggable, destination = _ref.destination, insideDestination = _ref.insideDestination, previousImpact = _ref.previousImpact;
  if (!destination.isCombineEnabled) {
    return null;
  }
  var location = tryGetDestination(previousImpact);
  if (!location) {
    return null;
  }
  function getImpact(target) {
    var at = {
      type: "COMBINE",
      combine: {
        draggableId: target,
        droppableId: destination.descriptor.id
      }
    };
    return _extends({}, previousImpact, {
      at
    });
  }
  var all2 = previousImpact.displaced.all;
  var closestId = all2.length ? all2[0] : null;
  if (isMovingForward) {
    return closestId ? getImpact(closestId) : null;
  }
  var withoutDraggable = removeDraggableFromList(draggable2, insideDestination);
  if (!closestId) {
    if (!withoutDraggable.length) {
      return null;
    }
    var last2 = withoutDraggable[withoutDraggable.length - 1];
    return getImpact(last2.descriptor.id);
  }
  var indexOfClosest = findIndex(withoutDraggable, function(d17) {
    return d17.descriptor.id === closestId;
  });
  !(indexOfClosest !== -1) ? true ? invariant2(false, "Could not find displaced item in set") : invariant2(false) : void 0;
  var proposedIndex = indexOfClosest - 1;
  if (proposedIndex < 0) {
    return null;
  }
  var before = withoutDraggable[proposedIndex];
  return getImpact(before.descriptor.id);
};
var isHomeOf = function(draggable2, destination) {
  return draggable2.descriptor.droppableId === destination.descriptor.id;
};
var noDisplacedBy = {
  point: origin,
  value: 0
};
var emptyGroups = {
  invisible: {},
  visible: {},
  all: []
};
var noImpact = {
  displaced: emptyGroups,
  displacedBy: noDisplacedBy,
  at: null
};
var isWithin = function(lowerBound, upperBound) {
  return function(value) {
    return lowerBound <= value && value <= upperBound;
  };
};
var isPartiallyVisibleThroughFrame = function(frame) {
  var isWithinVertical = isWithin(frame.top, frame.bottom);
  var isWithinHorizontal = isWithin(frame.left, frame.right);
  return function(subject) {
    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    if (isContained) {
      return true;
    }
    var isPartiallyVisibleVertically = isWithinVertical(subject.top) || isWithinVertical(subject.bottom);
    var isPartiallyVisibleHorizontally = isWithinHorizontal(subject.left) || isWithinHorizontal(subject.right);
    var isPartiallyContained = isPartiallyVisibleVertically && isPartiallyVisibleHorizontally;
    if (isPartiallyContained) {
      return true;
    }
    var isBiggerVertically = subject.top < frame.top && subject.bottom > frame.bottom;
    var isBiggerHorizontally = subject.left < frame.left && subject.right > frame.right;
    var isTargetBiggerThanFrame = isBiggerVertically && isBiggerHorizontally;
    if (isTargetBiggerThanFrame) {
      return true;
    }
    var isTargetBiggerOnOneAxis = isBiggerVertically && isPartiallyVisibleHorizontally || isBiggerHorizontally && isPartiallyVisibleVertically;
    return isTargetBiggerOnOneAxis;
  };
};
var isTotallyVisibleThroughFrame = function(frame) {
  var isWithinVertical = isWithin(frame.top, frame.bottom);
  var isWithinHorizontal = isWithin(frame.left, frame.right);
  return function(subject) {
    var isContained = isWithinVertical(subject.top) && isWithinVertical(subject.bottom) && isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    return isContained;
  };
};
var vertical = {
  direction: "vertical",
  line: "y",
  crossAxisLine: "x",
  start: "top",
  end: "bottom",
  size: "height",
  crossAxisStart: "left",
  crossAxisEnd: "right",
  crossAxisSize: "width"
};
var horizontal = {
  direction: "horizontal",
  line: "x",
  crossAxisLine: "y",
  start: "left",
  end: "right",
  size: "width",
  crossAxisStart: "top",
  crossAxisEnd: "bottom",
  crossAxisSize: "height"
};
var isTotallyVisibleThroughFrameOnAxis = function(axis) {
  return function(frame) {
    var isWithinVertical = isWithin(frame.top, frame.bottom);
    var isWithinHorizontal = isWithin(frame.left, frame.right);
    return function(subject) {
      if (axis === vertical) {
        return isWithinVertical(subject.top) && isWithinVertical(subject.bottom);
      }
      return isWithinHorizontal(subject.left) && isWithinHorizontal(subject.right);
    };
  };
};
var getDroppableDisplaced = function getDroppableDisplaced2(target, destination) {
  var displacement = destination.frame ? destination.frame.scroll.diff.displacement : origin;
  return offsetByPosition(target, displacement);
};
var isVisibleInDroppable = function isVisibleInDroppable2(target, destination, isVisibleThroughFrameFn) {
  if (!destination.subject.active) {
    return false;
  }
  return isVisibleThroughFrameFn(destination.subject.active)(target);
};
var isVisibleInViewport = function isVisibleInViewport2(target, viewport, isVisibleThroughFrameFn) {
  return isVisibleThroughFrameFn(viewport)(target);
};
var isVisible = function isVisible2(_ref) {
  var toBeDisplaced = _ref.target, destination = _ref.destination, viewport = _ref.viewport, withDroppableDisplacement2 = _ref.withDroppableDisplacement, isVisibleThroughFrameFn = _ref.isVisibleThroughFrameFn;
  var displacedTarget = withDroppableDisplacement2 ? getDroppableDisplaced(toBeDisplaced, destination) : toBeDisplaced;
  return isVisibleInDroppable(displacedTarget, destination, isVisibleThroughFrameFn) && isVisibleInViewport(displacedTarget, viewport, isVisibleThroughFrameFn);
};
var isPartiallyVisible = function isPartiallyVisible2(args) {
  return isVisible(_extends({}, args, {
    isVisibleThroughFrameFn: isPartiallyVisibleThroughFrame
  }));
};
var isTotallyVisible = function isTotallyVisible2(args) {
  return isVisible(_extends({}, args, {
    isVisibleThroughFrameFn: isTotallyVisibleThroughFrame
  }));
};
var isTotallyVisibleOnAxis = function isTotallyVisibleOnAxis2(args) {
  return isVisible(_extends({}, args, {
    isVisibleThroughFrameFn: isTotallyVisibleThroughFrameOnAxis(args.destination.axis)
  }));
};
var getShouldAnimate = function getShouldAnimate2(id, last2, forceShouldAnimate) {
  if (typeof forceShouldAnimate === "boolean") {
    return forceShouldAnimate;
  }
  if (!last2) {
    return true;
  }
  var invisible = last2.invisible, visible = last2.visible;
  if (invisible[id]) {
    return false;
  }
  var previous = visible[id];
  return previous ? previous.shouldAnimate : true;
};
function getTarget(draggable2, displacedBy) {
  var marginBox = draggable2.page.marginBox;
  var expandBy = {
    top: displacedBy.point.y,
    right: 0,
    bottom: 0,
    left: displacedBy.point.x
  };
  return getRect(expand(marginBox, expandBy));
}
function getDisplacementGroups(_ref) {
  var afterDragging = _ref.afterDragging, destination = _ref.destination, displacedBy = _ref.displacedBy, viewport = _ref.viewport, forceShouldAnimate = _ref.forceShouldAnimate, last2 = _ref.last;
  return afterDragging.reduce(function process2(groups, draggable2) {
    var target = getTarget(draggable2, displacedBy);
    var id = draggable2.descriptor.id;
    groups.all.push(id);
    var isVisible3 = isPartiallyVisible({
      target,
      destination,
      viewport,
      withDroppableDisplacement: true
    });
    if (!isVisible3) {
      groups.invisible[draggable2.descriptor.id] = true;
      return groups;
    }
    var shouldAnimate = getShouldAnimate(id, last2, forceShouldAnimate);
    var displacement = {
      draggableId: id,
      shouldAnimate
    };
    groups.visible[id] = displacement;
    return groups;
  }, {
    all: [],
    visible: {},
    invisible: {}
  });
}
function getIndexOfLastItem(draggables, options) {
  if (!draggables.length) {
    return 0;
  }
  var indexOfLastItem = draggables[draggables.length - 1].descriptor.index;
  return options.inHomeList ? indexOfLastItem : indexOfLastItem + 1;
}
function goAtEnd(_ref) {
  var insideDestination = _ref.insideDestination, inHomeList = _ref.inHomeList, displacedBy = _ref.displacedBy, destination = _ref.destination;
  var newIndex = getIndexOfLastItem(insideDestination, {
    inHomeList
  });
  return {
    displaced: emptyGroups,
    displacedBy,
    at: {
      type: "REORDER",
      destination: {
        droppableId: destination.descriptor.id,
        index: newIndex
      }
    }
  };
}
function calculateReorderImpact(_ref2) {
  var draggable2 = _ref2.draggable, insideDestination = _ref2.insideDestination, destination = _ref2.destination, viewport = _ref2.viewport, displacedBy = _ref2.displacedBy, last2 = _ref2.last, index2 = _ref2.index, forceShouldAnimate = _ref2.forceShouldAnimate;
  var inHomeList = isHomeOf(draggable2, destination);
  if (index2 == null) {
    return goAtEnd({
      insideDestination,
      inHomeList,
      displacedBy,
      destination
    });
  }
  var match5 = find(insideDestination, function(item) {
    return item.descriptor.index === index2;
  });
  if (!match5) {
    return goAtEnd({
      insideDestination,
      inHomeList,
      displacedBy,
      destination
    });
  }
  var withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  var sliceFrom = insideDestination.indexOf(match5);
  var impacted = withoutDragging.slice(sliceFrom);
  var displaced = getDisplacementGroups({
    afterDragging: impacted,
    destination,
    displacedBy,
    last: last2,
    viewport: viewport.frame,
    forceShouldAnimate
  });
  return {
    displaced,
    displacedBy,
    at: {
      type: "REORDER",
      destination: {
        droppableId: destination.descriptor.id,
        index: index2
      }
    }
  };
}
function didStartAfterCritical(draggableId, afterCritical) {
  return Boolean(afterCritical.effected[draggableId]);
}
var fromCombine = function(_ref) {
  var isMovingForward = _ref.isMovingForward, destination = _ref.destination, draggables = _ref.draggables, combine2 = _ref.combine, afterCritical = _ref.afterCritical;
  if (!destination.isCombineEnabled) {
    return null;
  }
  var combineId = combine2.draggableId;
  var combineWith = draggables[combineId];
  var combineWithIndex = combineWith.descriptor.index;
  var didCombineWithStartAfterCritical = didStartAfterCritical(combineId, afterCritical);
  if (didCombineWithStartAfterCritical) {
    if (isMovingForward) {
      return combineWithIndex;
    }
    return combineWithIndex - 1;
  }
  if (isMovingForward) {
    return combineWithIndex + 1;
  }
  return combineWithIndex;
};
var fromReorder = function(_ref) {
  var isMovingForward = _ref.isMovingForward, isInHomeList = _ref.isInHomeList, insideDestination = _ref.insideDestination, location = _ref.location;
  if (!insideDestination.length) {
    return null;
  }
  var currentIndex = location.index;
  var proposedIndex = isMovingForward ? currentIndex + 1 : currentIndex - 1;
  var firstIndex = insideDestination[0].descriptor.index;
  var lastIndex = insideDestination[insideDestination.length - 1].descriptor.index;
  var upperBound = isInHomeList ? lastIndex : lastIndex + 1;
  if (proposedIndex < firstIndex) {
    return null;
  }
  if (proposedIndex > upperBound) {
    return null;
  }
  return proposedIndex;
};
var moveToNextIndex = function(_ref) {
  var isMovingForward = _ref.isMovingForward, isInHomeList = _ref.isInHomeList, draggable2 = _ref.draggable, draggables = _ref.draggables, destination = _ref.destination, insideDestination = _ref.insideDestination, previousImpact = _ref.previousImpact, viewport = _ref.viewport, afterCritical = _ref.afterCritical;
  var wasAt = previousImpact.at;
  !wasAt ? true ? invariant2(false, "Cannot move in direction without previous impact location") : invariant2(false) : void 0;
  if (wasAt.type === "REORDER") {
    var _newIndex = fromReorder({
      isMovingForward,
      isInHomeList,
      location: wasAt.destination,
      insideDestination
    });
    if (_newIndex == null) {
      return null;
    }
    return calculateReorderImpact({
      draggable: draggable2,
      insideDestination,
      destination,
      viewport,
      last: previousImpact.displaced,
      displacedBy: previousImpact.displacedBy,
      index: _newIndex
    });
  }
  var newIndex = fromCombine({
    isMovingForward,
    destination,
    displaced: previousImpact.displaced,
    draggables,
    combine: wasAt.combine,
    afterCritical
  });
  if (newIndex == null) {
    return null;
  }
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport,
    last: previousImpact.displaced,
    displacedBy: previousImpact.displacedBy,
    index: newIndex
  });
};
var getCombinedItemDisplacement = function(_ref) {
  var displaced = _ref.displaced, afterCritical = _ref.afterCritical, combineWith = _ref.combineWith, displacedBy = _ref.displacedBy;
  var isDisplaced = Boolean(displaced.visible[combineWith] || displaced.invisible[combineWith]);
  if (didStartAfterCritical(combineWith, afterCritical)) {
    return isDisplaced ? origin : negate(displacedBy.point);
  }
  return isDisplaced ? displacedBy.point : origin;
};
var whenCombining = function(_ref) {
  var afterCritical = _ref.afterCritical, impact = _ref.impact, draggables = _ref.draggables;
  var combine2 = tryGetCombine(impact);
  !combine2 ? true ? invariant2(false) : invariant2(false) : void 0;
  var combineWith = combine2.draggableId;
  var center = draggables[combineWith].page.borderBox.center;
  var displaceBy = getCombinedItemDisplacement({
    displaced: impact.displaced,
    afterCritical,
    combineWith,
    displacedBy: impact.displacedBy
  });
  return add(center, displaceBy);
};
var distanceFromStartToBorderBoxCenter = function distanceFromStartToBorderBoxCenter2(axis, box) {
  return box.margin[axis.start] + box.borderBox[axis.size] / 2;
};
var distanceFromEndToBorderBoxCenter = function distanceFromEndToBorderBoxCenter2(axis, box) {
  return box.margin[axis.end] + box.borderBox[axis.size] / 2;
};
var getCrossAxisBorderBoxCenter = function getCrossAxisBorderBoxCenter2(axis, target, isMoving) {
  return target[axis.crossAxisStart] + isMoving.margin[axis.crossAxisStart] + isMoving.borderBox[axis.crossAxisSize] / 2;
};
var goAfter = function goAfter2(_ref) {
  var axis = _ref.axis, moveRelativeTo = _ref.moveRelativeTo, isMoving = _ref.isMoving;
  return patch(axis.line, moveRelativeTo.marginBox[axis.end] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
};
var goBefore = function goBefore2(_ref2) {
  var axis = _ref2.axis, moveRelativeTo = _ref2.moveRelativeTo, isMoving = _ref2.isMoving;
  return patch(axis.line, moveRelativeTo.marginBox[axis.start] - distanceFromEndToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveRelativeTo.marginBox, isMoving));
};
var goIntoStart = function goIntoStart2(_ref3) {
  var axis = _ref3.axis, moveInto = _ref3.moveInto, isMoving = _ref3.isMoving;
  return patch(axis.line, moveInto.contentBox[axis.start] + distanceFromStartToBorderBoxCenter(axis, isMoving), getCrossAxisBorderBoxCenter(axis, moveInto.contentBox, isMoving));
};
var whenReordering = function(_ref) {
  var impact = _ref.impact, draggable2 = _ref.draggable, draggables = _ref.draggables, droppable2 = _ref.droppable, afterCritical = _ref.afterCritical;
  var insideDestination = getDraggablesInsideDroppable(droppable2.descriptor.id, draggables);
  var draggablePage = draggable2.page;
  var axis = droppable2.axis;
  if (!insideDestination.length) {
    return goIntoStart({
      axis,
      moveInto: droppable2.page,
      isMoving: draggablePage
    });
  }
  var displaced = impact.displaced, displacedBy = impact.displacedBy;
  var closestAfter = displaced.all[0];
  if (closestAfter) {
    var closest3 = draggables[closestAfter];
    if (didStartAfterCritical(closestAfter, afterCritical)) {
      return goBefore({
        axis,
        moveRelativeTo: closest3.page,
        isMoving: draggablePage
      });
    }
    var withDisplacement = offset(closest3.page, displacedBy.point);
    return goBefore({
      axis,
      moveRelativeTo: withDisplacement,
      isMoving: draggablePage
    });
  }
  var last2 = insideDestination[insideDestination.length - 1];
  if (last2.descriptor.id === draggable2.descriptor.id) {
    return draggablePage.borderBox.center;
  }
  if (didStartAfterCritical(last2.descriptor.id, afterCritical)) {
    var page = offset(last2.page, negate(afterCritical.displacedBy.point));
    return goAfter({
      axis,
      moveRelativeTo: page,
      isMoving: draggablePage
    });
  }
  return goAfter({
    axis,
    moveRelativeTo: last2.page,
    isMoving: draggablePage
  });
};
var withDroppableDisplacement = function(droppable2, point) {
  var frame = droppable2.frame;
  if (!frame) {
    return point;
  }
  return add(point, frame.scroll.diff.displacement);
};
var getResultWithoutDroppableDisplacement = function getResultWithoutDroppableDisplacement2(_ref) {
  var impact = _ref.impact, draggable2 = _ref.draggable, droppable2 = _ref.droppable, draggables = _ref.draggables, afterCritical = _ref.afterCritical;
  var original = draggable2.page.borderBox.center;
  var at = impact.at;
  if (!droppable2) {
    return original;
  }
  if (!at) {
    return original;
  }
  if (at.type === "REORDER") {
    return whenReordering({
      impact,
      draggable: draggable2,
      draggables,
      droppable: droppable2,
      afterCritical
    });
  }
  return whenCombining({
    impact,
    draggables,
    afterCritical
  });
};
var getPageBorderBoxCenterFromImpact = function(args) {
  var withoutDisplacement = getResultWithoutDroppableDisplacement(args);
  var droppable2 = args.droppable;
  var withDisplacement = droppable2 ? withDroppableDisplacement(droppable2, withoutDisplacement) : withoutDisplacement;
  return withDisplacement;
};
var scrollViewport = function(viewport, newScroll) {
  var diff3 = subtract(newScroll, viewport.scroll.initial);
  var displacement = negate(diff3);
  var frame = getRect({
    top: newScroll.y,
    bottom: newScroll.y + viewport.frame.height,
    left: newScroll.x,
    right: newScroll.x + viewport.frame.width
  });
  var updated = {
    frame,
    scroll: {
      initial: viewport.scroll.initial,
      max: viewport.scroll.max,
      current: newScroll,
      diff: {
        value: diff3,
        displacement
      }
    }
  };
  return updated;
};
function getDraggables(ids, draggables) {
  return ids.map(function(id) {
    return draggables[id];
  });
}
function tryGetVisible(id, groups) {
  for (var i15 = 0; i15 < groups.length; i15++) {
    var displacement = groups[i15].visible[id];
    if (displacement) {
      return displacement;
    }
  }
  return null;
}
var speculativelyIncrease = function(_ref) {
  var impact = _ref.impact, viewport = _ref.viewport, destination = _ref.destination, draggables = _ref.draggables, maxScrollChange = _ref.maxScrollChange;
  var scrolledViewport = scrollViewport(viewport, add(viewport.scroll.current, maxScrollChange));
  var scrolledDroppable = destination.frame ? scrollDroppable(destination, add(destination.frame.scroll.current, maxScrollChange)) : destination;
  var last2 = impact.displaced;
  var withViewportScroll = getDisplacementGroups({
    afterDragging: getDraggables(last2.all, draggables),
    destination,
    displacedBy: impact.displacedBy,
    viewport: scrolledViewport.frame,
    last: last2,
    forceShouldAnimate: false
  });
  var withDroppableScroll2 = getDisplacementGroups({
    afterDragging: getDraggables(last2.all, draggables),
    destination: scrolledDroppable,
    displacedBy: impact.displacedBy,
    viewport: viewport.frame,
    last: last2,
    forceShouldAnimate: false
  });
  var invisible = {};
  var visible = {};
  var groups = [last2, withViewportScroll, withDroppableScroll2];
  last2.all.forEach(function(id) {
    var displacement = tryGetVisible(id, groups);
    if (displacement) {
      visible[id] = displacement;
      return;
    }
    invisible[id] = true;
  });
  var newImpact = _extends({}, impact, {
    displaced: {
      all: last2.all,
      invisible,
      visible
    }
  });
  return newImpact;
};
var withViewportDisplacement = function(viewport, point) {
  return add(viewport.scroll.diff.displacement, point);
};
var getClientFromPageBorderBoxCenter = function(_ref) {
  var pageBorderBoxCenter = _ref.pageBorderBoxCenter, draggable2 = _ref.draggable, viewport = _ref.viewport;
  var withoutPageScrollChange = withViewportDisplacement(viewport, pageBorderBoxCenter);
  var offset5 = subtract(withoutPageScrollChange, draggable2.page.borderBox.center);
  return add(draggable2.client.borderBox.center, offset5);
};
var isTotallyVisibleInNewLocation = function(_ref) {
  var draggable2 = _ref.draggable, destination = _ref.destination, newPageBorderBoxCenter = _ref.newPageBorderBoxCenter, viewport = _ref.viewport, withDroppableDisplacement2 = _ref.withDroppableDisplacement, _ref$onlyOnMainAxis = _ref.onlyOnMainAxis, onlyOnMainAxis = _ref$onlyOnMainAxis === void 0 ? false : _ref$onlyOnMainAxis;
  var changeNeeded = subtract(newPageBorderBoxCenter, draggable2.page.borderBox.center);
  var shifted = offsetByPosition(draggable2.page.borderBox, changeNeeded);
  var args = {
    target: shifted,
    destination,
    withDroppableDisplacement: withDroppableDisplacement2,
    viewport
  };
  return onlyOnMainAxis ? isTotallyVisibleOnAxis(args) : isTotallyVisible(args);
};
var moveToNextPlace = function(_ref) {
  var isMovingForward = _ref.isMovingForward, draggable2 = _ref.draggable, destination = _ref.destination, draggables = _ref.draggables, previousImpact = _ref.previousImpact, viewport = _ref.viewport, previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter, previousClientSelection = _ref.previousClientSelection, afterCritical = _ref.afterCritical;
  if (!destination.isEnabled) {
    return null;
  }
  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  var isInHomeList = isHomeOf(draggable2, destination);
  var impact = moveToNextCombine({
    isMovingForward,
    draggable: draggable2,
    destination,
    insideDestination,
    previousImpact
  }) || moveToNextIndex({
    isMovingForward,
    isInHomeList,
    draggable: draggable2,
    draggables,
    destination,
    insideDestination,
    previousImpact,
    viewport,
    afterCritical
  });
  if (!impact) {
    return null;
  }
  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    afterCritical
  });
  var isVisibleInNewLocation = isTotallyVisibleInNewLocation({
    draggable: draggable2,
    destination,
    newPageBorderBoxCenter: pageBorderBoxCenter,
    viewport: viewport.frame,
    withDroppableDisplacement: false,
    onlyOnMainAxis: true
  });
  if (isVisibleInNewLocation) {
    var clientSelection = getClientFromPageBorderBoxCenter({
      pageBorderBoxCenter,
      draggable: draggable2,
      viewport
    });
    return {
      clientSelection,
      impact,
      scrollJumpRequest: null
    };
  }
  var distance3 = subtract(pageBorderBoxCenter, previousPageBorderBoxCenter);
  var cautious = speculativelyIncrease({
    impact,
    viewport,
    destination,
    draggables,
    maxScrollChange: distance3
  });
  return {
    clientSelection: previousClientSelection,
    impact: cautious,
    scrollJumpRequest: distance3
  };
};
var getKnownActive = function getKnownActive2(droppable2) {
  var rect = droppable2.subject.active;
  !rect ? true ? invariant2(false, "Cannot get clipped area from droppable") : invariant2(false) : void 0;
  return rect;
};
var getBestCrossAxisDroppable = function(_ref) {
  var isMovingForward = _ref.isMovingForward, pageBorderBoxCenter = _ref.pageBorderBoxCenter, source = _ref.source, droppables = _ref.droppables, viewport = _ref.viewport;
  var active = source.subject.active;
  if (!active) {
    return null;
  }
  var axis = source.axis;
  var isBetweenSourceClipped = isWithin(active[axis.start], active[axis.end]);
  var candidates = toDroppableList(droppables).filter(function(droppable2) {
    return droppable2 !== source;
  }).filter(function(droppable2) {
    return droppable2.isEnabled;
  }).filter(function(droppable2) {
    return Boolean(droppable2.subject.active);
  }).filter(function(droppable2) {
    return isPartiallyVisibleThroughFrame(viewport.frame)(getKnownActive(droppable2));
  }).filter(function(droppable2) {
    var activeOfTarget = getKnownActive(droppable2);
    if (isMovingForward) {
      return active[axis.crossAxisEnd] < activeOfTarget[axis.crossAxisEnd];
    }
    return activeOfTarget[axis.crossAxisStart] < active[axis.crossAxisStart];
  }).filter(function(droppable2) {
    var activeOfTarget = getKnownActive(droppable2);
    var isBetweenDestinationClipped = isWithin(activeOfTarget[axis.start], activeOfTarget[axis.end]);
    return isBetweenSourceClipped(activeOfTarget[axis.start]) || isBetweenSourceClipped(activeOfTarget[axis.end]) || isBetweenDestinationClipped(active[axis.start]) || isBetweenDestinationClipped(active[axis.end]);
  }).sort(function(a13, b6) {
    var first = getKnownActive(a13)[axis.crossAxisStart];
    var second = getKnownActive(b6)[axis.crossAxisStart];
    if (isMovingForward) {
      return first - second;
    }
    return second - first;
  }).filter(function(droppable2, index2, array2) {
    return getKnownActive(droppable2)[axis.crossAxisStart] === getKnownActive(array2[0])[axis.crossAxisStart];
  });
  if (!candidates.length) {
    return null;
  }
  if (candidates.length === 1) {
    return candidates[0];
  }
  var contains2 = candidates.filter(function(droppable2) {
    var isWithinDroppable = isWithin(getKnownActive(droppable2)[axis.start], getKnownActive(droppable2)[axis.end]);
    return isWithinDroppable(pageBorderBoxCenter[axis.line]);
  });
  if (contains2.length === 1) {
    return contains2[0];
  }
  if (contains2.length > 1) {
    return contains2.sort(function(a13, b6) {
      return getKnownActive(a13)[axis.start] - getKnownActive(b6)[axis.start];
    })[0];
  }
  return candidates.sort(function(a13, b6) {
    var first = closest(pageBorderBoxCenter, getCorners(getKnownActive(a13)));
    var second = closest(pageBorderBoxCenter, getCorners(getKnownActive(b6)));
    if (first !== second) {
      return first - second;
    }
    return getKnownActive(a13)[axis.start] - getKnownActive(b6)[axis.start];
  })[0];
};
var getCurrentPageBorderBoxCenter = function getCurrentPageBorderBoxCenter2(draggable2, afterCritical) {
  var original = draggable2.page.borderBox.center;
  return didStartAfterCritical(draggable2.descriptor.id, afterCritical) ? subtract(original, afterCritical.displacedBy.point) : original;
};
var getCurrentPageBorderBox = function getCurrentPageBorderBox2(draggable2, afterCritical) {
  var original = draggable2.page.borderBox;
  return didStartAfterCritical(draggable2.descriptor.id, afterCritical) ? offsetByPosition(original, negate(afterCritical.displacedBy.point)) : original;
};
var getClosestDraggable = function(_ref) {
  var pageBorderBoxCenter = _ref.pageBorderBoxCenter, viewport = _ref.viewport, destination = _ref.destination, insideDestination = _ref.insideDestination, afterCritical = _ref.afterCritical;
  var sorted = insideDestination.filter(function(draggable2) {
    return isTotallyVisible({
      target: getCurrentPageBorderBox(draggable2, afterCritical),
      destination,
      viewport: viewport.frame,
      withDroppableDisplacement: true
    });
  }).sort(function(a13, b6) {
    var distanceToA = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(a13, afterCritical)));
    var distanceToB = distance(pageBorderBoxCenter, withDroppableDisplacement(destination, getCurrentPageBorderBoxCenter(b6, afterCritical)));
    if (distanceToA < distanceToB) {
      return -1;
    }
    if (distanceToB < distanceToA) {
      return 1;
    }
    return a13.descriptor.index - b6.descriptor.index;
  });
  return sorted[0] || null;
};
var getDisplacedBy = memoize_one_esm_default(function getDisplacedBy2(axis, displaceBy) {
  var displacement = displaceBy[axis.line];
  return {
    value: displacement,
    point: patch(axis.line, displacement)
  };
});
var getRequiredGrowthForPlaceholder = function getRequiredGrowthForPlaceholder2(droppable2, placeholderSize, draggables) {
  var axis = droppable2.axis;
  if (droppable2.descriptor.mode === "virtual") {
    return patch(axis.line, placeholderSize[axis.line]);
  }
  var availableSpace = droppable2.subject.page.contentBox[axis.size];
  var insideDroppable = getDraggablesInsideDroppable(droppable2.descriptor.id, draggables);
  var spaceUsed = insideDroppable.reduce(function(sum, dimension) {
    return sum + dimension.client.marginBox[axis.size];
  }, 0);
  var requiredSpace = spaceUsed + placeholderSize[axis.line];
  var needsToGrowBy = requiredSpace - availableSpace;
  if (needsToGrowBy <= 0) {
    return null;
  }
  return patch(axis.line, needsToGrowBy);
};
var withMaxScroll = function withMaxScroll2(frame, max4) {
  return _extends({}, frame, {
    scroll: _extends({}, frame.scroll, {
      max: max4
    })
  });
};
var addPlaceholder = function addPlaceholder2(droppable2, draggable2, draggables) {
  var frame = droppable2.frame;
  !!isHomeOf(draggable2, droppable2) ? true ? invariant2(false, "Should not add placeholder space to home list") : invariant2(false) : void 0;
  !!droppable2.subject.withPlaceholder ? true ? invariant2(false, "Cannot add placeholder size to a subject when it already has one") : invariant2(false) : void 0;
  var placeholderSize = getDisplacedBy(droppable2.axis, draggable2.displaceBy).point;
  var requiredGrowth = getRequiredGrowthForPlaceholder(droppable2, placeholderSize, draggables);
  var added = {
    placeholderSize,
    increasedBy: requiredGrowth,
    oldFrameMaxScroll: droppable2.frame ? droppable2.frame.scroll.max : null
  };
  if (!frame) {
    var _subject = getSubject({
      page: droppable2.subject.page,
      withPlaceholder: added,
      axis: droppable2.axis,
      frame: droppable2.frame
    });
    return _extends({}, droppable2, {
      subject: _subject
    });
  }
  var maxScroll = requiredGrowth ? add(frame.scroll.max, requiredGrowth) : frame.scroll.max;
  var newFrame = withMaxScroll(frame, maxScroll);
  var subject = getSubject({
    page: droppable2.subject.page,
    withPlaceholder: added,
    axis: droppable2.axis,
    frame: newFrame
  });
  return _extends({}, droppable2, {
    subject,
    frame: newFrame
  });
};
var removePlaceholder = function removePlaceholder2(droppable2) {
  var added = droppable2.subject.withPlaceholder;
  !added ? true ? invariant2(false, "Cannot remove placeholder form subject when there was none") : invariant2(false) : void 0;
  var frame = droppable2.frame;
  if (!frame) {
    var _subject2 = getSubject({
      page: droppable2.subject.page,
      axis: droppable2.axis,
      frame: null,
      withPlaceholder: null
    });
    return _extends({}, droppable2, {
      subject: _subject2
    });
  }
  var oldMaxScroll = added.oldFrameMaxScroll;
  !oldMaxScroll ? true ? invariant2(false, "Expected droppable with frame to have old max frame scroll when removing placeholder") : invariant2(false) : void 0;
  var newFrame = withMaxScroll(frame, oldMaxScroll);
  var subject = getSubject({
    page: droppable2.subject.page,
    axis: droppable2.axis,
    frame: newFrame,
    withPlaceholder: null
  });
  return _extends({}, droppable2, {
    subject,
    frame: newFrame
  });
};
var moveToNewDroppable = function(_ref) {
  var previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter, moveRelativeTo = _ref.moveRelativeTo, insideDestination = _ref.insideDestination, draggable2 = _ref.draggable, draggables = _ref.draggables, destination = _ref.destination, viewport = _ref.viewport, afterCritical = _ref.afterCritical;
  if (!moveRelativeTo) {
    if (insideDestination.length) {
      return null;
    }
    var proposed = {
      displaced: emptyGroups,
      displacedBy: noDisplacedBy,
      at: {
        type: "REORDER",
        destination: {
          droppableId: destination.descriptor.id,
          index: 0
        }
      }
    };
    var proposedPageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
      impact: proposed,
      draggable: draggable2,
      droppable: destination,
      draggables,
      afterCritical
    });
    var withPlaceholder = isHomeOf(draggable2, destination) ? destination : addPlaceholder(destination, draggable2, draggables);
    var isVisibleInNewLocation = isTotallyVisibleInNewLocation({
      draggable: draggable2,
      destination: withPlaceholder,
      newPageBorderBoxCenter: proposedPageBorderBoxCenter,
      viewport: viewport.frame,
      withDroppableDisplacement: false,
      onlyOnMainAxis: true
    });
    return isVisibleInNewLocation ? proposed : null;
  }
  var isGoingBeforeTarget = Boolean(previousPageBorderBoxCenter[destination.axis.line] <= moveRelativeTo.page.borderBox.center[destination.axis.line]);
  var proposedIndex = function() {
    var relativeTo = moveRelativeTo.descriptor.index;
    if (moveRelativeTo.descriptor.id === draggable2.descriptor.id) {
      return relativeTo;
    }
    if (isGoingBeforeTarget) {
      return relativeTo;
    }
    return relativeTo + 1;
  }();
  var displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport,
    displacedBy,
    last: emptyGroups,
    index: proposedIndex
  });
};
var moveCrossAxis = function(_ref) {
  var isMovingForward = _ref.isMovingForward, previousPageBorderBoxCenter = _ref.previousPageBorderBoxCenter, draggable2 = _ref.draggable, isOver = _ref.isOver, draggables = _ref.draggables, droppables = _ref.droppables, viewport = _ref.viewport, afterCritical = _ref.afterCritical;
  var destination = getBestCrossAxisDroppable({
    isMovingForward,
    pageBorderBoxCenter: previousPageBorderBoxCenter,
    source: isOver,
    droppables,
    viewport
  });
  if (!destination) {
    return null;
  }
  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  var moveRelativeTo = getClosestDraggable({
    pageBorderBoxCenter: previousPageBorderBoxCenter,
    viewport,
    destination,
    insideDestination,
    afterCritical
  });
  var impact = moveToNewDroppable({
    previousPageBorderBoxCenter,
    destination,
    draggable: draggable2,
    draggables,
    moveRelativeTo,
    insideDestination,
    viewport,
    afterCritical
  });
  if (!impact) {
    return null;
  }
  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    afterCritical
  });
  var clientSelection = getClientFromPageBorderBoxCenter({
    pageBorderBoxCenter,
    draggable: draggable2,
    viewport
  });
  return {
    clientSelection,
    impact,
    scrollJumpRequest: null
  };
};
var whatIsDraggedOver = function(impact) {
  var at = impact.at;
  if (!at) {
    return null;
  }
  if (at.type === "REORDER") {
    return at.destination.droppableId;
  }
  return at.combine.droppableId;
};
var getDroppableOver = function getDroppableOver2(impact, droppables) {
  var id = whatIsDraggedOver(impact);
  return id ? droppables[id] : null;
};
var moveInDirection = function(_ref) {
  var state = _ref.state, type = _ref.type;
  var isActuallyOver = getDroppableOver(state.impact, state.dimensions.droppables);
  var isMainAxisMovementAllowed = Boolean(isActuallyOver);
  var home2 = state.dimensions.droppables[state.critical.droppable.id];
  var isOver = isActuallyOver || home2;
  var direction = isOver.axis.direction;
  var isMovingOnMainAxis = direction === "vertical" && (type === "MOVE_UP" || type === "MOVE_DOWN") || direction === "horizontal" && (type === "MOVE_LEFT" || type === "MOVE_RIGHT");
  if (isMovingOnMainAxis && !isMainAxisMovementAllowed) {
    return null;
  }
  var isMovingForward = type === "MOVE_DOWN" || type === "MOVE_RIGHT";
  var draggable2 = state.dimensions.draggables[state.critical.draggable.id];
  var previousPageBorderBoxCenter = state.current.page.borderBoxCenter;
  var _state$dimensions = state.dimensions, draggables = _state$dimensions.draggables, droppables = _state$dimensions.droppables;
  return isMovingOnMainAxis ? moveToNextPlace({
    isMovingForward,
    previousPageBorderBoxCenter,
    draggable: draggable2,
    destination: isOver,
    draggables,
    viewport: state.viewport,
    previousClientSelection: state.current.client.selection,
    previousImpact: state.impact,
    afterCritical: state.afterCritical
  }) : moveCrossAxis({
    isMovingForward,
    previousPageBorderBoxCenter,
    draggable: draggable2,
    isOver,
    draggables,
    droppables,
    viewport: state.viewport,
    afterCritical: state.afterCritical
  });
};
function isMovementAllowed(state) {
  return state.phase === "DRAGGING" || state.phase === "COLLECTING";
}
function isPositionInFrame(frame) {
  var isWithinVertical = isWithin(frame.top, frame.bottom);
  var isWithinHorizontal = isWithin(frame.left, frame.right);
  return function run(point) {
    return isWithinVertical(point.y) && isWithinHorizontal(point.x);
  };
}
function getHasOverlap(first, second) {
  return first.left < second.right && first.right > second.left && first.top < second.bottom && first.bottom > second.top;
}
function getFurthestAway(_ref) {
  var pageBorderBox = _ref.pageBorderBox, draggable2 = _ref.draggable, candidates = _ref.candidates;
  var startCenter = draggable2.page.borderBox.center;
  var sorted = candidates.map(function(candidate) {
    var axis = candidate.axis;
    var target = patch(candidate.axis.line, pageBorderBox.center[axis.line], candidate.page.borderBox.center[axis.crossAxisLine]);
    return {
      id: candidate.descriptor.id,
      distance: distance(startCenter, target)
    };
  }).sort(function(a13, b6) {
    return b6.distance - a13.distance;
  });
  return sorted[0] ? sorted[0].id : null;
}
function getDroppableOver$1(_ref2) {
  var pageBorderBox = _ref2.pageBorderBox, draggable2 = _ref2.draggable, droppables = _ref2.droppables;
  var candidates = toDroppableList(droppables).filter(function(item) {
    if (!item.isEnabled) {
      return false;
    }
    var active = item.subject.active;
    if (!active) {
      return false;
    }
    if (!getHasOverlap(pageBorderBox, active)) {
      return false;
    }
    if (isPositionInFrame(active)(pageBorderBox.center)) {
      return true;
    }
    var axis = item.axis;
    var childCenter = active.center[axis.crossAxisLine];
    var crossAxisStart = pageBorderBox[axis.crossAxisStart];
    var crossAxisEnd = pageBorderBox[axis.crossAxisEnd];
    var isContained = isWithin(active[axis.crossAxisStart], active[axis.crossAxisEnd]);
    var isStartContained = isContained(crossAxisStart);
    var isEndContained = isContained(crossAxisEnd);
    if (!isStartContained && !isEndContained) {
      return true;
    }
    if (isStartContained) {
      return crossAxisStart < childCenter;
    }
    return crossAxisEnd > childCenter;
  });
  if (!candidates.length) {
    return null;
  }
  if (candidates.length === 1) {
    return candidates[0].descriptor.id;
  }
  return getFurthestAway({
    pageBorderBox,
    draggable: draggable2,
    candidates
  });
}
var offsetRectByPosition = function offsetRectByPosition2(rect, point) {
  return getRect(offsetByPosition(rect, point));
};
var withDroppableScroll = function(droppable2, area) {
  var frame = droppable2.frame;
  if (!frame) {
    return area;
  }
  return offsetRectByPosition(area, frame.scroll.diff.value);
};
function getIsDisplaced(_ref) {
  var displaced = _ref.displaced, id = _ref.id;
  return Boolean(displaced.visible[id] || displaced.invisible[id]);
}
function atIndex(_ref) {
  var draggable2 = _ref.draggable, closest3 = _ref.closest, inHomeList = _ref.inHomeList;
  if (!closest3) {
    return null;
  }
  if (!inHomeList) {
    return closest3.descriptor.index;
  }
  if (closest3.descriptor.index > draggable2.descriptor.index) {
    return closest3.descriptor.index - 1;
  }
  return closest3.descriptor.index;
}
var getReorderImpact = function(_ref2) {
  var targetRect = _ref2.pageBorderBoxWithDroppableScroll, draggable2 = _ref2.draggable, destination = _ref2.destination, insideDestination = _ref2.insideDestination, last2 = _ref2.last, viewport = _ref2.viewport, afterCritical = _ref2.afterCritical;
  var axis = destination.axis;
  var displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  var displacement = displacedBy.value;
  var targetStart = targetRect[axis.start];
  var targetEnd = targetRect[axis.end];
  var withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  var closest3 = find(withoutDragging, function(child) {
    var id = child.descriptor.id;
    var childCenter = child.page.borderBox.center[axis.line];
    var didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);
    var isDisplaced = getIsDisplaced({
      displaced: last2,
      id
    });
    if (didStartAfterCritical$1) {
      if (isDisplaced) {
        return targetEnd <= childCenter;
      }
      return targetStart < childCenter - displacement;
    }
    if (isDisplaced) {
      return targetEnd <= childCenter + displacement;
    }
    return targetStart < childCenter;
  });
  var newIndex = atIndex({
    draggable: draggable2,
    closest: closest3,
    inHomeList: isHomeOf(draggable2, destination)
  });
  return calculateReorderImpact({
    draggable: draggable2,
    insideDestination,
    destination,
    viewport,
    last: last2,
    displacedBy,
    index: newIndex
  });
};
var combineThresholdDivisor = 4;
var getCombineImpact = function(_ref) {
  var draggable2 = _ref.draggable, targetRect = _ref.pageBorderBoxWithDroppableScroll, previousImpact = _ref.previousImpact, destination = _ref.destination, insideDestination = _ref.insideDestination, afterCritical = _ref.afterCritical;
  if (!destination.isCombineEnabled) {
    return null;
  }
  var axis = destination.axis;
  var displacedBy = getDisplacedBy(destination.axis, draggable2.displaceBy);
  var displacement = displacedBy.value;
  var targetStart = targetRect[axis.start];
  var targetEnd = targetRect[axis.end];
  var withoutDragging = removeDraggableFromList(draggable2, insideDestination);
  var combineWith = find(withoutDragging, function(child) {
    var id = child.descriptor.id;
    var childRect = child.page.borderBox;
    var childSize = childRect[axis.size];
    var threshold = childSize / combineThresholdDivisor;
    var didStartAfterCritical$1 = didStartAfterCritical(id, afterCritical);
    var isDisplaced = getIsDisplaced({
      displaced: previousImpact.displaced,
      id
    });
    if (didStartAfterCritical$1) {
      if (isDisplaced) {
        return targetEnd > childRect[axis.start] + threshold && targetEnd < childRect[axis.end] - threshold;
      }
      return targetStart > childRect[axis.start] - displacement + threshold && targetStart < childRect[axis.end] - displacement - threshold;
    }
    if (isDisplaced) {
      return targetEnd > childRect[axis.start] + displacement + threshold && targetEnd < childRect[axis.end] + displacement - threshold;
    }
    return targetStart > childRect[axis.start] + threshold && targetStart < childRect[axis.end] - threshold;
  });
  if (!combineWith) {
    return null;
  }
  var impact = {
    displacedBy,
    displaced: previousImpact.displaced,
    at: {
      type: "COMBINE",
      combine: {
        draggableId: combineWith.descriptor.id,
        droppableId: destination.descriptor.id
      }
    }
  };
  return impact;
};
var getDragImpact = function(_ref) {
  var pageOffset = _ref.pageOffset, draggable2 = _ref.draggable, draggables = _ref.draggables, droppables = _ref.droppables, previousImpact = _ref.previousImpact, viewport = _ref.viewport, afterCritical = _ref.afterCritical;
  var pageBorderBox = offsetRectByPosition(draggable2.page.borderBox, pageOffset);
  var destinationId = getDroppableOver$1({
    pageBorderBox,
    draggable: draggable2,
    droppables
  });
  if (!destinationId) {
    return noImpact;
  }
  var destination = droppables[destinationId];
  var insideDestination = getDraggablesInsideDroppable(destination.descriptor.id, draggables);
  var pageBorderBoxWithDroppableScroll = withDroppableScroll(destination, pageBorderBox);
  return getCombineImpact({
    pageBorderBoxWithDroppableScroll,
    draggable: draggable2,
    previousImpact,
    destination,
    insideDestination,
    afterCritical
  }) || getReorderImpact({
    pageBorderBoxWithDroppableScroll,
    draggable: draggable2,
    destination,
    insideDestination,
    last: previousImpact.displaced,
    viewport,
    afterCritical
  });
};
var patchDroppableMap = function(droppables, updated) {
  var _extends24;
  return _extends({}, droppables, (_extends24 = {}, _extends24[updated.descriptor.id] = updated, _extends24));
};
var clearUnusedPlaceholder = function clearUnusedPlaceholder2(_ref) {
  var previousImpact = _ref.previousImpact, impact = _ref.impact, droppables = _ref.droppables;
  var last2 = whatIsDraggedOver(previousImpact);
  var now3 = whatIsDraggedOver(impact);
  if (!last2) {
    return droppables;
  }
  if (last2 === now3) {
    return droppables;
  }
  var lastDroppable = droppables[last2];
  if (!lastDroppable.subject.withPlaceholder) {
    return droppables;
  }
  var updated = removePlaceholder(lastDroppable);
  return patchDroppableMap(droppables, updated);
};
var recomputePlaceholders = function(_ref2) {
  var draggable2 = _ref2.draggable, draggables = _ref2.draggables, droppables = _ref2.droppables, previousImpact = _ref2.previousImpact, impact = _ref2.impact;
  var cleaned = clearUnusedPlaceholder({
    previousImpact,
    impact,
    droppables
  });
  var isOver = whatIsDraggedOver(impact);
  if (!isOver) {
    return cleaned;
  }
  var droppable2 = droppables[isOver];
  if (isHomeOf(draggable2, droppable2)) {
    return cleaned;
  }
  if (droppable2.subject.withPlaceholder) {
    return cleaned;
  }
  var patched = addPlaceholder(droppable2, draggable2, draggables);
  return patchDroppableMap(cleaned, patched);
};
var update3 = function(_ref) {
  var state = _ref.state, forcedClientSelection = _ref.clientSelection, forcedDimensions = _ref.dimensions, forcedViewport = _ref.viewport, forcedImpact = _ref.impact, scrollJumpRequest = _ref.scrollJumpRequest;
  var viewport = forcedViewport || state.viewport;
  var dimensions = forcedDimensions || state.dimensions;
  var clientSelection = forcedClientSelection || state.current.client.selection;
  var offset5 = subtract(clientSelection, state.initial.client.selection);
  var client = {
    offset: offset5,
    selection: clientSelection,
    borderBoxCenter: add(state.initial.client.borderBoxCenter, offset5)
  };
  var page = {
    selection: add(client.selection, viewport.scroll.current),
    borderBoxCenter: add(client.borderBoxCenter, viewport.scroll.current),
    offset: add(client.offset, viewport.scroll.diff.value)
  };
  var current = {
    client,
    page
  };
  if (state.phase === "COLLECTING") {
    return _extends({
      phase: "COLLECTING"
    }, state, {
      dimensions,
      viewport,
      current
    });
  }
  var draggable2 = dimensions.draggables[state.critical.draggable.id];
  var newImpact = forcedImpact || getDragImpact({
    pageOffset: page.offset,
    draggable: draggable2,
    draggables: dimensions.draggables,
    droppables: dimensions.droppables,
    previousImpact: state.impact,
    viewport,
    afterCritical: state.afterCritical
  });
  var withUpdatedPlaceholders = recomputePlaceholders({
    draggable: draggable2,
    impact: newImpact,
    previousImpact: state.impact,
    draggables: dimensions.draggables,
    droppables: dimensions.droppables
  });
  var result = _extends({}, state, {
    current,
    dimensions: {
      draggables: dimensions.draggables,
      droppables: withUpdatedPlaceholders
    },
    impact: newImpact,
    viewport,
    scrollJumpRequest: scrollJumpRequest || null,
    forceShouldAnimate: scrollJumpRequest ? false : null
  });
  return result;
};
function getDraggables$1(ids, draggables) {
  return ids.map(function(id) {
    return draggables[id];
  });
}
var recompute = function(_ref) {
  var impact = _ref.impact, viewport = _ref.viewport, draggables = _ref.draggables, destination = _ref.destination, forceShouldAnimate = _ref.forceShouldAnimate;
  var last2 = impact.displaced;
  var afterDragging = getDraggables$1(last2.all, draggables);
  var displaced = getDisplacementGroups({
    afterDragging,
    destination,
    displacedBy: impact.displacedBy,
    viewport: viewport.frame,
    forceShouldAnimate,
    last: last2
  });
  return _extends({}, impact, {
    displaced
  });
};
var getClientBorderBoxCenter = function(_ref) {
  var impact = _ref.impact, draggable2 = _ref.draggable, droppable2 = _ref.droppable, draggables = _ref.draggables, viewport = _ref.viewport, afterCritical = _ref.afterCritical;
  var pageBorderBoxCenter = getPageBorderBoxCenterFromImpact({
    impact,
    draggable: draggable2,
    draggables,
    droppable: droppable2,
    afterCritical
  });
  return getClientFromPageBorderBoxCenter({
    pageBorderBoxCenter,
    draggable: draggable2,
    viewport
  });
};
var refreshSnap = function(_ref) {
  var state = _ref.state, forcedDimensions = _ref.dimensions, forcedViewport = _ref.viewport;
  !(state.movementMode === "SNAP") ? true ? invariant2(false) : invariant2(false) : void 0;
  var needsVisibilityCheck = state.impact;
  var viewport = forcedViewport || state.viewport;
  var dimensions = forcedDimensions || state.dimensions;
  var draggables = dimensions.draggables, droppables = dimensions.droppables;
  var draggable2 = draggables[state.critical.draggable.id];
  var isOver = whatIsDraggedOver(needsVisibilityCheck);
  !isOver ? true ? invariant2(false, "Must be over a destination in SNAP movement mode") : invariant2(false) : void 0;
  var destination = droppables[isOver];
  var impact = recompute({
    impact: needsVisibilityCheck,
    viewport,
    destination,
    draggables
  });
  var clientSelection = getClientBorderBoxCenter({
    impact,
    draggable: draggable2,
    droppable: destination,
    draggables,
    viewport,
    afterCritical: state.afterCritical
  });
  return update3({
    impact,
    clientSelection,
    state,
    dimensions,
    viewport
  });
};
var getHomeLocation = function(descriptor) {
  return {
    index: descriptor.index,
    droppableId: descriptor.droppableId
  };
};
var getLiftEffect = function(_ref) {
  var draggable2 = _ref.draggable, home2 = _ref.home, draggables = _ref.draggables, viewport = _ref.viewport;
  var displacedBy = getDisplacedBy(home2.axis, draggable2.displaceBy);
  var insideHome = getDraggablesInsideDroppable(home2.descriptor.id, draggables);
  var rawIndex = insideHome.indexOf(draggable2);
  !(rawIndex !== -1) ? true ? invariant2(false, "Expected draggable to be inside home list") : invariant2(false) : void 0;
  var afterDragging = insideHome.slice(rawIndex + 1);
  var effected = afterDragging.reduce(function(previous, item) {
    previous[item.descriptor.id] = true;
    return previous;
  }, {});
  var afterCritical = {
    inVirtualList: home2.descriptor.mode === "virtual",
    displacedBy,
    effected
  };
  var displaced = getDisplacementGroups({
    afterDragging,
    destination: home2,
    displacedBy,
    last: null,
    viewport: viewport.frame,
    forceShouldAnimate: false
  });
  var impact = {
    displaced,
    displacedBy,
    at: {
      type: "REORDER",
      destination: getHomeLocation(draggable2.descriptor)
    }
  };
  return {
    impact,
    afterCritical
  };
};
var patchDimensionMap = function(dimensions, updated) {
  return {
    draggables: dimensions.draggables,
    droppables: patchDroppableMap(dimensions.droppables, updated)
  };
};
var start = function start2(key) {
  if (true) {
    {
      return;
    }
  }
};
var finish = function finish2(key) {
  if (true) {
    {
      return;
    }
  }
};
var offsetDraggable = function(_ref) {
  var draggable2 = _ref.draggable, offset$1 = _ref.offset, initialWindowScroll = _ref.initialWindowScroll;
  var client = offset(draggable2.client, offset$1);
  var page = withScroll(client, initialWindowScroll);
  var moved = _extends({}, draggable2, {
    placeholder: _extends({}, draggable2.placeholder, {
      client
    }),
    client,
    page
  });
  return moved;
};
var getFrame = function(droppable2) {
  var frame = droppable2.frame;
  !frame ? true ? invariant2(false, "Expected Droppable to have a frame") : invariant2(false) : void 0;
  return frame;
};
var adjustAdditionsForScrollChanges = function(_ref) {
  var additions = _ref.additions, updatedDroppables = _ref.updatedDroppables, viewport = _ref.viewport;
  var windowScrollChange = viewport.scroll.diff.value;
  return additions.map(function(draggable2) {
    var droppableId = draggable2.descriptor.droppableId;
    var modified = updatedDroppables[droppableId];
    var frame = getFrame(modified);
    var droppableScrollChange = frame.scroll.diff.value;
    var totalChange = add(windowScrollChange, droppableScrollChange);
    var moved = offsetDraggable({
      draggable: draggable2,
      offset: totalChange,
      initialWindowScroll: viewport.scroll.initial
    });
    return moved;
  });
};
var publishWhileDraggingInVirtual = function(_ref) {
  var state = _ref.state, published = _ref.published;
  start();
  var withScrollChange = published.modified.map(function(update4) {
    var existing = state.dimensions.droppables[update4.droppableId];
    var scrolled = scrollDroppable(existing, update4.scroll);
    return scrolled;
  });
  var droppables = _extends({}, state.dimensions.droppables, {}, toDroppableMap(withScrollChange));
  var updatedAdditions = toDraggableMap(adjustAdditionsForScrollChanges({
    additions: published.additions,
    updatedDroppables: droppables,
    viewport: state.viewport
  }));
  var draggables = _extends({}, state.dimensions.draggables, {}, updatedAdditions);
  published.removals.forEach(function(id) {
    delete draggables[id];
  });
  var dimensions = {
    droppables,
    draggables
  };
  var wasOverId = whatIsDraggedOver(state.impact);
  var wasOver = wasOverId ? dimensions.droppables[wasOverId] : null;
  var draggable2 = dimensions.draggables[state.critical.draggable.id];
  var home2 = dimensions.droppables[state.critical.droppable.id];
  var _getLiftEffect = getLiftEffect({
    draggable: draggable2,
    home: home2,
    draggables,
    viewport: state.viewport
  }), onLiftImpact = _getLiftEffect.impact, afterCritical = _getLiftEffect.afterCritical;
  var previousImpact = wasOver && wasOver.isCombineEnabled ? state.impact : onLiftImpact;
  var impact = getDragImpact({
    pageOffset: state.current.page.offset,
    draggable: dimensions.draggables[state.critical.draggable.id],
    draggables: dimensions.draggables,
    droppables: dimensions.droppables,
    previousImpact,
    viewport: state.viewport,
    afterCritical
  });
  finish();
  var draggingState = _extends({
    phase: "DRAGGING"
  }, state, {
    phase: "DRAGGING",
    impact,
    onLiftImpact,
    dimensions,
    afterCritical,
    forceShouldAnimate: false
  });
  if (state.phase === "COLLECTING") {
    return draggingState;
  }
  var dropPending3 = _extends({
    phase: "DROP_PENDING"
  }, draggingState, {
    phase: "DROP_PENDING",
    reason: state.reason,
    isWaiting: false
  });
  return dropPending3;
};
var isSnapping = function isSnapping2(state) {
  return state.movementMode === "SNAP";
};
var postDroppableChange = function postDroppableChange2(state, updated, isEnabledChanging) {
  var dimensions = patchDimensionMap(state.dimensions, updated);
  if (!isSnapping(state) || isEnabledChanging) {
    return update3({
      state,
      dimensions
    });
  }
  return refreshSnap({
    state,
    dimensions
  });
};
function removeScrollJumpRequest(state) {
  if (state.isDragging && state.movementMode === "SNAP") {
    return _extends({
      phase: "DRAGGING"
    }, state, {
      scrollJumpRequest: null
    });
  }
  return state;
}
var idle = {
  phase: "IDLE",
  completed: null,
  shouldFlush: false
};
var reducer = function(state, action) {
  if (state === void 0) {
    state = idle;
  }
  if (action.type === "FLUSH") {
    return _extends({}, idle, {
      shouldFlush: true
    });
  }
  if (action.type === "INITIAL_PUBLISH") {
    !(state.phase === "IDLE") ? true ? invariant2(false, "INITIAL_PUBLISH must come after a IDLE phase") : invariant2(false) : void 0;
    var _action$payload = action.payload, critical = _action$payload.critical, clientSelection = _action$payload.clientSelection, viewport = _action$payload.viewport, dimensions = _action$payload.dimensions, movementMode = _action$payload.movementMode;
    var draggable2 = dimensions.draggables[critical.draggable.id];
    var home2 = dimensions.droppables[critical.droppable.id];
    var client = {
      selection: clientSelection,
      borderBoxCenter: draggable2.client.borderBox.center,
      offset: origin
    };
    var initial = {
      client,
      page: {
        selection: add(client.selection, viewport.scroll.initial),
        borderBoxCenter: add(client.selection, viewport.scroll.initial),
        offset: add(client.selection, viewport.scroll.diff.value)
      }
    };
    var isWindowScrollAllowed = toDroppableList(dimensions.droppables).every(function(item) {
      return !item.isFixedOnPage;
    });
    var _getLiftEffect = getLiftEffect({
      draggable: draggable2,
      home: home2,
      draggables: dimensions.draggables,
      viewport
    }), impact = _getLiftEffect.impact, afterCritical = _getLiftEffect.afterCritical;
    var result = {
      phase: "DRAGGING",
      isDragging: true,
      critical,
      movementMode,
      dimensions,
      initial,
      current: initial,
      isWindowScrollAllowed,
      impact,
      afterCritical,
      onLiftImpact: impact,
      viewport,
      scrollJumpRequest: null,
      forceShouldAnimate: null
    };
    return result;
  }
  if (action.type === "COLLECTION_STARTING") {
    if (state.phase === "COLLECTING" || state.phase === "DROP_PENDING") {
      return state;
    }
    !(state.phase === "DRAGGING") ? true ? invariant2(false, "Collection cannot start from phase " + state.phase) : invariant2(false) : void 0;
    var _result = _extends({
      phase: "COLLECTING"
    }, state, {
      phase: "COLLECTING"
    });
    return _result;
  }
  if (action.type === "PUBLISH_WHILE_DRAGGING") {
    !(state.phase === "COLLECTING" || state.phase === "DROP_PENDING") ? true ? invariant2(false, "Unexpected " + action.type + " received in phase " + state.phase) : invariant2(false) : void 0;
    return publishWhileDraggingInVirtual({
      state,
      published: action.payload
    });
  }
  if (action.type === "MOVE") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? true ? invariant2(false, action.type + " not permitted in phase " + state.phase) : invariant2(false) : void 0;
    var _clientSelection = action.payload.client;
    if (isEqual3(_clientSelection, state.current.client.selection)) {
      return state;
    }
    return update3({
      state,
      clientSelection: _clientSelection,
      impact: isSnapping(state) ? state.impact : null
    });
  }
  if (action.type === "UPDATE_DROPPABLE_SCROLL") {
    if (state.phase === "DROP_PENDING") {
      return removeScrollJumpRequest(state);
    }
    if (state.phase === "COLLECTING") {
      return removeScrollJumpRequest(state);
    }
    !isMovementAllowed(state) ? true ? invariant2(false, action.type + " not permitted in phase " + state.phase) : invariant2(false) : void 0;
    var _action$payload2 = action.payload, id = _action$payload2.id, newScroll = _action$payload2.newScroll;
    var target = state.dimensions.droppables[id];
    if (!target) {
      return state;
    }
    var scrolled = scrollDroppable(target, newScroll);
    return postDroppableChange(state, scrolled, false);
  }
  if (action.type === "UPDATE_DROPPABLE_IS_ENABLED") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? true ? invariant2(false, "Attempting to move in an unsupported phase " + state.phase) : invariant2(false) : void 0;
    var _action$payload3 = action.payload, _id = _action$payload3.id, isEnabled = _action$payload3.isEnabled;
    var _target = state.dimensions.droppables[_id];
    !_target ? true ? invariant2(false, "Cannot find Droppable[id: " + _id + "] to toggle its enabled state") : invariant2(false) : void 0;
    !(_target.isEnabled !== isEnabled) ? true ? invariant2(false, "Trying to set droppable isEnabled to " + String(isEnabled) + "\n      but it is already " + String(_target.isEnabled)) : invariant2(false) : void 0;
    var updated = _extends({}, _target, {
      isEnabled
    });
    return postDroppableChange(state, updated, true);
  }
  if (action.type === "UPDATE_DROPPABLE_IS_COMBINE_ENABLED") {
    if (state.phase === "DROP_PENDING") {
      return state;
    }
    !isMovementAllowed(state) ? true ? invariant2(false, "Attempting to move in an unsupported phase " + state.phase) : invariant2(false) : void 0;
    var _action$payload4 = action.payload, _id2 = _action$payload4.id, isCombineEnabled = _action$payload4.isCombineEnabled;
    var _target2 = state.dimensions.droppables[_id2];
    !_target2 ? true ? invariant2(false, "Cannot find Droppable[id: " + _id2 + "] to toggle its isCombineEnabled state") : invariant2(false) : void 0;
    !(_target2.isCombineEnabled !== isCombineEnabled) ? true ? invariant2(false, "Trying to set droppable isCombineEnabled to " + String(isCombineEnabled) + "\n      but it is already " + String(_target2.isCombineEnabled)) : invariant2(false) : void 0;
    var _updated = _extends({}, _target2, {
      isCombineEnabled
    });
    return postDroppableChange(state, _updated, true);
  }
  if (action.type === "MOVE_BY_WINDOW_SCROLL") {
    if (state.phase === "DROP_PENDING" || state.phase === "DROP_ANIMATING") {
      return state;
    }
    !isMovementAllowed(state) ? true ? invariant2(false, "Cannot move by window in phase " + state.phase) : invariant2(false) : void 0;
    !state.isWindowScrollAllowed ? true ? invariant2(false, "Window scrolling is currently not supported for fixed lists") : invariant2(false) : void 0;
    var _newScroll = action.payload.newScroll;
    if (isEqual3(state.viewport.scroll.current, _newScroll)) {
      return removeScrollJumpRequest(state);
    }
    var _viewport = scrollViewport(state.viewport, _newScroll);
    if (isSnapping(state)) {
      return refreshSnap({
        state,
        viewport: _viewport
      });
    }
    return update3({
      state,
      viewport: _viewport
    });
  }
  if (action.type === "UPDATE_VIEWPORT_MAX_SCROLL") {
    if (!isMovementAllowed(state)) {
      return state;
    }
    var maxScroll = action.payload.maxScroll;
    if (isEqual3(maxScroll, state.viewport.scroll.max)) {
      return state;
    }
    var withMaxScroll3 = _extends({}, state.viewport, {
      scroll: _extends({}, state.viewport.scroll, {
        max: maxScroll
      })
    });
    return _extends({
      phase: "DRAGGING"
    }, state, {
      viewport: withMaxScroll3
    });
  }
  if (action.type === "MOVE_UP" || action.type === "MOVE_DOWN" || action.type === "MOVE_LEFT" || action.type === "MOVE_RIGHT") {
    if (state.phase === "COLLECTING" || state.phase === "DROP_PENDING") {
      return state;
    }
    !(state.phase === "DRAGGING") ? true ? invariant2(false, action.type + " received while not in DRAGGING phase") : invariant2(false) : void 0;
    var _result2 = moveInDirection({
      state,
      type: action.type
    });
    if (!_result2) {
      return state;
    }
    return update3({
      state,
      impact: _result2.impact,
      clientSelection: _result2.clientSelection,
      scrollJumpRequest: _result2.scrollJumpRequest
    });
  }
  if (action.type === "DROP_PENDING") {
    var reason = action.payload.reason;
    !(state.phase === "COLLECTING") ? true ? invariant2(false, "Can only move into the DROP_PENDING phase from the COLLECTING phase") : invariant2(false) : void 0;
    var newState = _extends({
      phase: "DROP_PENDING"
    }, state, {
      phase: "DROP_PENDING",
      isWaiting: true,
      reason
    });
    return newState;
  }
  if (action.type === "DROP_ANIMATE") {
    var _action$payload5 = action.payload, completed = _action$payload5.completed, dropDuration = _action$payload5.dropDuration, newHomeClientOffset = _action$payload5.newHomeClientOffset;
    !(state.phase === "DRAGGING" || state.phase === "DROP_PENDING") ? true ? invariant2(false, "Cannot animate drop from phase " + state.phase) : invariant2(false) : void 0;
    var _result3 = {
      phase: "DROP_ANIMATING",
      completed,
      dropDuration,
      newHomeClientOffset,
      dimensions: state.dimensions
    };
    return _result3;
  }
  if (action.type === "DROP_COMPLETE") {
    var _completed = action.payload.completed;
    return {
      phase: "IDLE",
      completed: _completed,
      shouldFlush: false
    };
  }
  return state;
};
var beforeInitialCapture = function beforeInitialCapture2(args) {
  return {
    type: "BEFORE_INITIAL_CAPTURE",
    payload: args
  };
};
var lift = function lift2(args) {
  return {
    type: "LIFT",
    payload: args
  };
};
var initialPublish = function initialPublish2(args) {
  return {
    type: "INITIAL_PUBLISH",
    payload: args
  };
};
var publishWhileDragging = function publishWhileDragging2(args) {
  return {
    type: "PUBLISH_WHILE_DRAGGING",
    payload: args
  };
};
var collectionStarting = function collectionStarting2() {
  return {
    type: "COLLECTION_STARTING",
    payload: null
  };
};
var updateDroppableScroll = function updateDroppableScroll2(args) {
  return {
    type: "UPDATE_DROPPABLE_SCROLL",
    payload: args
  };
};
var updateDroppableIsEnabled = function updateDroppableIsEnabled2(args) {
  return {
    type: "UPDATE_DROPPABLE_IS_ENABLED",
    payload: args
  };
};
var updateDroppableIsCombineEnabled = function updateDroppableIsCombineEnabled2(args) {
  return {
    type: "UPDATE_DROPPABLE_IS_COMBINE_ENABLED",
    payload: args
  };
};
var move3 = function move4(args) {
  return {
    type: "MOVE",
    payload: args
  };
};
var moveByWindowScroll = function moveByWindowScroll2(args) {
  return {
    type: "MOVE_BY_WINDOW_SCROLL",
    payload: args
  };
};
var updateViewportMaxScroll = function updateViewportMaxScroll2(args) {
  return {
    type: "UPDATE_VIEWPORT_MAX_SCROLL",
    payload: args
  };
};
var moveUp = function moveUp2() {
  return {
    type: "MOVE_UP",
    payload: null
  };
};
var moveDown = function moveDown2() {
  return {
    type: "MOVE_DOWN",
    payload: null
  };
};
var moveRight = function moveRight2() {
  return {
    type: "MOVE_RIGHT",
    payload: null
  };
};
var moveLeft = function moveLeft2() {
  return {
    type: "MOVE_LEFT",
    payload: null
  };
};
var flush = function flush2() {
  return {
    type: "FLUSH",
    payload: null
  };
};
var animateDrop = function animateDrop2(args) {
  return {
    type: "DROP_ANIMATE",
    payload: args
  };
};
var completeDrop = function completeDrop2(args) {
  return {
    type: "DROP_COMPLETE",
    payload: args
  };
};
var drop = function drop2(args) {
  return {
    type: "DROP",
    payload: args
  };
};
var dropPending = function dropPending2(args) {
  return {
    type: "DROP_PENDING",
    payload: args
  };
};
var dropAnimationFinished = function dropAnimationFinished2() {
  return {
    type: "DROP_ANIMATION_FINISHED",
    payload: null
  };
};
function checkIndexes(insideDestination) {
  if (insideDestination.length <= 1) {
    return;
  }
  var indexes = insideDestination.map(function(d17) {
    return d17.descriptor.index;
  });
  var errors = {};
  for (var i15 = 1; i15 < indexes.length; i15++) {
    var current = indexes[i15];
    var previous = indexes[i15 - 1];
    if (current !== previous + 1) {
      errors[current] = true;
    }
  }
  if (!Object.keys(errors).length) {
    return;
  }
  var formatted = indexes.map(function(index2) {
    var hasError = Boolean(errors[index2]);
    return hasError ? "[🔥" + index2 + "]" : "" + index2;
  }).join(", ");
  true ? warning2("\n    Detected non-consecutive <Draggable /> indexes.\n\n    (This can cause unexpected bugs)\n\n    " + formatted + "\n  ") : void 0;
}
function validateDimensions(critical, dimensions) {
  if (true) {
    var insideDestination = getDraggablesInsideDroppable(critical.droppable.id, dimensions.draggables);
    checkIndexes(insideDestination);
  }
}
var lift$1 = function(marshal) {
  return function(_ref) {
    var getState2 = _ref.getState, dispatch = _ref.dispatch;
    return function(next) {
      return function(action) {
        if (action.type !== "LIFT") {
          next(action);
          return;
        }
        var _action$payload = action.payload, id = _action$payload.id, clientSelection = _action$payload.clientSelection, movementMode = _action$payload.movementMode;
        var initial = getState2();
        if (initial.phase === "DROP_ANIMATING") {
          dispatch(completeDrop({
            completed: initial.completed
          }));
        }
        !(getState2().phase === "IDLE") ? true ? invariant2(false, "Unexpected phase to start a drag") : invariant2(false) : void 0;
        dispatch(flush());
        dispatch(beforeInitialCapture({
          draggableId: id,
          movementMode
        }));
        var scrollOptions = {
          shouldPublishImmediately: movementMode === "SNAP"
        };
        var request = {
          draggableId: id,
          scrollOptions
        };
        var _marshal$startPublish = marshal.startPublishing(request), critical = _marshal$startPublish.critical, dimensions = _marshal$startPublish.dimensions, viewport = _marshal$startPublish.viewport;
        validateDimensions(critical, dimensions);
        dispatch(initialPublish({
          critical,
          dimensions,
          clientSelection,
          movementMode,
          viewport
        }));
      };
    };
  };
};
var style = function(marshal) {
  return function() {
    return function(next) {
      return function(action) {
        if (action.type === "INITIAL_PUBLISH") {
          marshal.dragging();
        }
        if (action.type === "DROP_ANIMATE") {
          marshal.dropping(action.payload.completed.result.reason);
        }
        if (action.type === "FLUSH" || action.type === "DROP_COMPLETE") {
          marshal.resting();
        }
        next(action);
      };
    };
  };
};
var curves = {
  outOfTheWay: "cubic-bezier(0.2, 0, 0, 1)",
  drop: "cubic-bezier(.2,1,.1,1)"
};
var combine = {
  opacity: {
    drop: 0,
    combining: 0.7
  },
  scale: {
    drop: 0.75
  }
};
var timings = {
  outOfTheWay: 0.2,
  minDropTime: 0.33,
  maxDropTime: 0.55
};
var outOfTheWayTiming = timings.outOfTheWay + "s " + curves.outOfTheWay;
var transitions = {
  fluid: "opacity " + outOfTheWayTiming,
  snap: "transform " + outOfTheWayTiming + ", opacity " + outOfTheWayTiming,
  drop: function drop3(duration) {
    var timing = duration + "s " + curves.drop;
    return "transform " + timing + ", opacity " + timing;
  },
  outOfTheWay: "transform " + outOfTheWayTiming,
  placeholder: "height " + outOfTheWayTiming + ", width " + outOfTheWayTiming + ", margin " + outOfTheWayTiming
};
var moveTo = function moveTo2(offset5) {
  return isEqual3(offset5, origin) ? null : "translate(" + offset5.x + "px, " + offset5.y + "px)";
};
var transforms = {
  moveTo,
  drop: function drop4(offset5, isCombining) {
    var translate = moveTo(offset5);
    if (!translate) {
      return null;
    }
    if (!isCombining) {
      return translate;
    }
    return translate + " scale(" + combine.scale.drop + ")";
  }
};
var minDropTime = timings.minDropTime;
var maxDropTime = timings.maxDropTime;
var dropTimeRange = maxDropTime - minDropTime;
var maxDropTimeAtDistance = 1500;
var cancelDropModifier = 0.6;
var getDropDuration = function(_ref) {
  var current = _ref.current, destination = _ref.destination, reason = _ref.reason;
  var distance$1 = distance(current, destination);
  if (distance$1 <= 0) {
    return minDropTime;
  }
  if (distance$1 >= maxDropTimeAtDistance) {
    return maxDropTime;
  }
  var percentage = distance$1 / maxDropTimeAtDistance;
  var duration = minDropTime + dropTimeRange * percentage;
  var withDuration = reason === "CANCEL" ? duration * cancelDropModifier : duration;
  return Number(withDuration.toFixed(2));
};
var getNewHomeClientOffset = function(_ref) {
  var impact = _ref.impact, draggable2 = _ref.draggable, dimensions = _ref.dimensions, viewport = _ref.viewport, afterCritical = _ref.afterCritical;
  var draggables = dimensions.draggables, droppables = dimensions.droppables;
  var droppableId = whatIsDraggedOver(impact);
  var destination = droppableId ? droppables[droppableId] : null;
  var home2 = droppables[draggable2.descriptor.droppableId];
  var newClientCenter = getClientBorderBoxCenter({
    impact,
    draggable: draggable2,
    draggables,
    afterCritical,
    droppable: destination || home2,
    viewport
  });
  var offset5 = subtract(newClientCenter, draggable2.client.borderBox.center);
  return offset5;
};
var getDropImpact = function(_ref) {
  var draggables = _ref.draggables, reason = _ref.reason, lastImpact = _ref.lastImpact, home2 = _ref.home, viewport = _ref.viewport, onLiftImpact = _ref.onLiftImpact;
  if (!lastImpact.at || reason !== "DROP") {
    var recomputedHomeImpact = recompute({
      draggables,
      impact: onLiftImpact,
      destination: home2,
      viewport,
      forceShouldAnimate: true
    });
    return {
      impact: recomputedHomeImpact,
      didDropInsideDroppable: false
    };
  }
  if (lastImpact.at.type === "REORDER") {
    return {
      impact: lastImpact,
      didDropInsideDroppable: true
    };
  }
  var withoutMovement = _extends({}, lastImpact, {
    displaced: emptyGroups
  });
  return {
    impact: withoutMovement,
    didDropInsideDroppable: true
  };
};
var drop$1 = function(_ref) {
  var getState2 = _ref.getState, dispatch = _ref.dispatch;
  return function(next) {
    return function(action) {
      if (action.type !== "DROP") {
        next(action);
        return;
      }
      var state = getState2();
      var reason = action.payload.reason;
      if (state.phase === "COLLECTING") {
        dispatch(dropPending({
          reason
        }));
        return;
      }
      if (state.phase === "IDLE") {
        return;
      }
      var isWaitingForDrop = state.phase === "DROP_PENDING" && state.isWaiting;
      !!isWaitingForDrop ? true ? invariant2(false, "A DROP action occurred while DROP_PENDING and still waiting") : invariant2(false) : void 0;
      !(state.phase === "DRAGGING" || state.phase === "DROP_PENDING") ? true ? invariant2(false, "Cannot drop in phase: " + state.phase) : invariant2(false) : void 0;
      var critical = state.critical;
      var dimensions = state.dimensions;
      var draggable2 = dimensions.draggables[state.critical.draggable.id];
      var _getDropImpact = getDropImpact({
        reason,
        lastImpact: state.impact,
        afterCritical: state.afterCritical,
        onLiftImpact: state.onLiftImpact,
        home: state.dimensions.droppables[state.critical.droppable.id],
        viewport: state.viewport,
        draggables: state.dimensions.draggables
      }), impact = _getDropImpact.impact, didDropInsideDroppable = _getDropImpact.didDropInsideDroppable;
      var destination = didDropInsideDroppable ? tryGetDestination(impact) : null;
      var combine2 = didDropInsideDroppable ? tryGetCombine(impact) : null;
      var source = {
        index: critical.draggable.index,
        droppableId: critical.droppable.id
      };
      var result = {
        draggableId: draggable2.descriptor.id,
        type: draggable2.descriptor.type,
        source,
        reason,
        mode: state.movementMode,
        destination,
        combine: combine2
      };
      var newHomeClientOffset = getNewHomeClientOffset({
        impact,
        draggable: draggable2,
        dimensions,
        viewport: state.viewport,
        afterCritical: state.afterCritical
      });
      var completed = {
        critical: state.critical,
        afterCritical: state.afterCritical,
        result,
        impact
      };
      var isAnimationRequired = !isEqual3(state.current.client.offset, newHomeClientOffset) || Boolean(result.combine);
      if (!isAnimationRequired) {
        dispatch(completeDrop({
          completed
        }));
        return;
      }
      var dropDuration = getDropDuration({
        current: state.current.client.offset,
        destination: newHomeClientOffset,
        reason
      });
      var args = {
        newHomeClientOffset,
        dropDuration,
        completed
      };
      dispatch(animateDrop(args));
    };
  };
};
var getWindowScroll3 = function() {
  return {
    x: window.pageXOffset,
    y: window.pageYOffset
  };
};
function getWindowScrollBinding(update4) {
  return {
    eventName: "scroll",
    options: {
      passive: true,
      capture: false
    },
    fn: function fn2(event) {
      if (event.target !== window && event.target !== window.document) {
        return;
      }
      update4();
    }
  };
}
function getScrollListener(_ref) {
  var onWindowScroll = _ref.onWindowScroll;
  function updateScroll() {
    onWindowScroll(getWindowScroll3());
  }
  var scheduled = raf_schd_esm_default(updateScroll);
  var binding = getWindowScrollBinding(scheduled);
  var unbind = noop4;
  function isActive() {
    return unbind !== noop4;
  }
  function start3() {
    !!isActive() ? true ? invariant2(false, "Cannot start scroll listener when already active") : invariant2(false) : void 0;
    unbind = bindEvents(window, [binding]);
  }
  function stop() {
    !isActive() ? true ? invariant2(false, "Cannot stop scroll listener when not active") : invariant2(false) : void 0;
    scheduled.cancel();
    unbind();
    unbind = noop4;
  }
  return {
    start: start3,
    stop,
    isActive
  };
}
var shouldEnd = function shouldEnd2(action) {
  return action.type === "DROP_COMPLETE" || action.type === "DROP_ANIMATE" || action.type === "FLUSH";
};
var scrollListener = function(store) {
  var listener = getScrollListener({
    onWindowScroll: function onWindowScroll(newScroll) {
      store.dispatch(moveByWindowScroll({
        newScroll
      }));
    }
  });
  return function(next) {
    return function(action) {
      if (!listener.isActive() && action.type === "INITIAL_PUBLISH") {
        listener.start();
      }
      if (listener.isActive() && shouldEnd(action)) {
        listener.stop();
      }
      next(action);
    };
  };
};
var getExpiringAnnounce = function(announce) {
  var wasCalled = false;
  var isExpired = false;
  var timeoutId = setTimeout(function() {
    isExpired = true;
  });
  var result = function result2(message) {
    if (wasCalled) {
      true ? warning2("Announcement already made. Not making a second announcement") : void 0;
      return;
    }
    if (isExpired) {
      true ? warning2("\n        Announcements cannot be made asynchronously.\n        Default message has already been announced.\n      ") : void 0;
      return;
    }
    wasCalled = true;
    announce(message);
    clearTimeout(timeoutId);
  };
  result.wasCalled = function() {
    return wasCalled;
  };
  return result;
};
var getAsyncMarshal = function() {
  var entries = [];
  var execute3 = function execute4(timerId) {
    var index2 = findIndex(entries, function(item) {
      return item.timerId === timerId;
    });
    !(index2 !== -1) ? true ? invariant2(false, "Could not find timer") : invariant2(false) : void 0;
    var _entries$splice = entries.splice(index2, 1), entry = _entries$splice[0];
    entry.callback();
  };
  var add4 = function add5(fn2) {
    var timerId = setTimeout(function() {
      return execute3(timerId);
    });
    var entry = {
      timerId,
      callback: fn2
    };
    entries.push(entry);
  };
  var flush3 = function flush4() {
    if (!entries.length) {
      return;
    }
    var shallow = [].concat(entries);
    entries.length = 0;
    shallow.forEach(function(entry) {
      clearTimeout(entry.timerId);
      entry.callback();
    });
  };
  return {
    add: add4,
    flush: flush3
  };
};
var areLocationsEqual = function areLocationsEqual2(first, second) {
  if (first == null && second == null) {
    return true;
  }
  if (first == null || second == null) {
    return false;
  }
  return first.droppableId === second.droppableId && first.index === second.index;
};
var isCombineEqual = function isCombineEqual2(first, second) {
  if (first == null && second == null) {
    return true;
  }
  if (first == null || second == null) {
    return false;
  }
  return first.draggableId === second.draggableId && first.droppableId === second.droppableId;
};
var isCriticalEqual = function isCriticalEqual2(first, second) {
  if (first === second) {
    return true;
  }
  var isDraggableEqual = first.draggable.id === second.draggable.id && first.draggable.droppableId === second.draggable.droppableId && first.draggable.type === second.draggable.type && first.draggable.index === second.draggable.index;
  var isDroppableEqual = first.droppable.id === second.droppable.id && first.droppable.type === second.droppable.type;
  return isDraggableEqual && isDroppableEqual;
};
var withTimings = function withTimings2(key, fn2) {
  start();
  fn2();
  finish();
};
var getDragStart = function getDragStart2(critical, mode) {
  return {
    draggableId: critical.draggable.id,
    type: critical.droppable.type,
    source: {
      droppableId: critical.droppable.id,
      index: critical.draggable.index
    },
    mode
  };
};
var execute = function execute2(responder, data, announce, getDefaultMessage) {
  if (!responder) {
    announce(getDefaultMessage(data));
    return;
  }
  var willExpire = getExpiringAnnounce(announce);
  var provided = {
    announce: willExpire
  };
  responder(data, provided);
  if (!willExpire.wasCalled()) {
    announce(getDefaultMessage(data));
  }
};
var getPublisher = function(getResponders, announce) {
  var asyncMarshal = getAsyncMarshal();
  var dragging = null;
  var beforeCapture = function beforeCapture2(draggableId, mode) {
    !!dragging ? true ? invariant2(false, "Cannot fire onBeforeCapture as a drag start has already been published") : invariant2(false) : void 0;
    withTimings("onBeforeCapture", function() {
      var fn2 = getResponders().onBeforeCapture;
      if (fn2) {
        var before = {
          draggableId,
          mode
        };
        fn2(before);
      }
    });
  };
  var beforeStart = function beforeStart2(critical, mode) {
    !!dragging ? true ? invariant2(false, "Cannot fire onBeforeDragStart as a drag start has already been published") : invariant2(false) : void 0;
    withTimings("onBeforeDragStart", function() {
      var fn2 = getResponders().onBeforeDragStart;
      if (fn2) {
        fn2(getDragStart(critical, mode));
      }
    });
  };
  var start3 = function start4(critical, mode) {
    !!dragging ? true ? invariant2(false, "Cannot fire onBeforeDragStart as a drag start has already been published") : invariant2(false) : void 0;
    var data = getDragStart(critical, mode);
    dragging = {
      mode,
      lastCritical: critical,
      lastLocation: data.source,
      lastCombine: null
    };
    asyncMarshal.add(function() {
      withTimings("onDragStart", function() {
        return execute(getResponders().onDragStart, data, announce, preset.onDragStart);
      });
    });
  };
  var update4 = function update5(critical, impact) {
    var location = tryGetDestination(impact);
    var combine2 = tryGetCombine(impact);
    !dragging ? true ? invariant2(false, "Cannot fire onDragMove when onDragStart has not been called") : invariant2(false) : void 0;
    var hasCriticalChanged = !isCriticalEqual(critical, dragging.lastCritical);
    if (hasCriticalChanged) {
      dragging.lastCritical = critical;
    }
    var hasLocationChanged = !areLocationsEqual(dragging.lastLocation, location);
    if (hasLocationChanged) {
      dragging.lastLocation = location;
    }
    var hasGroupingChanged = !isCombineEqual(dragging.lastCombine, combine2);
    if (hasGroupingChanged) {
      dragging.lastCombine = combine2;
    }
    if (!hasCriticalChanged && !hasLocationChanged && !hasGroupingChanged) {
      return;
    }
    var data = _extends({}, getDragStart(critical, dragging.mode), {
      combine: combine2,
      destination: location
    });
    asyncMarshal.add(function() {
      withTimings("onDragUpdate", function() {
        return execute(getResponders().onDragUpdate, data, announce, preset.onDragUpdate);
      });
    });
  };
  var flush3 = function flush4() {
    !dragging ? true ? invariant2(false, "Can only flush responders while dragging") : invariant2(false) : void 0;
    asyncMarshal.flush();
  };
  var drop5 = function drop6(result) {
    !dragging ? true ? invariant2(false, "Cannot fire onDragEnd when there is no matching onDragStart") : invariant2(false) : void 0;
    dragging = null;
    withTimings("onDragEnd", function() {
      return execute(getResponders().onDragEnd, result, announce, preset.onDragEnd);
    });
  };
  var abort = function abort2() {
    if (!dragging) {
      return;
    }
    var result = _extends({}, getDragStart(dragging.lastCritical, dragging.mode), {
      combine: null,
      destination: null,
      reason: "CANCEL"
    });
    drop5(result);
  };
  return {
    beforeCapture,
    beforeStart,
    start: start3,
    update: update4,
    flush: flush3,
    drop: drop5,
    abort
  };
};
var responders = function(getResponders, announce) {
  var publisher = getPublisher(getResponders, announce);
  return function(store) {
    return function(next) {
      return function(action) {
        if (action.type === "BEFORE_INITIAL_CAPTURE") {
          publisher.beforeCapture(action.payload.draggableId, action.payload.movementMode);
          return;
        }
        if (action.type === "INITIAL_PUBLISH") {
          var critical = action.payload.critical;
          publisher.beforeStart(critical, action.payload.movementMode);
          next(action);
          publisher.start(critical, action.payload.movementMode);
          return;
        }
        if (action.type === "DROP_COMPLETE") {
          var result = action.payload.completed.result;
          publisher.flush();
          next(action);
          publisher.drop(result);
          return;
        }
        next(action);
        if (action.type === "FLUSH") {
          publisher.abort();
          return;
        }
        var state = store.getState();
        if (state.phase === "DRAGGING") {
          publisher.update(state.critical, state.impact);
        }
      };
    };
  };
};
var dropAnimationFinish = function(store) {
  return function(next) {
    return function(action) {
      if (action.type !== "DROP_ANIMATION_FINISHED") {
        next(action);
        return;
      }
      var state = store.getState();
      !(state.phase === "DROP_ANIMATING") ? true ? invariant2(false, "Cannot finish a drop animating when no drop is occurring") : invariant2(false) : void 0;
      store.dispatch(completeDrop({
        completed: state.completed
      }));
    };
  };
};
var dropAnimationFlushOnScroll = function(store) {
  var unbind = null;
  var frameId = null;
  function clear() {
    if (frameId) {
      cancelAnimationFrame(frameId);
      frameId = null;
    }
    if (unbind) {
      unbind();
      unbind = null;
    }
  }
  return function(next) {
    return function(action) {
      if (action.type === "FLUSH" || action.type === "DROP_COMPLETE" || action.type === "DROP_ANIMATION_FINISHED") {
        clear();
      }
      next(action);
      if (action.type !== "DROP_ANIMATE") {
        return;
      }
      var binding = {
        eventName: "scroll",
        options: {
          capture: true,
          passive: false,
          once: true
        },
        fn: function flushDropAnimation() {
          var state = store.getState();
          if (state.phase === "DROP_ANIMATING") {
            store.dispatch(dropAnimationFinished());
          }
        }
      };
      frameId = requestAnimationFrame(function() {
        frameId = null;
        unbind = bindEvents(window, [binding]);
      });
    };
  };
};
var dimensionMarshalStopper = function(marshal) {
  return function() {
    return function(next) {
      return function(action) {
        if (action.type === "DROP_COMPLETE" || action.type === "FLUSH" || action.type === "DROP_ANIMATE") {
          marshal.stopPublishing();
        }
        next(action);
      };
    };
  };
};
var focus = function(marshal) {
  var isWatching = false;
  return function() {
    return function(next) {
      return function(action) {
        if (action.type === "INITIAL_PUBLISH") {
          isWatching = true;
          marshal.tryRecordFocus(action.payload.critical.draggable.id);
          next(action);
          marshal.tryRestoreFocusRecorded();
          return;
        }
        next(action);
        if (!isWatching) {
          return;
        }
        if (action.type === "FLUSH") {
          isWatching = false;
          marshal.tryRestoreFocusRecorded();
          return;
        }
        if (action.type === "DROP_COMPLETE") {
          isWatching = false;
          var result = action.payload.completed.result;
          if (result.combine) {
            marshal.tryShiftRecord(result.draggableId, result.combine.draggableId);
          }
          marshal.tryRestoreFocusRecorded();
        }
      };
    };
  };
};
var shouldStop = function shouldStop2(action) {
  return action.type === "DROP_COMPLETE" || action.type === "DROP_ANIMATE" || action.type === "FLUSH";
};
var autoScroll = function(autoScroller) {
  return function(store) {
    return function(next) {
      return function(action) {
        if (shouldStop(action)) {
          autoScroller.stop();
          next(action);
          return;
        }
        if (action.type === "INITIAL_PUBLISH") {
          next(action);
          var state = store.getState();
          !(state.phase === "DRAGGING") ? true ? invariant2(false, "Expected phase to be DRAGGING after INITIAL_PUBLISH") : invariant2(false) : void 0;
          autoScroller.start(state);
          return;
        }
        next(action);
        autoScroller.scroll(store.getState());
      };
    };
  };
};
var pendingDrop = function(store) {
  return function(next) {
    return function(action) {
      next(action);
      if (action.type !== "PUBLISH_WHILE_DRAGGING") {
        return;
      }
      var postActionState = store.getState();
      if (postActionState.phase !== "DROP_PENDING") {
        return;
      }
      if (postActionState.isWaiting) {
        return;
      }
      store.dispatch(drop({
        reason: postActionState.reason
      }));
    };
  };
};
var composeEnhancers = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__({
  name: "react-beautiful-dnd"
}) : compose;
var createStore6 = function(_ref) {
  var dimensionMarshal = _ref.dimensionMarshal, focusMarshal = _ref.focusMarshal, styleMarshal = _ref.styleMarshal, getResponders = _ref.getResponders, announce = _ref.announce, autoScroller = _ref.autoScroller;
  return createStore5(reducer, composeEnhancers(applyMiddleware(style(styleMarshal), dimensionMarshalStopper(dimensionMarshal), lift$1(dimensionMarshal), drop$1, dropAnimationFinish, dropAnimationFlushOnScroll, pendingDrop, autoScroll(autoScroller), scrollListener, focus(focusMarshal), responders(getResponders, announce))));
};
var clean$1 = function clean3() {
  return {
    additions: {},
    removals: {},
    modified: {}
  };
};
function createPublisher(_ref) {
  var registry = _ref.registry, callbacks = _ref.callbacks;
  var staging = clean$1();
  var frameId = null;
  var collect = function collect2() {
    if (frameId) {
      return;
    }
    callbacks.collectionStarting();
    frameId = requestAnimationFrame(function() {
      frameId = null;
      start();
      var _staging = staging, additions = _staging.additions, removals = _staging.removals, modified = _staging.modified;
      var added = Object.keys(additions).map(function(id) {
        return registry.draggable.getById(id).getDimension(origin);
      }).sort(function(a13, b6) {
        return a13.descriptor.index - b6.descriptor.index;
      });
      var updated = Object.keys(modified).map(function(id) {
        var entry = registry.droppable.getById(id);
        var scroll3 = entry.callbacks.getScrollWhileDragging();
        return {
          droppableId: id,
          scroll: scroll3
        };
      });
      var result = {
        additions: added,
        removals: Object.keys(removals),
        modified: updated
      };
      staging = clean$1();
      finish();
      callbacks.publish(result);
    });
  };
  var add4 = function add5(entry) {
    var id = entry.descriptor.id;
    staging.additions[id] = entry;
    staging.modified[entry.descriptor.droppableId] = true;
    if (staging.removals[id]) {
      delete staging.removals[id];
    }
    collect();
  };
  var remove3 = function remove4(entry) {
    var descriptor = entry.descriptor;
    staging.removals[descriptor.id] = true;
    staging.modified[descriptor.droppableId] = true;
    if (staging.additions[descriptor.id]) {
      delete staging.additions[descriptor.id];
    }
    collect();
  };
  var stop = function stop2() {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
    staging = clean$1();
  };
  return {
    add: add4,
    remove: remove3,
    stop
  };
}
var getMaxScroll = function(_ref) {
  var scrollHeight = _ref.scrollHeight, scrollWidth = _ref.scrollWidth, height = _ref.height, width = _ref.width;
  var maxScroll = subtract({
    x: scrollWidth,
    y: scrollHeight
  }, {
    x: width,
    y: height
  });
  var adjustedMaxScroll = {
    x: Math.max(0, maxScroll.x),
    y: Math.max(0, maxScroll.y)
  };
  return adjustedMaxScroll;
};
var getDocumentElement = function() {
  var doc = document.documentElement;
  !doc ? true ? invariant2(false, "Cannot find document.documentElement") : invariant2(false) : void 0;
  return doc;
};
var getMaxWindowScroll = function() {
  var doc = getDocumentElement();
  var maxScroll = getMaxScroll({
    scrollHeight: doc.scrollHeight,
    scrollWidth: doc.scrollWidth,
    width: doc.clientWidth,
    height: doc.clientHeight
  });
  return maxScroll;
};
var getViewport = function() {
  var scroll3 = getWindowScroll3();
  var maxScroll = getMaxWindowScroll();
  var top = scroll3.y;
  var left = scroll3.x;
  var doc = getDocumentElement();
  var width = doc.clientWidth;
  var height = doc.clientHeight;
  var right = left + width;
  var bottom = top + height;
  var frame = getRect({
    top,
    left,
    right,
    bottom
  });
  var viewport = {
    frame,
    scroll: {
      initial: scroll3,
      current: scroll3,
      max: maxScroll,
      diff: {
        value: origin,
        displacement: origin
      }
    }
  };
  return viewport;
};
var getInitialPublish = function(_ref) {
  var critical = _ref.critical, scrollOptions = _ref.scrollOptions, registry = _ref.registry;
  start();
  var viewport = getViewport();
  var windowScroll = viewport.scroll.current;
  var home2 = critical.droppable;
  var droppables = registry.droppable.getAllByType(home2.type).map(function(entry) {
    return entry.callbacks.getDimensionAndWatchScroll(windowScroll, scrollOptions);
  });
  var draggables = registry.draggable.getAllByType(critical.draggable.type).map(function(entry) {
    return entry.getDimension(windowScroll);
  });
  var dimensions = {
    draggables: toDraggableMap(draggables),
    droppables: toDroppableMap(droppables)
  };
  finish();
  var result = {
    dimensions,
    critical,
    viewport
  };
  return result;
};
function shouldPublishUpdate(registry, dragging, entry) {
  if (entry.descriptor.id === dragging.id) {
    return false;
  }
  if (entry.descriptor.type !== dragging.type) {
    return false;
  }
  var home2 = registry.droppable.getById(entry.descriptor.droppableId);
  if (home2.descriptor.mode !== "virtual") {
    true ? warning2("\n      You are attempting to add or remove a Draggable [id: " + entry.descriptor.id + "]\n      while a drag is occurring. This is only supported for virtual lists.\n\n      See https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/patterns/virtual-lists.md\n    ") : void 0;
    return false;
  }
  return true;
}
var createDimensionMarshal = function(registry, callbacks) {
  var collection = null;
  var publisher = createPublisher({
    callbacks: {
      publish: callbacks.publishWhileDragging,
      collectionStarting: callbacks.collectionStarting
    },
    registry
  });
  var updateDroppableIsEnabled3 = function updateDroppableIsEnabled4(id, isEnabled) {
    !registry.droppable.exists(id) ? true ? invariant2(false, "Cannot update is enabled flag of Droppable " + id + " as it is not registered") : invariant2(false) : void 0;
    if (!collection) {
      return;
    }
    callbacks.updateDroppableIsEnabled({
      id,
      isEnabled
    });
  };
  var updateDroppableIsCombineEnabled3 = function updateDroppableIsCombineEnabled4(id, isCombineEnabled) {
    if (!collection) {
      return;
    }
    !registry.droppable.exists(id) ? true ? invariant2(false, "Cannot update isCombineEnabled flag of Droppable " + id + " as it is not registered") : invariant2(false) : void 0;
    callbacks.updateDroppableIsCombineEnabled({
      id,
      isCombineEnabled
    });
  };
  var updateDroppableScroll3 = function updateDroppableScroll4(id, newScroll) {
    if (!collection) {
      return;
    }
    !registry.droppable.exists(id) ? true ? invariant2(false, "Cannot update the scroll on Droppable " + id + " as it is not registered") : invariant2(false) : void 0;
    callbacks.updateDroppableScroll({
      id,
      newScroll
    });
  };
  var scrollDroppable2 = function scrollDroppable3(id, change) {
    if (!collection) {
      return;
    }
    registry.droppable.getById(id).callbacks.scroll(change);
  };
  var stopPublishing = function stopPublishing2() {
    if (!collection) {
      return;
    }
    publisher.stop();
    var home2 = collection.critical.droppable;
    registry.droppable.getAllByType(home2.type).forEach(function(entry) {
      return entry.callbacks.dragStopped();
    });
    collection.unsubscribe();
    collection = null;
  };
  var subscriber = function subscriber2(event) {
    !collection ? true ? invariant2(false, "Should only be subscribed when a collection is occurring") : invariant2(false) : void 0;
    var dragging = collection.critical.draggable;
    if (event.type === "ADDITION") {
      if (shouldPublishUpdate(registry, dragging, event.value)) {
        publisher.add(event.value);
      }
    }
    if (event.type === "REMOVAL") {
      if (shouldPublishUpdate(registry, dragging, event.value)) {
        publisher.remove(event.value);
      }
    }
  };
  var startPublishing = function startPublishing2(request) {
    !!collection ? true ? invariant2(false, "Cannot start capturing critical dimensions as there is already a collection") : invariant2(false) : void 0;
    var entry = registry.draggable.getById(request.draggableId);
    var home2 = registry.droppable.getById(entry.descriptor.droppableId);
    var critical = {
      draggable: entry.descriptor,
      droppable: home2.descriptor
    };
    var unsubscribe = registry.subscribe(subscriber);
    collection = {
      critical,
      unsubscribe
    };
    return getInitialPublish({
      critical,
      registry,
      scrollOptions: request.scrollOptions
    });
  };
  var marshal = {
    updateDroppableIsEnabled: updateDroppableIsEnabled3,
    updateDroppableIsCombineEnabled: updateDroppableIsCombineEnabled3,
    scrollDroppable: scrollDroppable2,
    updateDroppableScroll: updateDroppableScroll3,
    startPublishing,
    stopPublishing
  };
  return marshal;
};
var canStartDrag = function(state, id) {
  if (state.phase === "IDLE") {
    return true;
  }
  if (state.phase !== "DROP_ANIMATING") {
    return false;
  }
  if (state.completed.result.draggableId === id) {
    return false;
  }
  return state.completed.result.reason === "DROP";
};
var scrollWindow = function(change) {
  window.scrollBy(change.x, change.y);
};
var getScrollableDroppables = memoize_one_esm_default(function(droppables) {
  return toDroppableList(droppables).filter(function(droppable2) {
    if (!droppable2.isEnabled) {
      return false;
    }
    if (!droppable2.frame) {
      return false;
    }
    return true;
  });
});
var getScrollableDroppableOver = function getScrollableDroppableOver2(target, droppables) {
  var maybe = find(getScrollableDroppables(droppables), function(droppable2) {
    !droppable2.frame ? true ? invariant2(false, "Invalid result") : invariant2(false) : void 0;
    return isPositionInFrame(droppable2.frame.pageMarginBox)(target);
  });
  return maybe;
};
var getBestScrollableDroppable = function(_ref) {
  var center = _ref.center, destination = _ref.destination, droppables = _ref.droppables;
  if (destination) {
    var _dimension = droppables[destination];
    if (!_dimension.frame) {
      return null;
    }
    return _dimension;
  }
  var dimension = getScrollableDroppableOver(center, droppables);
  return dimension;
};
var config = {
  startFromPercentage: 0.25,
  maxScrollAtPercentage: 0.05,
  maxPixelScroll: 28,
  ease: function ease(percentage) {
    return Math.pow(percentage, 2);
  },
  durationDampening: {
    stopDampeningAt: 1200,
    accelerateAt: 360
  }
};
var getDistanceThresholds = function(container, axis) {
  var startScrollingFrom = container[axis.size] * config.startFromPercentage;
  var maxScrollValueAt = container[axis.size] * config.maxScrollAtPercentage;
  var thresholds2 = {
    startScrollingFrom,
    maxScrollValueAt
  };
  return thresholds2;
};
var getPercentage = function(_ref) {
  var startOfRange = _ref.startOfRange, endOfRange = _ref.endOfRange, current = _ref.current;
  var range = endOfRange - startOfRange;
  if (range === 0) {
    true ? warning2("\n      Detected distance range of 0 in the fluid auto scroller\n      This is unexpected and would cause a divide by 0 issue.\n      Not allowing an auto scroll\n    ") : void 0;
    return 0;
  }
  var currentInRange = current - startOfRange;
  var percentage = currentInRange / range;
  return percentage;
};
var minScroll = 1;
var getValueFromDistance = function(distanceToEdge, thresholds2) {
  if (distanceToEdge > thresholds2.startScrollingFrom) {
    return 0;
  }
  if (distanceToEdge <= thresholds2.maxScrollValueAt) {
    return config.maxPixelScroll;
  }
  if (distanceToEdge === thresholds2.startScrollingFrom) {
    return minScroll;
  }
  var percentageFromMaxScrollValueAt = getPercentage({
    startOfRange: thresholds2.maxScrollValueAt,
    endOfRange: thresholds2.startScrollingFrom,
    current: distanceToEdge
  });
  var percentageFromStartScrollingFrom = 1 - percentageFromMaxScrollValueAt;
  var scroll3 = config.maxPixelScroll * config.ease(percentageFromStartScrollingFrom);
  return Math.ceil(scroll3);
};
var accelerateAt = config.durationDampening.accelerateAt;
var stopAt = config.durationDampening.stopDampeningAt;
var dampenValueByTime = function(proposedScroll, dragStartTime) {
  var startOfRange = dragStartTime;
  var endOfRange = stopAt;
  var now3 = Date.now();
  var runTime = now3 - startOfRange;
  if (runTime >= stopAt) {
    return proposedScroll;
  }
  if (runTime < accelerateAt) {
    return minScroll;
  }
  var betweenAccelerateAtAndStopAtPercentage = getPercentage({
    startOfRange: accelerateAt,
    endOfRange,
    current: runTime
  });
  var scroll3 = proposedScroll * config.ease(betweenAccelerateAtAndStopAtPercentage);
  return Math.ceil(scroll3);
};
var getValue7 = function(_ref) {
  var distanceToEdge = _ref.distanceToEdge, thresholds2 = _ref.thresholds, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var scroll3 = getValueFromDistance(distanceToEdge, thresholds2);
  if (scroll3 === 0) {
    return 0;
  }
  if (!shouldUseTimeDampening) {
    return scroll3;
  }
  return Math.max(dampenValueByTime(scroll3, dragStartTime), minScroll);
};
var getScrollOnAxis = function(_ref) {
  var container = _ref.container, distanceToEdges = _ref.distanceToEdges, dragStartTime = _ref.dragStartTime, axis = _ref.axis, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var thresholds2 = getDistanceThresholds(container, axis);
  var isCloserToEnd = distanceToEdges[axis.end] < distanceToEdges[axis.start];
  if (isCloserToEnd) {
    return getValue7({
      distanceToEdge: distanceToEdges[axis.end],
      thresholds: thresholds2,
      dragStartTime,
      shouldUseTimeDampening
    });
  }
  return -1 * getValue7({
    distanceToEdge: distanceToEdges[axis.start],
    thresholds: thresholds2,
    dragStartTime,
    shouldUseTimeDampening
  });
};
var adjustForSizeLimits = function(_ref) {
  var container = _ref.container, subject = _ref.subject, proposedScroll = _ref.proposedScroll;
  var isTooBigVertically = subject.height > container.height;
  var isTooBigHorizontally = subject.width > container.width;
  if (!isTooBigHorizontally && !isTooBigVertically) {
    return proposedScroll;
  }
  if (isTooBigHorizontally && isTooBigVertically) {
    return null;
  }
  return {
    x: isTooBigHorizontally ? 0 : proposedScroll.x,
    y: isTooBigVertically ? 0 : proposedScroll.y
  };
};
var clean$2 = apply2(function(value) {
  return value === 0 ? 0 : value;
});
var getScroll = function(_ref) {
  var dragStartTime = _ref.dragStartTime, container = _ref.container, subject = _ref.subject, center = _ref.center, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var distanceToEdges = {
    top: center.y - container.top,
    right: container.right - center.x,
    bottom: container.bottom - center.y,
    left: center.x - container.left
  };
  var y9 = getScrollOnAxis({
    container,
    distanceToEdges,
    dragStartTime,
    axis: vertical,
    shouldUseTimeDampening
  });
  var x7 = getScrollOnAxis({
    container,
    distanceToEdges,
    dragStartTime,
    axis: horizontal,
    shouldUseTimeDampening
  });
  var required2 = clean$2({
    x: x7,
    y: y9
  });
  if (isEqual3(required2, origin)) {
    return null;
  }
  var limited = adjustForSizeLimits({
    container,
    subject,
    proposedScroll: required2
  });
  if (!limited) {
    return null;
  }
  return isEqual3(limited, origin) ? null : limited;
};
var smallestSigned = apply2(function(value) {
  if (value === 0) {
    return 0;
  }
  return value > 0 ? 1 : -1;
});
var getOverlap = function() {
  var getRemainder = function getRemainder2(target, max4) {
    if (target < 0) {
      return target;
    }
    if (target > max4) {
      return target - max4;
    }
    return 0;
  };
  return function(_ref) {
    var current = _ref.current, max4 = _ref.max, change = _ref.change;
    var targetScroll = add(current, change);
    var overlap = {
      x: getRemainder(targetScroll.x, max4.x),
      y: getRemainder(targetScroll.y, max4.y)
    };
    if (isEqual3(overlap, origin)) {
      return null;
    }
    return overlap;
  };
}();
var canPartiallyScroll = function canPartiallyScroll2(_ref2) {
  var rawMax = _ref2.max, current = _ref2.current, change = _ref2.change;
  var max4 = {
    x: Math.max(current.x, rawMax.x),
    y: Math.max(current.y, rawMax.y)
  };
  var smallestChange = smallestSigned(change);
  var overlap = getOverlap({
    max: max4,
    current,
    change: smallestChange
  });
  if (!overlap) {
    return true;
  }
  if (smallestChange.x !== 0 && overlap.x === 0) {
    return true;
  }
  if (smallestChange.y !== 0 && overlap.y === 0) {
    return true;
  }
  return false;
};
var canScrollWindow = function canScrollWindow2(viewport, change) {
  return canPartiallyScroll({
    current: viewport.scroll.current,
    max: viewport.scroll.max,
    change
  });
};
var getWindowOverlap = function getWindowOverlap2(viewport, change) {
  if (!canScrollWindow(viewport, change)) {
    return null;
  }
  var max4 = viewport.scroll.max;
  var current = viewport.scroll.current;
  return getOverlap({
    current,
    max: max4,
    change
  });
};
var canScrollDroppable = function canScrollDroppable2(droppable2, change) {
  var frame = droppable2.frame;
  if (!frame) {
    return false;
  }
  return canPartiallyScroll({
    current: frame.scroll.current,
    max: frame.scroll.max,
    change
  });
};
var getDroppableOverlap = function getDroppableOverlap2(droppable2, change) {
  var frame = droppable2.frame;
  if (!frame) {
    return null;
  }
  if (!canScrollDroppable(droppable2, change)) {
    return null;
  }
  return getOverlap({
    current: frame.scroll.current,
    max: frame.scroll.max,
    change
  });
};
var getWindowScrollChange = function(_ref) {
  var viewport = _ref.viewport, subject = _ref.subject, center = _ref.center, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var scroll3 = getScroll({
    dragStartTime,
    container: viewport.frame,
    subject,
    center,
    shouldUseTimeDampening
  });
  return scroll3 && canScrollWindow(viewport, scroll3) ? scroll3 : null;
};
var getDroppableScrollChange = function(_ref) {
  var droppable2 = _ref.droppable, subject = _ref.subject, center = _ref.center, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening;
  var frame = droppable2.frame;
  if (!frame) {
    return null;
  }
  var scroll3 = getScroll({
    dragStartTime,
    container: frame.pageMarginBox,
    subject,
    center,
    shouldUseTimeDampening
  });
  return scroll3 && canScrollDroppable(droppable2, scroll3) ? scroll3 : null;
};
var scroll$1 = function(_ref) {
  var state = _ref.state, dragStartTime = _ref.dragStartTime, shouldUseTimeDampening = _ref.shouldUseTimeDampening, scrollWindow2 = _ref.scrollWindow, scrollDroppable2 = _ref.scrollDroppable;
  var center = state.current.page.borderBoxCenter;
  var draggable2 = state.dimensions.draggables[state.critical.draggable.id];
  var subject = draggable2.page.marginBox;
  if (state.isWindowScrollAllowed) {
    var viewport = state.viewport;
    var _change = getWindowScrollChange({
      dragStartTime,
      viewport,
      subject,
      center,
      shouldUseTimeDampening
    });
    if (_change) {
      scrollWindow2(_change);
      return;
    }
  }
  var droppable2 = getBestScrollableDroppable({
    center,
    destination: whatIsDraggedOver(state.impact),
    droppables: state.dimensions.droppables
  });
  if (!droppable2) {
    return;
  }
  var change = getDroppableScrollChange({
    dragStartTime,
    droppable: droppable2,
    subject,
    center,
    shouldUseTimeDampening
  });
  if (change) {
    scrollDroppable2(droppable2.descriptor.id, change);
  }
};
var createFluidScroller = function(_ref) {
  var scrollWindow2 = _ref.scrollWindow, scrollDroppable2 = _ref.scrollDroppable;
  var scheduleWindowScroll = raf_schd_esm_default(scrollWindow2);
  var scheduleDroppableScroll = raf_schd_esm_default(scrollDroppable2);
  var dragging = null;
  var tryScroll = function tryScroll2(state) {
    !dragging ? true ? invariant2(false, "Cannot fluid scroll if not dragging") : invariant2(false) : void 0;
    var _dragging = dragging, shouldUseTimeDampening = _dragging.shouldUseTimeDampening, dragStartTime = _dragging.dragStartTime;
    scroll$1({
      state,
      scrollWindow: scheduleWindowScroll,
      scrollDroppable: scheduleDroppableScroll,
      dragStartTime,
      shouldUseTimeDampening
    });
  };
  var start$1 = function start$12(state) {
    start();
    !!dragging ? true ? invariant2(false, "Cannot start auto scrolling when already started") : invariant2(false) : void 0;
    var dragStartTime = Date.now();
    var wasScrollNeeded = false;
    var fakeScrollCallback = function fakeScrollCallback2() {
      wasScrollNeeded = true;
    };
    scroll$1({
      state,
      dragStartTime: 0,
      shouldUseTimeDampening: false,
      scrollWindow: fakeScrollCallback,
      scrollDroppable: fakeScrollCallback
    });
    dragging = {
      dragStartTime,
      shouldUseTimeDampening: wasScrollNeeded
    };
    finish();
    if (wasScrollNeeded) {
      tryScroll(state);
    }
  };
  var stop = function stop2() {
    if (!dragging) {
      return;
    }
    scheduleWindowScroll.cancel();
    scheduleDroppableScroll.cancel();
    dragging = null;
  };
  return {
    start: start$1,
    stop,
    scroll: tryScroll
  };
};
var createJumpScroller = function(_ref) {
  var move5 = _ref.move, scrollDroppable2 = _ref.scrollDroppable, scrollWindow2 = _ref.scrollWindow;
  var moveByOffset = function moveByOffset2(state, offset5) {
    var client = add(state.current.client.selection, offset5);
    move5({
      client
    });
  };
  var scrollDroppableAsMuchAsItCan = function scrollDroppableAsMuchAsItCan2(droppable2, change) {
    if (!canScrollDroppable(droppable2, change)) {
      return change;
    }
    var overlap = getDroppableOverlap(droppable2, change);
    if (!overlap) {
      scrollDroppable2(droppable2.descriptor.id, change);
      return null;
    }
    var whatTheDroppableCanScroll = subtract(change, overlap);
    scrollDroppable2(droppable2.descriptor.id, whatTheDroppableCanScroll);
    var remainder = subtract(change, whatTheDroppableCanScroll);
    return remainder;
  };
  var scrollWindowAsMuchAsItCan = function scrollWindowAsMuchAsItCan2(isWindowScrollAllowed, viewport, change) {
    if (!isWindowScrollAllowed) {
      return change;
    }
    if (!canScrollWindow(viewport, change)) {
      return change;
    }
    var overlap = getWindowOverlap(viewport, change);
    if (!overlap) {
      scrollWindow2(change);
      return null;
    }
    var whatTheWindowCanScroll = subtract(change, overlap);
    scrollWindow2(whatTheWindowCanScroll);
    var remainder = subtract(change, whatTheWindowCanScroll);
    return remainder;
  };
  var jumpScroller = function jumpScroller2(state) {
    var request = state.scrollJumpRequest;
    if (!request) {
      return;
    }
    var destination = whatIsDraggedOver(state.impact);
    !destination ? true ? invariant2(false, "Cannot perform a jump scroll when there is no destination") : invariant2(false) : void 0;
    var droppableRemainder = scrollDroppableAsMuchAsItCan(state.dimensions.droppables[destination], request);
    if (!droppableRemainder) {
      return;
    }
    var viewport = state.viewport;
    var windowRemainder = scrollWindowAsMuchAsItCan(state.isWindowScrollAllowed, viewport, droppableRemainder);
    if (!windowRemainder) {
      return;
    }
    moveByOffset(state, windowRemainder);
  };
  return jumpScroller;
};
var createAutoScroller = function(_ref) {
  var scrollDroppable2 = _ref.scrollDroppable, scrollWindow2 = _ref.scrollWindow, move5 = _ref.move;
  var fluidScroller = createFluidScroller({
    scrollWindow: scrollWindow2,
    scrollDroppable: scrollDroppable2
  });
  var jumpScroll = createJumpScroller({
    move: move5,
    scrollWindow: scrollWindow2,
    scrollDroppable: scrollDroppable2
  });
  var scroll3 = function scroll4(state) {
    if (state.phase !== "DRAGGING") {
      return;
    }
    if (state.movementMode === "FLUID") {
      fluidScroller.scroll(state);
      return;
    }
    if (!state.scrollJumpRequest) {
      return;
    }
    jumpScroll(state);
  };
  var scroller = {
    scroll: scroll3,
    start: fluidScroller.start,
    stop: fluidScroller.stop
  };
  return scroller;
};
var prefix$1 = "data-rbd";
var dragHandle = function() {
  var base = prefix$1 + "-drag-handle";
  return {
    base,
    draggableId: base + "-draggable-id",
    contextId: base + "-context-id"
  };
}();
var draggable = function() {
  var base = prefix$1 + "-draggable";
  return {
    base,
    contextId: base + "-context-id",
    id: base + "-id"
  };
}();
var droppable = function() {
  var base = prefix$1 + "-droppable";
  return {
    base,
    contextId: base + "-context-id",
    id: base + "-id"
  };
}();
var scrollContainer = {
  contextId: prefix$1 + "-scroll-container-context-id"
};
var makeGetSelector = function makeGetSelector2(context) {
  return function(attribute) {
    return "[" + attribute + '="' + context + '"]';
  };
};
var getStyles = function getStyles2(rules, property3) {
  return rules.map(function(rule) {
    var value = rule.styles[property3];
    if (!value) {
      return "";
    }
    return rule.selector + " { " + value + " }";
  }).join(" ");
};
var noPointerEvents = "pointer-events: none;";
var getStyles$1 = function(contextId) {
  var getSelector2 = makeGetSelector(contextId);
  var dragHandle$1 = function() {
    var grabCursor = "\n      cursor: -webkit-grab;\n      cursor: grab;\n    ";
    return {
      selector: getSelector2(dragHandle.contextId),
      styles: {
        always: "\n          -webkit-touch-callout: none;\n          -webkit-tap-highlight-color: rgba(0,0,0,0);\n          touch-action: manipulation;\n        ",
        resting: grabCursor,
        dragging: noPointerEvents,
        dropAnimating: grabCursor
      }
    };
  }();
  var draggable$1 = function() {
    var transition = "\n      transition: " + transitions.outOfTheWay + ";\n    ";
    return {
      selector: getSelector2(draggable.contextId),
      styles: {
        dragging: transition,
        dropAnimating: transition,
        userCancel: transition
      }
    };
  }();
  var droppable$1 = {
    selector: getSelector2(droppable.contextId),
    styles: {
      always: "overflow-anchor: none;"
    }
  };
  var body = {
    selector: "body",
    styles: {
      dragging: "\n        cursor: grabbing;\n        cursor: -webkit-grabbing;\n        user-select: none;\n        -webkit-user-select: none;\n        -moz-user-select: none;\n        -ms-user-select: none;\n        overflow-anchor: none;\n      "
    }
  };
  var rules = [draggable$1, dragHandle$1, droppable$1, body];
  return {
    always: getStyles(rules, "always"),
    resting: getStyles(rules, "resting"),
    dragging: getStyles(rules, "dragging"),
    dropAnimating: getStyles(rules, "dropAnimating"),
    userCancel: getStyles(rules, "userCancel")
  };
};
var useIsomorphicLayoutEffect5 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined" ? import_react66.useLayoutEffect : import_react66.useEffect;
var getHead = function getHead2() {
  var head = document.querySelector("head");
  !head ? true ? invariant2(false, "Cannot find the head to append a style to") : invariant2(false) : void 0;
  return head;
};
var createStyleEl = function createStyleEl2(nonce) {
  var el = document.createElement("style");
  if (nonce) {
    el.setAttribute("nonce", nonce);
  }
  el.type = "text/css";
  return el;
};
function useStyleMarshal(contextId, nonce) {
  var styles5 = useMemo11(function() {
    return getStyles$1(contextId);
  }, [contextId]);
  var alwaysRef = (0, import_react66.useRef)(null);
  var dynamicRef = (0, import_react66.useRef)(null);
  var setDynamicStyle = useCallback11(memoize_one_esm_default(function(proposed) {
    var el = dynamicRef.current;
    !el ? true ? invariant2(false, "Cannot set dynamic style element if it is not set") : invariant2(false) : void 0;
    el.textContent = proposed;
  }), []);
  var setAlwaysStyle = useCallback11(function(proposed) {
    var el = alwaysRef.current;
    !el ? true ? invariant2(false, "Cannot set dynamic style element if it is not set") : invariant2(false) : void 0;
    el.textContent = proposed;
  }, []);
  useIsomorphicLayoutEffect5(function() {
    !(!alwaysRef.current && !dynamicRef.current) ? true ? invariant2(false, "style elements already mounted") : invariant2(false) : void 0;
    var always = createStyleEl(nonce);
    var dynamic = createStyleEl(nonce);
    alwaysRef.current = always;
    dynamicRef.current = dynamic;
    always.setAttribute(prefix$1 + "-always", contextId);
    dynamic.setAttribute(prefix$1 + "-dynamic", contextId);
    getHead().appendChild(always);
    getHead().appendChild(dynamic);
    setAlwaysStyle(styles5.always);
    setDynamicStyle(styles5.resting);
    return function() {
      var remove3 = function remove4(ref2) {
        var current = ref2.current;
        !current ? true ? invariant2(false, "Cannot unmount ref as it is not set") : invariant2(false) : void 0;
        getHead().removeChild(current);
        ref2.current = null;
      };
      remove3(alwaysRef);
      remove3(dynamicRef);
    };
  }, [nonce, setAlwaysStyle, setDynamicStyle, styles5.always, styles5.resting, contextId]);
  var dragging = useCallback11(function() {
    return setDynamicStyle(styles5.dragging);
  }, [setDynamicStyle, styles5.dragging]);
  var dropping = useCallback11(function(reason) {
    if (reason === "DROP") {
      setDynamicStyle(styles5.dropAnimating);
      return;
    }
    setDynamicStyle(styles5.userCancel);
  }, [setDynamicStyle, styles5.dropAnimating, styles5.userCancel]);
  var resting = useCallback11(function() {
    if (!dynamicRef.current) {
      return;
    }
    setDynamicStyle(styles5.resting);
  }, [setDynamicStyle, styles5.resting]);
  var marshal = useMemo11(function() {
    return {
      dragging,
      dropping,
      resting
    };
  }, [dragging, dropping, resting]);
  return marshal;
}
var getWindowFromEl = function(el) {
  return el && el.ownerDocument ? el.ownerDocument.defaultView : window;
};
function isHtmlElement2(el) {
  return el instanceof getWindowFromEl(el).HTMLElement;
}
function findDragHandle(contextId, draggableId) {
  var selector = "[" + dragHandle.contextId + '="' + contextId + '"]';
  var possible = toArray(document.querySelectorAll(selector));
  if (!possible.length) {
    true ? warning2('Unable to find any drag handles in the context "' + contextId + '"') : void 0;
    return null;
  }
  var handle = find(possible, function(el) {
    return el.getAttribute(dragHandle.draggableId) === draggableId;
  });
  if (!handle) {
    true ? warning2('Unable to find drag handle with id "' + draggableId + '" as no handle with a matching id was found') : void 0;
    return null;
  }
  if (!isHtmlElement2(handle)) {
    true ? warning2("drag handle needs to be a HTMLElement") : void 0;
    return null;
  }
  return handle;
}
function useFocusMarshal(contextId) {
  var entriesRef = (0, import_react66.useRef)({});
  var recordRef = (0, import_react66.useRef)(null);
  var restoreFocusFrameRef = (0, import_react66.useRef)(null);
  var isMountedRef = (0, import_react66.useRef)(false);
  var register = useCallback11(function register2(id, focus2) {
    var entry = {
      id,
      focus: focus2
    };
    entriesRef.current[id] = entry;
    return function unregister() {
      var entries = entriesRef.current;
      var current = entries[id];
      if (current !== entry) {
        delete entries[id];
      }
    };
  }, []);
  var tryGiveFocus = useCallback11(function tryGiveFocus2(tryGiveFocusTo) {
    var handle = findDragHandle(contextId, tryGiveFocusTo);
    if (handle && handle !== document.activeElement) {
      handle.focus();
    }
  }, [contextId]);
  var tryShiftRecord = useCallback11(function tryShiftRecord2(previous, redirectTo) {
    if (recordRef.current === previous) {
      recordRef.current = redirectTo;
    }
  }, []);
  var tryRestoreFocusRecorded = useCallback11(function tryRestoreFocusRecorded2() {
    if (restoreFocusFrameRef.current) {
      return;
    }
    if (!isMountedRef.current) {
      return;
    }
    restoreFocusFrameRef.current = requestAnimationFrame(function() {
      restoreFocusFrameRef.current = null;
      var record = recordRef.current;
      if (record) {
        tryGiveFocus(record);
      }
    });
  }, [tryGiveFocus]);
  var tryRecordFocus = useCallback11(function tryRecordFocus2(id) {
    recordRef.current = null;
    var focused = document.activeElement;
    if (!focused) {
      return;
    }
    if (focused.getAttribute(dragHandle.draggableId) !== id) {
      return;
    }
    recordRef.current = id;
  }, []);
  useIsomorphicLayoutEffect5(function() {
    isMountedRef.current = true;
    return function clearFrameOnUnmount() {
      isMountedRef.current = false;
      var frameId = restoreFocusFrameRef.current;
      if (frameId) {
        cancelAnimationFrame(frameId);
      }
    };
  }, []);
  var marshal = useMemo11(function() {
    return {
      register,
      tryRecordFocus,
      tryRestoreFocusRecorded,
      tryShiftRecord
    };
  }, [register, tryRecordFocus, tryRestoreFocusRecorded, tryShiftRecord]);
  return marshal;
}
function createRegistry() {
  var entries = {
    draggables: {},
    droppables: {}
  };
  var subscribers = [];
  function subscribe(cb) {
    subscribers.push(cb);
    return function unsubscribe() {
      var index2 = subscribers.indexOf(cb);
      if (index2 === -1) {
        return;
      }
      subscribers.splice(index2, 1);
    };
  }
  function notify3(event) {
    if (subscribers.length) {
      subscribers.forEach(function(cb) {
        return cb(event);
      });
    }
  }
  function findDraggableById(id) {
    return entries.draggables[id] || null;
  }
  function getDraggableById(id) {
    var entry = findDraggableById(id);
    !entry ? true ? invariant2(false, "Cannot find draggable entry with id [" + id + "]") : invariant2(false) : void 0;
    return entry;
  }
  var draggableAPI = {
    register: function register(entry) {
      entries.draggables[entry.descriptor.id] = entry;
      notify3({
        type: "ADDITION",
        value: entry
      });
    },
    update: function update4(entry, last2) {
      var current = entries.draggables[last2.descriptor.id];
      if (!current) {
        return;
      }
      if (current.uniqueId !== entry.uniqueId) {
        return;
      }
      delete entries.draggables[last2.descriptor.id];
      entries.draggables[entry.descriptor.id] = entry;
    },
    unregister: function unregister(entry) {
      var draggableId = entry.descriptor.id;
      var current = findDraggableById(draggableId);
      if (!current) {
        return;
      }
      if (entry.uniqueId !== current.uniqueId) {
        return;
      }
      delete entries.draggables[draggableId];
      notify3({
        type: "REMOVAL",
        value: entry
      });
    },
    getById: getDraggableById,
    findById: findDraggableById,
    exists: function exists(id) {
      return Boolean(findDraggableById(id));
    },
    getAllByType: function getAllByType(type) {
      return values2(entries.draggables).filter(function(entry) {
        return entry.descriptor.type === type;
      });
    }
  };
  function findDroppableById(id) {
    return entries.droppables[id] || null;
  }
  function getDroppableById(id) {
    var entry = findDroppableById(id);
    !entry ? true ? invariant2(false, "Cannot find droppable entry with id [" + id + "]") : invariant2(false) : void 0;
    return entry;
  }
  var droppableAPI = {
    register: function register(entry) {
      entries.droppables[entry.descriptor.id] = entry;
    },
    unregister: function unregister(entry) {
      var current = findDroppableById(entry.descriptor.id);
      if (!current) {
        return;
      }
      if (entry.uniqueId !== current.uniqueId) {
        return;
      }
      delete entries.droppables[entry.descriptor.id];
    },
    getById: getDroppableById,
    findById: findDroppableById,
    exists: function exists(id) {
      return Boolean(findDroppableById(id));
    },
    getAllByType: function getAllByType(type) {
      return values2(entries.droppables).filter(function(entry) {
        return entry.descriptor.type === type;
      });
    }
  };
  function clean4() {
    entries.draggables = {};
    entries.droppables = {};
    subscribers.length = 0;
  }
  return {
    draggable: draggableAPI,
    droppable: droppableAPI,
    subscribe,
    clean: clean4
  };
}
function useRegistry() {
  var registry = useMemo11(createRegistry, []);
  (0, import_react66.useEffect)(function() {
    return function unmount() {
      requestAnimationFrame(registry.clean);
    };
  }, [registry]);
  return registry;
}
var StoreContext = import_react66.default.createContext(null);
var getBodyElement = function() {
  var body = document.body;
  !body ? true ? invariant2(false, "Cannot find document.body") : invariant2(false) : void 0;
  return body;
};
var visuallyHidden = {
  position: "absolute",
  width: "1px",
  height: "1px",
  margin: "-1px",
  border: "0",
  padding: "0",
  overflow: "hidden",
  clip: "rect(0 0 0 0)",
  "clip-path": "inset(100%)"
};
var getId = function getId2(contextId) {
  return "rbd-announcement-" + contextId;
};
function useAnnouncer(contextId) {
  var id = useMemo11(function() {
    return getId(contextId);
  }, [contextId]);
  var ref2 = (0, import_react66.useRef)(null);
  (0, import_react66.useEffect)(function setup() {
    var el = document.createElement("div");
    ref2.current = el;
    el.id = id;
    el.setAttribute("aria-live", "assertive");
    el.setAttribute("aria-atomic", "true");
    _extends(el.style, visuallyHidden);
    getBodyElement().appendChild(el);
    return function cleanup() {
      setTimeout(function remove3() {
        var body = getBodyElement();
        if (body.contains(el)) {
          body.removeChild(el);
        }
        if (el === ref2.current) {
          ref2.current = null;
        }
      });
    };
  }, [id]);
  var announce = useCallback11(function(message) {
    var el = ref2.current;
    if (el) {
      el.textContent = message;
      return;
    }
    true ? warning2('\n      A screen reader message was trying to be announced but it was unable to do so.\n      This can occur if you unmount your <DragDropContext /> in your onDragEnd.\n      Consider calling provided.announce() before the unmount so that the instruction will\n      not be lost for users relying on a screen reader.\n\n      Message not passed to screen reader:\n\n      "' + message + '"\n    ') : void 0;
  }, []);
  return announce;
}
var count = 0;
var defaults2 = {
  separator: "::"
};
function useUniqueId(prefix3, options) {
  if (options === void 0) {
    options = defaults2;
  }
  return useMemo11(function() {
    return "" + prefix3 + options.separator + count++;
  }, [options.separator, prefix3]);
}
function getElementId(_ref) {
  var contextId = _ref.contextId, uniqueId = _ref.uniqueId;
  return "rbd-hidden-text-" + contextId + "-" + uniqueId;
}
function useHiddenTextElement(_ref2) {
  var contextId = _ref2.contextId, text = _ref2.text;
  var uniqueId = useUniqueId("hidden-text", {
    separator: "-"
  });
  var id = useMemo11(function() {
    return getElementId({
      contextId,
      uniqueId
    });
  }, [uniqueId, contextId]);
  (0, import_react66.useEffect)(function mount() {
    var el = document.createElement("div");
    el.id = id;
    el.textContent = text;
    el.style.display = "none";
    getBodyElement().appendChild(el);
    return function unmount() {
      var body = getBodyElement();
      if (body.contains(el)) {
        body.removeChild(el);
      }
    };
  }, [id, text]);
  return id;
}
var AppContext = import_react66.default.createContext(null);
var peerDependencies = {
  react: "^16.8.5 || ^17.0.0 || ^18.0.0",
  "react-dom": "^16.8.5 || ^17.0.0 || ^18.0.0"
};
var semver = /(\d+)\.(\d+)\.(\d+)/;
var getVersion = function getVersion2(value) {
  var result = semver.exec(value);
  !(result != null) ? true ? invariant2(false, "Unable to parse React version " + value) : invariant2(false) : void 0;
  var major = Number(result[1]);
  var minor = Number(result[2]);
  var patch3 = Number(result[3]);
  return {
    major,
    minor,
    patch: patch3,
    raw: value
  };
};
var isSatisfied = function isSatisfied2(expected, actual) {
  if (actual.major > expected.major) {
    return true;
  }
  if (actual.major < expected.major) {
    return false;
  }
  if (actual.minor > expected.minor) {
    return true;
  }
  if (actual.minor < expected.minor) {
    return false;
  }
  return actual.patch >= expected.patch;
};
var checkReactVersion = function(peerDepValue, actualValue) {
  var peerDep = getVersion(peerDepValue);
  var actual = getVersion(actualValue);
  if (isSatisfied(peerDep, actual)) {
    return;
  }
  true ? warning2("\n    React version: [" + actual.raw + "]\n    does not satisfy expected peer dependency version: [" + peerDep.raw + "]\n\n    This can result in run time bugs, and even fatal crashes\n  ") : void 0;
};
var suffix = "\n  We expect a html5 doctype: <!doctype html>\n  This is to ensure consistent browser layout and measurement\n\n  More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/doctype.md\n";
var checkDoctype = function(doc) {
  var doctype = doc.doctype;
  if (!doctype) {
    true ? warning2("\n      No <!doctype html> found.\n\n      " + suffix + "\n    ") : void 0;
    return;
  }
  if (doctype.name.toLowerCase() !== "html") {
    true ? warning2("\n      Unexpected <!doctype> found: (" + doctype.name + ")\n\n      " + suffix + "\n    ") : void 0;
  }
  if (doctype.publicId !== "") {
    true ? warning2("\n      Unexpected <!doctype> publicId found: (" + doctype.publicId + ")\n      A html5 doctype does not have a publicId\n\n      " + suffix + "\n    ") : void 0;
  }
};
function useDev(useHook) {
  if (true) {
    useHook();
  }
}
function useDevSetupWarning(fn2, inputs) {
  useDev(function() {
    (0, import_react66.useEffect)(function() {
      try {
        fn2();
      } catch (e9) {
        error("\n          A setup problem was encountered.\n\n          > " + e9.message + "\n        ");
      }
    }, inputs);
  });
}
function useStartupValidation() {
  useDevSetupWarning(function() {
    checkReactVersion(peerDependencies.react, import_react66.default.version);
    checkDoctype(document);
  }, []);
}
function usePrevious(current) {
  var ref2 = (0, import_react66.useRef)(current);
  (0, import_react66.useEffect)(function() {
    ref2.current = current;
  });
  return ref2;
}
function create4() {
  var lock = null;
  function isClaimed() {
    return Boolean(lock);
  }
  function isActive(value) {
    return value === lock;
  }
  function claim(abandon) {
    !!lock ? true ? invariant2(false, "Cannot claim lock as it is already claimed") : invariant2(false) : void 0;
    var newLock = {
      abandon
    };
    lock = newLock;
    return newLock;
  }
  function release() {
    !lock ? true ? invariant2(false, "Cannot release lock when there is no lock") : invariant2(false) : void 0;
    lock = null;
  }
  function tryAbandon() {
    if (lock) {
      lock.abandon();
      release();
    }
  }
  return {
    isClaimed,
    isActive,
    claim,
    release,
    tryAbandon
  };
}
var tab = 9;
var enter = 13;
var escape = 27;
var space = 32;
var pageUp = 33;
var pageDown = 34;
var end = 35;
var home = 36;
var arrowLeft = 37;
var arrowUp = 38;
var arrowRight = 39;
var arrowDown = 40;
var _preventedKeys;
var preventedKeys = (_preventedKeys = {}, _preventedKeys[enter] = true, _preventedKeys[tab] = true, _preventedKeys);
var preventStandardKeyEvents = function(event) {
  if (preventedKeys[event.keyCode]) {
    event.preventDefault();
  }
};
var supportedEventName = function() {
  var base = "visibilitychange";
  if (typeof document === "undefined") {
    return base;
  }
  var candidates = [base, "ms" + base, "webkit" + base, "moz" + base, "o" + base];
  var supported = find(candidates, function(eventName) {
    return "on" + eventName in document;
  });
  return supported || base;
}();
var primaryButton = 0;
var sloppyClickThreshold = 5;
function isSloppyClickThresholdExceeded(original, current) {
  return Math.abs(current.x - original.x) >= sloppyClickThreshold || Math.abs(current.y - original.y) >= sloppyClickThreshold;
}
var idle$1 = {
  type: "IDLE"
};
function getCaptureBindings(_ref) {
  var cancel = _ref.cancel, completed = _ref.completed, getPhase = _ref.getPhase, setPhase = _ref.setPhase;
  return [{
    eventName: "mousemove",
    fn: function fn2(event) {
      var button = event.button, clientX = event.clientX, clientY = event.clientY;
      if (button !== primaryButton) {
        return;
      }
      var point = {
        x: clientX,
        y: clientY
      };
      var phase = getPhase();
      if (phase.type === "DRAGGING") {
        event.preventDefault();
        phase.actions.move(point);
        return;
      }
      !(phase.type === "PENDING") ? true ? invariant2(false, "Cannot be IDLE") : invariant2(false) : void 0;
      var pending = phase.point;
      if (!isSloppyClickThresholdExceeded(pending, point)) {
        return;
      }
      event.preventDefault();
      var actions = phase.actions.fluidLift(point);
      setPhase({
        type: "DRAGGING",
        actions
      });
    }
  }, {
    eventName: "mouseup",
    fn: function fn2(event) {
      var phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      phase.actions.drop({
        shouldBlockNextClick: true
      });
      completed();
    }
  }, {
    eventName: "mousedown",
    fn: function fn2(event) {
      if (getPhase().type === "DRAGGING") {
        event.preventDefault();
      }
      cancel();
    }
  }, {
    eventName: "keydown",
    fn: function fn2(event) {
      var phase = getPhase();
      if (phase.type === "PENDING") {
        cancel();
        return;
      }
      if (event.keyCode === escape) {
        event.preventDefault();
        cancel();
        return;
      }
      preventStandardKeyEvents(event);
    }
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "scroll",
    options: {
      passive: true,
      capture: false
    },
    fn: function fn2() {
      if (getPhase().type === "PENDING") {
        cancel();
      }
    }
  }, {
    eventName: "webkitmouseforcedown",
    fn: function fn2(event) {
      var phase = getPhase();
      !(phase.type !== "IDLE") ? true ? invariant2(false, "Unexpected phase") : invariant2(false) : void 0;
      if (phase.actions.shouldRespectForcePress()) {
        cancel();
        return;
      }
      event.preventDefault();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useMouseSensor(api) {
  var phaseRef = (0, import_react66.useRef)(idle$1);
  var unbindEventsRef = (0, import_react66.useRef)(noop4);
  var startCaptureBinding = useMemo11(function() {
    return {
      eventName: "mousedown",
      fn: function onMouseDown(event) {
        if (event.defaultPrevented) {
          return;
        }
        if (event.button !== primaryButton) {
          return;
        }
        if (event.ctrlKey || event.metaKey || event.shiftKey || event.altKey) {
          return;
        }
        var draggableId = api.findClosestDraggableId(event);
        if (!draggableId) {
          return;
        }
        var actions = api.tryGetLock(draggableId, stop, {
          sourceEvent: event
        });
        if (!actions) {
          return;
        }
        event.preventDefault();
        var point = {
          x: event.clientX,
          y: event.clientY
        };
        unbindEventsRef.current();
        startPendingDrag(actions, point);
      }
    };
  }, [api]);
  var preventForcePressBinding = useMemo11(function() {
    return {
      eventName: "webkitmouseforcewillbegin",
      fn: function fn2(event) {
        if (event.defaultPrevented) {
          return;
        }
        var id = api.findClosestDraggableId(event);
        if (!id) {
          return;
        }
        var options = api.findOptionsForDraggable(id);
        if (!options) {
          return;
        }
        if (options.shouldRespectForcePress) {
          return;
        }
        if (!api.canGetLock(id)) {
          return;
        }
        event.preventDefault();
      }
    };
  }, [api]);
  var listenForCapture = useCallback11(function listenForCapture2() {
    var options = {
      passive: false,
      capture: true
    };
    unbindEventsRef.current = bindEvents(window, [preventForcePressBinding, startCaptureBinding], options);
  }, [preventForcePressBinding, startCaptureBinding]);
  var stop = useCallback11(function() {
    var current = phaseRef.current;
    if (current.type === "IDLE") {
      return;
    }
    phaseRef.current = idle$1;
    unbindEventsRef.current();
    listenForCapture();
  }, [listenForCapture]);
  var cancel = useCallback11(function() {
    var phase = phaseRef.current;
    stop();
    if (phase.type === "DRAGGING") {
      phase.actions.cancel({
        shouldBlockNextClick: true
      });
    }
    if (phase.type === "PENDING") {
      phase.actions.abort();
    }
  }, [stop]);
  var bindCapturingEvents = useCallback11(function bindCapturingEvents2() {
    var options = {
      capture: true,
      passive: false
    };
    var bindings = getCaptureBindings({
      cancel,
      completed: stop,
      getPhase: function getPhase() {
        return phaseRef.current;
      },
      setPhase: function setPhase(phase) {
        phaseRef.current = phase;
      }
    });
    unbindEventsRef.current = bindEvents(window, bindings, options);
  }, [cancel, stop]);
  var startPendingDrag = useCallback11(function startPendingDrag2(actions, point) {
    !(phaseRef.current.type === "IDLE") ? true ? invariant2(false, "Expected to move from IDLE to PENDING drag") : invariant2(false) : void 0;
    phaseRef.current = {
      type: "PENDING",
      point,
      actions
    };
    bindCapturingEvents();
  }, [bindCapturingEvents]);
  useIsomorphicLayoutEffect5(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
    };
  }, [listenForCapture]);
}
var _scrollJumpKeys;
function noop$1() {
}
var scrollJumpKeys = (_scrollJumpKeys = {}, _scrollJumpKeys[pageDown] = true, _scrollJumpKeys[pageUp] = true, _scrollJumpKeys[home] = true, _scrollJumpKeys[end] = true, _scrollJumpKeys);
function getDraggingBindings(actions, stop) {
  function cancel() {
    stop();
    actions.cancel();
  }
  function drop5() {
    stop();
    actions.drop();
  }
  return [{
    eventName: "keydown",
    fn: function fn2(event) {
      if (event.keyCode === escape) {
        event.preventDefault();
        cancel();
        return;
      }
      if (event.keyCode === space) {
        event.preventDefault();
        drop5();
        return;
      }
      if (event.keyCode === arrowDown) {
        event.preventDefault();
        actions.moveDown();
        return;
      }
      if (event.keyCode === arrowUp) {
        event.preventDefault();
        actions.moveUp();
        return;
      }
      if (event.keyCode === arrowRight) {
        event.preventDefault();
        actions.moveRight();
        return;
      }
      if (event.keyCode === arrowLeft) {
        event.preventDefault();
        actions.moveLeft();
        return;
      }
      if (scrollJumpKeys[event.keyCode]) {
        event.preventDefault();
        return;
      }
      preventStandardKeyEvents(event);
    }
  }, {
    eventName: "mousedown",
    fn: cancel
  }, {
    eventName: "mouseup",
    fn: cancel
  }, {
    eventName: "click",
    fn: cancel
  }, {
    eventName: "touchstart",
    fn: cancel
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "wheel",
    fn: cancel,
    options: {
      passive: true
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useKeyboardSensor(api) {
  var unbindEventsRef = (0, import_react66.useRef)(noop$1);
  var startCaptureBinding = useMemo11(function() {
    return {
      eventName: "keydown",
      fn: function onKeyDown(event) {
        if (event.defaultPrevented) {
          return;
        }
        if (event.keyCode !== space) {
          return;
        }
        var draggableId = api.findClosestDraggableId(event);
        if (!draggableId) {
          return;
        }
        var preDrag = api.tryGetLock(draggableId, stop, {
          sourceEvent: event
        });
        if (!preDrag) {
          return;
        }
        event.preventDefault();
        var isCapturing = true;
        var actions = preDrag.snapLift();
        unbindEventsRef.current();
        function stop() {
          !isCapturing ? true ? invariant2(false, "Cannot stop capturing a keyboard drag when not capturing") : invariant2(false) : void 0;
          isCapturing = false;
          unbindEventsRef.current();
          listenForCapture();
        }
        unbindEventsRef.current = bindEvents(window, getDraggingBindings(actions, stop), {
          capture: true,
          passive: false
        });
      }
    };
  }, [api]);
  var listenForCapture = useCallback11(function tryStartCapture() {
    var options = {
      passive: false,
      capture: true
    };
    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);
  }, [startCaptureBinding]);
  useIsomorphicLayoutEffect5(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
    };
  }, [listenForCapture]);
}
var idle$2 = {
  type: "IDLE"
};
var timeForLongPress = 120;
var forcePressThreshold = 0.15;
function getWindowBindings(_ref) {
  var cancel = _ref.cancel, getPhase = _ref.getPhase;
  return [{
    eventName: "orientationchange",
    fn: cancel
  }, {
    eventName: "resize",
    fn: cancel
  }, {
    eventName: "contextmenu",
    fn: function fn2(event) {
      event.preventDefault();
    }
  }, {
    eventName: "keydown",
    fn: function fn2(event) {
      if (getPhase().type !== "DRAGGING") {
        cancel();
        return;
      }
      if (event.keyCode === escape) {
        event.preventDefault();
      }
      cancel();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function getHandleBindings(_ref2) {
  var cancel = _ref2.cancel, completed = _ref2.completed, getPhase = _ref2.getPhase;
  return [{
    eventName: "touchmove",
    options: {
      capture: false
    },
    fn: function fn2(event) {
      var phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      phase.hasMoved = true;
      var _event$touches$ = event.touches[0], clientX = _event$touches$.clientX, clientY = _event$touches$.clientY;
      var point = {
        x: clientX,
        y: clientY
      };
      event.preventDefault();
      phase.actions.move(point);
    }
  }, {
    eventName: "touchend",
    fn: function fn2(event) {
      var phase = getPhase();
      if (phase.type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      phase.actions.drop({
        shouldBlockNextClick: true
      });
      completed();
    }
  }, {
    eventName: "touchcancel",
    fn: function fn2(event) {
      if (getPhase().type !== "DRAGGING") {
        cancel();
        return;
      }
      event.preventDefault();
      cancel();
    }
  }, {
    eventName: "touchforcechange",
    fn: function fn2(event) {
      var phase = getPhase();
      !(phase.type !== "IDLE") ? true ? invariant2(false) : invariant2(false) : void 0;
      var touch = event.touches[0];
      if (!touch) {
        return;
      }
      var isForcePress = touch.force >= forcePressThreshold;
      if (!isForcePress) {
        return;
      }
      var shouldRespect = phase.actions.shouldRespectForcePress();
      if (phase.type === "PENDING") {
        if (shouldRespect) {
          cancel();
        }
        return;
      }
      if (shouldRespect) {
        if (phase.hasMoved) {
          event.preventDefault();
          return;
        }
        cancel();
        return;
      }
      event.preventDefault();
    }
  }, {
    eventName: supportedEventName,
    fn: cancel
  }];
}
function useTouchSensor(api) {
  var phaseRef = (0, import_react66.useRef)(idle$2);
  var unbindEventsRef = (0, import_react66.useRef)(noop4);
  var getPhase = useCallback11(function getPhase2() {
    return phaseRef.current;
  }, []);
  var setPhase = useCallback11(function setPhase2(phase) {
    phaseRef.current = phase;
  }, []);
  var startCaptureBinding = useMemo11(function() {
    return {
      eventName: "touchstart",
      fn: function onTouchStart(event) {
        if (event.defaultPrevented) {
          return;
        }
        var draggableId = api.findClosestDraggableId(event);
        if (!draggableId) {
          return;
        }
        var actions = api.tryGetLock(draggableId, stop, {
          sourceEvent: event
        });
        if (!actions) {
          return;
        }
        var touch = event.touches[0];
        var clientX = touch.clientX, clientY = touch.clientY;
        var point = {
          x: clientX,
          y: clientY
        };
        unbindEventsRef.current();
        startPendingDrag(actions, point);
      }
    };
  }, [api]);
  var listenForCapture = useCallback11(function listenForCapture2() {
    var options = {
      capture: true,
      passive: false
    };
    unbindEventsRef.current = bindEvents(window, [startCaptureBinding], options);
  }, [startCaptureBinding]);
  var stop = useCallback11(function() {
    var current = phaseRef.current;
    if (current.type === "IDLE") {
      return;
    }
    if (current.type === "PENDING") {
      clearTimeout(current.longPressTimerId);
    }
    setPhase(idle$2);
    unbindEventsRef.current();
    listenForCapture();
  }, [listenForCapture, setPhase]);
  var cancel = useCallback11(function() {
    var phase = phaseRef.current;
    stop();
    if (phase.type === "DRAGGING") {
      phase.actions.cancel({
        shouldBlockNextClick: true
      });
    }
    if (phase.type === "PENDING") {
      phase.actions.abort();
    }
  }, [stop]);
  var bindCapturingEvents = useCallback11(function bindCapturingEvents2() {
    var options = {
      capture: true,
      passive: false
    };
    var args = {
      cancel,
      completed: stop,
      getPhase
    };
    var unbindTarget = bindEvents(window, getHandleBindings(args), options);
    var unbindWindow = bindEvents(window, getWindowBindings(args), options);
    unbindEventsRef.current = function unbindAll() {
      unbindTarget();
      unbindWindow();
    };
  }, [cancel, getPhase, stop]);
  var startDragging = useCallback11(function startDragging2() {
    var phase = getPhase();
    !(phase.type === "PENDING") ? true ? invariant2(false, "Cannot start dragging from phase " + phase.type) : invariant2(false) : void 0;
    var actions = phase.actions.fluidLift(phase.point);
    setPhase({
      type: "DRAGGING",
      actions,
      hasMoved: false
    });
  }, [getPhase, setPhase]);
  var startPendingDrag = useCallback11(function startPendingDrag2(actions, point) {
    !(getPhase().type === "IDLE") ? true ? invariant2(false, "Expected to move from IDLE to PENDING drag") : invariant2(false) : void 0;
    var longPressTimerId = setTimeout(startDragging, timeForLongPress);
    setPhase({
      type: "PENDING",
      point,
      actions,
      longPressTimerId
    });
    bindCapturingEvents();
  }, [bindCapturingEvents, getPhase, setPhase, startDragging]);
  useIsomorphicLayoutEffect5(function mount() {
    listenForCapture();
    return function unmount() {
      unbindEventsRef.current();
      var phase = getPhase();
      if (phase.type === "PENDING") {
        clearTimeout(phase.longPressTimerId);
        setPhase(idle$2);
      }
    };
  }, [getPhase, listenForCapture, setPhase]);
  useIsomorphicLayoutEffect5(function webkitHack() {
    var unbind = bindEvents(window, [{
      eventName: "touchmove",
      fn: function fn2() {
      },
      options: {
        capture: false,
        passive: false
      }
    }]);
    return unbind;
  }, []);
}
function useValidateSensorHooks(sensorHooks) {
  useDev(function() {
    var previousRef = usePrevious(sensorHooks);
    useDevSetupWarning(function() {
      !(previousRef.current.length === sensorHooks.length) ? true ? invariant2(false, "Cannot change the amount of sensor hooks after mounting") : invariant2(false) : void 0;
    });
  });
}
var interactiveTagNames = {
  input: true,
  button: true,
  textarea: true,
  select: true,
  option: true,
  optgroup: true,
  video: true,
  audio: true
};
function isAnInteractiveElement(parent2, current) {
  if (current == null) {
    return false;
  }
  var hasAnInteractiveTag = Boolean(interactiveTagNames[current.tagName.toLowerCase()]);
  if (hasAnInteractiveTag) {
    return true;
  }
  var attribute = current.getAttribute("contenteditable");
  if (attribute === "true" || attribute === "") {
    return true;
  }
  if (current === parent2) {
    return false;
  }
  return isAnInteractiveElement(parent2, current.parentElement);
}
function isEventInInteractiveElement(draggable2, event) {
  var target = event.target;
  if (!isHtmlElement2(target)) {
    return false;
  }
  return isAnInteractiveElement(draggable2, target);
}
var getBorderBoxCenterPosition = function(el) {
  return getRect(el.getBoundingClientRect()).center;
};
function isElement3(el) {
  return el instanceof getWindowFromEl(el).Element;
}
var supportedMatchesName = function() {
  var base = "matches";
  if (typeof document === "undefined") {
    return base;
  }
  var candidates = [base, "msMatchesSelector", "webkitMatchesSelector"];
  var value = find(candidates, function(name2) {
    return name2 in Element.prototype;
  });
  return value || base;
}();
function closestPonyfill(el, selector) {
  if (el == null) {
    return null;
  }
  if (el[supportedMatchesName](selector)) {
    return el;
  }
  return closestPonyfill(el.parentElement, selector);
}
function closest$1(el, selector) {
  if (el.closest) {
    return el.closest(selector);
  }
  return closestPonyfill(el, selector);
}
function getSelector(contextId) {
  return "[" + dragHandle.contextId + '="' + contextId + '"]';
}
function findClosestDragHandleFromEvent(contextId, event) {
  var target = event.target;
  if (!isElement3(target)) {
    true ? warning2("event.target must be a Element") : void 0;
    return null;
  }
  var selector = getSelector(contextId);
  var handle = closest$1(target, selector);
  if (!handle) {
    return null;
  }
  if (!isHtmlElement2(handle)) {
    true ? warning2("drag handle must be a HTMLElement") : void 0;
    return null;
  }
  return handle;
}
function tryGetClosestDraggableIdFromEvent(contextId, event) {
  var handle = findClosestDragHandleFromEvent(contextId, event);
  if (!handle) {
    return null;
  }
  return handle.getAttribute(dragHandle.draggableId);
}
function findDraggable(contextId, draggableId) {
  var selector = "[" + draggable.contextId + '="' + contextId + '"]';
  var possible = toArray(document.querySelectorAll(selector));
  var draggable$1 = find(possible, function(el) {
    return el.getAttribute(draggable.id) === draggableId;
  });
  if (!draggable$1) {
    return null;
  }
  if (!isHtmlElement2(draggable$1)) {
    true ? warning2("Draggable element is not a HTMLElement") : void 0;
    return null;
  }
  return draggable$1;
}
function preventDefault(event) {
  event.preventDefault();
}
function _isActive(_ref) {
  var expected = _ref.expected, phase = _ref.phase, isLockActive = _ref.isLockActive, shouldWarn = _ref.shouldWarn;
  if (!isLockActive()) {
    if (shouldWarn) {
      true ? warning2("\n        Cannot perform action.\n        The sensor no longer has an action lock.\n\n        Tips:\n\n        - Throw away your action handlers when forceStop() is called\n        - Check actions.isActive() if you really need to\n      ") : void 0;
    }
    return false;
  }
  if (expected !== phase) {
    if (shouldWarn) {
      true ? warning2("\n        Cannot perform action.\n        The actions you used belong to an outdated phase\n\n        Current phase: " + expected + "\n        You called an action from outdated phase: " + phase + "\n\n        Tips:\n\n        - Do not use preDragActions actions after calling preDragActions.lift()\n      ") : void 0;
    }
    return false;
  }
  return true;
}
function canStart(_ref2) {
  var lockAPI = _ref2.lockAPI, store = _ref2.store, registry = _ref2.registry, draggableId = _ref2.draggableId;
  if (lockAPI.isClaimed()) {
    return false;
  }
  var entry = registry.draggable.findById(draggableId);
  if (!entry) {
    true ? warning2("Unable to find draggable with id: " + draggableId) : void 0;
    return false;
  }
  if (!entry.options.isEnabled) {
    return false;
  }
  if (!canStartDrag(store.getState(), draggableId)) {
    return false;
  }
  return true;
}
function tryStart(_ref3) {
  var lockAPI = _ref3.lockAPI, contextId = _ref3.contextId, store = _ref3.store, registry = _ref3.registry, draggableId = _ref3.draggableId, forceSensorStop = _ref3.forceSensorStop, sourceEvent = _ref3.sourceEvent;
  var shouldStart = canStart({
    lockAPI,
    store,
    registry,
    draggableId
  });
  if (!shouldStart) {
    return null;
  }
  var entry = registry.draggable.getById(draggableId);
  var el = findDraggable(contextId, entry.descriptor.id);
  if (!el) {
    true ? warning2("Unable to find draggable element with id: " + draggableId) : void 0;
    return null;
  }
  if (sourceEvent && !entry.options.canDragInteractiveElements && isEventInInteractiveElement(el, sourceEvent)) {
    return null;
  }
  var lock = lockAPI.claim(forceSensorStop || noop4);
  var phase = "PRE_DRAG";
  function getShouldRespectForcePress() {
    return entry.options.shouldRespectForcePress;
  }
  function isLockActive() {
    return lockAPI.isActive(lock);
  }
  function tryDispatch(expected, getAction) {
    if (_isActive({
      expected,
      phase,
      isLockActive,
      shouldWarn: true
    })) {
      store.dispatch(getAction());
    }
  }
  var tryDispatchWhenDragging = tryDispatch.bind(null, "DRAGGING");
  function lift$12(args) {
    function completed() {
      lockAPI.release();
      phase = "COMPLETED";
    }
    if (phase !== "PRE_DRAG") {
      completed();
      !(phase === "PRE_DRAG") ? true ? invariant2(false, "Cannot lift in phase " + phase) : invariant2(false) : void 0;
    }
    store.dispatch(lift(args.liftActionArgs));
    phase = "DRAGGING";
    function finish3(reason, options) {
      if (options === void 0) {
        options = {
          shouldBlockNextClick: false
        };
      }
      args.cleanup();
      if (options.shouldBlockNextClick) {
        var unbind = bindEvents(window, [{
          eventName: "click",
          fn: preventDefault,
          options: {
            once: true,
            passive: false,
            capture: true
          }
        }]);
        setTimeout(unbind);
      }
      completed();
      store.dispatch(drop({
        reason
      }));
    }
    return _extends({
      isActive: function isActive() {
        return _isActive({
          expected: "DRAGGING",
          phase,
          isLockActive,
          shouldWarn: false
        });
      },
      shouldRespectForcePress: getShouldRespectForcePress,
      drop: function drop5(options) {
        return finish3("DROP", options);
      },
      cancel: function cancel(options) {
        return finish3("CANCEL", options);
      }
    }, args.actions);
  }
  function fluidLift(clientSelection) {
    var move$1 = raf_schd_esm_default(function(client) {
      tryDispatchWhenDragging(function() {
        return move3({
          client
        });
      });
    });
    var api = lift$12({
      liftActionArgs: {
        id: draggableId,
        clientSelection,
        movementMode: "FLUID"
      },
      cleanup: function cleanup() {
        return move$1.cancel();
      },
      actions: {
        move: move$1
      }
    });
    return _extends({}, api, {
      move: move$1
    });
  }
  function snapLift() {
    var actions = {
      moveUp: function moveUp$1() {
        return tryDispatchWhenDragging(moveUp);
      },
      moveRight: function moveRight$1() {
        return tryDispatchWhenDragging(moveRight);
      },
      moveDown: function moveDown$1() {
        return tryDispatchWhenDragging(moveDown);
      },
      moveLeft: function moveLeft$1() {
        return tryDispatchWhenDragging(moveLeft);
      }
    };
    return lift$12({
      liftActionArgs: {
        id: draggableId,
        clientSelection: getBorderBoxCenterPosition(el),
        movementMode: "SNAP"
      },
      cleanup: noop4,
      actions
    });
  }
  function abortPreDrag() {
    var shouldRelease = _isActive({
      expected: "PRE_DRAG",
      phase,
      isLockActive,
      shouldWarn: true
    });
    if (shouldRelease) {
      lockAPI.release();
    }
  }
  var preDrag = {
    isActive: function isActive() {
      return _isActive({
        expected: "PRE_DRAG",
        phase,
        isLockActive,
        shouldWarn: false
      });
    },
    shouldRespectForcePress: getShouldRespectForcePress,
    fluidLift,
    snapLift,
    abort: abortPreDrag
  };
  return preDrag;
}
var defaultSensors = [useMouseSensor, useKeyboardSensor, useTouchSensor];
function useSensorMarshal(_ref4) {
  var contextId = _ref4.contextId, store = _ref4.store, registry = _ref4.registry, customSensors = _ref4.customSensors, enableDefaultSensors = _ref4.enableDefaultSensors;
  var useSensors = [].concat(enableDefaultSensors ? defaultSensors : [], customSensors || []);
  var lockAPI = (0, import_react66.useState)(function() {
    return create4();
  })[0];
  var tryAbandonLock = useCallback11(function tryAbandonLock2(previous, current) {
    if (previous.isDragging && !current.isDragging) {
      lockAPI.tryAbandon();
    }
  }, [lockAPI]);
  useIsomorphicLayoutEffect5(function listenToStore() {
    var previous = store.getState();
    var unsubscribe = store.subscribe(function() {
      var current = store.getState();
      tryAbandonLock(previous, current);
      previous = current;
    });
    return unsubscribe;
  }, [lockAPI, store, tryAbandonLock]);
  useIsomorphicLayoutEffect5(function() {
    return lockAPI.tryAbandon;
  }, [lockAPI.tryAbandon]);
  var canGetLock = useCallback11(function(draggableId) {
    return canStart({
      lockAPI,
      registry,
      store,
      draggableId
    });
  }, [lockAPI, registry, store]);
  var tryGetLock = useCallback11(function(draggableId, forceStop, options) {
    return tryStart({
      lockAPI,
      registry,
      contextId,
      store,
      draggableId,
      forceSensorStop: forceStop,
      sourceEvent: options && options.sourceEvent ? options.sourceEvent : null
    });
  }, [contextId, lockAPI, registry, store]);
  var findClosestDraggableId = useCallback11(function(event) {
    return tryGetClosestDraggableIdFromEvent(contextId, event);
  }, [contextId]);
  var findOptionsForDraggable = useCallback11(function(id) {
    var entry = registry.draggable.findById(id);
    return entry ? entry.options : null;
  }, [registry.draggable]);
  var tryReleaseLock = useCallback11(function tryReleaseLock2() {
    if (!lockAPI.isClaimed()) {
      return;
    }
    lockAPI.tryAbandon();
    if (store.getState().phase !== "IDLE") {
      store.dispatch(flush());
    }
  }, [lockAPI, store]);
  var isLockClaimed = useCallback11(lockAPI.isClaimed, [lockAPI]);
  var api = useMemo11(function() {
    return {
      canGetLock,
      tryGetLock,
      findClosestDraggableId,
      findOptionsForDraggable,
      tryReleaseLock,
      isLockClaimed
    };
  }, [canGetLock, tryGetLock, findClosestDraggableId, findOptionsForDraggable, tryReleaseLock, isLockClaimed]);
  useValidateSensorHooks(useSensors);
  for (var i15 = 0; i15 < useSensors.length; i15++) {
    useSensors[i15](api);
  }
}
var createResponders = function createResponders2(props) {
  return {
    onBeforeCapture: props.onBeforeCapture,
    onBeforeDragStart: props.onBeforeDragStart,
    onDragStart: props.onDragStart,
    onDragEnd: props.onDragEnd,
    onDragUpdate: props.onDragUpdate
  };
};
function getStore(lazyRef) {
  !lazyRef.current ? true ? invariant2(false, "Could not find store from lazy ref") : invariant2(false) : void 0;
  return lazyRef.current;
}
function App(props) {
  var contextId = props.contextId, setCallbacks = props.setCallbacks, sensors = props.sensors, nonce = props.nonce, dragHandleUsageInstructions2 = props.dragHandleUsageInstructions;
  var lazyStoreRef = (0, import_react66.useRef)(null);
  useStartupValidation();
  var lastPropsRef = usePrevious(props);
  var getResponders = useCallback11(function() {
    return createResponders(lastPropsRef.current);
  }, [lastPropsRef]);
  var announce = useAnnouncer(contextId);
  var dragHandleUsageInstructionsId = useHiddenTextElement({
    contextId,
    text: dragHandleUsageInstructions2
  });
  var styleMarshal = useStyleMarshal(contextId, nonce);
  var lazyDispatch = useCallback11(function(action) {
    getStore(lazyStoreRef).dispatch(action);
  }, []);
  var marshalCallbacks = useMemo11(function() {
    return bindActionCreators({
      publishWhileDragging,
      updateDroppableScroll,
      updateDroppableIsEnabled,
      updateDroppableIsCombineEnabled,
      collectionStarting
    }, lazyDispatch);
  }, [lazyDispatch]);
  var registry = useRegistry();
  var dimensionMarshal = useMemo11(function() {
    return createDimensionMarshal(registry, marshalCallbacks);
  }, [registry, marshalCallbacks]);
  var autoScroller = useMemo11(function() {
    return createAutoScroller(_extends({
      scrollWindow,
      scrollDroppable: dimensionMarshal.scrollDroppable
    }, bindActionCreators({
      move: move3
    }, lazyDispatch)));
  }, [dimensionMarshal.scrollDroppable, lazyDispatch]);
  var focusMarshal = useFocusMarshal(contextId);
  var store = useMemo11(function() {
    return createStore6({
      announce,
      autoScroller,
      dimensionMarshal,
      focusMarshal,
      getResponders,
      styleMarshal
    });
  }, [announce, autoScroller, dimensionMarshal, focusMarshal, getResponders, styleMarshal]);
  if (true) {
    if (lazyStoreRef.current && lazyStoreRef.current !== store) {
      true ? warning2("unexpected store change") : void 0;
    }
  }
  lazyStoreRef.current = store;
  var tryResetStore = useCallback11(function() {
    var current = getStore(lazyStoreRef);
    var state = current.getState();
    if (state.phase !== "IDLE") {
      current.dispatch(flush());
    }
  }, []);
  var isDragging = useCallback11(function() {
    var state = getStore(lazyStoreRef).getState();
    return state.isDragging || state.phase === "DROP_ANIMATING";
  }, []);
  var appCallbacks = useMemo11(function() {
    return {
      isDragging,
      tryAbort: tryResetStore
    };
  }, [isDragging, tryResetStore]);
  setCallbacks(appCallbacks);
  var getCanLift = useCallback11(function(id) {
    return canStartDrag(getStore(lazyStoreRef).getState(), id);
  }, []);
  var getIsMovementAllowed = useCallback11(function() {
    return isMovementAllowed(getStore(lazyStoreRef).getState());
  }, []);
  var appContext = useMemo11(function() {
    return {
      marshal: dimensionMarshal,
      focus: focusMarshal,
      contextId,
      canLift: getCanLift,
      isMovementAllowed: getIsMovementAllowed,
      dragHandleUsageInstructionsId,
      registry
    };
  }, [contextId, dimensionMarshal, dragHandleUsageInstructionsId, focusMarshal, getCanLift, getIsMovementAllowed, registry]);
  useSensorMarshal({
    contextId,
    store,
    registry,
    customSensors: sensors,
    enableDefaultSensors: props.enableDefaultSensors !== false
  });
  (0, import_react66.useEffect)(function() {
    return tryResetStore;
  }, [tryResetStore]);
  return import_react66.default.createElement(AppContext.Provider, {
    value: appContext
  }, import_react66.default.createElement(Provider_default, {
    context: StoreContext,
    store
  }, props.children));
}
var count$1 = 0;
function useInstanceCount() {
  return useMemo11(function() {
    return "" + count$1++;
  }, []);
}
function DragDropContext(props) {
  var contextId = useInstanceCount();
  var dragHandleUsageInstructions2 = props.dragHandleUsageInstructions || preset.dragHandleUsageInstructions;
  return import_react66.default.createElement(ErrorBoundary, null, function(setCallbacks) {
    return import_react66.default.createElement(App, {
      nonce: props.nonce,
      contextId,
      setCallbacks,
      dragHandleUsageInstructions: dragHandleUsageInstructions2,
      enableDefaultSensors: props.enableDefaultSensors,
      sensors: props.sensors,
      onBeforeCapture: props.onBeforeCapture,
      onBeforeDragStart: props.onBeforeDragStart,
      onDragStart: props.onDragStart,
      onDragUpdate: props.onDragUpdate,
      onDragEnd: props.onDragEnd
    }, props.children);
  });
}
var isEqual$1 = function isEqual5(base) {
  return function(value) {
    return base === value;
  };
};
var isScroll = isEqual$1("scroll");
var isAuto = isEqual$1("auto");
var isVisible$1 = isEqual$1("visible");
var isEither = function isEither2(overflow, fn2) {
  return fn2(overflow.overflowX) || fn2(overflow.overflowY);
};
var isBoth = function isBoth2(overflow, fn2) {
  return fn2(overflow.overflowX) && fn2(overflow.overflowY);
};
var isElementScrollable = function isElementScrollable2(el) {
  var style2 = window.getComputedStyle(el);
  var overflow = {
    overflowX: style2.overflowX,
    overflowY: style2.overflowY
  };
  return isEither(overflow, isScroll) || isEither(overflow, isAuto);
};
var isBodyScrollable = function isBodyScrollable2() {
  if (false) {
    return false;
  }
  var body = getBodyElement();
  var html = document.documentElement;
  !html ? true ? invariant2(false) : invariant2(false) : void 0;
  if (!isElementScrollable(body)) {
    return false;
  }
  var htmlStyle = window.getComputedStyle(html);
  var htmlOverflow = {
    overflowX: htmlStyle.overflowX,
    overflowY: htmlStyle.overflowY
  };
  if (isBoth(htmlOverflow, isVisible$1)) {
    return false;
  }
  true ? warning2("\n    We have detected that your <body> element might be a scroll container.\n    We have found no reliable way of detecting whether the <body> element is a scroll container.\n    Under most circumstances a <body> scroll bar will be on the <html> element (document.documentElement)\n\n    Because we cannot determine if the <body> is a scroll container, and generally it is not one,\n    we will be treating the <body> as *not* a scroll container\n\n    More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/how-we-detect-scroll-containers.md\n  ") : void 0;
  return false;
};
var getClosestScrollable = function getClosestScrollable2(el) {
  if (el == null) {
    return null;
  }
  if (el === document.body) {
    return isBodyScrollable() ? el : null;
  }
  if (el === document.documentElement) {
    return null;
  }
  if (!isElementScrollable(el)) {
    return getClosestScrollable2(el.parentElement);
  }
  return el;
};
var checkForNestedScrollContainers = function(scrollable) {
  if (!scrollable) {
    return;
  }
  var anotherScrollParent = getClosestScrollable(scrollable.parentElement);
  if (!anotherScrollParent) {
    return;
  }
  true ? warning2("\n    Droppable: unsupported nested scroll container detected.\n    A Droppable can only have one scroll parent (which can be itself)\n    Nested scroll containers are currently not supported.\n\n    We hope to support nested scroll containers soon: https://github.com/atlassian/react-beautiful-dnd/issues/131\n  ") : void 0;
};
var getScroll$1 = function(el) {
  return {
    x: el.scrollLeft,
    y: el.scrollTop
  };
};
var getIsFixed = function getIsFixed2(el) {
  if (!el) {
    return false;
  }
  var style2 = window.getComputedStyle(el);
  if (style2.position === "fixed") {
    return true;
  }
  return getIsFixed2(el.parentElement);
};
var getEnv = function(start3) {
  var closestScrollable = getClosestScrollable(start3);
  var isFixedOnPage = getIsFixed(start3);
  return {
    closestScrollable,
    isFixedOnPage
  };
};
var getDroppableDimension = function(_ref) {
  var descriptor = _ref.descriptor, isEnabled = _ref.isEnabled, isCombineEnabled = _ref.isCombineEnabled, isFixedOnPage = _ref.isFixedOnPage, direction = _ref.direction, client = _ref.client, page = _ref.page, closest3 = _ref.closest;
  var frame = function() {
    if (!closest3) {
      return null;
    }
    var scrollSize = closest3.scrollSize, frameClient = closest3.client;
    var maxScroll = getMaxScroll({
      scrollHeight: scrollSize.scrollHeight,
      scrollWidth: scrollSize.scrollWidth,
      height: frameClient.paddingBox.height,
      width: frameClient.paddingBox.width
    });
    return {
      pageMarginBox: closest3.page.marginBox,
      frameClient,
      scrollSize,
      shouldClipSubject: closest3.shouldClipSubject,
      scroll: {
        initial: closest3.scroll,
        current: closest3.scroll,
        max: maxScroll,
        diff: {
          value: origin,
          displacement: origin
        }
      }
    };
  }();
  var axis = direction === "vertical" ? vertical : horizontal;
  var subject = getSubject({
    page,
    withPlaceholder: null,
    axis,
    frame
  });
  var dimension = {
    descriptor,
    isCombineEnabled,
    isFixedOnPage,
    axis,
    isEnabled,
    client,
    page,
    frame,
    subject
  };
  return dimension;
};
var getClient = function getClient2(targetRef, closestScrollable) {
  var base = getBox(targetRef);
  if (!closestScrollable) {
    return base;
  }
  if (targetRef !== closestScrollable) {
    return base;
  }
  var top = base.paddingBox.top - closestScrollable.scrollTop;
  var left = base.paddingBox.left - closestScrollable.scrollLeft;
  var bottom = top + closestScrollable.scrollHeight;
  var right = left + closestScrollable.scrollWidth;
  var paddingBox = {
    top,
    right,
    bottom,
    left
  };
  var borderBox = expand(paddingBox, base.border);
  var client = createBox({
    borderBox,
    margin: base.margin,
    border: base.border,
    padding: base.padding
  });
  return client;
};
var getDimension = function(_ref) {
  var ref2 = _ref.ref, descriptor = _ref.descriptor, env = _ref.env, windowScroll = _ref.windowScroll, direction = _ref.direction, isDropDisabled = _ref.isDropDisabled, isCombineEnabled = _ref.isCombineEnabled, shouldClipSubject = _ref.shouldClipSubject;
  var closestScrollable = env.closestScrollable;
  var client = getClient(ref2, closestScrollable);
  var page = withScroll(client, windowScroll);
  var closest3 = function() {
    if (!closestScrollable) {
      return null;
    }
    var frameClient = getBox(closestScrollable);
    var scrollSize = {
      scrollHeight: closestScrollable.scrollHeight,
      scrollWidth: closestScrollable.scrollWidth
    };
    return {
      client: frameClient,
      page: withScroll(frameClient, windowScroll),
      scroll: getScroll$1(closestScrollable),
      scrollSize,
      shouldClipSubject
    };
  }();
  var dimension = getDroppableDimension({
    descriptor,
    isEnabled: !isDropDisabled,
    isCombineEnabled,
    isFixedOnPage: env.isFixedOnPage,
    direction,
    client,
    page,
    closest: closest3
  });
  return dimension;
};
var immediate = {
  passive: false
};
var delayed = {
  passive: true
};
var getListenerOptions = function(options) {
  return options.shouldPublishImmediately ? immediate : delayed;
};
function useRequiredContext(Context) {
  var result = (0, import_react66.useContext)(Context);
  !result ? true ? invariant2(false, "Could not find required context") : invariant2(false) : void 0;
  return result;
}
var getClosestScrollableFromDrag = function getClosestScrollableFromDrag2(dragging) {
  return dragging && dragging.env.closestScrollable || null;
};
function useDroppablePublisher(args) {
  var whileDraggingRef = (0, import_react66.useRef)(null);
  var appContext = useRequiredContext(AppContext);
  var uniqueId = useUniqueId("droppable");
  var registry = appContext.registry, marshal = appContext.marshal;
  var previousRef = usePrevious(args);
  var descriptor = useMemo11(function() {
    return {
      id: args.droppableId,
      type: args.type,
      mode: args.mode
    };
  }, [args.droppableId, args.mode, args.type]);
  var publishedDescriptorRef = (0, import_react66.useRef)(descriptor);
  var memoizedUpdateScroll = useMemo11(function() {
    return memoize_one_esm_default(function(x7, y9) {
      !whileDraggingRef.current ? true ? invariant2(false, "Can only update scroll when dragging") : invariant2(false) : void 0;
      var scroll4 = {
        x: x7,
        y: y9
      };
      marshal.updateDroppableScroll(descriptor.id, scroll4);
    });
  }, [descriptor.id, marshal]);
  var getClosestScroll = useCallback11(function() {
    var dragging = whileDraggingRef.current;
    if (!dragging || !dragging.env.closestScrollable) {
      return origin;
    }
    return getScroll$1(dragging.env.closestScrollable);
  }, []);
  var updateScroll = useCallback11(function() {
    var scroll4 = getClosestScroll();
    memoizedUpdateScroll(scroll4.x, scroll4.y);
  }, [getClosestScroll, memoizedUpdateScroll]);
  var scheduleScrollUpdate = useMemo11(function() {
    return raf_schd_esm_default(updateScroll);
  }, [updateScroll]);
  var onClosestScroll = useCallback11(function() {
    var dragging = whileDraggingRef.current;
    var closest3 = getClosestScrollableFromDrag(dragging);
    !(dragging && closest3) ? true ? invariant2(false, "Could not find scroll options while scrolling") : invariant2(false) : void 0;
    var options = dragging.scrollOptions;
    if (options.shouldPublishImmediately) {
      updateScroll();
      return;
    }
    scheduleScrollUpdate();
  }, [scheduleScrollUpdate, updateScroll]);
  var getDimensionAndWatchScroll = useCallback11(function(windowScroll, options) {
    !!whileDraggingRef.current ? true ? invariant2(false, "Cannot collect a droppable while a drag is occurring") : invariant2(false) : void 0;
    var previous = previousRef.current;
    var ref2 = previous.getDroppableRef();
    !ref2 ? true ? invariant2(false, "Cannot collect without a droppable ref") : invariant2(false) : void 0;
    var env = getEnv(ref2);
    var dragging = {
      ref: ref2,
      descriptor,
      env,
      scrollOptions: options
    };
    whileDraggingRef.current = dragging;
    var dimension = getDimension({
      ref: ref2,
      descriptor,
      env,
      windowScroll,
      direction: previous.direction,
      isDropDisabled: previous.isDropDisabled,
      isCombineEnabled: previous.isCombineEnabled,
      shouldClipSubject: !previous.ignoreContainerClipping
    });
    var scrollable = env.closestScrollable;
    if (scrollable) {
      scrollable.setAttribute(scrollContainer.contextId, appContext.contextId);
      scrollable.addEventListener("scroll", onClosestScroll, getListenerOptions(dragging.scrollOptions));
      if (true) {
        checkForNestedScrollContainers(scrollable);
      }
    }
    return dimension;
  }, [appContext.contextId, descriptor, onClosestScroll, previousRef]);
  var getScrollWhileDragging = useCallback11(function() {
    var dragging = whileDraggingRef.current;
    var closest3 = getClosestScrollableFromDrag(dragging);
    !(dragging && closest3) ? true ? invariant2(false, "Can only recollect Droppable client for Droppables that have a scroll container") : invariant2(false) : void 0;
    return getScroll$1(closest3);
  }, []);
  var dragStopped = useCallback11(function() {
    var dragging = whileDraggingRef.current;
    !dragging ? true ? invariant2(false, "Cannot stop drag when no active drag") : invariant2(false) : void 0;
    var closest3 = getClosestScrollableFromDrag(dragging);
    whileDraggingRef.current = null;
    if (!closest3) {
      return;
    }
    scheduleScrollUpdate.cancel();
    closest3.removeAttribute(scrollContainer.contextId);
    closest3.removeEventListener("scroll", onClosestScroll, getListenerOptions(dragging.scrollOptions));
  }, [onClosestScroll, scheduleScrollUpdate]);
  var scroll3 = useCallback11(function(change) {
    var dragging = whileDraggingRef.current;
    !dragging ? true ? invariant2(false, "Cannot scroll when there is no drag") : invariant2(false) : void 0;
    var closest3 = getClosestScrollableFromDrag(dragging);
    !closest3 ? true ? invariant2(false, "Cannot scroll a droppable with no closest scrollable") : invariant2(false) : void 0;
    closest3.scrollTop += change.y;
    closest3.scrollLeft += change.x;
  }, []);
  var callbacks = useMemo11(function() {
    return {
      getDimensionAndWatchScroll,
      getScrollWhileDragging,
      dragStopped,
      scroll: scroll3
    };
  }, [dragStopped, getDimensionAndWatchScroll, getScrollWhileDragging, scroll3]);
  var entry = useMemo11(function() {
    return {
      uniqueId,
      descriptor,
      callbacks
    };
  }, [callbacks, descriptor, uniqueId]);
  useIsomorphicLayoutEffect5(function() {
    publishedDescriptorRef.current = entry.descriptor;
    registry.droppable.register(entry);
    return function() {
      if (whileDraggingRef.current) {
        true ? warning2("Unsupported: changing the droppableId or type of a Droppable during a drag") : void 0;
        dragStopped();
      }
      registry.droppable.unregister(entry);
    };
  }, [callbacks, descriptor, dragStopped, entry, marshal, registry.droppable]);
  useIsomorphicLayoutEffect5(function() {
    if (!whileDraggingRef.current) {
      return;
    }
    marshal.updateDroppableIsEnabled(publishedDescriptorRef.current.id, !args.isDropDisabled);
  }, [args.isDropDisabled, marshal]);
  useIsomorphicLayoutEffect5(function() {
    if (!whileDraggingRef.current) {
      return;
    }
    marshal.updateDroppableIsCombineEnabled(publishedDescriptorRef.current.id, args.isCombineEnabled);
  }, [args.isCombineEnabled, marshal]);
}
function noop$2() {
}
var empty = {
  width: 0,
  height: 0,
  margin: noSpacing2
};
var getSize = function getSize2(_ref) {
  var isAnimatingOpenOnMount = _ref.isAnimatingOpenOnMount, placeholder2 = _ref.placeholder, animate = _ref.animate;
  if (isAnimatingOpenOnMount) {
    return empty;
  }
  if (animate === "close") {
    return empty;
  }
  return {
    height: placeholder2.client.borderBox.height,
    width: placeholder2.client.borderBox.width,
    margin: placeholder2.client.margin
  };
};
var getStyle = function getStyle2(_ref2) {
  var isAnimatingOpenOnMount = _ref2.isAnimatingOpenOnMount, placeholder2 = _ref2.placeholder, animate = _ref2.animate;
  var size2 = getSize({
    isAnimatingOpenOnMount,
    placeholder: placeholder2,
    animate
  });
  return {
    display: placeholder2.display,
    boxSizing: "border-box",
    width: size2.width,
    height: size2.height,
    marginTop: size2.margin.top,
    marginRight: size2.margin.right,
    marginBottom: size2.margin.bottom,
    marginLeft: size2.margin.left,
    flexShrink: "0",
    flexGrow: "0",
    pointerEvents: "none",
    transition: animate !== "none" ? transitions.placeholder : null
  };
};
function Placeholder(props) {
  var animateOpenTimerRef = (0, import_react66.useRef)(null);
  var tryClearAnimateOpenTimer = useCallback11(function() {
    if (!animateOpenTimerRef.current) {
      return;
    }
    clearTimeout(animateOpenTimerRef.current);
    animateOpenTimerRef.current = null;
  }, []);
  var animate = props.animate, onTransitionEnd = props.onTransitionEnd, onClose = props.onClose, contextId = props.contextId;
  var _useState = (0, import_react66.useState)(props.animate === "open"), isAnimatingOpenOnMount = _useState[0], setIsAnimatingOpenOnMount = _useState[1];
  (0, import_react66.useEffect)(function() {
    if (!isAnimatingOpenOnMount) {
      return noop$2;
    }
    if (animate !== "open") {
      tryClearAnimateOpenTimer();
      setIsAnimatingOpenOnMount(false);
      return noop$2;
    }
    if (animateOpenTimerRef.current) {
      return noop$2;
    }
    animateOpenTimerRef.current = setTimeout(function() {
      animateOpenTimerRef.current = null;
      setIsAnimatingOpenOnMount(false);
    });
    return tryClearAnimateOpenTimer;
  }, [animate, isAnimatingOpenOnMount, tryClearAnimateOpenTimer]);
  var onSizeChangeEnd = useCallback11(function(event) {
    if (event.propertyName !== "height") {
      return;
    }
    onTransitionEnd();
    if (animate === "close") {
      onClose();
    }
  }, [animate, onClose, onTransitionEnd]);
  var style2 = getStyle({
    isAnimatingOpenOnMount,
    animate: props.animate,
    placeholder: props.placeholder
  });
  return import_react66.default.createElement(props.placeholder.tagName, {
    style: style2,
    "data-rbd-placeholder-context-id": contextId,
    onTransitionEnd: onSizeChangeEnd,
    ref: props.innerRef
  });
}
var Placeholder$1 = import_react66.default.memo(Placeholder);
var DroppableContext = import_react66.default.createContext(null);
function checkIsValidInnerRef(el) {
  !(el && isHtmlElement2(el)) ? true ? invariant2(false, "\n    provided.innerRef has not been provided with a HTMLElement.\n\n    You can find a guide on using the innerRef callback functions at:\n    https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/guides/using-inner-ref.md\n  ") : invariant2(false) : void 0;
}
function isBoolean(value) {
  return typeof value === "boolean";
}
function runChecks(args, checks) {
  checks.forEach(function(check) {
    return check(args);
  });
}
var shared = [function required(_ref) {
  var props = _ref.props;
  !props.droppableId ? true ? invariant2(false, "A Droppable requires a droppableId prop") : invariant2(false) : void 0;
  !(typeof props.droppableId === "string") ? true ? invariant2(false, "A Droppable requires a [string] droppableId. Provided: [" + typeof props.droppableId + "]") : invariant2(false) : void 0;
}, function _boolean(_ref2) {
  var props = _ref2.props;
  !isBoolean(props.isDropDisabled) ? true ? invariant2(false, "isDropDisabled must be a boolean") : invariant2(false) : void 0;
  !isBoolean(props.isCombineEnabled) ? true ? invariant2(false, "isCombineEnabled must be a boolean") : invariant2(false) : void 0;
  !isBoolean(props.ignoreContainerClipping) ? true ? invariant2(false, "ignoreContainerClipping must be a boolean") : invariant2(false) : void 0;
}, function ref(_ref3) {
  var getDroppableRef = _ref3.getDroppableRef;
  checkIsValidInnerRef(getDroppableRef());
}];
var standard = [function placeholder(_ref4) {
  var props = _ref4.props, getPlaceholderRef = _ref4.getPlaceholderRef;
  if (!props.placeholder) {
    return;
  }
  var ref2 = getPlaceholderRef();
  if (ref2) {
    return;
  }
  true ? warning2('\n      Droppable setup issue [droppableId: "' + props.droppableId + '"]:\n      DroppableProvided > placeholder could not be found.\n\n      Please be sure to add the {provided.placeholder} React Node as a child of your Droppable.\n      More information: https://github.com/atlassian/react-beautiful-dnd/blob/master/docs/api/droppable.md\n    ') : void 0;
}];
var virtual = [function hasClone(_ref5) {
  var props = _ref5.props;
  !props.renderClone ? true ? invariant2(false, "Must provide a clone render function (renderClone) for virtual lists") : invariant2(false) : void 0;
}, function hasNoPlaceholder(_ref6) {
  var getPlaceholderRef = _ref6.getPlaceholderRef;
  !!getPlaceholderRef() ? true ? invariant2(false, "Expected virtual list to not have a placeholder") : invariant2(false) : void 0;
}];
function useValidation(args) {
  useDevSetupWarning(function() {
    runChecks(args, shared);
    if (args.props.mode === "standard") {
      runChecks(args, standard);
    }
    if (args.props.mode === "virtual") {
      runChecks(args, virtual);
    }
  });
}
var AnimateInOut = function(_React$PureComponent) {
  _inheritsLoose(AnimateInOut2, _React$PureComponent);
  function AnimateInOut2() {
    var _this;
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _React$PureComponent.call.apply(_React$PureComponent, [this].concat(args)) || this;
    _this.state = {
      isVisible: Boolean(_this.props.on),
      data: _this.props.on,
      animate: _this.props.shouldAnimate && _this.props.on ? "open" : "none"
    };
    _this.onClose = function() {
      if (_this.state.animate !== "close") {
        return;
      }
      _this.setState({
        isVisible: false
      });
    };
    return _this;
  }
  AnimateInOut2.getDerivedStateFromProps = function getDerivedStateFromProps(props, state) {
    if (!props.shouldAnimate) {
      return {
        isVisible: Boolean(props.on),
        data: props.on,
        animate: "none"
      };
    }
    if (props.on) {
      return {
        isVisible: true,
        data: props.on,
        animate: "open"
      };
    }
    if (state.isVisible) {
      return {
        isVisible: true,
        data: state.data,
        animate: "close"
      };
    }
    return {
      isVisible: false,
      animate: "close",
      data: null
    };
  };
  var _proto = AnimateInOut2.prototype;
  _proto.render = function render3() {
    if (!this.state.isVisible) {
      return null;
    }
    var provided = {
      onClose: this.onClose,
      data: this.state.data,
      animate: this.state.animate
    };
    return this.props.children(provided);
  };
  return AnimateInOut2;
}(import_react66.default.PureComponent);
var zIndexOptions = {
  dragging: 5e3,
  dropAnimating: 4500
};
var getDraggingTransition = function getDraggingTransition2(shouldAnimateDragMovement, dropping) {
  if (dropping) {
    return transitions.drop(dropping.duration);
  }
  if (shouldAnimateDragMovement) {
    return transitions.snap;
  }
  return transitions.fluid;
};
var getDraggingOpacity = function getDraggingOpacity2(isCombining, isDropAnimating) {
  if (!isCombining) {
    return null;
  }
  return isDropAnimating ? combine.opacity.drop : combine.opacity.combining;
};
var getShouldDraggingAnimate = function getShouldDraggingAnimate2(dragging) {
  if (dragging.forceShouldAnimate != null) {
    return dragging.forceShouldAnimate;
  }
  return dragging.mode === "SNAP";
};
function getDraggingStyle(dragging) {
  var dimension = dragging.dimension;
  var box = dimension.client;
  var offset5 = dragging.offset, combineWith = dragging.combineWith, dropping = dragging.dropping;
  var isCombining = Boolean(combineWith);
  var shouldAnimate = getShouldDraggingAnimate(dragging);
  var isDropAnimating = Boolean(dropping);
  var transform = isDropAnimating ? transforms.drop(offset5, isCombining) : transforms.moveTo(offset5);
  var style2 = {
    position: "fixed",
    top: box.marginBox.top,
    left: box.marginBox.left,
    boxSizing: "border-box",
    width: box.borderBox.width,
    height: box.borderBox.height,
    transition: getDraggingTransition(shouldAnimate, dropping),
    transform,
    opacity: getDraggingOpacity(isCombining, isDropAnimating),
    zIndex: isDropAnimating ? zIndexOptions.dropAnimating : zIndexOptions.dragging,
    pointerEvents: "none"
  };
  return style2;
}
function getSecondaryStyle(secondary) {
  return {
    transform: transforms.moveTo(secondary.offset),
    transition: secondary.shouldAnimateDisplacement ? null : "none"
  };
}
function getStyle$1(mapped) {
  return mapped.type === "DRAGGING" ? getDraggingStyle(mapped) : getSecondaryStyle(mapped);
}
function getDimension$1(descriptor, el, windowScroll) {
  if (windowScroll === void 0) {
    windowScroll = origin;
  }
  var computedStyles = window.getComputedStyle(el);
  var borderBox = el.getBoundingClientRect();
  var client = calculateBox(borderBox, computedStyles);
  var page = withScroll(client, windowScroll);
  var placeholder2 = {
    client,
    tagName: el.tagName.toLowerCase(),
    display: computedStyles.display
  };
  var displaceBy = {
    x: client.marginBox.width,
    y: client.marginBox.height
  };
  var dimension = {
    descriptor,
    placeholder: placeholder2,
    displaceBy,
    client,
    page
  };
  return dimension;
}
function useDraggablePublisher(args) {
  var uniqueId = useUniqueId("draggable");
  var descriptor = args.descriptor, registry = args.registry, getDraggableRef = args.getDraggableRef, canDragInteractiveElements = args.canDragInteractiveElements, shouldRespectForcePress = args.shouldRespectForcePress, isEnabled = args.isEnabled;
  var options = useMemo11(function() {
    return {
      canDragInteractiveElements,
      shouldRespectForcePress,
      isEnabled
    };
  }, [canDragInteractiveElements, isEnabled, shouldRespectForcePress]);
  var getDimension2 = useCallback11(function(windowScroll) {
    var el = getDraggableRef();
    !el ? true ? invariant2(false, "Cannot get dimension when no ref is set") : invariant2(false) : void 0;
    return getDimension$1(descriptor, el, windowScroll);
  }, [descriptor, getDraggableRef]);
  var entry = useMemo11(function() {
    return {
      uniqueId,
      descriptor,
      options,
      getDimension: getDimension2
    };
  }, [descriptor, getDimension2, options, uniqueId]);
  var publishedRef = (0, import_react66.useRef)(entry);
  var isFirstPublishRef = (0, import_react66.useRef)(true);
  useIsomorphicLayoutEffect5(function() {
    registry.draggable.register(publishedRef.current);
    return function() {
      return registry.draggable.unregister(publishedRef.current);
    };
  }, [registry.draggable]);
  useIsomorphicLayoutEffect5(function() {
    if (isFirstPublishRef.current) {
      isFirstPublishRef.current = false;
      return;
    }
    var last2 = publishedRef.current;
    publishedRef.current = entry;
    registry.draggable.update(entry, last2);
  }, [entry, registry.draggable]);
}
function useValidation$1(props, contextId, getRef) {
  useDevSetupWarning(function() {
    function prefix3(id2) {
      return "Draggable[id: " + id2 + "]: ";
    }
    var id = props.draggableId;
    !id ? true ? invariant2(false, "Draggable requires a draggableId") : invariant2(false) : void 0;
    !(typeof id === "string") ? true ? invariant2(false, "Draggable requires a [string] draggableId.\n      Provided: [type: " + typeof id + "] (value: " + id + ")") : invariant2(false) : void 0;
    !isInteger(props.index) ? true ? invariant2(false, prefix3(id) + " requires an integer index prop") : invariant2(false) : void 0;
    if (props.mapped.type === "DRAGGING") {
      return;
    }
    checkIsValidInnerRef(getRef());
    if (props.isEnabled) {
      !findDragHandle(contextId, id) ? true ? invariant2(false, prefix3(id) + " Unable to find drag handle") : invariant2(false) : void 0;
    }
  });
}
function useClonePropValidation(isClone) {
  useDev(function() {
    var initialRef = (0, import_react66.useRef)(isClone);
    useDevSetupWarning(function() {
      !(isClone === initialRef.current) ? true ? invariant2(false, "Draggable isClone prop value changed during component life") : invariant2(false) : void 0;
    }, [isClone]);
  });
}
function preventHtml5Dnd(event) {
  event.preventDefault();
}
function Draggable(props) {
  var ref2 = (0, import_react66.useRef)(null);
  var setRef2 = useCallback11(function(el) {
    ref2.current = el;
  }, []);
  var getRef = useCallback11(function() {
    return ref2.current;
  }, []);
  var _useRequiredContext = useRequiredContext(AppContext), contextId = _useRequiredContext.contextId, dragHandleUsageInstructionsId = _useRequiredContext.dragHandleUsageInstructionsId, registry = _useRequiredContext.registry;
  var _useRequiredContext2 = useRequiredContext(DroppableContext), type = _useRequiredContext2.type, droppableId = _useRequiredContext2.droppableId;
  var descriptor = useMemo11(function() {
    return {
      id: props.draggableId,
      index: props.index,
      type,
      droppableId
    };
  }, [props.draggableId, props.index, type, droppableId]);
  var children = props.children, draggableId = props.draggableId, isEnabled = props.isEnabled, shouldRespectForcePress = props.shouldRespectForcePress, canDragInteractiveElements = props.canDragInteractiveElements, isClone = props.isClone, mapped = props.mapped, dropAnimationFinishedAction = props.dropAnimationFinished;
  useValidation$1(props, contextId, getRef);
  useClonePropValidation(isClone);
  if (!isClone) {
    var forPublisher = useMemo11(function() {
      return {
        descriptor,
        registry,
        getDraggableRef: getRef,
        canDragInteractiveElements,
        shouldRespectForcePress,
        isEnabled
      };
    }, [descriptor, registry, getRef, canDragInteractiveElements, shouldRespectForcePress, isEnabled]);
    useDraggablePublisher(forPublisher);
  }
  var dragHandleProps = useMemo11(function() {
    return isEnabled ? {
      tabIndex: 0,
      role: "button",
      "aria-describedby": dragHandleUsageInstructionsId,
      "data-rbd-drag-handle-draggable-id": draggableId,
      "data-rbd-drag-handle-context-id": contextId,
      draggable: false,
      onDragStart: preventHtml5Dnd
    } : null;
  }, [contextId, dragHandleUsageInstructionsId, draggableId, isEnabled]);
  var onMoveEnd = useCallback11(function(event) {
    if (mapped.type !== "DRAGGING") {
      return;
    }
    if (!mapped.dropping) {
      return;
    }
    if (event.propertyName !== "transform") {
      return;
    }
    dropAnimationFinishedAction();
  }, [dropAnimationFinishedAction, mapped]);
  var provided = useMemo11(function() {
    var style2 = getStyle$1(mapped);
    var onTransitionEnd = mapped.type === "DRAGGING" && mapped.dropping ? onMoveEnd : null;
    var result = {
      innerRef: setRef2,
      draggableProps: {
        "data-rbd-draggable-context-id": contextId,
        "data-rbd-draggable-id": draggableId,
        style: style2,
        onTransitionEnd
      },
      dragHandleProps
    };
    return result;
  }, [contextId, dragHandleProps, draggableId, mapped, onMoveEnd, setRef2]);
  var rubric = useMemo11(function() {
    return {
      draggableId: descriptor.id,
      type: descriptor.type,
      source: {
        index: descriptor.index,
        droppableId: descriptor.droppableId
      }
    };
  }, [descriptor.droppableId, descriptor.id, descriptor.index, descriptor.type]);
  return children(provided, mapped.snapshot, rubric);
}
var isStrictEqual = function(a13, b6) {
  return a13 === b6;
};
var whatIsDraggedOverFromResult = function(result) {
  var combine2 = result.combine, destination = result.destination;
  if (destination) {
    return destination.droppableId;
  }
  if (combine2) {
    return combine2.droppableId;
  }
  return null;
};
var getCombineWithFromResult = function getCombineWithFromResult2(result) {
  return result.combine ? result.combine.draggableId : null;
};
var getCombineWithFromImpact = function getCombineWithFromImpact2(impact) {
  return impact.at && impact.at.type === "COMBINE" ? impact.at.combine.draggableId : null;
};
function getDraggableSelector() {
  var memoizedOffset = memoize_one_esm_default(function(x7, y9) {
    return {
      x: x7,
      y: y9
    };
  });
  var getMemoizedSnapshot = memoize_one_esm_default(function(mode, isClone, draggingOver, combineWith, dropping) {
    return {
      isDragging: true,
      isClone,
      isDropAnimating: Boolean(dropping),
      dropAnimation: dropping,
      mode,
      draggingOver,
      combineWith,
      combineTargetFor: null
    };
  });
  var getMemoizedProps = memoize_one_esm_default(function(offset5, mode, dimension, isClone, draggingOver, combineWith, forceShouldAnimate) {
    return {
      mapped: {
        type: "DRAGGING",
        dropping: null,
        draggingOver,
        combineWith,
        mode,
        offset: offset5,
        dimension,
        forceShouldAnimate,
        snapshot: getMemoizedSnapshot(mode, isClone, draggingOver, combineWith, null)
      }
    };
  });
  var selector = function selector2(state, ownProps) {
    if (state.isDragging) {
      if (state.critical.draggable.id !== ownProps.draggableId) {
        return null;
      }
      var offset5 = state.current.client.offset;
      var dimension = state.dimensions.draggables[ownProps.draggableId];
      var draggingOver = whatIsDraggedOver(state.impact);
      var combineWith = getCombineWithFromImpact(state.impact);
      var forceShouldAnimate = state.forceShouldAnimate;
      return getMemoizedProps(memoizedOffset(offset5.x, offset5.y), state.movementMode, dimension, ownProps.isClone, draggingOver, combineWith, forceShouldAnimate);
    }
    if (state.phase === "DROP_ANIMATING") {
      var completed = state.completed;
      if (completed.result.draggableId !== ownProps.draggableId) {
        return null;
      }
      var isClone = ownProps.isClone;
      var _dimension = state.dimensions.draggables[ownProps.draggableId];
      var result = completed.result;
      var mode = result.mode;
      var _draggingOver = whatIsDraggedOverFromResult(result);
      var _combineWith = getCombineWithFromResult(result);
      var duration = state.dropDuration;
      var dropping = {
        duration,
        curve: curves.drop,
        moveTo: state.newHomeClientOffset,
        opacity: _combineWith ? combine.opacity.drop : null,
        scale: _combineWith ? combine.scale.drop : null
      };
      return {
        mapped: {
          type: "DRAGGING",
          offset: state.newHomeClientOffset,
          dimension: _dimension,
          dropping,
          draggingOver: _draggingOver,
          combineWith: _combineWith,
          mode,
          forceShouldAnimate: null,
          snapshot: getMemoizedSnapshot(mode, isClone, _draggingOver, _combineWith, dropping)
        }
      };
    }
    return null;
  };
  return selector;
}
function getSecondarySnapshot(combineTargetFor) {
  return {
    isDragging: false,
    isDropAnimating: false,
    isClone: false,
    dropAnimation: null,
    mode: null,
    draggingOver: null,
    combineTargetFor,
    combineWith: null
  };
}
var atRest = {
  mapped: {
    type: "SECONDARY",
    offset: origin,
    combineTargetFor: null,
    shouldAnimateDisplacement: true,
    snapshot: getSecondarySnapshot(null)
  }
};
function getSecondarySelector() {
  var memoizedOffset = memoize_one_esm_default(function(x7, y9) {
    return {
      x: x7,
      y: y9
    };
  });
  var getMemoizedSnapshot = memoize_one_esm_default(getSecondarySnapshot);
  var getMemoizedProps = memoize_one_esm_default(function(offset5, combineTargetFor, shouldAnimateDisplacement) {
    if (combineTargetFor === void 0) {
      combineTargetFor = null;
    }
    return {
      mapped: {
        type: "SECONDARY",
        offset: offset5,
        combineTargetFor,
        shouldAnimateDisplacement,
        snapshot: getMemoizedSnapshot(combineTargetFor)
      }
    };
  });
  var getFallback = function getFallback2(combineTargetFor) {
    return combineTargetFor ? getMemoizedProps(origin, combineTargetFor, true) : null;
  };
  var getProps = function getProps2(ownId, draggingId, impact, afterCritical) {
    var visualDisplacement = impact.displaced.visible[ownId];
    var isAfterCriticalInVirtualList = Boolean(afterCritical.inVirtualList && afterCritical.effected[ownId]);
    var combine2 = tryGetCombine(impact);
    var combineTargetFor = combine2 && combine2.draggableId === ownId ? draggingId : null;
    if (!visualDisplacement) {
      if (!isAfterCriticalInVirtualList) {
        return getFallback(combineTargetFor);
      }
      if (impact.displaced.invisible[ownId]) {
        return null;
      }
      var change = negate(afterCritical.displacedBy.point);
      var _offset = memoizedOffset(change.x, change.y);
      return getMemoizedProps(_offset, combineTargetFor, true);
    }
    if (isAfterCriticalInVirtualList) {
      return getFallback(combineTargetFor);
    }
    var displaceBy = impact.displacedBy.point;
    var offset5 = memoizedOffset(displaceBy.x, displaceBy.y);
    return getMemoizedProps(offset5, combineTargetFor, visualDisplacement.shouldAnimate);
  };
  var selector = function selector2(state, ownProps) {
    if (state.isDragging) {
      if (state.critical.draggable.id === ownProps.draggableId) {
        return null;
      }
      return getProps(ownProps.draggableId, state.critical.draggable.id, state.impact, state.afterCritical);
    }
    if (state.phase === "DROP_ANIMATING") {
      var completed = state.completed;
      if (completed.result.draggableId === ownProps.draggableId) {
        return null;
      }
      return getProps(ownProps.draggableId, completed.result.draggableId, completed.impact, completed.afterCritical);
    }
    return null;
  };
  return selector;
}
var makeMapStateToProps = function makeMapStateToProps2() {
  var draggingSelector = getDraggableSelector();
  var secondarySelector = getSecondarySelector();
  var selector = function selector2(state, ownProps) {
    return draggingSelector(state, ownProps) || secondarySelector(state, ownProps) || atRest;
  };
  return selector;
};
var mapDispatchToProps = {
  dropAnimationFinished
};
var ConnectedDraggable = connect_default(makeMapStateToProps, mapDispatchToProps, null, {
  context: StoreContext,
  pure: true,
  areStatePropsEqual: isStrictEqual
})(Draggable);
function PrivateDraggable(props) {
  var droppableContext = useRequiredContext(DroppableContext);
  var isUsingCloneFor = droppableContext.isUsingCloneFor;
  if (isUsingCloneFor === props.draggableId && !props.isClone) {
    return null;
  }
  return import_react66.default.createElement(ConnectedDraggable, props);
}
function PublicDraggable(props) {
  var isEnabled = typeof props.isDragDisabled === "boolean" ? !props.isDragDisabled : true;
  var canDragInteractiveElements = Boolean(props.disableInteractiveElementBlocking);
  var shouldRespectForcePress = Boolean(props.shouldRespectForcePress);
  return import_react66.default.createElement(PrivateDraggable, _extends({}, props, {
    isClone: false,
    isEnabled,
    canDragInteractiveElements,
    shouldRespectForcePress
  }));
}
function Droppable(props) {
  var appContext = (0, import_react66.useContext)(AppContext);
  !appContext ? true ? invariant2(false, "Could not find app context") : invariant2(false) : void 0;
  var contextId = appContext.contextId, isMovementAllowed2 = appContext.isMovementAllowed;
  var droppableRef = (0, import_react66.useRef)(null);
  var placeholderRef = (0, import_react66.useRef)(null);
  var children = props.children, droppableId = props.droppableId, type = props.type, mode = props.mode, direction = props.direction, ignoreContainerClipping = props.ignoreContainerClipping, isDropDisabled = props.isDropDisabled, isCombineEnabled = props.isCombineEnabled, snapshot = props.snapshot, useClone = props.useClone, updateViewportMaxScroll3 = props.updateViewportMaxScroll, getContainerForClone = props.getContainerForClone;
  var getDroppableRef = useCallback11(function() {
    return droppableRef.current;
  }, []);
  var setDroppableRef = useCallback11(function(value) {
    droppableRef.current = value;
  }, []);
  var getPlaceholderRef = useCallback11(function() {
    return placeholderRef.current;
  }, []);
  var setPlaceholderRef = useCallback11(function(value) {
    placeholderRef.current = value;
  }, []);
  useValidation({
    props,
    getDroppableRef,
    getPlaceholderRef
  });
  var onPlaceholderTransitionEnd = useCallback11(function() {
    if (isMovementAllowed2()) {
      updateViewportMaxScroll3({
        maxScroll: getMaxWindowScroll()
      });
    }
  }, [isMovementAllowed2, updateViewportMaxScroll3]);
  useDroppablePublisher({
    droppableId,
    type,
    mode,
    direction,
    isDropDisabled,
    isCombineEnabled,
    ignoreContainerClipping,
    getDroppableRef
  });
  var placeholder2 = import_react66.default.createElement(AnimateInOut, {
    on: props.placeholder,
    shouldAnimate: props.shouldAnimatePlaceholder
  }, function(_ref) {
    var onClose = _ref.onClose, data = _ref.data, animate = _ref.animate;
    return import_react66.default.createElement(Placeholder$1, {
      placeholder: data,
      onClose,
      innerRef: setPlaceholderRef,
      animate,
      contextId,
      onTransitionEnd: onPlaceholderTransitionEnd
    });
  });
  var provided = useMemo11(function() {
    return {
      innerRef: setDroppableRef,
      placeholder: placeholder2,
      droppableProps: {
        "data-rbd-droppable-id": droppableId,
        "data-rbd-droppable-context-id": contextId
      }
    };
  }, [contextId, droppableId, placeholder2, setDroppableRef]);
  var isUsingCloneFor = useClone ? useClone.dragging.draggableId : null;
  var droppableContext = useMemo11(function() {
    return {
      droppableId,
      type,
      isUsingCloneFor
    };
  }, [droppableId, isUsingCloneFor, type]);
  function getClone() {
    if (!useClone) {
      return null;
    }
    var dragging = useClone.dragging, render3 = useClone.render;
    var node = import_react66.default.createElement(PrivateDraggable, {
      draggableId: dragging.draggableId,
      index: dragging.source.index,
      isClone: true,
      isEnabled: true,
      shouldRespectForcePress: false,
      canDragInteractiveElements: true
    }, function(draggableProvided, draggableSnapshot) {
      return render3(draggableProvided, draggableSnapshot, dragging);
    });
    return import_react_dom7.default.createPortal(node, getContainerForClone());
  }
  return import_react66.default.createElement(DroppableContext.Provider, {
    value: droppableContext
  }, children(provided, snapshot), getClone());
}
var isMatchingType = function isMatchingType2(type, critical) {
  return type === critical.droppable.type;
};
var getDraggable = function getDraggable2(critical, dimensions) {
  return dimensions.draggables[critical.draggable.id];
};
var makeMapStateToProps$1 = function makeMapStateToProps3() {
  var idleWithAnimation = {
    placeholder: null,
    shouldAnimatePlaceholder: true,
    snapshot: {
      isDraggingOver: false,
      draggingOverWith: null,
      draggingFromThisWith: null,
      isUsingPlaceholder: false
    },
    useClone: null
  };
  var idleWithoutAnimation = _extends({}, idleWithAnimation, {
    shouldAnimatePlaceholder: false
  });
  var getDraggableRubric = memoize_one_esm_default(function(descriptor) {
    return {
      draggableId: descriptor.id,
      type: descriptor.type,
      source: {
        index: descriptor.index,
        droppableId: descriptor.droppableId
      }
    };
  });
  var getMapProps = memoize_one_esm_default(function(id, isEnabled, isDraggingOverForConsumer, isDraggingOverForImpact, dragging, renderClone) {
    var draggableId = dragging.descriptor.id;
    var isHome = dragging.descriptor.droppableId === id;
    if (isHome) {
      var useClone = renderClone ? {
        render: renderClone,
        dragging: getDraggableRubric(dragging.descriptor)
      } : null;
      var _snapshot = {
        isDraggingOver: isDraggingOverForConsumer,
        draggingOverWith: isDraggingOverForConsumer ? draggableId : null,
        draggingFromThisWith: draggableId,
        isUsingPlaceholder: true
      };
      return {
        placeholder: dragging.placeholder,
        shouldAnimatePlaceholder: false,
        snapshot: _snapshot,
        useClone
      };
    }
    if (!isEnabled) {
      return idleWithoutAnimation;
    }
    if (!isDraggingOverForImpact) {
      return idleWithAnimation;
    }
    var snapshot = {
      isDraggingOver: isDraggingOverForConsumer,
      draggingOverWith: draggableId,
      draggingFromThisWith: null,
      isUsingPlaceholder: true
    };
    return {
      placeholder: dragging.placeholder,
      shouldAnimatePlaceholder: true,
      snapshot,
      useClone: null
    };
  });
  var selector = function selector2(state, ownProps) {
    var id = ownProps.droppableId;
    var type = ownProps.type;
    var isEnabled = !ownProps.isDropDisabled;
    var renderClone = ownProps.renderClone;
    if (state.isDragging) {
      var critical = state.critical;
      if (!isMatchingType(type, critical)) {
        return idleWithoutAnimation;
      }
      var dragging = getDraggable(critical, state.dimensions);
      var isDraggingOver = whatIsDraggedOver(state.impact) === id;
      return getMapProps(id, isEnabled, isDraggingOver, isDraggingOver, dragging, renderClone);
    }
    if (state.phase === "DROP_ANIMATING") {
      var completed = state.completed;
      if (!isMatchingType(type, completed.critical)) {
        return idleWithoutAnimation;
      }
      var _dragging = getDraggable(completed.critical, state.dimensions);
      return getMapProps(id, isEnabled, whatIsDraggedOverFromResult(completed.result) === id, whatIsDraggedOver(completed.impact) === id, _dragging, renderClone);
    }
    if (state.phase === "IDLE" && state.completed && !state.shouldFlush) {
      var _completed = state.completed;
      if (!isMatchingType(type, _completed.critical)) {
        return idleWithoutAnimation;
      }
      var wasOver = whatIsDraggedOver(_completed.impact) === id;
      var wasCombining = Boolean(_completed.impact.at && _completed.impact.at.type === "COMBINE");
      var isHome = _completed.critical.droppable.id === id;
      if (wasOver) {
        return wasCombining ? idleWithAnimation : idleWithoutAnimation;
      }
      if (isHome) {
        return idleWithAnimation;
      }
      return idleWithoutAnimation;
    }
    return idleWithoutAnimation;
  };
  return selector;
};
var mapDispatchToProps$1 = {
  updateViewportMaxScroll
};
function getBody() {
  !document.body ? true ? invariant2(false, "document.body is not ready") : invariant2(false) : void 0;
  return document.body;
}
var defaultProps2 = {
  mode: "standard",
  type: "DEFAULT",
  direction: "vertical",
  isDropDisabled: false,
  isCombineEnabled: false,
  ignoreContainerClipping: false,
  renderClone: null,
  getContainerForClone: getBody
};
var ConnectedDroppable = connect_default(makeMapStateToProps$1, mapDispatchToProps$1, null, {
  context: StoreContext,
  pure: true,
  areStatePropsEqual: isStrictEqual
})(Droppable);
ConnectedDroppable.defaultProps = defaultProps2;

// node_modules/@tinacms/toolkit/dist/index.es.js
var import_is_hotkey2 = __toESM(require_lib4());

// node_modules/react-color/es/components/alpha/Alpha.js
var import_react77 = __toESM(require_react());
var import_reactcss9 = __toESM(require_lib5());

// node_modules/react-color/es/components/common/Alpha.js
var import_react68 = __toESM(require_react());
var import_reactcss2 = __toESM(require_lib5());

// node_modules/react-color/es/helpers/alpha.js
var calculateChange = function calculateChange2(e9, hsl, direction, initialA, container) {
  var containerWidth = container.clientWidth;
  var containerHeight = container.clientHeight;
  var x7 = typeof e9.pageX === "number" ? e9.pageX : e9.touches[0].pageX;
  var y9 = typeof e9.pageY === "number" ? e9.pageY : e9.touches[0].pageY;
  var left = x7 - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y9 - (container.getBoundingClientRect().top + window.pageYOffset);
  if (direction === "vertical") {
    var a13 = void 0;
    if (top < 0) {
      a13 = 0;
    } else if (top > containerHeight) {
      a13 = 1;
    } else {
      a13 = Math.round(top * 100 / containerHeight) / 100;
    }
    if (hsl.a !== a13) {
      return {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: a13,
        source: "rgb"
      };
    }
  } else {
    var _a = void 0;
    if (left < 0) {
      _a = 0;
    } else if (left > containerWidth) {
      _a = 1;
    } else {
      _a = Math.round(left * 100 / containerWidth) / 100;
    }
    if (initialA !== _a) {
      return {
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: _a,
        source: "rgb"
      };
    }
  }
  return null;
};

// node_modules/react-color/es/components/common/Checkboard.js
var import_react67 = __toESM(require_react());
var import_reactcss = __toESM(require_lib5());

// node_modules/react-color/es/helpers/checkboard.js
var checkboardCache = {};
var render = function render2(c1, c22, size2, serverCanvas) {
  if (typeof document === "undefined" && !serverCanvas) {
    return null;
  }
  var canvas = serverCanvas ? new serverCanvas() : document.createElement("canvas");
  canvas.width = size2 * 2;
  canvas.height = size2 * 2;
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return null;
  }
  ctx.fillStyle = c1;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = c22;
  ctx.fillRect(0, 0, size2, size2);
  ctx.translate(size2, size2);
  ctx.fillRect(0, 0, size2, size2);
  return canvas.toDataURL();
};
var get3 = function get4(c1, c22, size2, serverCanvas) {
  var key = c1 + "-" + c22 + "-" + size2 + (serverCanvas ? "-server" : "");
  if (checkboardCache[key]) {
    return checkboardCache[key];
  }
  var checkboard = render(c1, c22, size2, serverCanvas);
  checkboardCache[key] = checkboard;
  return checkboard;
};

// node_modules/react-color/es/components/common/Checkboard.js
var _extends7 = Object.assign || function(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var Checkboard = function Checkboard2(_ref) {
  var white = _ref.white, grey = _ref.grey, size2 = _ref.size, renderers = _ref.renderers, borderRadius = _ref.borderRadius, boxShadow = _ref.boxShadow, children = _ref.children;
  var styles5 = (0, import_reactcss.default)({
    "default": {
      grid: {
        borderRadius,
        boxShadow,
        absolute: "0px 0px 0px 0px",
        background: "url(" + get3(white, grey, size2, renderers.canvas) + ") center left"
      }
    }
  });
  return (0, import_react67.isValidElement)(children) ? import_react67.default.cloneElement(children, _extends7({}, children.props, { style: _extends7({}, children.props.style, styles5.grid) })) : import_react67.default.createElement("div", { style: styles5.grid });
};
Checkboard.defaultProps = {
  size: 8,
  white: "transparent",
  grey: "rgba(0,0,0,.08)",
  renderers: {}
};
var Checkboard_default = Checkboard;

// node_modules/react-color/es/components/common/Alpha.js
var _extends8 = Object.assign || function(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass = function() {
  function defineProperties(target, props) {
    for (var i15 = 0; i15 < props.length; i15++) {
      var descriptor = props[i15];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Alpha = function(_ref) {
  _inherits(Alpha2, _ref);
  function Alpha2() {
    var _ref2;
    var _temp, _this, _ret;
    _classCallCheck(this, Alpha2);
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref2 = Alpha2.__proto__ || Object.getPrototypeOf(Alpha2)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function(e9) {
      var change = calculateChange(e9, _this.props.hsl, _this.props.direction, _this.props.a, _this.container);
      change && typeof _this.props.onChange === "function" && _this.props.onChange(change, e9);
    }, _this.handleMouseDown = function(e9) {
      _this.handleChange(e9);
      window.addEventListener("mousemove", _this.handleChange);
      window.addEventListener("mouseup", _this.handleMouseUp);
    }, _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    }, _this.unbindEventListeners = function() {
      window.removeEventListener("mousemove", _this.handleChange);
      window.removeEventListener("mouseup", _this.handleMouseUp);
    }, _temp), _possibleConstructorReturn(_this, _ret);
  }
  _createClass(Alpha2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var rgb = this.props.rgb;
      var styles5 = (0, import_reactcss2.default)({
        "default": {
          alpha: {
            absolute: "0px 0px 0px 0px",
            borderRadius: this.props.radius
          },
          checkboard: {
            absolute: "0px 0px 0px 0px",
            overflow: "hidden",
            borderRadius: this.props.radius
          },
          gradient: {
            absolute: "0px 0px 0px 0px",
            background: "linear-gradient(to right, rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 0) 0%,\n           rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 1) 100%)",
            boxShadow: this.props.shadow,
            borderRadius: this.props.radius
          },
          container: {
            position: "relative",
            height: "100%",
            margin: "0 3px"
          },
          pointer: {
            position: "absolute",
            left: rgb.a * 100 + "%"
          },
          slider: {
            width: "4px",
            borderRadius: "1px",
            height: "8px",
            boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
            background: "#fff",
            marginTop: "1px",
            transform: "translateX(-2px)"
          }
        },
        "vertical": {
          gradient: {
            background: "linear-gradient(to bottom, rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 0) 0%,\n           rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + ", 1) 100%)"
          },
          pointer: {
            left: 0,
            top: rgb.a * 100 + "%"
          }
        },
        "overwrite": _extends8({}, this.props.style)
      }, {
        vertical: this.props.direction === "vertical",
        overwrite: true
      });
      return import_react68.default.createElement(
        "div",
        { style: styles5.alpha },
        import_react68.default.createElement(
          "div",
          { style: styles5.checkboard },
          import_react68.default.createElement(Checkboard_default, { renderers: this.props.renderers })
        ),
        import_react68.default.createElement("div", { style: styles5.gradient }),
        import_react68.default.createElement(
          "div",
          {
            style: styles5.container,
            ref: function ref2(container) {
              return _this2.container = container;
            },
            onMouseDown: this.handleMouseDown,
            onTouchMove: this.handleChange,
            onTouchStart: this.handleChange
          },
          import_react68.default.createElement(
            "div",
            { style: styles5.pointer },
            this.props.pointer ? import_react68.default.createElement(this.props.pointer, this.props) : import_react68.default.createElement("div", { style: styles5.slider })
          )
        )
      );
    }
  }]);
  return Alpha2;
}(import_react68.PureComponent || import_react68.Component);
var Alpha_default = Alpha;

// node_modules/react-color/es/components/common/EditableInput.js
var import_react69 = __toESM(require_react());
var import_reactcss3 = __toESM(require_lib5());
var _createClass2 = function() {
  function defineProperties(target, props) {
    for (var i15 = 0; i15 < props.length; i15++) {
      var descriptor = props[i15];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _defineProperty7(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn2(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var DEFAULT_ARROW_OFFSET = 1;
var UP_KEY_CODE = 38;
var DOWN_KEY_CODE = 40;
var VALID_KEY_CODES = [UP_KEY_CODE, DOWN_KEY_CODE];
var isValidKeyCode = function isValidKeyCode2(keyCode) {
  return VALID_KEY_CODES.indexOf(keyCode) > -1;
};
var getNumberValue = function getNumberValue2(value) {
  return Number(String(value).replace(/%/g, ""));
};
var idCounter2 = 1;
var EditableInput = function(_ref) {
  _inherits2(EditableInput2, _ref);
  function EditableInput2(props) {
    _classCallCheck2(this, EditableInput2);
    var _this = _possibleConstructorReturn2(this, (EditableInput2.__proto__ || Object.getPrototypeOf(EditableInput2)).call(this));
    _this.handleBlur = function() {
      if (_this.state.blurValue) {
        _this.setState({ value: _this.state.blurValue, blurValue: null });
      }
    };
    _this.handleChange = function(e9) {
      _this.setUpdatedValue(e9.target.value, e9);
    };
    _this.handleKeyDown = function(e9) {
      var value = getNumberValue(e9.target.value);
      if (!isNaN(value) && isValidKeyCode(e9.keyCode)) {
        var offset5 = _this.getArrowOffset();
        var updatedValue = e9.keyCode === UP_KEY_CODE ? value + offset5 : value - offset5;
        _this.setUpdatedValue(updatedValue, e9);
      }
    };
    _this.handleDrag = function(e9) {
      if (_this.props.dragLabel) {
        var newValue = Math.round(_this.props.value + e9.movementX);
        if (newValue >= 0 && newValue <= _this.props.dragMax) {
          _this.props.onChange && _this.props.onChange(_this.getValueObjectWithLabel(newValue), e9);
        }
      }
    };
    _this.handleMouseDown = function(e9) {
      if (_this.props.dragLabel) {
        e9.preventDefault();
        _this.handleDrag(e9);
        window.addEventListener("mousemove", _this.handleDrag);
        window.addEventListener("mouseup", _this.handleMouseUp);
      }
    };
    _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    };
    _this.unbindEventListeners = function() {
      window.removeEventListener("mousemove", _this.handleDrag);
      window.removeEventListener("mouseup", _this.handleMouseUp);
    };
    _this.state = {
      value: String(props.value).toUpperCase(),
      blurValue: String(props.value).toUpperCase()
    };
    _this.inputId = "rc-editable-input-" + idCounter2++;
    return _this;
  }
  _createClass2(EditableInput2, [{
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps, prevState) {
      if (this.props.value !== this.state.value && (prevProps.value !== this.props.value || prevState.value !== this.state.value)) {
        if (this.input === document.activeElement) {
          this.setState({ blurValue: String(this.props.value).toUpperCase() });
        } else {
          this.setState({ value: String(this.props.value).toUpperCase(), blurValue: !this.state.blurValue && String(this.props.value).toUpperCase() });
        }
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: "getValueObjectWithLabel",
    value: function getValueObjectWithLabel(value) {
      return _defineProperty7({}, this.props.label, value);
    }
  }, {
    key: "getArrowOffset",
    value: function getArrowOffset() {
      return this.props.arrowOffset || DEFAULT_ARROW_OFFSET;
    }
  }, {
    key: "setUpdatedValue",
    value: function setUpdatedValue(value, e9) {
      var onChangeValue = this.props.label ? this.getValueObjectWithLabel(value) : value;
      this.props.onChange && this.props.onChange(onChangeValue, e9);
      this.setState({ value });
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var styles5 = (0, import_reactcss3.default)({
        "default": {
          wrap: {
            position: "relative"
          }
        },
        "user-override": {
          wrap: this.props.style && this.props.style.wrap ? this.props.style.wrap : {},
          input: this.props.style && this.props.style.input ? this.props.style.input : {},
          label: this.props.style && this.props.style.label ? this.props.style.label : {}
        },
        "dragLabel-true": {
          label: {
            cursor: "ew-resize"
          }
        }
      }, {
        "user-override": true
      }, this.props);
      return import_react69.default.createElement(
        "div",
        { style: styles5.wrap },
        import_react69.default.createElement("input", {
          id: this.inputId,
          style: styles5.input,
          ref: function ref2(input) {
            return _this2.input = input;
          },
          value: this.state.value,
          onKeyDown: this.handleKeyDown,
          onChange: this.handleChange,
          onBlur: this.handleBlur,
          placeholder: this.props.placeholder,
          spellCheck: "false"
        }),
        this.props.label && !this.props.hideLabel ? import_react69.default.createElement(
          "label",
          {
            htmlFor: this.inputId,
            style: styles5.label,
            onMouseDown: this.handleMouseDown
          },
          this.props.label
        ) : null
      );
    }
  }]);
  return EditableInput2;
}(import_react69.PureComponent || import_react69.Component);
var EditableInput_default = EditableInput;

// node_modules/react-color/es/components/common/Hue.js
var import_react70 = __toESM(require_react());
var import_reactcss4 = __toESM(require_lib5());

// node_modules/react-color/es/helpers/hue.js
var calculateChange3 = function calculateChange4(e9, direction, hsl, container) {
  var containerWidth = container.clientWidth;
  var containerHeight = container.clientHeight;
  var x7 = typeof e9.pageX === "number" ? e9.pageX : e9.touches[0].pageX;
  var y9 = typeof e9.pageY === "number" ? e9.pageY : e9.touches[0].pageY;
  var left = x7 - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y9 - (container.getBoundingClientRect().top + window.pageYOffset);
  if (direction === "vertical") {
    var h11 = void 0;
    if (top < 0) {
      h11 = 359;
    } else if (top > containerHeight) {
      h11 = 0;
    } else {
      var percent = -(top * 100 / containerHeight) + 100;
      h11 = 360 * percent / 100;
    }
    if (hsl.h !== h11) {
      return {
        h: h11,
        s: hsl.s,
        l: hsl.l,
        a: hsl.a,
        source: "hsl"
      };
    }
  } else {
    var _h = void 0;
    if (left < 0) {
      _h = 0;
    } else if (left > containerWidth) {
      _h = 359;
    } else {
      var _percent = left * 100 / containerWidth;
      _h = 360 * _percent / 100;
    }
    if (hsl.h !== _h) {
      return {
        h: _h,
        s: hsl.s,
        l: hsl.l,
        a: hsl.a,
        source: "hsl"
      };
    }
  }
  return null;
};

// node_modules/react-color/es/components/common/Hue.js
var _createClass3 = function() {
  function defineProperties(target, props) {
    for (var i15 = 0; i15 < props.length; i15++) {
      var descriptor = props[i15];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn3(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Hue = function(_ref) {
  _inherits3(Hue2, _ref);
  function Hue2() {
    var _ref2;
    var _temp, _this, _ret;
    _classCallCheck3(this, Hue2);
    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return _ret = (_temp = (_this = _possibleConstructorReturn3(this, (_ref2 = Hue2.__proto__ || Object.getPrototypeOf(Hue2)).call.apply(_ref2, [this].concat(args))), _this), _this.handleChange = function(e9) {
      var change = calculateChange3(e9, _this.props.direction, _this.props.hsl, _this.container);
      change && typeof _this.props.onChange === "function" && _this.props.onChange(change, e9);
    }, _this.handleMouseDown = function(e9) {
      _this.handleChange(e9);
      window.addEventListener("mousemove", _this.handleChange);
      window.addEventListener("mouseup", _this.handleMouseUp);
    }, _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    }, _temp), _possibleConstructorReturn3(_this, _ret);
  }
  _createClass3(Hue2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.unbindEventListeners();
    }
  }, {
    key: "unbindEventListeners",
    value: function unbindEventListeners() {
      window.removeEventListener("mousemove", this.handleChange);
      window.removeEventListener("mouseup", this.handleMouseUp);
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var _props$direction = this.props.direction, direction = _props$direction === void 0 ? "horizontal" : _props$direction;
      var styles5 = (0, import_reactcss4.default)({
        "default": {
          hue: {
            absolute: "0px 0px 0px 0px",
            borderRadius: this.props.radius,
            boxShadow: this.props.shadow
          },
          container: {
            padding: "0 2px",
            position: "relative",
            height: "100%",
            borderRadius: this.props.radius
          },
          pointer: {
            position: "absolute",
            left: this.props.hsl.h * 100 / 360 + "%"
          },
          slider: {
            marginTop: "1px",
            width: "4px",
            borderRadius: "1px",
            height: "8px",
            boxShadow: "0 0 2px rgba(0, 0, 0, .6)",
            background: "#fff",
            transform: "translateX(-2px)"
          }
        },
        "vertical": {
          pointer: {
            left: "0px",
            top: -(this.props.hsl.h * 100 / 360) + 100 + "%"
          }
        }
      }, { vertical: direction === "vertical" });
      return import_react70.default.createElement(
        "div",
        { style: styles5.hue },
        import_react70.default.createElement(
          "div",
          {
            className: "hue-" + direction,
            style: styles5.container,
            ref: function ref2(container) {
              return _this2.container = container;
            },
            onMouseDown: this.handleMouseDown,
            onTouchMove: this.handleChange,
            onTouchStart: this.handleChange
          },
          import_react70.default.createElement(
            "style",
            null,
            "\n            .hue-horizontal {\n              background: linear-gradient(to right, #f00 0%, #ff0 17%, #0f0\n                33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to right, #f00 0%, #ff0\n                17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n\n            .hue-vertical {\n              background: linear-gradient(to top, #f00 0%, #ff0 17%, #0f0 33%,\n                #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n              background: -webkit-linear-gradient(to top, #f00 0%, #ff0 17%,\n                #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, #f00 100%);\n            }\n          "
          ),
          import_react70.default.createElement(
            "div",
            { style: styles5.pointer },
            this.props.pointer ? import_react70.default.createElement(this.props.pointer, this.props) : import_react70.default.createElement("div", { style: styles5.slider })
          )
        )
      );
    }
  }]);
  return Hue2;
}(import_react70.PureComponent || import_react70.Component);
var Hue_default = Hue;

// node_modules/react-color/es/components/common/Raised.js
var import_react71 = __toESM(require_react());
var import_prop_types3 = __toESM(require_prop_types());
var import_reactcss5 = __toESM(require_lib5());

// node_modules/lodash-es/_listCacheClear.js
function listCacheClear5() {
  this.__data__ = [];
  this.size = 0;
}
var listCacheClear_default = listCacheClear5;

// node_modules/lodash-es/eq.js
function eq5(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_default = eq5;

// node_modules/lodash-es/_assocIndexOf.js
function assocIndexOf5(array2, key) {
  var length = array2.length;
  while (length--) {
    if (eq_default(array2[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var assocIndexOf_default = assocIndexOf5;

// node_modules/lodash-es/_listCacheDelete.js
var arrayProto5 = Array.prototype;
var splice5 = arrayProto5.splice;
function listCacheDelete5(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  if (index2 < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index2 == lastIndex) {
    data.pop();
  } else {
    splice5.call(data, index2, 1);
  }
  --this.size;
  return true;
}
var listCacheDelete_default = listCacheDelete5;

// node_modules/lodash-es/_listCacheGet.js
function listCacheGet5(key) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  return index2 < 0 ? void 0 : data[index2][1];
}
var listCacheGet_default = listCacheGet5;

// node_modules/lodash-es/_listCacheHas.js
function listCacheHas5(key) {
  return assocIndexOf_default(this.__data__, key) > -1;
}
var listCacheHas_default = listCacheHas5;

// node_modules/lodash-es/_listCacheSet.js
function listCacheSet5(key, value) {
  var data = this.__data__, index2 = assocIndexOf_default(data, key);
  if (index2 < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index2][1] = value;
  }
  return this;
}
var listCacheSet_default = listCacheSet5;

// node_modules/lodash-es/_ListCache.js
function ListCache5(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
ListCache5.prototype.clear = listCacheClear_default;
ListCache5.prototype["delete"] = listCacheDelete_default;
ListCache5.prototype.get = listCacheGet_default;
ListCache5.prototype.has = listCacheHas_default;
ListCache5.prototype.set = listCacheSet_default;
var ListCache_default = ListCache5;

// node_modules/lodash-es/_stackClear.js
function stackClear5() {
  this.__data__ = new ListCache_default();
  this.size = 0;
}
var stackClear_default = stackClear5;

// node_modules/lodash-es/_stackDelete.js
function stackDelete5(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var stackDelete_default = stackDelete5;

// node_modules/lodash-es/_stackGet.js
function stackGet5(key) {
  return this.__data__.get(key);
}
var stackGet_default = stackGet5;

// node_modules/lodash-es/_stackHas.js
function stackHas5(key) {
  return this.__data__.has(key);
}
var stackHas_default = stackHas5;

// node_modules/lodash-es/_freeGlobal.js
var freeGlobal5 = typeof global == "object" && global && global.Object === Object && global;
var freeGlobal_default = freeGlobal5;

// node_modules/lodash-es/_root.js
var freeSelf5 = typeof self == "object" && self && self.Object === Object && self;
var root5 = freeGlobal_default || freeSelf5 || Function("return this")();
var root_default = root5;

// node_modules/lodash-es/_Symbol.js
var Symbol4 = root_default.Symbol;
var Symbol_default = Symbol4;

// node_modules/lodash-es/_getRawTag.js
var objectProto5 = Object.prototype;
var hasOwnProperty5 = objectProto5.hasOwnProperty;
var nativeObjectToString5 = objectProto5.toString;
var symToStringTag5 = Symbol_default ? Symbol_default.toStringTag : void 0;
function getRawTag5(value) {
  var isOwn = hasOwnProperty5.call(value, symToStringTag5), tag = value[symToStringTag5];
  try {
    value[symToStringTag5] = void 0;
    var unmasked = true;
  } catch (e9) {
  }
  var result = nativeObjectToString5.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag5] = tag;
    } else {
      delete value[symToStringTag5];
    }
  }
  return result;
}
var getRawTag_default = getRawTag5;

// node_modules/lodash-es/_objectToString.js
var objectProto6 = Object.prototype;
var nativeObjectToString6 = objectProto6.toString;
function objectToString5(value) {
  return nativeObjectToString6.call(value);
}
var objectToString_default = objectToString5;

// node_modules/lodash-es/_baseGetTag.js
var nullTag5 = "[object Null]";
var undefinedTag5 = "[object Undefined]";
var symToStringTag6 = Symbol_default ? Symbol_default.toStringTag : void 0;
function baseGetTag5(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag5 : nullTag5;
  }
  return symToStringTag6 && symToStringTag6 in Object(value) ? getRawTag_default(value) : objectToString_default(value);
}
var baseGetTag_default = baseGetTag5;

// node_modules/lodash-es/isObject.js
function isObject6(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_default = isObject6;

// node_modules/lodash-es/isFunction.js
var asyncTag5 = "[object AsyncFunction]";
var funcTag5 = "[object Function]";
var genTag5 = "[object GeneratorFunction]";
var proxyTag5 = "[object Proxy]";
function isFunction5(value) {
  if (!isObject_default(value)) {
    return false;
  }
  var tag = baseGetTag_default(value);
  return tag == funcTag5 || tag == genTag5 || tag == asyncTag5 || tag == proxyTag5;
}
var isFunction_default = isFunction5;

// node_modules/lodash-es/_coreJsData.js
var coreJsData5 = root_default["__core-js_shared__"];
var coreJsData_default = coreJsData5;

// node_modules/lodash-es/_isMasked.js
var maskSrcKey5 = function() {
  var uid2 = /[^.]+$/.exec(coreJsData_default && coreJsData_default.keys && coreJsData_default.keys.IE_PROTO || "");
  return uid2 ? "Symbol(src)_1." + uid2 : "";
}();
function isMasked5(func) {
  return !!maskSrcKey5 && maskSrcKey5 in func;
}
var isMasked_default = isMasked5;

// node_modules/lodash-es/_toSource.js
var funcProto5 = Function.prototype;
var funcToString5 = funcProto5.toString;
function toSource5(func) {
  if (func != null) {
    try {
      return funcToString5.call(func);
    } catch (e9) {
    }
    try {
      return func + "";
    } catch (e9) {
    }
  }
  return "";
}
var toSource_default = toSource5;

// node_modules/lodash-es/_baseIsNative.js
var reRegExpChar5 = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor5 = /^\[object .+?Constructor\]$/;
var funcProto6 = Function.prototype;
var objectProto7 = Object.prototype;
var funcToString6 = funcProto6.toString;
var hasOwnProperty6 = objectProto7.hasOwnProperty;
var reIsNative5 = RegExp(
  "^" + funcToString6.call(hasOwnProperty6).replace(reRegExpChar5, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative5(value) {
  if (!isObject_default(value) || isMasked_default(value)) {
    return false;
  }
  var pattern = isFunction_default(value) ? reIsNative5 : reIsHostCtor5;
  return pattern.test(toSource_default(value));
}
var baseIsNative_default = baseIsNative5;

// node_modules/lodash-es/_getValue.js
function getValue8(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
var getValue_default = getValue8;

// node_modules/lodash-es/_getNative.js
function getNative5(object2, key) {
  var value = getValue_default(object2, key);
  return baseIsNative_default(value) ? value : void 0;
}
var getNative_default = getNative5;

// node_modules/lodash-es/_Map.js
var Map6 = getNative_default(root_default, "Map");
var Map_default = Map6;

// node_modules/lodash-es/_nativeCreate.js
var nativeCreate5 = getNative_default(Object, "create");
var nativeCreate_default = nativeCreate5;

// node_modules/lodash-es/_hashClear.js
function hashClear5() {
  this.__data__ = nativeCreate_default ? nativeCreate_default(null) : {};
  this.size = 0;
}
var hashClear_default = hashClear5;

// node_modules/lodash-es/_hashDelete.js
function hashDelete5(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var hashDelete_default = hashDelete5;

// node_modules/lodash-es/_hashGet.js
var HASH_UNDEFINED5 = "__lodash_hash_undefined__";
var objectProto8 = Object.prototype;
var hasOwnProperty7 = objectProto8.hasOwnProperty;
function hashGet5(key) {
  var data = this.__data__;
  if (nativeCreate_default) {
    var result = data[key];
    return result === HASH_UNDEFINED5 ? void 0 : result;
  }
  return hasOwnProperty7.call(data, key) ? data[key] : void 0;
}
var hashGet_default = hashGet5;

// node_modules/lodash-es/_hashHas.js
var objectProto9 = Object.prototype;
var hasOwnProperty8 = objectProto9.hasOwnProperty;
function hashHas5(key) {
  var data = this.__data__;
  return nativeCreate_default ? data[key] !== void 0 : hasOwnProperty8.call(data, key);
}
var hashHas_default = hashHas5;

// node_modules/lodash-es/_hashSet.js
var HASH_UNDEFINED6 = "__lodash_hash_undefined__";
function hashSet5(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate_default && value === void 0 ? HASH_UNDEFINED6 : value;
  return this;
}
var hashSet_default = hashSet5;

// node_modules/lodash-es/_Hash.js
function Hash5(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
Hash5.prototype.clear = hashClear_default;
Hash5.prototype["delete"] = hashDelete_default;
Hash5.prototype.get = hashGet_default;
Hash5.prototype.has = hashHas_default;
Hash5.prototype.set = hashSet_default;
var Hash_default = Hash5;

// node_modules/lodash-es/_mapCacheClear.js
function mapCacheClear5() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash_default(),
    "map": new (Map_default || ListCache_default)(),
    "string": new Hash_default()
  };
}
var mapCacheClear_default = mapCacheClear5;

// node_modules/lodash-es/_isKeyable.js
function isKeyable5(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var isKeyable_default = isKeyable5;

// node_modules/lodash-es/_getMapData.js
function getMapData5(map5, key) {
  var data = map5.__data__;
  return isKeyable_default(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var getMapData_default = getMapData5;

// node_modules/lodash-es/_mapCacheDelete.js
function mapCacheDelete5(key) {
  var result = getMapData_default(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var mapCacheDelete_default = mapCacheDelete5;

// node_modules/lodash-es/_mapCacheGet.js
function mapCacheGet5(key) {
  return getMapData_default(this, key).get(key);
}
var mapCacheGet_default = mapCacheGet5;

// node_modules/lodash-es/_mapCacheHas.js
function mapCacheHas5(key) {
  return getMapData_default(this, key).has(key);
}
var mapCacheHas_default = mapCacheHas5;

// node_modules/lodash-es/_mapCacheSet.js
function mapCacheSet5(key, value) {
  var data = getMapData_default(this, key), size2 = data.size;
  data.set(key, value);
  this.size += data.size == size2 ? 0 : 1;
  return this;
}
var mapCacheSet_default = mapCacheSet5;

// node_modules/lodash-es/_MapCache.js
function MapCache5(entries) {
  var index2 = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index2 < length) {
    var entry = entries[index2];
    this.set(entry[0], entry[1]);
  }
}
MapCache5.prototype.clear = mapCacheClear_default;
MapCache5.prototype["delete"] = mapCacheDelete_default;
MapCache5.prototype.get = mapCacheGet_default;
MapCache5.prototype.has = mapCacheHas_default;
MapCache5.prototype.set = mapCacheSet_default;
var MapCache_default = MapCache5;

// node_modules/lodash-es/_stackSet.js
var LARGE_ARRAY_SIZE5 = 200;
function stackSet5(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache_default) {
    var pairs = data.__data__;
    if (!Map_default || pairs.length < LARGE_ARRAY_SIZE5 - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache_default(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var stackSet_default = stackSet5;

// node_modules/lodash-es/_Stack.js
function Stack5(entries) {
  var data = this.__data__ = new ListCache_default(entries);
  this.size = data.size;
}
Stack5.prototype.clear = stackClear_default;
Stack5.prototype["delete"] = stackDelete_default;
Stack5.prototype.get = stackGet_default;
Stack5.prototype.has = stackHas_default;
Stack5.prototype.set = stackSet_default;
var Stack_default = Stack5;

// node_modules/lodash-es/_defineProperty.js
var defineProperty5 = function() {
  try {
    var func = getNative_default(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e9) {
  }
}();
var defineProperty_default = defineProperty5;

// node_modules/lodash-es/_baseAssignValue.js
function baseAssignValue4(object2, key, value) {
  if (key == "__proto__" && defineProperty_default) {
    defineProperty_default(object2, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object2[key] = value;
  }
}
var baseAssignValue_default = baseAssignValue4;

// node_modules/lodash-es/_assignMergeValue.js
function assignMergeValue2(object2, key, value) {
  if (value !== void 0 && !eq_default(object2[key], value) || value === void 0 && !(key in object2)) {
    baseAssignValue_default(object2, key, value);
  }
}
var assignMergeValue_default = assignMergeValue2;

// node_modules/lodash-es/_createBaseFor.js
function createBaseFor3(fromRight) {
  return function(object2, iteratee, keysFunc) {
    var index2 = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index2];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object2;
  };
}
var createBaseFor_default = createBaseFor3;

// node_modules/lodash-es/_baseFor.js
var baseFor3 = createBaseFor_default();
var baseFor_default = baseFor3;

// node_modules/lodash-es/_cloneBuffer.js
var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
var moduleExports = freeModule && freeModule.exports === freeExports;
var Buffer = moduleExports ? root_default.Buffer : void 0;
var allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
  buffer.copy(result);
  return result;
}
var cloneBuffer_default = cloneBuffer;

// node_modules/lodash-es/_Uint8Array.js
var Uint8Array6 = root_default.Uint8Array;
var Uint8Array_default = Uint8Array6;

// node_modules/lodash-es/_cloneArrayBuffer.js
function cloneArrayBuffer4(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new Uint8Array_default(result).set(new Uint8Array_default(arrayBuffer));
  return result;
}
var cloneArrayBuffer_default = cloneArrayBuffer4;

// node_modules/lodash-es/_cloneTypedArray.js
function cloneTypedArray4(typedArray, isDeep) {
  var buffer = isDeep ? cloneArrayBuffer_default(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}
var cloneTypedArray_default = cloneTypedArray4;

// node_modules/lodash-es/_copyArray.js
function copyArray4(source, array2) {
  var index2 = -1, length = source.length;
  array2 || (array2 = Array(length));
  while (++index2 < length) {
    array2[index2] = source[index2];
  }
  return array2;
}
var copyArray_default = copyArray4;

// node_modules/lodash-es/_baseCreate.js
var objectCreate4 = Object.create;
var baseCreate4 = function() {
  function object2() {
  }
  return function(proto2) {
    if (!isObject_default(proto2)) {
      return {};
    }
    if (objectCreate4) {
      return objectCreate4(proto2);
    }
    object2.prototype = proto2;
    var result = new object2();
    object2.prototype = void 0;
    return result;
  };
}();
var baseCreate_default = baseCreate4;

// node_modules/lodash-es/_overArg.js
function overArg5(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var overArg_default = overArg5;

// node_modules/lodash-es/_getPrototype.js
var getPrototype4 = overArg_default(Object.getPrototypeOf, Object);
var getPrototype_default = getPrototype4;

// node_modules/lodash-es/_isPrototype.js
var objectProto10 = Object.prototype;
function isPrototype4(value) {
  var Ctor = value && value.constructor, proto2 = typeof Ctor == "function" && Ctor.prototype || objectProto10;
  return value === proto2;
}
var isPrototype_default = isPrototype4;

// node_modules/lodash-es/_initCloneObject.js
function initCloneObject4(object2) {
  return typeof object2.constructor == "function" && !isPrototype_default(object2) ? baseCreate_default(getPrototype_default(object2)) : {};
}
var initCloneObject_default = initCloneObject4;

// node_modules/lodash-es/isObjectLike.js
function isObjectLike5(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_default = isObjectLike5;

// node_modules/lodash-es/_baseIsArguments.js
var argsTag4 = "[object Arguments]";
function baseIsArguments5(value) {
  return isObjectLike_default(value) && baseGetTag_default(value) == argsTag4;
}
var baseIsArguments_default = baseIsArguments5;

// node_modules/lodash-es/isArguments.js
var objectProto11 = Object.prototype;
var hasOwnProperty9 = objectProto11.hasOwnProperty;
var propertyIsEnumerable5 = objectProto11.propertyIsEnumerable;
var isArguments5 = baseIsArguments_default(function() {
  return arguments;
}()) ? baseIsArguments_default : function(value) {
  return isObjectLike_default(value) && hasOwnProperty9.call(value, "callee") && !propertyIsEnumerable5.call(value, "callee");
};
var isArguments_default = isArguments5;

// node_modules/lodash-es/isArray.js
var isArray8 = Array.isArray;
var isArray_default = isArray8;

// node_modules/lodash-es/isLength.js
var MAX_SAFE_INTEGER5 = 9007199254740991;
function isLength5(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER5;
}
var isLength_default = isLength5;

// node_modules/lodash-es/isArrayLike.js
function isArrayLike4(value) {
  return value != null && isLength_default(value.length) && !isFunction_default(value);
}
var isArrayLike_default = isArrayLike4;

// node_modules/lodash-es/isArrayLikeObject.js
function isArrayLikeObject2(value) {
  return isObjectLike_default(value) && isArrayLike_default(value);
}
var isArrayLikeObject_default = isArrayLikeObject2;

// node_modules/lodash-es/stubFalse.js
function stubFalse5() {
  return false;
}
var stubFalse_default = stubFalse5;

// node_modules/lodash-es/isBuffer.js
var freeExports2 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule2 = freeExports2 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports2 = freeModule2 && freeModule2.exports === freeExports2;
var Buffer2 = moduleExports2 ? root_default.Buffer : void 0;
var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
var isBuffer = nativeIsBuffer || stubFalse_default;
var isBuffer_default = isBuffer;

// node_modules/lodash-es/isPlainObject.js
var objectTag4 = "[object Object]";
var funcProto7 = Function.prototype;
var objectProto12 = Object.prototype;
var funcToString7 = funcProto7.toString;
var hasOwnProperty10 = objectProto12.hasOwnProperty;
var objectCtorString2 = funcToString7.call(Object);
function isPlainObject6(value) {
  if (!isObjectLike_default(value) || baseGetTag_default(value) != objectTag4) {
    return false;
  }
  var proto2 = getPrototype_default(value);
  if (proto2 === null) {
    return true;
  }
  var Ctor = hasOwnProperty10.call(proto2, "constructor") && proto2.constructor;
  return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString7.call(Ctor) == objectCtorString2;
}
var isPlainObject_default = isPlainObject6;

// node_modules/lodash-es/_baseIsTypedArray.js
var argsTag5 = "[object Arguments]";
var arrayTag4 = "[object Array]";
var boolTag4 = "[object Boolean]";
var dateTag4 = "[object Date]";
var errorTag4 = "[object Error]";
var funcTag6 = "[object Function]";
var mapTag5 = "[object Map]";
var numberTag4 = "[object Number]";
var objectTag5 = "[object Object]";
var regexpTag4 = "[object RegExp]";
var setTag5 = "[object Set]";
var stringTag4 = "[object String]";
var weakMapTag5 = "[object WeakMap]";
var arrayBufferTag4 = "[object ArrayBuffer]";
var dataViewTag5 = "[object DataView]";
var float32Tag5 = "[object Float32Array]";
var float64Tag5 = "[object Float64Array]";
var int8Tag5 = "[object Int8Array]";
var int16Tag5 = "[object Int16Array]";
var int32Tag5 = "[object Int32Array]";
var uint8Tag5 = "[object Uint8Array]";
var uint8ClampedTag5 = "[object Uint8ClampedArray]";
var uint16Tag5 = "[object Uint16Array]";
var uint32Tag5 = "[object Uint32Array]";
var typedArrayTags5 = {};
typedArrayTags5[float32Tag5] = typedArrayTags5[float64Tag5] = typedArrayTags5[int8Tag5] = typedArrayTags5[int16Tag5] = typedArrayTags5[int32Tag5] = typedArrayTags5[uint8Tag5] = typedArrayTags5[uint8ClampedTag5] = typedArrayTags5[uint16Tag5] = typedArrayTags5[uint32Tag5] = true;
typedArrayTags5[argsTag5] = typedArrayTags5[arrayTag4] = typedArrayTags5[arrayBufferTag4] = typedArrayTags5[boolTag4] = typedArrayTags5[dataViewTag5] = typedArrayTags5[dateTag4] = typedArrayTags5[errorTag4] = typedArrayTags5[funcTag6] = typedArrayTags5[mapTag5] = typedArrayTags5[numberTag4] = typedArrayTags5[objectTag5] = typedArrayTags5[regexpTag4] = typedArrayTags5[setTag5] = typedArrayTags5[stringTag4] = typedArrayTags5[weakMapTag5] = false;
function baseIsTypedArray5(value) {
  return isObjectLike_default(value) && isLength_default(value.length) && !!typedArrayTags5[baseGetTag_default(value)];
}
var baseIsTypedArray_default = baseIsTypedArray5;

// node_modules/lodash-es/_baseUnary.js
function baseUnary5(func) {
  return function(value) {
    return func(value);
  };
}
var baseUnary_default = baseUnary5;

// node_modules/lodash-es/_nodeUtil.js
var freeExports3 = typeof exports == "object" && exports && !exports.nodeType && exports;
var freeModule3 = freeExports3 && typeof module == "object" && module && !module.nodeType && module;
var moduleExports3 = freeModule3 && freeModule3.exports === freeExports3;
var freeProcess = moduleExports3 && freeGlobal_default.process;
var nodeUtil = function() {
  try {
    var types = freeModule3 && freeModule3.require && freeModule3.require("util").types;
    if (types) {
      return types;
    }
    return freeProcess && freeProcess.binding && freeProcess.binding("util");
  } catch (e9) {
  }
}();
var nodeUtil_default = nodeUtil;

// node_modules/lodash-es/isTypedArray.js
var nodeIsTypedArray5 = nodeUtil_default && nodeUtil_default.isTypedArray;
var isTypedArray5 = nodeIsTypedArray5 ? baseUnary_default(nodeIsTypedArray5) : baseIsTypedArray_default;
var isTypedArray_default = isTypedArray5;

// node_modules/lodash-es/_safeGet.js
function safeGet2(object2, key) {
  if (key === "constructor" && typeof object2[key] === "function") {
    return;
  }
  if (key == "__proto__") {
    return;
  }
  return object2[key];
}
var safeGet_default = safeGet2;

// node_modules/lodash-es/_assignValue.js
var objectProto13 = Object.prototype;
var hasOwnProperty11 = objectProto13.hasOwnProperty;
function assignValue4(object2, key, value) {
  var objValue = object2[key];
  if (!(hasOwnProperty11.call(object2, key) && eq_default(objValue, value)) || value === void 0 && !(key in object2)) {
    baseAssignValue_default(object2, key, value);
  }
}
var assignValue_default = assignValue4;

// node_modules/lodash-es/_copyObject.js
function copyObject4(source, props, object2, customizer) {
  var isNew = !object2;
  object2 || (object2 = {});
  var index2 = -1, length = props.length;
  while (++index2 < length) {
    var key = props[index2];
    var newValue = customizer ? customizer(object2[key], source[key], key, object2, source) : void 0;
    if (newValue === void 0) {
      newValue = source[key];
    }
    if (isNew) {
      baseAssignValue_default(object2, key, newValue);
    } else {
      assignValue_default(object2, key, newValue);
    }
  }
  return object2;
}
var copyObject_default = copyObject4;

// node_modules/lodash-es/_baseTimes.js
function baseTimes4(n12, iteratee) {
  var index2 = -1, result = Array(n12);
  while (++index2 < n12) {
    result[index2] = iteratee(index2);
  }
  return result;
}
var baseTimes_default = baseTimes4;

// node_modules/lodash-es/_isIndex.js
var MAX_SAFE_INTEGER6 = 9007199254740991;
var reIsUint4 = /^(?:0|[1-9]\d*)$/;
function isIndex4(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER6 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint4.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var isIndex_default = isIndex4;

// node_modules/lodash-es/_arrayLikeKeys.js
var objectProto14 = Object.prototype;
var hasOwnProperty12 = objectProto14.hasOwnProperty;
function arrayLikeKeys4(value, inherited) {
  var isArr = isArray_default(value), isArg = !isArr && isArguments_default(value), isBuff = !isArr && !isArg && isBuffer_default(value), isType2 = !isArr && !isArg && !isBuff && isTypedArray_default(value), skipIndexes = isArr || isArg || isBuff || isType2, result = skipIndexes ? baseTimes_default(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty12.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType2 && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex_default(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var arrayLikeKeys_default = arrayLikeKeys4;

// node_modules/lodash-es/_nativeKeysIn.js
function nativeKeysIn4(object2) {
  var result = [];
  if (object2 != null) {
    for (var key in Object(object2)) {
      result.push(key);
    }
  }
  return result;
}
var nativeKeysIn_default = nativeKeysIn4;

// node_modules/lodash-es/_baseKeysIn.js
var objectProto15 = Object.prototype;
var hasOwnProperty13 = objectProto15.hasOwnProperty;
function baseKeysIn4(object2) {
  if (!isObject_default(object2)) {
    return nativeKeysIn_default(object2);
  }
  var isProto = isPrototype_default(object2), result = [];
  for (var key in object2) {
    if (!(key == "constructor" && (isProto || !hasOwnProperty13.call(object2, key)))) {
      result.push(key);
    }
  }
  return result;
}
var baseKeysIn_default = baseKeysIn4;

// node_modules/lodash-es/keysIn.js
function keysIn4(object2) {
  return isArrayLike_default(object2) ? arrayLikeKeys_default(object2, true) : baseKeysIn_default(object2);
}
var keysIn_default = keysIn4;

// node_modules/lodash-es/toPlainObject.js
function toPlainObject2(value) {
  return copyObject_default(value, keysIn_default(value));
}
var toPlainObject_default = toPlainObject2;

// node_modules/lodash-es/_baseMergeDeep.js
function baseMergeDeep2(object2, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = safeGet_default(object2, key), srcValue = safeGet_default(source, key), stacked = stack.get(srcValue);
  if (stacked) {
    assignMergeValue_default(object2, key, stacked);
    return;
  }
  var newValue = customizer ? customizer(objValue, srcValue, key + "", object2, source, stack) : void 0;
  var isCommon = newValue === void 0;
  if (isCommon) {
    var isArr = isArray_default(srcValue), isBuff = !isArr && isBuffer_default(srcValue), isTyped = !isArr && !isBuff && isTypedArray_default(srcValue);
    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (isArray_default(objValue)) {
        newValue = objValue;
      } else if (isArrayLikeObject_default(objValue)) {
        newValue = copyArray_default(objValue);
      } else if (isBuff) {
        isCommon = false;
        newValue = cloneBuffer_default(srcValue, true);
      } else if (isTyped) {
        isCommon = false;
        newValue = cloneTypedArray_default(srcValue, true);
      } else {
        newValue = [];
      }
    } else if (isPlainObject_default(srcValue) || isArguments_default(srcValue)) {
      newValue = objValue;
      if (isArguments_default(objValue)) {
        newValue = toPlainObject_default(objValue);
      } else if (!isObject_default(objValue) || isFunction_default(objValue)) {
        newValue = initCloneObject_default(srcValue);
      }
    } else {
      isCommon = false;
    }
  }
  if (isCommon) {
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack["delete"](srcValue);
  }
  assignMergeValue_default(object2, key, newValue);
}
var baseMergeDeep_default = baseMergeDeep2;

// node_modules/lodash-es/_baseMerge.js
function baseMerge2(object2, source, srcIndex, customizer, stack) {
  if (object2 === source) {
    return;
  }
  baseFor_default(source, function(srcValue, key) {
    stack || (stack = new Stack_default());
    if (isObject_default(srcValue)) {
      baseMergeDeep_default(object2, source, key, srcIndex, baseMerge2, customizer, stack);
    } else {
      var newValue = customizer ? customizer(safeGet_default(object2, key), srcValue, key + "", object2, source, stack) : void 0;
      if (newValue === void 0) {
        newValue = srcValue;
      }
      assignMergeValue_default(object2, key, newValue);
    }
  }, keysIn_default);
}
var baseMerge_default = baseMerge2;

// node_modules/lodash-es/identity.js
function identity2(value) {
  return value;
}
var identity_default = identity2;

// node_modules/lodash-es/_apply.js
function apply4(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var apply_default = apply4;

// node_modules/lodash-es/_overRest.js
var nativeMax2 = Math.max;
function overRest2(func, start3, transform) {
  start3 = nativeMax2(start3 === void 0 ? func.length - 1 : start3, 0);
  return function() {
    var args = arguments, index2 = -1, length = nativeMax2(args.length - start3, 0), array2 = Array(length);
    while (++index2 < length) {
      array2[index2] = args[start3 + index2];
    }
    index2 = -1;
    var otherArgs = Array(start3 + 1);
    while (++index2 < start3) {
      otherArgs[index2] = args[index2];
    }
    otherArgs[start3] = transform(array2);
    return apply_default(func, this, otherArgs);
  };
}
var overRest_default = overRest2;

// node_modules/lodash-es/constant.js
function constant2(value) {
  return function() {
    return value;
  };
}
var constant_default = constant2;

// node_modules/lodash-es/_baseSetToString.js
var baseSetToString2 = !defineProperty_default ? identity_default : function(func, string2) {
  return defineProperty_default(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant_default(string2),
    "writable": true
  });
};
var baseSetToString_default = baseSetToString2;

// node_modules/lodash-es/_shortOut.js
var HOT_COUNT2 = 800;
var HOT_SPAN2 = 16;
var nativeNow2 = Date.now;
function shortOut2(func) {
  var count2 = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow2(), remaining = HOT_SPAN2 - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count2 >= HOT_COUNT2) {
        return arguments[0];
      }
    } else {
      count2 = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var shortOut_default = shortOut2;

// node_modules/lodash-es/_setToString.js
var setToString2 = shortOut_default(baseSetToString_default);
var setToString_default = setToString2;

// node_modules/lodash-es/_baseRest.js
function baseRest2(func, start3) {
  return setToString_default(overRest_default(func, start3, identity_default), func + "");
}
var baseRest_default = baseRest2;

// node_modules/lodash-es/_isIterateeCall.js
function isIterateeCall2(value, index2, object2) {
  if (!isObject_default(object2)) {
    return false;
  }
  var type = typeof index2;
  if (type == "number" ? isArrayLike_default(object2) && isIndex_default(index2, object2.length) : type == "string" && index2 in object2) {
    return eq_default(object2[index2], value);
  }
  return false;
}
var isIterateeCall_default = isIterateeCall2;

// node_modules/lodash-es/_createAssigner.js
function createAssigner2(assigner) {
  return baseRest_default(function(object2, sources) {
    var index2 = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
    customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
    if (guard && isIterateeCall_default(sources[0], sources[1], guard)) {
      customizer = length < 3 ? void 0 : customizer;
      length = 1;
    }
    object2 = Object(object2);
    while (++index2 < length) {
      var source = sources[index2];
      if (source) {
        assigner(object2, source, index2, customizer);
      }
    }
    return object2;
  });
}
var createAssigner_default = createAssigner2;

// node_modules/lodash-es/merge.js
var merge2 = createAssigner_default(function(object2, source, srcIndex) {
  baseMerge_default(object2, source, srcIndex);
});
var merge_default = merge2;

// node_modules/react-color/es/components/common/Raised.js
var Raised = function Raised2(_ref) {
  var zDepth = _ref.zDepth, radius = _ref.radius, background = _ref.background, children = _ref.children, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles;
  var styles5 = (0, import_reactcss5.default)(merge_default({
    "default": {
      wrap: {
        position: "relative",
        display: "inline-block"
      },
      content: {
        position: "relative"
      },
      bg: {
        absolute: "0px 0px 0px 0px",
        boxShadow: "0 " + zDepth + "px " + zDepth * 4 + "px rgba(0,0,0,.24)",
        borderRadius: radius,
        background
      }
    },
    "zDepth-0": {
      bg: {
        boxShadow: "none"
      }
    },
    "zDepth-1": {
      bg: {
        boxShadow: "0 2px 10px rgba(0,0,0,.12), 0 2px 5px rgba(0,0,0,.16)"
      }
    },
    "zDepth-2": {
      bg: {
        boxShadow: "0 6px 20px rgba(0,0,0,.19), 0 8px 17px rgba(0,0,0,.2)"
      }
    },
    "zDepth-3": {
      bg: {
        boxShadow: "0 17px 50px rgba(0,0,0,.19), 0 12px 15px rgba(0,0,0,.24)"
      }
    },
    "zDepth-4": {
      bg: {
        boxShadow: "0 25px 55px rgba(0,0,0,.21), 0 16px 28px rgba(0,0,0,.22)"
      }
    },
    "zDepth-5": {
      bg: {
        boxShadow: "0 40px 77px rgba(0,0,0,.22), 0 27px 24px rgba(0,0,0,.2)"
      }
    },
    "square": {
      bg: {
        borderRadius: "0"
      }
    },
    "circle": {
      bg: {
        borderRadius: "50%"
      }
    }
  }, passedStyles), { "zDepth-1": zDepth === 1 });
  return import_react71.default.createElement(
    "div",
    { style: styles5.wrap },
    import_react71.default.createElement("div", { style: styles5.bg }),
    import_react71.default.createElement(
      "div",
      { style: styles5.content },
      children
    )
  );
};
Raised.propTypes = {
  background: import_prop_types3.default.string,
  zDepth: import_prop_types3.default.oneOf([0, 1, 2, 3, 4, 5]),
  radius: import_prop_types3.default.number,
  styles: import_prop_types3.default.object
};
Raised.defaultProps = {
  background: "#fff",
  zDepth: 1,
  radius: 2,
  styles: {}
};
var Raised_default = Raised;

// node_modules/react-color/es/components/common/Saturation.js
var import_react72 = __toESM(require_react());
var import_reactcss6 = __toESM(require_lib5());

// node_modules/lodash-es/now.js
var now = function() {
  return root_default.Date.now();
};
var now_default = now;

// node_modules/lodash-es/_trimmedEndIndex.js
var reWhitespace = /\s/;
function trimmedEndIndex(string2) {
  var index2 = string2.length;
  while (index2-- && reWhitespace.test(string2.charAt(index2))) {
  }
  return index2;
}
var trimmedEndIndex_default = trimmedEndIndex;

// node_modules/lodash-es/_baseTrim.js
var reTrimStart = /^\s+/;
function baseTrim(string2) {
  return string2 ? string2.slice(0, trimmedEndIndex_default(string2) + 1).replace(reTrimStart, "") : string2;
}
var baseTrim_default = baseTrim;

// node_modules/lodash-es/isSymbol.js
var symbolTag4 = "[object Symbol]";
function isSymbol2(value) {
  return typeof value == "symbol" || isObjectLike_default(value) && baseGetTag_default(value) == symbolTag4;
}
var isSymbol_default = isSymbol2;

// node_modules/lodash-es/toNumber.js
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol_default(value)) {
    return NAN;
  }
  if (isObject_default(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject_default(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim_default(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_default = toNumber;

// node_modules/lodash-es/debounce.js
var FUNC_ERROR_TEXT3 = "Expected a function";
var nativeMax3 = Math.max;
var nativeMin = Math.min;
function debounce3(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT3);
  }
  wait = toNumber_default(wait) || 0;
  if (isObject_default(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax3(toNumber_default(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time) {
    lastInvokeTime = time;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time) : result;
  }
  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time = now_default();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    timerId = setTimeout(timerExpired, remainingWait(time));
  }
  function trailingEdge(time) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush3() {
    return timerId === void 0 ? result : trailingEdge(now_default());
  }
  function debounced() {
    var time = now_default(), isInvoking = shouldInvoke(time);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush3;
  return debounced;
}
var debounce_default = debounce3;

// node_modules/lodash-es/throttle.js
var FUNC_ERROR_TEXT4 = "Expected a function";
function throttle2(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT4);
  }
  if (isObject_default(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce_default(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_default = throttle2;

// node_modules/react-color/es/helpers/saturation.js
var calculateChange5 = function calculateChange6(e9, hsl, container) {
  var _container$getBoundin = container.getBoundingClientRect(), containerWidth = _container$getBoundin.width, containerHeight = _container$getBoundin.height;
  var x7 = typeof e9.pageX === "number" ? e9.pageX : e9.touches[0].pageX;
  var y9 = typeof e9.pageY === "number" ? e9.pageY : e9.touches[0].pageY;
  var left = x7 - (container.getBoundingClientRect().left + window.pageXOffset);
  var top = y9 - (container.getBoundingClientRect().top + window.pageYOffset);
  if (left < 0) {
    left = 0;
  } else if (left > containerWidth) {
    left = containerWidth;
  }
  if (top < 0) {
    top = 0;
  } else if (top > containerHeight) {
    top = containerHeight;
  }
  var saturation = left / containerWidth;
  var bright = 1 - top / containerHeight;
  return {
    h: hsl.h,
    s: saturation,
    v: bright,
    a: hsl.a,
    source: "hsv"
  };
};

// node_modules/react-color/es/components/common/Saturation.js
var _createClass4 = function() {
  function defineProperties(target, props) {
    for (var i15 = 0; i15 < props.length; i15++) {
      var descriptor = props[i15];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn4(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Saturation = function(_ref) {
  _inherits4(Saturation2, _ref);
  function Saturation2(props) {
    _classCallCheck4(this, Saturation2);
    var _this = _possibleConstructorReturn4(this, (Saturation2.__proto__ || Object.getPrototypeOf(Saturation2)).call(this, props));
    _this.handleChange = function(e9) {
      typeof _this.props.onChange === "function" && _this.throttle(_this.props.onChange, calculateChange5(e9, _this.props.hsl, _this.container), e9);
    };
    _this.handleMouseDown = function(e9) {
      _this.handleChange(e9);
      var renderWindow = _this.getContainerRenderWindow();
      renderWindow.addEventListener("mousemove", _this.handleChange);
      renderWindow.addEventListener("mouseup", _this.handleMouseUp);
    };
    _this.handleMouseUp = function() {
      _this.unbindEventListeners();
    };
    _this.throttle = throttle_default(function(fn2, data, e9) {
      fn2(data, e9);
    }, 50);
    return _this;
  }
  _createClass4(Saturation2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.throttle.cancel();
      this.unbindEventListeners();
    }
  }, {
    key: "getContainerRenderWindow",
    value: function getContainerRenderWindow() {
      var container = this.container;
      var renderWindow = window;
      while (!renderWindow.document.contains(container) && renderWindow.parent !== renderWindow) {
        renderWindow = renderWindow.parent;
      }
      return renderWindow;
    }
  }, {
    key: "unbindEventListeners",
    value: function unbindEventListeners() {
      var renderWindow = this.getContainerRenderWindow();
      renderWindow.removeEventListener("mousemove", this.handleChange);
      renderWindow.removeEventListener("mouseup", this.handleMouseUp);
    }
  }, {
    key: "render",
    value: function render3() {
      var _this2 = this;
      var _ref2 = this.props.style || {}, color = _ref2.color, white = _ref2.white, black = _ref2.black, pointer = _ref2.pointer, circle = _ref2.circle;
      var styles5 = (0, import_reactcss6.default)({
        "default": {
          color: {
            absolute: "0px 0px 0px 0px",
            background: "hsl(" + this.props.hsl.h + ",100%, 50%)",
            borderRadius: this.props.radius
          },
          white: {
            absolute: "0px 0px 0px 0px",
            borderRadius: this.props.radius
          },
          black: {
            absolute: "0px 0px 0px 0px",
            boxShadow: this.props.shadow,
            borderRadius: this.props.radius
          },
          pointer: {
            position: "absolute",
            top: -(this.props.hsv.v * 100) + 100 + "%",
            left: this.props.hsv.s * 100 + "%",
            cursor: "default"
          },
          circle: {
            width: "4px",
            height: "4px",
            boxShadow: "0 0 0 1.5px #fff, inset 0 0 1px 1px rgba(0,0,0,.3),\n            0 0 1px 2px rgba(0,0,0,.4)",
            borderRadius: "50%",
            cursor: "hand",
            transform: "translate(-2px, -2px)"
          }
        },
        "custom": {
          color,
          white,
          black,
          pointer,
          circle
        }
      }, { "custom": !!this.props.style });
      return import_react72.default.createElement(
        "div",
        {
          style: styles5.color,
          ref: function ref2(container) {
            return _this2.container = container;
          },
          onMouseDown: this.handleMouseDown,
          onTouchMove: this.handleChange,
          onTouchStart: this.handleChange
        },
        import_react72.default.createElement(
          "style",
          null,
          "\n          .saturation-white {\n            background: -webkit-linear-gradient(to right, #fff, rgba(255,255,255,0));\n            background: linear-gradient(to right, #fff, rgba(255,255,255,0));\n          }\n          .saturation-black {\n            background: -webkit-linear-gradient(to top, #000, rgba(0,0,0,0));\n            background: linear-gradient(to top, #000, rgba(0,0,0,0));\n          }\n        "
        ),
        import_react72.default.createElement(
          "div",
          { style: styles5.white, className: "saturation-white" },
          import_react72.default.createElement("div", { style: styles5.black, className: "saturation-black" }),
          import_react72.default.createElement(
            "div",
            { style: styles5.pointer },
            this.props.pointer ? import_react72.default.createElement(this.props.pointer, this.props) : import_react72.default.createElement("div", { style: styles5.circle })
          )
        )
      );
    }
  }]);
  return Saturation2;
}(import_react72.PureComponent || import_react72.Component);
var Saturation_default = Saturation;

// node_modules/react-color/es/components/common/ColorWrap.js
var import_react73 = __toESM(require_react());

// node_modules/lodash-es/_arrayEach.js
function arrayEach4(array2, iteratee) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (iteratee(array2[index2], index2, array2) === false) {
      break;
    }
  }
  return array2;
}
var arrayEach_default = arrayEach4;

// node_modules/lodash-es/_nativeKeys.js
var nativeKeys5 = overArg_default(Object.keys, Object);
var nativeKeys_default = nativeKeys5;

// node_modules/lodash-es/_baseKeys.js
var objectProto16 = Object.prototype;
var hasOwnProperty14 = objectProto16.hasOwnProperty;
function baseKeys4(object2) {
  if (!isPrototype_default(object2)) {
    return nativeKeys_default(object2);
  }
  var result = [];
  for (var key in Object(object2)) {
    if (hasOwnProperty14.call(object2, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var baseKeys_default = baseKeys4;

// node_modules/lodash-es/keys.js
function keys4(object2) {
  return isArrayLike_default(object2) ? arrayLikeKeys_default(object2) : baseKeys_default(object2);
}
var keys_default = keys4;

// node_modules/lodash-es/_baseForOwn.js
function baseForOwn2(object2, iteratee) {
  return object2 && baseFor_default(object2, iteratee, keys_default);
}
var baseForOwn_default = baseForOwn2;

// node_modules/lodash-es/_createBaseEach.js
function createBaseEach2(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike_default(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index2 = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index2-- : ++index2 < length) {
      if (iteratee(iterable[index2], index2, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var createBaseEach_default = createBaseEach2;

// node_modules/lodash-es/_baseEach.js
var baseEach2 = createBaseEach_default(baseForOwn_default);
var baseEach_default = baseEach2;

// node_modules/lodash-es/_castFunction.js
function castFunction(value) {
  return typeof value == "function" ? value : identity_default;
}
var castFunction_default = castFunction;

// node_modules/lodash-es/forEach.js
function forEach(collection, iteratee) {
  var func = isArray_default(collection) ? arrayEach_default : baseEach_default;
  return func(collection, castFunction_default(iteratee));
}
var forEach_default = forEach;

// node_modules/tinycolor2/esm/tinycolor.js
function _typeof2(obj) {
  "@babel/helpers - typeof";
  return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof2(obj);
}
var trimLeft = /^\s+/;
var trimRight = /\s+$/;
function tinycolor(color, opts) {
  color = color ? color : "";
  opts = opts || {};
  if (color instanceof tinycolor) {
    return color;
  }
  if (!(this instanceof tinycolor)) {
    return new tinycolor(color, opts);
  }
  var rgb = inputToRGB(color);
  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;
  this._gradientType = opts.gradientType;
  if (this._r < 1)
    this._r = Math.round(this._r);
  if (this._g < 1)
    this._g = Math.round(this._g);
  if (this._b < 1)
    this._b = Math.round(this._b);
  this._ok = rgb.ok;
}
tinycolor.prototype = {
  isDark: function isDark() {
    return this.getBrightness() < 128;
  },
  isLight: function isLight() {
    return !this.isDark();
  },
  isValid: function isValid2() {
    return this._ok;
  },
  getOriginalInput: function getOriginalInput() {
    return this._originalInput;
  },
  getFormat: function getFormat() {
    return this._format;
  },
  getAlpha: function getAlpha() {
    return this._a;
  },
  getBrightness: function getBrightness() {
    var rgb = this.toRgb();
    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1e3;
  },
  getLuminance: function getLuminance() {
    var rgb = this.toRgb();
    var RsRGB, GsRGB, BsRGB, R4, G5, B5;
    RsRGB = rgb.r / 255;
    GsRGB = rgb.g / 255;
    BsRGB = rgb.b / 255;
    if (RsRGB <= 0.03928)
      R4 = RsRGB / 12.92;
    else
      R4 = Math.pow((RsRGB + 0.055) / 1.055, 2.4);
    if (GsRGB <= 0.03928)
      G5 = GsRGB / 12.92;
    else
      G5 = Math.pow((GsRGB + 0.055) / 1.055, 2.4);
    if (BsRGB <= 0.03928)
      B5 = BsRGB / 12.92;
    else
      B5 = Math.pow((BsRGB + 0.055) / 1.055, 2.4);
    return 0.2126 * R4 + 0.7152 * G5 + 0.0722 * B5;
  },
  setAlpha: function setAlpha(value) {
    this._a = boundAlpha(value);
    this._roundA = Math.round(100 * this._a) / 100;
    return this;
  },
  toHsv: function toHsv() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    return {
      h: hsv.h * 360,
      s: hsv.s,
      v: hsv.v,
      a: this._a
    };
  },
  toHsvString: function toHsvString() {
    var hsv = rgbToHsv(this._r, this._g, this._b);
    var h11 = Math.round(hsv.h * 360), s20 = Math.round(hsv.s * 100), v6 = Math.round(hsv.v * 100);
    return this._a == 1 ? "hsv(" + h11 + ", " + s20 + "%, " + v6 + "%)" : "hsva(" + h11 + ", " + s20 + "%, " + v6 + "%, " + this._roundA + ")";
  },
  toHsl: function toHsl() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    return {
      h: hsl.h * 360,
      s: hsl.s,
      l: hsl.l,
      a: this._a
    };
  },
  toHslString: function toHslString() {
    var hsl = rgbToHsl(this._r, this._g, this._b);
    var h11 = Math.round(hsl.h * 360), s20 = Math.round(hsl.s * 100), l14 = Math.round(hsl.l * 100);
    return this._a == 1 ? "hsl(" + h11 + ", " + s20 + "%, " + l14 + "%)" : "hsla(" + h11 + ", " + s20 + "%, " + l14 + "%, " + this._roundA + ")";
  },
  toHex: function toHex(allow3Char) {
    return rgbToHex(this._r, this._g, this._b, allow3Char);
  },
  toHexString: function toHexString(allow3Char) {
    return "#" + this.toHex(allow3Char);
  },
  toHex8: function toHex8(allow4Char) {
    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);
  },
  toHex8String: function toHex8String(allow4Char) {
    return "#" + this.toHex8(allow4Char);
  },
  toRgb: function toRgb() {
    return {
      r: Math.round(this._r),
      g: Math.round(this._g),
      b: Math.round(this._b),
      a: this._a
    };
  },
  toRgbString: function toRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
  },
  toPercentageRgb: function toPercentageRgb() {
    return {
      r: Math.round(bound01(this._r, 255) * 100) + "%",
      g: Math.round(bound01(this._g, 255) * 100) + "%",
      b: Math.round(bound01(this._b, 255) * 100) + "%",
      a: this._a
    };
  },
  toPercentageRgbString: function toPercentageRgbString() {
    return this._a == 1 ? "rgb(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%)" : "rgba(" + Math.round(bound01(this._r, 255) * 100) + "%, " + Math.round(bound01(this._g, 255) * 100) + "%, " + Math.round(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
  },
  toName: function toName() {
    if (this._a === 0) {
      return "transparent";
    }
    if (this._a < 1) {
      return false;
    }
    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
  },
  toFilter: function toFilter(secondColor) {
    var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a);
    var secondHex8String = hex8String;
    var gradientType = this._gradientType ? "GradientType = 1, " : "";
    if (secondColor) {
      var s20 = tinycolor(secondColor);
      secondHex8String = "#" + rgbaToArgbHex(s20._r, s20._g, s20._b, s20._a);
    }
    return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")";
  },
  toString: function toString3(format3) {
    var formatSet = !!format3;
    format3 = format3 || this._format;
    var formattedString = false;
    var hasAlpha = this._a < 1 && this._a >= 0;
    var needsAlphaFormat = !formatSet && hasAlpha && (format3 === "hex" || format3 === "hex6" || format3 === "hex3" || format3 === "hex4" || format3 === "hex8" || format3 === "name");
    if (needsAlphaFormat) {
      if (format3 === "name" && this._a === 0) {
        return this.toName();
      }
      return this.toRgbString();
    }
    if (format3 === "rgb") {
      formattedString = this.toRgbString();
    }
    if (format3 === "prgb") {
      formattedString = this.toPercentageRgbString();
    }
    if (format3 === "hex" || format3 === "hex6") {
      formattedString = this.toHexString();
    }
    if (format3 === "hex3") {
      formattedString = this.toHexString(true);
    }
    if (format3 === "hex4") {
      formattedString = this.toHex8String(true);
    }
    if (format3 === "hex8") {
      formattedString = this.toHex8String();
    }
    if (format3 === "name") {
      formattedString = this.toName();
    }
    if (format3 === "hsl") {
      formattedString = this.toHslString();
    }
    if (format3 === "hsv") {
      formattedString = this.toHsvString();
    }
    return formattedString || this.toHexString();
  },
  clone: function clone() {
    return tinycolor(this.toString());
  },
  _applyModification: function _applyModification(fn2, args) {
    var color = fn2.apply(null, [this].concat([].slice.call(args)));
    this._r = color._r;
    this._g = color._g;
    this._b = color._b;
    this.setAlpha(color._a);
    return this;
  },
  lighten: function lighten() {
    return this._applyModification(_lighten, arguments);
  },
  brighten: function brighten() {
    return this._applyModification(_brighten, arguments);
  },
  darken: function darken() {
    return this._applyModification(_darken, arguments);
  },
  desaturate: function desaturate() {
    return this._applyModification(_desaturate, arguments);
  },
  saturate: function saturate() {
    return this._applyModification(_saturate, arguments);
  },
  greyscale: function greyscale() {
    return this._applyModification(_greyscale, arguments);
  },
  spin: function spin() {
    return this._applyModification(_spin, arguments);
  },
  _applyCombination: function _applyCombination(fn2, args) {
    return fn2.apply(null, [this].concat([].slice.call(args)));
  },
  analogous: function analogous() {
    return this._applyCombination(_analogous, arguments);
  },
  complement: function complement() {
    return this._applyCombination(_complement, arguments);
  },
  monochromatic: function monochromatic() {
    return this._applyCombination(_monochromatic, arguments);
  },
  splitcomplement: function splitcomplement() {
    return this._applyCombination(_splitcomplement, arguments);
  },
  // Disabled until https://github.com/bgrins/TinyColor/issues/254
  // polyad: function (number) {
  //   return this._applyCombination(polyad, [number]);
  // },
  triad: function triad() {
    return this._applyCombination(polyad, [3]);
  },
  tetrad: function tetrad() {
    return this._applyCombination(polyad, [4]);
  }
};
tinycolor.fromRatio = function(color, opts) {
  if (_typeof2(color) == "object") {
    var newColor = {};
    for (var i15 in color) {
      if (color.hasOwnProperty(i15)) {
        if (i15 === "a") {
          newColor[i15] = color[i15];
        } else {
          newColor[i15] = convertToPercentage(color[i15]);
        }
      }
    }
    color = newColor;
  }
  return tinycolor(color, opts);
};
function inputToRGB(color) {
  var rgb = {
    r: 0,
    g: 0,
    b: 0
  };
  var a13 = 1;
  var s20 = null;
  var v6 = null;
  var l14 = null;
  var ok = false;
  var format3 = false;
  if (typeof color == "string") {
    color = stringInputToObject(color);
  }
  if (_typeof2(color) == "object") {
    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {
      rgb = rgbToRgb(color.r, color.g, color.b);
      ok = true;
      format3 = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {
      s20 = convertToPercentage(color.s);
      v6 = convertToPercentage(color.v);
      rgb = hsvToRgb(color.h, s20, v6);
      ok = true;
      format3 = "hsv";
    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {
      s20 = convertToPercentage(color.s);
      l14 = convertToPercentage(color.l);
      rgb = hslToRgb(color.h, s20, l14);
      ok = true;
      format3 = "hsl";
    }
    if (color.hasOwnProperty("a")) {
      a13 = color.a;
    }
  }
  a13 = boundAlpha(a13);
  return {
    ok,
    format: color.format || format3,
    r: Math.min(255, Math.max(rgb.r, 0)),
    g: Math.min(255, Math.max(rgb.g, 0)),
    b: Math.min(255, Math.max(rgb.b, 0)),
    a: a13
  };
}
function rgbToRgb(r15, g6, b6) {
  return {
    r: bound01(r15, 255) * 255,
    g: bound01(g6, 255) * 255,
    b: bound01(b6, 255) * 255
  };
}
function rgbToHsl(r15, g6, b6) {
  r15 = bound01(r15, 255);
  g6 = bound01(g6, 255);
  b6 = bound01(b6, 255);
  var max4 = Math.max(r15, g6, b6), min4 = Math.min(r15, g6, b6);
  var h11, s20, l14 = (max4 + min4) / 2;
  if (max4 == min4) {
    h11 = s20 = 0;
  } else {
    var d17 = max4 - min4;
    s20 = l14 > 0.5 ? d17 / (2 - max4 - min4) : d17 / (max4 + min4);
    switch (max4) {
      case r15:
        h11 = (g6 - b6) / d17 + (g6 < b6 ? 6 : 0);
        break;
      case g6:
        h11 = (b6 - r15) / d17 + 2;
        break;
      case b6:
        h11 = (r15 - g6) / d17 + 4;
        break;
    }
    h11 /= 6;
  }
  return {
    h: h11,
    s: s20,
    l: l14
  };
}
function hslToRgb(h11, s20, l14) {
  var r15, g6, b6;
  h11 = bound01(h11, 360);
  s20 = bound01(s20, 100);
  l14 = bound01(l14, 100);
  function hue2rgb(p13, q8, t20) {
    if (t20 < 0)
      t20 += 1;
    if (t20 > 1)
      t20 -= 1;
    if (t20 < 1 / 6)
      return p13 + (q8 - p13) * 6 * t20;
    if (t20 < 1 / 2)
      return q8;
    if (t20 < 2 / 3)
      return p13 + (q8 - p13) * (2 / 3 - t20) * 6;
    return p13;
  }
  if (s20 === 0) {
    r15 = g6 = b6 = l14;
  } else {
    var q7 = l14 < 0.5 ? l14 * (1 + s20) : l14 + s20 - l14 * s20;
    var p12 = 2 * l14 - q7;
    r15 = hue2rgb(p12, q7, h11 + 1 / 3);
    g6 = hue2rgb(p12, q7, h11);
    b6 = hue2rgb(p12, q7, h11 - 1 / 3);
  }
  return {
    r: r15 * 255,
    g: g6 * 255,
    b: b6 * 255
  };
}
function rgbToHsv(r15, g6, b6) {
  r15 = bound01(r15, 255);
  g6 = bound01(g6, 255);
  b6 = bound01(b6, 255);
  var max4 = Math.max(r15, g6, b6), min4 = Math.min(r15, g6, b6);
  var h11, s20, v6 = max4;
  var d17 = max4 - min4;
  s20 = max4 === 0 ? 0 : d17 / max4;
  if (max4 == min4) {
    h11 = 0;
  } else {
    switch (max4) {
      case r15:
        h11 = (g6 - b6) / d17 + (g6 < b6 ? 6 : 0);
        break;
      case g6:
        h11 = (b6 - r15) / d17 + 2;
        break;
      case b6:
        h11 = (r15 - g6) / d17 + 4;
        break;
    }
    h11 /= 6;
  }
  return {
    h: h11,
    s: s20,
    v: v6
  };
}
function hsvToRgb(h11, s20, v6) {
  h11 = bound01(h11, 360) * 6;
  s20 = bound01(s20, 100);
  v6 = bound01(v6, 100);
  var i15 = Math.floor(h11), f16 = h11 - i15, p12 = v6 * (1 - s20), q7 = v6 * (1 - f16 * s20), t20 = v6 * (1 - (1 - f16) * s20), mod2 = i15 % 6, r15 = [v6, q7, p12, p12, t20, v6][mod2], g6 = [t20, v6, v6, q7, p12, p12][mod2], b6 = [p12, p12, t20, v6, v6, q7][mod2];
  return {
    r: r15 * 255,
    g: g6 * 255,
    b: b6 * 255
  };
}
function rgbToHex(r15, g6, b6, allow3Char) {
  var hex = [pad2(Math.round(r15).toString(16)), pad2(Math.round(g6).toString(16)), pad2(Math.round(b6).toString(16))];
  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
  }
  return hex.join("");
}
function rgbaToHex(r15, g6, b6, a13, allow4Char) {
  var hex = [pad2(Math.round(r15).toString(16)), pad2(Math.round(g6).toString(16)), pad2(Math.round(b6).toString(16)), pad2(convertDecimalToHex(a13))];
  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {
    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);
  }
  return hex.join("");
}
function rgbaToArgbHex(r15, g6, b6, a13) {
  var hex = [pad2(convertDecimalToHex(a13)), pad2(Math.round(r15).toString(16)), pad2(Math.round(g6).toString(16)), pad2(Math.round(b6).toString(16))];
  return hex.join("");
}
tinycolor.equals = function(color1, color2) {
  if (!color1 || !color2)
    return false;
  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
};
tinycolor.random = function() {
  return tinycolor.fromRatio({
    r: Math.random(),
    g: Math.random(),
    b: Math.random()
  });
};
function _desaturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s -= amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _saturate(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.s += amount / 100;
  hsl.s = clamp01(hsl.s);
  return tinycolor(hsl);
}
function _greyscale(color) {
  return tinycolor(color).desaturate(100);
}
function _lighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l += amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _brighten(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var rgb = tinycolor(color).toRgb();
  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));
  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));
  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));
  return tinycolor(rgb);
}
function _darken(color, amount) {
  amount = amount === 0 ? 0 : amount || 10;
  var hsl = tinycolor(color).toHsl();
  hsl.l -= amount / 100;
  hsl.l = clamp01(hsl.l);
  return tinycolor(hsl);
}
function _spin(color, amount) {
  var hsl = tinycolor(color).toHsl();
  var hue = (hsl.h + amount) % 360;
  hsl.h = hue < 0 ? 360 + hue : hue;
  return tinycolor(hsl);
}
function _complement(color) {
  var hsl = tinycolor(color).toHsl();
  hsl.h = (hsl.h + 180) % 360;
  return tinycolor(hsl);
}
function polyad(color, number2) {
  if (isNaN(number2) || number2 <= 0) {
    throw new Error("Argument to polyad must be a positive number");
  }
  var hsl = tinycolor(color).toHsl();
  var result = [tinycolor(color)];
  var step = 360 / number2;
  for (var i15 = 1; i15 < number2; i15++) {
    result.push(tinycolor({
      h: (hsl.h + i15 * step) % 360,
      s: hsl.s,
      l: hsl.l
    }));
  }
  return result;
}
function _splitcomplement(color) {
  var hsl = tinycolor(color).toHsl();
  var h11 = hsl.h;
  return [tinycolor(color), tinycolor({
    h: (h11 + 72) % 360,
    s: hsl.s,
    l: hsl.l
  }), tinycolor({
    h: (h11 + 216) % 360,
    s: hsl.s,
    l: hsl.l
  })];
}
function _analogous(color, results, slices) {
  results = results || 6;
  slices = slices || 30;
  var hsl = tinycolor(color).toHsl();
  var part = 360 / slices;
  var ret = [tinycolor(color)];
  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results; ) {
    hsl.h = (hsl.h + part) % 360;
    ret.push(tinycolor(hsl));
  }
  return ret;
}
function _monochromatic(color, results) {
  results = results || 6;
  var hsv = tinycolor(color).toHsv();
  var h11 = hsv.h, s20 = hsv.s, v6 = hsv.v;
  var ret = [];
  var modification = 1 / results;
  while (results--) {
    ret.push(tinycolor({
      h: h11,
      s: s20,
      v: v6
    }));
    v6 = (v6 + modification) % 1;
  }
  return ret;
}
tinycolor.mix = function(color1, color2, amount) {
  amount = amount === 0 ? 0 : amount || 50;
  var rgb1 = tinycolor(color1).toRgb();
  var rgb2 = tinycolor(color2).toRgb();
  var p12 = amount / 100;
  var rgba = {
    r: (rgb2.r - rgb1.r) * p12 + rgb1.r,
    g: (rgb2.g - rgb1.g) * p12 + rgb1.g,
    b: (rgb2.b - rgb1.b) * p12 + rgb1.b,
    a: (rgb2.a - rgb1.a) * p12 + rgb1.a
  };
  return tinycolor(rgba);
};
tinycolor.readability = function(color1, color2) {
  var c1 = tinycolor(color1);
  var c22 = tinycolor(color2);
  return (Math.max(c1.getLuminance(), c22.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c22.getLuminance()) + 0.05);
};
tinycolor.isReadable = function(color1, color2, wcag2) {
  var readability = tinycolor.readability(color1, color2);
  var wcag2Parms, out;
  out = false;
  wcag2Parms = validateWCAG2Parms(wcag2);
  switch (wcag2Parms.level + wcag2Parms.size) {
    case "AAsmall":
    case "AAAlarge":
      out = readability >= 4.5;
      break;
    case "AAlarge":
      out = readability >= 3;
      break;
    case "AAAsmall":
      out = readability >= 7;
      break;
  }
  return out;
};
tinycolor.mostReadable = function(baseColor, colorList, args) {
  var bestColor = null;
  var bestScore = 0;
  var readability;
  var includeFallbackColors, level, size2;
  args = args || {};
  includeFallbackColors = args.includeFallbackColors;
  level = args.level;
  size2 = args.size;
  for (var i15 = 0; i15 < colorList.length; i15++) {
    readability = tinycolor.readability(baseColor, colorList[i15]);
    if (readability > bestScore) {
      bestScore = readability;
      bestColor = tinycolor(colorList[i15]);
    }
  }
  if (tinycolor.isReadable(baseColor, bestColor, {
    level,
    size: size2
  }) || !includeFallbackColors) {
    return bestColor;
  } else {
    args.includeFallbackColors = false;
    return tinycolor.mostReadable(baseColor, ["#fff", "#000"], args);
  }
};
var names = tinycolor.names = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "0ff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000",
  blanchedalmond: "ffebcd",
  blue: "00f",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  burntsienna: "ea7e5d",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "0ff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgreen: "006400",
  darkgrey: "a9a9a9",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "f0f",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  green: "008000",
  greenyellow: "adff2f",
  grey: "808080",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgreen: "90ee90",
  lightgrey: "d3d3d3",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "789",
  lightslategrey: "789",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "0f0",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "f0f",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370db",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "db7093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  rebeccapurple: "663399",
  red: "f00",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "fff",
  whitesmoke: "f5f5f5",
  yellow: "ff0",
  yellowgreen: "9acd32"
};
var hexNames = tinycolor.hexNames = flip(names);
function flip(o16) {
  var flipped = {};
  for (var i15 in o16) {
    if (o16.hasOwnProperty(i15)) {
      flipped[o16[i15]] = i15;
    }
  }
  return flipped;
}
function boundAlpha(a13) {
  a13 = parseFloat(a13);
  if (isNaN(a13) || a13 < 0 || a13 > 1) {
    a13 = 1;
  }
  return a13;
}
function bound01(n12, max4) {
  if (isOnePointZero(n12))
    n12 = "100%";
  var processPercent = isPercentage(n12);
  n12 = Math.min(max4, Math.max(0, parseFloat(n12)));
  if (processPercent) {
    n12 = parseInt(n12 * max4, 10) / 100;
  }
  if (Math.abs(n12 - max4) < 1e-6) {
    return 1;
  }
  return n12 % max4 / parseFloat(max4);
}
function clamp01(val) {
  return Math.min(1, Math.max(0, val));
}
function parseIntFromHex(val) {
  return parseInt(val, 16);
}
function isOnePointZero(n12) {
  return typeof n12 == "string" && n12.indexOf(".") != -1 && parseFloat(n12) === 1;
}
function isPercentage(n12) {
  return typeof n12 === "string" && n12.indexOf("%") != -1;
}
function pad2(c16) {
  return c16.length == 1 ? "0" + c16 : "" + c16;
}
function convertToPercentage(n12) {
  if (n12 <= 1) {
    n12 = n12 * 100 + "%";
  }
  return n12;
}
function convertDecimalToHex(d17) {
  return Math.round(parseFloat(d17) * 255).toString(16);
}
function convertHexToDecimal(h11) {
  return parseIntFromHex(h11) / 255;
}
var matchers = function() {
  var CSS_INTEGER = "[-\\+]?\\d+%?";
  var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";
  var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";
  var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
  return {
    CSS_UNIT: new RegExp(CSS_UNIT),
    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
  };
}();
function isValidCSSUnit(color) {
  return !!matchers.CSS_UNIT.exec(color);
}
function stringInputToObject(color) {
  color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
  var named = false;
  if (names[color]) {
    color = names[color];
    named = true;
  } else if (color == "transparent") {
    return {
      r: 0,
      g: 0,
      b: 0,
      a: 0,
      format: "name"
    };
  }
  var match5;
  if (match5 = matchers.rgb.exec(color)) {
    return {
      r: match5[1],
      g: match5[2],
      b: match5[3]
    };
  }
  if (match5 = matchers.rgba.exec(color)) {
    return {
      r: match5[1],
      g: match5[2],
      b: match5[3],
      a: match5[4]
    };
  }
  if (match5 = matchers.hsl.exec(color)) {
    return {
      h: match5[1],
      s: match5[2],
      l: match5[3]
    };
  }
  if (match5 = matchers.hsla.exec(color)) {
    return {
      h: match5[1],
      s: match5[2],
      l: match5[3],
      a: match5[4]
    };
  }
  if (match5 = matchers.hsv.exec(color)) {
    return {
      h: match5[1],
      s: match5[2],
      v: match5[3]
    };
  }
  if (match5 = matchers.hsva.exec(color)) {
    return {
      h: match5[1],
      s: match5[2],
      v: match5[3],
      a: match5[4]
    };
  }
  if (match5 = matchers.hex8.exec(color)) {
    return {
      r: parseIntFromHex(match5[1]),
      g: parseIntFromHex(match5[2]),
      b: parseIntFromHex(match5[3]),
      a: convertHexToDecimal(match5[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match5 = matchers.hex6.exec(color)) {
    return {
      r: parseIntFromHex(match5[1]),
      g: parseIntFromHex(match5[2]),
      b: parseIntFromHex(match5[3]),
      format: named ? "name" : "hex"
    };
  }
  if (match5 = matchers.hex4.exec(color)) {
    return {
      r: parseIntFromHex(match5[1] + "" + match5[1]),
      g: parseIntFromHex(match5[2] + "" + match5[2]),
      b: parseIntFromHex(match5[3] + "" + match5[3]),
      a: convertHexToDecimal(match5[4] + "" + match5[4]),
      format: named ? "name" : "hex8"
    };
  }
  if (match5 = matchers.hex3.exec(color)) {
    return {
      r: parseIntFromHex(match5[1] + "" + match5[1]),
      g: parseIntFromHex(match5[2] + "" + match5[2]),
      b: parseIntFromHex(match5[3] + "" + match5[3]),
      format: named ? "name" : "hex"
    };
  }
  return false;
}
function validateWCAG2Parms(parms) {
  var level, size2;
  parms = parms || {
    level: "AA",
    size: "small"
  };
  level = (parms.level || "AA").toUpperCase();
  size2 = (parms.size || "small").toLowerCase();
  if (level !== "AA" && level !== "AAA") {
    level = "AA";
  }
  if (size2 !== "small" && size2 !== "large") {
    size2 = "small";
  }
  return {
    level,
    size: size2
  };
}

// node_modules/react-color/es/helpers/color.js
var simpleCheckForValidColor = function simpleCheckForValidColor2(data) {
  var keysToCheck = ["r", "g", "b", "a", "h", "s", "l", "v"];
  var checked = 0;
  var passed = 0;
  forEach_default(keysToCheck, function(letter) {
    if (data[letter]) {
      checked += 1;
      if (!isNaN(data[letter])) {
        passed += 1;
      }
      if (letter === "s" || letter === "l") {
        var percentPatt = /^\d+%$/;
        if (percentPatt.test(data[letter])) {
          passed += 1;
        }
      }
    }
  });
  return checked === passed ? data : false;
};
var toState = function toState2(data, oldHue) {
  var color = data.hex ? tinycolor(data.hex) : tinycolor(data);
  var hsl = color.toHsl();
  var hsv = color.toHsv();
  var rgb = color.toRgb();
  var hex = color.toHex();
  if (hsl.s === 0) {
    hsl.h = oldHue || 0;
    hsv.h = oldHue || 0;
  }
  var transparent = hex === "000000" && rgb.a === 0;
  return {
    hsl,
    hex: transparent ? "transparent" : "#" + hex,
    rgb,
    hsv,
    oldHue: data.h || oldHue || hsl.h,
    source: data.source
  };
};
var isValidHex = function isValidHex2(hex) {
  if (hex === "transparent") {
    return true;
  }
  var lh = String(hex).charAt(0) === "#" ? 1 : 0;
  return hex.length !== 4 + lh && hex.length < 7 + lh && tinycolor(hex).isValid();
};
var getContrastingColor = function getContrastingColor2(data) {
  if (!data) {
    return "#fff";
  }
  var col = toState(data);
  if (col.hex === "transparent") {
    return "rgba(0,0,0,0.4)";
  }
  var yiq = (col.rgb.r * 299 + col.rgb.g * 587 + col.rgb.b * 114) / 1e3;
  return yiq >= 128 ? "#000" : "#fff";
};
var isvalidColorString = function isvalidColorString2(string2, type) {
  var stringWithoutDegree = string2.replace("°", "");
  return tinycolor(type + " (" + stringWithoutDegree + ")")._ok;
};

// node_modules/react-color/es/components/common/ColorWrap.js
var _extends9 = Object.assign || function(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass5 = function() {
  function defineProperties(target, props) {
    for (var i15 = 0; i15 < props.length; i15++) {
      var descriptor = props[i15];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn5(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var ColorWrap = function ColorWrap2(Picker) {
  var ColorPicker2 = function(_ref) {
    _inherits5(ColorPicker3, _ref);
    function ColorPicker3(props) {
      _classCallCheck5(this, ColorPicker3);
      var _this = _possibleConstructorReturn5(this, (ColorPicker3.__proto__ || Object.getPrototypeOf(ColorPicker3)).call(this));
      _this.handleChange = function(data, event) {
        var isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
          var colors = toState(data, data.h || _this.state.oldHue);
          _this.setState(colors);
          _this.props.onChangeComplete && _this.debounce(_this.props.onChangeComplete, colors, event);
          _this.props.onChange && _this.props.onChange(colors, event);
        }
      };
      _this.handleSwatchHover = function(data, event) {
        var isValidColor = simpleCheckForValidColor(data);
        if (isValidColor) {
          var colors = toState(data, data.h || _this.state.oldHue);
          _this.props.onSwatchHover && _this.props.onSwatchHover(colors, event);
        }
      };
      _this.state = _extends9({}, toState(props.color, 0));
      _this.debounce = debounce_default(function(fn2, data, event) {
        fn2(data, event);
      }, 100);
      return _this;
    }
    _createClass5(ColorPicker3, [{
      key: "render",
      value: function render3() {
        var optionalEvents = {};
        if (this.props.onSwatchHover) {
          optionalEvents.onSwatchHover = this.handleSwatchHover;
        }
        return import_react73.default.createElement(Picker, _extends9({}, this.props, this.state, {
          onChange: this.handleChange
        }, optionalEvents));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(nextProps, state) {
        return _extends9({}, toState(nextProps.color, state.oldHue));
      }
    }]);
    return ColorPicker3;
  }(import_react73.PureComponent || import_react73.Component);
  ColorPicker2.propTypes = _extends9({}, Picker.propTypes);
  ColorPicker2.defaultProps = _extends9({}, Picker.defaultProps, {
    color: {
      h: 250,
      s: 0.5,
      l: 0.2,
      a: 1
    }
  });
  return ColorPicker2;
};
var ColorWrap_default = ColorWrap;

// node_modules/react-color/es/components/common/Swatch.js
var import_react75 = __toESM(require_react());
var import_reactcss7 = __toESM(require_lib5());

// node_modules/react-color/es/helpers/interaction.js
var import_react74 = __toESM(require_react());
var _extends10 = Object.assign || function(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var _createClass6 = function() {
  function defineProperties(target, props) {
    for (var i15 = 0; i15 < props.length; i15++) {
      var descriptor = props[i15];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn6(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var handleFocus = function handleFocus2(Component9) {
  var Span2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "span";
  return function(_React$Component) {
    _inherits6(Focus, _React$Component);
    function Focus() {
      var _ref;
      var _temp, _this, _ret;
      _classCallCheck6(this, Focus);
      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      return _ret = (_temp = (_this = _possibleConstructorReturn6(this, (_ref = Focus.__proto__ || Object.getPrototypeOf(Focus)).call.apply(_ref, [this].concat(args))), _this), _this.state = { focus: false }, _this.handleFocus = function() {
        return _this.setState({ focus: true });
      }, _this.handleBlur = function() {
        return _this.setState({ focus: false });
      }, _temp), _possibleConstructorReturn6(_this, _ret);
    }
    _createClass6(Focus, [{
      key: "render",
      value: function render3() {
        return import_react74.default.createElement(
          Span2,
          { onFocus: this.handleFocus, onBlur: this.handleBlur },
          import_react74.default.createElement(Component9, _extends10({}, this.props, this.state))
        );
      }
    }]);
    return Focus;
  }(import_react74.default.Component);
};

// node_modules/react-color/es/components/common/Swatch.js
var _extends11 = Object.assign || function(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var ENTER = 13;
var Swatch = function Swatch2(_ref) {
  var color = _ref.color, style2 = _ref.style, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onHover = _ref.onHover, _ref$title = _ref.title, title = _ref$title === void 0 ? color : _ref$title, children = _ref.children, focus2 = _ref.focus, _ref$focusStyle = _ref.focusStyle, focusStyle = _ref$focusStyle === void 0 ? {} : _ref$focusStyle;
  var transparent = color === "transparent";
  var styles5 = (0, import_reactcss7.default)({
    default: {
      swatch: _extends11({
        background: color,
        height: "100%",
        width: "100%",
        cursor: "pointer",
        position: "relative",
        outline: "none"
      }, style2, focus2 ? focusStyle : {})
    }
  });
  var handleClick = function handleClick2(e9) {
    return onClick(color, e9);
  };
  var handleKeyDown = function handleKeyDown2(e9) {
    return e9.keyCode === ENTER && onClick(color, e9);
  };
  var handleHover3 = function handleHover4(e9) {
    return onHover(color, e9);
  };
  var optionalEvents = {};
  if (onHover) {
    optionalEvents.onMouseOver = handleHover3;
  }
  return import_react75.default.createElement(
    "div",
    _extends11({
      style: styles5.swatch,
      onClick: handleClick,
      title,
      tabIndex: 0,
      onKeyDown: handleKeyDown
    }, optionalEvents),
    children,
    transparent && import_react75.default.createElement(Checkboard_default, {
      borderRadius: styles5.swatch.borderRadius,
      boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.1)"
    })
  );
};
var Swatch_default = handleFocus(Swatch);

// node_modules/react-color/es/components/alpha/AlphaPointer.js
var import_react76 = __toESM(require_react());
var import_reactcss8 = __toESM(require_lib5());
var AlphaPointer = function AlphaPointer2(_ref) {
  var direction = _ref.direction;
  var styles5 = (0, import_reactcss8.default)({
    "default": {
      picker: {
        width: "18px",
        height: "18px",
        borderRadius: "50%",
        transform: "translate(-9px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    },
    "vertical": {
      picker: {
        transform: "translate(-3px, -9px)"
      }
    }
  }, { vertical: direction === "vertical" });
  return import_react76.default.createElement("div", { style: styles5.picker });
};
var AlphaPointer_default = AlphaPointer;

// node_modules/react-color/es/components/alpha/Alpha.js
var _extends12 = Object.assign || function(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var AlphaPicker = function AlphaPicker2(_ref) {
  var rgb = _ref.rgb, hsl = _ref.hsl, width = _ref.width, height = _ref.height, onChange = _ref.onChange, direction = _ref.direction, style2 = _ref.style, renderers = _ref.renderers, pointer = _ref.pointer, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles5 = (0, import_reactcss9.default)({
    "default": {
      picker: {
        position: "relative",
        width,
        height
      },
      alpha: {
        radius: "2px",
        style: style2
      }
    }
  });
  return import_react77.default.createElement(
    "div",
    { style: styles5.picker, className: "alpha-picker " + className },
    import_react77.default.createElement(Alpha_default, _extends12({}, styles5.alpha, {
      rgb,
      hsl,
      pointer,
      renderers,
      onChange,
      direction
    }))
  );
};
AlphaPicker.defaultProps = {
  width: "316px",
  height: "16px",
  direction: "horizontal",
  pointer: AlphaPointer_default
};
var Alpha_default2 = ColorWrap_default(AlphaPicker);

// node_modules/react-color/es/components/block/Block.js
var import_react79 = __toESM(require_react());
var import_prop_types4 = __toESM(require_prop_types());
var import_reactcss11 = __toESM(require_lib5());

// node_modules/react-color/es/components/block/BlockSwatches.js
var import_react78 = __toESM(require_react());
var import_reactcss10 = __toESM(require_lib5());

// node_modules/lodash-es/_arrayMap.js
function arrayMap2(array2, iteratee) {
  var index2 = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
  while (++index2 < length) {
    result[index2] = iteratee(array2[index2], index2, array2);
  }
  return result;
}
var arrayMap_default = arrayMap2;

// node_modules/lodash-es/_setCacheAdd.js
var HASH_UNDEFINED7 = "__lodash_hash_undefined__";
function setCacheAdd3(value) {
  this.__data__.set(value, HASH_UNDEFINED7);
  return this;
}
var setCacheAdd_default = setCacheAdd3;

// node_modules/lodash-es/_setCacheHas.js
function setCacheHas3(value) {
  return this.__data__.has(value);
}
var setCacheHas_default = setCacheHas3;

// node_modules/lodash-es/_SetCache.js
function SetCache3(values3) {
  var index2 = -1, length = values3 == null ? 0 : values3.length;
  this.__data__ = new MapCache_default();
  while (++index2 < length) {
    this.add(values3[index2]);
  }
}
SetCache3.prototype.add = SetCache3.prototype.push = setCacheAdd_default;
SetCache3.prototype.has = setCacheHas_default;
var SetCache_default = SetCache3;

// node_modules/lodash-es/_arraySome.js
function arraySome2(array2, predicate) {
  var index2 = -1, length = array2 == null ? 0 : array2.length;
  while (++index2 < length) {
    if (predicate(array2[index2], index2, array2)) {
      return true;
    }
  }
  return false;
}
var arraySome_default = arraySome2;

// node_modules/lodash-es/_cacheHas.js
function cacheHas2(cache, key) {
  return cache.has(key);
}
var cacheHas_default = cacheHas2;

// node_modules/lodash-es/_equalArrays.js
var COMPARE_PARTIAL_FLAG2 = 1;
var COMPARE_UNORDERED_FLAG2 = 2;
function equalArrays2(array2, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG2, arrLength = array2.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array2);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array2;
  }
  var index2 = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG2 ? new SetCache_default() : void 0;
  stack.set(array2, other);
  stack.set(other, array2);
  while (++index2 < arrLength) {
    var arrValue = array2[index2], othValue = other[index2];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index2, other, array2, stack) : customizer(arrValue, othValue, index2, array2, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome_default(other, function(othValue2, othIndex) {
        if (!cacheHas_default(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array2);
  stack["delete"](other);
  return result;
}
var equalArrays_default = equalArrays2;

// node_modules/lodash-es/_mapToArray.js
function mapToArray2(map5) {
  var index2 = -1, result = Array(map5.size);
  map5.forEach(function(value, key) {
    result[++index2] = [key, value];
  });
  return result;
}
var mapToArray_default = mapToArray2;

// node_modules/lodash-es/_setToArray.js
function setToArray2(set3) {
  var index2 = -1, result = Array(set3.size);
  set3.forEach(function(value) {
    result[++index2] = value;
  });
  return result;
}
var setToArray_default = setToArray2;

// node_modules/lodash-es/_equalByTag.js
var COMPARE_PARTIAL_FLAG3 = 1;
var COMPARE_UNORDERED_FLAG3 = 2;
var boolTag5 = "[object Boolean]";
var dateTag5 = "[object Date]";
var errorTag5 = "[object Error]";
var mapTag6 = "[object Map]";
var numberTag5 = "[object Number]";
var regexpTag5 = "[object RegExp]";
var setTag6 = "[object Set]";
var stringTag5 = "[object String]";
var symbolTag5 = "[object Symbol]";
var arrayBufferTag5 = "[object ArrayBuffer]";
var dataViewTag6 = "[object DataView]";
var symbolProto5 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolValueOf5 = symbolProto5 ? symbolProto5.valueOf : void 0;
function equalByTag2(object2, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag6:
      if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
        return false;
      }
      object2 = object2.buffer;
      other = other.buffer;
    case arrayBufferTag5:
      if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array_default(object2), new Uint8Array_default(other))) {
        return false;
      }
      return true;
    case boolTag5:
    case dateTag5:
    case numberTag5:
      return eq_default(+object2, +other);
    case errorTag5:
      return object2.name == other.name && object2.message == other.message;
    case regexpTag5:
    case stringTag5:
      return object2 == other + "";
    case mapTag6:
      var convert = mapToArray_default;
    case setTag6:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG3;
      convert || (convert = setToArray_default);
      if (object2.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object2);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG3;
      stack.set(object2, other);
      var result = equalArrays_default(convert(object2), convert(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object2);
      return result;
    case symbolTag5:
      if (symbolValueOf5) {
        return symbolValueOf5.call(object2) == symbolValueOf5.call(other);
      }
  }
  return false;
}
var equalByTag_default = equalByTag2;

// node_modules/lodash-es/_arrayPush.js
function arrayPush4(array2, values3) {
  var index2 = -1, length = values3.length, offset5 = array2.length;
  while (++index2 < length) {
    array2[offset5 + index2] = values3[index2];
  }
  return array2;
}
var arrayPush_default = arrayPush4;

// node_modules/lodash-es/_baseGetAllKeys.js
function baseGetAllKeys4(object2, keysFunc, symbolsFunc) {
  var result = keysFunc(object2);
  return isArray_default(object2) ? result : arrayPush_default(result, symbolsFunc(object2));
}
var baseGetAllKeys_default = baseGetAllKeys4;

// node_modules/lodash-es/_arrayFilter.js
function arrayFilter4(array2, predicate) {
  var index2 = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
  while (++index2 < length) {
    var value = array2[index2];
    if (predicate(value, index2, array2)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var arrayFilter_default = arrayFilter4;

// node_modules/lodash-es/stubArray.js
function stubArray4() {
  return [];
}
var stubArray_default = stubArray4;

// node_modules/lodash-es/_getSymbols.js
var objectProto17 = Object.prototype;
var propertyIsEnumerable6 = objectProto17.propertyIsEnumerable;
var nativeGetSymbols4 = Object.getOwnPropertySymbols;
var getSymbols4 = !nativeGetSymbols4 ? stubArray_default : function(object2) {
  if (object2 == null) {
    return [];
  }
  object2 = Object(object2);
  return arrayFilter_default(nativeGetSymbols4(object2), function(symbol) {
    return propertyIsEnumerable6.call(object2, symbol);
  });
};
var getSymbols_default = getSymbols4;

// node_modules/lodash-es/_getAllKeys.js
function getAllKeys4(object2) {
  return baseGetAllKeys_default(object2, keys_default, getSymbols_default);
}
var getAllKeys_default = getAllKeys4;

// node_modules/lodash-es/_equalObjects.js
var COMPARE_PARTIAL_FLAG4 = 1;
var objectProto18 = Object.prototype;
var hasOwnProperty15 = objectProto18.hasOwnProperty;
function equalObjects2(object2, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG4, objProps = getAllKeys_default(object2), objLength = objProps.length, othProps = getAllKeys_default(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index2 = objLength;
  while (index2--) {
    var key = objProps[index2];
    if (!(isPartial ? key in other : hasOwnProperty15.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object2);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object2;
  }
  var result = true;
  stack.set(object2, other);
  stack.set(other, object2);
  var skipCtor = isPartial;
  while (++index2 < objLength) {
    key = objProps[index2];
    var objValue = object2[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object2.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object2);
  stack["delete"](other);
  return result;
}
var equalObjects_default = equalObjects2;

// node_modules/lodash-es/_DataView.js
var DataView5 = getNative_default(root_default, "DataView");
var DataView_default = DataView5;

// node_modules/lodash-es/_Promise.js
var Promise2 = getNative_default(root_default, "Promise");
var Promise_default = Promise2;

// node_modules/lodash-es/_Set.js
var Set6 = getNative_default(root_default, "Set");
var Set_default = Set6;

// node_modules/lodash-es/_WeakMap.js
var WeakMap5 = getNative_default(root_default, "WeakMap");
var WeakMap_default = WeakMap5;

// node_modules/lodash-es/_getTag.js
var mapTag7 = "[object Map]";
var objectTag6 = "[object Object]";
var promiseTag5 = "[object Promise]";
var setTag7 = "[object Set]";
var weakMapTag6 = "[object WeakMap]";
var dataViewTag7 = "[object DataView]";
var dataViewCtorString5 = toSource_default(DataView_default);
var mapCtorString5 = toSource_default(Map_default);
var promiseCtorString5 = toSource_default(Promise_default);
var setCtorString5 = toSource_default(Set_default);
var weakMapCtorString5 = toSource_default(WeakMap_default);
var getTag5 = baseGetTag_default;
if (DataView_default && getTag5(new DataView_default(new ArrayBuffer(1))) != dataViewTag7 || Map_default && getTag5(new Map_default()) != mapTag7 || Promise_default && getTag5(Promise_default.resolve()) != promiseTag5 || Set_default && getTag5(new Set_default()) != setTag7 || WeakMap_default && getTag5(new WeakMap_default()) != weakMapTag6) {
  getTag5 = function(value) {
    var result = baseGetTag_default(value), Ctor = result == objectTag6 ? value.constructor : void 0, ctorString = Ctor ? toSource_default(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString5:
          return dataViewTag7;
        case mapCtorString5:
          return mapTag7;
        case promiseCtorString5:
          return promiseTag5;
        case setCtorString5:
          return setTag7;
        case weakMapCtorString5:
          return weakMapTag6;
      }
    }
    return result;
  };
}
var getTag_default = getTag5;

// node_modules/lodash-es/_baseIsEqualDeep.js
var COMPARE_PARTIAL_FLAG5 = 1;
var argsTag6 = "[object Arguments]";
var arrayTag5 = "[object Array]";
var objectTag7 = "[object Object]";
var objectProto19 = Object.prototype;
var hasOwnProperty16 = objectProto19.hasOwnProperty;
function baseIsEqualDeep2(object2, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray_default(object2), othIsArr = isArray_default(other), objTag = objIsArr ? arrayTag5 : getTag_default(object2), othTag = othIsArr ? arrayTag5 : getTag_default(other);
  objTag = objTag == argsTag6 ? objectTag7 : objTag;
  othTag = othTag == argsTag6 ? objectTag7 : othTag;
  var objIsObj = objTag == objectTag7, othIsObj = othTag == objectTag7, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer_default(object2)) {
    if (!isBuffer_default(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack_default());
    return objIsArr || isTypedArray_default(object2) ? equalArrays_default(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag_default(object2, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG5)) {
    var objIsWrapped = objIsObj && hasOwnProperty16.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty16.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack_default());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack_default());
  return equalObjects_default(object2, other, bitmask, customizer, equalFunc, stack);
}
var baseIsEqualDeep_default = baseIsEqualDeep2;

// node_modules/lodash-es/_baseIsEqual.js
function baseIsEqual2(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike_default(value) && !isObjectLike_default(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep_default(value, other, bitmask, customizer, baseIsEqual2, stack);
}
var baseIsEqual_default = baseIsEqual2;

// node_modules/lodash-es/_baseIsMatch.js
var COMPARE_PARTIAL_FLAG6 = 1;
var COMPARE_UNORDERED_FLAG4 = 2;
function baseIsMatch2(object2, source, matchData, customizer) {
  var index2 = matchData.length, length = index2, noCustomizer = !customizer;
  if (object2 == null) {
    return !length;
  }
  object2 = Object(object2);
  while (index2--) {
    var data = matchData[index2];
    if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
      return false;
    }
  }
  while (++index2 < length) {
    data = matchData[index2];
    var key = data[0], objValue = object2[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object2)) {
        return false;
      }
    } else {
      var stack = new Stack_default();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object2, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG6 | COMPARE_UNORDERED_FLAG4, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var baseIsMatch_default = baseIsMatch2;

// node_modules/lodash-es/_isStrictComparable.js
function isStrictComparable2(value) {
  return value === value && !isObject_default(value);
}
var isStrictComparable_default = isStrictComparable2;

// node_modules/lodash-es/_getMatchData.js
function getMatchData2(object2) {
  var result = keys_default(object2), length = result.length;
  while (length--) {
    var key = result[length], value = object2[key];
    result[length] = [key, value, isStrictComparable_default(value)];
  }
  return result;
}
var getMatchData_default = getMatchData2;

// node_modules/lodash-es/_matchesStrictComparable.js
function matchesStrictComparable2(key, srcValue) {
  return function(object2) {
    if (object2 == null) {
      return false;
    }
    return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
  };
}
var matchesStrictComparable_default = matchesStrictComparable2;

// node_modules/lodash-es/_baseMatches.js
function baseMatches2(source) {
  var matchData = getMatchData_default(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable_default(matchData[0][0], matchData[0][1]);
  }
  return function(object2) {
    return object2 === source || baseIsMatch_default(object2, source, matchData);
  };
}
var baseMatches_default = baseMatches2;

// node_modules/lodash-es/_isKey.js
var reIsDeepProp2 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
var reIsPlainProp2 = /^\w*$/;
function isKey2(value, object2) {
  if (isArray_default(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol_default(value)) {
    return true;
  }
  return reIsPlainProp2.test(value) || !reIsDeepProp2.test(value) || object2 != null && value in Object(object2);
}
var isKey_default = isKey2;

// node_modules/lodash-es/memoize.js
var FUNC_ERROR_TEXT5 = "Expected a function";
function memoize5(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT5);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize5.Cache || MapCache_default)();
  return memoized;
}
memoize5.Cache = MapCache_default;
var memoize_default = memoize5;

// node_modules/lodash-es/_memoizeCapped.js
var MAX_MEMOIZE_SIZE3 = 500;
function memoizeCapped3(func) {
  var result = memoize_default(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE3) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var memoizeCapped_default = memoizeCapped3;

// node_modules/lodash-es/_stringToPath.js
var rePropName4 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar4 = /\\(\\)?/g;
var stringToPath5 = memoizeCapped_default(function(string2) {
  var result = [];
  if (string2.charCodeAt(0) === 46) {
    result.push("");
  }
  string2.replace(rePropName4, function(match5, number2, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar4, "$1") : number2 || match5);
  });
  return result;
});
var stringToPath_default = stringToPath5;

// node_modules/lodash-es/_baseToString.js
var INFINITY3 = 1 / 0;
var symbolProto6 = Symbol_default ? Symbol_default.prototype : void 0;
var symbolToString3 = symbolProto6 ? symbolProto6.toString : void 0;
function baseToString2(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray_default(value)) {
    return arrayMap_default(value, baseToString2) + "";
  }
  if (isSymbol_default(value)) {
    return symbolToString3 ? symbolToString3.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY3 ? "-0" : result;
}
var baseToString_default = baseToString2;

// node_modules/lodash-es/toString.js
function toString4(value) {
  return value == null ? "" : baseToString_default(value);
}
var toString_default = toString4;

// node_modules/lodash-es/_castPath.js
function castPath2(value, object2) {
  if (isArray_default(value)) {
    return value;
  }
  return isKey_default(value, object2) ? [value] : stringToPath_default(toString_default(value));
}
var castPath_default = castPath2;

// node_modules/lodash-es/_toKey.js
var INFINITY4 = 1 / 0;
function toKey2(value) {
  if (typeof value == "string" || isSymbol_default(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY4 ? "-0" : result;
}
var toKey_default = toKey2;

// node_modules/lodash-es/_baseGet.js
function baseGet2(object2, path) {
  path = castPath_default(path, object2);
  var index2 = 0, length = path.length;
  while (object2 != null && index2 < length) {
    object2 = object2[toKey_default(path[index2++])];
  }
  return index2 && index2 == length ? object2 : void 0;
}
var baseGet_default = baseGet2;

// node_modules/lodash-es/get.js
function get5(object2, path, defaultValue) {
  var result = object2 == null ? void 0 : baseGet_default(object2, path);
  return result === void 0 ? defaultValue : result;
}
var get_default = get5;

// node_modules/lodash-es/_baseHasIn.js
function baseHasIn2(object2, key) {
  return object2 != null && key in Object(object2);
}
var baseHasIn_default = baseHasIn2;

// node_modules/lodash-es/_hasPath.js
function hasPath2(object2, path, hasFunc) {
  path = castPath_default(path, object2);
  var index2 = -1, length = path.length, result = false;
  while (++index2 < length) {
    var key = toKey_default(path[index2]);
    if (!(result = object2 != null && hasFunc(object2, key))) {
      break;
    }
    object2 = object2[key];
  }
  if (result || ++index2 != length) {
    return result;
  }
  length = object2 == null ? 0 : object2.length;
  return !!length && isLength_default(length) && isIndex_default(key, length) && (isArray_default(object2) || isArguments_default(object2));
}
var hasPath_default = hasPath2;

// node_modules/lodash-es/hasIn.js
function hasIn2(object2, path) {
  return object2 != null && hasPath_default(object2, path, baseHasIn_default);
}
var hasIn_default = hasIn2;

// node_modules/lodash-es/_baseMatchesProperty.js
var COMPARE_PARTIAL_FLAG7 = 1;
var COMPARE_UNORDERED_FLAG5 = 2;
function baseMatchesProperty2(path, srcValue) {
  if (isKey_default(path) && isStrictComparable_default(srcValue)) {
    return matchesStrictComparable_default(toKey_default(path), srcValue);
  }
  return function(object2) {
    var objValue = get_default(object2, path);
    return objValue === void 0 && objValue === srcValue ? hasIn_default(object2, path) : baseIsEqual_default(srcValue, objValue, COMPARE_PARTIAL_FLAG7 | COMPARE_UNORDERED_FLAG5);
  };
}
var baseMatchesProperty_default = baseMatchesProperty2;

// node_modules/lodash-es/_baseProperty.js
function baseProperty2(key) {
  return function(object2) {
    return object2 == null ? void 0 : object2[key];
  };
}
var baseProperty_default = baseProperty2;

// node_modules/lodash-es/_basePropertyDeep.js
function basePropertyDeep2(path) {
  return function(object2) {
    return baseGet_default(object2, path);
  };
}
var basePropertyDeep_default = basePropertyDeep2;

// node_modules/lodash-es/property.js
function property2(path) {
  return isKey_default(path) ? baseProperty_default(toKey_default(path)) : basePropertyDeep_default(path);
}
var property_default = property2;

// node_modules/lodash-es/_baseIteratee.js
function baseIteratee2(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity_default;
  }
  if (typeof value == "object") {
    return isArray_default(value) ? baseMatchesProperty_default(value[0], value[1]) : baseMatches_default(value);
  }
  return property_default(value);
}
var baseIteratee_default = baseIteratee2;

// node_modules/lodash-es/_baseMap.js
function baseMap2(collection, iteratee) {
  var index2 = -1, result = isArrayLike_default(collection) ? Array(collection.length) : [];
  baseEach_default(collection, function(value, key, collection2) {
    result[++index2] = iteratee(value, key, collection2);
  });
  return result;
}
var baseMap_default = baseMap2;

// node_modules/lodash-es/map.js
function map2(collection, iteratee) {
  var func = isArray_default(collection) ? arrayMap_default : baseMap_default;
  return func(collection, baseIteratee_default(iteratee, 3));
}
var map_default = map2;

// node_modules/react-color/es/components/block/BlockSwatches.js
var BlockSwatches = function BlockSwatches2(_ref) {
  var colors = _ref.colors, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover;
  var styles5 = (0, import_reactcss10.default)({
    "default": {
      swatches: {
        marginRight: "-10px"
      },
      swatch: {
        width: "22px",
        height: "22px",
        float: "left",
        marginRight: "10px",
        marginBottom: "10px",
        borderRadius: "4px"
      },
      clear: {
        clear: "both"
      }
    }
  });
  return import_react78.default.createElement(
    "div",
    { style: styles5.swatches },
    map_default(colors, function(c16) {
      return import_react78.default.createElement(Swatch_default, {
        key: c16,
        color: c16,
        style: styles5.swatch,
        onClick,
        onHover: onSwatchHover,
        focusStyle: {
          boxShadow: "0 0 4px " + c16
        }
      });
    }),
    import_react78.default.createElement("div", { style: styles5.clear })
  );
};
var BlockSwatches_default = BlockSwatches;

// node_modules/react-color/es/components/block/Block.js
var Block = function Block2(_ref) {
  var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, hex = _ref.hex, colors = _ref.colors, width = _ref.width, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var transparent = hex === "transparent";
  var handleChange = function handleChange2(hexCode, e9) {
    isValidHex(hexCode) && onChange({
      hex: hexCode,
      source: "hex"
    }, e9);
  };
  var styles5 = (0, import_reactcss11.default)(merge_default({
    "default": {
      card: {
        width,
        background: "#fff",
        boxShadow: "0 1px rgba(0,0,0,.1)",
        borderRadius: "6px",
        position: "relative"
      },
      head: {
        height: "110px",
        background: hex,
        borderRadius: "6px 6px 0 0",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        position: "relative"
      },
      body: {
        padding: "10px"
      },
      label: {
        fontSize: "18px",
        color: getContrastingColor(hex),
        position: "relative"
      },
      triangle: {
        width: "0px",
        height: "0px",
        borderStyle: "solid",
        borderWidth: "0 10px 10px 10px",
        borderColor: "transparent transparent " + hex + " transparent",
        position: "absolute",
        top: "-10px",
        left: "50%",
        marginLeft: "-10px"
      },
      input: {
        width: "100%",
        fontSize: "12px",
        color: "#666",
        border: "0px",
        outline: "none",
        height: "22px",
        boxShadow: "inset 0 0 0 1px #ddd",
        borderRadius: "4px",
        padding: "0 7px",
        boxSizing: "border-box"
      }
    },
    "hide-triangle": {
      triangle: {
        display: "none"
      }
    }
  }, passedStyles), { "hide-triangle": triangle === "hide" });
  return import_react79.default.createElement(
    "div",
    { style: styles5.card, className: "block-picker " + className },
    import_react79.default.createElement("div", { style: styles5.triangle }),
    import_react79.default.createElement(
      "div",
      { style: styles5.head },
      transparent && import_react79.default.createElement(Checkboard_default, { borderRadius: "6px 6px 0 0" }),
      import_react79.default.createElement(
        "div",
        { style: styles5.label },
        hex
      )
    ),
    import_react79.default.createElement(
      "div",
      { style: styles5.body },
      import_react79.default.createElement(BlockSwatches_default, { colors, onClick: handleChange, onSwatchHover }),
      import_react79.default.createElement(EditableInput_default, {
        style: { input: styles5.input },
        value: hex,
        onChange: handleChange
      })
    )
  );
};
Block.propTypes = {
  width: import_prop_types4.default.oneOfType([import_prop_types4.default.string, import_prop_types4.default.number]),
  colors: import_prop_types4.default.arrayOf(import_prop_types4.default.string),
  triangle: import_prop_types4.default.oneOf(["top", "hide"]),
  styles: import_prop_types4.default.object
};
Block.defaultProps = {
  width: 170,
  colors: ["#D9E3F0", "#F47373", "#697689", "#37D67A", "#2CCCE4", "#555555", "#dce775", "#ff8a65", "#ba68c8"],
  triangle: "top",
  styles: {}
};
var Block_default = ColorWrap_default(Block);

// node_modules/react-color/es/components/circle/Circle.js
var import_react81 = __toESM(require_react());
var import_prop_types5 = __toESM(require_prop_types());
var import_reactcss13 = __toESM(require_lib5());

// node_modules/material-colors/dist/colors.es2015.js
var red = { "50": "#ffebee", "100": "#ffcdd2", "200": "#ef9a9a", "300": "#e57373", "400": "#ef5350", "500": "#f44336", "600": "#e53935", "700": "#d32f2f", "800": "#c62828", "900": "#b71c1c", "a100": "#ff8a80", "a200": "#ff5252", "a400": "#ff1744", "a700": "#d50000" };
var pink = { "50": "#fce4ec", "100": "#f8bbd0", "200": "#f48fb1", "300": "#f06292", "400": "#ec407a", "500": "#e91e63", "600": "#d81b60", "700": "#c2185b", "800": "#ad1457", "900": "#880e4f", "a100": "#ff80ab", "a200": "#ff4081", "a400": "#f50057", "a700": "#c51162" };
var purple = { "50": "#f3e5f5", "100": "#e1bee7", "200": "#ce93d8", "300": "#ba68c8", "400": "#ab47bc", "500": "#9c27b0", "600": "#8e24aa", "700": "#7b1fa2", "800": "#6a1b9a", "900": "#4a148c", "a100": "#ea80fc", "a200": "#e040fb", "a400": "#d500f9", "a700": "#aa00ff" };
var deepPurple = { "50": "#ede7f6", "100": "#d1c4e9", "200": "#b39ddb", "300": "#9575cd", "400": "#7e57c2", "500": "#673ab7", "600": "#5e35b1", "700": "#512da8", "800": "#4527a0", "900": "#311b92", "a100": "#b388ff", "a200": "#7c4dff", "a400": "#651fff", "a700": "#6200ea" };
var indigo = { "50": "#e8eaf6", "100": "#c5cae9", "200": "#9fa8da", "300": "#7986cb", "400": "#5c6bc0", "500": "#3f51b5", "600": "#3949ab", "700": "#303f9f", "800": "#283593", "900": "#1a237e", "a100": "#8c9eff", "a200": "#536dfe", "a400": "#3d5afe", "a700": "#304ffe" };
var blue = { "50": "#e3f2fd", "100": "#bbdefb", "200": "#90caf9", "300": "#64b5f6", "400": "#42a5f5", "500": "#2196f3", "600": "#1e88e5", "700": "#1976d2", "800": "#1565c0", "900": "#0d47a1", "a100": "#82b1ff", "a200": "#448aff", "a400": "#2979ff", "a700": "#2962ff" };
var lightBlue = { "50": "#e1f5fe", "100": "#b3e5fc", "200": "#81d4fa", "300": "#4fc3f7", "400": "#29b6f6", "500": "#03a9f4", "600": "#039be5", "700": "#0288d1", "800": "#0277bd", "900": "#01579b", "a100": "#80d8ff", "a200": "#40c4ff", "a400": "#00b0ff", "a700": "#0091ea" };
var cyan = { "50": "#e0f7fa", "100": "#b2ebf2", "200": "#80deea", "300": "#4dd0e1", "400": "#26c6da", "500": "#00bcd4", "600": "#00acc1", "700": "#0097a7", "800": "#00838f", "900": "#006064", "a100": "#84ffff", "a200": "#18ffff", "a400": "#00e5ff", "a700": "#00b8d4" };
var teal = { "50": "#e0f2f1", "100": "#b2dfdb", "200": "#80cbc4", "300": "#4db6ac", "400": "#26a69a", "500": "#009688", "600": "#00897b", "700": "#00796b", "800": "#00695c", "900": "#004d40", "a100": "#a7ffeb", "a200": "#64ffda", "a400": "#1de9b6", "a700": "#00bfa5" };
var green = { "50": "#e8f5e9", "100": "#c8e6c9", "200": "#a5d6a7", "300": "#81c784", "400": "#66bb6a", "500": "#4caf50", "600": "#43a047", "700": "#388e3c", "800": "#2e7d32", "900": "#1b5e20", "a100": "#b9f6ca", "a200": "#69f0ae", "a400": "#00e676", "a700": "#00c853" };
var lightGreen = { "50": "#f1f8e9", "100": "#dcedc8", "200": "#c5e1a5", "300": "#aed581", "400": "#9ccc65", "500": "#8bc34a", "600": "#7cb342", "700": "#689f38", "800": "#558b2f", "900": "#33691e", "a100": "#ccff90", "a200": "#b2ff59", "a400": "#76ff03", "a700": "#64dd17" };
var lime = { "50": "#f9fbe7", "100": "#f0f4c3", "200": "#e6ee9c", "300": "#dce775", "400": "#d4e157", "500": "#cddc39", "600": "#c0ca33", "700": "#afb42b", "800": "#9e9d24", "900": "#827717", "a100": "#f4ff81", "a200": "#eeff41", "a400": "#c6ff00", "a700": "#aeea00" };
var yellow = { "50": "#fffde7", "100": "#fff9c4", "200": "#fff59d", "300": "#fff176", "400": "#ffee58", "500": "#ffeb3b", "600": "#fdd835", "700": "#fbc02d", "800": "#f9a825", "900": "#f57f17", "a100": "#ffff8d", "a200": "#ffff00", "a400": "#ffea00", "a700": "#ffd600" };
var amber = { "50": "#fff8e1", "100": "#ffecb3", "200": "#ffe082", "300": "#ffd54f", "400": "#ffca28", "500": "#ffc107", "600": "#ffb300", "700": "#ffa000", "800": "#ff8f00", "900": "#ff6f00", "a100": "#ffe57f", "a200": "#ffd740", "a400": "#ffc400", "a700": "#ffab00" };
var orange = { "50": "#fff3e0", "100": "#ffe0b2", "200": "#ffcc80", "300": "#ffb74d", "400": "#ffa726", "500": "#ff9800", "600": "#fb8c00", "700": "#f57c00", "800": "#ef6c00", "900": "#e65100", "a100": "#ffd180", "a200": "#ffab40", "a400": "#ff9100", "a700": "#ff6d00" };
var deepOrange = { "50": "#fbe9e7", "100": "#ffccbc", "200": "#ffab91", "300": "#ff8a65", "400": "#ff7043", "500": "#ff5722", "600": "#f4511e", "700": "#e64a19", "800": "#d84315", "900": "#bf360c", "a100": "#ff9e80", "a200": "#ff6e40", "a400": "#ff3d00", "a700": "#dd2c00" };
var brown = { "50": "#efebe9", "100": "#d7ccc8", "200": "#bcaaa4", "300": "#a1887f", "400": "#8d6e63", "500": "#795548", "600": "#6d4c41", "700": "#5d4037", "800": "#4e342e", "900": "#3e2723" };
var blueGrey = { "50": "#eceff1", "100": "#cfd8dc", "200": "#b0bec5", "300": "#90a4ae", "400": "#78909c", "500": "#607d8b", "600": "#546e7a", "700": "#455a64", "800": "#37474f", "900": "#263238" };

// node_modules/react-color/es/components/circle/CircleSwatch.js
var import_react80 = __toESM(require_react());
var import_reactcss12 = __toESM(require_lib5());
var CircleSwatch = function CircleSwatch2(_ref) {
  var color = _ref.color, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover, hover = _ref.hover, active = _ref.active, circleSize = _ref.circleSize, circleSpacing = _ref.circleSpacing;
  var styles5 = (0, import_reactcss12.default)({
    "default": {
      swatch: {
        width: circleSize,
        height: circleSize,
        marginRight: circleSpacing,
        marginBottom: circleSpacing,
        transform: "scale(1)",
        transition: "100ms transform ease"
      },
      Swatch: {
        borderRadius: "50%",
        background: "transparent",
        boxShadow: "inset 0 0 0 " + (circleSize / 2 + 1) + "px " + color,
        transition: "100ms box-shadow ease"
      }
    },
    "hover": {
      swatch: {
        transform: "scale(1.2)"
      }
    },
    "active": {
      Swatch: {
        boxShadow: "inset 0 0 0 3px " + color
      }
    }
  }, { hover, active });
  return import_react80.default.createElement(
    "div",
    { style: styles5.swatch },
    import_react80.default.createElement(Swatch_default, {
      style: styles5.Swatch,
      color,
      onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: styles5.Swatch.boxShadow + ", 0 0 5px " + color }
    })
  );
};
CircleSwatch.defaultProps = {
  circleSize: 28,
  circleSpacing: 14
};
var CircleSwatch_default = (0, import_reactcss12.handleHover)(CircleSwatch);

// node_modules/react-color/es/components/circle/Circle.js
var Circle = function Circle2(_ref) {
  var width = _ref.width, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors = _ref.colors, hex = _ref.hex, circleSize = _ref.circleSize, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, circleSpacing = _ref.circleSpacing, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles5 = (0, import_reactcss13.default)(merge_default({
    "default": {
      card: {
        width,
        display: "flex",
        flexWrap: "wrap",
        marginRight: -circleSpacing,
        marginBottom: -circleSpacing
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(hexCode, e9) {
    return onChange({ hex: hexCode, source: "hex" }, e9);
  };
  return import_react81.default.createElement(
    "div",
    { style: styles5.card, className: "circle-picker " + className },
    map_default(colors, function(c16) {
      return import_react81.default.createElement(CircleSwatch_default, {
        key: c16,
        color: c16,
        onClick: handleChange,
        onSwatchHover,
        active: hex === c16.toLowerCase(),
        circleSize,
        circleSpacing
      });
    })
  );
};
Circle.propTypes = {
  width: import_prop_types5.default.oneOfType([import_prop_types5.default.string, import_prop_types5.default.number]),
  circleSize: import_prop_types5.default.number,
  circleSpacing: import_prop_types5.default.number,
  styles: import_prop_types5.default.object
};
Circle.defaultProps = {
  width: 252,
  circleSize: 28,
  circleSpacing: 14,
  colors: [red["500"], pink["500"], purple["500"], deepPurple["500"], indigo["500"], blue["500"], lightBlue["500"], cyan["500"], teal["500"], green["500"], lightGreen["500"], lime["500"], yellow["500"], amber["500"], orange["500"], deepOrange["500"], brown["500"], blueGrey["500"]],
  styles: {}
};
var Circle_default = ColorWrap_default(Circle);

// node_modules/react-color/es/components/chrome/Chrome.js
var import_react85 = __toESM(require_react());
var import_prop_types6 = __toESM(require_prop_types());
var import_reactcss17 = __toESM(require_lib5());

// node_modules/react-color/es/components/chrome/ChromeFields.js
var import_react82 = __toESM(require_react());
var import_reactcss14 = __toESM(require_lib5());

// node_modules/lodash-es/isUndefined.js
function isUndefined2(value) {
  return value === void 0;
}
var isUndefined_default = isUndefined2;

// node_modules/react-color/es/components/chrome/ChromeFields.js
var import_UnfoldMoreHorizontalIcon = __toESM(require_UnfoldMoreHorizontalIcon());
var _createClass7 = function() {
  function defineProperties(target, props) {
    for (var i15 = 0; i15 < props.length; i15++) {
      var descriptor = props[i15];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn7(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var ChromeFields = function(_React$Component) {
  _inherits7(ChromeFields2, _React$Component);
  function ChromeFields2(props) {
    _classCallCheck7(this, ChromeFields2);
    var _this = _possibleConstructorReturn7(this, (ChromeFields2.__proto__ || Object.getPrototypeOf(ChromeFields2)).call(this));
    _this.toggleViews = function() {
      if (_this.state.view === "hex") {
        _this.setState({ view: "rgb" });
      } else if (_this.state.view === "rgb") {
        _this.setState({ view: "hsl" });
      } else if (_this.state.view === "hsl") {
        if (_this.props.hsl.a === 1) {
          _this.setState({ view: "hex" });
        } else {
          _this.setState({ view: "rgb" });
        }
      }
    };
    _this.handleChange = function(data, e9) {
      if (data.hex) {
        isValidHex(data.hex) && _this.props.onChange({
          hex: data.hex,
          source: "hex"
        }, e9);
      } else if (data.r || data.g || data.b) {
        _this.props.onChange({
          r: data.r || _this.props.rgb.r,
          g: data.g || _this.props.rgb.g,
          b: data.b || _this.props.rgb.b,
          source: "rgb"
        }, e9);
      } else if (data.a) {
        if (data.a < 0) {
          data.a = 0;
        } else if (data.a > 1) {
          data.a = 1;
        }
        _this.props.onChange({
          h: _this.props.hsl.h,
          s: _this.props.hsl.s,
          l: _this.props.hsl.l,
          a: Math.round(data.a * 100) / 100,
          source: "rgb"
        }, e9);
      } else if (data.h || data.s || data.l) {
        if (typeof data.s === "string" && data.s.includes("%")) {
          data.s = data.s.replace("%", "");
        }
        if (typeof data.l === "string" && data.l.includes("%")) {
          data.l = data.l.replace("%", "");
        }
        if (data.s == 1) {
          data.s = 0.01;
        } else if (data.l == 1) {
          data.l = 0.01;
        }
        _this.props.onChange({
          h: data.h || _this.props.hsl.h,
          s: Number(!isUndefined_default(data.s) ? data.s : _this.props.hsl.s),
          l: Number(!isUndefined_default(data.l) ? data.l : _this.props.hsl.l),
          source: "hsl"
        }, e9);
      }
    };
    _this.showHighlight = function(e9) {
      e9.currentTarget.style.background = "#eee";
    };
    _this.hideHighlight = function(e9) {
      e9.currentTarget.style.background = "transparent";
    };
    if (props.hsl.a !== 1 && props.view === "hex") {
      _this.state = {
        view: "rgb"
      };
    } else {
      _this.state = {
        view: props.view
      };
    }
    return _this;
  }
  _createClass7(ChromeFields2, [{
    key: "render",
    value: function render3() {
      var _this2 = this;
      var styles5 = (0, import_reactcss14.default)({
        "default": {
          wrap: {
            paddingTop: "16px",
            display: "flex"
          },
          fields: {
            flex: "1",
            display: "flex",
            marginLeft: "-6px"
          },
          field: {
            paddingLeft: "6px",
            width: "100%"
          },
          alpha: {
            paddingLeft: "6px",
            width: "100%"
          },
          toggle: {
            width: "32px",
            textAlign: "right",
            position: "relative"
          },
          icon: {
            marginRight: "-4px",
            marginTop: "12px",
            cursor: "pointer",
            position: "relative"
          },
          iconHighlight: {
            position: "absolute",
            width: "24px",
            height: "28px",
            background: "#eee",
            borderRadius: "4px",
            top: "10px",
            left: "12px",
            display: "none"
          },
          input: {
            fontSize: "11px",
            color: "#333",
            width: "100%",
            borderRadius: "2px",
            border: "none",
            boxShadow: "inset 0 0 0 1px #dadada",
            height: "21px",
            textAlign: "center"
          },
          label: {
            textTransform: "uppercase",
            fontSize: "11px",
            lineHeight: "11px",
            color: "#969696",
            textAlign: "center",
            display: "block",
            marginTop: "12px"
          },
          svg: {
            fill: "#333",
            width: "24px",
            height: "24px",
            border: "1px transparent solid",
            borderRadius: "5px"
          }
        },
        "disableAlpha": {
          alpha: {
            display: "none"
          }
        }
      }, this.props, this.state);
      var fields = void 0;
      if (this.state.view === "hex") {
        fields = import_react82.default.createElement(
          "div",
          { style: styles5.fields, className: "flexbox-fix" },
          import_react82.default.createElement(
            "div",
            { style: styles5.field },
            import_react82.default.createElement(EditableInput_default, {
              style: { input: styles5.input, label: styles5.label },
              label: "hex",
              value: this.props.hex,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === "rgb") {
        fields = import_react82.default.createElement(
          "div",
          { style: styles5.fields, className: "flexbox-fix" },
          import_react82.default.createElement(
            "div",
            { style: styles5.field },
            import_react82.default.createElement(EditableInput_default, {
              style: { input: styles5.input, label: styles5.label },
              label: "r",
              value: this.props.rgb.r,
              onChange: this.handleChange
            })
          ),
          import_react82.default.createElement(
            "div",
            { style: styles5.field },
            import_react82.default.createElement(EditableInput_default, {
              style: { input: styles5.input, label: styles5.label },
              label: "g",
              value: this.props.rgb.g,
              onChange: this.handleChange
            })
          ),
          import_react82.default.createElement(
            "div",
            { style: styles5.field },
            import_react82.default.createElement(EditableInput_default, {
              style: { input: styles5.input, label: styles5.label },
              label: "b",
              value: this.props.rgb.b,
              onChange: this.handleChange
            })
          ),
          import_react82.default.createElement(
            "div",
            { style: styles5.alpha },
            import_react82.default.createElement(EditableInput_default, {
              style: { input: styles5.input, label: styles5.label },
              label: "a",
              value: this.props.rgb.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      } else if (this.state.view === "hsl") {
        fields = import_react82.default.createElement(
          "div",
          { style: styles5.fields, className: "flexbox-fix" },
          import_react82.default.createElement(
            "div",
            { style: styles5.field },
            import_react82.default.createElement(EditableInput_default, {
              style: { input: styles5.input, label: styles5.label },
              label: "h",
              value: Math.round(this.props.hsl.h),
              onChange: this.handleChange
            })
          ),
          import_react82.default.createElement(
            "div",
            { style: styles5.field },
            import_react82.default.createElement(EditableInput_default, {
              style: { input: styles5.input, label: styles5.label },
              label: "s",
              value: Math.round(this.props.hsl.s * 100) + "%",
              onChange: this.handleChange
            })
          ),
          import_react82.default.createElement(
            "div",
            { style: styles5.field },
            import_react82.default.createElement(EditableInput_default, {
              style: { input: styles5.input, label: styles5.label },
              label: "l",
              value: Math.round(this.props.hsl.l * 100) + "%",
              onChange: this.handleChange
            })
          ),
          import_react82.default.createElement(
            "div",
            { style: styles5.alpha },
            import_react82.default.createElement(EditableInput_default, {
              style: { input: styles5.input, label: styles5.label },
              label: "a",
              value: this.props.hsl.a,
              arrowOffset: 0.01,
              onChange: this.handleChange
            })
          )
        );
      }
      return import_react82.default.createElement(
        "div",
        { style: styles5.wrap, className: "flexbox-fix" },
        fields,
        import_react82.default.createElement(
          "div",
          { style: styles5.toggle },
          import_react82.default.createElement(
            "div",
            { style: styles5.icon, onClick: this.toggleViews, ref: function ref2(icon) {
              return _this2.icon = icon;
            } },
            import_react82.default.createElement(import_UnfoldMoreHorizontalIcon.default, {
              style: styles5.svg,
              onMouseOver: this.showHighlight,
              onMouseEnter: this.showHighlight,
              onMouseOut: this.hideHighlight
            })
          )
        )
      );
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, state) {
      if (nextProps.hsl.a !== 1 && state.view === "hex") {
        return { view: "rgb" };
      }
      return null;
    }
  }]);
  return ChromeFields2;
}(import_react82.default.Component);
ChromeFields.defaultProps = {
  view: "hex"
};
var ChromeFields_default = ChromeFields;

// node_modules/react-color/es/components/chrome/ChromePointer.js
var import_react83 = __toESM(require_react());
var import_reactcss15 = __toESM(require_lib5());
var ChromePointer = function ChromePointer2() {
  var styles5 = (0, import_reactcss15.default)({
    "default": {
      picker: {
        width: "12px",
        height: "12px",
        borderRadius: "6px",
        transform: "translate(-6px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    }
  });
  return import_react83.default.createElement("div", { style: styles5.picker });
};
var ChromePointer_default = ChromePointer;

// node_modules/react-color/es/components/chrome/ChromePointerCircle.js
var import_react84 = __toESM(require_react());
var import_reactcss16 = __toESM(require_lib5());
var ChromePointerCircle = function ChromePointerCircle2() {
  var styles5 = (0, import_reactcss16.default)({
    "default": {
      picker: {
        width: "12px",
        height: "12px",
        borderRadius: "6px",
        boxShadow: "inset 0 0 0 1px #fff",
        transform: "translate(-6px, -6px)"
      }
    }
  });
  return import_react84.default.createElement("div", { style: styles5.picker });
};
var ChromePointerCircle_default = ChromePointerCircle;

// node_modules/react-color/es/components/chrome/Chrome.js
var Chrome = function Chrome2(_ref) {
  var width = _ref.width, onChange = _ref.onChange, disableAlpha = _ref.disableAlpha, rgb = _ref.rgb, hsl = _ref.hsl, hsv = _ref.hsv, hex = _ref.hex, renderers = _ref.renderers, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className, defaultView = _ref.defaultView;
  var styles5 = (0, import_reactcss17.default)(merge_default({
    "default": {
      picker: {
        width,
        background: "#fff",
        borderRadius: "2px",
        boxShadow: "0 0 2px rgba(0,0,0,.3), 0 4px 8px rgba(0,0,0,.3)",
        boxSizing: "initial",
        fontFamily: "Menlo"
      },
      saturation: {
        width: "100%",
        paddingBottom: "55%",
        position: "relative",
        borderRadius: "2px 2px 0 0",
        overflow: "hidden"
      },
      Saturation: {
        radius: "2px 2px 0 0"
      },
      body: {
        padding: "16px 16px 12px"
      },
      controls: {
        display: "flex"
      },
      color: {
        width: "32px"
      },
      swatch: {
        marginTop: "6px",
        width: "16px",
        height: "16px",
        borderRadius: "8px",
        position: "relative",
        overflow: "hidden"
      },
      active: {
        absolute: "0px 0px 0px 0px",
        borderRadius: "8px",
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,.1)",
        background: "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", " + rgb.a + ")",
        zIndex: "2"
      },
      toggles: {
        flex: "1"
      },
      hue: {
        height: "10px",
        position: "relative",
        marginBottom: "8px"
      },
      Hue: {
        radius: "2px"
      },
      alpha: {
        height: "10px",
        position: "relative"
      },
      Alpha: {
        radius: "2px"
      }
    },
    "disableAlpha": {
      color: {
        width: "22px"
      },
      alpha: {
        display: "none"
      },
      hue: {
        marginBottom: "0px"
      },
      swatch: {
        width: "10px",
        height: "10px",
        marginTop: "0px"
      }
    }
  }, passedStyles), { disableAlpha });
  return import_react85.default.createElement(
    "div",
    { style: styles5.picker, className: "chrome-picker " + className },
    import_react85.default.createElement(
      "div",
      { style: styles5.saturation },
      import_react85.default.createElement(Saturation_default, {
        style: styles5.Saturation,
        hsl,
        hsv,
        pointer: ChromePointerCircle_default,
        onChange
      })
    ),
    import_react85.default.createElement(
      "div",
      { style: styles5.body },
      import_react85.default.createElement(
        "div",
        { style: styles5.controls, className: "flexbox-fix" },
        import_react85.default.createElement(
          "div",
          { style: styles5.color },
          import_react85.default.createElement(
            "div",
            { style: styles5.swatch },
            import_react85.default.createElement("div", { style: styles5.active }),
            import_react85.default.createElement(Checkboard_default, { renderers })
          )
        ),
        import_react85.default.createElement(
          "div",
          { style: styles5.toggles },
          import_react85.default.createElement(
            "div",
            { style: styles5.hue },
            import_react85.default.createElement(Hue_default, {
              style: styles5.Hue,
              hsl,
              pointer: ChromePointer_default,
              onChange
            })
          ),
          import_react85.default.createElement(
            "div",
            { style: styles5.alpha },
            import_react85.default.createElement(Alpha_default, {
              style: styles5.Alpha,
              rgb,
              hsl,
              pointer: ChromePointer_default,
              renderers,
              onChange
            })
          )
        )
      ),
      import_react85.default.createElement(ChromeFields_default, {
        rgb,
        hsl,
        hex,
        view: defaultView,
        onChange,
        disableAlpha
      })
    )
  );
};
Chrome.propTypes = {
  width: import_prop_types6.default.oneOfType([import_prop_types6.default.string, import_prop_types6.default.number]),
  disableAlpha: import_prop_types6.default.bool,
  styles: import_prop_types6.default.object,
  defaultView: import_prop_types6.default.oneOf(["hex", "rgb", "hsl"])
};
Chrome.defaultProps = {
  width: 225,
  disableAlpha: false,
  styles: {}
};
var Chrome_default = ColorWrap_default(Chrome);

// node_modules/react-color/es/components/compact/Compact.js
var import_react88 = __toESM(require_react());
var import_prop_types7 = __toESM(require_prop_types());
var import_reactcss20 = __toESM(require_lib5());

// node_modules/react-color/es/components/compact/CompactColor.js
var import_react86 = __toESM(require_react());
var import_reactcss18 = __toESM(require_lib5());
var CompactColor = function CompactColor2(_ref) {
  var color = _ref.color, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onSwatchHover = _ref.onSwatchHover, active = _ref.active;
  var styles5 = (0, import_reactcss18.default)({
    "default": {
      color: {
        background: color,
        width: "15px",
        height: "15px",
        float: "left",
        marginRight: "5px",
        marginBottom: "5px",
        position: "relative",
        cursor: "pointer"
      },
      dot: {
        absolute: "5px 5px 5px 5px",
        background: getContrastingColor(color),
        borderRadius: "50%",
        opacity: "0"
      }
    },
    "active": {
      dot: {
        opacity: "1"
      }
    },
    "color-#FFFFFF": {
      color: {
        boxShadow: "inset 0 0 0 1px #ddd"
      },
      dot: {
        background: "#000"
      }
    },
    "transparent": {
      dot: {
        background: "#000"
      }
    }
  }, { active, "color-#FFFFFF": color === "#FFFFFF", "transparent": color === "transparent" });
  return import_react86.default.createElement(
    Swatch_default,
    {
      style: styles5.color,
      color,
      onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: "0 0 4px " + color }
    },
    import_react86.default.createElement("div", { style: styles5.dot })
  );
};
var CompactColor_default = CompactColor;

// node_modules/react-color/es/components/compact/CompactFields.js
var import_react87 = __toESM(require_react());
var import_reactcss19 = __toESM(require_lib5());
var CompactFields = function CompactFields2(_ref) {
  var hex = _ref.hex, rgb = _ref.rgb, onChange = _ref.onChange;
  var styles5 = (0, import_reactcss19.default)({
    "default": {
      fields: {
        display: "flex",
        paddingBottom: "6px",
        paddingRight: "5px",
        position: "relative"
      },
      active: {
        position: "absolute",
        top: "6px",
        left: "5px",
        height: "9px",
        width: "9px",
        background: hex
      },
      HEXwrap: {
        flex: "6",
        position: "relative"
      },
      HEXinput: {
        width: "80%",
        padding: "0px",
        paddingLeft: "20%",
        border: "none",
        outline: "none",
        background: "none",
        fontSize: "12px",
        color: "#333",
        height: "16px"
      },
      HEXlabel: {
        display: "none"
      },
      RGBwrap: {
        flex: "3",
        position: "relative"
      },
      RGBinput: {
        width: "70%",
        padding: "0px",
        paddingLeft: "30%",
        border: "none",
        outline: "none",
        background: "none",
        fontSize: "12px",
        color: "#333",
        height: "16px"
      },
      RGBlabel: {
        position: "absolute",
        top: "3px",
        left: "0px",
        lineHeight: "16px",
        textTransform: "uppercase",
        fontSize: "12px",
        color: "#999"
      }
    }
  });
  var handleChange = function handleChange2(data, e9) {
    if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: "rgb"
      }, e9);
    } else {
      onChange({
        hex: data.hex,
        source: "hex"
      }, e9);
    }
  };
  return import_react87.default.createElement(
    "div",
    { style: styles5.fields, className: "flexbox-fix" },
    import_react87.default.createElement("div", { style: styles5.active }),
    import_react87.default.createElement(EditableInput_default, {
      style: { wrap: styles5.HEXwrap, input: styles5.HEXinput, label: styles5.HEXlabel },
      label: "hex",
      value: hex,
      onChange: handleChange
    }),
    import_react87.default.createElement(EditableInput_default, {
      style: { wrap: styles5.RGBwrap, input: styles5.RGBinput, label: styles5.RGBlabel },
      label: "r",
      value: rgb.r,
      onChange: handleChange
    }),
    import_react87.default.createElement(EditableInput_default, {
      style: { wrap: styles5.RGBwrap, input: styles5.RGBinput, label: styles5.RGBlabel },
      label: "g",
      value: rgb.g,
      onChange: handleChange
    }),
    import_react87.default.createElement(EditableInput_default, {
      style: { wrap: styles5.RGBwrap, input: styles5.RGBinput, label: styles5.RGBlabel },
      label: "b",
      value: rgb.b,
      onChange: handleChange
    })
  );
};
var CompactFields_default = CompactFields;

// node_modules/react-color/es/components/compact/Compact.js
var Compact = function Compact2(_ref) {
  var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors = _ref.colors, hex = _ref.hex, rgb = _ref.rgb, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles5 = (0, import_reactcss20.default)(merge_default({
    "default": {
      Compact: {
        background: "#f6f6f6",
        radius: "4px"
      },
      compact: {
        paddingTop: "5px",
        paddingLeft: "5px",
        boxSizing: "initial",
        width: "240px"
      },
      clear: {
        clear: "both"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data, e9) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e9);
    } else {
      onChange(data, e9);
    }
  };
  return import_react88.default.createElement(
    Raised_default,
    { style: styles5.Compact, styles: passedStyles },
    import_react88.default.createElement(
      "div",
      { style: styles5.compact, className: "compact-picker " + className },
      import_react88.default.createElement(
        "div",
        null,
        map_default(colors, function(c16) {
          return import_react88.default.createElement(CompactColor_default, {
            key: c16,
            color: c16,
            active: c16.toLowerCase() === hex,
            onClick: handleChange,
            onSwatchHover
          });
        }),
        import_react88.default.createElement("div", { style: styles5.clear })
      ),
      import_react88.default.createElement(CompactFields_default, { hex, rgb, onChange: handleChange })
    )
  );
};
Compact.propTypes = {
  colors: import_prop_types7.default.arrayOf(import_prop_types7.default.string),
  styles: import_prop_types7.default.object
};
Compact.defaultProps = {
  colors: ["#4D4D4D", "#999999", "#FFFFFF", "#F44E3B", "#FE9200", "#FCDC00", "#DBDF00", "#A4DD00", "#68CCCA", "#73D8FF", "#AEA1FF", "#FDA1FF", "#333333", "#808080", "#cccccc", "#D33115", "#E27300", "#FCC400", "#B0BC00", "#68BC00", "#16A5A5", "#009CE0", "#7B64FF", "#FA28FF", "#000000", "#666666", "#B3B3B3", "#9F0500", "#C45100", "#FB9E00", "#808900", "#194D33", "#0C797D", "#0062B1", "#653294", "#AB149E"],
  styles: {}
};
var Compact_default = ColorWrap_default(Compact);

// node_modules/react-color/es/components/github/Github.js
var import_react90 = __toESM(require_react());
var import_prop_types8 = __toESM(require_prop_types());
var import_reactcss22 = __toESM(require_lib5());

// node_modules/react-color/es/components/github/GithubSwatch.js
var import_react89 = __toESM(require_react());
var import_reactcss21 = __toESM(require_lib5());
var GithubSwatch = function GithubSwatch2(_ref) {
  var hover = _ref.hover, color = _ref.color, onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover;
  var hoverSwatch = {
    position: "relative",
    zIndex: "2",
    outline: "2px solid #fff",
    boxShadow: "0 0 5px 2px rgba(0,0,0,0.25)"
  };
  var styles5 = (0, import_reactcss21.default)({
    "default": {
      swatch: {
        width: "25px",
        height: "25px",
        fontSize: "0"
      }
    },
    "hover": {
      swatch: hoverSwatch
    }
  }, { hover });
  return import_react89.default.createElement(
    "div",
    { style: styles5.swatch },
    import_react89.default.createElement(Swatch_default, {
      color,
      onClick,
      onHover: onSwatchHover,
      focusStyle: hoverSwatch
    })
  );
};
var GithubSwatch_default = (0, import_reactcss21.handleHover)(GithubSwatch);

// node_modules/react-color/es/components/github/Github.js
var Github = function Github2(_ref) {
  var width = _ref.width, colors = _ref.colors, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles5 = (0, import_reactcss22.default)(merge_default({
    "default": {
      card: {
        width,
        background: "#fff",
        border: "1px solid rgba(0,0,0,0.2)",
        boxShadow: "0 3px 12px rgba(0,0,0,0.15)",
        borderRadius: "4px",
        position: "relative",
        padding: "5px",
        display: "flex",
        flexWrap: "wrap"
      },
      triangle: {
        position: "absolute",
        border: "7px solid transparent",
        borderBottomColor: "#fff"
      },
      triangleShadow: {
        position: "absolute",
        border: "8px solid transparent",
        borderBottomColor: "rgba(0,0,0,0.15)"
      }
    },
    "hide-triangle": {
      triangle: {
        display: "none"
      },
      triangleShadow: {
        display: "none"
      }
    },
    "top-left-triangle": {
      triangle: {
        top: "-14px",
        left: "10px"
      },
      triangleShadow: {
        top: "-16px",
        left: "9px"
      }
    },
    "top-right-triangle": {
      triangle: {
        top: "-14px",
        right: "10px"
      },
      triangleShadow: {
        top: "-16px",
        right: "9px"
      }
    },
    "bottom-left-triangle": {
      triangle: {
        top: "35px",
        left: "10px",
        transform: "rotate(180deg)"
      },
      triangleShadow: {
        top: "37px",
        left: "9px",
        transform: "rotate(180deg)"
      }
    },
    "bottom-right-triangle": {
      triangle: {
        top: "35px",
        right: "10px",
        transform: "rotate(180deg)"
      },
      triangleShadow: {
        top: "37px",
        right: "9px",
        transform: "rotate(180deg)"
      }
    }
  }, passedStyles), {
    "hide-triangle": triangle === "hide",
    "top-left-triangle": triangle === "top-left",
    "top-right-triangle": triangle === "top-right",
    "bottom-left-triangle": triangle === "bottom-left",
    "bottom-right-triangle": triangle === "bottom-right"
  });
  var handleChange = function handleChange2(hex, e9) {
    return onChange({ hex, source: "hex" }, e9);
  };
  return import_react90.default.createElement(
    "div",
    { style: styles5.card, className: "github-picker " + className },
    import_react90.default.createElement("div", { style: styles5.triangleShadow }),
    import_react90.default.createElement("div", { style: styles5.triangle }),
    map_default(colors, function(c16) {
      return import_react90.default.createElement(GithubSwatch_default, {
        color: c16,
        key: c16,
        onClick: handleChange,
        onSwatchHover
      });
    })
  );
};
Github.propTypes = {
  width: import_prop_types8.default.oneOfType([import_prop_types8.default.string, import_prop_types8.default.number]),
  colors: import_prop_types8.default.arrayOf(import_prop_types8.default.string),
  triangle: import_prop_types8.default.oneOf(["hide", "top-left", "top-right", "bottom-left", "bottom-right"]),
  styles: import_prop_types8.default.object
};
Github.defaultProps = {
  width: 200,
  colors: ["#B80000", "#DB3E00", "#FCCB00", "#008B02", "#006B76", "#1273DE", "#004DCF", "#5300EB", "#EB9694", "#FAD0C3", "#FEF3BD", "#C1E1C5", "#BEDADC", "#C4DEF6", "#BED3F3", "#D4C4FB"],
  triangle: "top-left",
  styles: {}
};
var Github_default = ColorWrap_default(Github);

// node_modules/react-color/es/components/hue/Hue.js
var import_react92 = __toESM(require_react());
var import_prop_types9 = __toESM(require_prop_types());
var import_reactcss24 = __toESM(require_lib5());

// node_modules/react-color/es/components/hue/HuePointer.js
var import_react91 = __toESM(require_react());
var import_reactcss23 = __toESM(require_lib5());
var SliderPointer = function SliderPointer2(_ref) {
  var direction = _ref.direction;
  var styles5 = (0, import_reactcss23.default)({
    "default": {
      picker: {
        width: "18px",
        height: "18px",
        borderRadius: "50%",
        transform: "translate(-9px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    },
    "vertical": {
      picker: {
        transform: "translate(-3px, -9px)"
      }
    }
  }, { vertical: direction === "vertical" });
  return import_react91.default.createElement("div", { style: styles5.picker });
};
var HuePointer_default = SliderPointer;

// node_modules/react-color/es/components/hue/Hue.js
var _extends13 = Object.assign || function(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var HuePicker = function HuePicker2(_ref) {
  var width = _ref.width, height = _ref.height, onChange = _ref.onChange, hsl = _ref.hsl, direction = _ref.direction, pointer = _ref.pointer, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles5 = (0, import_reactcss24.default)(merge_default({
    "default": {
      picker: {
        position: "relative",
        width,
        height
      },
      hue: {
        radius: "2px"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data) {
    return onChange({ a: 1, h: data.h, l: 0.5, s: 1 });
  };
  return import_react92.default.createElement(
    "div",
    { style: styles5.picker, className: "hue-picker " + className },
    import_react92.default.createElement(Hue_default, _extends13({}, styles5.hue, {
      hsl,
      pointer,
      onChange: handleChange,
      direction
    }))
  );
};
HuePicker.propTypes = {
  styles: import_prop_types9.default.object
};
HuePicker.defaultProps = {
  width: "316px",
  height: "16px",
  direction: "horizontal",
  pointer: HuePointer_default,
  styles: {}
};
var Hue_default2 = ColorWrap_default(HuePicker);

// node_modules/react-color/es/components/material/Material.js
var import_react93 = __toESM(require_react());
var import_reactcss25 = __toESM(require_lib5());
var Material = function Material2(_ref) {
  var onChange = _ref.onChange, hex = _ref.hex, rgb = _ref.rgb, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles5 = (0, import_reactcss25.default)(merge_default({
    "default": {
      material: {
        width: "98px",
        height: "98px",
        padding: "16px",
        fontFamily: "Roboto"
      },
      HEXwrap: {
        position: "relative"
      },
      HEXinput: {
        width: "100%",
        marginTop: "12px",
        fontSize: "15px",
        color: "#333",
        padding: "0px",
        border: "0px",
        borderBottom: "2px solid " + hex,
        outline: "none",
        height: "30px"
      },
      HEXlabel: {
        position: "absolute",
        top: "0px",
        left: "0px",
        fontSize: "11px",
        color: "#999999",
        textTransform: "capitalize"
      },
      Hex: {
        style: {}
      },
      RGBwrap: {
        position: "relative"
      },
      RGBinput: {
        width: "100%",
        marginTop: "12px",
        fontSize: "15px",
        color: "#333",
        padding: "0px",
        border: "0px",
        borderBottom: "1px solid #eee",
        outline: "none",
        height: "30px"
      },
      RGBlabel: {
        position: "absolute",
        top: "0px",
        left: "0px",
        fontSize: "11px",
        color: "#999999",
        textTransform: "capitalize"
      },
      split: {
        display: "flex",
        marginRight: "-10px",
        paddingTop: "11px"
      },
      third: {
        flex: "1",
        paddingRight: "10px"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data, e9) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e9);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: "rgb"
      }, e9);
    }
  };
  return import_react93.default.createElement(
    Raised_default,
    { styles: passedStyles },
    import_react93.default.createElement(
      "div",
      { style: styles5.material, className: "material-picker " + className },
      import_react93.default.createElement(EditableInput_default, {
        style: { wrap: styles5.HEXwrap, input: styles5.HEXinput, label: styles5.HEXlabel },
        label: "hex",
        value: hex,
        onChange: handleChange
      }),
      import_react93.default.createElement(
        "div",
        { style: styles5.split, className: "flexbox-fix" },
        import_react93.default.createElement(
          "div",
          { style: styles5.third },
          import_react93.default.createElement(EditableInput_default, {
            style: { wrap: styles5.RGBwrap, input: styles5.RGBinput, label: styles5.RGBlabel },
            label: "r",
            value: rgb.r,
            onChange: handleChange
          })
        ),
        import_react93.default.createElement(
          "div",
          { style: styles5.third },
          import_react93.default.createElement(EditableInput_default, {
            style: { wrap: styles5.RGBwrap, input: styles5.RGBinput, label: styles5.RGBlabel },
            label: "g",
            value: rgb.g,
            onChange: handleChange
          })
        ),
        import_react93.default.createElement(
          "div",
          { style: styles5.third },
          import_react93.default.createElement(EditableInput_default, {
            style: { wrap: styles5.RGBwrap, input: styles5.RGBinput, label: styles5.RGBlabel },
            label: "b",
            value: rgb.b,
            onChange: handleChange
          })
        )
      )
    )
  );
};
var Material_default = ColorWrap_default(Material);

// node_modules/react-color/es/components/photoshop/Photoshop.js
var import_react99 = __toESM(require_react());
var import_prop_types10 = __toESM(require_prop_types());
var import_reactcss31 = __toESM(require_lib5());

// node_modules/react-color/es/components/photoshop/PhotoshopFields.js
var import_react94 = __toESM(require_react());
var import_reactcss26 = __toESM(require_lib5());
var PhotoshopPicker = function PhotoshopPicker2(_ref) {
  var onChange = _ref.onChange, rgb = _ref.rgb, hsv = _ref.hsv, hex = _ref.hex;
  var styles5 = (0, import_reactcss26.default)({
    "default": {
      fields: {
        paddingTop: "5px",
        paddingBottom: "9px",
        width: "80px",
        position: "relative"
      },
      divider: {
        height: "5px"
      },
      RGBwrap: {
        position: "relative"
      },
      RGBinput: {
        marginLeft: "40%",
        width: "40%",
        height: "18px",
        border: "1px solid #888888",
        boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
        marginBottom: "5px",
        fontSize: "13px",
        paddingLeft: "3px",
        marginRight: "10px"
      },
      RGBlabel: {
        left: "0px",
        top: "0px",
        width: "34px",
        textTransform: "uppercase",
        fontSize: "13px",
        height: "18px",
        lineHeight: "22px",
        position: "absolute"
      },
      HEXwrap: {
        position: "relative"
      },
      HEXinput: {
        marginLeft: "20%",
        width: "80%",
        height: "18px",
        border: "1px solid #888888",
        boxShadow: "inset 0 1px 1px rgba(0,0,0,.1), 0 1px 0 0 #ECECEC",
        marginBottom: "6px",
        fontSize: "13px",
        paddingLeft: "3px"
      },
      HEXlabel: {
        position: "absolute",
        top: "0px",
        left: "0px",
        width: "14px",
        textTransform: "uppercase",
        fontSize: "13px",
        height: "18px",
        lineHeight: "22px"
      },
      fieldSymbols: {
        position: "absolute",
        top: "5px",
        right: "-7px",
        fontSize: "13px"
      },
      symbol: {
        height: "20px",
        lineHeight: "22px",
        paddingBottom: "7px"
      }
    }
  });
  var handleChange = function handleChange2(data, e9) {
    if (data["#"]) {
      isValidHex(data["#"]) && onChange({
        hex: data["#"],
        source: "hex"
      }, e9);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        source: "rgb"
      }, e9);
    } else if (data.h || data.s || data.v) {
      onChange({
        h: data.h || hsv.h,
        s: data.s || hsv.s,
        v: data.v || hsv.v,
        source: "hsv"
      }, e9);
    }
  };
  return import_react94.default.createElement(
    "div",
    { style: styles5.fields },
    import_react94.default.createElement(EditableInput_default, {
      style: { wrap: styles5.RGBwrap, input: styles5.RGBinput, label: styles5.RGBlabel },
      label: "h",
      value: Math.round(hsv.h),
      onChange: handleChange
    }),
    import_react94.default.createElement(EditableInput_default, {
      style: { wrap: styles5.RGBwrap, input: styles5.RGBinput, label: styles5.RGBlabel },
      label: "s",
      value: Math.round(hsv.s * 100),
      onChange: handleChange
    }),
    import_react94.default.createElement(EditableInput_default, {
      style: { wrap: styles5.RGBwrap, input: styles5.RGBinput, label: styles5.RGBlabel },
      label: "v",
      value: Math.round(hsv.v * 100),
      onChange: handleChange
    }),
    import_react94.default.createElement("div", { style: styles5.divider }),
    import_react94.default.createElement(EditableInput_default, {
      style: { wrap: styles5.RGBwrap, input: styles5.RGBinput, label: styles5.RGBlabel },
      label: "r",
      value: rgb.r,
      onChange: handleChange
    }),
    import_react94.default.createElement(EditableInput_default, {
      style: { wrap: styles5.RGBwrap, input: styles5.RGBinput, label: styles5.RGBlabel },
      label: "g",
      value: rgb.g,
      onChange: handleChange
    }),
    import_react94.default.createElement(EditableInput_default, {
      style: { wrap: styles5.RGBwrap, input: styles5.RGBinput, label: styles5.RGBlabel },
      label: "b",
      value: rgb.b,
      onChange: handleChange
    }),
    import_react94.default.createElement("div", { style: styles5.divider }),
    import_react94.default.createElement(EditableInput_default, {
      style: { wrap: styles5.HEXwrap, input: styles5.HEXinput, label: styles5.HEXlabel },
      label: "#",
      value: hex.replace("#", ""),
      onChange: handleChange
    }),
    import_react94.default.createElement(
      "div",
      { style: styles5.fieldSymbols },
      import_react94.default.createElement(
        "div",
        { style: styles5.symbol },
        "°"
      ),
      import_react94.default.createElement(
        "div",
        { style: styles5.symbol },
        "%"
      ),
      import_react94.default.createElement(
        "div",
        { style: styles5.symbol },
        "%"
      )
    )
  );
};
var PhotoshopFields_default = PhotoshopPicker;

// node_modules/react-color/es/components/photoshop/PhotoshopPointerCircle.js
var import_react95 = __toESM(require_react());
var import_reactcss27 = __toESM(require_lib5());
var PhotoshopPointerCircle = function PhotoshopPointerCircle2(_ref) {
  var hsl = _ref.hsl;
  var styles5 = (0, import_reactcss27.default)({
    "default": {
      picker: {
        width: "12px",
        height: "12px",
        borderRadius: "6px",
        boxShadow: "inset 0 0 0 1px #fff",
        transform: "translate(-6px, -6px)"
      }
    },
    "black-outline": {
      picker: {
        boxShadow: "inset 0 0 0 1px #000"
      }
    }
  }, { "black-outline": hsl.l > 0.5 });
  return import_react95.default.createElement("div", { style: styles5.picker });
};
var PhotoshopPointerCircle_default = PhotoshopPointerCircle;

// node_modules/react-color/es/components/photoshop/PhotoshopPointer.js
var import_react96 = __toESM(require_react());
var import_reactcss28 = __toESM(require_lib5());
var PhotoshopPointerCircle3 = function PhotoshopPointerCircle4() {
  var styles5 = (0, import_reactcss28.default)({
    "default": {
      triangle: {
        width: 0,
        height: 0,
        borderStyle: "solid",
        borderWidth: "4px 0 4px 6px",
        borderColor: "transparent transparent transparent #fff",
        position: "absolute",
        top: "1px",
        left: "1px"
      },
      triangleBorder: {
        width: 0,
        height: 0,
        borderStyle: "solid",
        borderWidth: "5px 0 5px 8px",
        borderColor: "transparent transparent transparent #555"
      },
      left: {
        Extend: "triangleBorder",
        transform: "translate(-13px, -4px)"
      },
      leftInside: {
        Extend: "triangle",
        transform: "translate(-8px, -5px)"
      },
      right: {
        Extend: "triangleBorder",
        transform: "translate(20px, -14px) rotate(180deg)"
      },
      rightInside: {
        Extend: "triangle",
        transform: "translate(-8px, -5px)"
      }
    }
  });
  return import_react96.default.createElement(
    "div",
    { style: styles5.pointer },
    import_react96.default.createElement(
      "div",
      { style: styles5.left },
      import_react96.default.createElement("div", { style: styles5.leftInside })
    ),
    import_react96.default.createElement(
      "div",
      { style: styles5.right },
      import_react96.default.createElement("div", { style: styles5.rightInside })
    )
  );
};
var PhotoshopPointer_default = PhotoshopPointerCircle3;

// node_modules/react-color/es/components/photoshop/PhotoshopButton.js
var import_react97 = __toESM(require_react());
var import_reactcss29 = __toESM(require_lib5());
var PhotoshopButton = function PhotoshopButton2(_ref) {
  var onClick = _ref.onClick, label = _ref.label, children = _ref.children, active = _ref.active;
  var styles5 = (0, import_reactcss29.default)({
    "default": {
      button: {
        backgroundImage: "linear-gradient(-180deg, #FFFFFF 0%, #E6E6E6 100%)",
        border: "1px solid #878787",
        borderRadius: "2px",
        height: "20px",
        boxShadow: "0 1px 0 0 #EAEAEA",
        fontSize: "14px",
        color: "#000",
        lineHeight: "20px",
        textAlign: "center",
        marginBottom: "10px",
        cursor: "pointer"
      }
    },
    "active": {
      button: {
        boxShadow: "0 0 0 1px #878787"
      }
    }
  }, { active });
  return import_react97.default.createElement(
    "div",
    { style: styles5.button, onClick },
    label || children
  );
};
var PhotoshopButton_default = PhotoshopButton;

// node_modules/react-color/es/components/photoshop/PhotoshopPreviews.js
var import_react98 = __toESM(require_react());
var import_reactcss30 = __toESM(require_lib5());
var PhotoshopPreviews = function PhotoshopPreviews2(_ref) {
  var rgb = _ref.rgb, currentColor = _ref.currentColor;
  var styles5 = (0, import_reactcss30.default)({
    "default": {
      swatches: {
        border: "1px solid #B3B3B3",
        borderBottom: "1px solid #F0F0F0",
        marginBottom: "2px",
        marginTop: "1px"
      },
      new: {
        height: "34px",
        background: "rgb(" + rgb.r + "," + rgb.g + ", " + rgb.b + ")",
        boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 1px 0 #000"
      },
      current: {
        height: "34px",
        background: currentColor,
        boxShadow: "inset 1px 0 0 #000, inset -1px 0 0 #000, inset 0 -1px 0 #000"
      },
      label: {
        fontSize: "14px",
        color: "#000",
        textAlign: "center"
      }
    }
  });
  return import_react98.default.createElement(
    "div",
    null,
    import_react98.default.createElement(
      "div",
      { style: styles5.label },
      "new"
    ),
    import_react98.default.createElement(
      "div",
      { style: styles5.swatches },
      import_react98.default.createElement("div", { style: styles5.new }),
      import_react98.default.createElement("div", { style: styles5.current })
    ),
    import_react98.default.createElement(
      "div",
      { style: styles5.label },
      "current"
    )
  );
};
var PhotoshopPreviews_default = PhotoshopPreviews;

// node_modules/react-color/es/components/photoshop/Photoshop.js
var _createClass8 = function() {
  function defineProperties(target, props) {
    for (var i15 = 0; i15 < props.length; i15++) {
      var descriptor = props[i15];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  return function(Constructor, protoProps, staticProps) {
    if (protoProps)
      defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();
function _classCallCheck8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _possibleConstructorReturn8(self2, call) {
  if (!self2) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return call && (typeof call === "object" || typeof call === "function") ? call : self2;
}
function _inherits8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });
  if (superClass)
    Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
}
var Photoshop = function(_React$Component) {
  _inherits8(Photoshop2, _React$Component);
  function Photoshop2(props) {
    _classCallCheck8(this, Photoshop2);
    var _this = _possibleConstructorReturn8(this, (Photoshop2.__proto__ || Object.getPrototypeOf(Photoshop2)).call(this));
    _this.state = {
      currentColor: props.hex
    };
    return _this;
  }
  _createClass8(Photoshop2, [{
    key: "render",
    value: function render3() {
      var _props = this.props, _props$styles = _props.styles, passedStyles = _props$styles === void 0 ? {} : _props$styles, _props$className = _props.className, className = _props$className === void 0 ? "" : _props$className;
      var styles5 = (0, import_reactcss31.default)(merge_default({
        "default": {
          picker: {
            background: "#DCDCDC",
            borderRadius: "4px",
            boxShadow: "0 0 0 1px rgba(0,0,0,.25), 0 8px 16px rgba(0,0,0,.15)",
            boxSizing: "initial",
            width: "513px"
          },
          head: {
            backgroundImage: "linear-gradient(-180deg, #F0F0F0 0%, #D4D4D4 100%)",
            borderBottom: "1px solid #B1B1B1",
            boxShadow: "inset 0 1px 0 0 rgba(255,255,255,.2), inset 0 -1px 0 0 rgba(0,0,0,.02)",
            height: "23px",
            lineHeight: "24px",
            borderRadius: "4px 4px 0 0",
            fontSize: "13px",
            color: "#4D4D4D",
            textAlign: "center"
          },
          body: {
            padding: "15px 15px 0",
            display: "flex"
          },
          saturation: {
            width: "256px",
            height: "256px",
            position: "relative",
            border: "2px solid #B3B3B3",
            borderBottom: "2px solid #F0F0F0",
            overflow: "hidden"
          },
          hue: {
            position: "relative",
            height: "256px",
            width: "19px",
            marginLeft: "10px",
            border: "2px solid #B3B3B3",
            borderBottom: "2px solid #F0F0F0"
          },
          controls: {
            width: "180px",
            marginLeft: "10px"
          },
          top: {
            display: "flex"
          },
          previews: {
            width: "60px"
          },
          actions: {
            flex: "1",
            marginLeft: "20px"
          }
        }
      }, passedStyles));
      return import_react99.default.createElement(
        "div",
        { style: styles5.picker, className: "photoshop-picker " + className },
        import_react99.default.createElement(
          "div",
          { style: styles5.head },
          this.props.header
        ),
        import_react99.default.createElement(
          "div",
          { style: styles5.body, className: "flexbox-fix" },
          import_react99.default.createElement(
            "div",
            { style: styles5.saturation },
            import_react99.default.createElement(Saturation_default, {
              hsl: this.props.hsl,
              hsv: this.props.hsv,
              pointer: PhotoshopPointerCircle_default,
              onChange: this.props.onChange
            })
          ),
          import_react99.default.createElement(
            "div",
            { style: styles5.hue },
            import_react99.default.createElement(Hue_default, {
              direction: "vertical",
              hsl: this.props.hsl,
              pointer: PhotoshopPointer_default,
              onChange: this.props.onChange
            })
          ),
          import_react99.default.createElement(
            "div",
            { style: styles5.controls },
            import_react99.default.createElement(
              "div",
              { style: styles5.top, className: "flexbox-fix" },
              import_react99.default.createElement(
                "div",
                { style: styles5.previews },
                import_react99.default.createElement(PhotoshopPreviews_default, {
                  rgb: this.props.rgb,
                  currentColor: this.state.currentColor
                })
              ),
              import_react99.default.createElement(
                "div",
                { style: styles5.actions },
                import_react99.default.createElement(PhotoshopButton_default, { label: "OK", onClick: this.props.onAccept, active: true }),
                import_react99.default.createElement(PhotoshopButton_default, { label: "Cancel", onClick: this.props.onCancel }),
                import_react99.default.createElement(PhotoshopFields_default, {
                  onChange: this.props.onChange,
                  rgb: this.props.rgb,
                  hsv: this.props.hsv,
                  hex: this.props.hex
                })
              )
            )
          )
        )
      );
    }
  }]);
  return Photoshop2;
}(import_react99.default.Component);
Photoshop.propTypes = {
  header: import_prop_types10.default.string,
  styles: import_prop_types10.default.object
};
Photoshop.defaultProps = {
  header: "Color Picker",
  styles: {}
};
var Photoshop_default = ColorWrap_default(Photoshop);

// node_modules/react-color/es/components/sketch/Sketch.js
var import_react102 = __toESM(require_react());
var import_prop_types12 = __toESM(require_prop_types());
var import_reactcss34 = __toESM(require_lib5());

// node_modules/react-color/es/components/sketch/SketchFields.js
var import_react100 = __toESM(require_react());
var import_reactcss32 = __toESM(require_lib5());
var SketchFields = function SketchFields2(_ref) {
  var onChange = _ref.onChange, rgb = _ref.rgb, hsl = _ref.hsl, hex = _ref.hex, disableAlpha = _ref.disableAlpha;
  var styles5 = (0, import_reactcss32.default)({
    "default": {
      fields: {
        display: "flex",
        paddingTop: "4px"
      },
      single: {
        flex: "1",
        paddingLeft: "6px"
      },
      alpha: {
        flex: "1",
        paddingLeft: "6px"
      },
      double: {
        flex: "2"
      },
      input: {
        width: "80%",
        padding: "4px 10% 3px",
        border: "none",
        boxShadow: "inset 0 0 0 1px #ccc",
        fontSize: "11px"
      },
      label: {
        display: "block",
        textAlign: "center",
        fontSize: "11px",
        color: "#222",
        paddingTop: "3px",
        paddingBottom: "4px",
        textTransform: "capitalize"
      }
    },
    "disableAlpha": {
      alpha: {
        display: "none"
      }
    }
  }, { disableAlpha });
  var handleChange = function handleChange2(data, e9) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e9);
    } else if (data.r || data.g || data.b) {
      onChange({
        r: data.r || rgb.r,
        g: data.g || rgb.g,
        b: data.b || rgb.b,
        a: rgb.a,
        source: "rgb"
      }, e9);
    } else if (data.a) {
      if (data.a < 0) {
        data.a = 0;
      } else if (data.a > 100) {
        data.a = 100;
      }
      data.a /= 100;
      onChange({
        h: hsl.h,
        s: hsl.s,
        l: hsl.l,
        a: data.a,
        source: "rgb"
      }, e9);
    }
  };
  return import_react100.default.createElement(
    "div",
    { style: styles5.fields, className: "flexbox-fix" },
    import_react100.default.createElement(
      "div",
      { style: styles5.double },
      import_react100.default.createElement(EditableInput_default, {
        style: { input: styles5.input, label: styles5.label },
        label: "hex",
        value: hex.replace("#", ""),
        onChange: handleChange
      })
    ),
    import_react100.default.createElement(
      "div",
      { style: styles5.single },
      import_react100.default.createElement(EditableInput_default, {
        style: { input: styles5.input, label: styles5.label },
        label: "r",
        value: rgb.r,
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "255"
      })
    ),
    import_react100.default.createElement(
      "div",
      { style: styles5.single },
      import_react100.default.createElement(EditableInput_default, {
        style: { input: styles5.input, label: styles5.label },
        label: "g",
        value: rgb.g,
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "255"
      })
    ),
    import_react100.default.createElement(
      "div",
      { style: styles5.single },
      import_react100.default.createElement(EditableInput_default, {
        style: { input: styles5.input, label: styles5.label },
        label: "b",
        value: rgb.b,
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "255"
      })
    ),
    import_react100.default.createElement(
      "div",
      { style: styles5.alpha },
      import_react100.default.createElement(EditableInput_default, {
        style: { input: styles5.input, label: styles5.label },
        label: "a",
        value: Math.round(rgb.a * 100),
        onChange: handleChange,
        dragLabel: "true",
        dragMax: "100"
      })
    )
  );
};
var SketchFields_default = SketchFields;

// node_modules/react-color/es/components/sketch/SketchPresetColors.js
var import_react101 = __toESM(require_react());
var import_prop_types11 = __toESM(require_prop_types());
var import_reactcss33 = __toESM(require_lib5());
var _extends14 = Object.assign || function(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var SketchPresetColors = function SketchPresetColors2(_ref) {
  var colors = _ref.colors, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onSwatchHover = _ref.onSwatchHover;
  var styles5 = (0, import_reactcss33.default)({
    "default": {
      colors: {
        margin: "0 -10px",
        padding: "10px 0 0 10px",
        borderTop: "1px solid #eee",
        display: "flex",
        flexWrap: "wrap",
        position: "relative"
      },
      swatchWrap: {
        width: "16px",
        height: "16px",
        margin: "0 10px 10px 0"
      },
      swatch: {
        borderRadius: "3px",
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15)"
      }
    },
    "no-presets": {
      colors: {
        display: "none"
      }
    }
  }, {
    "no-presets": !colors || !colors.length
  });
  var handleClick = function handleClick2(hex, e9) {
    onClick({
      hex,
      source: "hex"
    }, e9);
  };
  return import_react101.default.createElement(
    "div",
    { style: styles5.colors, className: "flexbox-fix" },
    colors.map(function(colorObjOrString) {
      var c16 = typeof colorObjOrString === "string" ? { color: colorObjOrString } : colorObjOrString;
      var key = "" + c16.color + (c16.title || "");
      return import_react101.default.createElement(
        "div",
        { key, style: styles5.swatchWrap },
        import_react101.default.createElement(Swatch_default, _extends14({}, c16, {
          style: styles5.swatch,
          onClick: handleClick,
          onHover: onSwatchHover,
          focusStyle: {
            boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), 0 0 4px " + c16.color
          }
        }))
      );
    })
  );
};
SketchPresetColors.propTypes = {
  colors: import_prop_types11.default.arrayOf(import_prop_types11.default.oneOfType([import_prop_types11.default.string, import_prop_types11.default.shape({
    color: import_prop_types11.default.string,
    title: import_prop_types11.default.string
  })])).isRequired
};
var SketchPresetColors_default = SketchPresetColors;

// node_modules/react-color/es/components/sketch/Sketch.js
var _extends15 = Object.assign || function(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = arguments[i15];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var Sketch = function Sketch2(_ref) {
  var width = _ref.width, rgb = _ref.rgb, hex = _ref.hex, hsv = _ref.hsv, hsl = _ref.hsl, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, disableAlpha = _ref.disableAlpha, presetColors2 = _ref.presetColors, renderers = _ref.renderers, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles5 = (0, import_reactcss34.default)(merge_default({
    "default": _extends15({
      picker: {
        width,
        padding: "10px 10px 0",
        boxSizing: "initial",
        background: "#fff",
        borderRadius: "4px",
        boxShadow: "0 0 0 1px rgba(0,0,0,.15), 0 8px 16px rgba(0,0,0,.15)"
      },
      saturation: {
        width: "100%",
        paddingBottom: "75%",
        position: "relative",
        overflow: "hidden"
      },
      Saturation: {
        radius: "3px",
        shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      },
      controls: {
        display: "flex"
      },
      sliders: {
        padding: "4px 0",
        flex: "1"
      },
      color: {
        width: "24px",
        height: "24px",
        position: "relative",
        marginTop: "4px",
        marginLeft: "4px",
        borderRadius: "3px"
      },
      activeColor: {
        absolute: "0px 0px 0px 0px",
        borderRadius: "2px",
        background: "rgba(" + rgb.r + "," + rgb.g + "," + rgb.b + "," + rgb.a + ")",
        boxShadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      },
      hue: {
        position: "relative",
        height: "10px",
        overflow: "hidden"
      },
      Hue: {
        radius: "2px",
        shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      },
      alpha: {
        position: "relative",
        height: "10px",
        marginTop: "4px",
        overflow: "hidden"
      },
      Alpha: {
        radius: "2px",
        shadow: "inset 0 0 0 1px rgba(0,0,0,.15), inset 0 0 4px rgba(0,0,0,.25)"
      }
    }, passedStyles),
    "disableAlpha": {
      color: {
        height: "10px"
      },
      hue: {
        height: "10px"
      },
      alpha: {
        display: "none"
      }
    }
  }, passedStyles), { disableAlpha });
  return import_react102.default.createElement(
    "div",
    { style: styles5.picker, className: "sketch-picker " + className },
    import_react102.default.createElement(
      "div",
      { style: styles5.saturation },
      import_react102.default.createElement(Saturation_default, {
        style: styles5.Saturation,
        hsl,
        hsv,
        onChange
      })
    ),
    import_react102.default.createElement(
      "div",
      { style: styles5.controls, className: "flexbox-fix" },
      import_react102.default.createElement(
        "div",
        { style: styles5.sliders },
        import_react102.default.createElement(
          "div",
          { style: styles5.hue },
          import_react102.default.createElement(Hue_default, {
            style: styles5.Hue,
            hsl,
            onChange
          })
        ),
        import_react102.default.createElement(
          "div",
          { style: styles5.alpha },
          import_react102.default.createElement(Alpha_default, {
            style: styles5.Alpha,
            rgb,
            hsl,
            renderers,
            onChange
          })
        )
      ),
      import_react102.default.createElement(
        "div",
        { style: styles5.color },
        import_react102.default.createElement(Checkboard_default, null),
        import_react102.default.createElement("div", { style: styles5.activeColor })
      )
    ),
    import_react102.default.createElement(SketchFields_default, {
      rgb,
      hsl,
      hex,
      onChange,
      disableAlpha
    }),
    import_react102.default.createElement(SketchPresetColors_default, {
      colors: presetColors2,
      onClick: onChange,
      onSwatchHover
    })
  );
};
Sketch.propTypes = {
  disableAlpha: import_prop_types12.default.bool,
  width: import_prop_types12.default.oneOfType([import_prop_types12.default.string, import_prop_types12.default.number]),
  styles: import_prop_types12.default.object
};
Sketch.defaultProps = {
  disableAlpha: false,
  width: 200,
  styles: {},
  presetColors: ["#D0021B", "#F5A623", "#F8E71C", "#8B572A", "#7ED321", "#417505", "#BD10E0", "#9013FE", "#4A90E2", "#50E3C2", "#B8E986", "#000000", "#4A4A4A", "#9B9B9B", "#FFFFFF"]
};
var Sketch_default = ColorWrap_default(Sketch);

// node_modules/react-color/es/components/slider/Slider.js
var import_react106 = __toESM(require_react());
var import_prop_types13 = __toESM(require_prop_types());
var import_reactcss38 = __toESM(require_lib5());

// node_modules/react-color/es/components/slider/SliderSwatches.js
var import_react104 = __toESM(require_react());
var import_reactcss36 = __toESM(require_lib5());

// node_modules/react-color/es/components/slider/SliderSwatch.js
var import_react103 = __toESM(require_react());
var import_reactcss35 = __toESM(require_lib5());
var SliderSwatch = function SliderSwatch2(_ref) {
  var hsl = _ref.hsl, offset5 = _ref.offset, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, active = _ref.active, first = _ref.first, last2 = _ref.last;
  var styles5 = (0, import_reactcss35.default)({
    "default": {
      swatch: {
        height: "12px",
        background: "hsl(" + hsl.h + ", 50%, " + offset5 * 100 + "%)",
        cursor: "pointer"
      }
    },
    "first": {
      swatch: {
        borderRadius: "2px 0 0 2px"
      }
    },
    "last": {
      swatch: {
        borderRadius: "0 2px 2px 0"
      }
    },
    "active": {
      swatch: {
        transform: "scaleY(1.8)",
        borderRadius: "3.6px/2px"
      }
    }
  }, { active, first, last: last2 });
  var handleClick = function handleClick2(e9) {
    return onClick({
      h: hsl.h,
      s: 0.5,
      l: offset5,
      source: "hsl"
    }, e9);
  };
  return import_react103.default.createElement("div", { style: styles5.swatch, onClick: handleClick });
};
var SliderSwatch_default = SliderSwatch;

// node_modules/react-color/es/components/slider/SliderSwatches.js
var SliderSwatches = function SliderSwatches2(_ref) {
  var onClick = _ref.onClick, hsl = _ref.hsl;
  var styles5 = (0, import_reactcss36.default)({
    "default": {
      swatches: {
        marginTop: "20px"
      },
      swatch: {
        boxSizing: "border-box",
        width: "20%",
        paddingRight: "1px",
        float: "left"
      },
      clear: {
        clear: "both"
      }
    }
  });
  var epsilon = 0.1;
  return import_react104.default.createElement(
    "div",
    { style: styles5.swatches },
    import_react104.default.createElement(
      "div",
      { style: styles5.swatch },
      import_react104.default.createElement(SliderSwatch_default, {
        hsl,
        offset: ".80",
        active: Math.abs(hsl.l - 0.8) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick,
        first: true
      })
    ),
    import_react104.default.createElement(
      "div",
      { style: styles5.swatch },
      import_react104.default.createElement(SliderSwatch_default, {
        hsl,
        offset: ".65",
        active: Math.abs(hsl.l - 0.65) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick
      })
    ),
    import_react104.default.createElement(
      "div",
      { style: styles5.swatch },
      import_react104.default.createElement(SliderSwatch_default, {
        hsl,
        offset: ".50",
        active: Math.abs(hsl.l - 0.5) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick
      })
    ),
    import_react104.default.createElement(
      "div",
      { style: styles5.swatch },
      import_react104.default.createElement(SliderSwatch_default, {
        hsl,
        offset: ".35",
        active: Math.abs(hsl.l - 0.35) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick
      })
    ),
    import_react104.default.createElement(
      "div",
      { style: styles5.swatch },
      import_react104.default.createElement(SliderSwatch_default, {
        hsl,
        offset: ".20",
        active: Math.abs(hsl.l - 0.2) < epsilon && Math.abs(hsl.s - 0.5) < epsilon,
        onClick,
        last: true
      })
    ),
    import_react104.default.createElement("div", { style: styles5.clear })
  );
};
var SliderSwatches_default = SliderSwatches;

// node_modules/react-color/es/components/slider/SliderPointer.js
var import_react105 = __toESM(require_react());
var import_reactcss37 = __toESM(require_lib5());
var SliderPointer3 = function SliderPointer4() {
  var styles5 = (0, import_reactcss37.default)({
    "default": {
      picker: {
        width: "14px",
        height: "14px",
        borderRadius: "6px",
        transform: "translate(-7px, -1px)",
        backgroundColor: "rgb(248, 248, 248)",
        boxShadow: "0 1px 4px 0 rgba(0, 0, 0, 0.37)"
      }
    }
  });
  return import_react105.default.createElement("div", { style: styles5.picker });
};
var SliderPointer_default = SliderPointer3;

// node_modules/react-color/es/components/slider/Slider.js
var Slider = function Slider2(_ref) {
  var hsl = _ref.hsl, onChange = _ref.onChange, pointer = _ref.pointer, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles5 = (0, import_reactcss38.default)(merge_default({
    "default": {
      hue: {
        height: "12px",
        position: "relative"
      },
      Hue: {
        radius: "2px"
      }
    }
  }, passedStyles));
  return import_react106.default.createElement(
    "div",
    { style: styles5.wrap || {}, className: "slider-picker " + className },
    import_react106.default.createElement(
      "div",
      { style: styles5.hue },
      import_react106.default.createElement(Hue_default, {
        style: styles5.Hue,
        hsl,
        pointer,
        onChange
      })
    ),
    import_react106.default.createElement(
      "div",
      { style: styles5.swatches },
      import_react106.default.createElement(SliderSwatches_default, { hsl, onClick: onChange })
    )
  );
};
Slider.propTypes = {
  styles: import_prop_types13.default.object
};
Slider.defaultProps = {
  pointer: SliderPointer_default,
  styles: {}
};
var Slider_default = ColorWrap_default(Slider);

// node_modules/react-color/es/components/swatches/Swatches.js
var import_react109 = __toESM(require_react());
var import_prop_types14 = __toESM(require_prop_types());
var import_reactcss41 = __toESM(require_lib5());

// node_modules/react-color/es/components/swatches/SwatchesGroup.js
var import_react108 = __toESM(require_react());
var import_reactcss40 = __toESM(require_lib5());

// node_modules/react-color/es/components/swatches/SwatchesColor.js
var import_react107 = __toESM(require_react());
var import_reactcss39 = __toESM(require_lib5());
var import_CheckIcon = __toESM(require_CheckIcon());
var SwatchesColor = function SwatchesColor2(_ref) {
  var color = _ref.color, _ref$onClick = _ref.onClick, onClick = _ref$onClick === void 0 ? function() {
  } : _ref$onClick, onSwatchHover = _ref.onSwatchHover, first = _ref.first, last2 = _ref.last, active = _ref.active;
  var styles5 = (0, import_reactcss39.default)({
    "default": {
      color: {
        width: "40px",
        height: "24px",
        cursor: "pointer",
        background: color,
        marginBottom: "1px"
      },
      check: {
        color: getContrastingColor(color),
        marginLeft: "8px",
        display: "none"
      }
    },
    "first": {
      color: {
        overflow: "hidden",
        borderRadius: "2px 2px 0 0"
      }
    },
    "last": {
      color: {
        overflow: "hidden",
        borderRadius: "0 0 2px 2px"
      }
    },
    "active": {
      check: {
        display: "block"
      }
    },
    "color-#FFFFFF": {
      color: {
        boxShadow: "inset 0 0 0 1px #ddd"
      },
      check: {
        color: "#333"
      }
    },
    "transparent": {
      check: {
        color: "#333"
      }
    }
  }, {
    first,
    last: last2,
    active,
    "color-#FFFFFF": color === "#FFFFFF",
    "transparent": color === "transparent"
  });
  return import_react107.default.createElement(
    Swatch_default,
    {
      color,
      style: styles5.color,
      onClick,
      onHover: onSwatchHover,
      focusStyle: { boxShadow: "0 0 4px " + color }
    },
    import_react107.default.createElement(
      "div",
      { style: styles5.check },
      import_react107.default.createElement(import_CheckIcon.default, null)
    )
  );
};
var SwatchesColor_default = SwatchesColor;

// node_modules/react-color/es/components/swatches/SwatchesGroup.js
var SwatchesGroup = function SwatchesGroup2(_ref) {
  var onClick = _ref.onClick, onSwatchHover = _ref.onSwatchHover, group = _ref.group, active = _ref.active;
  var styles5 = (0, import_reactcss40.default)({
    "default": {
      group: {
        paddingBottom: "10px",
        width: "40px",
        float: "left",
        marginRight: "10px"
      }
    }
  });
  return import_react108.default.createElement(
    "div",
    { style: styles5.group },
    map_default(group, function(color, i15) {
      return import_react108.default.createElement(SwatchesColor_default, {
        key: color,
        color,
        active: color.toLowerCase() === active,
        first: i15 === 0,
        last: i15 === group.length - 1,
        onClick,
        onSwatchHover
      });
    })
  );
};
var SwatchesGroup_default = SwatchesGroup;

// node_modules/react-color/es/components/swatches/Swatches.js
var Swatches = function Swatches2(_ref) {
  var width = _ref.width, height = _ref.height, onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, colors = _ref.colors, hex = _ref.hex, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles5 = (0, import_reactcss41.default)(merge_default({
    "default": {
      picker: {
        width,
        height
      },
      overflow: {
        height,
        overflowY: "scroll"
      },
      body: {
        padding: "16px 0 6px 16px"
      },
      clear: {
        clear: "both"
      }
    }
  }, passedStyles));
  var handleChange = function handleChange2(data, e9) {
    return onChange({ hex: data, source: "hex" }, e9);
  };
  return import_react109.default.createElement(
    "div",
    { style: styles5.picker, className: "swatches-picker " + className },
    import_react109.default.createElement(
      Raised_default,
      null,
      import_react109.default.createElement(
        "div",
        { style: styles5.overflow },
        import_react109.default.createElement(
          "div",
          { style: styles5.body },
          map_default(colors, function(group) {
            return import_react109.default.createElement(SwatchesGroup_default, {
              key: group.toString(),
              group,
              active: hex,
              onClick: handleChange,
              onSwatchHover
            });
          }),
          import_react109.default.createElement("div", { style: styles5.clear })
        )
      )
    )
  );
};
Swatches.propTypes = {
  width: import_prop_types14.default.oneOfType([import_prop_types14.default.string, import_prop_types14.default.number]),
  height: import_prop_types14.default.oneOfType([import_prop_types14.default.string, import_prop_types14.default.number]),
  colors: import_prop_types14.default.arrayOf(import_prop_types14.default.arrayOf(import_prop_types14.default.string)),
  styles: import_prop_types14.default.object
  /* eslint-disable max-len */
};
Swatches.defaultProps = {
  width: 320,
  height: 240,
  colors: [[red["900"], red["700"], red["500"], red["300"], red["100"]], [pink["900"], pink["700"], pink["500"], pink["300"], pink["100"]], [purple["900"], purple["700"], purple["500"], purple["300"], purple["100"]], [deepPurple["900"], deepPurple["700"], deepPurple["500"], deepPurple["300"], deepPurple["100"]], [indigo["900"], indigo["700"], indigo["500"], indigo["300"], indigo["100"]], [blue["900"], blue["700"], blue["500"], blue["300"], blue["100"]], [lightBlue["900"], lightBlue["700"], lightBlue["500"], lightBlue["300"], lightBlue["100"]], [cyan["900"], cyan["700"], cyan["500"], cyan["300"], cyan["100"]], [teal["900"], teal["700"], teal["500"], teal["300"], teal["100"]], ["#194D33", green["700"], green["500"], green["300"], green["100"]], [lightGreen["900"], lightGreen["700"], lightGreen["500"], lightGreen["300"], lightGreen["100"]], [lime["900"], lime["700"], lime["500"], lime["300"], lime["100"]], [yellow["900"], yellow["700"], yellow["500"], yellow["300"], yellow["100"]], [amber["900"], amber["700"], amber["500"], amber["300"], amber["100"]], [orange["900"], orange["700"], orange["500"], orange["300"], orange["100"]], [deepOrange["900"], deepOrange["700"], deepOrange["500"], deepOrange["300"], deepOrange["100"]], [brown["900"], brown["700"], brown["500"], brown["300"], brown["100"]], [blueGrey["900"], blueGrey["700"], blueGrey["500"], blueGrey["300"], blueGrey["100"]], ["#000000", "#525252", "#969696", "#D9D9D9", "#FFFFFF"]],
  styles: {}
};
var Swatches_default = ColorWrap_default(Swatches);

// node_modules/react-color/es/components/twitter/Twitter.js
var import_react110 = __toESM(require_react());
var import_prop_types15 = __toESM(require_prop_types());
var import_reactcss42 = __toESM(require_lib5());
var Twitter = function Twitter2(_ref) {
  var onChange = _ref.onChange, onSwatchHover = _ref.onSwatchHover, hex = _ref.hex, colors = _ref.colors, width = _ref.width, triangle = _ref.triangle, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles5 = (0, import_reactcss42.default)(merge_default({
    "default": {
      card: {
        width,
        background: "#fff",
        border: "0 solid rgba(0,0,0,0.25)",
        boxShadow: "0 1px 4px rgba(0,0,0,0.25)",
        borderRadius: "4px",
        position: "relative"
      },
      body: {
        padding: "15px 9px 9px 15px"
      },
      label: {
        fontSize: "18px",
        color: "#fff"
      },
      triangle: {
        width: "0px",
        height: "0px",
        borderStyle: "solid",
        borderWidth: "0 9px 10px 9px",
        borderColor: "transparent transparent #fff transparent",
        position: "absolute"
      },
      triangleShadow: {
        width: "0px",
        height: "0px",
        borderStyle: "solid",
        borderWidth: "0 9px 10px 9px",
        borderColor: "transparent transparent rgba(0,0,0,.1) transparent",
        position: "absolute"
      },
      hash: {
        background: "#F0F0F0",
        height: "30px",
        width: "30px",
        borderRadius: "4px 0 0 4px",
        float: "left",
        color: "#98A1A4",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      },
      input: {
        width: "100px",
        fontSize: "14px",
        color: "#666",
        border: "0px",
        outline: "none",
        height: "28px",
        boxShadow: "inset 0 0 0 1px #F0F0F0",
        boxSizing: "content-box",
        borderRadius: "0 4px 4px 0",
        float: "left",
        paddingLeft: "8px"
      },
      swatch: {
        width: "30px",
        height: "30px",
        float: "left",
        borderRadius: "4px",
        margin: "0 6px 6px 0"
      },
      clear: {
        clear: "both"
      }
    },
    "hide-triangle": {
      triangle: {
        display: "none"
      },
      triangleShadow: {
        display: "none"
      }
    },
    "top-left-triangle": {
      triangle: {
        top: "-10px",
        left: "12px"
      },
      triangleShadow: {
        top: "-11px",
        left: "12px"
      }
    },
    "top-right-triangle": {
      triangle: {
        top: "-10px",
        right: "12px"
      },
      triangleShadow: {
        top: "-11px",
        right: "12px"
      }
    }
  }, passedStyles), {
    "hide-triangle": triangle === "hide",
    "top-left-triangle": triangle === "top-left",
    "top-right-triangle": triangle === "top-right"
  });
  var handleChange = function handleChange2(hexcode, e9) {
    isValidHex(hexcode) && onChange({
      hex: hexcode,
      source: "hex"
    }, e9);
  };
  return import_react110.default.createElement(
    "div",
    { style: styles5.card, className: "twitter-picker " + className },
    import_react110.default.createElement("div", { style: styles5.triangleShadow }),
    import_react110.default.createElement("div", { style: styles5.triangle }),
    import_react110.default.createElement(
      "div",
      { style: styles5.body },
      map_default(colors, function(c16, i15) {
        return import_react110.default.createElement(Swatch_default, {
          key: i15,
          color: c16,
          hex: c16,
          style: styles5.swatch,
          onClick: handleChange,
          onHover: onSwatchHover,
          focusStyle: {
            boxShadow: "0 0 4px " + c16
          }
        });
      }),
      import_react110.default.createElement(
        "div",
        { style: styles5.hash },
        "#"
      ),
      import_react110.default.createElement(EditableInput_default, {
        label: null,
        style: { input: styles5.input },
        value: hex.replace("#", ""),
        onChange: handleChange
      }),
      import_react110.default.createElement("div", { style: styles5.clear })
    )
  );
};
Twitter.propTypes = {
  width: import_prop_types15.default.oneOfType([import_prop_types15.default.string, import_prop_types15.default.number]),
  triangle: import_prop_types15.default.oneOf(["hide", "top-left", "top-right"]),
  colors: import_prop_types15.default.arrayOf(import_prop_types15.default.string),
  styles: import_prop_types15.default.object
};
Twitter.defaultProps = {
  width: 276,
  colors: ["#FF6900", "#FCB900", "#7BDCB5", "#00D084", "#8ED1FC", "#0693E3", "#ABB8C3", "#EB144C", "#F78DA7", "#9900EF"],
  triangle: "top-left",
  styles: {}
};
var Twitter_default = ColorWrap_default(Twitter);

// node_modules/react-color/es/components/google/Google.js
var import_react114 = __toESM(require_react());
var import_prop_types18 = __toESM(require_prop_types());
var import_reactcss46 = __toESM(require_lib5());

// node_modules/react-color/es/components/google/GooglePointerCircle.js
var import_react111 = __toESM(require_react());
var import_reactcss43 = __toESM(require_lib5());
var import_prop_types16 = __toESM(require_prop_types());
var GooglePointerCircle = function GooglePointerCircle2(props) {
  var styles5 = (0, import_reactcss43.default)({
    "default": {
      picker: {
        width: "20px",
        height: "20px",
        borderRadius: "22px",
        border: "2px #fff solid",
        transform: "translate(-12px, -13px)",
        background: "hsl(" + Math.round(props.hsl.h) + ", " + Math.round(props.hsl.s * 100) + "%, " + Math.round(props.hsl.l * 100) + "%)"
      }
    }
  });
  return import_react111.default.createElement("div", { style: styles5.picker });
};
GooglePointerCircle.propTypes = {
  hsl: import_prop_types16.default.shape({
    h: import_prop_types16.default.number,
    s: import_prop_types16.default.number,
    l: import_prop_types16.default.number,
    a: import_prop_types16.default.number
  })
};
GooglePointerCircle.defaultProps = {
  hsl: { a: 1, h: 249.94, l: 0.2, s: 0.5 }
};
var GooglePointerCircle_default = GooglePointerCircle;

// node_modules/react-color/es/components/google/GooglePointer.js
var import_react112 = __toESM(require_react());
var import_reactcss44 = __toESM(require_lib5());
var import_prop_types17 = __toESM(require_prop_types());
var GooglePointer = function GooglePointer2(props) {
  var styles5 = (0, import_reactcss44.default)({
    "default": {
      picker: {
        width: "20px",
        height: "20px",
        borderRadius: "22px",
        transform: "translate(-10px, -7px)",
        background: "hsl(" + Math.round(props.hsl.h) + ", 100%, 50%)",
        border: "2px white solid"
      }
    }
  });
  return import_react112.default.createElement("div", { style: styles5.picker });
};
GooglePointer.propTypes = {
  hsl: import_prop_types17.default.shape({
    h: import_prop_types17.default.number,
    s: import_prop_types17.default.number,
    l: import_prop_types17.default.number,
    a: import_prop_types17.default.number
  })
};
GooglePointer.defaultProps = {
  hsl: { a: 1, h: 249.94, l: 0.2, s: 0.5 }
};
var GooglePointer_default = GooglePointer;

// node_modules/react-color/es/components/google/GoogleFields.js
var import_react113 = __toESM(require_react());
var import_reactcss45 = __toESM(require_lib5());
var GoogleFields = function GoogleFields2(_ref) {
  var onChange = _ref.onChange, rgb = _ref.rgb, hsl = _ref.hsl, hex = _ref.hex, hsv = _ref.hsv;
  var handleChange = function handleChange2(data, e9) {
    if (data.hex) {
      isValidHex(data.hex) && onChange({
        hex: data.hex,
        source: "hex"
      }, e9);
    } else if (data.rgb) {
      var values3 = data.rgb.split(",");
      isvalidColorString(data.rgb, "rgb") && onChange({
        r: values3[0],
        g: values3[1],
        b: values3[2],
        a: 1,
        source: "rgb"
      }, e9);
    } else if (data.hsv) {
      var _values = data.hsv.split(",");
      if (isvalidColorString(data.hsv, "hsv")) {
        _values[2] = _values[2].replace("%", "");
        _values[1] = _values[1].replace("%", "");
        _values[0] = _values[0].replace("°", "");
        if (_values[1] == 1) {
          _values[1] = 0.01;
        } else if (_values[2] == 1) {
          _values[2] = 0.01;
        }
        onChange({
          h: Number(_values[0]),
          s: Number(_values[1]),
          v: Number(_values[2]),
          source: "hsv"
        }, e9);
      }
    } else if (data.hsl) {
      var _values2 = data.hsl.split(",");
      if (isvalidColorString(data.hsl, "hsl")) {
        _values2[2] = _values2[2].replace("%", "");
        _values2[1] = _values2[1].replace("%", "");
        _values2[0] = _values2[0].replace("°", "");
        if (hsvValue[1] == 1) {
          hsvValue[1] = 0.01;
        } else if (hsvValue[2] == 1) {
          hsvValue[2] = 0.01;
        }
        onChange({
          h: Number(_values2[0]),
          s: Number(_values2[1]),
          v: Number(_values2[2]),
          source: "hsl"
        }, e9);
      }
    }
  };
  var styles5 = (0, import_reactcss45.default)({
    "default": {
      wrap: {
        display: "flex",
        height: "100px",
        marginTop: "4px"
      },
      fields: {
        width: "100%"
      },
      column: {
        paddingTop: "10px",
        display: "flex",
        justifyContent: "space-between"
      },
      double: {
        padding: "0px 4.4px",
        boxSizing: "border-box"
      },
      input: {
        width: "100%",
        height: "38px",
        boxSizing: "border-box",
        padding: "4px 10% 3px",
        textAlign: "center",
        border: "1px solid #dadce0",
        fontSize: "11px",
        textTransform: "lowercase",
        borderRadius: "5px",
        outline: "none",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      input2: {
        height: "38px",
        width: "100%",
        border: "1px solid #dadce0",
        boxSizing: "border-box",
        fontSize: "11px",
        textTransform: "lowercase",
        borderRadius: "5px",
        outline: "none",
        paddingLeft: "10px",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      label: {
        textAlign: "center",
        fontSize: "12px",
        background: "#fff",
        position: "absolute",
        textTransform: "uppercase",
        color: "#3c4043",
        width: "35px",
        top: "-6px",
        left: "0",
        right: "0",
        marginLeft: "auto",
        marginRight: "auto",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      label2: {
        left: "10px",
        textAlign: "center",
        fontSize: "12px",
        background: "#fff",
        position: "absolute",
        textTransform: "uppercase",
        color: "#3c4043",
        width: "32px",
        top: "-6px",
        fontFamily: "Roboto,Arial,sans-serif"
      },
      single: {
        flexGrow: "1",
        margin: "0px 4.4px"
      }
    }
  });
  var rgbValue = rgb.r + ", " + rgb.g + ", " + rgb.b;
  var hslValue = Math.round(hsl.h) + "°, " + Math.round(hsl.s * 100) + "%, " + Math.round(hsl.l * 100) + "%";
  var hsvValue = Math.round(hsv.h) + "°, " + Math.round(hsv.s * 100) + "%, " + Math.round(hsv.v * 100) + "%";
  return import_react113.default.createElement(
    "div",
    { style: styles5.wrap, className: "flexbox-fix" },
    import_react113.default.createElement(
      "div",
      { style: styles5.fields },
      import_react113.default.createElement(
        "div",
        { style: styles5.double },
        import_react113.default.createElement(EditableInput_default, {
          style: { input: styles5.input, label: styles5.label },
          label: "hex",
          value: hex,
          onChange: handleChange
        })
      ),
      import_react113.default.createElement(
        "div",
        { style: styles5.column },
        import_react113.default.createElement(
          "div",
          { style: styles5.single },
          import_react113.default.createElement(EditableInput_default, {
            style: { input: styles5.input2, label: styles5.label2 },
            label: "rgb",
            value: rgbValue,
            onChange: handleChange
          })
        ),
        import_react113.default.createElement(
          "div",
          { style: styles5.single },
          import_react113.default.createElement(EditableInput_default, {
            style: { input: styles5.input2, label: styles5.label2 },
            label: "hsv",
            value: hsvValue,
            onChange: handleChange
          })
        ),
        import_react113.default.createElement(
          "div",
          { style: styles5.single },
          import_react113.default.createElement(EditableInput_default, {
            style: { input: styles5.input2, label: styles5.label2 },
            label: "hsl",
            value: hslValue,
            onChange: handleChange
          })
        )
      )
    )
  );
};
var GoogleFields_default = GoogleFields;

// node_modules/react-color/es/components/google/Google.js
var Google = function Google2(_ref) {
  var width = _ref.width, onChange = _ref.onChange, rgb = _ref.rgb, hsl = _ref.hsl, hsv = _ref.hsv, hex = _ref.hex, header = _ref.header, _ref$styles = _ref.styles, passedStyles = _ref$styles === void 0 ? {} : _ref$styles, _ref$className = _ref.className, className = _ref$className === void 0 ? "" : _ref$className;
  var styles5 = (0, import_reactcss46.default)(merge_default({
    "default": {
      picker: {
        width,
        background: "#fff",
        border: "1px solid #dfe1e5",
        boxSizing: "initial",
        display: "flex",
        flexWrap: "wrap",
        borderRadius: "8px 8px 0px 0px"
      },
      head: {
        height: "57px",
        width: "100%",
        paddingTop: "16px",
        paddingBottom: "16px",
        paddingLeft: "16px",
        fontSize: "20px",
        boxSizing: "border-box",
        fontFamily: "Roboto-Regular,HelveticaNeue,Arial,sans-serif"
      },
      saturation: {
        width: "70%",
        padding: "0px",
        position: "relative",
        overflow: "hidden"
      },
      swatch: {
        width: "30%",
        height: "228px",
        padding: "0px",
        background: "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", 1)",
        position: "relative",
        overflow: "hidden"
      },
      body: {
        margin: "auto",
        width: "95%"
      },
      controls: {
        display: "flex",
        boxSizing: "border-box",
        height: "52px",
        paddingTop: "22px"
      },
      color: {
        width: "32px"
      },
      hue: {
        height: "8px",
        position: "relative",
        margin: "0px 16px 0px 16px",
        width: "100%"
      },
      Hue: {
        radius: "2px"
      }
    }
  }, passedStyles));
  return import_react114.default.createElement(
    "div",
    { style: styles5.picker, className: "google-picker " + className },
    import_react114.default.createElement(
      "div",
      { style: styles5.head },
      header
    ),
    import_react114.default.createElement("div", { style: styles5.swatch }),
    import_react114.default.createElement(
      "div",
      { style: styles5.saturation },
      import_react114.default.createElement(Saturation_default, {
        hsl,
        hsv,
        pointer: GooglePointerCircle_default,
        onChange
      })
    ),
    import_react114.default.createElement(
      "div",
      { style: styles5.body },
      import_react114.default.createElement(
        "div",
        { style: styles5.controls, className: "flexbox-fix" },
        import_react114.default.createElement(
          "div",
          { style: styles5.hue },
          import_react114.default.createElement(Hue_default, {
            style: styles5.Hue,
            hsl,
            radius: "4px",
            pointer: GooglePointer_default,
            onChange
          })
        )
      ),
      import_react114.default.createElement(GoogleFields_default, {
        rgb,
        hsl,
        hex,
        hsv,
        onChange
      })
    )
  );
};
Google.propTypes = {
  width: import_prop_types18.default.oneOfType([import_prop_types18.default.string, import_prop_types18.default.number]),
  styles: import_prop_types18.default.object,
  header: import_prop_types18.default.string
};
Google.defaultProps = {
  width: 652,
  styles: {},
  header: "Color picker"
};
var Google_default = ColorWrap_default(Google);

// node_modules/@tinacms/toolkit/dist/index.es.js
var import_color_string = __toESM(require_color_string());

// node_modules/react-dropzone/dist/es/index.js
var import_react115 = __toESM(require_react());
var import_prop_types19 = __toESM(require_prop_types());

// node_modules/file-selector/dist/es5/file.js
var COMMON_MIME_TYPES = /* @__PURE__ */ new Map([
  // https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types
  ["aac", "audio/aac"],
  ["abw", "application/x-abiword"],
  ["arc", "application/x-freearc"],
  ["avif", "image/avif"],
  ["avi", "video/x-msvideo"],
  ["azw", "application/vnd.amazon.ebook"],
  ["bin", "application/octet-stream"],
  ["bmp", "image/bmp"],
  ["bz", "application/x-bzip"],
  ["bz2", "application/x-bzip2"],
  ["cda", "application/x-cdf"],
  ["csh", "application/x-csh"],
  ["css", "text/css"],
  ["csv", "text/csv"],
  ["doc", "application/msword"],
  ["docx", "application/vnd.openxmlformats-officedocument.wordprocessingml.document"],
  ["eot", "application/vnd.ms-fontobject"],
  ["epub", "application/epub+zip"],
  ["gz", "application/gzip"],
  ["gif", "image/gif"],
  ["heic", "image/heic"],
  ["heif", "image/heif"],
  ["htm", "text/html"],
  ["html", "text/html"],
  ["ico", "image/vnd.microsoft.icon"],
  ["ics", "text/calendar"],
  ["jar", "application/java-archive"],
  ["jpeg", "image/jpeg"],
  ["jpg", "image/jpeg"],
  ["js", "text/javascript"],
  ["json", "application/json"],
  ["jsonld", "application/ld+json"],
  ["mid", "audio/midi"],
  ["midi", "audio/midi"],
  ["mjs", "text/javascript"],
  ["mp3", "audio/mpeg"],
  ["mp4", "video/mp4"],
  ["mpeg", "video/mpeg"],
  ["mpkg", "application/vnd.apple.installer+xml"],
  ["odp", "application/vnd.oasis.opendocument.presentation"],
  ["ods", "application/vnd.oasis.opendocument.spreadsheet"],
  ["odt", "application/vnd.oasis.opendocument.text"],
  ["oga", "audio/ogg"],
  ["ogv", "video/ogg"],
  ["ogx", "application/ogg"],
  ["opus", "audio/opus"],
  ["otf", "font/otf"],
  ["png", "image/png"],
  ["pdf", "application/pdf"],
  ["php", "application/x-httpd-php"],
  ["ppt", "application/vnd.ms-powerpoint"],
  ["pptx", "application/vnd.openxmlformats-officedocument.presentationml.presentation"],
  ["rar", "application/vnd.rar"],
  ["rtf", "application/rtf"],
  ["sh", "application/x-sh"],
  ["svg", "image/svg+xml"],
  ["swf", "application/x-shockwave-flash"],
  ["tar", "application/x-tar"],
  ["tif", "image/tiff"],
  ["tiff", "image/tiff"],
  ["ts", "video/mp2t"],
  ["ttf", "font/ttf"],
  ["txt", "text/plain"],
  ["vsd", "application/vnd.visio"],
  ["wav", "audio/wav"],
  ["weba", "audio/webm"],
  ["webm", "video/webm"],
  ["webp", "image/webp"],
  ["woff", "font/woff"],
  ["woff2", "font/woff2"],
  ["xhtml", "application/xhtml+xml"],
  ["xls", "application/vnd.ms-excel"],
  ["xlsx", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"],
  ["xml", "application/xml"],
  ["xul", "application/vnd.mozilla.xul+xml"],
  ["zip", "application/zip"],
  ["7z", "application/x-7z-compressed"],
  // Others
  ["mkv", "video/x-matroska"],
  ["mov", "video/quicktime"],
  ["msg", "application/vnd.ms-outlook"]
]);
function toFileWithPath(file, path) {
  var f16 = withMimeType(file);
  if (typeof f16.path !== "string") {
    var webkitRelativePath = file.webkitRelativePath;
    Object.defineProperty(f16, "path", {
      value: typeof path === "string" ? path : typeof webkitRelativePath === "string" && webkitRelativePath.length > 0 ? webkitRelativePath : file.name,
      writable: false,
      configurable: false,
      enumerable: true
    });
  }
  return f16;
}
function withMimeType(file) {
  var name2 = file.name;
  var hasExtension = name2 && name2.lastIndexOf(".") !== -1;
  if (hasExtension && !file.type) {
    var ext = name2.split(".").pop().toLowerCase();
    var type = COMMON_MIME_TYPES.get(ext);
    if (type) {
      Object.defineProperty(file, "type", {
        value: type,
        writable: false,
        configurable: false,
        enumerable: true
      });
    }
  }
  return file;
}

// node_modules/file-selector/dist/es5/file-selector.js
var FILES_TO_IGNORE = [
  // Thumbnail cache files for macOS and Windows
  ".DS_Store",
  "Thumbs.db"
  // Windows
];
function fromEvent(evt) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a) {
      if (isObject7(evt) && isDataTransfer(evt.dataTransfer)) {
        return [2, getDataTransferFiles(evt.dataTransfer, evt.type)];
      } else if (isChangeEvt(evt)) {
        return [2, getInputFiles(evt)];
      } else if (Array.isArray(evt) && evt.every(function(item) {
        return "getFile" in item && typeof item.getFile === "function";
      })) {
        return [2, getFsHandleFiles(evt)];
      }
      return [2, []];
    });
  });
}
function isDataTransfer(value) {
  return isObject7(value);
}
function isChangeEvt(value) {
  return isObject7(value) && isObject7(value.target);
}
function isObject7(v6) {
  return typeof v6 === "object" && v6 !== null;
}
function getInputFiles(evt) {
  return fromList(evt.target.files).map(function(file) {
    return toFileWithPath(file);
  });
}
function getFsHandleFiles(handles) {
  return __awaiter(this, void 0, void 0, function() {
    var files;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          return [4, Promise.all(handles.map(function(h11) {
            return h11.getFile();
          }))];
        case 1:
          files = _a.sent();
          return [2, files.map(function(file) {
            return toFileWithPath(file);
          })];
      }
    });
  });
}
function getDataTransferFiles(dt, type) {
  return __awaiter(this, void 0, void 0, function() {
    var items, files;
    return __generator(this, function(_a) {
      switch (_a.label) {
        case 0:
          if (!dt.items)
            return [3, 2];
          items = fromList(dt.items).filter(function(item) {
            return item.kind === "file";
          });
          if (type !== "drop") {
            return [2, items];
          }
          return [4, Promise.all(items.map(toFilePromises))];
        case 1:
          files = _a.sent();
          return [2, noIgnoredFiles(flatten2(files))];
        case 2:
          return [2, noIgnoredFiles(fromList(dt.files).map(function(file) {
            return toFileWithPath(file);
          }))];
      }
    });
  });
}
function noIgnoredFiles(files) {
  return files.filter(function(file) {
    return FILES_TO_IGNORE.indexOf(file.name) === -1;
  });
}
function fromList(items) {
  if (items === null) {
    return [];
  }
  var files = [];
  for (var i15 = 0; i15 < items.length; i15++) {
    var file = items[i15];
    files.push(file);
  }
  return files;
}
function toFilePromises(item) {
  if (typeof item.webkitGetAsEntry !== "function") {
    return fromDataTransferItem(item);
  }
  var entry = item.webkitGetAsEntry();
  if (entry && entry.isDirectory) {
    return fromDirEntry(entry);
  }
  return fromDataTransferItem(item);
}
function flatten2(items) {
  return items.reduce(function(acc, files) {
    return __spreadArray(__spreadArray([], __read(acc), false), __read(Array.isArray(files) ? flatten2(files) : [files]), false);
  }, []);
}
function fromDataTransferItem(item) {
  var file = item.getAsFile();
  if (!file) {
    return Promise.reject("".concat(item, " is not a File"));
  }
  var fwp = toFileWithPath(file);
  return Promise.resolve(fwp);
}
function fromEntry(entry) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a) {
      return [2, entry.isDirectory ? fromDirEntry(entry) : fromFileEntry(entry)];
    });
  });
}
function fromDirEntry(entry) {
  var reader = entry.createReader();
  return new Promise(function(resolve, reject) {
    var entries = [];
    function readEntries() {
      var _this = this;
      reader.readEntries(function(batch2) {
        return __awaiter(_this, void 0, void 0, function() {
          var files, err_1, items;
          return __generator(this, function(_a) {
            switch (_a.label) {
              case 0:
                if (!!batch2.length)
                  return [3, 5];
                _a.label = 1;
              case 1:
                _a.trys.push([1, 3, , 4]);
                return [4, Promise.all(entries)];
              case 2:
                files = _a.sent();
                resolve(files);
                return [3, 4];
              case 3:
                err_1 = _a.sent();
                reject(err_1);
                return [3, 4];
              case 4:
                return [3, 6];
              case 5:
                items = Promise.all(batch2.map(fromEntry));
                entries.push(items);
                readEntries();
                _a.label = 6;
              case 6:
                return [
                  2
                  /*return*/
                ];
            }
          });
        });
      }, function(err) {
        reject(err);
      });
    }
    readEntries();
  });
}
function fromFileEntry(entry) {
  return __awaiter(this, void 0, void 0, function() {
    return __generator(this, function(_a) {
      return [2, new Promise(function(resolve, reject) {
        entry.file(function(file) {
          var fwp = toFileWithPath(file, entry.fullPath);
          resolve(fwp);
        }, function(err) {
          reject(err);
        });
      })];
    });
  });
}

// node_modules/react-dropzone/dist/es/utils/index.js
var import_attr_accept = __toESM(require_es());
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function ownKeys5(object2, enumerableOnly) {
  var keys6 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys6.push.apply(keys6, symbols);
  }
  return keys6;
}
function _objectSpread4(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = null != arguments[i15] ? arguments[i15] : {};
    i15 % 2 ? ownKeys5(Object(source), true).forEach(function(key) {
      _defineProperty8(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty8(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray(arr, i15) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i15) || _unsupportedIterableToArray(arr, i15) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o16, minLen) {
  if (!o16)
    return;
  if (typeof o16 === "string")
    return _arrayLikeToArray(o16, minLen);
  var n12 = Object.prototype.toString.call(o16).slice(8, -1);
  if (n12 === "Object" && o16.constructor)
    n12 = o16.constructor.name;
  if (n12 === "Map" || n12 === "Set")
    return Array.from(o16);
  if (n12 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n12))
    return _arrayLikeToArray(o16, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i15 = 0, arr2 = new Array(len); i15 < len; i15++) {
    arr2[i15] = arr[i15];
  }
  return arr2;
}
function _iterableToArrayLimit(arr, i15) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e4;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i15 && _arr.length === i15)
        break;
    }
  } catch (err) {
    _d = true;
    _e4 = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e4;
    }
  }
  return _arr;
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
var FILE_INVALID_TYPE = "file-invalid-type";
var FILE_TOO_LARGE = "file-too-large";
var FILE_TOO_SMALL = "file-too-small";
var TOO_MANY_FILES = "too-many-files";
var getInvalidTypeRejectionErr = function getInvalidTypeRejectionErr2(accept) {
  accept = Array.isArray(accept) && accept.length === 1 ? accept[0] : accept;
  var messageSuffix = Array.isArray(accept) ? "one of ".concat(accept.join(", ")) : accept;
  return {
    code: FILE_INVALID_TYPE,
    message: "File type must be ".concat(messageSuffix)
  };
};
var getTooLargeRejectionErr = function getTooLargeRejectionErr2(maxSize) {
  return {
    code: FILE_TOO_LARGE,
    message: "File is larger than ".concat(maxSize, " ").concat(maxSize === 1 ? "byte" : "bytes")
  };
};
var getTooSmallRejectionErr = function getTooSmallRejectionErr2(minSize) {
  return {
    code: FILE_TOO_SMALL,
    message: "File is smaller than ".concat(minSize, " ").concat(minSize === 1 ? "byte" : "bytes")
  };
};
var TOO_MANY_FILES_REJECTION = {
  code: TOO_MANY_FILES,
  message: "Too many files"
};
function fileAccepted(file, accept) {
  var isAcceptable = file.type === "application/x-moz-file" || (0, import_attr_accept.default)(file, accept);
  return [isAcceptable, isAcceptable ? null : getInvalidTypeRejectionErr(accept)];
}
function fileMatchSize(file, minSize, maxSize) {
  if (isDefined2(file.size)) {
    if (isDefined2(minSize) && isDefined2(maxSize)) {
      if (file.size > maxSize)
        return [false, getTooLargeRejectionErr(maxSize)];
      if (file.size < minSize)
        return [false, getTooSmallRejectionErr(minSize)];
    } else if (isDefined2(minSize) && file.size < minSize)
      return [false, getTooSmallRejectionErr(minSize)];
    else if (isDefined2(maxSize) && file.size > maxSize)
      return [false, getTooLargeRejectionErr(maxSize)];
  }
  return [true, null];
}
function isDefined2(value) {
  return value !== void 0 && value !== null;
}
function allFilesAccepted(_ref) {
  var files = _ref.files, accept = _ref.accept, minSize = _ref.minSize, maxSize = _ref.maxSize, multiple = _ref.multiple, maxFiles = _ref.maxFiles, validator = _ref.validator;
  if (!multiple && files.length > 1 || multiple && maxFiles >= 1 && files.length > maxFiles) {
    return false;
  }
  return files.every(function(file) {
    var _fileAccepted = fileAccepted(file, accept), _fileAccepted2 = _slicedToArray(_fileAccepted, 1), accepted = _fileAccepted2[0];
    var _fileMatchSize = fileMatchSize(file, minSize, maxSize), _fileMatchSize2 = _slicedToArray(_fileMatchSize, 1), sizeMatch = _fileMatchSize2[0];
    var customErrors = validator ? validator(file) : null;
    return accepted && sizeMatch && !customErrors;
  });
}
function isPropagationStopped(event) {
  if (typeof event.isPropagationStopped === "function") {
    return event.isPropagationStopped();
  } else if (typeof event.cancelBubble !== "undefined") {
    return event.cancelBubble;
  }
  return false;
}
function isEvtWithFiles(event) {
  if (!event.dataTransfer) {
    return !!event.target && !!event.target.files;
  }
  return Array.prototype.some.call(event.dataTransfer.types, function(type) {
    return type === "Files" || type === "application/x-moz-file";
  });
}
function onDocumentDragOver(event) {
  event.preventDefault();
}
function isIe(userAgent) {
  return userAgent.indexOf("MSIE") !== -1 || userAgent.indexOf("Trident/") !== -1;
}
function isEdge(userAgent) {
  return userAgent.indexOf("Edge/") !== -1;
}
function isIeOrEdge() {
  var userAgent = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.navigator.userAgent;
  return isIe(userAgent) || isEdge(userAgent);
}
function composeEventHandlers() {
  for (var _len = arguments.length, fns = new Array(_len), _key = 0; _key < _len; _key++) {
    fns[_key] = arguments[_key];
  }
  return function(event) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    return fns.some(function(fn2) {
      if (!isPropagationStopped(event) && fn2) {
        fn2.apply(void 0, [event].concat(args));
      }
      return isPropagationStopped(event);
    });
  };
}
function canUseFileSystemAccessAPI() {
  return "showOpenFilePicker" in window;
}
function pickerOptionsFromAccept(accept) {
  if (isDefined2(accept)) {
    var acceptForPicker = Object.entries(accept).filter(function(_ref2) {
      var _ref3 = _slicedToArray(_ref2, 2), mimeType = _ref3[0], ext = _ref3[1];
      var ok = true;
      if (!isMIMEType(mimeType)) {
        console.warn('Skipped "'.concat(mimeType, '" because it is not a valid MIME type. Check https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types/Common_types for a list of valid MIME types.'));
        ok = false;
      }
      if (!Array.isArray(ext) || !ext.every(isExt)) {
        console.warn('Skipped "'.concat(mimeType, '" because an invalid file extension was provided.'));
        ok = false;
      }
      return ok;
    }).reduce(function(agg, _ref4) {
      var _ref5 = _slicedToArray(_ref4, 2), mimeType = _ref5[0], ext = _ref5[1];
      return _objectSpread4(_objectSpread4({}, agg), {}, _defineProperty8({}, mimeType, ext));
    }, {});
    return [{
      // description is required due to https://crbug.com/1264708
      description: "Files",
      accept: acceptForPicker
    }];
  }
  return accept;
}
function acceptPropAsAcceptAttr(accept) {
  if (isDefined2(accept)) {
    return Object.entries(accept).reduce(function(a13, _ref6) {
      var _ref7 = _slicedToArray(_ref6, 2), mimeType = _ref7[0], ext = _ref7[1];
      return [].concat(_toConsumableArray(a13), [mimeType], _toConsumableArray(ext));
    }, []).filter(function(v6) {
      return isMIMEType(v6) || isExt(v6);
    }).join(",");
  }
  return void 0;
}
function isAbort(v6) {
  return v6 instanceof DOMException && (v6.name === "AbortError" || v6.code === v6.ABORT_ERR);
}
function isSecurityError(v6) {
  return v6 instanceof DOMException && (v6.name === "SecurityError" || v6.code === v6.SECURITY_ERR);
}
function isMIMEType(v6) {
  return v6 === "audio/*" || v6 === "video/*" || v6 === "image/*" || v6 === "text/*" || /\w+\/[-+.\w]+/g.test(v6);
}
function isExt(v6) {
  return /^.*\.[\w]+$/.test(v6);
}

// node_modules/react-dropzone/dist/es/index.js
var _excluded9 = ["children"];
var _excluded24 = ["open"];
var _excluded32 = ["refKey", "role", "onKeyDown", "onFocus", "onBlur", "onClick", "onDragEnter", "onDragOver", "onDragLeave", "onDrop"];
var _excluded42 = ["refKey", "onChange", "onClick"];
function _toConsumableArray2(arr) {
  return _arrayWithoutHoles2(arr) || _iterableToArray2(arr) || _unsupportedIterableToArray2(arr) || _nonIterableSpread2();
}
function _nonIterableSpread2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles2(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray2(arr);
}
function _slicedToArray2(arr, i15) {
  return _arrayWithHoles2(arr) || _iterableToArrayLimit2(arr, i15) || _unsupportedIterableToArray2(arr, i15) || _nonIterableRest2();
}
function _nonIterableRest2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray2(o16, minLen) {
  if (!o16)
    return;
  if (typeof o16 === "string")
    return _arrayLikeToArray2(o16, minLen);
  var n12 = Object.prototype.toString.call(o16).slice(8, -1);
  if (n12 === "Object" && o16.constructor)
    n12 = o16.constructor.name;
  if (n12 === "Map" || n12 === "Set")
    return Array.from(o16);
  if (n12 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n12))
    return _arrayLikeToArray2(o16, minLen);
}
function _arrayLikeToArray2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i15 = 0, arr2 = new Array(len); i15 < len; i15++) {
    arr2[i15] = arr[i15];
  }
  return arr2;
}
function _iterableToArrayLimit2(arr, i15) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e4;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i15 && _arr.length === i15)
        break;
    }
  } catch (err) {
    _d = true;
    _e4 = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e4;
    }
  }
  return _arr;
}
function _arrayWithHoles2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function ownKeys6(object2, enumerableOnly) {
  var keys6 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys6.push.apply(keys6, symbols);
  }
  return keys6;
}
function _objectSpread5(target) {
  for (var i15 = 1; i15 < arguments.length; i15++) {
    var source = null != arguments[i15] ? arguments[i15] : {};
    i15 % 2 ? ownKeys6(Object(source), true).forEach(function(key) {
      _defineProperty9(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys6(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty9(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectWithoutProperties3(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose4(source, excluded);
  var key, i15;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i15 = 0; i15 < sourceSymbolKeys.length; i15++) {
      key = sourceSymbolKeys[i15];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose4(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i15;
  for (i15 = 0; i15 < sourceKeys.length; i15++) {
    key = sourceKeys[i15];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var Dropzone = (0, import_react115.forwardRef)(function(_ref, ref2) {
  var children = _ref.children, params = _objectWithoutProperties3(_ref, _excluded9);
  var _useDropzone = useDropzone(params), open = _useDropzone.open, props = _objectWithoutProperties3(_useDropzone, _excluded24);
  (0, import_react115.useImperativeHandle)(ref2, function() {
    return {
      open
    };
  }, [open]);
  return import_react115.default.createElement(import_react115.Fragment, null, children(_objectSpread5(_objectSpread5({}, props), {}, {
    open
  })));
});
Dropzone.displayName = "Dropzone";
var defaultProps3 = {
  disabled: false,
  getFilesFromEvent: fromEvent,
  maxSize: Infinity,
  minSize: 0,
  multiple: true,
  maxFiles: 0,
  preventDropOnDocument: true,
  noClick: false,
  noKeyboard: false,
  noDrag: false,
  noDragEventsBubbling: false,
  validator: null,
  useFsAccessApi: true,
  autoFocus: false
};
Dropzone.defaultProps = defaultProps3;
Dropzone.propTypes = {
  /**
   * Render function that exposes the dropzone state and prop getter fns
   *
   * @param {object} params
   * @param {Function} params.getRootProps Returns the props you should apply to the root drop container you render
   * @param {Function} params.getInputProps Returns the props you should apply to hidden file input you render
   * @param {Function} params.open Open the native file selection dialog
   * @param {boolean} params.isFocused Dropzone area is in focus
   * @param {boolean} params.isFileDialogActive File dialog is opened
   * @param {boolean} params.isDragActive Active drag is in progress
   * @param {boolean} params.isDragAccept Dragged files are accepted
   * @param {boolean} params.isDragReject Some dragged files are rejected
   * @param {File[]} params.acceptedFiles Accepted files
   * @param {FileRejection[]} params.fileRejections Rejected files and why they were rejected
   */
  children: import_prop_types19.default.func,
  /**
   * Set accepted file types.
   * Checkout https://developer.mozilla.org/en-US/docs/Web/API/window/showOpenFilePicker types option for more information.
   * Keep in mind that mime type determination is not reliable across platforms. CSV files,
   * for example, are reported as text/plain under macOS but as application/vnd.ms-excel under
   * Windows. In some cases there might not be a mime type set at all (https://github.com/react-dropzone/react-dropzone/issues/276).
   */
  accept: import_prop_types19.default.objectOf(import_prop_types19.default.arrayOf(import_prop_types19.default.string)),
  /**
   * Allow drag 'n' drop (or selection from the file dialog) of multiple files
   */
  multiple: import_prop_types19.default.bool,
  /**
   * If false, allow dropped items to take over the current browser window
   */
  preventDropOnDocument: import_prop_types19.default.bool,
  /**
   * If true, disables click to open the native file selection dialog
   */
  noClick: import_prop_types19.default.bool,
  /**
   * If true, disables SPACE/ENTER to open the native file selection dialog.
   * Note that it also stops tracking the focus state.
   */
  noKeyboard: import_prop_types19.default.bool,
  /**
   * If true, disables drag 'n' drop
   */
  noDrag: import_prop_types19.default.bool,
  /**
   * If true, stops drag event propagation to parents
   */
  noDragEventsBubbling: import_prop_types19.default.bool,
  /**
   * Minimum file size (in bytes)
   */
  minSize: import_prop_types19.default.number,
  /**
   * Maximum file size (in bytes)
   */
  maxSize: import_prop_types19.default.number,
  /**
   * Maximum accepted number of files
   * The default value is 0 which means there is no limitation to how many files are accepted.
   */
  maxFiles: import_prop_types19.default.number,
  /**
   * Enable/disable the dropzone
   */
  disabled: import_prop_types19.default.bool,
  /**
   * Use this to provide a custom file aggregator
   *
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  getFilesFromEvent: import_prop_types19.default.func,
  /**
   * Cb for when closing the file dialog with no selection
   */
  onFileDialogCancel: import_prop_types19.default.func,
  /**
   * Cb for when opening the file dialog
   */
  onFileDialogOpen: import_prop_types19.default.func,
  /**
   * Set to true to use the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API
   * to open the file picker instead of using an `<input type="file">` click event.
   */
  useFsAccessApi: import_prop_types19.default.bool,
  /**
   * Set to true to focus the root element on render
   */
  autoFocus: import_prop_types19.default.bool,
  /**
   * Cb for when the `dragenter` event occurs.
   *
   * @param {DragEvent} event
   */
  onDragEnter: import_prop_types19.default.func,
  /**
   * Cb for when the `dragleave` event occurs
   *
   * @param {DragEvent} event
   */
  onDragLeave: import_prop_types19.default.func,
  /**
   * Cb for when the `dragover` event occurs
   *
   * @param {DragEvent} event
   */
  onDragOver: import_prop_types19.default.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that this callback is invoked after the `getFilesFromEvent` callback is done.
   *
   * Files are accepted or rejected based on the `accept`, `multiple`, `minSize` and `maxSize` props.
   * `accept` must be a valid [MIME type](http://www.iana.org/assignments/media-types/media-types.xhtml) according to [input element specification](https://www.w3.org/wiki/HTML/Elements/input/file) or a valid file extension.
   * If `multiple` is set to false and additional files are dropped,
   * all files besides the first will be rejected.
   * Any file which does not have a size in the [`minSize`, `maxSize`] range, will be rejected as well.
   *
   * Note that the `onDrop` callback will always be invoked regardless if the dropped files were accepted or rejected.
   * If you'd like to react to a specific scenario, use the `onDropAccepted`/`onDropRejected` props.
   *
   * `onDrop` will provide you with an array of [File](https://developer.mozilla.org/en-US/docs/Web/API/File) objects which you can then process and send to a server.
   * For example, with [SuperAgent](https://github.com/visionmedia/superagent) as a http/ajax library:
   *
   * ```js
   * function onDrop(acceptedFiles) {
   *   const req = request.post('/upload')
   *   acceptedFiles.forEach(file => {
   *     req.attach(file.name, file)
   *   })
   *   req.end(callback)
   * }
   * ```
   *
   * @param {File[]} acceptedFiles
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event A drag event or input change event (if files were selected via the file dialog)
   */
  onDrop: import_prop_types19.default.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are accepted, this callback is not invoked.
   *
   * @param {File[]} files
   * @param {(DragEvent|Event)} event
   */
  onDropAccepted: import_prop_types19.default.func,
  /**
   * Cb for when the `drop` event occurs.
   * Note that if no files are rejected, this callback is not invoked.
   *
   * @param {FileRejection[]} fileRejections
   * @param {(DragEvent|Event)} event
   */
  onDropRejected: import_prop_types19.default.func,
  /**
   * Cb for when there's some error from any of the promises.
   *
   * @param {Error} error
   */
  onError: import_prop_types19.default.func,
  /**
   * Custom validation function. It must return null if there's no errors.
   * @param {File} file
   * @returns {FileError|FileError[]|null}
   */
  validator: import_prop_types19.default.func
};
var initialState = {
  isFocused: false,
  isFileDialogActive: false,
  isDragActive: false,
  isDragAccept: false,
  isDragReject: false,
  acceptedFiles: [],
  fileRejections: []
};
function useDropzone() {
  var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _defaultProps$props = _objectSpread5(_objectSpread5({}, defaultProps3), props), accept = _defaultProps$props.accept, disabled = _defaultProps$props.disabled, getFilesFromEvent = _defaultProps$props.getFilesFromEvent, maxSize = _defaultProps$props.maxSize, minSize = _defaultProps$props.minSize, multiple = _defaultProps$props.multiple, maxFiles = _defaultProps$props.maxFiles, onDragEnter = _defaultProps$props.onDragEnter, onDragLeave = _defaultProps$props.onDragLeave, onDragOver = _defaultProps$props.onDragOver, onDrop = _defaultProps$props.onDrop, onDropAccepted = _defaultProps$props.onDropAccepted, onDropRejected = _defaultProps$props.onDropRejected, onFileDialogCancel = _defaultProps$props.onFileDialogCancel, onFileDialogOpen = _defaultProps$props.onFileDialogOpen, useFsAccessApi = _defaultProps$props.useFsAccessApi, autoFocus = _defaultProps$props.autoFocus, preventDropOnDocument = _defaultProps$props.preventDropOnDocument, noClick = _defaultProps$props.noClick, noKeyboard = _defaultProps$props.noKeyboard, noDrag = _defaultProps$props.noDrag, noDragEventsBubbling = _defaultProps$props.noDragEventsBubbling, onError = _defaultProps$props.onError, validator = _defaultProps$props.validator;
  var acceptAttr = (0, import_react115.useMemo)(function() {
    return acceptPropAsAcceptAttr(accept);
  }, [accept]);
  var pickerTypes = (0, import_react115.useMemo)(function() {
    return pickerOptionsFromAccept(accept);
  }, [accept]);
  var onFileDialogOpenCb = (0, import_react115.useMemo)(function() {
    return typeof onFileDialogOpen === "function" ? onFileDialogOpen : noop5;
  }, [onFileDialogOpen]);
  var onFileDialogCancelCb = (0, import_react115.useMemo)(function() {
    return typeof onFileDialogCancel === "function" ? onFileDialogCancel : noop5;
  }, [onFileDialogCancel]);
  var rootRef = (0, import_react115.useRef)(null);
  var inputRef = (0, import_react115.useRef)(null);
  var _useReducer = (0, import_react115.useReducer)(reducer2, initialState), _useReducer2 = _slicedToArray2(_useReducer, 2), state = _useReducer2[0], dispatch = _useReducer2[1];
  var isFocused = state.isFocused, isFileDialogActive = state.isFileDialogActive;
  var fsAccessApiWorksRef = (0, import_react115.useRef)(typeof window !== "undefined" && window.isSecureContext && useFsAccessApi && canUseFileSystemAccessAPI());
  var onWindowFocus = function onWindowFocus2() {
    if (!fsAccessApiWorksRef.current && isFileDialogActive) {
      setTimeout(function() {
        if (inputRef.current) {
          var files = inputRef.current.files;
          if (!files.length) {
            dispatch({
              type: "closeDialog"
            });
            onFileDialogCancelCb();
          }
        }
      }, 300);
    }
  };
  (0, import_react115.useEffect)(function() {
    window.addEventListener("focus", onWindowFocus, false);
    return function() {
      window.removeEventListener("focus", onWindowFocus, false);
    };
  }, [inputRef, isFileDialogActive, onFileDialogCancelCb, fsAccessApiWorksRef]);
  var dragTargetsRef = (0, import_react115.useRef)([]);
  var onDocumentDrop = function onDocumentDrop2(event) {
    if (rootRef.current && rootRef.current.contains(event.target)) {
      return;
    }
    event.preventDefault();
    dragTargetsRef.current = [];
  };
  (0, import_react115.useEffect)(function() {
    if (preventDropOnDocument) {
      document.addEventListener("dragover", onDocumentDragOver, false);
      document.addEventListener("drop", onDocumentDrop, false);
    }
    return function() {
      if (preventDropOnDocument) {
        document.removeEventListener("dragover", onDocumentDragOver);
        document.removeEventListener("drop", onDocumentDrop);
      }
    };
  }, [rootRef, preventDropOnDocument]);
  (0, import_react115.useEffect)(function() {
    if (!disabled && autoFocus && rootRef.current) {
      rootRef.current.focus();
    }
    return function() {
    };
  }, [rootRef, autoFocus, disabled]);
  var onErrCb = (0, import_react115.useCallback)(function(e9) {
    if (onError) {
      onError(e9);
    } else {
      console.error(e9);
    }
  }, [onError]);
  var onDragEnterCb = (0, import_react115.useCallback)(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    dragTargetsRef.current = [].concat(_toConsumableArray2(dragTargetsRef.current), [event.target]);
    if (isEvtWithFiles(event)) {
      Promise.resolve(getFilesFromEvent(event)).then(function(files) {
        if (isPropagationStopped(event) && !noDragEventsBubbling) {
          return;
        }
        var fileCount = files.length;
        var isDragAccept = fileCount > 0 && allFilesAccepted({
          files,
          accept: acceptAttr,
          minSize,
          maxSize,
          multiple,
          maxFiles,
          validator
        });
        var isDragReject = fileCount > 0 && !isDragAccept;
        dispatch({
          isDragAccept,
          isDragReject,
          isDragActive: true,
          type: "setDraggedFiles"
        });
        if (onDragEnter) {
          onDragEnter(event);
        }
      }).catch(function(e9) {
        return onErrCb(e9);
      });
    }
  }, [getFilesFromEvent, onDragEnter, onErrCb, noDragEventsBubbling, acceptAttr, minSize, maxSize, multiple, maxFiles, validator]);
  var onDragOverCb = (0, import_react115.useCallback)(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    var hasFiles = isEvtWithFiles(event);
    if (hasFiles && event.dataTransfer) {
      try {
        event.dataTransfer.dropEffect = "copy";
      } catch (_unused) {
      }
    }
    if (hasFiles && onDragOver) {
      onDragOver(event);
    }
    return false;
  }, [onDragOver, noDragEventsBubbling]);
  var onDragLeaveCb = (0, import_react115.useCallback)(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    var targets = dragTargetsRef.current.filter(function(target) {
      return rootRef.current && rootRef.current.contains(target);
    });
    var targetIdx = targets.indexOf(event.target);
    if (targetIdx !== -1) {
      targets.splice(targetIdx, 1);
    }
    dragTargetsRef.current = targets;
    if (targets.length > 0) {
      return;
    }
    dispatch({
      type: "setDraggedFiles",
      isDragActive: false,
      isDragAccept: false,
      isDragReject: false
    });
    if (isEvtWithFiles(event) && onDragLeave) {
      onDragLeave(event);
    }
  }, [rootRef, onDragLeave, noDragEventsBubbling]);
  var setFiles = (0, import_react115.useCallback)(function(files, event) {
    var acceptedFiles = [];
    var fileRejections = [];
    files.forEach(function(file) {
      var _fileAccepted = fileAccepted(file, acceptAttr), _fileAccepted2 = _slicedToArray2(_fileAccepted, 2), accepted = _fileAccepted2[0], acceptError = _fileAccepted2[1];
      var _fileMatchSize = fileMatchSize(file, minSize, maxSize), _fileMatchSize2 = _slicedToArray2(_fileMatchSize, 2), sizeMatch = _fileMatchSize2[0], sizeError = _fileMatchSize2[1];
      var customErrors = validator ? validator(file) : null;
      if (accepted && sizeMatch && !customErrors) {
        acceptedFiles.push(file);
      } else {
        var errors = [acceptError, sizeError];
        if (customErrors) {
          errors = errors.concat(customErrors);
        }
        fileRejections.push({
          file,
          errors: errors.filter(function(e9) {
            return e9;
          })
        });
      }
    });
    if (!multiple && acceptedFiles.length > 1 || multiple && maxFiles >= 1 && acceptedFiles.length > maxFiles) {
      acceptedFiles.forEach(function(file) {
        fileRejections.push({
          file,
          errors: [TOO_MANY_FILES_REJECTION]
        });
      });
      acceptedFiles.splice(0);
    }
    dispatch({
      acceptedFiles,
      fileRejections,
      type: "setFiles"
    });
    if (onDrop) {
      onDrop(acceptedFiles, fileRejections, event);
    }
    if (fileRejections.length > 0 && onDropRejected) {
      onDropRejected(fileRejections, event);
    }
    if (acceptedFiles.length > 0 && onDropAccepted) {
      onDropAccepted(acceptedFiles, event);
    }
  }, [dispatch, multiple, acceptAttr, minSize, maxSize, maxFiles, onDrop, onDropAccepted, onDropRejected, validator]);
  var onDropCb = (0, import_react115.useCallback)(function(event) {
    event.preventDefault();
    event.persist();
    stopPropagation(event);
    dragTargetsRef.current = [];
    if (isEvtWithFiles(event)) {
      Promise.resolve(getFilesFromEvent(event)).then(function(files) {
        if (isPropagationStopped(event) && !noDragEventsBubbling) {
          return;
        }
        setFiles(files, event);
      }).catch(function(e9) {
        return onErrCb(e9);
      });
    }
    dispatch({
      type: "reset"
    });
  }, [getFilesFromEvent, setFiles, onErrCb, noDragEventsBubbling]);
  var openFileDialog = (0, import_react115.useCallback)(function() {
    if (fsAccessApiWorksRef.current) {
      dispatch({
        type: "openDialog"
      });
      onFileDialogOpenCb();
      var opts = {
        multiple,
        types: pickerTypes
      };
      window.showOpenFilePicker(opts).then(function(handles) {
        return getFilesFromEvent(handles);
      }).then(function(files) {
        setFiles(files, null);
        dispatch({
          type: "closeDialog"
        });
      }).catch(function(e9) {
        if (isAbort(e9)) {
          onFileDialogCancelCb(e9);
          dispatch({
            type: "closeDialog"
          });
        } else if (isSecurityError(e9)) {
          fsAccessApiWorksRef.current = false;
          if (inputRef.current) {
            inputRef.current.value = null;
            inputRef.current.click();
          } else {
            onErrCb(new Error("Cannot open the file picker because the https://developer.mozilla.org/en-US/docs/Web/API/File_System_Access_API is not supported and no <input> was provided."));
          }
        } else {
          onErrCb(e9);
        }
      });
      return;
    }
    if (inputRef.current) {
      dispatch({
        type: "openDialog"
      });
      onFileDialogOpenCb();
      inputRef.current.value = null;
      inputRef.current.click();
    }
  }, [dispatch, onFileDialogOpenCb, onFileDialogCancelCb, useFsAccessApi, setFiles, onErrCb, pickerTypes, multiple]);
  var onKeyDownCb = (0, import_react115.useCallback)(function(event) {
    if (!rootRef.current || !rootRef.current.isEqualNode(event.target)) {
      return;
    }
    if (event.key === " " || event.key === "Enter" || event.keyCode === 32 || event.keyCode === 13) {
      event.preventDefault();
      openFileDialog();
    }
  }, [rootRef, openFileDialog]);
  var onFocusCb = (0, import_react115.useCallback)(function() {
    dispatch({
      type: "focus"
    });
  }, []);
  var onBlurCb = (0, import_react115.useCallback)(function() {
    dispatch({
      type: "blur"
    });
  }, []);
  var onClickCb = (0, import_react115.useCallback)(function() {
    if (noClick) {
      return;
    }
    if (isIeOrEdge()) {
      setTimeout(openFileDialog, 0);
    } else {
      openFileDialog();
    }
  }, [noClick, openFileDialog]);
  var composeHandler = function composeHandler2(fn2) {
    return disabled ? null : fn2;
  };
  var composeKeyboardHandler = function composeKeyboardHandler2(fn2) {
    return noKeyboard ? null : composeHandler(fn2);
  };
  var composeDragHandler = function composeDragHandler2(fn2) {
    return noDrag ? null : composeHandler(fn2);
  };
  var stopPropagation = function stopPropagation2(event) {
    if (noDragEventsBubbling) {
      event.stopPropagation();
    }
  };
  var getRootProps = (0, import_react115.useMemo)(function() {
    return function() {
      var _ref2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref2$refKey = _ref2.refKey, refKey = _ref2$refKey === void 0 ? "ref" : _ref2$refKey, role = _ref2.role, onKeyDown = _ref2.onKeyDown, onFocus = _ref2.onFocus, onBlur = _ref2.onBlur, onClick = _ref2.onClick, onDragEnter2 = _ref2.onDragEnter, onDragOver2 = _ref2.onDragOver, onDragLeave2 = _ref2.onDragLeave, onDrop2 = _ref2.onDrop, rest = _objectWithoutProperties3(_ref2, _excluded32);
      return _objectSpread5(_objectSpread5(_defineProperty9({
        onKeyDown: composeKeyboardHandler(composeEventHandlers(onKeyDown, onKeyDownCb)),
        onFocus: composeKeyboardHandler(composeEventHandlers(onFocus, onFocusCb)),
        onBlur: composeKeyboardHandler(composeEventHandlers(onBlur, onBlurCb)),
        onClick: composeHandler(composeEventHandlers(onClick, onClickCb)),
        onDragEnter: composeDragHandler(composeEventHandlers(onDragEnter2, onDragEnterCb)),
        onDragOver: composeDragHandler(composeEventHandlers(onDragOver2, onDragOverCb)),
        onDragLeave: composeDragHandler(composeEventHandlers(onDragLeave2, onDragLeaveCb)),
        onDrop: composeDragHandler(composeEventHandlers(onDrop2, onDropCb)),
        role: typeof role === "string" && role !== "" ? role : "presentation"
      }, refKey, rootRef), !disabled && !noKeyboard ? {
        tabIndex: 0
      } : {}), rest);
    };
  }, [rootRef, onKeyDownCb, onFocusCb, onBlurCb, onClickCb, onDragEnterCb, onDragOverCb, onDragLeaveCb, onDropCb, noKeyboard, noDrag, disabled]);
  var onInputElementClick = (0, import_react115.useCallback)(function(event) {
    event.stopPropagation();
  }, []);
  var getInputProps = (0, import_react115.useMemo)(function() {
    return function() {
      var _ref3 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref3$refKey = _ref3.refKey, refKey = _ref3$refKey === void 0 ? "ref" : _ref3$refKey, onChange = _ref3.onChange, onClick = _ref3.onClick, rest = _objectWithoutProperties3(_ref3, _excluded42);
      var inputProps = _defineProperty9({
        accept: acceptAttr,
        multiple,
        type: "file",
        style: {
          display: "none"
        },
        onChange: composeHandler(composeEventHandlers(onChange, onDropCb)),
        onClick: composeHandler(composeEventHandlers(onClick, onInputElementClick)),
        tabIndex: -1
      }, refKey, inputRef);
      return _objectSpread5(_objectSpread5({}, inputProps), rest);
    };
  }, [inputRef, accept, multiple, onDropCb, disabled]);
  return _objectSpread5(_objectSpread5({}, state), {}, {
    isFocused: isFocused && !disabled,
    getRootProps,
    getInputProps,
    rootRef,
    inputRef,
    open: composeHandler(openFileDialog)
  });
}
function reducer2(state, action) {
  switch (action.type) {
    case "focus":
      return _objectSpread5(_objectSpread5({}, state), {}, {
        isFocused: true
      });
    case "blur":
      return _objectSpread5(_objectSpread5({}, state), {}, {
        isFocused: false
      });
    case "openDialog":
      return _objectSpread5(_objectSpread5({}, initialState), {}, {
        isFileDialogActive: true
      });
    case "closeDialog":
      return _objectSpread5(_objectSpread5({}, state), {}, {
        isFileDialogActive: false
      });
    case "setDraggedFiles":
      return _objectSpread5(_objectSpread5({}, state), {}, {
        isDragActive: action.isDragActive,
        isDragAccept: action.isDragAccept,
        isDragReject: action.isDragReject
      });
    case "setFiles":
      return _objectSpread5(_objectSpread5({}, state), {}, {
        acceptedFiles: action.acceptedFiles,
        fileRejections: action.fileRejections
      });
    case "reset":
      return _objectSpread5({}, initialState);
    default:
      return state;
  }
}
function noop5() {
}

// node_modules/@floating-ui/core/dist/floating-ui.core.esm.js
function getBasePlacement(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getMainAxisFromPlacement(placement) {
  return ["top", "bottom"].includes(getBasePlacement(placement)) ? "x" : "y";
}
function getLengthFromAxis(axis) {
  return axis === "y" ? "height" : "width";
}
function computeCoordsFromPlacement(_ref) {
  let {
    reference,
    floating,
    placement
  } = _ref;
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  let coords;
  switch (getBasePlacement(placement)) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  switch (getAlignment(placement)) {
    case "start":
      coords[mainAxis] = coords[mainAxis] - (reference[length] / 2 - floating[length] / 2);
      break;
    case "end":
      coords[mainAxis] = coords[mainAxis] + (reference[length] / 2 - floating[length] / 2);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config2) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config2;
  if (true) {
    if (platform2 == null) {
      console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" "));
    }
    if (middleware.filter((_ref) => {
      let {
        name: name2
      } = _ref;
      return name2 === "autoPlacement" || name2 === "flip";
    }).length > 1) {
      throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement`", "middleware detected. This will lead to an infinite loop. Ensure only", "one of either has been passed to the `middleware` array."].join(" "));
    }
  }
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x7,
    y: y9
  } = computeCoordsFromPlacement({
    ...rects,
    placement
  });
  let statefulPlacement = placement;
  let middlewareData = {};
  let _debug_loop_count_ = 0;
  for (let i15 = 0; i15 < middleware.length; i15++) {
    if (true) {
      _debug_loop_count_++;
      if (_debug_loop_count_ > 100) {
        throw new Error(["Floating UI: The middleware lifecycle appears to be", "running in an infinite loop. This is usually caused by a `reset`", "continually being returned without a break condition."].join(" "));
      }
    }
    const {
      name: name2,
      fn: fn2
    } = middleware[i15];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn2({
      x: x7,
      y: y9,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x7 = nextX != null ? nextX : x7;
    y9 = nextY != null ? nextY : y9;
    middlewareData = {
      ...middlewareData,
      [name2]: data != null ? data : {}
    };
    if (reset) {
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x7,
          y: y9
        } = computeCoordsFromPlacement({
          ...rects,
          placement: statefulPlacement
        }));
      }
      i15 = -1;
      continue;
    }
  }
  return {
    x: x7,
    y: y9,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getSideObjectFromPadding(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}
async function detectOverflow(middlewareArguments, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    x: x7,
    y: y9,
    platform: platform2,
    rects,
    elements,
    strategy
  } = middlewareArguments;
  const {
    boundary = "clippingParents",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = options;
  const paddingObject = getSideObjectFromPadding(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = await platform2.getClippingClientRect({
    element: await platform2.isElement(element) ? element : element.contextElement || await platform2.getDocumentElement({
      element: elements.floating
    }),
    boundary,
    rootBoundary
  });
  const elementClientRect = rectToClientRect(await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    rect: elementContext === "floating" ? {
      ...rects.floating,
      x: x7,
      y: y9
    } : rects.reference,
    offsetParent: await platform2.getOffsetParent({
      element: elements.floating
    }),
    strategy
  }));
  return {
    top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
    bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
    left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
    right: elementClientRect.right - clippingClientRect.right + paddingObject.right
  };
}
var min = Math.min;
var max = Math.max;
function within(min$1, value, max$1) {
  return max(min$1, min(value, max$1));
}
var hash$1 = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (matched) => hash$1[matched]);
}
function getAlignmentSides(placement, rects) {
  const isStart = getAlignment(placement) === "start";
  const mainAxis = getMainAxisFromPlacement(placement);
  const length = getLengthFromAxis(mainAxis);
  let mainAlignmentSide = mainAxis === "x" ? isStart ? "right" : "left" : isStart ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return {
    main: mainAlignmentSide,
    cross: getOppositePlacement(mainAlignmentSide)
  };
}
var hash = {
  start: "end",
  end: "start"
};
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (matched) => hash[matched]);
}
var basePlacements = ["top", "right", "bottom", "left"];
var allPlacements = basePlacements.reduce((acc, basePlacement) => acc.concat(basePlacement, basePlacement + "-start", basePlacement + "-end"), []);
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
var flip2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(middlewareArguments) {
      var _middlewareData$flip, _middlewareData$flip2;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement
      } = middlewareArguments;
      if ((_middlewareData$flip = middlewareData.flip) != null && _middlewareData$flip.skip) {
        return {};
      }
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        flipAlignment = true,
        ...detectOverflowOptions
      } = options;
      const basePlacement = getBasePlacement(placement);
      const isBasePlacement = basePlacement === initialPlacement;
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[basePlacement]);
      }
      if (checkCrossAxis) {
        const {
          main,
          cross
        } = getAlignmentSides(placement, rects);
        overflows.push(overflow[main], overflow[cross]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side) => side <= 0)) {
        var _middlewareData$flip$, _middlewareData$flip3;
        const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip3 = middlewareData.flip) == null ? void 0 : _middlewareData$flip3.index) != null ? _middlewareData$flip$ : 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = "bottom";
        switch (fallbackStrategy) {
          case "bestFit": {
            var _overflowsData$slice$;
            const placement2 = (_overflowsData$slice$ = overflowsData.slice().sort((a13, b6) => a13.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0) - b6.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0))[0]) == null ? void 0 : _overflowsData$slice$.placement;
            if (placement2) {
              resetPlacement = placement2;
            }
            break;
          }
          case "initialPlacement":
            resetPlacement = initialPlacement;
            break;
        }
        return {
          data: {
            skip: true
          },
          reset: {
            placement: resetPlacement
          }
        };
      }
      return {};
    }
  };
};
function getCrossAxis(axis) {
  return axis === "x" ? "y" : "x";
}
var shift5 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(middlewareArguments) {
      const {
        x: x7,
        y: y9,
        placement
      } = middlewareArguments;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x8,
              y: y10
            } = _ref;
            return {
              x: x8,
              y: y10
            };
          }
        },
        ...detectOverflowOptions
      } = options;
      const coords = {
        x: x7,
        y: y9
      };
      const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
      const mainAxis = getMainAxisFromPlacement(getBasePlacement(placement));
      const crossAxis = getCrossAxis(mainAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min4 = mainAxisCoord + overflow[minSide];
        const max4 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = within(min4, mainAxisCoord, max4);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min4 = crossAxisCoord + overflow[minSide];
        const max4 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = within(min4, crossAxisCoord, max4);
      }
      const limitedCoords = limiter.fn({
        ...middlewareArguments,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x7,
          y: limitedCoords.y - y9
        }
      };
    }
  };
};

// node_modules/@floating-ui/dom/dist/floating-ui.dom.esm.js
function isWindow(value) {
  return (value == null ? void 0 : value.toString()) === "[object Window]";
}
function getWindow(node) {
  if (node == null) {
    return window;
  }
  if (!isWindow(node)) {
    const ownerDocument = node.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView || window : window;
  }
  return node;
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeName(node) {
  return isWindow(node) ? "" : node ? (node.nodeName || "").toLowerCase() : "";
}
function isHTMLElement(value) {
  return value instanceof getWindow(value).HTMLElement;
}
function isElement4(value) {
  return value instanceof getWindow(value).Element;
}
function isNode(value) {
  return value instanceof getWindow(value).Node;
}
function isShadowRoot(node) {
  const OwnElement = getWindow(node).ShadowRoot;
  return node instanceof OwnElement || node instanceof ShadowRoot;
}
function isScrollParent(element) {
  const {
    overflow,
    overflowX,
    overflowY
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isContainingBlock(element) {
  const isFirefox = navigator.userAgent.toLowerCase().includes("firefox");
  const css = getComputedStyle$1(element);
  return css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].includes(css.willChange) || isFirefox && css.willChange === "filter" || isFirefox && (css.filter ? css.filter !== "none" : false);
}
var min2 = Math.min;
var max2 = Math.max;
var round = Math.round;
function getBoundingClientRect(element, includeScale) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  const clientRect = element.getBoundingClientRect();
  let scaleX = 1;
  let scaleY = 1;
  if (includeScale && isHTMLElement(element)) {
    scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
    scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
  }
  return {
    width: clientRect.width / scaleX,
    height: clientRect.height / scaleY,
    top: clientRect.top / scaleY,
    right: clientRect.right / scaleX,
    bottom: clientRect.bottom / scaleY,
    left: clientRect.left / scaleX,
    x: clientRect.left / scaleX,
    y: clientRect.top / scaleY
  };
}
function getDocumentElement2(node) {
  return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
}
function getNodeScroll(element) {
  if (isWindow(element)) {
    return {
      scrollLeft: element.pageXOffset,
      scrollTop: element.pageYOffset
    };
  }
  return {
    scrollLeft: element.scrollLeft,
    scrollTop: element.scrollTop
  };
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect(getDocumentElement2(element)).left + getNodeScroll(element).scrollLeft;
}
function isScaled(element) {
  const rect = getBoundingClientRect(element);
  return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement2(offsetParent);
  const rect = getBoundingClientRect(element, isOffsetParentAnElement && isScaled(offsetParent));
  let scroll3 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll3 = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  return {
    x: rect.left + scroll3.scrollLeft - offsets.x,
    y: rect.top + scroll3.scrollTop - offsets.y,
    width: rect.width,
    height: rect.height
  };
}
function getParentNode2(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  return (
    // this is a quicker (but less type safe) way to save quite some bytes from the bundle
    // @ts-ignore
    node.assignedSlot || // step into the shadow DOM of the parent of a slotted node
    node.parentNode || // DOM Element detected
    (isShadowRoot(node) ? node.host : null) || // ShadowRoot detected
    getDocumentElement2(node)
  );
}
function getTrueOffsetParent(element) {
  if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
    return null;
  }
  return element.offsetParent;
}
function getContainingBlock(element) {
  let currentNode = getParentNode2(element);
  while (isHTMLElement(currentNode) && !["html", "body"].includes(getNodeName(currentNode))) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = currentNode.parentNode;
    }
  }
  return null;
}
function getOffsetParent(element) {
  const window2 = getWindow(element);
  let offsetParent = getTrueOffsetParent(element);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
function getDimensions(element) {
  return {
    width: element.offsetWidth,
    height: element.offsetHeight
  };
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement2(offsetParent);
  if (offsetParent === documentElement) {
    return rect;
  }
  let scroll3 = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = {
    x: 0,
    y: 0
  };
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isScrollParent(documentElement)) {
      scroll3 = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent, true);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    ...rect,
    x: rect.x - scroll3.scrollLeft + offsets.x,
    y: rect.y - scroll3.scrollTop + offsets.y
  };
}
function getViewportRect(element) {
  const win2 = getWindow(element);
  const html = getDocumentElement2(element);
  const visualViewport = win2.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x7 = 0;
  let y9 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    if (Math.abs(win2.innerWidth / visualViewport.scale - visualViewport.width) < 0.01) {
      x7 = visualViewport.offsetLeft;
      y9 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x7,
    y: y9
  };
}
function getDocumentRect(element) {
  var _element$ownerDocumen;
  const html = getDocumentElement2(element);
  const scroll3 = getNodeScroll(element);
  const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
  const width = max2(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
  const height = max2(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
  let x7 = -scroll3.scrollLeft + getWindowScrollBarX(element);
  const y9 = -scroll3.scrollTop;
  if (getComputedStyle$1(body || html).direction === "rtl") {
    x7 += max2(html.clientWidth, body ? body.clientWidth : 0) - width;
  }
  return {
    width,
    height,
    x: x7,
    y: y9
  };
}
function getScrollParent(node) {
  if (["html", "body", "#document"].includes(getNodeName(node))) {
    return node.ownerDocument.body;
  }
  if (isHTMLElement(node) && isScrollParent(node)) {
    return node;
  }
  return getScrollParent(getParentNode2(node));
}
function getScrollParents(node, list) {
  var _node$ownerDocument;
  if (list === void 0) {
    list = [];
  }
  const scrollParent = getScrollParent(node);
  const isBody = scrollParent === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
  const win2 = getWindow(scrollParent);
  const target = isBody ? [win2].concat(win2.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;
  const updatedList = list.concat(target);
  return isBody ? updatedList : (
    // @ts-ignore: isBody tells us target will be an HTMLElement here
    updatedList.concat(getScrollParents(getParentNode2(target)))
  );
}
function contains(parent2, child) {
  const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
  if (parent2.contains(child)) {
    return true;
  } else if (rootNode && isShadowRoot(rootNode)) {
    let next = child;
    do {
      if (next && parent2 === next) {
        return true;
      }
      next = next.parentNode || next.host;
    } while (next);
  }
  return false;
}
function getInnerBoundingClientRect(element) {
  const clientRect = getBoundingClientRect(element);
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  return {
    top,
    left,
    x: left,
    y: top,
    right: left + element.clientWidth,
    bottom: top + element.clientHeight,
    width: element.clientWidth,
    height: element.clientHeight
  };
}
function getClientRectFromClippingParent(element, clippingParent) {
  if (clippingParent === "viewport") {
    return rectToClientRect(getViewportRect(element));
  }
  if (isElement4(clippingParent)) {
    return getInnerBoundingClientRect(clippingParent);
  }
  return rectToClientRect(getDocumentRect(getDocumentElement2(element)));
}
function getClippingParents(element) {
  const clippingParents = getScrollParents(getParentNode2(element));
  const canEscapeClipping = ["absolute", "fixed"].includes(getComputedStyle$1(element).position);
  const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
  if (!isElement4(clipperElement)) {
    return [];
  }
  return clippingParents.filter((clippingParent) => isElement4(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== "body");
}
function getClippingClientRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary
  } = _ref;
  const mainClippingParents = boundary === "clippingParents" ? getClippingParents(element) : [].concat(boundary);
  const clippingParents = [...mainClippingParents, rootBoundary];
  const firstClippingParent = clippingParents[0];
  const clippingRect = clippingParents.reduce((accRect, clippingParent) => {
    const rect = getClientRectFromClippingParent(element, clippingParent);
    accRect.top = max2(rect.top, accRect.top);
    accRect.right = min2(rect.right, accRect.right);
    accRect.bottom = min2(rect.bottom, accRect.bottom);
    accRect.left = max2(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingParent(element, firstClippingParent));
  clippingRect.width = clippingRect.right - clippingRect.left;
  clippingRect.height = clippingRect.bottom - clippingRect.top;
  clippingRect.x = clippingRect.left;
  clippingRect.y = clippingRect.top;
  return clippingRect;
}
var platform = {
  getElementRects: (_ref) => {
    let {
      reference,
      floating,
      strategy
    } = _ref;
    return {
      reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
      floating: {
        ...getDimensions(floating),
        x: 0,
        y: 0
      }
    };
  },
  convertOffsetParentRelativeRectToViewportRelativeRect: (args) => convertOffsetParentRelativeRectToViewportRelativeRect(args),
  getOffsetParent: (_ref2) => {
    let {
      element
    } = _ref2;
    return getOffsetParent(element);
  },
  isElement: (value) => isElement4(value),
  getDocumentElement: (_ref3) => {
    let {
      element
    } = _ref3;
    return getDocumentElement2(element);
  },
  getClippingClientRect: (args) => getClippingClientRect(args),
  getDimensions: (_ref4) => {
    let {
      element
    } = _ref4;
    return getDimensions(element);
  },
  getClientRects: (_ref5) => {
    let {
      element
    } = _ref5;
    return element.getClientRects();
  }
};
var computePosition2 = (reference, floating, options) => computePosition(reference, floating, {
  platform,
  ...options
});

// node_modules/moment/dist/moment.js
var hookCallback;
function hooks() {
  return hookCallback.apply(null, arguments);
}
function setHookCallback(callback) {
  hookCallback = callback;
}
function isArray9(input) {
  return input instanceof Array || Object.prototype.toString.call(input) === "[object Array]";
}
function isObject8(input) {
  return input != null && Object.prototype.toString.call(input) === "[object Object]";
}
function hasOwnProp(a13, b6) {
  return Object.prototype.hasOwnProperty.call(a13, b6);
}
function isObjectEmpty(obj) {
  if (Object.getOwnPropertyNames) {
    return Object.getOwnPropertyNames(obj).length === 0;
  } else {
    var k3;
    for (k3 in obj) {
      if (hasOwnProp(obj, k3)) {
        return false;
      }
    }
    return true;
  }
}
function isUndefined3(input) {
  return input === void 0;
}
function isNumber(input) {
  return typeof input === "number" || Object.prototype.toString.call(input) === "[object Number]";
}
function isDate2(input) {
  return input instanceof Date || Object.prototype.toString.call(input) === "[object Date]";
}
function map3(arr, fn2) {
  var res = [], i15, arrLen = arr.length;
  for (i15 = 0; i15 < arrLen; ++i15) {
    res.push(fn2(arr[i15], i15));
  }
  return res;
}
function extend(a13, b6) {
  for (var i15 in b6) {
    if (hasOwnProp(b6, i15)) {
      a13[i15] = b6[i15];
    }
  }
  if (hasOwnProp(b6, "toString")) {
    a13.toString = b6.toString;
  }
  if (hasOwnProp(b6, "valueOf")) {
    a13.valueOf = b6.valueOf;
  }
  return a13;
}
function createUTC(input, format3, locale2, strict) {
  return createLocalOrUTC(input, format3, locale2, strict, true).utc();
}
function defaultParsingFlags() {
  return {
    empty: false,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: false,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: false,
    userInvalidated: false,
    iso: false,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: false,
    weekdayMismatch: false
  };
}
function getParsingFlags(m10) {
  if (m10._pf == null) {
    m10._pf = defaultParsingFlags();
  }
  return m10._pf;
}
var some;
if (Array.prototype.some) {
  some = Array.prototype.some;
} else {
  some = function(fun) {
    var t20 = Object(this), len = t20.length >>> 0, i15;
    for (i15 = 0; i15 < len; i15++) {
      if (i15 in t20 && fun.call(this, t20[i15], i15, t20)) {
        return true;
      }
    }
    return false;
  };
}
function isValid3(m10) {
  if (m10._isValid == null) {
    var flags = getParsingFlags(m10), parsedParts = some.call(flags.parsedDateParts, function(i15) {
      return i15 != null;
    }), isNowValid = !isNaN(m10._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
    if (m10._strict) {
      isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === void 0;
    }
    if (Object.isFrozen == null || !Object.isFrozen(m10)) {
      m10._isValid = isNowValid;
    } else {
      return isNowValid;
    }
  }
  return m10._isValid;
}
function createInvalid(flags) {
  var m10 = createUTC(NaN);
  if (flags != null) {
    extend(getParsingFlags(m10), flags);
  } else {
    getParsingFlags(m10).userInvalidated = true;
  }
  return m10;
}
var momentProperties = hooks.momentProperties = [];
var updateInProgress = false;
function copyConfig(to4, from2) {
  var i15, prop, val, momentPropertiesLen = momentProperties.length;
  if (!isUndefined3(from2._isAMomentObject)) {
    to4._isAMomentObject = from2._isAMomentObject;
  }
  if (!isUndefined3(from2._i)) {
    to4._i = from2._i;
  }
  if (!isUndefined3(from2._f)) {
    to4._f = from2._f;
  }
  if (!isUndefined3(from2._l)) {
    to4._l = from2._l;
  }
  if (!isUndefined3(from2._strict)) {
    to4._strict = from2._strict;
  }
  if (!isUndefined3(from2._tzm)) {
    to4._tzm = from2._tzm;
  }
  if (!isUndefined3(from2._isUTC)) {
    to4._isUTC = from2._isUTC;
  }
  if (!isUndefined3(from2._offset)) {
    to4._offset = from2._offset;
  }
  if (!isUndefined3(from2._pf)) {
    to4._pf = getParsingFlags(from2);
  }
  if (!isUndefined3(from2._locale)) {
    to4._locale = from2._locale;
  }
  if (momentPropertiesLen > 0) {
    for (i15 = 0; i15 < momentPropertiesLen; i15++) {
      prop = momentProperties[i15];
      val = from2[prop];
      if (!isUndefined3(val)) {
        to4[prop] = val;
      }
    }
  }
  return to4;
}
function Moment(config2) {
  copyConfig(this, config2);
  this._d = new Date(config2._d != null ? config2._d.getTime() : NaN);
  if (!this.isValid()) {
    this._d = new Date(NaN);
  }
  if (updateInProgress === false) {
    updateInProgress = true;
    hooks.updateOffset(this);
    updateInProgress = false;
  }
}
function isMoment(obj) {
  return obj instanceof Moment || obj != null && obj._isAMomentObject != null;
}
function warn(msg) {
  if (hooks.suppressDeprecationWarnings === false && typeof console !== "undefined" && console.warn) {
    console.warn("Deprecation warning: " + msg);
  }
}
function deprecate(msg, fn2) {
  var firstTime = true;
  return extend(function() {
    if (hooks.deprecationHandler != null) {
      hooks.deprecationHandler(null, msg);
    }
    if (firstTime) {
      var args = [], arg, i15, key, argLen = arguments.length;
      for (i15 = 0; i15 < argLen; i15++) {
        arg = "";
        if (typeof arguments[i15] === "object") {
          arg += "\n[" + i15 + "] ";
          for (key in arguments[0]) {
            if (hasOwnProp(arguments[0], key)) {
              arg += key + ": " + arguments[0][key] + ", ";
            }
          }
          arg = arg.slice(0, -2);
        } else {
          arg = arguments[i15];
        }
        args.push(arg);
      }
      warn(
        msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + new Error().stack
      );
      firstTime = false;
    }
    return fn2.apply(this, arguments);
  }, fn2);
}
var deprecations = {};
function deprecateSimple(name2, msg) {
  if (hooks.deprecationHandler != null) {
    hooks.deprecationHandler(name2, msg);
  }
  if (!deprecations[name2]) {
    warn(msg);
    deprecations[name2] = true;
  }
}
hooks.suppressDeprecationWarnings = false;
hooks.deprecationHandler = null;
function isFunction6(input) {
  return typeof Function !== "undefined" && input instanceof Function || Object.prototype.toString.call(input) === "[object Function]";
}
function set(config2) {
  var prop, i15;
  for (i15 in config2) {
    if (hasOwnProp(config2, i15)) {
      prop = config2[i15];
      if (isFunction6(prop)) {
        this[i15] = prop;
      } else {
        this["_" + i15] = prop;
      }
    }
  }
  this._config = config2;
  this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function mergeConfigs(parentConfig, childConfig) {
  var res = extend({}, parentConfig), prop;
  for (prop in childConfig) {
    if (hasOwnProp(childConfig, prop)) {
      if (isObject8(parentConfig[prop]) && isObject8(childConfig[prop])) {
        res[prop] = {};
        extend(res[prop], parentConfig[prop]);
        extend(res[prop], childConfig[prop]);
      } else if (childConfig[prop] != null) {
        res[prop] = childConfig[prop];
      } else {
        delete res[prop];
      }
    }
  }
  for (prop in parentConfig) {
    if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject8(parentConfig[prop])) {
      res[prop] = extend({}, res[prop]);
    }
  }
  return res;
}
function Locale(config2) {
  if (config2 != null) {
    this.set(config2);
  }
}
var keys5;
if (Object.keys) {
  keys5 = Object.keys;
} else {
  keys5 = function(obj) {
    var i15, res = [];
    for (i15 in obj) {
      if (hasOwnProp(obj, i15)) {
        res.push(i15);
      }
    }
    return res;
  };
}
var defaultCalendar = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function calendar(key, mom, now3) {
  var output = this._calendar[key] || this._calendar["sameElse"];
  return isFunction6(output) ? output.call(mom, now3) : output;
}
function zeroFill(number2, targetLength, forceSign) {
  var absNumber = "" + Math.abs(number2), zerosToFill = targetLength - absNumber.length, sign2 = number2 >= 0;
  return (sign2 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
}
var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
var formatFunctions = {};
var formatTokenFunctions = {};
function addFormatToken(token2, padded, ordinal2, callback) {
  var func = callback;
  if (typeof callback === "string") {
    func = function() {
      return this[callback]();
    };
  }
  if (token2) {
    formatTokenFunctions[token2] = func;
  }
  if (padded) {
    formatTokenFunctions[padded[0]] = function() {
      return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
    };
  }
  if (ordinal2) {
    formatTokenFunctions[ordinal2] = function() {
      return this.localeData().ordinal(
        func.apply(this, arguments),
        token2
      );
    };
  }
}
function removeFormattingTokens(input) {
  if (input.match(/\[[\s\S]/)) {
    return input.replace(/^\[|\]$/g, "");
  }
  return input.replace(/\\/g, "");
}
function makeFormatFunction(format3) {
  var array2 = format3.match(formattingTokens), i15, length;
  for (i15 = 0, length = array2.length; i15 < length; i15++) {
    if (formatTokenFunctions[array2[i15]]) {
      array2[i15] = formatTokenFunctions[array2[i15]];
    } else {
      array2[i15] = removeFormattingTokens(array2[i15]);
    }
  }
  return function(mom) {
    var output = "", i16;
    for (i16 = 0; i16 < length; i16++) {
      output += isFunction6(array2[i16]) ? array2[i16].call(mom, format3) : array2[i16];
    }
    return output;
  };
}
function formatMoment(m10, format3) {
  if (!m10.isValid()) {
    return m10.localeData().invalidDate();
  }
  format3 = expandFormat(format3, m10.localeData());
  formatFunctions[format3] = formatFunctions[format3] || makeFormatFunction(format3);
  return formatFunctions[format3](m10);
}
function expandFormat(format3, locale2) {
  var i15 = 5;
  function replaceLongDateFormatTokens(input) {
    return locale2.longDateFormat(input) || input;
  }
  localFormattingTokens.lastIndex = 0;
  while (i15 >= 0 && localFormattingTokens.test(format3)) {
    format3 = format3.replace(
      localFormattingTokens,
      replaceLongDateFormatTokens
    );
    localFormattingTokens.lastIndex = 0;
    i15 -= 1;
  }
  return format3;
}
var defaultLongDateFormat = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function longDateFormat(key) {
  var format3 = this._longDateFormat[key], formatUpper = this._longDateFormat[key.toUpperCase()];
  if (format3 || !formatUpper) {
    return format3;
  }
  this._longDateFormat[key] = formatUpper.match(formattingTokens).map(function(tok) {
    if (tok === "MMMM" || tok === "MM" || tok === "DD" || tok === "dddd") {
      return tok.slice(1);
    }
    return tok;
  }).join("");
  return this._longDateFormat[key];
}
var defaultInvalidDate = "Invalid date";
function invalidDate() {
  return this._invalidDate;
}
var defaultOrdinal = "%d";
var defaultDayOfMonthOrdinalParse = /\d{1,2}/;
function ordinal(number2) {
  return this._ordinal.replace("%d", number2);
}
var defaultRelativeTime = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function relativeTime(number2, withoutSuffix, string2, isFuture) {
  var output = this._relativeTime[string2];
  return isFunction6(output) ? output(number2, withoutSuffix, string2, isFuture) : output.replace(/%d/i, number2);
}
function pastFuture(diff3, output) {
  var format3 = this._relativeTime[diff3 > 0 ? "future" : "past"];
  return isFunction6(format3) ? format3(output) : format3.replace(/%s/i, output);
}
var aliases = {};
function addUnitAlias(unit, shorthand) {
  var lowerCase = unit.toLowerCase();
  aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit;
}
function normalizeUnits(units) {
  return typeof units === "string" ? aliases[units] || aliases[units.toLowerCase()] : void 0;
}
function normalizeObjectUnits(inputObject) {
  var normalizedInput = {}, normalizedProp, prop;
  for (prop in inputObject) {
    if (hasOwnProp(inputObject, prop)) {
      normalizedProp = normalizeUnits(prop);
      if (normalizedProp) {
        normalizedInput[normalizedProp] = inputObject[prop];
      }
    }
  }
  return normalizedInput;
}
var priorities = {};
function addUnitPriority(unit, priority) {
  priorities[unit] = priority;
}
function getPrioritizedUnits(unitsObj) {
  var units = [], u11;
  for (u11 in unitsObj) {
    if (hasOwnProp(unitsObj, u11)) {
      units.push({ unit: u11, priority: priorities[u11] });
    }
  }
  units.sort(function(a13, b6) {
    return a13.priority - b6.priority;
  });
  return units;
}
function isLeapYear(year) {
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
function absFloor(number2) {
  if (number2 < 0) {
    return Math.ceil(number2) || 0;
  } else {
    return Math.floor(number2);
  }
}
function toInt(argumentForCoercion) {
  var coercedNumber = +argumentForCoercion, value = 0;
  if (coercedNumber !== 0 && isFinite(coercedNumber)) {
    value = absFloor(coercedNumber);
  }
  return value;
}
function makeGetSet(unit, keepTime) {
  return function(value) {
    if (value != null) {
      set$1(this, unit, value);
      hooks.updateOffset(this, keepTime);
      return this;
    } else {
      return get6(this, unit);
    }
  };
}
function get6(mom, unit) {
  return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN;
}
function set$1(mom, unit, value) {
  if (mom.isValid() && !isNaN(value)) {
    if (unit === "FullYear" && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
      value = toInt(value);
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](
        value,
        mom.month(),
        daysInMonth(value, mom.month())
      );
    } else {
      mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value);
    }
  }
}
function stringGet(units) {
  units = normalizeUnits(units);
  if (isFunction6(this[units])) {
    return this[units]();
  }
  return this;
}
function stringSet(units, value) {
  if (typeof units === "object") {
    units = normalizeObjectUnits(units);
    var prioritized = getPrioritizedUnits(units), i15, prioritizedLen = prioritized.length;
    for (i15 = 0; i15 < prioritizedLen; i15++) {
      this[prioritized[i15].unit](units[prioritized[i15].unit]);
    }
  } else {
    units = normalizeUnits(units);
    if (isFunction6(this[units])) {
      return this[units](value);
    }
  }
  return this;
}
var match1 = /\d/;
var match22 = /\d\d/;
var match3 = /\d{3}/;
var match4 = /\d{4}/;
var match6 = /[+-]?\d{6}/;
var match1to2 = /\d\d?/;
var match3to4 = /\d\d\d\d?/;
var match5to6 = /\d\d\d\d\d\d?/;
var match1to3 = /\d{1,3}/;
var match1to4 = /\d{1,4}/;
var match1to6 = /[+-]?\d{1,6}/;
var matchUnsigned = /\d+/;
var matchSigned = /[+-]?\d+/;
var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;
var regexes;
regexes = {};
function addRegexToken(token2, regex, strictRegex) {
  regexes[token2] = isFunction6(regex) ? regex : function(isStrict, localeData2) {
    return isStrict && strictRegex ? strictRegex : regex;
  };
}
function getParseRegexForToken(token2, config2) {
  if (!hasOwnProp(regexes, token2)) {
    return new RegExp(unescapeFormat(token2));
  }
  return regexes[token2](config2._strict, config2._locale);
}
function unescapeFormat(s20) {
  return regexEscape(
    s20.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(matched, p1, p22, p32, p42) {
        return p1 || p22 || p32 || p42;
      }
    )
  );
}
function regexEscape(s20) {
  return s20.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
var tokens = {};
function addParseToken(token2, callback) {
  var i15, func = callback, tokenLen;
  if (typeof token2 === "string") {
    token2 = [token2];
  }
  if (isNumber(callback)) {
    func = function(input, array2) {
      array2[callback] = toInt(input);
    };
  }
  tokenLen = token2.length;
  for (i15 = 0; i15 < tokenLen; i15++) {
    tokens[token2[i15]] = func;
  }
}
function addWeekParseToken(token2, callback) {
  addParseToken(token2, function(input, array2, config2, token3) {
    config2._w = config2._w || {};
    callback(input, config2._w, config2, token3);
  });
}
function addTimeToArrayFromToken(token2, input, config2) {
  if (input != null && hasOwnProp(tokens, token2)) {
    tokens[token2](input, config2._a, config2, token2);
  }
}
var YEAR = 0;
var MONTH = 1;
var DATE = 2;
var HOUR = 3;
var MINUTE = 4;
var SECOND = 5;
var MILLISECOND = 6;
var WEEK = 7;
var WEEKDAY = 8;
function mod(n12, x7) {
  return (n12 % x7 + x7) % x7;
}
var indexOf;
if (Array.prototype.indexOf) {
  indexOf = Array.prototype.indexOf;
} else {
  indexOf = function(o16) {
    var i15;
    for (i15 = 0; i15 < this.length; ++i15) {
      if (this[i15] === o16) {
        return i15;
      }
    }
    return -1;
  };
}
function daysInMonth(year, month) {
  if (isNaN(year) || isNaN(month)) {
    return NaN;
  }
  var modMonth = mod(month, 12);
  year += (month - modMonth) / 12;
  return modMonth === 1 ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2;
}
addFormatToken("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
addFormatToken("MMM", 0, 0, function(format3) {
  return this.localeData().monthsShort(this, format3);
});
addFormatToken("MMMM", 0, 0, function(format3) {
  return this.localeData().months(this, format3);
});
addUnitAlias("month", "M");
addUnitPriority("month", 8);
addRegexToken("M", match1to2);
addRegexToken("MM", match1to2, match22);
addRegexToken("MMM", function(isStrict, locale2) {
  return locale2.monthsShortRegex(isStrict);
});
addRegexToken("MMMM", function(isStrict, locale2) {
  return locale2.monthsRegex(isStrict);
});
addParseToken(["M", "MM"], function(input, array2) {
  array2[MONTH] = toInt(input) - 1;
});
addParseToken(["MMM", "MMMM"], function(input, array2, config2, token2) {
  var month = config2._locale.monthsParse(input, token2, config2._strict);
  if (month != null) {
    array2[MONTH] = month;
  } else {
    getParsingFlags(config2).invalidMonth = input;
  }
});
var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
);
var defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_");
var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
var defaultMonthsShortRegex = matchWord;
var defaultMonthsRegex = matchWord;
function localeMonths(m10, format3) {
  if (!m10) {
    return isArray9(this._months) ? this._months : this._months["standalone"];
  }
  return isArray9(this._months) ? this._months[m10.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format3) ? "format" : "standalone"][m10.month()];
}
function localeMonthsShort(m10, format3) {
  if (!m10) {
    return isArray9(this._monthsShort) ? this._monthsShort : this._monthsShort["standalone"];
  }
  return isArray9(this._monthsShort) ? this._monthsShort[m10.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format3) ? "format" : "standalone"][m10.month()];
}
function handleStrictParse(monthName, format3, strict) {
  var i15, ii, mom, llc = monthName.toLocaleLowerCase();
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
    for (i15 = 0; i15 < 12; ++i15) {
      mom = createUTC([2e3, i15]);
      this._shortMonthsParse[i15] = this.monthsShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._longMonthsParse[i15] = this.months(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format3 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format3 === "MMM") {
      ii = indexOf.call(this._shortMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._longMonthsParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._longMonthsParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortMonthsParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeMonthsParse(monthName, format3, strict) {
  var i15, mom, regex;
  if (this._monthsParseExact) {
    return handleStrictParse.call(this, monthName, format3, strict);
  }
  if (!this._monthsParse) {
    this._monthsParse = [];
    this._longMonthsParse = [];
    this._shortMonthsParse = [];
  }
  for (i15 = 0; i15 < 12; i15++) {
    mom = createUTC([2e3, i15]);
    if (strict && !this._longMonthsParse[i15]) {
      this._longMonthsParse[i15] = new RegExp(
        "^" + this.months(mom, "").replace(".", "") + "$",
        "i"
      );
      this._shortMonthsParse[i15] = new RegExp(
        "^" + this.monthsShort(mom, "").replace(".", "") + "$",
        "i"
      );
    }
    if (!strict && !this._monthsParse[i15]) {
      regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, "");
      this._monthsParse[i15] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format3 === "MMMM" && this._longMonthsParse[i15].test(monthName)) {
      return i15;
    } else if (strict && format3 === "MMM" && this._shortMonthsParse[i15].test(monthName)) {
      return i15;
    } else if (!strict && this._monthsParse[i15].test(monthName)) {
      return i15;
    }
  }
}
function setMonth(mom, value) {
  var dayOfMonth;
  if (!mom.isValid()) {
    return mom;
  }
  if (typeof value === "string") {
    if (/^\d+$/.test(value)) {
      value = toInt(value);
    } else {
      value = mom.localeData().monthsParse(value);
      if (!isNumber(value)) {
        return mom;
      }
    }
  }
  dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
  mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth);
  return mom;
}
function getSetMonth(value) {
  if (value != null) {
    setMonth(this, value);
    hooks.updateOffset(this, true);
    return this;
  } else {
    return get6(this, "Month");
  }
}
function getDaysInMonth() {
  return daysInMonth(this.year(), this.month());
}
function monthsShortRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsShortStrictRegex;
    } else {
      return this._monthsShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsShortRegex")) {
      this._monthsShortRegex = defaultMonthsShortRegex;
    }
    return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
  }
}
function monthsRegex(isStrict) {
  if (this._monthsParseExact) {
    if (!hasOwnProp(this, "_monthsRegex")) {
      computeMonthsParse.call(this);
    }
    if (isStrict) {
      return this._monthsStrictRegex;
    } else {
      return this._monthsRegex;
    }
  } else {
    if (!hasOwnProp(this, "_monthsRegex")) {
      this._monthsRegex = defaultMonthsRegex;
    }
    return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
  }
}
function computeMonthsParse() {
  function cmpLenRev(a13, b6) {
    return b6.length - a13.length;
  }
  var shortPieces = [], longPieces = [], mixedPieces = [], i15, mom;
  for (i15 = 0; i15 < 12; i15++) {
    mom = createUTC([2e3, i15]);
    shortPieces.push(this.monthsShort(mom, ""));
    longPieces.push(this.months(mom, ""));
    mixedPieces.push(this.months(mom, ""));
    mixedPieces.push(this.monthsShort(mom, ""));
  }
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  for (i15 = 0; i15 < 12; i15++) {
    shortPieces[i15] = regexEscape(shortPieces[i15]);
    longPieces[i15] = regexEscape(longPieces[i15]);
  }
  for (i15 = 0; i15 < 24; i15++) {
    mixedPieces[i15] = regexEscape(mixedPieces[i15]);
  }
  this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._monthsShortRegex = this._monthsRegex;
  this._monthsStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._monthsShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
}
addFormatToken("Y", 0, 0, function() {
  var y9 = this.year();
  return y9 <= 9999 ? zeroFill(y9, 4) : "+" + y9;
});
addFormatToken(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
addFormatToken(0, ["YYYY", 4], 0, "year");
addFormatToken(0, ["YYYYY", 5], 0, "year");
addFormatToken(0, ["YYYYYY", 6, true], 0, "year");
addUnitAlias("year", "y");
addUnitPriority("year", 1);
addRegexToken("Y", matchSigned);
addRegexToken("YY", match1to2, match22);
addRegexToken("YYYY", match1to4, match4);
addRegexToken("YYYYY", match1to6, match6);
addRegexToken("YYYYYY", match1to6, match6);
addParseToken(["YYYYY", "YYYYYY"], YEAR);
addParseToken("YYYY", function(input, array2) {
  array2[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
});
addParseToken("YY", function(input, array2) {
  array2[YEAR] = hooks.parseTwoDigitYear(input);
});
addParseToken("Y", function(input, array2) {
  array2[YEAR] = parseInt(input, 10);
});
function daysInYear(year) {
  return isLeapYear(year) ? 366 : 365;
}
hooks.parseTwoDigitYear = function(input) {
  return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3);
};
var getSetYear = makeGetSet("FullYear", true);
function getIsLeapYear() {
  return isLeapYear(this.year());
}
function createDate(y9, m10, d17, h11, M10, s20, ms) {
  var date2;
  if (y9 < 100 && y9 >= 0) {
    date2 = new Date(y9 + 400, m10, d17, h11, M10, s20, ms);
    if (isFinite(date2.getFullYear())) {
      date2.setFullYear(y9);
    }
  } else {
    date2 = new Date(y9, m10, d17, h11, M10, s20, ms);
  }
  return date2;
}
function createUTCDate(y9) {
  var date2, args;
  if (y9 < 100 && y9 >= 0) {
    args = Array.prototype.slice.call(arguments);
    args[0] = y9 + 400;
    date2 = new Date(Date.UTC.apply(null, args));
    if (isFinite(date2.getUTCFullYear())) {
      date2.setUTCFullYear(y9);
    }
  } else {
    date2 = new Date(Date.UTC.apply(null, arguments));
  }
  return date2;
}
function firstWeekOffset(year, dow, doy) {
  var fwd = 7 + dow - doy, fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
  return -fwdlw + fwd - 1;
}
function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
  var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;
  if (dayOfYear <= 0) {
    resYear = year - 1;
    resDayOfYear = daysInYear(resYear) + dayOfYear;
  } else if (dayOfYear > daysInYear(year)) {
    resYear = year + 1;
    resDayOfYear = dayOfYear - daysInYear(year);
  } else {
    resYear = year;
    resDayOfYear = dayOfYear;
  }
  return {
    year: resYear,
    dayOfYear: resDayOfYear
  };
}
function weekOfYear(mom, dow, doy) {
  var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;
  if (week < 1) {
    resYear = mom.year() - 1;
    resWeek = week + weeksInYear(resYear, dow, doy);
  } else if (week > weeksInYear(mom.year(), dow, doy)) {
    resWeek = week - weeksInYear(mom.year(), dow, doy);
    resYear = mom.year() + 1;
  } else {
    resYear = mom.year();
    resWeek = week;
  }
  return {
    week: resWeek,
    year: resYear
  };
}
function weeksInYear(year, dow, doy) {
  var weekOffset = firstWeekOffset(year, dow, doy), weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
  return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
}
addFormatToken("w", ["ww", 2], "wo", "week");
addFormatToken("W", ["WW", 2], "Wo", "isoWeek");
addUnitAlias("week", "w");
addUnitAlias("isoWeek", "W");
addUnitPriority("week", 5);
addUnitPriority("isoWeek", 5);
addRegexToken("w", match1to2);
addRegexToken("ww", match1to2, match22);
addRegexToken("W", match1to2);
addRegexToken("WW", match1to2, match22);
addWeekParseToken(
  ["w", "ww", "W", "WW"],
  function(input, week, config2, token2) {
    week[token2.substr(0, 1)] = toInt(input);
  }
);
function localeWeek(mom) {
  return weekOfYear(mom, this._week.dow, this._week.doy).week;
}
var defaultLocaleWeek = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function localeFirstDayOfWeek() {
  return this._week.dow;
}
function localeFirstDayOfYear() {
  return this._week.doy;
}
function getSetWeek(input) {
  var week = this.localeData().week(this);
  return input == null ? week : this.add((input - week) * 7, "d");
}
function getSetISOWeek(input) {
  var week = weekOfYear(this, 1, 4).week;
  return input == null ? week : this.add((input - week) * 7, "d");
}
addFormatToken("d", 0, "do", "day");
addFormatToken("dd", 0, 0, function(format3) {
  return this.localeData().weekdaysMin(this, format3);
});
addFormatToken("ddd", 0, 0, function(format3) {
  return this.localeData().weekdaysShort(this, format3);
});
addFormatToken("dddd", 0, 0, function(format3) {
  return this.localeData().weekdays(this, format3);
});
addFormatToken("e", 0, 0, "weekday");
addFormatToken("E", 0, 0, "isoWeekday");
addUnitAlias("day", "d");
addUnitAlias("weekday", "e");
addUnitAlias("isoWeekday", "E");
addUnitPriority("day", 11);
addUnitPriority("weekday", 11);
addUnitPriority("isoWeekday", 11);
addRegexToken("d", match1to2);
addRegexToken("e", match1to2);
addRegexToken("E", match1to2);
addRegexToken("dd", function(isStrict, locale2) {
  return locale2.weekdaysMinRegex(isStrict);
});
addRegexToken("ddd", function(isStrict, locale2) {
  return locale2.weekdaysShortRegex(isStrict);
});
addRegexToken("dddd", function(isStrict, locale2) {
  return locale2.weekdaysRegex(isStrict);
});
addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config2, token2) {
  var weekday = config2._locale.weekdaysParse(input, token2, config2._strict);
  if (weekday != null) {
    week.d = weekday;
  } else {
    getParsingFlags(config2).invalidWeekday = input;
  }
});
addWeekParseToken(["d", "e", "E"], function(input, week, config2, token2) {
  week[token2] = toInt(input);
});
function parseWeekday(input, locale2) {
  if (typeof input !== "string") {
    return input;
  }
  if (!isNaN(input)) {
    return parseInt(input, 10);
  }
  input = locale2.weekdaysParse(input);
  if (typeof input === "number") {
    return input;
  }
  return null;
}
function parseIsoWeekday(input, locale2) {
  if (typeof input === "string") {
    return locale2.weekdaysParse(input) % 7 || 7;
  }
  return isNaN(input) ? null : input;
}
function shiftWeekdays(ws, n12) {
  return ws.slice(n12, 7).concat(ws.slice(0, n12));
}
var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_");
var defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_");
var defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_");
var defaultWeekdaysRegex = matchWord;
var defaultWeekdaysShortRegex = matchWord;
var defaultWeekdaysMinRegex = matchWord;
function localeWeekdays(m10, format3) {
  var weekdays = isArray9(this._weekdays) ? this._weekdays : this._weekdays[m10 && m10 !== true && this._weekdays.isFormat.test(format3) ? "format" : "standalone"];
  return m10 === true ? shiftWeekdays(weekdays, this._week.dow) : m10 ? weekdays[m10.day()] : weekdays;
}
function localeWeekdaysShort(m10) {
  return m10 === true ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m10 ? this._weekdaysShort[m10.day()] : this._weekdaysShort;
}
function localeWeekdaysMin(m10) {
  return m10 === true ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m10 ? this._weekdaysMin[m10.day()] : this._weekdaysMin;
}
function handleStrictParse$1(weekdayName, format3, strict) {
  var i15, ii, mom, llc = weekdayName.toLocaleLowerCase();
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._minWeekdaysParse = [];
    for (i15 = 0; i15 < 7; ++i15) {
      mom = createUTC([2e3, 1]).day(i15);
      this._minWeekdaysParse[i15] = this.weekdaysMin(
        mom,
        ""
      ).toLocaleLowerCase();
      this._shortWeekdaysParse[i15] = this.weekdaysShort(
        mom,
        ""
      ).toLocaleLowerCase();
      this._weekdaysParse[i15] = this.weekdays(mom, "").toLocaleLowerCase();
    }
  }
  if (strict) {
    if (format3 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format3 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  } else {
    if (format3 === "dddd") {
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else if (format3 === "ddd") {
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._minWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    } else {
      ii = indexOf.call(this._minWeekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._weekdaysParse, llc);
      if (ii !== -1) {
        return ii;
      }
      ii = indexOf.call(this._shortWeekdaysParse, llc);
      return ii !== -1 ? ii : null;
    }
  }
}
function localeWeekdaysParse(weekdayName, format3, strict) {
  var i15, mom, regex;
  if (this._weekdaysParseExact) {
    return handleStrictParse$1.call(this, weekdayName, format3, strict);
  }
  if (!this._weekdaysParse) {
    this._weekdaysParse = [];
    this._minWeekdaysParse = [];
    this._shortWeekdaysParse = [];
    this._fullWeekdaysParse = [];
  }
  for (i15 = 0; i15 < 7; i15++) {
    mom = createUTC([2e3, 1]).day(i15);
    if (strict && !this._fullWeekdaysParse[i15]) {
      this._fullWeekdaysParse[i15] = new RegExp(
        "^" + this.weekdays(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._shortWeekdaysParse[i15] = new RegExp(
        "^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
      this._minWeekdaysParse[i15] = new RegExp(
        "^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$",
        "i"
      );
    }
    if (!this._weekdaysParse[i15]) {
      regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, "");
      this._weekdaysParse[i15] = new RegExp(regex.replace(".", ""), "i");
    }
    if (strict && format3 === "dddd" && this._fullWeekdaysParse[i15].test(weekdayName)) {
      return i15;
    } else if (strict && format3 === "ddd" && this._shortWeekdaysParse[i15].test(weekdayName)) {
      return i15;
    } else if (strict && format3 === "dd" && this._minWeekdaysParse[i15].test(weekdayName)) {
      return i15;
    } else if (!strict && this._weekdaysParse[i15].test(weekdayName)) {
      return i15;
    }
  }
}
function getSetDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
  if (input != null) {
    input = parseWeekday(input, this.localeData());
    return this.add(input - day, "d");
  } else {
    return day;
  }
}
function getSetLocaleDayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return input == null ? weekday : this.add(input - weekday, "d");
}
function getSetISODayOfWeek(input) {
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    var weekday = parseIsoWeekday(input, this.localeData());
    return this.day(this.day() % 7 ? weekday : weekday - 7);
  } else {
    return this.day() || 7;
  }
}
function weekdaysRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysStrictRegex;
    } else {
      return this._weekdaysRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      this._weekdaysRegex = defaultWeekdaysRegex;
    }
    return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
  }
}
function weekdaysShortRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysShortStrictRegex;
    } else {
      return this._weekdaysShortRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysShortRegex")) {
      this._weekdaysShortRegex = defaultWeekdaysShortRegex;
    }
    return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
  }
}
function weekdaysMinRegex(isStrict) {
  if (this._weekdaysParseExact) {
    if (!hasOwnProp(this, "_weekdaysRegex")) {
      computeWeekdaysParse.call(this);
    }
    if (isStrict) {
      return this._weekdaysMinStrictRegex;
    } else {
      return this._weekdaysMinRegex;
    }
  } else {
    if (!hasOwnProp(this, "_weekdaysMinRegex")) {
      this._weekdaysMinRegex = defaultWeekdaysMinRegex;
    }
    return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
  }
}
function computeWeekdaysParse() {
  function cmpLenRev(a13, b6) {
    return b6.length - a13.length;
  }
  var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i15, mom, minp, shortp, longp;
  for (i15 = 0; i15 < 7; i15++) {
    mom = createUTC([2e3, 1]).day(i15);
    minp = regexEscape(this.weekdaysMin(mom, ""));
    shortp = regexEscape(this.weekdaysShort(mom, ""));
    longp = regexEscape(this.weekdays(mom, ""));
    minPieces.push(minp);
    shortPieces.push(shortp);
    longPieces.push(longp);
    mixedPieces.push(minp);
    mixedPieces.push(shortp);
    mixedPieces.push(longp);
  }
  minPieces.sort(cmpLenRev);
  shortPieces.sort(cmpLenRev);
  longPieces.sort(cmpLenRev);
  mixedPieces.sort(cmpLenRev);
  this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._weekdaysShortRegex = this._weekdaysRegex;
  this._weekdaysMinRegex = this._weekdaysRegex;
  this._weekdaysStrictRegex = new RegExp(
    "^(" + longPieces.join("|") + ")",
    "i"
  );
  this._weekdaysShortStrictRegex = new RegExp(
    "^(" + shortPieces.join("|") + ")",
    "i"
  );
  this._weekdaysMinStrictRegex = new RegExp(
    "^(" + minPieces.join("|") + ")",
    "i"
  );
}
function hFormat() {
  return this.hours() % 12 || 12;
}
function kFormat() {
  return this.hours() || 24;
}
addFormatToken("H", ["HH", 2], 0, "hour");
addFormatToken("h", ["hh", 2], 0, hFormat);
addFormatToken("k", ["kk", 2], 0, kFormat);
addFormatToken("hmm", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2);
});
addFormatToken("hmmss", 0, 0, function() {
  return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
addFormatToken("Hmm", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2);
});
addFormatToken("Hmmss", 0, 0, function() {
  return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
});
function meridiem(token2, lowercase) {
  addFormatToken(token2, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      lowercase
    );
  });
}
meridiem("a", true);
meridiem("A", false);
addUnitAlias("hour", "h");
addUnitPriority("hour", 13);
function matchMeridiem(isStrict, locale2) {
  return locale2._meridiemParse;
}
addRegexToken("a", matchMeridiem);
addRegexToken("A", matchMeridiem);
addRegexToken("H", match1to2);
addRegexToken("h", match1to2);
addRegexToken("k", match1to2);
addRegexToken("HH", match1to2, match22);
addRegexToken("hh", match1to2, match22);
addRegexToken("kk", match1to2, match22);
addRegexToken("hmm", match3to4);
addRegexToken("hmmss", match5to6);
addRegexToken("Hmm", match3to4);
addRegexToken("Hmmss", match5to6);
addParseToken(["H", "HH"], HOUR);
addParseToken(["k", "kk"], function(input, array2, config2) {
  var kInput = toInt(input);
  array2[HOUR] = kInput === 24 ? 0 : kInput;
});
addParseToken(["a", "A"], function(input, array2, config2) {
  config2._isPm = config2._locale.isPM(input);
  config2._meridiem = input;
});
addParseToken(["h", "hh"], function(input, array2, config2) {
  array2[HOUR] = toInt(input);
  getParsingFlags(config2).bigHour = true;
});
addParseToken("hmm", function(input, array2, config2) {
  var pos = input.length - 2;
  array2[HOUR] = toInt(input.substr(0, pos));
  array2[MINUTE] = toInt(input.substr(pos));
  getParsingFlags(config2).bigHour = true;
});
addParseToken("hmmss", function(input, array2, config2) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array2[HOUR] = toInt(input.substr(0, pos1));
  array2[MINUTE] = toInt(input.substr(pos1, 2));
  array2[SECOND] = toInt(input.substr(pos2));
  getParsingFlags(config2).bigHour = true;
});
addParseToken("Hmm", function(input, array2, config2) {
  var pos = input.length - 2;
  array2[HOUR] = toInt(input.substr(0, pos));
  array2[MINUTE] = toInt(input.substr(pos));
});
addParseToken("Hmmss", function(input, array2, config2) {
  var pos1 = input.length - 4, pos2 = input.length - 2;
  array2[HOUR] = toInt(input.substr(0, pos1));
  array2[MINUTE] = toInt(input.substr(pos1, 2));
  array2[SECOND] = toInt(input.substr(pos2));
});
function localeIsPM(input) {
  return (input + "").toLowerCase().charAt(0) === "p";
}
var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
var getSetHour = makeGetSet("Hours", true);
function localeMeridiem(hours2, minutes2, isLower) {
  if (hours2 > 11) {
    return isLower ? "pm" : "PM";
  } else {
    return isLower ? "am" : "AM";
  }
}
var baseConfig = {
  calendar: defaultCalendar,
  longDateFormat: defaultLongDateFormat,
  invalidDate: defaultInvalidDate,
  ordinal: defaultOrdinal,
  dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
  relativeTime: defaultRelativeTime,
  months: defaultLocaleMonths,
  monthsShort: defaultLocaleMonthsShort,
  week: defaultLocaleWeek,
  weekdays: defaultLocaleWeekdays,
  weekdaysMin: defaultLocaleWeekdaysMin,
  weekdaysShort: defaultLocaleWeekdaysShort,
  meridiemParse: defaultLocaleMeridiemParse
};
var locales = {};
var localeFamilies = {};
var globalLocale;
function commonPrefix(arr1, arr2) {
  var i15, minl = Math.min(arr1.length, arr2.length);
  for (i15 = 0; i15 < minl; i15 += 1) {
    if (arr1[i15] !== arr2[i15]) {
      return i15;
    }
  }
  return minl;
}
function normalizeLocale(key) {
  return key ? key.toLowerCase().replace("_", "-") : key;
}
function chooseLocale(names2) {
  var i15 = 0, j6, next, locale2, split2;
  while (i15 < names2.length) {
    split2 = normalizeLocale(names2[i15]).split("-");
    j6 = split2.length;
    next = normalizeLocale(names2[i15 + 1]);
    next = next ? next.split("-") : null;
    while (j6 > 0) {
      locale2 = loadLocale(split2.slice(0, j6).join("-"));
      if (locale2) {
        return locale2;
      }
      if (next && next.length >= j6 && commonPrefix(split2, next) >= j6 - 1) {
        break;
      }
      j6--;
    }
    i15++;
  }
  return globalLocale;
}
function isLocaleNameSane(name2) {
  return name2.match("^[^/\\\\]*$") != null;
}
function loadLocale(name2) {
  var oldLocale = null, aliasedRequire;
  if (locales[name2] === void 0 && typeof module !== "undefined" && module && module.exports && isLocaleNameSane(name2)) {
    try {
      oldLocale = globalLocale._abbr;
      aliasedRequire = __require;
      aliasedRequire("./locale/" + name2);
      getSetGlobalLocale(oldLocale);
    } catch (e9) {
      locales[name2] = null;
    }
  }
  return locales[name2];
}
function getSetGlobalLocale(key, values3) {
  var data;
  if (key) {
    if (isUndefined3(values3)) {
      data = getLocale(key);
    } else {
      data = defineLocale(key, values3);
    }
    if (data) {
      globalLocale = data;
    } else {
      if (typeof console !== "undefined" && console.warn) {
        console.warn(
          "Locale " + key + " not found. Did you forget to load it?"
        );
      }
    }
  }
  return globalLocale._abbr;
}
function defineLocale(name2, config2) {
  if (config2 !== null) {
    var locale2, parentConfig = baseConfig;
    config2.abbr = name2;
    if (locales[name2] != null) {
      deprecateSimple(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      );
      parentConfig = locales[name2]._config;
    } else if (config2.parentLocale != null) {
      if (locales[config2.parentLocale] != null) {
        parentConfig = locales[config2.parentLocale]._config;
      } else {
        locale2 = loadLocale(config2.parentLocale);
        if (locale2 != null) {
          parentConfig = locale2._config;
        } else {
          if (!localeFamilies[config2.parentLocale]) {
            localeFamilies[config2.parentLocale] = [];
          }
          localeFamilies[config2.parentLocale].push({
            name: name2,
            config: config2
          });
          return null;
        }
      }
    }
    locales[name2] = new Locale(mergeConfigs(parentConfig, config2));
    if (localeFamilies[name2]) {
      localeFamilies[name2].forEach(function(x7) {
        defineLocale(x7.name, x7.config);
      });
    }
    getSetGlobalLocale(name2);
    return locales[name2];
  } else {
    delete locales[name2];
    return null;
  }
}
function updateLocale(name2, config2) {
  if (config2 != null) {
    var locale2, tmpLocale, parentConfig = baseConfig;
    if (locales[name2] != null && locales[name2].parentLocale != null) {
      locales[name2].set(mergeConfigs(locales[name2]._config, config2));
    } else {
      tmpLocale = loadLocale(name2);
      if (tmpLocale != null) {
        parentConfig = tmpLocale._config;
      }
      config2 = mergeConfigs(parentConfig, config2);
      if (tmpLocale == null) {
        config2.abbr = name2;
      }
      locale2 = new Locale(config2);
      locale2.parentLocale = locales[name2];
      locales[name2] = locale2;
    }
    getSetGlobalLocale(name2);
  } else {
    if (locales[name2] != null) {
      if (locales[name2].parentLocale != null) {
        locales[name2] = locales[name2].parentLocale;
        if (name2 === getSetGlobalLocale()) {
          getSetGlobalLocale(name2);
        }
      } else if (locales[name2] != null) {
        delete locales[name2];
      }
    }
  }
  return locales[name2];
}
function getLocale(key) {
  var locale2;
  if (key && key._locale && key._locale._abbr) {
    key = key._locale._abbr;
  }
  if (!key) {
    return globalLocale;
  }
  if (!isArray9(key)) {
    locale2 = loadLocale(key);
    if (locale2) {
      return locale2;
    }
    key = [key];
  }
  return chooseLocale(key);
}
function listLocales() {
  return keys5(locales);
}
function checkOverflow(m10) {
  var overflow, a13 = m10._a;
  if (a13 && getParsingFlags(m10).overflow === -2) {
    overflow = a13[MONTH] < 0 || a13[MONTH] > 11 ? MONTH : a13[DATE] < 1 || a13[DATE] > daysInMonth(a13[YEAR], a13[MONTH]) ? DATE : a13[HOUR] < 0 || a13[HOUR] > 24 || a13[HOUR] === 24 && (a13[MINUTE] !== 0 || a13[SECOND] !== 0 || a13[MILLISECOND] !== 0) ? HOUR : a13[MINUTE] < 0 || a13[MINUTE] > 59 ? MINUTE : a13[SECOND] < 0 || a13[SECOND] > 59 ? SECOND : a13[MILLISECOND] < 0 || a13[MILLISECOND] > 999 ? MILLISECOND : -1;
    if (getParsingFlags(m10)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
      overflow = DATE;
    }
    if (getParsingFlags(m10)._overflowWeeks && overflow === -1) {
      overflow = WEEK;
    }
    if (getParsingFlags(m10)._overflowWeekday && overflow === -1) {
      overflow = WEEKDAY;
    }
    getParsingFlags(m10).overflow = overflow;
  }
  return m10;
}
var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
var isoDates = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, false],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, false],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, false],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, false],
  ["YYYY", /\d{4}/, false]
];
var isoTimes = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
];
var aspNetJsonRegex = /^\/?Date\((-?\d+)/i;
var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;
var obsOffsets = {
  UT: 0,
  GMT: 0,
  EDT: -4 * 60,
  EST: -5 * 60,
  CDT: -5 * 60,
  CST: -6 * 60,
  MDT: -6 * 60,
  MST: -7 * 60,
  PDT: -7 * 60,
  PST: -8 * 60
};
function configFromISO(config2) {
  var i15, l14, string2 = config2._i, match5 = extendedIsoRegex.exec(string2) || basicIsoRegex.exec(string2), allowTime, dateFormat, timeFormat, tzFormat, isoDatesLen = isoDates.length, isoTimesLen = isoTimes.length;
  if (match5) {
    getParsingFlags(config2).iso = true;
    for (i15 = 0, l14 = isoDatesLen; i15 < l14; i15++) {
      if (isoDates[i15][1].exec(match5[1])) {
        dateFormat = isoDates[i15][0];
        allowTime = isoDates[i15][2] !== false;
        break;
      }
    }
    if (dateFormat == null) {
      config2._isValid = false;
      return;
    }
    if (match5[3]) {
      for (i15 = 0, l14 = isoTimesLen; i15 < l14; i15++) {
        if (isoTimes[i15][1].exec(match5[3])) {
          timeFormat = (match5[2] || " ") + isoTimes[i15][0];
          break;
        }
      }
      if (timeFormat == null) {
        config2._isValid = false;
        return;
      }
    }
    if (!allowTime && timeFormat != null) {
      config2._isValid = false;
      return;
    }
    if (match5[4]) {
      if (tzRegex.exec(match5[4])) {
        tzFormat = "Z";
      } else {
        config2._isValid = false;
        return;
      }
    }
    config2._f = dateFormat + (timeFormat || "") + (tzFormat || "");
    configFromStringAndFormat(config2);
  } else {
    config2._isValid = false;
  }
}
function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
  var result = [
    untruncateYear(yearStr),
    defaultLocaleMonthsShort.indexOf(monthStr),
    parseInt(dayStr, 10),
    parseInt(hourStr, 10),
    parseInt(minuteStr, 10)
  ];
  if (secondStr) {
    result.push(parseInt(secondStr, 10));
  }
  return result;
}
function untruncateYear(yearStr) {
  var year = parseInt(yearStr, 10);
  if (year <= 49) {
    return 2e3 + year;
  } else if (year <= 999) {
    return 1900 + year;
  }
  return year;
}
function preprocessRFC2822(s20) {
  return s20.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function checkWeekday(weekdayStr, parsedInput, config2) {
  if (weekdayStr) {
    var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr), weekdayActual = new Date(
      parsedInput[0],
      parsedInput[1],
      parsedInput[2]
    ).getDay();
    if (weekdayProvided !== weekdayActual) {
      getParsingFlags(config2).weekdayMismatch = true;
      config2._isValid = false;
      return false;
    }
  }
  return true;
}
function calculateOffset(obsOffset, militaryOffset, numOffset) {
  if (obsOffset) {
    return obsOffsets[obsOffset];
  } else if (militaryOffset) {
    return 0;
  } else {
    var hm = parseInt(numOffset, 10), m10 = hm % 100, h11 = (hm - m10) / 100;
    return h11 * 60 + m10;
  }
}
function configFromRFC2822(config2) {
  var match5 = rfc2822.exec(preprocessRFC2822(config2._i)), parsedArray;
  if (match5) {
    parsedArray = extractFromRFC2822Strings(
      match5[4],
      match5[3],
      match5[2],
      match5[5],
      match5[6],
      match5[7]
    );
    if (!checkWeekday(match5[1], parsedArray, config2)) {
      return;
    }
    config2._a = parsedArray;
    config2._tzm = calculateOffset(match5[8], match5[9], match5[10]);
    config2._d = createUTCDate.apply(null, config2._a);
    config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
    getParsingFlags(config2).rfc2822 = true;
  } else {
    config2._isValid = false;
  }
}
function configFromString(config2) {
  var matched = aspNetJsonRegex.exec(config2._i);
  if (matched !== null) {
    config2._d = new Date(+matched[1]);
    return;
  }
  configFromISO(config2);
  if (config2._isValid === false) {
    delete config2._isValid;
  } else {
    return;
  }
  configFromRFC2822(config2);
  if (config2._isValid === false) {
    delete config2._isValid;
  } else {
    return;
  }
  if (config2._strict) {
    config2._isValid = false;
  } else {
    hooks.createFromInputFallback(config2);
  }
}
hooks.createFromInputFallback = deprecate(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(config2) {
    config2._d = new Date(config2._i + (config2._useUTC ? " UTC" : ""));
  }
);
function defaults3(a13, b6, c16) {
  if (a13 != null) {
    return a13;
  }
  if (b6 != null) {
    return b6;
  }
  return c16;
}
function currentDateArray(config2) {
  var nowValue = new Date(hooks.now());
  if (config2._useUTC) {
    return [
      nowValue.getUTCFullYear(),
      nowValue.getUTCMonth(),
      nowValue.getUTCDate()
    ];
  }
  return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
}
function configFromArray(config2) {
  var i15, date2, input = [], currentDate, expectedWeekday, yearToUse;
  if (config2._d) {
    return;
  }
  currentDate = currentDateArray(config2);
  if (config2._w && config2._a[DATE] == null && config2._a[MONTH] == null) {
    dayOfYearFromWeekInfo(config2);
  }
  if (config2._dayOfYear != null) {
    yearToUse = defaults3(config2._a[YEAR], currentDate[YEAR]);
    if (config2._dayOfYear > daysInYear(yearToUse) || config2._dayOfYear === 0) {
      getParsingFlags(config2)._overflowDayOfYear = true;
    }
    date2 = createUTCDate(yearToUse, 0, config2._dayOfYear);
    config2._a[MONTH] = date2.getUTCMonth();
    config2._a[DATE] = date2.getUTCDate();
  }
  for (i15 = 0; i15 < 3 && config2._a[i15] == null; ++i15) {
    config2._a[i15] = input[i15] = currentDate[i15];
  }
  for (; i15 < 7; i15++) {
    config2._a[i15] = input[i15] = config2._a[i15] == null ? i15 === 2 ? 1 : 0 : config2._a[i15];
  }
  if (config2._a[HOUR] === 24 && config2._a[MINUTE] === 0 && config2._a[SECOND] === 0 && config2._a[MILLISECOND] === 0) {
    config2._nextDay = true;
    config2._a[HOUR] = 0;
  }
  config2._d = (config2._useUTC ? createUTCDate : createDate).apply(
    null,
    input
  );
  expectedWeekday = config2._useUTC ? config2._d.getUTCDay() : config2._d.getDay();
  if (config2._tzm != null) {
    config2._d.setUTCMinutes(config2._d.getUTCMinutes() - config2._tzm);
  }
  if (config2._nextDay) {
    config2._a[HOUR] = 24;
  }
  if (config2._w && typeof config2._w.d !== "undefined" && config2._w.d !== expectedWeekday) {
    getParsingFlags(config2).weekdayMismatch = true;
  }
}
function dayOfYearFromWeekInfo(config2) {
  var w7, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
  w7 = config2._w;
  if (w7.GG != null || w7.W != null || w7.E != null) {
    dow = 1;
    doy = 4;
    weekYear = defaults3(
      w7.GG,
      config2._a[YEAR],
      weekOfYear(createLocal(), 1, 4).year
    );
    week = defaults3(w7.W, 1);
    weekday = defaults3(w7.E, 1);
    if (weekday < 1 || weekday > 7) {
      weekdayOverflow = true;
    }
  } else {
    dow = config2._locale._week.dow;
    doy = config2._locale._week.doy;
    curWeek = weekOfYear(createLocal(), dow, doy);
    weekYear = defaults3(w7.gg, config2._a[YEAR], curWeek.year);
    week = defaults3(w7.w, curWeek.week);
    if (w7.d != null) {
      weekday = w7.d;
      if (weekday < 0 || weekday > 6) {
        weekdayOverflow = true;
      }
    } else if (w7.e != null) {
      weekday = w7.e + dow;
      if (w7.e < 0 || w7.e > 6) {
        weekdayOverflow = true;
      }
    } else {
      weekday = dow;
    }
  }
  if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
    getParsingFlags(config2)._overflowWeeks = true;
  } else if (weekdayOverflow != null) {
    getParsingFlags(config2)._overflowWeekday = true;
  } else {
    temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
    config2._a[YEAR] = temp.year;
    config2._dayOfYear = temp.dayOfYear;
  }
}
hooks.ISO_8601 = function() {
};
hooks.RFC_2822 = function() {
};
function configFromStringAndFormat(config2) {
  if (config2._f === hooks.ISO_8601) {
    configFromISO(config2);
    return;
  }
  if (config2._f === hooks.RFC_2822) {
    configFromRFC2822(config2);
    return;
  }
  config2._a = [];
  getParsingFlags(config2).empty = true;
  var string2 = "" + config2._i, i15, parsedInput, tokens2, token2, skipped, stringLength = string2.length, totalParsedInputLength = 0, era, tokenLen;
  tokens2 = expandFormat(config2._f, config2._locale).match(formattingTokens) || [];
  tokenLen = tokens2.length;
  for (i15 = 0; i15 < tokenLen; i15++) {
    token2 = tokens2[i15];
    parsedInput = (string2.match(getParseRegexForToken(token2, config2)) || [])[0];
    if (parsedInput) {
      skipped = string2.substr(0, string2.indexOf(parsedInput));
      if (skipped.length > 0) {
        getParsingFlags(config2).unusedInput.push(skipped);
      }
      string2 = string2.slice(
        string2.indexOf(parsedInput) + parsedInput.length
      );
      totalParsedInputLength += parsedInput.length;
    }
    if (formatTokenFunctions[token2]) {
      if (parsedInput) {
        getParsingFlags(config2).empty = false;
      } else {
        getParsingFlags(config2).unusedTokens.push(token2);
      }
      addTimeToArrayFromToken(token2, parsedInput, config2);
    } else if (config2._strict && !parsedInput) {
      getParsingFlags(config2).unusedTokens.push(token2);
    }
  }
  getParsingFlags(config2).charsLeftOver = stringLength - totalParsedInputLength;
  if (string2.length > 0) {
    getParsingFlags(config2).unusedInput.push(string2);
  }
  if (config2._a[HOUR] <= 12 && getParsingFlags(config2).bigHour === true && config2._a[HOUR] > 0) {
    getParsingFlags(config2).bigHour = void 0;
  }
  getParsingFlags(config2).parsedDateParts = config2._a.slice(0);
  getParsingFlags(config2).meridiem = config2._meridiem;
  config2._a[HOUR] = meridiemFixWrap(
    config2._locale,
    config2._a[HOUR],
    config2._meridiem
  );
  era = getParsingFlags(config2).era;
  if (era !== null) {
    config2._a[YEAR] = config2._locale.erasConvertYear(era, config2._a[YEAR]);
  }
  configFromArray(config2);
  checkOverflow(config2);
}
function meridiemFixWrap(locale2, hour, meridiem2) {
  var isPm;
  if (meridiem2 == null) {
    return hour;
  }
  if (locale2.meridiemHour != null) {
    return locale2.meridiemHour(hour, meridiem2);
  } else if (locale2.isPM != null) {
    isPm = locale2.isPM(meridiem2);
    if (isPm && hour < 12) {
      hour += 12;
    }
    if (!isPm && hour === 12) {
      hour = 0;
    }
    return hour;
  } else {
    return hour;
  }
}
function configFromStringAndArray(config2) {
  var tempConfig, bestMoment, scoreToBeat, i15, currentScore, validFormatFound, bestFormatIsValid = false, configfLen = config2._f.length;
  if (configfLen === 0) {
    getParsingFlags(config2).invalidFormat = true;
    config2._d = new Date(NaN);
    return;
  }
  for (i15 = 0; i15 < configfLen; i15++) {
    currentScore = 0;
    validFormatFound = false;
    tempConfig = copyConfig({}, config2);
    if (config2._useUTC != null) {
      tempConfig._useUTC = config2._useUTC;
    }
    tempConfig._f = config2._f[i15];
    configFromStringAndFormat(tempConfig);
    if (isValid3(tempConfig)) {
      validFormatFound = true;
    }
    currentScore += getParsingFlags(tempConfig).charsLeftOver;
    currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
    getParsingFlags(tempConfig).score = currentScore;
    if (!bestFormatIsValid) {
      if (scoreToBeat == null || currentScore < scoreToBeat || validFormatFound) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
        if (validFormatFound) {
          bestFormatIsValid = true;
        }
      }
    } else {
      if (currentScore < scoreToBeat) {
        scoreToBeat = currentScore;
        bestMoment = tempConfig;
      }
    }
  }
  extend(config2, bestMoment || tempConfig);
}
function configFromObject(config2) {
  if (config2._d) {
    return;
  }
  var i15 = normalizeObjectUnits(config2._i), dayOrDate = i15.day === void 0 ? i15.date : i15.day;
  config2._a = map3(
    [i15.year, i15.month, dayOrDate, i15.hour, i15.minute, i15.second, i15.millisecond],
    function(obj) {
      return obj && parseInt(obj, 10);
    }
  );
  configFromArray(config2);
}
function createFromConfig(config2) {
  var res = new Moment(checkOverflow(prepareConfig(config2)));
  if (res._nextDay) {
    res.add(1, "d");
    res._nextDay = void 0;
  }
  return res;
}
function prepareConfig(config2) {
  var input = config2._i, format3 = config2._f;
  config2._locale = config2._locale || getLocale(config2._l);
  if (input === null || format3 === void 0 && input === "") {
    return createInvalid({ nullInput: true });
  }
  if (typeof input === "string") {
    config2._i = input = config2._locale.preparse(input);
  }
  if (isMoment(input)) {
    return new Moment(checkOverflow(input));
  } else if (isDate2(input)) {
    config2._d = input;
  } else if (isArray9(format3)) {
    configFromStringAndArray(config2);
  } else if (format3) {
    configFromStringAndFormat(config2);
  } else {
    configFromInput(config2);
  }
  if (!isValid3(config2)) {
    config2._d = null;
  }
  return config2;
}
function configFromInput(config2) {
  var input = config2._i;
  if (isUndefined3(input)) {
    config2._d = new Date(hooks.now());
  } else if (isDate2(input)) {
    config2._d = new Date(input.valueOf());
  } else if (typeof input === "string") {
    configFromString(config2);
  } else if (isArray9(input)) {
    config2._a = map3(input.slice(0), function(obj) {
      return parseInt(obj, 10);
    });
    configFromArray(config2);
  } else if (isObject8(input)) {
    configFromObject(config2);
  } else if (isNumber(input)) {
    config2._d = new Date(input);
  } else {
    hooks.createFromInputFallback(config2);
  }
}
function createLocalOrUTC(input, format3, locale2, strict, isUTC) {
  var c16 = {};
  if (format3 === true || format3 === false) {
    strict = format3;
    format3 = void 0;
  }
  if (locale2 === true || locale2 === false) {
    strict = locale2;
    locale2 = void 0;
  }
  if (isObject8(input) && isObjectEmpty(input) || isArray9(input) && input.length === 0) {
    input = void 0;
  }
  c16._isAMomentObject = true;
  c16._useUTC = c16._isUTC = isUTC;
  c16._l = locale2;
  c16._i = input;
  c16._f = format3;
  c16._strict = strict;
  return createFromConfig(c16);
}
function createLocal(input, format3, locale2, strict) {
  return createLocalOrUTC(input, format3, locale2, strict, false);
}
var prototypeMin = deprecate(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other < this ? this : other;
    } else {
      return createInvalid();
    }
  }
);
var prototypeMax = deprecate(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var other = createLocal.apply(null, arguments);
    if (this.isValid() && other.isValid()) {
      return other > this ? this : other;
    } else {
      return createInvalid();
    }
  }
);
function pickBy(fn2, moments) {
  var res, i15;
  if (moments.length === 1 && isArray9(moments[0])) {
    moments = moments[0];
  }
  if (!moments.length) {
    return createLocal();
  }
  res = moments[0];
  for (i15 = 1; i15 < moments.length; ++i15) {
    if (!moments[i15].isValid() || moments[i15][fn2](res)) {
      res = moments[i15];
    }
  }
  return res;
}
function min3() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isBefore", args);
}
function max3() {
  var args = [].slice.call(arguments, 0);
  return pickBy("isAfter", args);
}
var now2 = function() {
  return Date.now ? Date.now() : +new Date();
};
var ordering = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function isDurationValid(m10) {
  var key, unitHasDecimal = false, i15, orderLen = ordering.length;
  for (key in m10) {
    if (hasOwnProp(m10, key) && !(indexOf.call(ordering, key) !== -1 && (m10[key] == null || !isNaN(m10[key])))) {
      return false;
    }
  }
  for (i15 = 0; i15 < orderLen; ++i15) {
    if (m10[ordering[i15]]) {
      if (unitHasDecimal) {
        return false;
      }
      if (parseFloat(m10[ordering[i15]]) !== toInt(m10[ordering[i15]])) {
        unitHasDecimal = true;
      }
    }
  }
  return true;
}
function isValid$1() {
  return this._isValid;
}
function createInvalid$1() {
  return createDuration(NaN);
}
function Duration(duration) {
  var normalizedInput = normalizeObjectUnits(duration), years2 = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months2 = normalizedInput.month || 0, weeks2 = normalizedInput.week || normalizedInput.isoWeek || 0, days2 = normalizedInput.day || 0, hours2 = normalizedInput.hour || 0, minutes2 = normalizedInput.minute || 0, seconds2 = normalizedInput.second || 0, milliseconds2 = normalizedInput.millisecond || 0;
  this._isValid = isDurationValid(normalizedInput);
  this._milliseconds = +milliseconds2 + seconds2 * 1e3 + // 1000
  minutes2 * 6e4 + // 1000 * 60
  hours2 * 1e3 * 60 * 60;
  this._days = +days2 + weeks2 * 7;
  this._months = +months2 + quarters * 3 + years2 * 12;
  this._data = {};
  this._locale = getLocale();
  this._bubble();
}
function isDuration(obj) {
  return obj instanceof Duration;
}
function absRound(number2) {
  if (number2 < 0) {
    return Math.round(-1 * number2) * -1;
  } else {
    return Math.round(number2);
  }
}
function compareArrays(array1, array2, dontConvert) {
  var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i15;
  for (i15 = 0; i15 < len; i15++) {
    if (dontConvert && array1[i15] !== array2[i15] || !dontConvert && toInt(array1[i15]) !== toInt(array2[i15])) {
      diffs++;
    }
  }
  return diffs + lengthDiff;
}
function offset4(token2, separator) {
  addFormatToken(token2, 0, 0, function() {
    var offset5 = this.utcOffset(), sign2 = "+";
    if (offset5 < 0) {
      offset5 = -offset5;
      sign2 = "-";
    }
    return sign2 + zeroFill(~~(offset5 / 60), 2) + separator + zeroFill(~~offset5 % 60, 2);
  });
}
offset4("Z", ":");
offset4("ZZ", "");
addRegexToken("Z", matchShortOffset);
addRegexToken("ZZ", matchShortOffset);
addParseToken(["Z", "ZZ"], function(input, array2, config2) {
  config2._useUTC = true;
  config2._tzm = offsetFromString(matchShortOffset, input);
});
var chunkOffset = /([\+\-]|\d\d)/gi;
function offsetFromString(matcher, string2) {
  var matches = (string2 || "").match(matcher), chunk, parts, minutes2;
  if (matches === null) {
    return null;
  }
  chunk = matches[matches.length - 1] || [];
  parts = (chunk + "").match(chunkOffset) || ["-", 0, 0];
  minutes2 = +(parts[1] * 60) + toInt(parts[2]);
  return minutes2 === 0 ? 0 : parts[0] === "+" ? minutes2 : -minutes2;
}
function cloneWithOffset(input, model) {
  var res, diff3;
  if (model._isUTC) {
    res = model.clone();
    diff3 = (isMoment(input) || isDate2(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
    res._d.setTime(res._d.valueOf() + diff3);
    hooks.updateOffset(res, false);
    return res;
  } else {
    return createLocal(input).local();
  }
}
function getDateOffset(m10) {
  return -Math.round(m10._d.getTimezoneOffset());
}
hooks.updateOffset = function() {
};
function getSetOffset(input, keepLocalTime, keepMinutes) {
  var offset5 = this._offset || 0, localAdjust;
  if (!this.isValid()) {
    return input != null ? this : NaN;
  }
  if (input != null) {
    if (typeof input === "string") {
      input = offsetFromString(matchShortOffset, input);
      if (input === null) {
        return this;
      }
    } else if (Math.abs(input) < 16 && !keepMinutes) {
      input = input * 60;
    }
    if (!this._isUTC && keepLocalTime) {
      localAdjust = getDateOffset(this);
    }
    this._offset = input;
    this._isUTC = true;
    if (localAdjust != null) {
      this.add(localAdjust, "m");
    }
    if (offset5 !== input) {
      if (!keepLocalTime || this._changeInProgress) {
        addSubtract(
          this,
          createDuration(input - offset5, "m"),
          1,
          false
        );
      } else if (!this._changeInProgress) {
        this._changeInProgress = true;
        hooks.updateOffset(this, true);
        this._changeInProgress = null;
      }
    }
    return this;
  } else {
    return this._isUTC ? offset5 : getDateOffset(this);
  }
}
function getSetZone(input, keepLocalTime) {
  if (input != null) {
    if (typeof input !== "string") {
      input = -input;
    }
    this.utcOffset(input, keepLocalTime);
    return this;
  } else {
    return -this.utcOffset();
  }
}
function setOffsetToUTC(keepLocalTime) {
  return this.utcOffset(0, keepLocalTime);
}
function setOffsetToLocal(keepLocalTime) {
  if (this._isUTC) {
    this.utcOffset(0, keepLocalTime);
    this._isUTC = false;
    if (keepLocalTime) {
      this.subtract(getDateOffset(this), "m");
    }
  }
  return this;
}
function setOffsetToParsedOffset() {
  if (this._tzm != null) {
    this.utcOffset(this._tzm, false, true);
  } else if (typeof this._i === "string") {
    var tZone = offsetFromString(matchOffset, this._i);
    if (tZone != null) {
      this.utcOffset(tZone);
    } else {
      this.utcOffset(0, true);
    }
  }
  return this;
}
function hasAlignedHourOffset(input) {
  if (!this.isValid()) {
    return false;
  }
  input = input ? createLocal(input).utcOffset() : 0;
  return (this.utcOffset() - input) % 60 === 0;
}
function isDaylightSavingTime() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function isDaylightSavingTimeShifted() {
  if (!isUndefined3(this._isDSTShifted)) {
    return this._isDSTShifted;
  }
  var c16 = {}, other;
  copyConfig(c16, this);
  c16 = prepareConfig(c16);
  if (c16._a) {
    other = c16._isUTC ? createUTC(c16._a) : createLocal(c16._a);
    this._isDSTShifted = this.isValid() && compareArrays(c16._a, other.toArray()) > 0;
  } else {
    this._isDSTShifted = false;
  }
  return this._isDSTShifted;
}
function isLocal() {
  return this.isValid() ? !this._isUTC : false;
}
function isUtcOffset() {
  return this.isValid() ? this._isUTC : false;
}
function isUtc() {
  return this.isValid() ? this._isUTC && this._offset === 0 : false;
}
var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/;
var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function createDuration(input, key) {
  var duration = input, match5 = null, sign2, ret, diffRes;
  if (isDuration(input)) {
    duration = {
      ms: input._milliseconds,
      d: input._days,
      M: input._months
    };
  } else if (isNumber(input) || !isNaN(+input)) {
    duration = {};
    if (key) {
      duration[key] = +input;
    } else {
      duration.milliseconds = +input;
    }
  } else if (match5 = aspNetRegex.exec(input)) {
    sign2 = match5[1] === "-" ? -1 : 1;
    duration = {
      y: 0,
      d: toInt(match5[DATE]) * sign2,
      h: toInt(match5[HOUR]) * sign2,
      m: toInt(match5[MINUTE]) * sign2,
      s: toInt(match5[SECOND]) * sign2,
      ms: toInt(absRound(match5[MILLISECOND] * 1e3)) * sign2
      // the millisecond decimal point is included in the match
    };
  } else if (match5 = isoRegex.exec(input)) {
    sign2 = match5[1] === "-" ? -1 : 1;
    duration = {
      y: parseIso(match5[2], sign2),
      M: parseIso(match5[3], sign2),
      w: parseIso(match5[4], sign2),
      d: parseIso(match5[5], sign2),
      h: parseIso(match5[6], sign2),
      m: parseIso(match5[7], sign2),
      s: parseIso(match5[8], sign2)
    };
  } else if (duration == null) {
    duration = {};
  } else if (typeof duration === "object" && ("from" in duration || "to" in duration)) {
    diffRes = momentsDifference(
      createLocal(duration.from),
      createLocal(duration.to)
    );
    duration = {};
    duration.ms = diffRes.milliseconds;
    duration.M = diffRes.months;
  }
  ret = new Duration(duration);
  if (isDuration(input) && hasOwnProp(input, "_locale")) {
    ret._locale = input._locale;
  }
  if (isDuration(input) && hasOwnProp(input, "_isValid")) {
    ret._isValid = input._isValid;
  }
  return ret;
}
createDuration.fn = Duration.prototype;
createDuration.invalid = createInvalid$1;
function parseIso(inp, sign2) {
  var res = inp && parseFloat(inp.replace(",", "."));
  return (isNaN(res) ? 0 : res) * sign2;
}
function positiveMomentsDifference(base, other) {
  var res = {};
  res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
  if (base.clone().add(res.months, "M").isAfter(other)) {
    --res.months;
  }
  res.milliseconds = +other - +base.clone().add(res.months, "M");
  return res;
}
function momentsDifference(base, other) {
  var res;
  if (!(base.isValid() && other.isValid())) {
    return { milliseconds: 0, months: 0 };
  }
  other = cloneWithOffset(other, base);
  if (base.isBefore(other)) {
    res = positiveMomentsDifference(base, other);
  } else {
    res = positiveMomentsDifference(other, base);
    res.milliseconds = -res.milliseconds;
    res.months = -res.months;
  }
  return res;
}
function createAdder(direction, name2) {
  return function(val, period) {
    var dur, tmp;
    if (period !== null && !isNaN(+period)) {
      deprecateSimple(
        name2,
        "moment()." + name2 + "(period, number) is deprecated. Please use moment()." + name2 + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
      );
      tmp = val;
      val = period;
      period = tmp;
    }
    dur = createDuration(val, period);
    addSubtract(this, dur, direction);
    return this;
  };
}
function addSubtract(mom, duration, isAdding, updateOffset) {
  var milliseconds2 = duration._milliseconds, days2 = absRound(duration._days), months2 = absRound(duration._months);
  if (!mom.isValid()) {
    return;
  }
  updateOffset = updateOffset == null ? true : updateOffset;
  if (months2) {
    setMonth(mom, get6(mom, "Month") + months2 * isAdding);
  }
  if (days2) {
    set$1(mom, "Date", get6(mom, "Date") + days2 * isAdding);
  }
  if (milliseconds2) {
    mom._d.setTime(mom._d.valueOf() + milliseconds2 * isAdding);
  }
  if (updateOffset) {
    hooks.updateOffset(mom, days2 || months2);
  }
}
var add3 = createAdder(1, "add");
var subtract3 = createAdder(-1, "subtract");
function isString(input) {
  return typeof input === "string" || input instanceof String;
}
function isMomentInput(input) {
  return isMoment(input) || isDate2(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || input === null || input === void 0;
}
function isMomentInputObject(input) {
  var objectTest = isObject8(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], i15, property3, propertyLen = properties.length;
  for (i15 = 0; i15 < propertyLen; i15 += 1) {
    property3 = properties[i15];
    propertyTest = propertyTest || hasOwnProp(input, property3);
  }
  return objectTest && propertyTest;
}
function isNumberOrStringArray(input) {
  var arrayTest = isArray9(input), dataTypeTest = false;
  if (arrayTest) {
    dataTypeTest = input.filter(function(item) {
      return !isNumber(item) && isString(input);
    }).length === 0;
  }
  return arrayTest && dataTypeTest;
}
function isCalendarSpec(input) {
  var objectTest = isObject8(input) && !isObjectEmpty(input), propertyTest = false, properties = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], i15, property3;
  for (i15 = 0; i15 < properties.length; i15 += 1) {
    property3 = properties[i15];
    propertyTest = propertyTest || hasOwnProp(input, property3);
  }
  return objectTest && propertyTest;
}
function getCalendarFormat(myMoment, now3) {
  var diff3 = myMoment.diff(now3, "days", true);
  return diff3 < -6 ? "sameElse" : diff3 < -1 ? "lastWeek" : diff3 < 0 ? "lastDay" : diff3 < 1 ? "sameDay" : diff3 < 2 ? "nextDay" : diff3 < 7 ? "nextWeek" : "sameElse";
}
function calendar$1(time, formats) {
  if (arguments.length === 1) {
    if (!arguments[0]) {
      time = void 0;
      formats = void 0;
    } else if (isMomentInput(arguments[0])) {
      time = arguments[0];
      formats = void 0;
    } else if (isCalendarSpec(arguments[0])) {
      formats = arguments[0];
      time = void 0;
    }
  }
  var now3 = time || createLocal(), sod = cloneWithOffset(now3, this).startOf("day"), format3 = hooks.calendarFormat(this, sod) || "sameElse", output = formats && (isFunction6(formats[format3]) ? formats[format3].call(this, now3) : formats[format3]);
  return this.format(
    output || this.localeData().calendar(format3, this, createLocal(now3))
  );
}
function clone2() {
  return new Moment(this);
}
function isAfter(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() > localInput.valueOf();
  } else {
    return localInput.valueOf() < this.clone().startOf(units).valueOf();
  }
}
function isBefore(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input);
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() < localInput.valueOf();
  } else {
    return this.clone().endOf(units).valueOf() < localInput.valueOf();
  }
}
function isBetween(from2, to4, units, inclusivity) {
  var localFrom = isMoment(from2) ? from2 : createLocal(from2), localTo = isMoment(to4) ? to4 : createLocal(to4);
  if (!(this.isValid() && localFrom.isValid() && localTo.isValid())) {
    return false;
  }
  inclusivity = inclusivity || "()";
  return (inclusivity[0] === "(" ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (inclusivity[1] === ")" ? this.isBefore(localTo, units) : !this.isAfter(localTo, units));
}
function isSame(input, units) {
  var localInput = isMoment(input) ? input : createLocal(input), inputMs;
  if (!(this.isValid() && localInput.isValid())) {
    return false;
  }
  units = normalizeUnits(units) || "millisecond";
  if (units === "millisecond") {
    return this.valueOf() === localInput.valueOf();
  } else {
    inputMs = localInput.valueOf();
    return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
  }
}
function isSameOrAfter(input, units) {
  return this.isSame(input, units) || this.isAfter(input, units);
}
function isSameOrBefore(input, units) {
  return this.isSame(input, units) || this.isBefore(input, units);
}
function diff(input, units, asFloat) {
  var that, zoneDelta, output;
  if (!this.isValid()) {
    return NaN;
  }
  that = cloneWithOffset(input, this);
  if (!that.isValid()) {
    return NaN;
  }
  zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
  units = normalizeUnits(units);
  switch (units) {
    case "year":
      output = monthDiff(this, that) / 12;
      break;
    case "month":
      output = monthDiff(this, that);
      break;
    case "quarter":
      output = monthDiff(this, that) / 3;
      break;
    case "second":
      output = (this - that) / 1e3;
      break;
    case "minute":
      output = (this - that) / 6e4;
      break;
    case "hour":
      output = (this - that) / 36e5;
      break;
    case "day":
      output = (this - that - zoneDelta) / 864e5;
      break;
    case "week":
      output = (this - that - zoneDelta) / 6048e5;
      break;
    default:
      output = this - that;
  }
  return asFloat ? output : absFloor(output);
}
function monthDiff(a13, b6) {
  if (a13.date() < b6.date()) {
    return -monthDiff(b6, a13);
  }
  var wholeMonthDiff = (b6.year() - a13.year()) * 12 + (b6.month() - a13.month()), anchor = a13.clone().add(wholeMonthDiff, "months"), anchor2, adjust;
  if (b6 - anchor < 0) {
    anchor2 = a13.clone().add(wholeMonthDiff - 1, "months");
    adjust = (b6 - anchor) / (anchor - anchor2);
  } else {
    anchor2 = a13.clone().add(wholeMonthDiff + 1, "months");
    adjust = (b6 - anchor) / (anchor2 - anchor);
  }
  return -(wholeMonthDiff + adjust) || 0;
}
hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function toString5() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function toISOString(keepOffset) {
  if (!this.isValid()) {
    return null;
  }
  var utc = keepOffset !== true, m10 = utc ? this.clone().utc() : this;
  if (m10.year() < 0 || m10.year() > 9999) {
    return formatMoment(
      m10,
      utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
    );
  }
  if (isFunction6(Date.prototype.toISOString)) {
    if (utc) {
      return this.toDate().toISOString();
    } else {
      return new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", formatMoment(m10, "Z"));
    }
  }
  return formatMoment(
    m10,
    utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function inspect() {
  if (!this.isValid()) {
    return "moment.invalid(/* " + this._i + " */)";
  }
  var func = "moment", zone = "", prefix3, year, datetime, suffix2;
  if (!this.isLocal()) {
    func = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone";
    zone = "Z";
  }
  prefix3 = "[" + func + '("]';
  year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY";
  datetime = "-MM-DD[T]HH:mm:ss.SSS";
  suffix2 = zone + '[")]';
  return this.format(prefix3 + year + datetime + suffix2);
}
function format(inputString) {
  if (!inputString) {
    inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
  }
  var output = formatMoment(this, inputString);
  return this.localeData().postformat(output);
}
function from(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ to: this, from: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function fromNow(withoutSuffix) {
  return this.from(createLocal(), withoutSuffix);
}
function to2(time, withoutSuffix) {
  if (this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid())) {
    return createDuration({ from: this, to: time }).locale(this.locale()).humanize(!withoutSuffix);
  } else {
    return this.localeData().invalidDate();
  }
}
function toNow(withoutSuffix) {
  return this.to(createLocal(), withoutSuffix);
}
function locale(key) {
  var newLocaleData;
  if (key === void 0) {
    return this._locale._abbr;
  } else {
    newLocaleData = getLocale(key);
    if (newLocaleData != null) {
      this._locale = newLocaleData;
    }
    return this;
  }
}
var lang = deprecate(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(key) {
    if (key === void 0) {
      return this.localeData();
    } else {
      return this.locale(key);
    }
  }
);
function localeData() {
  return this._locale;
}
var MS_PER_SECOND = 1e3;
var MS_PER_MINUTE = 60 * MS_PER_SECOND;
var MS_PER_HOUR = 60 * MS_PER_MINUTE;
var MS_PER_400_YEARS = (365 * 400 + 97) * 24 * MS_PER_HOUR;
function mod$1(dividend, divisor) {
  return (dividend % divisor + divisor) % divisor;
}
function localStartOfDate(y9, m10, d17) {
  if (y9 < 100 && y9 >= 0) {
    return new Date(y9 + 400, m10, d17) - MS_PER_400_YEARS;
  } else {
    return new Date(y9, m10, d17).valueOf();
  }
}
function utcStartOfDate(y9, m10, d17) {
  if (y9 < 100 && y9 >= 0) {
    return Date.UTC(y9 + 400, m10, d17) - MS_PER_400_YEARS;
  } else {
    return Date.UTC(y9, m10, d17);
  }
}
function startOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year(), 0, 1);
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      time = startOfDate(this.year(), this.month(), 1);
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date());
      break;
    case "hour":
      time = this._d.valueOf();
      time -= mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      );
      break;
    case "minute":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_MINUTE);
      break;
    case "second":
      time = this._d.valueOf();
      time -= mod$1(time, MS_PER_SECOND);
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function endOf(units) {
  var time, startOfDate;
  units = normalizeUnits(units);
  if (units === void 0 || units === "millisecond" || !this.isValid()) {
    return this;
  }
  startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate;
  switch (units) {
    case "year":
      time = startOfDate(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      time = startOfDate(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      time = startOfDate(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      time = startOfDate(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      time = this._d.valueOf();
      time += MS_PER_HOUR - mod$1(
        time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE),
        MS_PER_HOUR
      ) - 1;
      break;
    case "minute":
      time = this._d.valueOf();
      time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
      break;
    case "second":
      time = this._d.valueOf();
      time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1;
      break;
  }
  this._d.setTime(time);
  hooks.updateOffset(this, true);
  return this;
}
function valueOf() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function unix() {
  return Math.floor(this.valueOf() / 1e3);
}
function toDate() {
  return new Date(this.valueOf());
}
function toArray2() {
  var m10 = this;
  return [
    m10.year(),
    m10.month(),
    m10.date(),
    m10.hour(),
    m10.minute(),
    m10.second(),
    m10.millisecond()
  ];
}
function toObject() {
  var m10 = this;
  return {
    years: m10.year(),
    months: m10.month(),
    date: m10.date(),
    hours: m10.hours(),
    minutes: m10.minutes(),
    seconds: m10.seconds(),
    milliseconds: m10.milliseconds()
  };
}
function toJSON() {
  return this.isValid() ? this.toISOString() : null;
}
function isValid$2() {
  return isValid3(this);
}
function parsingFlags() {
  return extend({}, getParsingFlags(this));
}
function invalidAt() {
  return getParsingFlags(this).overflow;
}
function creationData() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
addFormatToken("N", 0, 0, "eraAbbr");
addFormatToken("NN", 0, 0, "eraAbbr");
addFormatToken("NNN", 0, 0, "eraAbbr");
addFormatToken("NNNN", 0, 0, "eraName");
addFormatToken("NNNNN", 0, 0, "eraNarrow");
addFormatToken("y", ["y", 1], "yo", "eraYear");
addFormatToken("y", ["yy", 2], 0, "eraYear");
addFormatToken("y", ["yyy", 3], 0, "eraYear");
addFormatToken("y", ["yyyy", 4], 0, "eraYear");
addRegexToken("N", matchEraAbbr);
addRegexToken("NN", matchEraAbbr);
addRegexToken("NNN", matchEraAbbr);
addRegexToken("NNNN", matchEraName);
addRegexToken("NNNNN", matchEraNarrow);
addParseToken(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(input, array2, config2, token2) {
    var era = config2._locale.erasParse(input, token2, config2._strict);
    if (era) {
      getParsingFlags(config2).era = era;
    } else {
      getParsingFlags(config2).invalidEra = input;
    }
  }
);
addRegexToken("y", matchUnsigned);
addRegexToken("yy", matchUnsigned);
addRegexToken("yyy", matchUnsigned);
addRegexToken("yyyy", matchUnsigned);
addRegexToken("yo", matchEraYearOrdinal);
addParseToken(["y", "yy", "yyy", "yyyy"], YEAR);
addParseToken(["yo"], function(input, array2, config2, token2) {
  var match5;
  if (config2._locale._eraYearOrdinalRegex) {
    match5 = input.match(config2._locale._eraYearOrdinalRegex);
  }
  if (config2._locale.eraYearOrdinalParse) {
    array2[YEAR] = config2._locale.eraYearOrdinalParse(input, match5);
  } else {
    array2[YEAR] = parseInt(input, 10);
  }
});
function localeEras(m10, format3) {
  var i15, l14, date2, eras = this._eras || getLocale("en")._eras;
  for (i15 = 0, l14 = eras.length; i15 < l14; ++i15) {
    switch (typeof eras[i15].since) {
      case "string":
        date2 = hooks(eras[i15].since).startOf("day");
        eras[i15].since = date2.valueOf();
        break;
    }
    switch (typeof eras[i15].until) {
      case "undefined":
        eras[i15].until = Infinity;
        break;
      case "string":
        date2 = hooks(eras[i15].until).startOf("day").valueOf();
        eras[i15].until = date2.valueOf();
        break;
    }
  }
  return eras;
}
function localeErasParse(eraName, format3, strict) {
  var i15, l14, eras = this.eras(), name2, abbr, narrow;
  eraName = eraName.toUpperCase();
  for (i15 = 0, l14 = eras.length; i15 < l14; ++i15) {
    name2 = eras[i15].name.toUpperCase();
    abbr = eras[i15].abbr.toUpperCase();
    narrow = eras[i15].narrow.toUpperCase();
    if (strict) {
      switch (format3) {
        case "N":
        case "NN":
        case "NNN":
          if (abbr === eraName) {
            return eras[i15];
          }
          break;
        case "NNNN":
          if (name2 === eraName) {
            return eras[i15];
          }
          break;
        case "NNNNN":
          if (narrow === eraName) {
            return eras[i15];
          }
          break;
      }
    } else if ([name2, abbr, narrow].indexOf(eraName) >= 0) {
      return eras[i15];
    }
  }
}
function localeErasConvertYear(era, year) {
  var dir = era.since <= era.until ? 1 : -1;
  if (year === void 0) {
    return hooks(era.since).year();
  } else {
    return hooks(era.since).year() + (year - era.offset) * dir;
  }
}
function getEraName() {
  var i15, l14, val, eras = this.localeData().eras();
  for (i15 = 0, l14 = eras.length; i15 < l14; ++i15) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i15].since <= val && val <= eras[i15].until) {
      return eras[i15].name;
    }
    if (eras[i15].until <= val && val <= eras[i15].since) {
      return eras[i15].name;
    }
  }
  return "";
}
function getEraNarrow() {
  var i15, l14, val, eras = this.localeData().eras();
  for (i15 = 0, l14 = eras.length; i15 < l14; ++i15) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i15].since <= val && val <= eras[i15].until) {
      return eras[i15].narrow;
    }
    if (eras[i15].until <= val && val <= eras[i15].since) {
      return eras[i15].narrow;
    }
  }
  return "";
}
function getEraAbbr() {
  var i15, l14, val, eras = this.localeData().eras();
  for (i15 = 0, l14 = eras.length; i15 < l14; ++i15) {
    val = this.clone().startOf("day").valueOf();
    if (eras[i15].since <= val && val <= eras[i15].until) {
      return eras[i15].abbr;
    }
    if (eras[i15].until <= val && val <= eras[i15].since) {
      return eras[i15].abbr;
    }
  }
  return "";
}
function getEraYear() {
  var i15, l14, dir, val, eras = this.localeData().eras();
  for (i15 = 0, l14 = eras.length; i15 < l14; ++i15) {
    dir = eras[i15].since <= eras[i15].until ? 1 : -1;
    val = this.clone().startOf("day").valueOf();
    if (eras[i15].since <= val && val <= eras[i15].until || eras[i15].until <= val && val <= eras[i15].since) {
      return (this.year() - hooks(eras[i15].since).year()) * dir + eras[i15].offset;
    }
  }
  return this.year();
}
function erasNameRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNameRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNameRegex : this._erasRegex;
}
function erasAbbrRegex(isStrict) {
  if (!hasOwnProp(this, "_erasAbbrRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasAbbrRegex : this._erasRegex;
}
function erasNarrowRegex(isStrict) {
  if (!hasOwnProp(this, "_erasNarrowRegex")) {
    computeErasParse.call(this);
  }
  return isStrict ? this._erasNarrowRegex : this._erasRegex;
}
function matchEraAbbr(isStrict, locale2) {
  return locale2.erasAbbrRegex(isStrict);
}
function matchEraName(isStrict, locale2) {
  return locale2.erasNameRegex(isStrict);
}
function matchEraNarrow(isStrict, locale2) {
  return locale2.erasNarrowRegex(isStrict);
}
function matchEraYearOrdinal(isStrict, locale2) {
  return locale2._eraYearOrdinalRegex || matchUnsigned;
}
function computeErasParse() {
  var abbrPieces = [], namePieces = [], narrowPieces = [], mixedPieces = [], i15, l14, eras = this.eras();
  for (i15 = 0, l14 = eras.length; i15 < l14; ++i15) {
    namePieces.push(regexEscape(eras[i15].name));
    abbrPieces.push(regexEscape(eras[i15].abbr));
    narrowPieces.push(regexEscape(eras[i15].narrow));
    mixedPieces.push(regexEscape(eras[i15].name));
    mixedPieces.push(regexEscape(eras[i15].abbr));
    mixedPieces.push(regexEscape(eras[i15].narrow));
  }
  this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i");
  this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i");
  this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i");
  this._erasNarrowRegex = new RegExp(
    "^(" + narrowPieces.join("|") + ")",
    "i"
  );
}
addFormatToken(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
addFormatToken(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function addWeekYearFormatToken(token2, getter3) {
  addFormatToken(0, [token2, token2.length], 0, getter3);
}
addWeekYearFormatToken("gggg", "weekYear");
addWeekYearFormatToken("ggggg", "weekYear");
addWeekYearFormatToken("GGGG", "isoWeekYear");
addWeekYearFormatToken("GGGGG", "isoWeekYear");
addUnitAlias("weekYear", "gg");
addUnitAlias("isoWeekYear", "GG");
addUnitPriority("weekYear", 1);
addUnitPriority("isoWeekYear", 1);
addRegexToken("G", matchSigned);
addRegexToken("g", matchSigned);
addRegexToken("GG", match1to2, match22);
addRegexToken("gg", match1to2, match22);
addRegexToken("GGGG", match1to4, match4);
addRegexToken("gggg", match1to4, match4);
addRegexToken("GGGGG", match1to6, match6);
addRegexToken("ggggg", match1to6, match6);
addWeekParseToken(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(input, week, config2, token2) {
    week[token2.substr(0, 2)] = toInt(input);
  }
);
addWeekParseToken(["gg", "GG"], function(input, week, config2, token2) {
  week[token2] = hooks.parseTwoDigitYear(input);
});
function getSetWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.week(),
    this.weekday(),
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function getSetISOWeekYear(input) {
  return getSetWeekYearHelper.call(
    this,
    input,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function getISOWeeksInYear() {
  return weeksInYear(this.year(), 1, 4);
}
function getISOWeeksInISOWeekYear() {
  return weeksInYear(this.isoWeekYear(), 1, 4);
}
function getWeeksInYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
}
function getWeeksInWeekYear() {
  var weekInfo = this.localeData()._week;
  return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy);
}
function getSetWeekYearHelper(input, week, weekday, dow, doy) {
  var weeksTarget;
  if (input == null) {
    return weekOfYear(this, dow, doy).year;
  } else {
    weeksTarget = weeksInYear(input, dow, doy);
    if (week > weeksTarget) {
      week = weeksTarget;
    }
    return setWeekAll.call(this, input, week, weekday, dow, doy);
  }
}
function setWeekAll(weekYear, week, weekday, dow, doy) {
  var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), date2 = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
  this.year(date2.getUTCFullYear());
  this.month(date2.getUTCMonth());
  this.date(date2.getUTCDate());
  return this;
}
addFormatToken("Q", 0, "Qo", "quarter");
addUnitAlias("quarter", "Q");
addUnitPriority("quarter", 7);
addRegexToken("Q", match1);
addParseToken("Q", function(input, array2) {
  array2[MONTH] = (toInt(input) - 1) * 3;
});
function getSetQuarter(input) {
  return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
}
addFormatToken("D", ["DD", 2], "Do", "date");
addUnitAlias("date", "D");
addUnitPriority("date", 9);
addRegexToken("D", match1to2);
addRegexToken("DD", match1to2, match22);
addRegexToken("Do", function(isStrict, locale2) {
  return isStrict ? locale2._dayOfMonthOrdinalParse || locale2._ordinalParse : locale2._dayOfMonthOrdinalParseLenient;
});
addParseToken(["D", "DD"], DATE);
addParseToken("Do", function(input, array2) {
  array2[DATE] = toInt(input.match(match1to2)[0]);
});
var getSetDayOfMonth = makeGetSet("Date", true);
addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
addUnitAlias("dayOfYear", "DDD");
addUnitPriority("dayOfYear", 4);
addRegexToken("DDD", match1to3);
addRegexToken("DDDD", match3);
addParseToken(["DDD", "DDDD"], function(input, array2, config2) {
  config2._dayOfYear = toInt(input);
});
function getSetDayOfYear(input) {
  var dayOfYear = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return input == null ? dayOfYear : this.add(input - dayOfYear, "d");
}
addFormatToken("m", ["mm", 2], 0, "minute");
addUnitAlias("minute", "m");
addUnitPriority("minute", 14);
addRegexToken("m", match1to2);
addRegexToken("mm", match1to2, match22);
addParseToken(["m", "mm"], MINUTE);
var getSetMinute = makeGetSet("Minutes", false);
addFormatToken("s", ["ss", 2], 0, "second");
addUnitAlias("second", "s");
addUnitPriority("second", 15);
addRegexToken("s", match1to2);
addRegexToken("ss", match1to2, match22);
addParseToken(["s", "ss"], SECOND);
var getSetSecond = makeGetSet("Seconds", false);
addFormatToken("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
addFormatToken(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
addFormatToken(0, ["SSS", 3], 0, "millisecond");
addFormatToken(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
addFormatToken(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
addFormatToken(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
addFormatToken(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
addUnitAlias("millisecond", "ms");
addUnitPriority("millisecond", 16);
addRegexToken("S", match1to3, match1);
addRegexToken("SS", match1to3, match22);
addRegexToken("SSS", match1to3, match3);
var token;
var getSetMillisecond;
for (token = "SSSS"; token.length <= 9; token += "S") {
  addRegexToken(token, matchUnsigned);
}
function parseMs(input, array2) {
  array2[MILLISECOND] = toInt(("0." + input) * 1e3);
}
for (token = "S"; token.length <= 9; token += "S") {
  addParseToken(token, parseMs);
}
getSetMillisecond = makeGetSet("Milliseconds", false);
addFormatToken("z", 0, 0, "zoneAbbr");
addFormatToken("zz", 0, 0, "zoneName");
function getZoneAbbr() {
  return this._isUTC ? "UTC" : "";
}
function getZoneName() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var proto = Moment.prototype;
proto.add = add3;
proto.calendar = calendar$1;
proto.clone = clone2;
proto.diff = diff;
proto.endOf = endOf;
proto.format = format;
proto.from = from;
proto.fromNow = fromNow;
proto.to = to2;
proto.toNow = toNow;
proto.get = stringGet;
proto.invalidAt = invalidAt;
proto.isAfter = isAfter;
proto.isBefore = isBefore;
proto.isBetween = isBetween;
proto.isSame = isSame;
proto.isSameOrAfter = isSameOrAfter;
proto.isSameOrBefore = isSameOrBefore;
proto.isValid = isValid$2;
proto.lang = lang;
proto.locale = locale;
proto.localeData = localeData;
proto.max = prototypeMax;
proto.min = prototypeMin;
proto.parsingFlags = parsingFlags;
proto.set = stringSet;
proto.startOf = startOf;
proto.subtract = subtract3;
proto.toArray = toArray2;
proto.toObject = toObject;
proto.toDate = toDate;
proto.toISOString = toISOString;
proto.inspect = inspect;
if (typeof Symbol !== "undefined" && Symbol.for != null) {
  proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
    return "Moment<" + this.format() + ">";
  };
}
proto.toJSON = toJSON;
proto.toString = toString5;
proto.unix = unix;
proto.valueOf = valueOf;
proto.creationData = creationData;
proto.eraName = getEraName;
proto.eraNarrow = getEraNarrow;
proto.eraAbbr = getEraAbbr;
proto.eraYear = getEraYear;
proto.year = getSetYear;
proto.isLeapYear = getIsLeapYear;
proto.weekYear = getSetWeekYear;
proto.isoWeekYear = getSetISOWeekYear;
proto.quarter = proto.quarters = getSetQuarter;
proto.month = getSetMonth;
proto.daysInMonth = getDaysInMonth;
proto.week = proto.weeks = getSetWeek;
proto.isoWeek = proto.isoWeeks = getSetISOWeek;
proto.weeksInYear = getWeeksInYear;
proto.weeksInWeekYear = getWeeksInWeekYear;
proto.isoWeeksInYear = getISOWeeksInYear;
proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear;
proto.date = getSetDayOfMonth;
proto.day = proto.days = getSetDayOfWeek;
proto.weekday = getSetLocaleDayOfWeek;
proto.isoWeekday = getSetISODayOfWeek;
proto.dayOfYear = getSetDayOfYear;
proto.hour = proto.hours = getSetHour;
proto.minute = proto.minutes = getSetMinute;
proto.second = proto.seconds = getSetSecond;
proto.millisecond = proto.milliseconds = getSetMillisecond;
proto.utcOffset = getSetOffset;
proto.utc = setOffsetToUTC;
proto.local = setOffsetToLocal;
proto.parseZone = setOffsetToParsedOffset;
proto.hasAlignedHourOffset = hasAlignedHourOffset;
proto.isDST = isDaylightSavingTime;
proto.isLocal = isLocal;
proto.isUtcOffset = isUtcOffset;
proto.isUtc = isUtc;
proto.isUTC = isUtc;
proto.zoneAbbr = getZoneAbbr;
proto.zoneName = getZoneName;
proto.dates = deprecate(
  "dates accessor is deprecated. Use date instead.",
  getSetDayOfMonth
);
proto.months = deprecate(
  "months accessor is deprecated. Use month instead",
  getSetMonth
);
proto.years = deprecate(
  "years accessor is deprecated. Use year instead",
  getSetYear
);
proto.zone = deprecate(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  getSetZone
);
proto.isDSTShifted = deprecate(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  isDaylightSavingTimeShifted
);
function createUnix(input) {
  return createLocal(input * 1e3);
}
function createInZone() {
  return createLocal.apply(null, arguments).parseZone();
}
function preParsePostFormat(string2) {
  return string2;
}
var proto$1 = Locale.prototype;
proto$1.calendar = calendar;
proto$1.longDateFormat = longDateFormat;
proto$1.invalidDate = invalidDate;
proto$1.ordinal = ordinal;
proto$1.preparse = preParsePostFormat;
proto$1.postformat = preParsePostFormat;
proto$1.relativeTime = relativeTime;
proto$1.pastFuture = pastFuture;
proto$1.set = set;
proto$1.eras = localeEras;
proto$1.erasParse = localeErasParse;
proto$1.erasConvertYear = localeErasConvertYear;
proto$1.erasAbbrRegex = erasAbbrRegex;
proto$1.erasNameRegex = erasNameRegex;
proto$1.erasNarrowRegex = erasNarrowRegex;
proto$1.months = localeMonths;
proto$1.monthsShort = localeMonthsShort;
proto$1.monthsParse = localeMonthsParse;
proto$1.monthsRegex = monthsRegex;
proto$1.monthsShortRegex = monthsShortRegex;
proto$1.week = localeWeek;
proto$1.firstDayOfYear = localeFirstDayOfYear;
proto$1.firstDayOfWeek = localeFirstDayOfWeek;
proto$1.weekdays = localeWeekdays;
proto$1.weekdaysMin = localeWeekdaysMin;
proto$1.weekdaysShort = localeWeekdaysShort;
proto$1.weekdaysParse = localeWeekdaysParse;
proto$1.weekdaysRegex = weekdaysRegex;
proto$1.weekdaysShortRegex = weekdaysShortRegex;
proto$1.weekdaysMinRegex = weekdaysMinRegex;
proto$1.isPM = localeIsPM;
proto$1.meridiem = localeMeridiem;
function get$1(format3, index2, field, setter) {
  var locale2 = getLocale(), utc = createUTC().set(setter, index2);
  return locale2[field](utc, format3);
}
function listMonthsImpl(format3, index2, field) {
  if (isNumber(format3)) {
    index2 = format3;
    format3 = void 0;
  }
  format3 = format3 || "";
  if (index2 != null) {
    return get$1(format3, index2, field, "month");
  }
  var i15, out = [];
  for (i15 = 0; i15 < 12; i15++) {
    out[i15] = get$1(format3, i15, field, "month");
  }
  return out;
}
function listWeekdaysImpl(localeSorted, format3, index2, field) {
  if (typeof localeSorted === "boolean") {
    if (isNumber(format3)) {
      index2 = format3;
      format3 = void 0;
    }
    format3 = format3 || "";
  } else {
    format3 = localeSorted;
    index2 = format3;
    localeSorted = false;
    if (isNumber(format3)) {
      index2 = format3;
      format3 = void 0;
    }
    format3 = format3 || "";
  }
  var locale2 = getLocale(), shift6 = localeSorted ? locale2._week.dow : 0, i15, out = [];
  if (index2 != null) {
    return get$1(format3, (index2 + shift6) % 7, field, "day");
  }
  for (i15 = 0; i15 < 7; i15++) {
    out[i15] = get$1(format3, (i15 + shift6) % 7, field, "day");
  }
  return out;
}
function listMonths(format3, index2) {
  return listMonthsImpl(format3, index2, "months");
}
function listMonthsShort(format3, index2) {
  return listMonthsImpl(format3, index2, "monthsShort");
}
function listWeekdays(localeSorted, format3, index2) {
  return listWeekdaysImpl(localeSorted, format3, index2, "weekdays");
}
function listWeekdaysShort(localeSorted, format3, index2) {
  return listWeekdaysImpl(localeSorted, format3, index2, "weekdaysShort");
}
function listWeekdaysMin(localeSorted, format3, index2) {
  return listWeekdaysImpl(localeSorted, format3, index2, "weekdaysMin");
}
getSetGlobalLocale("en", {
  eras: [
    {
      since: "0001-01-01",
      until: Infinity,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -Infinity,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(number2) {
    var b6 = number2 % 10, output = toInt(number2 % 100 / 10) === 1 ? "th" : b6 === 1 ? "st" : b6 === 2 ? "nd" : b6 === 3 ? "rd" : "th";
    return number2 + output;
  }
});
hooks.lang = deprecate(
  "moment.lang is deprecated. Use moment.locale instead.",
  getSetGlobalLocale
);
hooks.langData = deprecate(
  "moment.langData is deprecated. Use moment.localeData instead.",
  getLocale
);
var mathAbs = Math.abs;
function abs() {
  var data = this._data;
  this._milliseconds = mathAbs(this._milliseconds);
  this._days = mathAbs(this._days);
  this._months = mathAbs(this._months);
  data.milliseconds = mathAbs(data.milliseconds);
  data.seconds = mathAbs(data.seconds);
  data.minutes = mathAbs(data.minutes);
  data.hours = mathAbs(data.hours);
  data.months = mathAbs(data.months);
  data.years = mathAbs(data.years);
  return this;
}
function addSubtract$1(duration, input, value, direction) {
  var other = createDuration(input, value);
  duration._milliseconds += direction * other._milliseconds;
  duration._days += direction * other._days;
  duration._months += direction * other._months;
  return duration._bubble();
}
function add$1(input, value) {
  return addSubtract$1(this, input, value, 1);
}
function subtract$1(input, value) {
  return addSubtract$1(this, input, value, -1);
}
function absCeil(number2) {
  if (number2 < 0) {
    return Math.floor(number2);
  } else {
    return Math.ceil(number2);
  }
}
function bubble() {
  var milliseconds2 = this._milliseconds, days2 = this._days, months2 = this._months, data = this._data, seconds2, minutes2, hours2, years2, monthsFromDays;
  if (!(milliseconds2 >= 0 && days2 >= 0 && months2 >= 0 || milliseconds2 <= 0 && days2 <= 0 && months2 <= 0)) {
    milliseconds2 += absCeil(monthsToDays(months2) + days2) * 864e5;
    days2 = 0;
    months2 = 0;
  }
  data.milliseconds = milliseconds2 % 1e3;
  seconds2 = absFloor(milliseconds2 / 1e3);
  data.seconds = seconds2 % 60;
  minutes2 = absFloor(seconds2 / 60);
  data.minutes = minutes2 % 60;
  hours2 = absFloor(minutes2 / 60);
  data.hours = hours2 % 24;
  days2 += absFloor(hours2 / 24);
  monthsFromDays = absFloor(daysToMonths(days2));
  months2 += monthsFromDays;
  days2 -= absCeil(monthsToDays(monthsFromDays));
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  data.days = days2;
  data.months = months2;
  data.years = years2;
  return this;
}
function daysToMonths(days2) {
  return days2 * 4800 / 146097;
}
function monthsToDays(months2) {
  return months2 * 146097 / 4800;
}
function as(units) {
  if (!this.isValid()) {
    return NaN;
  }
  var days2, months2, milliseconds2 = this._milliseconds;
  units = normalizeUnits(units);
  if (units === "month" || units === "quarter" || units === "year") {
    days2 = this._days + milliseconds2 / 864e5;
    months2 = this._months + daysToMonths(days2);
    switch (units) {
      case "month":
        return months2;
      case "quarter":
        return months2 / 3;
      case "year":
        return months2 / 12;
    }
  } else {
    days2 = this._days + Math.round(monthsToDays(this._months));
    switch (units) {
      case "week":
        return days2 / 7 + milliseconds2 / 6048e5;
      case "day":
        return days2 + milliseconds2 / 864e5;
      case "hour":
        return days2 * 24 + milliseconds2 / 36e5;
      case "minute":
        return days2 * 1440 + milliseconds2 / 6e4;
      case "second":
        return days2 * 86400 + milliseconds2 / 1e3;
      case "millisecond":
        return Math.floor(days2 * 864e5) + milliseconds2;
      default:
        throw new Error("Unknown unit " + units);
    }
  }
}
function valueOf$1() {
  if (!this.isValid()) {
    return NaN;
  }
  return this._milliseconds + this._days * 864e5 + this._months % 12 * 2592e6 + toInt(this._months / 12) * 31536e6;
}
function makeAs(alias) {
  return function() {
    return this.as(alias);
  };
}
var asMilliseconds = makeAs("ms");
var asSeconds = makeAs("s");
var asMinutes = makeAs("m");
var asHours = makeAs("h");
var asDays = makeAs("d");
var asWeeks = makeAs("w");
var asMonths = makeAs("M");
var asQuarters = makeAs("Q");
var asYears = makeAs("y");
function clone$1() {
  return createDuration(this);
}
function get$2(units) {
  units = normalizeUnits(units);
  return this.isValid() ? this[units + "s"]() : NaN;
}
function makeGetter(name2) {
  return function() {
    return this.isValid() ? this._data[name2] : NaN;
  };
}
var milliseconds = makeGetter("milliseconds");
var seconds = makeGetter("seconds");
var minutes = makeGetter("minutes");
var hours = makeGetter("hours");
var days = makeGetter("days");
var months = makeGetter("months");
var years = makeGetter("years");
function weeks() {
  return absFloor(this.days() / 7);
}
var round2 = Math.round;
var thresholds = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function substituteTimeAgo(string2, number2, withoutSuffix, isFuture, locale2) {
  return locale2.relativeTime(number2 || 1, !!withoutSuffix, string2, isFuture);
}
function relativeTime$1(posNegDuration, withoutSuffix, thresholds2, locale2) {
  var duration = createDuration(posNegDuration).abs(), seconds2 = round2(duration.as("s")), minutes2 = round2(duration.as("m")), hours2 = round2(duration.as("h")), days2 = round2(duration.as("d")), months2 = round2(duration.as("M")), weeks2 = round2(duration.as("w")), years2 = round2(duration.as("y")), a13 = seconds2 <= thresholds2.ss && ["s", seconds2] || seconds2 < thresholds2.s && ["ss", seconds2] || minutes2 <= 1 && ["m"] || minutes2 < thresholds2.m && ["mm", minutes2] || hours2 <= 1 && ["h"] || hours2 < thresholds2.h && ["hh", hours2] || days2 <= 1 && ["d"] || days2 < thresholds2.d && ["dd", days2];
  if (thresholds2.w != null) {
    a13 = a13 || weeks2 <= 1 && ["w"] || weeks2 < thresholds2.w && ["ww", weeks2];
  }
  a13 = a13 || months2 <= 1 && ["M"] || months2 < thresholds2.M && ["MM", months2] || years2 <= 1 && ["y"] || ["yy", years2];
  a13[2] = withoutSuffix;
  a13[3] = +posNegDuration > 0;
  a13[4] = locale2;
  return substituteTimeAgo.apply(null, a13);
}
function getSetRelativeTimeRounding(roundingFunction) {
  if (roundingFunction === void 0) {
    return round2;
  }
  if (typeof roundingFunction === "function") {
    round2 = roundingFunction;
    return true;
  }
  return false;
}
function getSetRelativeTimeThreshold(threshold, limit) {
  if (thresholds[threshold] === void 0) {
    return false;
  }
  if (limit === void 0) {
    return thresholds[threshold];
  }
  thresholds[threshold] = limit;
  if (threshold === "s") {
    thresholds.ss = limit - 1;
  }
  return true;
}
function humanize(argWithSuffix, argThresholds) {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var withSuffix = false, th = thresholds, locale2, output;
  if (typeof argWithSuffix === "object") {
    argThresholds = argWithSuffix;
    argWithSuffix = false;
  }
  if (typeof argWithSuffix === "boolean") {
    withSuffix = argWithSuffix;
  }
  if (typeof argThresholds === "object") {
    th = Object.assign({}, thresholds, argThresholds);
    if (argThresholds.s != null && argThresholds.ss == null) {
      th.ss = argThresholds.s - 1;
    }
  }
  locale2 = this.localeData();
  output = relativeTime$1(this, !withSuffix, th, locale2);
  if (withSuffix) {
    output = locale2.pastFuture(+this, output);
  }
  return locale2.postformat(output);
}
var abs$1 = Math.abs;
function sign(x7) {
  return (x7 > 0) - (x7 < 0) || +x7;
}
function toISOString$1() {
  if (!this.isValid()) {
    return this.localeData().invalidDate();
  }
  var seconds2 = abs$1(this._milliseconds) / 1e3, days2 = abs$1(this._days), months2 = abs$1(this._months), minutes2, hours2, years2, s20, total = this.asSeconds(), totalSign, ymSign, daysSign, hmsSign;
  if (!total) {
    return "P0D";
  }
  minutes2 = absFloor(seconds2 / 60);
  hours2 = absFloor(minutes2 / 60);
  seconds2 %= 60;
  minutes2 %= 60;
  years2 = absFloor(months2 / 12);
  months2 %= 12;
  s20 = seconds2 ? seconds2.toFixed(3).replace(/\.?0+$/, "") : "";
  totalSign = total < 0 ? "-" : "";
  ymSign = sign(this._months) !== sign(total) ? "-" : "";
  daysSign = sign(this._days) !== sign(total) ? "-" : "";
  hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
  return totalSign + "P" + (years2 ? ymSign + years2 + "Y" : "") + (months2 ? ymSign + months2 + "M" : "") + (days2 ? daysSign + days2 + "D" : "") + (hours2 || minutes2 || seconds2 ? "T" : "") + (hours2 ? hmsSign + hours2 + "H" : "") + (minutes2 ? hmsSign + minutes2 + "M" : "") + (seconds2 ? hmsSign + s20 + "S" : "");
}
var proto$2 = Duration.prototype;
proto$2.isValid = isValid$1;
proto$2.abs = abs;
proto$2.add = add$1;
proto$2.subtract = subtract$1;
proto$2.as = as;
proto$2.asMilliseconds = asMilliseconds;
proto$2.asSeconds = asSeconds;
proto$2.asMinutes = asMinutes;
proto$2.asHours = asHours;
proto$2.asDays = asDays;
proto$2.asWeeks = asWeeks;
proto$2.asMonths = asMonths;
proto$2.asQuarters = asQuarters;
proto$2.asYears = asYears;
proto$2.valueOf = valueOf$1;
proto$2._bubble = bubble;
proto$2.clone = clone$1;
proto$2.get = get$2;
proto$2.milliseconds = milliseconds;
proto$2.seconds = seconds;
proto$2.minutes = minutes;
proto$2.hours = hours;
proto$2.days = days;
proto$2.weeks = weeks;
proto$2.months = months;
proto$2.years = years;
proto$2.humanize = humanize;
proto$2.toISOString = toISOString$1;
proto$2.toString = toISOString$1;
proto$2.toJSON = toISOString$1;
proto$2.locale = locale;
proto$2.localeData = localeData;
proto$2.toIsoString = deprecate(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  toISOString$1
);
proto$2.lang = lang;
addFormatToken("X", 0, 0, "unix");
addFormatToken("x", 0, 0, "valueOf");
addRegexToken("x", matchSigned);
addRegexToken("X", matchTimestamp);
addParseToken("X", function(input, array2, config2) {
  config2._d = new Date(parseFloat(input) * 1e3);
});
addParseToken("x", function(input, array2, config2) {
  config2._d = new Date(toInt(input));
});
hooks.version = "2.29.4";
setHookCallback(createLocal);
hooks.fn = proto;
hooks.min = min3;
hooks.max = max3;
hooks.now = now2;
hooks.utc = createUTC;
hooks.unix = createUnix;
hooks.months = listMonths;
hooks.isDate = isDate2;
hooks.locale = getSetGlobalLocale;
hooks.invalid = createInvalid;
hooks.duration = createDuration;
hooks.isMoment = isMoment;
hooks.weekdays = listWeekdays;
hooks.parseZone = createInZone;
hooks.localeData = getLocale;
hooks.isDuration = isDuration;
hooks.monthsShort = listMonthsShort;
hooks.weekdaysMin = listWeekdaysMin;
hooks.defineLocale = defineLocale;
hooks.updateLocale = updateLocale;
hooks.locales = listLocales;
hooks.weekdaysShort = listWeekdaysShort;
hooks.normalizeUnits = normalizeUnits;
hooks.relativeTimeRounding = getSetRelativeTimeRounding;
hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
hooks.calendarFormat = getCalendarFormat;
hooks.prototype = proto;
hooks.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
var moment_default = hooks;

// node_modules/react-onclickoutside/dist/react-onclickoutside.es.js
var import_react116 = __toESM(require_react());
var import_react_dom8 = __toESM(require_react_dom());
function _inheritsLoose2(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf2(subClass, superClass);
}
function _setPrototypeOf2(o16, p12) {
  _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o17, p13) {
    o17.__proto__ = p13;
    return o17;
  };
  return _setPrototypeOf2(o16, p12);
}
function _objectWithoutPropertiesLoose5(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i15;
  for (i15 = 0; i15 < sourceKeys.length; i15++) {
    key = sourceKeys[i15];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function isNodeFound(current, componentNode, ignoreClass) {
  if (current === componentNode) {
    return true;
  }
  if (current.correspondingElement) {
    return current.correspondingElement.classList.contains(ignoreClass);
  }
  return current.classList.contains(ignoreClass);
}
function findHighest(current, componentNode, ignoreClass) {
  if (current === componentNode) {
    return true;
  }
  while (current.parentNode || current.host) {
    if (current.parentNode && isNodeFound(current, componentNode, ignoreClass)) {
      return true;
    }
    current = current.parentNode || current.host;
  }
  return current;
}
function clickedScrollbar(evt) {
  return document.documentElement.clientWidth <= evt.clientX || document.documentElement.clientHeight <= evt.clientY;
}
var testPassiveEventSupport = function testPassiveEventSupport2() {
  if (typeof window === "undefined" || typeof window.addEventListener !== "function") {
    return;
  }
  var passive = false;
  var options = Object.defineProperty({}, "passive", {
    get: function get8() {
      passive = true;
    }
  });
  var noop6 = function noop7() {
  };
  window.addEventListener("testPassiveEventSupport", noop6, options);
  window.removeEventListener("testPassiveEventSupport", noop6, options);
  return passive;
};
function autoInc(seed) {
  if (seed === void 0) {
    seed = 0;
  }
  return function() {
    return ++seed;
  };
}
var uid = autoInc();
var passiveEventSupport;
var handlersMap = {};
var enabledInstances = {};
var touchEvents = ["touchstart", "touchmove"];
var IGNORE_CLASS_NAME = "ignore-react-onclickoutside";
function getEventHandlerOptions(instance, eventName) {
  var handlerOptions = {};
  var isTouchEvent3 = touchEvents.indexOf(eventName) !== -1;
  if (isTouchEvent3 && passiveEventSupport) {
    handlerOptions.passive = !instance.props.preventDefault;
  }
  return handlerOptions;
}
function onClickOutsideHOC(WrappedComponent, config2) {
  var _class, _temp;
  var componentName = WrappedComponent.displayName || WrappedComponent.name || "Component";
  return _temp = _class = function(_Component) {
    _inheritsLoose2(onClickOutside, _Component);
    function onClickOutside(props) {
      var _this;
      _this = _Component.call(this, props) || this;
      _this.__outsideClickHandler = function(event) {
        if (typeof _this.__clickOutsideHandlerProp === "function") {
          _this.__clickOutsideHandlerProp(event);
          return;
        }
        var instance = _this.getInstance();
        if (typeof instance.props.handleClickOutside === "function") {
          instance.props.handleClickOutside(event);
          return;
        }
        if (typeof instance.handleClickOutside === "function") {
          instance.handleClickOutside(event);
          return;
        }
        throw new Error("WrappedComponent: " + componentName + " lacks a handleClickOutside(event) function for processing outside click events.");
      };
      _this.__getComponentNode = function() {
        var instance = _this.getInstance();
        if (config2 && typeof config2.setClickOutsideRef === "function") {
          return config2.setClickOutsideRef()(instance);
        }
        if (typeof instance.setClickOutsideRef === "function") {
          return instance.setClickOutsideRef();
        }
        return (0, import_react_dom8.findDOMNode)(instance);
      };
      _this.enableOnClickOutside = function() {
        if (typeof document === "undefined" || enabledInstances[_this._uid]) {
          return;
        }
        if (typeof passiveEventSupport === "undefined") {
          passiveEventSupport = testPassiveEventSupport();
        }
        enabledInstances[_this._uid] = true;
        var events = _this.props.eventTypes;
        if (!events.forEach) {
          events = [events];
        }
        handlersMap[_this._uid] = function(event) {
          if (_this.componentNode === null)
            return;
          if (_this.props.preventDefault) {
            event.preventDefault();
          }
          if (_this.props.stopPropagation) {
            event.stopPropagation();
          }
          if (_this.props.excludeScrollbar && clickedScrollbar(event))
            return;
          var current = event.composed && event.composedPath && event.composedPath().shift() || event.target;
          if (findHighest(current, _this.componentNode, _this.props.outsideClickIgnoreClass) !== document) {
            return;
          }
          _this.__outsideClickHandler(event);
        };
        events.forEach(function(eventName) {
          document.addEventListener(eventName, handlersMap[_this._uid], getEventHandlerOptions(_assertThisInitialized(_this), eventName));
        });
      };
      _this.disableOnClickOutside = function() {
        delete enabledInstances[_this._uid];
        var fn2 = handlersMap[_this._uid];
        if (fn2 && typeof document !== "undefined") {
          var events = _this.props.eventTypes;
          if (!events.forEach) {
            events = [events];
          }
          events.forEach(function(eventName) {
            return document.removeEventListener(eventName, fn2, getEventHandlerOptions(_assertThisInitialized(_this), eventName));
          });
          delete handlersMap[_this._uid];
        }
      };
      _this.getRef = function(ref2) {
        return _this.instanceRef = ref2;
      };
      _this._uid = uid();
      return _this;
    }
    var _proto = onClickOutside.prototype;
    _proto.getInstance = function getInstance() {
      if (WrappedComponent.prototype && !WrappedComponent.prototype.isReactComponent) {
        return this;
      }
      var ref2 = this.instanceRef;
      return ref2.getInstance ? ref2.getInstance() : ref2;
    };
    _proto.componentDidMount = function componentDidMount() {
      if (typeof document === "undefined" || !document.createElement) {
        return;
      }
      var instance = this.getInstance();
      if (config2 && typeof config2.handleClickOutside === "function") {
        this.__clickOutsideHandlerProp = config2.handleClickOutside(instance);
        if (typeof this.__clickOutsideHandlerProp !== "function") {
          throw new Error("WrappedComponent: " + componentName + " lacks a function for processing outside click events specified by the handleClickOutside config option.");
        }
      }
      this.componentNode = this.__getComponentNode();
      if (this.props.disableOnClickOutside)
        return;
      this.enableOnClickOutside();
    };
    _proto.componentDidUpdate = function componentDidUpdate() {
      this.componentNode = this.__getComponentNode();
    };
    _proto.componentWillUnmount = function componentWillUnmount() {
      this.disableOnClickOutside();
    };
    _proto.render = function render3() {
      var _this$props = this.props;
      _this$props.excludeScrollbar;
      var props = _objectWithoutPropertiesLoose5(_this$props, ["excludeScrollbar"]);
      if (WrappedComponent.prototype && WrappedComponent.prototype.isReactComponent) {
        props.ref = this.getRef;
      } else {
        props.wrappedRef = this.getRef;
      }
      props.disableOnClickOutside = this.disableOnClickOutside;
      props.enableOnClickOutside = this.enableOnClickOutside;
      return (0, import_react116.createElement)(WrappedComponent, props);
    };
    return onClickOutside;
  }(import_react116.Component), _class.displayName = "OnClickOutside(" + componentName + ")", _class.defaultProps = {
    eventTypes: ["mousedown", "touchstart"],
    excludeScrollbar: config2 && config2.excludeScrollbar || false,
    outsideClickIgnoreClass: IGNORE_CLASS_NAME,
    preventDefault: false,
    stopPropagation: false
  }, _class.getClass = function() {
    return WrappedComponent.getClass ? WrappedComponent.getClass() : WrappedComponent;
  }, _temp;
}
var react_onclickoutside_es_default = onClickOutsideHOC;

// node_modules/@react-hook/debounce/dist/module/index.js
var React66 = __toESM(require_react());

// node_modules/@react-hook/latest/dist/module/index.js
var React65 = __toESM(require_react());
var useLatest4 = (current) => {
  const storedValue = React65.useRef(current);
  React65.useEffect(() => {
    storedValue.current = current;
  });
  return storedValue;
};
var module_default = useLatest4;

// node_modules/@react-hook/debounce/dist/module/index.js
var useDebounceCallback = (callback, wait = 100, leading = false) => {
  const storedCallback = module_default(callback);
  const timeout = React66.useRef();
  const deps = [wait, leading, storedCallback];
  function _ref() {
    timeout.current && clearTimeout(timeout.current);
    timeout.current = void 0;
  }
  React66.useEffect(() => _ref, deps);
  function _ref2() {
    timeout.current = void 0;
  }
  return React66.useCallback(function() {
    const args = arguments;
    const {
      current
    } = timeout;
    if (current === void 0 && leading) {
      timeout.current = setTimeout(_ref2, wait);
      return storedCallback.current.apply(null, args);
    }
    current && clearTimeout(current);
    timeout.current = setTimeout(() => {
      timeout.current = void 0;
      storedCallback.current.apply(null, args);
    }, wait);
  }, deps);
};
var useDebounce = (initialState2, wait, leading) => {
  const state = React66.useState(initialState2);
  return [state[0], useDebounceCallback(state[1], wait, leading)];
};

// node_modules/@react-hook/event/dist/module/index.js
var React67 = __toESM(require_react());
function useEvent(target, type, listener, cleanup) {
  const storedListener = React67.useRef(listener);
  const storedCleanup = React67.useRef(cleanup);
  React67.useEffect(() => {
    storedListener.current = listener;
    storedCleanup.current = cleanup;
  });
  React67.useEffect(() => {
    const targetEl = target && "current" in target ? target.current : target;
    if (!targetEl)
      return;
    let didUnsubscribe = 0;
    function listener2(...args) {
      if (didUnsubscribe)
        return;
      storedListener.current.apply(this, args);
    }
    targetEl.addEventListener(type, listener2);
    const cleanup2 = storedCleanup.current;
    return () => {
      didUnsubscribe = 1;
      targetEl.removeEventListener(type, listener2);
      cleanup2 && cleanup2();
    };
  }, [target, type]);
}
var module_default2 = useEvent;

// node_modules/@react-hook/window-size/dist/module/index.js
var emptyObj = {};
var win = typeof window === "undefined" ? null : window;
var wv = win && typeof win.visualViewport !== "undefined" ? win.visualViewport : null;
var getSize3 = () => [document.documentElement.clientWidth, document.documentElement.clientHeight];
var useWindowSize = function(options) {
  if (options === void 0) {
    options = emptyObj;
  }
  const {
    wait,
    leading,
    initialWidth = 0,
    initialHeight = 0
  } = options;
  const [size2, setDebouncedSize] = useDebounce(
    /* istanbul ignore next */
    typeof document === "undefined" ? [initialWidth, initialHeight] : getSize3,
    wait,
    leading
  );
  const setSize = () => setDebouncedSize(getSize3);
  module_default2(win, "resize", setSize);
  module_default2(wv, "resize", setSize);
  module_default2(win, "orientationchange", setSize);
  return size2;
};
var useWindowWidth = (options) => useWindowSize(options)[0];

// node_modules/@tinacms/toolkit/dist/index.es.js
var __defProp2 = Object.defineProperty;
var __defNormalProp2 = (obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var ModalProvider = ({ children }) => {
  const [modalRootContainerRef, setModalRootContainerRef] = (0, import_react117.useState)(null);
  const setModalRef = (0, import_react117.useCallback)((node) => {
    if (node !== null) {
      setModalRootContainerRef(node);
    }
  }, []);
  return React68.createElement(React68.Fragment, null, React68.createElement("div", {
    id: "modal-root",
    className: "tina-tailwind",
    ref: setModalRef
  }), React68.createElement(ModalContainerContext.Provider, {
    value: { portalNode: modalRootContainerRef }
  }, children));
};
var ModalContainerContext = React68.createContext(null);
function useModalContainer() {
  const modalContainer = React68.useContext(ModalContainerContext);
  if (!modalContainer) {
    throw new Error("No Modal Container context provided");
  }
  return modalContainer;
}
var ModalOverlay = ({ children }) => {
  return React68.createElement("div", {
    className: "fixed inset-0 z-modal w-screen h-screen overflow-y-auto"
  }, children, React68.createElement("div", {
    className: "fixed -z-1 inset-0 opacity-80 bg-gradient-to-br from-gray-800 via-gray-900 to-black"
  }));
};
var Modal = (props) => {
  const { portalNode } = useModalContainer();
  if (!portalNode)
    return null;
  return (0, import_react_dom9.createPortal)(React68.createElement(ModalOverlay, null, React68.createElement("div", {
    ...props
  })), portalNode);
};
var ModalActions = ({ children }) => {
  return React68.createElement("div", {
    className: "w-full flex justify-between gap-4 items-center px-5 pb-5 rounded-b-md"
  }, children);
};
var ModalBody = ({ className = "", padded = false, ...props }) => import_react117.default.createElement("div", {
  className: `${padded ? "p-5" : "p-0"} m-0 overflow-hidden flex flex-col min-h-[160px] [&:last-child]:rounded-[0_0_5px_5px] ${className}`,
  ...props
});
var AddIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M14.9524 4.89689L14.9524 26.8016H16.7461L16.7461 4.89689H14.9524Z"
}), React68.createElement("path", {
  d: "M4.8969 16.7461H26.8016L26.8016 14.9523H4.89689L4.8969 16.7461Z"
}));
var AlignCenter = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M9.125 24H22.875V26H9.125V24ZM5 18H27V20H5V18ZM5 6H27V8H5V6ZM9.125 12H22.875V14H9.125V12Z",
  fill: "inherit"
}));
var AlignLeft = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M5 24H20.125V26H5V24ZM5 18H27V20H5V18ZM5 6H27V8H5V6ZM5 12H20.125V14H5V12Z",
  fill: "inherit"
}));
var AlignRight = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M11.875 24H27V26H11.875V24ZM5 18H27V20H5V18ZM5 6H27V8H5V6ZM11.875 12H27V14H11.875V12Z",
  fill: "inherit"
}));
var CloseIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M5 6.2684L24.7316 26L26 24.7316L6.2684 5L5 6.2684Z"
}), React68.createElement("path", {
  d: "M6.2684 26L26 6.2684L24.7316 5L5 24.7316L6.2684 26Z"
}));
var EllipsisVerticalIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 4 14",
  fill: "#828282",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M2 5.5C1.5625 5.5 1.21875 5.65625 0.9375 5.9375C0.625 6.25 0.5 6.59375 0.5 7C0.5 7.4375 0.625 7.78125 0.9375 8.0625C1.21875 8.375 1.5625 8.5 2 8.5C2.40625 8.5 2.75 8.375 3.0625 8.0625C3.34375 7.78125 3.5 7.4375 3.5 7C3.5 6.59375 3.34375 6.25 3.0625 5.9375C2.75 5.65625 2.40625 5.5 2 5.5ZM0.5 2.25C0.5 1.84375 0.625 1.5 0.9375 1.1875C1.21875 0.90625 1.5625 0.75 2 0.75C2.40625 0.75 2.75 0.90625 3.0625 1.1875C3.34375 1.5 3.5 1.84375 3.5 2.25C3.5 2.6875 3.34375 3.03125 3.0625 3.3125C2.75 3.625 2.40625 3.75 2 3.75C1.5625 3.75 1.21875 3.625 0.9375 3.3125C0.625 3.03125 0.5 2.6875 0.5 2.25ZM0.5 11.75C0.5 11.3438 0.625 11 0.9375 10.6875C1.21875 10.4062 1.5625 10.25 2 10.25C2.40625 10.25 2.75 10.4062 3.0625 10.6875C3.34375 11 3.5 11.3438 3.5 11.75C3.5 12.1875 3.34375 12.5312 3.0625 12.8125C2.75 13.125 2.40625 13.25 2 13.25C1.5625 13.25 1.21875 13.125 0.9375 12.8125C0.625 12.5312 0.5 12.1875 0.5 11.75Z"
}));
var HamburgerIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M4 10H28V8H4V10Z"
}), React68.createElement("path", {
  d: "M4 17H28V15H4V17Z"
}), React68.createElement("path", {
  d: "M4 24H28V22H4V24Z"
}));
var EditIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M24.3324 8.96875C24.754 9.42578 25 9.95312 25 10.5859C25 11.2188 24.754 11.7461 24.3324 12.168L11.9634 24.543L7.85212 25C7.57101 25 7.36018 24.9297 7.21962 24.7188C7.04392 24.543 6.97365 24.332 7.00878 24.0508L7.46559 20.043L19.8346 7.66797C20.2562 7.24609 20.7833 7 21.4158 7C22.0483 7 22.5754 7.24609 23.0322 7.66797L24.3324 8.96875ZM11.1903 22.9258L20.3968 13.7148L18.2884 11.6055L9.08199 20.8164L8.80088 23.207L11.1903 22.9258ZM23.1376 10.9727C23.243 10.8672 23.3133 10.7266 23.3133 10.5859C23.3133 10.4453 23.243 10.3047 23.1376 10.1641L21.8375 8.86328C21.6969 8.75781 21.5564 8.6875 21.4158 8.6875C21.2753 8.6875 21.1347 8.75781 21.0293 8.86328L19.4832 10.4102L21.5915 12.5195L23.1376 10.9727Z"
}));
var ChevronDownIcon$2 = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M6.708 10.5L5.5 11.7654L14.2939 20.9773C14.9597 21.6747 16.0412 21.6737 16.7061 20.9773L25.5 11.7654L24.292 10.5L15.5 19.7098L6.708 10.5Z"
}));
var ChevronUpIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M25.292 21.5L26.5 20.2346L17.7061 11.0227C17.0403 10.3253 15.9588 10.3263 15.2939 11.0227L6.5 20.2346L7.708 21.5L16.5 12.2901L25.292 21.5Z"
}));
var ChevronLeftIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M21 7.208L19.7346 6L10.5227 14.7939C9.82527 15.4597 9.82626 16.5412 10.5227 17.2061L19.7346 26L21 24.792L11.7901 16L21 7.208Z"
}));
var ChevronRightIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M11 24.792L12.2654 26L21.4773 17.2061C22.1747 16.5403 22.1737 15.4588 21.4773 14.7939L12.2654 6L11 7.208L20.2099 16L11 24.792Z"
}));
var DuplicateIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M24.95,25.85H13.01c-0.5,0-0.9-0.4-0.9-0.9V13.01c0-0.5,0.4-0.9,0.9-0.9h11.94c0.5,0,0.9,0.4,0.9,0.9v11.94\n      C25.85,25.45,25.45,25.85,24.95,25.85z M13.91,24.05h10.14V13.91H13.91V24.05z"
}), React68.createElement("path", {
  d: "M9.93,19.89H7.05c-0.5,0-0.9-0.4-0.9-0.9V7.05c0-0.5,0.4-0.9,0.9-0.9h11.94c0.5,0,0.9,0.4,0.9,0.9v2.89h-1.8V7.95H7.95\n      v10.14h1.99V19.89z"
}));
var DragIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M15 22C15 23.1 14.1 24 13 24C11.9 24 11 23.1 11 22C11 20.9 11.9 20 13 20C14.1 20 15 20.9 15 22ZM13 14C11.9 14 11 14.9 11 16C11 17.1 11.9 18 13 18C14.1 18 15 17.1 15 16C15 14.9 14.1 14 13 14ZM13 8C11.9 8 11 8.9 11 10C11 11.1 11.9 12 13 12C14.1 12 15 11.1 15 10C15 8.9 14.1 8 13 8ZM19 12C20.1 12 21 11.1 21 10C21 8.9 20.1 8 19 8C17.9 8 17 8.9 17 10C17 11.1 17.9 12 19 12ZM19 14C17.9 14 17 14.9 17 16C17 17.1 17.9 18 19 18C20.1 18 21 17.1 21 16C21 14.9 20.1 14 19 14ZM19 20C17.9 20 17 20.9 17 22C17 23.1 17.9 24 19 24C20.1 24 21 23.1 21 22C21 20.9 20.1 20 19 20Z"
}));
var LeftArrowIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M21 7.208L19.7346 6L10.5227 14.7939C9.82527 15.4597 9.82626 16.5412 10.5227 17.2061L19.7346 26L21 24.792L11.7901 16L21 7.208Z"
}));
var RightArrowIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M11 24.792L12.2654 26L21.4773 17.2061C22.1747 16.5403 22.1737 15.4588 21.4773 14.7939L12.2654 6L11 7.20799L20.2099 16L11 24.792Z"
}));
var BoldIcon$1 = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M20.8 14.3867C22.0933 13.4933 23 12.0267 23 10.6667C23 7.65334 20.6667 5.33334 17.6667 5.33334H9.33333V24H18.72C21.5067 24 23.6667 21.7333 23.6667 18.9467C23.6667 16.92 22.52 15.1867 20.8 14.3867V14.3867ZM13.3333 8.66667H17.3333C18.44 8.66667 19.3333 9.56 19.3333 10.6667C19.3333 11.7733 18.44 12.6667 17.3333 12.6667H13.3333V8.66667ZM18 20.6667H13.3333V16.6667H18C19.1067 16.6667 20 17.56 20 18.6667C20 19.7733 19.1067 20.6667 18 20.6667Z"
}));
var CodeIcon$1 = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M12.5333 22.1333L6.40001 16L12.5333 9.86667L10.6667 8L2.66667 16L10.6667 24L12.5333 22.1333ZM19.4667 22.1333L25.6 16L19.4667 9.86667L21.3333 8L29.3333 16L21.3333 24L19.4667 22.1333V22.1333Z"
}));
var ExitIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M15.5 23.0129L8.88889 23.0129L8.88889 9.10324L15.5 9.10324L15.5 7.11615L8.88889 7.11615C7.85 7.11615 7 8.01034 7 9.10324L7 23.0129C7 24.1058 7.85 25 8.88889 25L15.5 25L15.5 23.0129Z"
}), React68.createElement("path", {
  d: "M18.6961 12.4912L21.1328 15.0645L12 15.0645L12 17.0516L21.1328 17.0516L18.6961 19.6249L20.0278 21.0258L24.75 16.0581L20.0278 11.0903L18.6961 12.4912Z"
}));
var HeadingIcon$1 = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M12 5.33334V9.33334H18.6667V25.3333H22.6667V9.33334H29.3333V5.33334H12ZM4 16H8V25.3333H12V16H16V12H4V16Z"
}));
var ItalicIcon$1 = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M13.3333 5.33334V9.33334H16.28L11.72 20H8V24H18.6667V20H15.72L20.28 9.33334H24V5.33334H13.3333Z"
}));
var MediaIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "currentColor",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M26 20V8C26 6.9 25.1 6 24 6H12C10.9 6 10 6.9 10 8V20C10 21.1 10.9 22 12 22H24C25.1 22 26 21.1 26 20ZM15 16L17.03 18.71L20 15L24 20H12L15 16ZM6 10V24C6 25.1 6.9 26 8 26H22V24H8V10H6Z"
}));
var OrderedListIcon$1 = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M2.66667 22.6667H5.33333V23.3333H4V24.6667H5.33333V25.3333H2.66667V26.6667H6.66667V21.3333H2.66667V22.6667ZM4 10.6667H5.33333V5.33334H2.66667V6.66667H4V10.6667ZM2.66667 14.6667H5.06667L2.66667 17.4667V18.6667H6.66667V17.3333H4.26667L6.66667 14.5333V13.3333H2.66667V14.6667ZM9.33333 6.66667V9.33334H28V6.66667H9.33333ZM9.33333 25.3333H28V22.6667H9.33333V25.3333ZM9.33333 17.3333H28V14.6667H9.33333V17.3333Z"
}));
var SettingsIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "currentColor",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M24.7021 13.8628L24.0959 12.4533C24.0959 12.4533 25.5063 9.34049 25.3804 9.22033L23.5152 7.43748C23.3853 7.3142 20.2046 8.73502 20.2046 8.73502L18.7364 8.1553C18.7364 8.1553 17.4403 5 17.2622 5H14.629C14.4469 5 13.2457 8.16271 13.2457 8.16271L11.7807 8.74321C11.7807 8.74321 8.53338 7.393 8.40784 7.51277L6.54507 9.29875C6.41594 9.42125 7.89851 12.4724 7.89851 12.4724L7.29273 13.8788C7.29273 13.8788 4 15.1209 4 15.2883V17.8143C4 17.9903 7.3003 19.1415 7.3003 19.1415L7.90608 20.5467C7.90608 20.5467 6.49724 23.6572 6.62079 23.7765L8.48595 25.5641C8.61189 25.6854 11.795 24.265 11.795 24.265L13.264 24.847C13.264 24.847 14.5601 28 14.739 28H17.373C17.5551 28 18.7555 24.8373 18.7555 24.8373L20.2257 24.2552C20.2257 24.2552 23.467 25.607 23.5922 25.4888L25.4581 23.7028C25.5872 23.5788 24.1015 20.5292 24.1015 20.5292L24.7057 19.1228C24.7057 19.1228 28 17.8791 28 17.7094V15.1841C28.0008 15.0105 24.7021 13.8628 24.7021 13.8628ZM19.8479 16.4984C19.8479 18.5306 18.1222 20.1855 16.0012 20.1855C13.8818 20.1855 12.1537 18.5306 12.1537 16.4984C12.1537 14.4679 13.8818 12.8161 16.0012 12.8161C18.123 12.8169 19.8479 14.4679 19.8479 16.4984Z"
}));
var TableIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 24 24",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M4 21h15.893c1.103 0 2-.897 2-2V5c0-1.103-.897-2-2-2H4c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2zm0-2v-5h4v5H4zM14 7v5h-4V7h4zM8 7v5H4V7h4zm2 12v-5h4v5h-4zm6 0v-5h3.894v5H16zm3.893-7H16V7h3.893v5z"
}));
var TinaIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "currentColor",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M18.6466 14.5553C19.9018 13.5141 20.458 7.36086 21.0014 5.14903C21.5447 2.9372 23.7919 3.04938 23.7919 3.04938C23.7919 3.04938 23.2085 4.06764 23.4464 4.82751C23.6844 5.58738 25.3145 6.26662 25.3145 6.26662L24.9629 7.19622C24.9629 7.19622 24.2288 7.10204 23.7919 7.9785C23.355 8.85496 24.3392 17.4442 24.3392 17.4442C24.3392 17.4442 21.4469 22.7275 21.4469 24.9206C21.4469 27.1136 22.4819 28.9515 22.4819 28.9515H21.0296C21.0296 28.9515 18.899 26.4086 18.462 25.1378C18.0251 23.8669 18.1998 22.596 18.1998 22.596C18.1998 22.596 15.8839 22.4646 13.8303 22.596C11.7767 22.7275 10.4072 24.498 10.16 25.4884C9.91287 26.4787 9.81048 28.9515 9.81048 28.9515H8.66211C7.96315 26.7882 7.40803 26.0129 7.70918 24.9206C8.54334 21.8949 8.37949 20.1788 8.18635 19.4145C7.99321 18.6501 6.68552 17.983 6.68552 17.983C7.32609 16.6741 7.97996 16.0452 10.7926 15.9796C13.6052 15.914 17.3915 15.5965 18.6466 14.5553Z"
}), React68.createElement("path", {
  d: "M11.1268 24.7939C11.1268 24.7939 11.4236 27.5481 13.0001 28.9516H14.3511C13.0001 27.4166 12.8527 23.4155 12.8527 23.4155C12.1656 23.6399 11.3045 24.3846 11.1268 24.7939Z"
}));
var TrashIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M16.9 4.2V6.9H25V8.7H7V6.9H15.1V4.2H16.9ZM7.77201 10.5H24.2279L22.4102 24.1332C22.2853 25.0698 21.4406 25.8 20.4977 25.8H11.5022C10.5561 25.8 9.71404 25.0653 9.58977 24.1332L7.77201 10.5ZM22.172 12.3H9.82791L11.3739 23.8953C11.3788 23.9318 11.4569 24 11.5022 24H20.4977C20.5432 24 20.6209 23.9328 20.6259 23.8953L22.172 12.3Z"
}));
var UnorderedListIcon$1 = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M5.33333 14C4.22667 14 3.33333 14.8933 3.33333 16C3.33333 17.1067 4.22667 18 5.33333 18C6.44 18 7.33333 17.1067 7.33333 16C7.33333 14.8933 6.44 14 5.33333 14ZM5.33333 6C4.22667 6 3.33333 6.89333 3.33333 8C3.33333 9.10667 4.22667 10 5.33333 10C6.44 10 7.33333 9.10667 7.33333 8C7.33333 6.89333 6.44 6 5.33333 6ZM5.33333 22C4.22667 22 3.33333 22.9067 3.33333 24C3.33333 25.0933 4.24 26 5.33333 26C6.42667 26 7.33333 25.0933 7.33333 24C7.33333 22.9067 6.44 22 5.33333 22ZM9.33333 25.3333H28V22.6667H9.33333V25.3333ZM9.33333 17.3333H28V14.6667H9.33333V17.3333ZM9.33333 6.66667V9.33333H28V6.66667H9.33333Z"
}));
var UndoIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M16.6667 10.6667C13.1333 10.6667 9.93333 11.9867 7.46667 14.1333L2.66667 9.33334V21.3333H14.6667L9.84 16.5067C11.6933 14.96 14.0533 14 16.6667 14C21.3867 14 25.4 17.08 26.8 21.3333L29.96 20.2933C28.1067 14.7067 22.8667 10.6667 16.6667 10.6667Z"
}));
var RedoIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M24.5333 14.1333C22.0667 11.9867 18.8667 10.6667 15.3333 10.6667C9.13333 10.6667 3.89333 14.7067 2.05333 20.2933L5.2 21.3333C6.6 17.08 10.6 14 15.3333 14C17.9333 14 20.3067 14.96 22.16 16.5067L17.3333 21.3333H29.3333V9.33334L24.5333 14.1333Z"
}));
var ReorderIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M15.3012 6.23952L11.0607 10.4801L10 9.41943L14.2406 5.17886C14.9213 4.49816 16.0233 4.48258 16.7196 5.17886L20.9602 9.41943L19.8995 10.4801L15.6589 6.23952C15.5561 6.13671 15.4039 6.13689 15.3012 6.23952Z"
}), React68.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M15.6988 25.8732L19.9393 21.6326L21 22.6933L16.7594 26.9339C16.0787 27.6146 14.9767 27.6301 14.2804 26.9339L10.0398 22.6933L11.1005 21.6326L15.3411 25.8732C15.4439 25.976 15.5961 25.9758 15.6988 25.8732Z"
}), React68.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M14.6569 27.1127V17.799L16.1569 17.799V27.1127L14.6569 27.1127Z"
}), React68.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M14.6569 14.3137V5L16.1569 5V14.3137L14.6569 14.3137Z"
}));
var ReorderRowIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M25.7605 15.3012L21.5199 11.0607L22.5806 10L26.8211 14.2406C27.5018 14.9213 27.5174 16.0233 26.8211 16.7196L22.5806 20.9602L21.5199 19.8995L25.7605 15.6589C25.8633 15.5561 25.8631 15.4039 25.7605 15.3012Z"
}), React68.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M6.12679 15.6988L10.3674 19.9393L9.3067 21L5.06613 16.7594C4.38543 16.0787 4.36985 14.9767 5.06613 14.2804L9.3067 10.0398L10.3674 11.1005L6.12679 15.3411C6.02398 15.4439 6.02416 15.5961 6.12679 15.6988Z"
}), React68.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M4.88727 14.6569L14.201 14.6569L14.201 16.1569L4.88727 16.1569L4.88727 14.6569Z"
}), React68.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M17.6863 14.6569L27 14.6569L27 16.1569L17.6863 16.1569L17.6863 14.6569Z"
}));
var UploadIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "currentColor",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M17.3 25.1V19.9H21.2L16 13.4L10.8 19.9H14.7V25.1H17.3Z"
}), React68.createElement("path", {
  d: "M9.5 25.1H12.1V22.5H9.5C7.3498 22.5 5.6 20.7502 5.6 18.6C5.6 16.7748 7.1587 15.0172 9.0749 14.6805L9.8302 14.5479L10.0798 13.8225C10.9937 11.1562 13.2635 9.49996 16 9.49996C19.5841 9.49996 22.5 12.4159 22.5 16V17.3H23.8C25.2339 17.3 26.4 18.4661 26.4 19.9C26.4 21.3339 25.2339 22.5 23.8 22.5H19.9V25.1H23.8C26.6678 25.1 29 22.7678 29 19.9C28.998 18.7347 28.6056 17.6036 27.8855 16.6874C27.1654 15.7713 26.1591 15.1228 25.0272 14.8456C24.4591 10.371 20.628 6.89996 16 6.89996C12.4172 6.89996 9.305 8.99426 7.8841 12.295C5.0917 13.1296 3 15.766 3 18.6C3 22.1841 5.9159 25.1 9.5 25.1Z"
}));
var ResetIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M12.625 13.3846H19.375C21.2358 13.3846 22.75 14.8342 22.75 16.6154C22.75 18.3966 21.2358 19.8462 19.375 19.8462H16V22H19.375C22.4766 22 25 19.5845 25 16.6154C25 13.6463 22.4766 11.2308 19.375 11.2308H12.625V8L7 12.3077L12.625 16.6154V13.3846Z",
  fill: "inherit"
}));
var LinkIcon$1 = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M5.2 16C5.2 13.72 7.05333 11.8667 9.33333 11.8667H14.6667V9.33334H9.33333C5.65333 9.33334 2.66666 12.32 2.66666 16C2.66666 19.68 5.65333 22.6667 9.33333 22.6667H14.6667V20.1333H9.33333C7.05333 20.1333 5.2 18.28 5.2 16ZM10.6667 17.3333H21.3333V14.6667H10.6667V17.3333ZM22.6667 9.33334H17.3333V11.8667H22.6667C24.9467 11.8667 26.8 13.72 26.8 16C26.8 18.28 24.9467 20.1333 22.6667 20.1333H17.3333V22.6667H22.6667C26.3467 22.6667 29.3333 19.68 29.3333 16C29.3333 12.32 26.3467 9.33334 22.6667 9.33334Z"
}));
var LockIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M25 16.5C25 15.3419 23.9909 14.4 22.75 14.4H21.625V10.25C21.625 7.35515 19.1016 5 16 5C12.8984 5 10.375 7.35515 10.375 10.25V14.4H9.25C8.00912 14.4 7 15.3419 7 16.5V23.9C7 25.0581 8.00912 26 9.25 26H22.75C23.9909 26 25 25.0581 25 23.9V16.5ZM12.625 10.25C12.625 8.5133 14.1392 7.1 16 7.1C17.8608 7.1 19.375 8.5133 19.375 10.25V14.4H12.625V10.25Z",
  fill: "inherit"
}));
var QuoteIcon$1 = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M8.00001 22.6667H12L14.6667 17.3333V9.33334H6.66667V17.3333H10.6667L8.00001 22.6667ZM18.6667 22.6667H22.6667L25.3333 17.3333V9.33334H17.3333V17.3333H21.3333L18.6667 22.6667Z"
}));
var UnderlineIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M16 22.6667C20.4133 22.6667 24 19.08 24 14.6667V4H20.6667V14.6667C20.6667 17.24 18.5733 19.3333 16 19.3333C13.4267 19.3333 11.3333 17.24 11.3333 14.6667V4H8.00001V14.6667C8.00001 19.08 11.5867 22.6667 16 22.6667ZM6.66667 25.3333V28H25.3333V25.3333H6.66667Z"
}));
var StrikethroughIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M16.578 26a14.1 14.1 0 01-4.535-.75A12.299 12.299 0 018 22.889l2.628-3.028a13.437 13.437 0 002.83 1.722c.982.426 2.051.64 3.206.64.924 0 1.637-.158 2.137-.473.52-.333.78-.787.78-1.361v-.056c0-.117-.01-.228-.03-.333H24c-.003.952-.186 1.804-.549 2.556a5.478 5.478 0 01-1.53 1.888c-.655.5-1.435.89-2.34 1.167-.905.26-1.906.389-3.003.389zm-3.993-9H29v-3H17.265a71.646 71.646 0 01-1.843-.5c-.558-.167-1-.343-1.328-.528-.327-.185-.558-.389-.693-.61a1.905 1.905 0 01-.174-.834v-.056c0-.481.212-.88.636-1.194.443-.334 1.097-.5 1.964-.5.866 0 1.733.176 2.599.528a14.16 14.16 0 012.657 1.388l2.31-3.222a11.94 11.94 0 00-3.436-1.833C18.724 6.213 17.367 6 15.884 6c-1.04 0-1.992.139-2.859.417-.866.277-1.617.676-2.252 1.194a5.537 5.537 0 00-1.444 1.861c-.347.704-.52 1.5-.52 2.39v.055c0 .804.107 1.498.322 2.083H4v3h8.585z"
}));
var MarkdownIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M28.0035 7H4.01374C2.91056 7 2 7.988 2 9.185V23.796C2 25.012 2.91056 26 4.01374 26H27.986C29.1067 26 29.9998 25.012 29.9998 23.815V9.185C30.0173 7.988 29.1067 7 28.0035 7ZM17.7597 22.2H14.2576V16.5L11.6309 20.148L9.00432 16.5V22.2H5.50216V10.8H9.00432L11.6309 14.6L14.2576 10.8H17.7597V22.2ZM22.9954 23.15L18.6352 16.5H21.2619V10.8H24.764V16.5H27.3906L22.9954 23.15Z"
}));
var AlertIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M16 29.3333C17.4666 29.3333 18.6666 28.1333 18.6666 26.6666H13.3333C13.3333 27.3739 13.6143 28.0522 14.1144 28.5523C14.6145 29.0524 15.2927 29.3333 16 29.3333ZM24 21.3333V14.6666C24 10.5733 21.8133 7.14665 18 6.23998V5.33331C18 4.22665 17.1066 3.33331 16 3.33331C14.8933 3.33331 14 4.22665 14 5.33331V6.23998C10.1733 7.14665 7.99998 10.56 7.99998 14.6666V21.3333L5.33331 24V25.3333H26.6666V24L24 21.3333Z",
  fill: "inherit"
}));
var InfoIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M16 2.66669C8.64802 2.66669 2.66669 8.64802 2.66669 16C2.66669 23.352 8.64802 29.3334 16 29.3334C23.352 29.3334 29.3334 23.352 29.3334 16C29.3334 8.64802 23.352 2.66669 16 2.66669ZM17.3334 22.6667H14.6667V14.6667H17.3334V22.6667ZM17.3334 12H14.6667V9.33335H17.3334V12Z",
  fill: "inherit"
}));
var WarningIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M31.2176 28.768L16.9664 2.1568C16.8686 1.98698 16.7278 1.84593 16.5581 1.74786C16.3884 1.64978 16.1959 1.59814 16 1.59814C15.804 1.59814 15.6115 1.64978 15.4419 1.74786C15.2722 1.84593 15.1314 1.98698 15.0336 2.1568L0.783977 28.768C0.688907 28.9338 0.639554 29.1219 0.640959 29.3131C0.642365 29.5042 0.694478 29.6916 0.791977 29.856C0.991977 30.1936 1.35518 30.4 1.74878 30.4H30.2512C30.4442 30.4003 30.6339 30.3503 30.8017 30.2549C30.9695 30.1595 31.1095 30.022 31.208 29.856C31.3054 29.6916 31.3576 29.5044 31.3593 29.3133C31.361 29.1222 31.3121 28.9341 31.2176 28.768V28.768ZM17.6 27.2H14.4V24H17.6V27.2ZM17.6 21.6H14.4V11.2H17.6V21.6Z",
  fill: "inherit"
}));
var ErrorIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "inherit",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M22.276 3.05736C22.1524 2.9333 22.0055 2.83491 21.8437 2.76787C21.6819 2.70082 21.5085 2.66643 21.3334 2.66669H10.6667C10.4916 2.66643 10.3181 2.70082 10.1563 2.76787C9.99455 2.83491 9.84763 2.9333 9.72402 3.05736L3.05736 9.72402C2.9333 9.84763 2.83491 9.99455 2.76787 10.1563C2.70082 10.3181 2.66643 10.4916 2.66669 10.6667V21.3334C2.66669 21.688 2.80669 22.0267 3.05736 22.276L9.72402 28.9427C9.84763 29.0667 9.99455 29.1651 10.1563 29.2322C10.3181 29.2992 10.4916 29.3336 10.6667 29.3334H21.3334C21.688 29.3334 22.0267 29.1934 22.276 28.9427L28.9427 22.276C29.0667 22.1524 29.1651 22.0055 29.2322 21.8437C29.2992 21.6819 29.3336 21.5085 29.3334 21.3334V10.6667C29.3336 10.4916 29.2992 10.3181 29.2322 10.1563C29.1651 9.99455 29.0667 9.84763 28.9427 9.72402L22.276 3.05736ZM17.3334 22.6667H14.6667V20H17.3334V22.6667ZM17.3334 17.3334H14.6667V9.33336H17.3334V17.3334Z",
  fill: "inherit"
}));
var PullRequestIcon = ({ ...props }) => React68.createElement("svg", {
  viewBox: "0 0 32 32",
  fill: "currentColor",
  xmlns: "http://www.w3.org/2000/svg",
  ...props
}, React68.createElement("path", {
  d: "M22.6328 19.163V11.997C22.6281 10.391 21.613 8 18.8359 8V6L15.0484 9L18.8359 12V10C20.5677 10 20.7306 11.539 20.7391 12V19.163C19.3756 19.597 18.3719 20.92 18.3719 22.5C18.3719 24.43 19.8585 26 21.686 26C23.5134 26 25 24.43 25 22.5C25 20.92 23.9963 19.597 22.6328 19.163ZM21.686 24C20.9029 24 20.2656 23.327 20.2656 22.5C20.2656 21.673 20.9029 21 21.686 21C22.469 21 23.1063 21.673 23.1063 22.5C23.1063 23.327 22.469 24 21.686 24ZM13.6281 9.5C13.6281 7.57 12.1415 6 10.314 6C8.48659 6 7 7.57 7 9.5C7 11.08 8.00368 12.403 9.36718 12.837V19.163C8.00368 19.597 7 20.92 7 22.5C7 24.43 8.48659 26 10.314 26C12.1415 26 13.6281 24.43 13.6281 22.5C13.6281 20.92 12.6244 19.597 11.2609 19.163V12.837C12.6244 12.403 13.6281 11.08 13.6281 9.5ZM8.89374 9.5C8.89374 8.673 9.53098 8 10.314 8C11.0971 8 11.7344 8.673 11.7344 9.5C11.7344 10.327 11.0971 11 10.314 11C9.53098 11 8.89374 10.327 8.89374 9.5ZM11.7344 22.5C11.7344 23.327 11.0971 24 10.314 24C9.53098 24 8.89374 23.327 8.89374 22.5C8.89374 21.673 9.53098 21 10.314 21C11.0971 21 11.7344 21.673 11.7344 22.5Z"
}));
var Folder = ({ ...props }) => {
  return import_react117.default.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "2 2 20 20",
    ...props
  }, import_react117.default.createElement("path", {
    d: "M20,5h-8.586L9.707,3.293C9.52,3.105,9.265,3,9,3H4C2.897,3,2,3.897,2,5v14c0,1.103,0.897,2,2,2h16c1.103,0,2-0.897,2-2V7 C22,5.897,21.103,5,20,5z M4,19V7h7h1h8l0.002,12H4z"
  }));
};
var File2 = ({ ...props }) => {
  return import_react117.default.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "2 2 20 20",
    ...props
  }, import_react117.default.createElement("path", {
    d: "M19.903,8.586c-0.049-0.106-0.11-0.207-0.196-0.293l-6-6c-0.086-0.086-0.187-0.147-0.293-0.196 c-0.03-0.014-0.062-0.022-0.094-0.033c-0.084-0.028-0.17-0.046-0.259-0.051C13.04,2.011,13.021,2,13,2H6C4.897,2,4,2.897,4,4v16 c0,1.103,0.897,2,2,2h12c1.103,0,2-0.897,2-2V9c0-0.021-0.011-0.04-0.013-0.062c-0.005-0.089-0.022-0.175-0.051-0.259 C19.926,8.647,19.917,8.616,19.903,8.586z M16.586,8H14V5.414L16.586,8z M6,20V4h6v5c0,0.553,0.447,1,1,1h5l0.002,10H6z"
  }), import_react117.default.createElement("path", {
    d: "M8 12H16V14H8zM8 16H16V18H8zM8 8H10V10H8z"
  }));
};
var Circle3 = ({ ...props }) => React68.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  fill: "currentColor",
  className: "bi bi-circle",
  viewBox: "0 0 16 16",
  ...props
}, React68.createElement("path", {
  d: "M8 15A7 7 0 1 1 8 1a7 7 0 0 1 0 14zm0 1A8 8 0 1 0 8 0a8 8 0 0 0 0 16z"
}));
var CircleCheck = ({ ...props }) => React68.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  fill: "currentColor",
  className: "bi bi-check-circle-fill",
  viewBox: "0 0 16 16",
  ...props
}, React68.createElement("path", {
  d: "M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z"
}));
var ModalHeader = ({ children, close: close2 }) => {
  return React68.createElement("div", {
    className: "h-14 flex items-center justify-between px-5 border-b border-gray-200 m-0"
  }, React68.createElement(ModalTitle, null, children), close2 && React68.createElement("div", {
    onClick: close2,
    className: "flex items-center fill-gray-400 cursor-pointer transition-colors duration-100 ease-out hover:fill-gray-700"
  }, React68.createElement(CloseIcon, {
    className: "w-6 h-auto"
  })));
};
var ModalTitle = ({ children }) => {
  return React68.createElement("h2", {
    className: "text-gray-600 font-sans font-medium text-base leading-none m-0 block truncate"
  }, children);
};
var FullscreenModal = ({ className = "", style: style2 = {}, ...props }) => import_react117.default.createElement("div", {
  className: `flex flex-col z-0 overflow-visible bg-white rounded-none absolute top-0 left-0 w-full max-w-[1500px] h-full ${className} md:w-[calc(100%-170px)]`,
  style: {
    animation: "popup-right 150ms ease-out 1",
    ...style2
  },
  ...props
});
var ModalFullscreen = FullscreenModal;
var PopupModal = ({ className = "", style: style2 = {}, ...props }) => import_react117.default.createElement("div", {
  className: `block z-0 overflow-visible bg-gray-50 rounded-[5px] my-10 mx-auto w-[460px] max-w-[90%] ${className}`,
  style: {
    animation: "popup-down 150ms ease-out 1",
    ...style2
  },
  ...props
});
var ModalPopup = PopupModal;
var ERROR_MISSING_CMS = `useCMS could not find an instance of CMS`;
var CMSContext = React68.createContext(null);
function useCMS$1() {
  const cms = React68.useContext(CMSContext);
  if (!cms) {
    throw new Error(ERROR_MISSING_CMS);
  }
  const [, setEnabled] = React68.useState(cms.enabled);
  React68.useEffect(() => {
    return cms.events.subscribe("cms", () => {
      setEnabled(cms.enabled);
    });
  }, [cms]);
  return cms;
}
function useCMSEvent(event, callback, deps) {
  const cms = useCMS$1();
  React68.useEffect(function() {
    return cms.events.subscribe(event, callback);
  }, deps);
}
var useEventSubscription = useCMSEvent;
function useEvent2(eventType) {
  const cms = useCMS$1();
  return {
    dispatch: (event) => cms.events.dispatch({
      ...event,
      type: eventType
    }),
    subscribe: (callback) => cms.events.subscribe(eventType, callback)
  };
}
function wrapFieldsWithMeta(Field22) {
  return (props) => {
    return React68.createElement(FieldMeta, {
      name: props.input.name,
      label: props.field.label,
      description: props.field.description,
      error: props.meta.error,
      index: props.index,
      tinaForm: props.tinaForm
    }, React68.createElement(Field22, {
      ...props
    }));
  };
}
function wrapFieldWithError(Field22) {
  return (props) => {
    return React68.createElement(FieldMeta, {
      name: props.input.name,
      label: false,
      description: props.field.description,
      error: props.meta.error,
      index: props.index,
      tinaForm: props.tinaForm
    }, React68.createElement(Field22, {
      ...props
    }));
  };
}
var FieldMeta = ({
  name: name2,
  label,
  description,
  error: error2,
  margin = true,
  children,
  index: index2,
  tinaForm,
  ...props
}) => {
  const { dispatch: setHoveredField } = useEvent2("field:hover");
  const { dispatch: setFocusedField } = useEvent2("field:focus");
  return React68.createElement(FieldWrapper, {
    margin,
    onMouseOver: () => setHoveredField({ id: tinaForm.id, fieldName: name2 }),
    onMouseOut: () => setHoveredField({ id: null, fieldName: null }),
    onClick: () => setFocusedField({ id: tinaForm.id, fieldName: name2 }),
    style: { zIndex: index2 ? 1e3 - index2 : void 0 },
    ...props
  }, (label !== false || description) && React68.createElement(FieldLabel, {
    name: name2
  }, label !== false && React68.createElement(React68.Fragment, null, label || name2), description && React68.createElement(FieldDescription, null, description)), children, error2 && typeof error2 === "string" && React68.createElement(FieldError, null, error2));
};
var FieldWrapper = ({
  margin,
  children,
  ...props
}) => {
  return React68.createElement("div", {
    className: `relative ${margin ? `mb-5 last:mb-0` : ``}`,
    ...props
  }, children);
};
var FieldLabel = ({
  children,
  className,
  name: name2,
  ...props
}) => {
  return React68.createElement("label", {
    htmlFor: name2,
    className: `block font-sans text-xs font-semibold text-gray-700 whitespace-normal mb-2 ${className}`,
    ...props
  }, children);
};
var FieldDescription = ({
  children,
  className,
  ...props
}) => {
  return React68.createElement("span", {
    className: `block font-sans text-xs italic font-light text-gray-400 pt-0.5 whitespace-normal m-0 ${className}`,
    ...props
  }, children);
};
var FieldError = ({
  children,
  className,
  ...props
}) => {
  return React68.createElement("span", {
    className: `block font-sans text-xs font-normal text-red-500 pt-3 animate-slide-in whitespace-normal m-0  ${className}`,
    ...props
  }, children);
};
function classNames$1(...classes) {
  return classes.filter(Boolean).join(" ");
}
var uuid = () => {
  return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, (c16) => (c16 ^ crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c16 / 4).toString(16));
};
function ChevronDownIcon(props, svgRef) {
  return React68.createElement("svg", Object.assign({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    "aria-hidden": "true",
    ref: svgRef
  }, props), React68.createElement("path", {
    fillRule: "evenodd",
    d: "M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z",
    clipRule: "evenodd"
  }));
}
var ForwardRef = React68.forwardRef(ChevronDownIcon);
var ChevronDownIcon$1 = ForwardRef;
var Autocomplete = ({
  value,
  onChange,
  defaultQuery,
  items
}) => {
  const [query, setQuery] = import_react117.default.useState(defaultQuery != null ? defaultQuery : "");
  const filteredItems = import_react117.default.useMemo(() => {
    try {
      const reFilter = new RegExp(query, "i");
      const _items = items.filter((item) => reFilter.test(item.label));
      if (_items.length === 0)
        return items;
      return _items;
    } catch (err) {
      return items;
    }
  }, [items, query]);
  return import_react117.default.createElement(Wo, {
    value,
    onChange,
    as: "div",
    className: "relative inline-block text-left z-20"
  }, import_react117.default.createElement("div", {
    className: "mt-1"
  }, import_react117.default.createElement("div", {
    className: "relative w-full cursor-default overflow-hidden rounded-lg bg-white text-left shadow-md sm:text-sm"
  }, import_react117.default.createElement(Wo.Input, {
    className: "w-full border-none py-2 pl-3 pr-10 text-sm leading-5 text-gray-900 focus:ring-0 focus:outline-none focus-visible:ring-2 focus-visible:ring-white focus-visible:ring-opacity-75 focus-visible:ring-offset-2 focus-visible:ring-offset-teal-300",
    displayValue: (item) => {
      var _a;
      return (_a = item == null ? void 0 : item.label) != null ? _a : "Plain Text";
    },
    onChange: (event) => setQuery(event.target.value),
    onClick: (ev) => ev.stopPropagation()
  }), import_react117.default.createElement(Wo.Button, {
    className: "absolute inset-y-0 right-0 flex items-center pr-2"
  }, import_react117.default.createElement(ChevronDownIcon$1, {
    className: "h-5 w-5 text-gray-400",
    "aria-hidden": "true"
  })))), import_react117.default.createElement(tt2, {
    as: import_react117.Fragment,
    enter: "transition ease-out duration-100",
    enterFrom: "transform opacity-0 scale-95",
    enterTo: "transform opacity-100 scale-100",
    leave: "transition ease-in duration-75",
    leaveFrom: "transform opacity-100 scale-100",
    leaveTo: "transform opacity-0 scale-95"
  }, import_react117.default.createElement(Wo.Options, {
    className: "origin-top-right absolute right-0 mt-1 w-full max-h-[300px] overflow-y-auto rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none"
  }, filteredItems.map((item) => import_react117.default.createElement(Wo.Option, {
    key: item.key,
    value: item
  }, ({ active }) => import_react117.default.createElement("button", {
    className: classNames$1(active ? "bg-gray-100 text-gray-900" : "text-gray-700", "block px-4 py-2 text-xs w-full text-right")
  }, item.render(item)))))));
};
loader_default.config({
  paths: { vs: "https://cdn.jsdelivr.net/npm/monaco-editor@0.31.1/min/vs" }
});
var retryCount = 0;
var retryFocus = (ref2) => {
  if (ref2.current) {
    ref2.current.focus();
  } else {
    if (retryCount < 30) {
      setTimeout(() => {
        retryCount = retryCount + 1;
        retryFocus(ref2);
      }, 100);
    }
  }
};
var CodeBlock = ({
  attributes,
  editor,
  element,
  language: restrictLanguage,
  ...props
}) => {
  const [navigateAway, setNavigateAway] = import_react117.default.useState(null);
  const monaco = useMonaco_default();
  const monacoEditorRef = import_react117.default.useRef(null);
  const selected = useSelected();
  const [height, setHeight] = import_react117.default.useState(28);
  import_react117.default.useEffect(() => {
    if (selected && isCollapsed(editor.selection)) {
      retryFocus(monacoEditorRef);
    }
  }, [selected, monacoEditorRef.current]);
  const value = element.value || "";
  if (typeof value !== "string") {
    throw new Error(`Element must be of type string for code block`);
  }
  const language = restrictLanguage || element.lang;
  const id = import_react117.default.useMemo(() => uuid(), []);
  const languages2 = import_react117.default.useMemo(() => {
    const defaultLangSet = { "": "plain text" };
    if (!monaco)
      return defaultLangSet;
    return monaco.languages.getLanguages().reduce((ac, cv) => {
      if (cv.id === "plaintext")
        return ac;
      return { ...ac, [cv.id]: cv.id };
    }, defaultLangSet);
  }, [monaco]);
  import_react117.default.useEffect(() => {
    if (monaco) {
      monaco.languages.typescript.typescriptDefaults.setEagerModelSync(true);
      monaco.languages.typescript.typescriptDefaults.setDiagnosticsOptions({
        noSemanticValidation: true,
        noSyntaxValidation: true
      });
    }
  }, [monaco]);
  const items = Object.entries(languages2).map(([key, label]) => ({
    key,
    label,
    render: (item) => item.label
  }));
  const currentItem = import_react117.default.useMemo(() => {
    var _a;
    return (_a = items.find((item) => item.key === language)) != null ? _a : {
      key: "",
      label: "Plain Text"
    };
  }, [items, language]);
  import_react117.default.useEffect(() => {
    if (navigateAway) {
      setNavigateAway(null);
      switch (navigateAway) {
        case "remove":
          {
            focusEditor(editor);
            setNodes(editor, {
              type: "p",
              children: [{ text: "" }],
              lang: void 0,
              value: void 0
            }, {
              match: (n12) => {
                if (isElement2(n12) && n12.type === element.type) {
                  return true;
                }
              }
            });
          }
          break;
        case "insertNext":
          {
            insertNodes(editor, [
              {
                type: ELEMENT_DEFAULT,
                children: [{ text: "" }],
                lang: void 0,
                value: void 0
              }
            ], { select: true });
            focusEditor(editor);
          }
          break;
        case "up":
          {
            const path = findNodePath(editor, element);
            if (!path) {
              return;
            }
            const previousNodePath = getPointBefore(editor, path);
            if (!previousNodePath) {
              focusEditor(editor);
              insertNodes(editor, [
                {
                  type: ELEMENT_DEFAULT,
                  children: [{ text: "" }],
                  lang: void 0,
                  value: void 0
                }
              ], { at: path, select: true });
              return;
            }
            focusEditor(editor, previousNodePath);
          }
          break;
        case "down": {
          const path = findNodePath(editor, element);
          if (!path) {
            return;
          }
          const nextNodePath = getPointAfter(editor, path);
          if (!nextNodePath) {
            insertNodes(editor, [
              {
                type: ELEMENT_DEFAULT,
                children: [{ text: "" }],
                lang: void 0,
                value: void 0
              }
            ], { select: true });
            focusEditor(editor);
          } else {
            focusEditor(editor, nextNodePath);
          }
          break;
        }
      }
    }
  }, [navigateAway]);
  function handleEditorDidMount(monacoEditor, monaco2) {
    monacoEditorRef.current = monacoEditor;
    monacoEditor.onDidContentSizeChange(() => {
      setHeight(monacoEditor.getContentHeight());
      monacoEditor.layout();
    });
    monacoEditor.addCommand(monaco2.KeyMod.Shift | monaco2.KeyCode.Enter, () => {
      if (monacoEditor.hasTextFocus()) {
        setNavigateAway("insertNext");
      }
    });
    monacoEditor.onKeyDown((l14) => {
      if (l14.code === "ArrowUp") {
        const selection = monacoEditor.getSelection();
        if (selection.endLineNumber === 1 && selection.startLineNumber === 1) {
          setNavigateAway("up");
        }
      }
      if (l14.code === "ArrowDown") {
        const selection = monacoEditor.getSelection();
        const totalLines = monacoEditor.getModel().getLineCount();
        if (selection.endLineNumber === totalLines && selection.startLineNumber === totalLines) {
          setNavigateAway("down");
        }
      }
      if (l14.code === "Backspace") {
        const selection = monacoEditor.getSelection();
        if (selection.endColumn === 1 && selection.endLineNumber === 1 && selection.positionColumn === 1 && selection.positionLineNumber === 1 && selection.selectionStartColumn === 1 && selection.selectionStartLineNumber === 1 && selection.startColumn === 1 && selection.startLineNumber === 1) {
          setNavigateAway("remove");
        }
      }
    });
  }
  return import_react117.default.createElement("div", {
    ...attributes,
    className: "relative mb-2 mt-0.5 rounded-lg shadow-md p-2 border-gray-200 border"
  }, import_react117.default.createElement("style", null, `.tina-tailwind .monaco-editor .editor-widget {
          display: none !important;
          visibility: hidden !important;
        }`), props.children, import_react117.default.createElement("div", {
    contentEditable: false
  }, !restrictLanguage && import_react117.default.createElement("div", {
    className: "flex justify-between pb-2"
  }, import_react117.default.createElement("div", null), import_react117.default.createElement(Autocomplete, {
    items,
    value: currentItem,
    defaultQuery: "plaintext",
    onChange: (item) => setNodes(editor, { lang: item.key })
  })), import_react117.default.createElement("div", {
    style: { height: `${height}px` }
  }, import_react117.default.createElement(Editor_default, {
    path: id,
    onMount: handleEditorDidMount,
    options: {
      scrollBeyondLastLine: false,
      tabSize: 2,
      disableLayerHinting: true,
      accessibilitySupport: "off",
      codeLens: false,
      wordWrap: "on",
      minimap: {
        enabled: false
      },
      fontSize: 14,
      lineHeight: 2,
      formatOnPaste: true,
      lineNumbers: "off",
      formatOnType: true,
      fixedOverflowWidgets: true,
      folding: false,
      renderLineHighlight: "none",
      scrollbar: {
        verticalScrollbarSize: 1,
        horizontalScrollbarSize: 1,
        alwaysConsumeMouseWheel: false
      }
    },
    language: String(language),
    value: String(element.value),
    onChange: (value2) => {
      setNodes(editor, { value: value2, lang: language });
    }
  }))));
};
var blockClasses = "mt-0.5";
var headerClasses = "font-normal";
var components = () => {
  return {
    [ELEMENT_H1]: ({ attributes, editor, element, className, ...props }) => import_react117.default.createElement("h1", {
      className: classNames$1(headerClasses, blockClasses, className, "text-4xl font-medium mb-4 last:mb-0 mt-6 first:mt-0"),
      ...attributes,
      ...props
    }),
    [ELEMENT_H2]: ({ attributes, editor, element, className, ...props }) => import_react117.default.createElement("h2", {
      className: classNames$1(headerClasses, blockClasses, className, "text-3xl font-medium mb-4 last:mb-0 mt-6 first:mt-0"),
      ...attributes,
      ...props
    }),
    [ELEMENT_H3]: ({ attributes, editor, element, className, ...props }) => import_react117.default.createElement("h3", {
      className: classNames$1(headerClasses, blockClasses, className, "text-2xl font-semibold mb-4 last:mb-0 mt-6 first:mt-0"),
      ...attributes,
      ...props
    }),
    [ELEMENT_H4]: ({ attributes, editor, element, className, ...props }) => import_react117.default.createElement("h4", {
      className: classNames$1(headerClasses, blockClasses, className, "text-xl font-bold mb-4 last:mb-0 mt-6 first:mt-0"),
      ...attributes,
      ...props
    }),
    [ELEMENT_H5]: ({ attributes, editor, element, className, ...props }) => import_react117.default.createElement("h5", {
      className: classNames$1(headerClasses, blockClasses, className, "text-lg font-bold mb-4 last:mb-0 mt-6 first:mt-0"),
      ...attributes,
      ...props
    }),
    [ELEMENT_H6]: ({ attributes, editor, element, className, ...props }) => import_react117.default.createElement("h6", {
      className: classNames$1(headerClasses, blockClasses, className, "text-base font-bold mb-4 last:mb-0 mt-6 first:mt-0"),
      ...attributes,
      ...props
    }),
    [ELEMENT_PARAGRAPH]: ({
      attributes,
      className,
      editor,
      element,
      ...props
    }) => import_react117.default.createElement("div", {
      className: classNames$1(blockClasses, className, `text-base font-normal mb-4 last:mb-0`),
      ...attributes,
      ...props
    }),
    [ELEMENT_BLOCKQUOTE]: ({
      className,
      attributes,
      editor,
      element,
      ...props
    }) => import_react117.default.createElement("blockquote", {
      className: classNames$1("not-italic mb-4 last:mb-0 border-l-3 border-gray-200 pl-3", blockClasses, className),
      ...attributes,
      ...props
    }),
    [ELEMENT_CODE_BLOCK]: (props) => import_react117.default.createElement(CodeBlock, {
      ...props
    }),
    html: ({ attributes, editor, element, children, className }) => {
      return import_react117.default.createElement("div", {
        ...attributes,
        className: classNames$1("font-mono text-sm bg-green-100 cursor-not-allowed mb-4", className)
      }, children, element.value);
    },
    html_inline: ({ attributes, editor, element, children, className }) => {
      return import_react117.default.createElement("span", {
        ...attributes,
        className: classNames$1("font-mono bg-green-100 cursor-not-allowed", className)
      }, children, element.value);
    },
    [ELEMENT_UL]: ({ attributes, editor, className, element, ...props }) => import_react117.default.createElement("ul", {
      className: classNames$1(blockClasses, className, "mb-4 pl-4 list-disc list-inside last:mb-0"),
      ...attributes,
      ...props
    }),
    [ELEMENT_OL]: ({ attributes, editor, className, element, ...props }) => import_react117.default.createElement("ol", {
      className: classNames$1(blockClasses, className, "mb-4 pl-4 list-decimal list-inside last:mb-0"),
      ...attributes,
      ...props
    }),
    [ELEMENT_LI]: ({ attributes, className, editor, element, ...props }) => import_react117.default.createElement("li", {
      className: classNames$1("p-0 mt-0 mb-0 list-outside", className),
      ...attributes,
      ...props
    }),
    [ELEMENT_LIC]: ({ attributes, editor, element, className, ...props }) => import_react117.default.createElement("span", {
      className: classNames$1(className, "w-full inline-block align-top mb-2"),
      ...attributes,
      ...props
    }),
    [ELEMENT_LINK]: ({
      attributes,
      editor,
      element,
      nodeProps,
      className,
      ...props
    }) => import_react117.default.createElement("a", {
      className: classNames$1(className, "text-blue-500 hover:text-blue-600 transition-color ease-out duration-150 underline"),
      ...attributes,
      ...props
    }),
    [MARK_CODE]: ({ editor, leaf, text, attributes, className, ...props }) => import_react117.default.createElement("code", {
      className: classNames$1("bg-gray-100 p-1 rounded-sm", className),
      ...attributes,
      ...props
    }),
    [MARK_ITALIC]: ({ editor, leaf, text, ...props }) => import_react117.default.createElement("em", {
      ...props.attributes,
      ...props
    }),
    [MARK_BOLD]: ({ editor, leaf, text, ...props }) => import_react117.default.createElement("strong", {
      ...props.attributes,
      ...props
    }),
    [ELEMENT_HR]: ({
      attributes,
      className,
      editor,
      element,
      children,
      ...props
    }) => {
      const selected = useSelected();
      return import_react117.default.createElement("div", {
        className: classNames$1(className, "cursor-pointer relative border bg-gray-200 my-4 first:mt-0 last:mb-0"),
        ...attributes,
        ...props
      }, children, selected && import_react117.default.createElement("span", {
        className: "absolute h-4 -top-2 inset-0 ring-2 ring-blue-100 ring-inset rounded-md z-10 pointer-events-none"
      }));
    }
  };
};
var RawMarkdown = () => {
  return import_react117.default.createElement("svg", {
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: 0,
    role: "img",
    className: "h-5 w-5",
    viewBox: "0 0 24 24",
    height: "1em",
    width: "1em",
    xmlns: "http://www.w3.org/2000/svg"
  }, import_react117.default.createElement("title", null), import_react117.default.createElement("path", {
    d: "M22.27 19.385H1.73A1.73 1.73 0 010 17.655V6.345a1.73 1.73 0 011.73-1.73h20.54A1.73 1.73 0 0124 6.345v11.308a1.73 1.73 0 01-1.73 1.731zM5.769 15.923v-4.5l2.308 2.885 2.307-2.885v4.5h2.308V8.078h-2.308l-2.307 2.885-2.308-2.885H3.46v7.847zM21.232 12h-2.309V8.077h-2.307V12h-2.308l3.461 4.039z"
  }));
};
var iconEl = {
  heading: import_react117.default.createElement(HeadingIcon, null),
  link: import_react117.default.createElement(LinkIcon, null),
  quote: import_react117.default.createElement(QuoteIcon, null),
  image: import_react117.default.createElement(ImageIcon, null),
  ul: import_react117.default.createElement(UnorderedListIcon, null),
  ol: import_react117.default.createElement(OrderedListIcon, null),
  code: import_react117.default.createElement(CodeIcon, null),
  codeBlock: import_react117.default.createElement(CodeBlockIcon, null),
  bold: import_react117.default.createElement(BoldIcon, null),
  italic: import_react117.default.createElement(ItalicIcon, null),
  raw: import_react117.default.createElement(RawMarkdown, null)
};
var ToolbarIcon = ({ name: name2 }) => {
  return iconEl[name2];
};
var EllipsisIcon = ({ title }) => {
  return import_react117.default.createElement(import_react117.default.Fragment, null, title && import_react117.default.createElement("span", {
    className: "sr-only"
  }, title), import_react117.default.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    className: "h-5 w-5",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor"
  }, import_react117.default.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 2,
    d: "M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z"
  })));
};
function UnorderedListIcon(props) {
  const title = props.title || "format list bulleted";
  return import_react117.default.createElement("svg", {
    className: "h-5 w-5",
    height: "24",
    width: "24",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, import_react117.default.createElement("title", null, title), import_react117.default.createElement("g", {
    fill: "none"
  }, import_react117.default.createElement("path", {
    d: "M7 5h14v2H7V5z",
    fill: "currentColor"
  }), import_react117.default.createElement("path", {
    d: "M4 7.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z",
    fill: "currentColor"
  }), import_react117.default.createElement("path", {
    d: "M7 11h14v2H7v-2zm0 6h14v2H7v-2zm-3 2.5c.82 0 1.5-.68 1.5-1.5s-.67-1.5-1.5-1.5-1.5.68-1.5 1.5.68 1.5 1.5 1.5z",
    fill: "currentColor"
  }), import_react117.default.createElement("path", {
    d: "M4 13.5a1.5 1.5 0 1 0 0-3 1.5 1.5 0 0 0 0 3z",
    fill: "currentColor"
  })));
}
function HeadingIcon(props) {
  const title = props.title || "format size";
  return import_react117.default.createElement("svg", {
    height: "24",
    width: "24",
    className: "h-5 w-5",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, import_react117.default.createElement("title", null, title), import_react117.default.createElement("g", {
    fill: "none"
  }, import_react117.default.createElement("path", {
    d: "M9 4v3h5v12h3V7h5V4H9zm-6 8h3v7h3v-7h3V9H3v3z",
    fill: "currentColor"
  })));
}
function OrderedListIcon(props) {
  const title = props.title || "format list numbered";
  return import_react117.default.createElement("svg", {
    className: "h-5 w-5",
    height: "24",
    width: "24",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, import_react117.default.createElement("title", null, title), import_react117.default.createElement("g", {
    fill: "none"
  }, import_react117.default.createElement("path", {
    d: "M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z",
    fill: "currentColor"
  })));
}
function QuoteIcon(props) {
  const title = props.title || "format quote";
  return import_react117.default.createElement("svg", {
    height: "24",
    className: "h-5 w-5",
    width: "24",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, import_react117.default.createElement("title", null, title), import_react117.default.createElement("g", {
    fill: "none"
  }, import_react117.default.createElement("path", {
    d: "M6 17h3l2-4V7H5v6h3l-2 4zm8 0h3l2-4V7h-6v6h3l-2 4z",
    fill: "currentColor"
  })));
}
function LinkIcon(props) {
  const title = props.title || "insert link";
  return import_react117.default.createElement("svg", {
    height: "24",
    className: "h-5 w-5",
    width: "24",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, import_react117.default.createElement("title", null, title), import_react117.default.createElement("g", {
    fill: "none"
  }, import_react117.default.createElement("path", {
    d: "M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1 0 1.71-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z",
    fill: "currentColor"
  })));
}
function CodeIcon(props) {
  const title = props.title || "code";
  return import_react117.default.createElement("svg", {
    className: "h-5 w-5",
    height: "24",
    width: "24",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, import_react117.default.createElement("title", null, title), import_react117.default.createElement("g", {
    fill: "none"
  }, import_react117.default.createElement("path", {
    d: "M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z",
    fill: "currentColor"
  })));
}
function CodeBlockIcon(props) {
  const title = props.title || "code-block";
  return import_react117.default.createElement("svg", {
    className: "h-5 w-5",
    stroke: "currentColor",
    fill: "currentColor",
    strokeWidth: 0,
    viewBox: "0 0 16 16",
    height: "1em",
    width: "1em",
    xmlns: "http://www.w3.org/2000/svg"
  }, import_react117.default.createElement("title", null, title), import_react117.default.createElement("path", {
    d: "M14 1a1 1 0 0 1 1 1v12a1 1 0 0 1-1 1H2a1 1 0 0 1-1-1V2a1 1 0 0 1 1-1h12zM2 0a2 2 0 0 0-2 2v12a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V2a2 2 0 0 0-2-2H2z"
  }), import_react117.default.createElement("path", {
    d: "M6.854 4.646a.5.5 0 0 1 0 .708L4.207 8l2.647 2.646a.5.5 0 0 1-.708.708l-3-3a.5.5 0 0 1 0-.708l3-3a.5.5 0 0 1 .708 0zm2.292 0a.5.5 0 0 0 0 .708L11.793 8l-2.647 2.646a.5.5 0 0 0 .708.708l3-3a.5.5 0 0 0 0-.708l-3-3a.5.5 0 0 0-.708 0z"
  }));
}
function ImageIcon(props) {
  const title = props.title || "image";
  return import_react117.default.createElement("svg", {
    className: "h-5 w-5",
    height: "24",
    width: "24",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, import_react117.default.createElement("title", null, title), import_react117.default.createElement("g", {
    fill: "none"
  }, import_react117.default.createElement("path", {
    d: "M19 5v14H5V5h14zm0-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-4.86 8.86l-3 3.87L9 13.14 6 17h12l-3.86-5.14z",
    fill: "currentColor"
  })));
}
function BoldIcon(props) {
  const title = props.title || "format bold";
  return import_react117.default.createElement("svg", {
    className: "h-5 w-5",
    height: "24",
    width: "24",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, import_react117.default.createElement("title", null, title), import_react117.default.createElement("g", {
    fill: "none"
  }, import_react117.default.createElement("path", {
    d: "M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z",
    fill: "currentColor"
  })));
}
function ItalicIcon(props) {
  const title = props.title || "format italic";
  return import_react117.default.createElement("svg", {
    className: "h-5 w-5",
    height: "24",
    width: "24",
    viewBox: "0 0 24 24",
    xmlns: "http://www.w3.org/2000/svg"
  }, import_react117.default.createElement("title", null, title), import_react117.default.createElement("g", {
    fill: "none"
  }, import_react117.default.createElement("path", {
    d: "M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4h-8z",
    fill: "currentColor"
  })));
}
function PlusIcon({ className = "" }) {
  return import_react117.default.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    className: `h-4 w-4 ${className}`,
    viewBox: "0 0 20 20",
    fill: "currentColor"
  }, import_react117.default.createElement("path", {
    fillRule: "evenodd",
    d: "M10 3a1 1 0 011 1v5h5a1 1 0 110 2h-5v5a1 1 0 11-2 0v-5H4a1 1 0 110-2h5V4a1 1 0 011-1z",
    clipRule: "evenodd"
  }));
}
var Form = class {
  constructor({
    id,
    label,
    fields,
    actions,
    buttons,
    global: global2,
    reset,
    loadInitialValues,
    onChange,
    ...options
  }) {
    this.global = null;
    this.loading = false;
    this.subscribe = (cb, options2) => {
      return this.finalForm.subscribe(cb, options2);
    };
    this.handleSubmit = async (values3, form, cb) => {
      try {
        const response = await this.onSubmit(values3, form, cb);
        form.initialize(values3);
        return response;
      } catch (error2) {
        return { [FORM_ERROR]: error2 };
      }
    };
    this.submit = () => {
      return this.finalForm.submit();
    };
    const initialValues = options.initialValues || {};
    this.__type = options.__type || "form";
    this.id = id;
    this.label = label;
    this.global = global2;
    this.fields = fields || [];
    this.onSubmit = options.onSubmit;
    this.finalForm = createForm({
      ...options,
      initialValues,
      onSubmit: this.handleSubmit,
      mutators: {
        ...final_form_arrays_es_default,
        setFieldData: final_form_set_field_data_es_default,
        ...options.mutators
      }
    });
    this._reset = reset;
    this.actions = actions || [];
    this.buttons = buttons || {
      save: "Save",
      reset: "Reset"
    };
    this.updateFields(this.fields);
    if (loadInitialValues) {
      this.loading = true;
      loadInitialValues().then((initialValues2) => {
        this.updateInitialValues(initialValues2);
      }).finally(() => {
        this.loading = false;
      });
    }
    if (onChange) {
      let firstUpdate = true;
      this.subscribe((formState) => {
        if (firstUpdate) {
          firstUpdate = false;
        } else {
          onChange(formState);
        }
      }, { values: true, ...(options == null ? void 0 : options.extraSubscribeValues) || {} });
    }
  }
  get name() {
    return this.id;
  }
  get values() {
    if (this.loading) {
      return void 0;
    }
    return this.finalForm.getState().values || this.initialValues;
  }
  get initialValues() {
    return this.finalForm.getState().initialValues;
  }
  get pristine() {
    return this.finalForm.getState().pristine;
  }
  get dirty() {
    return this.finalForm.getState().dirty;
  }
  get submitting() {
    return this.finalForm.getState().submitting;
  }
  get valid() {
    return this.finalForm.getState().valid;
  }
  async reset() {
    if (this._reset) {
      await this._reset();
    }
    this.finalForm.reset();
  }
  updateFields(fields) {
    this.fields = fields;
  }
  change(name2, value) {
    return this.finalForm.change(name2, value);
  }
  get mutators() {
    return this.finalForm.mutators;
  }
  updateValues(values3) {
    this.finalForm.batch(() => {
      const activePath = this.finalForm.getState().active;
      if (!activePath) {
        updateEverything(this.finalForm, values3);
      } else {
        updateSelectively(this.finalForm, values3);
      }
    });
  }
  updateInitialValues(initialValues) {
    this.finalForm.batch(() => {
      const values3 = this.values || {};
      this.finalForm.initialize(initialValues);
      const activePath = this.finalForm.getState().active;
      if (!activePath) {
        updateEverything(this.finalForm, values3);
      } else {
        updateSelectively(this.finalForm, values3);
      }
    });
  }
};
function updateEverything(form, values3) {
  Object.entries(values3).forEach(([path, value]) => {
    form.change(path, value);
  });
}
function updateSelectively(form, values3, prefix3) {
  const activePath = form.getState().active;
  Object.entries(values3).forEach(([name2, value]) => {
    const path = prefix3 ? `${prefix3}.${name2}` : name2;
    if (typeof value === "object") {
      if (typeof activePath === "string" && activePath.startsWith(path)) {
        updateSelectively(form, value, path);
      } else {
        form.change(path, value);
      }
    } else if (path !== activePath) {
      form.change(path, value);
    }
  });
}
var usePlugin = usePlugins;
function usePlugins(plugins2) {
  const cms = useCMS$1();
  let pluginArray;
  if (Array.isArray(plugins2)) {
    pluginArray = plugins2;
  } else {
    pluginArray = [plugins2];
  }
  React68.useEffect(() => {
    pluginArray.forEach((plugin) => {
      if (plugin) {
        cms.plugins.add(plugin);
      }
    });
    return () => {
      pluginArray.forEach((plugin) => {
        if (plugin) {
          cms.plugins.remove(plugin);
        }
      });
    };
  }, [cms.plugins, ...pluginArray]);
}
function useLocalForm(options, watch = {}) {
  const [values3, form] = useForm2(options, watch);
  usePlugins(form);
  return [values3, form];
}
function useForm2({ loadInitialValues, ...options }, watch = {}) {
  options.initialValues = options.initialValues || watch.values;
  const [, setValues] = React68.useState(options.initialValues);
  const [form, setForm] = React68.useState(() => {
    return createForm2(options, (form2) => {
      setValues(form2.values);
    });
  });
  React68.useEffect(function() {
    if (form.id === options.id)
      return;
    setForm(createForm2(options, (form2) => {
      setValues(form2.values);
    }));
  }, [options.id]);
  const [formIsLoading, setFormIsLoading] = React68.useState(() => loadInitialValues ? true : false);
  const loadFormData = React68.useCallback(async () => {
    if (loadInitialValues) {
      setFormIsLoading(true);
      await loadInitialValues().then((values3) => {
        form.updateInitialValues(values3);
      }).finally(() => {
        setFormIsLoading(false);
      });
    }
  }, [form, setFormIsLoading]);
  React68.useEffect(() => {
    loadFormData();
  }, [form, loadFormData]);
  useCMSEvent("unstable:reload-form-data", async () => {
    await loadFormData();
    await form.reset();
  }, [loadFormData, form]);
  useUpdateFormFields(form, watch.fields);
  useUpdateFormLabel(form, watch.label);
  useUpdateFormValues(form, watch.values);
  return [form ? form.values : options.initialValues, form, formIsLoading];
}
function createForm2(options, handleChange) {
  const form = new Form(options);
  form.subscribe(handleChange, { values: true });
  return form;
}
function useUpdateFormFields(form, fields) {
  React68.useEffect(() => {
    if (typeof fields === "undefined")
      return;
    form.updateFields(fields);
  }, [form, fields]);
}
function useUpdateFormLabel(form, label) {
  React68.useEffect(() => {
    if (typeof label === "undefined")
      return;
    form.label = label;
  }, [form, label]);
}
function useUpdateFormValues(form, values3) {
  React68.useEffect(() => {
    if (typeof values3 === "undefined")
      return;
    form.updateValues(values3);
  }, [form, values3]);
}
function useSubscribable(subscribable, cb) {
  const [, s20] = React68.useState(0);
  React68.useEffect(() => {
    return subscribable.subscribe(() => {
      s20((x7) => x7 + 1);
      if (cb)
        cb();
    });
  });
}
function useWatchFormValues(form, cb) {
  (0, import_react117.useEffect)(() => {
    if (!form)
      return;
    let firstUpdate = true;
    return form.subscribe((formState) => {
      if (firstUpdate) {
        firstUpdate = false;
      } else {
        cb(formState);
      }
    }, { values: true });
  }, [cb, form]);
}
function withPlugins(Component9, plugins2) {
  return (props) => {
    usePlugin(plugins2);
    return React68.createElement(Component9, {
      ...props
    });
  };
}
var withPlugin = withPlugins;
function FieldsBuilder({
  form,
  fields,
  padding = false
}) {
  const cms = useCMS$1();
  const [fieldPlugins, setFieldPlugins] = React68.useState([]);
  const updateFieldPlugins = React68.useCallback(() => {
    const fieldPlugins2 = cms.plugins.getType("field").all();
    setFieldPlugins(fieldPlugins2);
  }, [setFieldPlugins]);
  React68.useEffect(() => updateFieldPlugins(), []);
  useEventSubscription("plugin:add:field", () => updateFieldPlugins(), []);
  return React68.createElement(FieldsGroup, {
    padding
  }, fields.map((field, index2) => React68.createElement(InnerField, {
    key: field.name,
    field,
    form,
    fieldPlugins,
    index: index2
  })));
}
var InnerField = ({ field, form, fieldPlugins, index: index2 }) => {
  React68.useEffect(() => {
    form.mutators.setFieldData(field.name, {
      tinaField: field
    });
  }, [form, field]);
  if (field.component === null)
    return null;
  const plugin = fieldPlugins.find((plugin2) => plugin2.name === field.component);
  let type;
  if (plugin && plugin.type) {
    type = plugin.type;
  }
  const parse22 = getProp("parse", field, plugin);
  const validate3 = getProp("validate", field, plugin);
  let format22 = field.format;
  if (!format22 && plugin && plugin.format) {
    format22 = plugin.format;
  }
  return React68.createElement(Field, {
    name: field.name,
    key: field.name,
    type,
    parse: parse22 ? (value, name2) => parse22(value, name2, field) : void 0,
    format: format22 ? (value, name2) => format22(value, name2, field) : void 0,
    validate: (value, values3, meta) => {
      if (validate3) {
        return validate3(value, values3, meta, field);
      }
    }
  }, (fieldProps) => {
    if (typeof field.component !== "string" && field.component !== null) {
      return React68.createElement(field.component, {
        ...fieldProps,
        form: form.finalForm,
        tinaForm: form,
        field
      });
    }
    if (plugin) {
      return React68.createElement(plugin.Component, {
        ...fieldProps,
        form: form.finalForm,
        tinaForm: form,
        field,
        index: index2
      });
    }
    return React68.createElement("p", null, "Unrecognized field type");
  });
};
var FieldsGroup = ({
  padding,
  children
}) => {
  return React68.createElement("div", {
    className: `relative block w-full h-full whitespace-nowrap overflow-x-visible ${padding ? `pb-5` : ``}`
  }, children);
};
function getProp(name2, field, plugin) {
  let prop = field[name2];
  if (!prop && plugin && plugin[name2]) {
    prop = plugin[name2];
  }
  return prop;
}
var FF = ReactFinalForm;
var FormLegacy = ({ form, children }) => {
  const [i15, setI] = React68.useState(0);
  React68.useEffect(() => {
    setI((i22) => i22 + 1);
  }, [form]);
  return React68.createElement(FF, {
    form: form.finalForm,
    key: `${i15}: ${form.id}`
  }, children);
};
var EditingContext = React68.createContext(false);
function TinaForm({ form, children }) {
  const [isEditing, setIsEditing] = (0, import_react117.useState)(false);
  if (!form) {
    return React68.createElement(EditingContext.Provider, {
      value: isEditing
    }, children({ isEditing, setIsEditing }));
  }
  return React68.createElement(EditingContext.Provider, {
    value: isEditing
  }, React68.createElement(FormLegacy, {
    form
  }, () => {
    return children({ isEditing, setIsEditing });
  }));
}
function TinaField({
  Component: Component9,
  children,
  ...fieldProps
}) {
  const isEditing = (0, import_react117.useContext)(EditingContext);
  if (!isEditing)
    return children || null;
  return React68.createElement(Field, {
    ...fieldProps
  }, ({ input, meta }) => {
    return React68.createElement(Component9, {
      input,
      meta,
      ...fieldProps
    });
  });
}
TinaField.propTypes = {
  name: import_prop_types20.default.string,
  type: import_prop_types20.default.string,
  Component: import_prop_types20.default.any.isRequired,
  children: import_prop_types20.default.any
};
var Button = ({
  variant = "secondary",
  as: Tag2 = "button",
  size: size2 = "medium",
  busy,
  disabled,
  rounded = "full",
  children,
  className,
  ...props
}) => {
  const baseClasses = "icon-parent border-0 inline-flex items-center font-medium focus:outline-none focus:ring-2 focus:shadow-outline text-center inline-flex justify-center transition-all duration-150 ease-out ";
  const variantClasses = {
    primary: `shadow text-white bg-blue-500 hover:bg-blue-600 focus:ring-blue-500`,
    secondary: `shadow text-gray-500 hover:text-blue-500 bg-gray-50 hover:bg-white border border-gray-200`,
    white: `shadow text-gray-500 hover:text-blue-500 bg-white hover:bg-gray-50 border border-gray-200`,
    ghost: `text-gray-500 hover:text-blue-500 hover:shadow border border-transparent hover:border-gray-200 bg-transparent`,
    danger: `shadow text-white bg-red-500 hover:bg-red-600 focus:ring-red-500`
  };
  const state = busy ? `busy` : disabled ? `disabled` : `default`;
  const stateClasses = {
    disabled: `pointer-events-none	opacity-30 cursor-not-allowed`,
    busy: `pointer-events-none opacity-70 cursor-wait`,
    default: ``
  };
  const roundedClasses = {
    full: `rounded-full`,
    left: `rounded-l-full`,
    right: `rounded-r-full`
  };
  const sizeClasses = {
    small: `text-xs h-8 px-3`,
    medium: `text-sm h-10 px-4`,
    custom: ``
  };
  return React68.createElement(Tag2, {
    className: `${baseClasses} ${variantClasses[variant]} ${sizeClasses[size2]} ${stateClasses[state]} ${roundedClasses[rounded]} ${className}`,
    ...props
  }, children);
};
var IconButton = ({
  variant = "secondary",
  size: size2 = "medium",
  busy,
  disabled,
  children,
  className,
  ...props
}) => {
  const baseClasses = "icon-parent inline-flex items-center border border-transparent text-sm font-medium focus:outline-none focus:ring-2 focus:shadow-outline text-center inline-flex justify-center transition-all duration-150 ease-out rounded-full ";
  const variantClasses = {
    primary: `shadow text-white bg-blue-500 hover:bg-blue-600 focus:ring-blue-500`,
    secondary: `shadow text-gray-500 hover:text-blue-500 bg-gray-50 hover:bg-white border border-gray-200`,
    white: `shadow text-gray-500 hover:text-blue-500 bg-white hover:bg-gray-50 border border-gray-200`,
    ghost: `text-gray-500 hover:text-blue-500 hover:shadow border border-transparent hover:border-gray-200 bg-transparent`
  };
  const state = busy ? `busy` : disabled ? `disabled` : `default`;
  const stateClasses = {
    disabled: `pointer-events-none	opacity-30 cursor-not-allowed`,
    busy: `pointer-events-none opacity-70 cursor-wait`,
    default: ``
  };
  const sizeClasses = {
    small: `h-7 w-7`,
    medium: `h-9 w-9`,
    custom: ``
  };
  return React68.createElement("button", {
    className: `${baseClasses} ${variantClasses[variant]} ${sizeClasses[size2]} ${stateClasses[state]} ${className}`,
    ...props
  }, children);
};
function FontLoader() {
  const [fontLoaded, setFontLoaded] = React68.useState(false);
  const WebFontConfig = {
    google: {
      families: ["Inter:400,600"]
    },
    loading: () => {
      setFontLoaded(true);
    }
  };
  React68.useEffect(() => {
    if (!fontLoaded) {
      import("./webfontloader-WOTMK3F5.js").then((WebFont) => {
        return WebFont.load(WebFontConfig);
      });
    }
  }, []);
  return null;
}
function classNames(...classes) {
  return classes.filter(Boolean).join(" ");
}
var OverflowMenu$1 = ({ toolbarItems }) => {
  return import_react117.default.createElement(Lt, {
    as: "div",
    className: "relative block w-full"
  }, ({ open }) => import_react117.default.createElement(import_react117.default.Fragment, null, import_react117.default.createElement(Lt.Button, {
    "data-test": "popoverRichTextButton",
    className: `cursor-pointer relative w-full justify-center inline-flex border items-center p-3 text-sm font-medium focus:outline-none pointer-events-auto ${open ? `text-blue-400` : `text-gray-300 hover:text-blue-500`}`,
    onMouseDown: (e9) => {
      e9.preventDefault();
    }
  }, import_react117.default.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    className: "h-5 w-5",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor"
  }, import_react117.default.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 2,
    d: "M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z"
  }))), import_react117.default.createElement(tt2, {
    as: import_react117.Fragment,
    enter: "transition ease-out duration-100",
    enterFrom: "transform opacity-0 scale-95",
    enterTo: "transform opacity-100 scale-100",
    leave: "transition ease-in duration-75",
    leaveFrom: "transform opacity-100 scale-100",
    leaveTo: "transform opacity-0 scale-95"
  }, import_react117.default.createElement(Lt.Panel, {
    className: "absolute z-20 origin-top-right right-0"
  }, ({ close: close2 }) => import_react117.default.createElement("div", {
    className: "mt-0 -mr-1 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none py-1"
  }, toolbarItems.map((toolbarItem) => {
    return import_react117.default.createElement("span", {
      "data-test": `${toolbarItem.name}OverflowButton`,
      key: toolbarItem.name,
      onMouseDown: (event) => {
        event.preventDefault();
        close2();
        toolbarItem.onMouseDown(event);
      },
      className: classNames(toolbarItem.active ? "bg-gray-50 text-blue-500" : "bg-white text-gray-600", "hover:bg-gray-50 hover:text-blue-500 cursor-pointer pointer-events-auto px-4 py-2 text-sm w-full flex items-center whitespace-nowrap")
    }, import_react117.default.createElement("div", {
      className: "mr-2 opacity-80"
    }, toolbarItem.Icon), " ", toolbarItem.label);
  }))))));
};
var keyframes$1 = "@keyframes loading-dots-scale-up-and-down {\n  0% {\n    transform: scale(0.1);\n  }\n\n  50% {\n    transform: scale(1);\n  }\n\n  90% {\n    transform: scale(0.1);\n  }\n\n  100% {\n    transform: scale(0.1);\n  }\n}\n";
var LoadingDots = ({
  dotSize = 8,
  color = "white"
}) => {
  return React68.createElement("div", null, React68.createElement("style", null, keyframes$1), React68.createElement(SingleDot, {
    dotSize,
    color
  }), React68.createElement(SingleDot, {
    dotSize,
    color,
    delay: 0.3
  }), React68.createElement(SingleDot, {
    dotSize,
    color,
    delay: 0.5
  }));
};
var SingleDot = ({ delay = 0, color, dotSize }) => React68.createElement("span", {
  className: "inline-block mr-1",
  style: {
    animation: "loading-dots-scale-up-and-down 2s linear infinite",
    animationDelay: `${delay}s`,
    background: color,
    width: dotSize,
    height: dotSize,
    borderRadius: dotSize
  }
});
var FormPortalContext = React68.createContext(() => {
  return null;
});
function useFormPortal() {
  return (0, import_react117.useContext)(FormPortalContext);
}
var FormPortalProvider = ({ children }) => {
  const wrapperRef = React68.useRef(null);
  const zIndexRef = React68.useRef(0);
  const FormPortal = React68.useCallback((props) => {
    if (!wrapperRef.current)
      return null;
    return (0, import_react_dom9.createPortal)(props.children({ zIndexShift: zIndexRef.current += 1 }), wrapperRef.current);
  }, [wrapperRef, zIndexRef]);
  return React68.createElement(FormPortalContext.Provider, {
    value: FormPortal
  }, React68.createElement("div", {
    ref: wrapperRef,
    style: {
      position: "relative",
      width: "100%",
      flex: "1 1 0%",
      overflow: "hidden"
    }
  }, children));
};
var ResetForm = ({
  pristine,
  reset,
  children,
  ...props
}) => {
  const [open, setOpen] = React68.useState(false);
  return React68.createElement(React68.Fragment, null, React68.createElement(Button, {
    onClick: () => {
      setOpen((p12) => !p12);
    },
    disabled: pristine,
    ...props
  }, children), open && React68.createElement(ResetModal, {
    reset,
    close: () => setOpen(false)
  }));
};
var ResetModal = ({ close: close2, reset }) => {
  return React68.createElement(Modal, null, React68.createElement(ModalPopup, null, React68.createElement(ModalHeader, {
    close: close2
  }, "Reset"), React68.createElement(ModalBody, {
    padded: true
  }, React68.createElement("p", null, "Are you sure you want to reset all changes?")), React68.createElement(ModalActions, null, React68.createElement(Button, {
    style: { flexGrow: 2 },
    onClick: close2
  }, "Cancel"), React68.createElement(Button, {
    style: { flexGrow: 3 },
    variant: "primary",
    onClick: async () => {
      await reset();
      close2();
    }
  }, "Reset"))));
};
var Dismissible = ({
  onDismiss,
  escape: escape2,
  click,
  disabled,
  allowClickPropagation,
  document: document2,
  ...props
}) => {
  const area = useDismissible({
    onDismiss,
    escape: escape2,
    click,
    disabled,
    allowClickPropagation,
    document: document2
  });
  return React68.createElement("div", {
    ref: area,
    ...props
  });
};
function useDismissible({
  onDismiss,
  escape: escape2 = false,
  click = false,
  disabled = false,
  allowClickPropagation = false,
  document: customDocument
}) {
  const area = (0, import_react117.useRef)();
  (0, import_react117.useEffect)(() => {
    const documents = customDocument ? [document, customDocument] : [document];
    const stopAndPrevent = (event) => {
      event.stopPropagation();
      event.stopImmediatePropagation();
      event.preventDefault();
    };
    const handleDocumentClick = (event) => {
      if (disabled)
        return;
      if (!area.current.contains(event.target)) {
        console.log("did not click main content", event.target, area.current);
        if (!allowClickPropagation) {
          stopAndPrevent(event);
        }
        onDismiss(event);
      }
    };
    const handleEscape = (event) => {
      if (disabled)
        return;
      if (event.keyCode === 27) {
        event.stopPropagation();
        onDismiss(event);
      }
    };
    if (click) {
      documents.forEach((document2) => document2.body.addEventListener("click", handleDocumentClick));
    }
    if (escape2) {
      documents.forEach((document2) => document2.addEventListener("keydown", handleEscape));
    }
    return () => {
      documents.forEach((document2) => {
        document2.body.removeEventListener("click", handleDocumentClick);
        document2.removeEventListener("keydown", handleEscape);
      });
    };
  }, [click, customDocument, escape2, disabled, onDismiss]);
  return area;
}
var FormActionMenu = ({ actions, form }) => {
  const [actionMenuVisibility, setActionMenuVisibility] = (0, import_react117.useState)(false);
  return React68.createElement(React68.Fragment, null, React68.createElement(MoreActionsButton, {
    onClick: () => setActionMenuVisibility((p12) => !p12)
  }), React68.createElement(ActionsOverlay, {
    open: actionMenuVisibility
  }, React68.createElement(Dismissible, {
    click: true,
    escape: true,
    disabled: !actionMenuVisibility,
    onDismiss: () => {
      setActionMenuVisibility((p12) => !p12);
    }
  }, actions.map((Action2, i15) => React68.createElement(Action2, {
    form,
    key: i15
  })))));
};
var MoreActionsButton = ({ className = "", ...props }) => React68.createElement("button", {
  className: `h-16 w-10 self-stretch bg-transparent bg-center bg-[length:auto_18px] -mr-4 ml-2 outline-none cursor-pointer transition-opacity duration-100 ease-out flex justify-center items-center hover:bg-gray-50 hover:fill-gray-700 ${className}`,
  ...props
}, React68.createElement(EllipsisVerticalIcon, null));
var ActionsOverlay = ({ open, className = "", style: style2 = {}, ...props }) => React68.createElement("div", {
  className: `min-w-[192px] rounded-3xl border border-solid border-[#efefef] block absolute bottom-5 right-5 ${open ? "opacity-100" : "opacity-0"} transition-all duration-100 ease-out origin-bottom-right shadow-[0_2px_3px_rgba(0,0,0,0.05)] bg-white overflow-hidden z-10 ${className}`,
  style: {
    transform: open ? "translate3d(0, -28px, 0) scale3d(1, 1, 1)" : "translate3d(0, 0, 0) scale3d(0.5, 0.5, 1)",
    pointerEvents: open ? "all" : "none",
    ...style2
  },
  ...props
});
var ActionButton = ({ className = "", ...props }) => React68.createElement("button", {
  className: `relative text-center text-[13px] px-3 h-10 font-normal w-full bg-none cursor-pointer outline-none border-0 transition-all duration-[150ms] ease-out hover:text-blue-500 hover:bg-gray50 [&:not(:last-child)]: border-b-[1px] border-solid border-b-[#edecf3] ${className}`,
  ...props
});
var NoFieldsPlaceholder = () => React68.createElement("div", {
  className: "relative flex flex-col items-center justify-center text-center p-5 pb-16 w-full h-full overflow-y-auto",
  style: {
    animationName: "fade-in",
    animationDelay: "300ms",
    animationTimingFunction: "ease-out",
    animationIterationCount: 1,
    animationFillMode: "both",
    animationDuration: "150ms"
  }
}, React68.createElement(Emoji$1, {
  className: "block pb-5"
}, "🤔"), React68.createElement("h3", {
  className: "font-sans font-normal text-lg block pb-5"
}, "Hey, you don't have any fields added to this form."), React68.createElement("p", {
  className: "block pb-5"
}, React68.createElement("a", {
  className: "text-center rounded-3xl border border-solid border-gray-100 shadow-[0_2px_3px_rgba(0,0,0,0.12)] font-normal cursor-pointer text-[12px] transition-all duration-100 ease-out bg-white text-gray-700 py-3 pr-5 pl-14 relative no-underline inline-block hover:text-blue-500",
  href: "https://tinacms.org/docs/fields",
  target: "_blank"
}, React68.createElement(Emoji$1, {
  className: "absolute left-5 top-1/2 origin-center -translate-y-1/2 transition-all duration-100 ease-out",
  style: { fontSize: 24 }
}, "📖"), " ", "Field Setup Guide")));
var FormKeyBindings = ({ onSubmit }) => {
  (0, import_react117.useEffect)(() => {
    const handleKeyDown = (e9) => {
      if ((e9.metaKey || e9.ctrlKey) && e9.key === "s") {
        e9.preventDefault();
        onSubmit();
      }
    };
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, [onSubmit]);
  return null;
};
var FormBuilder = ({
  form: tinaForm,
  onPristineChange,
  ...rest
}) => {
  const hideFooter = !!rest.hideFooter;
  const [i15, setI] = React68.useState(0);
  React68.useEffect(() => {
    setI((i22) => i22 + 1);
  }, [tinaForm]);
  const finalForm = tinaForm.finalForm;
  const moveArrayItem = React68.useCallback((result) => {
    if (!result.destination || !finalForm)
      return;
    const name2 = result.type;
    finalForm.mutators.move(name2, result.source.index, result.destination.index);
  }, [tinaForm]);
  React68.useEffect(() => {
    const unsubscribe = finalForm.subscribe(({ pristine }) => {
      if (onPristineChange) {
        onPristineChange(pristine);
      }
    }, { pristine: true });
    return () => {
      unsubscribe();
    };
  }, [finalForm]);
  useOnChangeEventDispatch({ finalForm, tinaForm });
  return React68.createElement(ReactFinalForm, {
    form: finalForm,
    key: `${i15}: ${tinaForm.id}`,
    onSubmit: tinaForm.onSubmit
  }, ({
    handleSubmit,
    pristine,
    invalid,
    submitting,
    dirtySinceLastSubmit,
    hasValidationErrors
  }) => {
    const canSubmit = !pristine && !submitting && !hasValidationErrors && !(invalid && !dirtySinceLastSubmit);
    const safeHandleSubmit = () => {
      if (canSubmit) {
        handleSubmit();
      }
    };
    return React68.createElement(React68.Fragment, null, React68.createElement(DragDropContext, {
      onDragEnd: moveArrayItem
    }, React68.createElement(FormKeyBindings, {
      onSubmit: safeHandleSubmit
    }), React68.createElement(FormPortalProvider, null, React68.createElement(FormWrapper$1, {
      id: tinaForm.id
    }, tinaForm && tinaForm.fields.length ? React68.createElement(FieldsBuilder, {
      form: tinaForm,
      fields: tinaForm.fields
    }) : React68.createElement(NoFieldsPlaceholder, null))), !hideFooter && React68.createElement("div", {
      className: "relative flex-none w-full h-16 px-6 bg-white border-t border-gray-100	flex items-center justify-center"
    }, React68.createElement("div", {
      className: "flex-1 w-full flex justify-between gap-4 items-center max-w-form"
    }, tinaForm.reset && React68.createElement(ResetForm, {
      pristine,
      reset: async () => {
        finalForm.reset();
        await tinaForm.reset();
      },
      style: { flexGrow: 1 }
    }, tinaForm.buttons.reset), React68.createElement(Button, {
      onClick: safeHandleSubmit,
      disabled: !canSubmit,
      busy: submitting,
      variant: "primary",
      style: { flexGrow: 3 }
    }, submitting && React68.createElement(LoadingDots, null), !submitting && tinaForm.buttons.save), tinaForm.actions.length > 0 && React68.createElement(FormActionMenu, {
      form: tinaForm,
      actions: tinaForm.actions
    })))));
  });
};
var FullscreenFormBuilder = ({
  form: tinaForm,
  label
}) => {
  const [i15, setI] = React68.useState(0);
  React68.useEffect(() => {
    setI((i22) => i22 + 1);
  }, [tinaForm]);
  const finalForm = tinaForm.finalForm;
  const moveArrayItem = React68.useCallback((result) => {
    if (!result.destination || !finalForm)
      return;
    const name2 = result.type;
    finalForm.mutators.move(name2, result.source.index, result.destination.index);
  }, [tinaForm]);
  return React68.createElement(ModalProvider, null, React68.createElement(ReactFinalForm, {
    form: finalForm,
    key: `${i15}: ${tinaForm.id}`,
    onSubmit: tinaForm.onSubmit
  }, ({ handleSubmit, pristine, invalid, submitting }) => {
    const canSubmit = !pristine && !submitting && !invalid;
    const safeHandleSubmit = () => {
      if (canSubmit) {
        handleSubmit();
      }
    };
    return React68.createElement(DragDropContext, {
      onDragEnd: moveArrayItem
    }, React68.createElement(FormKeyBindings, {
      onSubmit: safeHandleSubmit
    }), React68.createElement("div", {
      className: "w-full h-screen flex flex-col items-center"
    }, React68.createElement("div", {
      className: "px-6 py-4 w-full bg-white border-b border-gray-150 shadow-sm sticky flex flex-wrap gap-x-6 gap-y-3 justify-between items-center"
    }, label && React68.createElement("h4", {
      className: "font-bold font-sans text-lg opacity-80"
    }, label), React68.createElement("div", {
      className: "flex flex-1 gap-4 items-center justify-end"
    }, React68.createElement(FormStatus, {
      pristine
    }), tinaForm.reset && React68.createElement(ResetForm, {
      pristine,
      reset: async () => {
        finalForm.reset();
        await tinaForm.reset();
      },
      style: { flexBasis: "7rem" }
    }, tinaForm.buttons.reset), React68.createElement(Button, {
      onClick: safeHandleSubmit,
      disabled: !canSubmit,
      busy: submitting,
      variant: "primary",
      style: { flexBasis: "10rem" }
    }, submitting && React68.createElement(LoadingDots, null), !submitting && tinaForm.buttons.save), tinaForm.actions.length > 0 && React68.createElement(FormActionMenu, {
      form: tinaForm,
      actions: tinaForm.actions
    }))), React68.createElement(FormPortalProvider, null, React68.createElement(FormWrapper$1, {
      id: tinaForm.id
    }, tinaForm && tinaForm.fields.length ? React68.createElement(FieldsBuilder, {
      form: tinaForm,
      fields: tinaForm.fields
    }) : React68.createElement(NoFieldsPlaceholder, null)))));
  }));
};
var FormStatus = ({ pristine }) => {
  return React68.createElement("div", {
    className: "flex flex-0 items-center"
  }, !pristine && React68.createElement(React68.Fragment, null, React68.createElement("span", {
    className: "w-3 h-3 flex-0 rounded-full bg-yellow-400 border border-yellow-500 mr-2"
  }), " ", React68.createElement("p", {
    className: "text-gray-700 text-sm leading-tight whitespace-nowrap"
  }, "Unsaved Changes")), pristine && React68.createElement(React68.Fragment, null, React68.createElement("span", {
    className: "w-3 h-3 flex-0 rounded-full bg-green-300 border border-green-400 mr-2"
  }), " ", React68.createElement("p", {
    className: "text-gray-500 text-sm leading-tight whitespace-nowrap"
  }, "No Changes")));
};
var FormWrapper$1 = ({ children, id }) => {
  return React68.createElement("div", {
    "data-test": `form:${id == null ? void 0 : id.replace(/\\/g, "/")}`,
    className: "h-full overflow-y-auto max-h-full bg-gray-50 py-5 px-6"
  }, React68.createElement("div", {
    className: "w-full flex justify-center"
  }, React68.createElement("div", {
    className: "w-full max-w-form"
  }, children)));
};
var useOnChangeEventDispatch = ({
  finalForm,
  tinaForm
}) => {
  const [formValues, setFormValues] = React68.useState({});
  const [newUpdate, setNewUpdate] = React68.useState(null);
  const { subscribe } = finalForm;
  React68.useEffect(() => {
    subscribe(({ values: values3 }) => {
      setFormValues(values3);
    }, { values: true });
  }, [subscribe, setFormValues]);
  const cms = useCMS$1();
  React68.useEffect(() => {
    var _a;
    if ((newUpdate == null ? void 0 : newUpdate.name) === "reset") {
      cms.events.dispatch({
        type: `forms:reset`,
        value: null,
        mutationType: newUpdate.mutationType,
        formId: tinaForm.id
      });
      setNewUpdate(null);
    } else if (newUpdate == null ? void 0 : newUpdate.name) {
      const previousValue = (_a = newUpdate == null ? void 0 : newUpdate.field) == null ? void 0 : _a.value;
      const newValue = getIn(formValues, newUpdate == null ? void 0 : newUpdate.name);
      cms.events.dispatch({
        type: `forms:fields:onChange`,
        value: newValue,
        previousValue,
        mutationType: newUpdate.mutationType,
        formId: tinaForm.id,
        field: newUpdate.field
      });
      setNewUpdate(null);
    }
  }, [JSON.stringify(formValues), cms]);
  const { change, reset } = finalForm;
  const { insert: insert3, move: move5, remove: remove3, ...moreMutators } = finalForm.mutators;
  const prepareNewUpdate = (name2, mutationType) => {
    setNewUpdate({
      name: name2,
      field: finalForm.getFieldState(name2),
      mutationType
    });
  };
  React68.useMemo(() => {
    finalForm.reset = (initialValues) => {
      prepareNewUpdate("reset", { type: "reset" });
      return reset(initialValues);
    };
    finalForm.change = (name2, value) => {
      prepareNewUpdate(name2.toString(), { type: "change" });
      return change(name2, value);
    };
    finalForm.mutators = {
      insert: (...args) => {
        prepareNewUpdate(args[0], { type: "insert", at: args[1] });
        insert3(...args);
      },
      move: (...args) => {
        prepareNewUpdate(args[0], {
          type: "move",
          from: args[1],
          to: args[2]
        });
        move5(...args);
      },
      remove: (...args) => {
        prepareNewUpdate(args[0], { type: "remove", at: args[1] });
        remove3(...args);
      },
      ...moreMutators
    };
  }, [JSON.stringify(formValues)]);
};
var Emoji$1 = ({ className = "", ...props }) => React68.createElement("span", {
  className: `text-[40px] leading-none inline-block ${className}`,
  ...props
});
var DefaultContext = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var IconContext = import_react117.default.createContext && import_react117.default.createContext(DefaultContext);
var __assign5 = globalThis && globalThis.__assign || function() {
  __assign5 = Object.assign || function(t20) {
    for (var s20, i15 = 1, n12 = arguments.length; i15 < n12; i15++) {
      s20 = arguments[i15];
      for (var p12 in s20)
        if (Object.prototype.hasOwnProperty.call(s20, p12))
          t20[p12] = s20[p12];
    }
    return t20;
  };
  return __assign5.apply(this, arguments);
};
var __rest = globalThis && globalThis.__rest || function(s20, e9) {
  var t20 = {};
  for (var p12 in s20)
    if (Object.prototype.hasOwnProperty.call(s20, p12) && e9.indexOf(p12) < 0)
      t20[p12] = s20[p12];
  if (s20 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i15 = 0, p12 = Object.getOwnPropertySymbols(s20); i15 < p12.length; i15++) {
      if (e9.indexOf(p12[i15]) < 0 && Object.prototype.propertyIsEnumerable.call(s20, p12[i15]))
        t20[p12[i15]] = s20[p12[i15]];
    }
  return t20;
};
function Tree2Element(tree) {
  return tree && tree.map(function(node, i15) {
    return import_react117.default.createElement(node.tag, __assign5({
      key: i15
    }, node.attr), Tree2Element(node.child));
  });
}
function GenIcon(data) {
  return function(props) {
    return import_react117.default.createElement(IconBase, __assign5({
      attr: __assign5({}, data.attr)
    }, props), Tree2Element(data.child));
  };
}
function IconBase(props) {
  var elem = function(conf) {
    var attr = props.attr, size2 = props.size, title = props.title, svgProps = __rest(props, ["attr", "size", "title"]);
    var computedSize = size2 || conf.size || "1em";
    var className;
    if (conf.className)
      className = conf.className;
    if (props.className)
      className = (className ? className + " " : "") + props.className;
    return import_react117.default.createElement("svg", __assign5({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className,
      style: __assign5(__assign5({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title && import_react117.default.createElement("title", null, title), props.children);
  };
  return IconContext !== void 0 ? import_react117.default.createElement(IconContext.Consumer, null, function(conf) {
    return elem(conf);
  }) : elem(DefaultContext);
}
function BiArrowToBottom(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M6 18h12v2H6zm5-14v8.586L6.707 8.293 5.293 9.707 12 16.414l6.707-6.707-1.414-1.414L13 12.586V4z" } }] })(props);
}
function BiCheck(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "m10 15.586-3.293-3.293-1.414 1.414L10 18.414l9.707-9.707-1.414-1.414z" } }] })(props);
}
function BiChevronDown(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M16.293 9.293 12 13.586 7.707 9.293l-1.414 1.414L12 16.414l5.707-5.707z" } }] })(props);
}
function BiChevronLeft(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M13.293 6.293 7.586 12l5.707 5.707 1.414-1.414L10.414 12l4.293-4.293z" } }] })(props);
}
function BiCloudUpload(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M13 19v-4h3l-4-5-4 5h3v4z" } }, { "tag": "path", "attr": { "d": "M7 19h2v-2H7c-1.654 0-3-1.346-3-3 0-1.404 1.199-2.756 2.673-3.015l.581-.102.192-.558C8.149 8.274 9.895 7 12 7c2.757 0 5 2.243 5 5v1h1c1.103 0 2 .897 2 2s-.897 2-2 2h-3v2h3c2.206 0 4-1.794 4-4a4.01 4.01 0 0 0-3.056-3.888C18.507 7.67 15.56 5 12 5 9.244 5 6.85 6.611 5.757 9.15 3.609 9.792 2 11.82 2 14c0 2.757 2.243 5 5 5z" } }] })(props);
}
function BiCopyAlt(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M20 2H10c-1.103 0-2 .897-2 2v4H4c-1.103 0-2 .897-2 2v10c0 1.103.897 2 2 2h10c1.103 0 2-.897 2-2v-4h4c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zM4 20V10h10l.002 10H4zm16-6h-4v-4c0-1.103-.897-2-2-2h-4V4h10v10z" } }, { "tag": "path", "attr": { "d": "M6 12h6v2H6zm0 4h6v2H6z" } }] })(props);
}
function BiEdit(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "m7 17.013 4.413-.015 9.632-9.54c.378-.378.586-.88.586-1.414s-.208-1.036-.586-1.414l-1.586-1.586c-.756-.756-2.075-.752-2.825-.003L7 12.583v4.43zM18.045 4.458l1.589 1.583-1.597 1.582-1.586-1.585 1.594-1.58zM9 13.417l6.03-5.973 1.586 1.586-6.029 5.971L9 15.006v-1.589z" } }, { "tag": "path", "attr": { "d": "M5 21h14c1.103 0 2-.897 2-2v-8.668l-2 2V19H8.158c-.026 0-.053.01-.079.01-.033 0-.066-.009-.1-.01H5V5h6.847l2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2z" } }] })(props);
}
function BiError(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M11.001 10h2v5h-2zM11 16h2v2h-2z" } }, { "tag": "path", "attr": { "d": "M13.768 4.2C13.42 3.545 12.742 3.138 12 3.138s-1.42.407-1.768 1.063L2.894 18.064a1.986 1.986 0 0 0 .054 1.968A1.984 1.984 0 0 0 4.661 21h14.678c.708 0 1.349-.362 1.714-.968a1.989 1.989 0 0 0 .054-1.968L13.768 4.2zM4.661 19 12 5.137 19.344 19H4.661z" } }] })(props);
}
function BiExit(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M19.002 3h-14c-1.103 0-2 .897-2 2v4h2V5h14v14h-14v-4h-2v4c0 1.103.897 2 2 2h14c1.103 0 2-.897 2-2V5c0-1.103-.898-2-2-2z" } }, { "tag": "path", "attr": { "d": "m11 16 5-4-5-4v3.001H3v2h8z" } }] })(props);
}
function BiFileBlank(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M19.937 8.68c-.011-.032-.02-.063-.033-.094a.997.997 0 0 0-.196-.293l-6-6a.997.997 0 0 0-.293-.196c-.03-.014-.062-.022-.094-.033a.991.991 0 0 0-.259-.051C13.04 2.011 13.021 2 13 2H6c-1.103 0-2 .897-2 2v16c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2V9c0-.021-.011-.04-.013-.062a.99.99 0 0 0-.05-.258zM16.586 8H14V5.414L16.586 8zM6 20V4h6v5a1 1 0 0 0 1 1h5l.002 10H6z" } }] })(props);
}
function BiFile(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M19.903 8.586a.997.997 0 0 0-.196-.293l-6-6a.997.997 0 0 0-.293-.196c-.03-.014-.062-.022-.094-.033a.991.991 0 0 0-.259-.051C13.04 2.011 13.021 2 13 2H6c-1.103 0-2 .897-2 2v16c0 1.103.897 2 2 2h12c1.103 0 2-.897 2-2V9c0-.021-.011-.04-.013-.062a.952.952 0 0 0-.051-.259c-.01-.032-.019-.063-.033-.093zM16.586 8H14V5.414L16.586 8zM6 20V4h6v5a1 1 0 0 0 1 1h5l.002 10H6z" } }, { "tag": "path", "attr": { "d": "M8 12h8v2H8zm0 4h8v2H8zm0-8h2v2H8z" } }] })(props);
}
function BiFolder(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M20 5h-8.586L9.707 3.293A.997.997 0 0 0 9 3H4c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2h16c1.103 0 2-.897 2-2V7c0-1.103-.897-2-2-2zM4 19V7h16l.002 12H4z" } }] })(props);
}
function BiGitBranch(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M17.5 4C15.57 4 14 5.57 14 7.5c0 1.554 1.025 2.859 2.43 3.315-.146.932-.547 1.7-1.23 2.323-1.946 1.773-5.527 1.935-7.2 1.907V8.837c1.44-.434 2.5-1.757 2.5-3.337C10.5 3.57 8.93 2 7 2S3.5 3.57 3.5 5.5c0 1.58 1.06 2.903 2.5 3.337v6.326c-1.44.434-2.5 1.757-2.5 3.337C3.5 20.43 5.07 22 7 22s3.5-1.57 3.5-3.5c0-.551-.14-1.065-.367-1.529 2.06-.186 4.657-.757 6.409-2.35 1.097-.997 1.731-2.264 1.904-3.768C19.915 10.438 21 9.1 21 7.5 21 5.57 19.43 4 17.5 4zm-12 1.5C5.5 4.673 6.173 4 7 4s1.5.673 1.5 1.5S7.827 7 7 7s-1.5-.673-1.5-1.5zM7 20c-.827 0-1.5-.673-1.5-1.5a1.5 1.5 0 0 1 1.482-1.498l.13.01A1.495 1.495 0 0 1 7 20zM17.5 9c-.827 0-1.5-.673-1.5-1.5S16.673 6 17.5 6s1.5.673 1.5 1.5S18.327 9 17.5 9z" } }] })(props);
}
function BiGitRepoForked(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M5.559 8.855c.166 1.183.789 3.207 3.087 4.079C11 13.829 11 14.534 11 15v.163c-1.44.434-2.5 1.757-2.5 3.337 0 1.93 1.57 3.5 3.5 3.5s3.5-1.57 3.5-3.5c0-1.58-1.06-2.903-2.5-3.337V15c0-.466 0-1.171 2.354-2.065 2.298-.872 2.921-2.896 3.087-4.079C19.912 8.441 21 7.102 21 5.5 21 3.57 19.43 2 17.5 2S14 3.57 14 5.5c0 1.552 1.022 2.855 2.424 3.313-.146.735-.565 1.791-1.778 2.252-1.192.452-2.053.953-2.646 1.536-.593-.583-1.453-1.084-2.646-1.536-1.213-.461-1.633-1.517-1.778-2.252C8.978 8.355 10 7.052 10 5.5 10 3.57 8.43 2 6.5 2S3 3.57 3 5.5c0 1.602 1.088 2.941 2.559 3.355zM17.5 4c.827 0 1.5.673 1.5 1.5S18.327 7 17.5 7 16 6.327 16 5.5 16.673 4 17.5 4zm-4 14.5c0 .827-.673 1.5-1.5 1.5s-1.5-.673-1.5-1.5.673-1.5 1.5-1.5 1.5.673 1.5 1.5zM6.5 4C7.327 4 8 4.673 8 5.5S7.327 7 6.5 7 5 6.327 5 5.5 5.673 4 6.5 4z" } }] })(props);
}
function BiGridAlt(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M10 3H4a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1zM9 9H5V5h4v4zm5 2h6a1 1 0 0 0 1-1V4a1 1 0 0 0-1-1h-6a1 1 0 0 0-1 1v6a1 1 0 0 0 1 1zm1-6h4v4h-4V5zM3 20a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-6a1 1 0 0 0-1-1H4a1 1 0 0 0-1 1v6zm2-5h4v4H5v-4zm8 5a1 1 0 0 0 1 1h6a1 1 0 0 0 1-1v-6a1 1 0 0 0-1-1h-6a1 1 0 0 0-1 1v6zm2-5h4v4h-4v-4z" } }] })(props);
}
function BiLeftArrowAlt(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M12.707 17.293 8.414 13H18v-2H8.414l4.293-4.293-1.414-1.414L4.586 12l6.707 6.707z" } }] })(props);
}
function BiListUl(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M4 6h2v2H4zm0 5h2v2H4zm0 5h2v2H4zm16-8V6H8.023v2H18.8zM8 11h12v2H8zm0 5h12v2H8z" } }] })(props);
}
function BiMenu(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z" } }] })(props);
}
function BiPencil(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M4 21a1 1 0 0 0 .24 0l4-1a1 1 0 0 0 .47-.26L21 7.41a2 2 0 0 0 0-2.82L19.42 3a2 2 0 0 0-2.83 0L4.3 15.29a1.06 1.06 0 0 0-.27.47l-1 4A1 1 0 0 0 3.76 21 1 1 0 0 0 4 21zM18 4.41 19.59 6 18 7.59 16.42 6zM5.91 16.51 15 7.41 16.59 9l-9.1 9.1-2.11.52z" } }] })(props);
}
function BiPlus(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M19 11h-6V5h-2v6H5v2h6v6h2v-6h6z" } }] })(props);
}
function BiRefresh(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M10 11H7.101l.001-.009a4.956 4.956 0 0 1 .752-1.787 5.054 5.054 0 0 1 2.2-1.811c.302-.128.617-.226.938-.291a5.078 5.078 0 0 1 2.018 0 4.978 4.978 0 0 1 2.525 1.361l1.416-1.412a7.036 7.036 0 0 0-2.224-1.501 6.921 6.921 0 0 0-1.315-.408 7.079 7.079 0 0 0-2.819 0 6.94 6.94 0 0 0-1.316.409 7.04 7.04 0 0 0-3.08 2.534 6.978 6.978 0 0 0-1.054 2.505c-.028.135-.043.273-.063.41H2l4 4 4-4zm4 2h2.899l-.001.008a4.976 4.976 0 0 1-2.103 3.138 4.943 4.943 0 0 1-1.787.752 5.073 5.073 0 0 1-2.017 0 4.956 4.956 0 0 1-1.787-.752 5.072 5.072 0 0 1-.74-.61L7.05 16.95a7.032 7.032 0 0 0 2.225 1.5c.424.18.867.317 1.315.408a7.07 7.07 0 0 0 2.818 0 7.031 7.031 0 0 0 4.395-2.945 6.974 6.974 0 0 0 1.053-2.503c.027-.135.043-.273.063-.41H22l-4-4-4 4z" } }] })(props);
}
function BiRightArrowAlt(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "m11.293 17.293 1.414 1.414L19.414 12l-6.707-6.707-1.414 1.414L15.586 11H6v2h9.586z" } }] })(props);
}
function BiSearch(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M10 18a7.952 7.952 0 0 0 4.897-1.688l4.396 4.396 1.414-1.414-4.396-4.396A7.952 7.952 0 0 0 18 10c0-4.411-3.589-8-8-8s-8 3.589-8 8 3.589 8 8 8zm0-14c3.309 0 6 2.691 6 6s-2.691 6-6 6-6-2.691-6-6 2.691-6 6-6z" } }] })(props);
}
function BiX(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "m16.192 6.344-4.243 4.242-4.242-4.242-1.414 1.414L10.535 12l-4.242 4.242 1.414 1.414 4.242-4.242 4.243 4.242 1.414-1.414L13.364 12l4.242-4.242z" } }] })(props);
}
function IoMdClose(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M405 136.798L375.202 107 256 226.202 136.798 107 107 136.798 226.202 256 107 375.202 136.798 405 256 285.798 375.202 405 405 375.202 285.798 256z" } }] })(props);
}
function IoMdSync(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M256 93.09V32l-80 81.454 80 81.456v-61.093c65.996 0 120 54.982 120 122.183 0 20.363-5 39.714-14.004 57.016L391 342.547c15.996-25.457 25-54.988 25-86.547 0-89.599-72.002-162.91-160-162.91zm0 285.094c-66.001 0-120-54.988-120-122.184 0-20.363 5-39.709 13.999-57.02L121 169.454C104.999 193.89 96 224.436 96 256c0 89.599 72.002 162.91 160 162.91V480l80-81.453-80-81.457v61.094z" } }] })(props);
}
var Group$1 = wrapFieldWithError(({ tinaForm, field }) => {
  const cms = useCMS$1();
  const [isExpanded2, setExpanded] = React68.useState(false);
  return React68.createElement(React68.Fragment, null, React68.createElement(Header, {
    onClick: () => {
      const state = tinaForm.finalForm.getState();
      if (state.invalid === true) {
        cms.alerts.error("Cannot navigate away from an invalid form.");
        return;
      }
      setExpanded((p12) => !p12);
    }
  }, field.label || field.name), React68.createElement(Panel$2, {
    isExpanded: isExpanded2,
    setExpanded,
    field,
    tinaForm
  }));
});
var Panel$2 = function Panel2({
  setExpanded,
  isExpanded: isExpanded2,
  tinaForm,
  field
}) {
  const cms = useCMS$1();
  const FormPortal = useFormPortal();
  const fields = React68.useMemo(() => {
    return field.fields.map((subField) => ({
      ...subField,
      name: `${field.name}.${subField.name}`
    }));
  }, [field.fields, field.name]);
  return React68.createElement(FormPortal, null, ({ zIndexShift }) => React68.createElement(GroupPanel, {
    isExpanded: isExpanded2,
    style: { zIndex: zIndexShift + 1e3 }
  }, React68.createElement(PanelHeader, {
    onClick: () => {
      const state = tinaForm.finalForm.getState();
      if (state.invalid === true) {
        cms.alerts.error("Cannot navigate away from an invalid form.");
        return;
      }
      setExpanded(false);
    }
  }, field.label || field.name), React68.createElement(PanelBody, {
    id: tinaForm.id
  }, isExpanded2 ? React68.createElement(FieldsBuilder, {
    form: tinaForm,
    fields
  }) : null)));
};
var Header = ({ onClick, children }) => {
  return React68.createElement("div", {
    className: "pt-1 mb-5"
  }, React68.createElement("button", {
    onClick,
    className: "group px-4 py-3 bg-white hover:bg-gray-50 shadow focus:shadow-outline focus:border-blue-500 w-full border border-gray-100 hover:border-gray-200 text-gray-500 hover:text-blue-400 focus:text-blue-500 rounded-md flex justify-between items-center gap-2"
  }, React68.createElement("span", {
    className: "text-left text-base font-medium overflow-hidden text-ellipsis whitespace-nowrap flex-1"
  }, children), " ", React68.createElement(BiPencil, {
    className: "h-6 w-auto transition-opacity duration-150 ease-out opacity-80 group-hover:opacity-90"
  })));
};
var PanelHeader = ({ onClick, children }) => {
  return React68.createElement("button", {
    className: `relative z-40 group text-left w-full bg-white hover:bg-gray-50 py-2 border-t border-b shadow-sm
       border-gray-100 px-6 -mt-px`,
    onClick,
    tabIndex: -1
  }, React68.createElement("div", {
    className: "flex items-center justify-between gap-3 text-xs tracking-wide font-medium text-gray-700 group-hover:text-blue-400 uppercase max-w-form mx-auto"
  }, children, React68.createElement(IoMdClose, {
    className: "h-auto w-5 inline-block opacity-70 -mt-0.5 -mx-0.5"
  })));
};
var PanelBody = ({ id, children }) => {
  return React68.createElement("div", {
    style: {
      flex: "1 1 0%",
      width: "100%",
      overflowY: "auto",
      background: "var(--tina-color-grey-1)"
    }
  }, React68.createElement(FormWrapper$1, {
    id
  }, children));
};
var GroupPanel = ({
  isExpanded: isExpanded2,
  className = "",
  style: style2 = {},
  ...props
}) => React68.createElement("div", {
  className: `absolute w-full top-0 bottom-0 left-0 flex flex-col justify-between overflow-hidden z-10 ${className}`,
  style: {
    pointerEvents: isExpanded2 ? "all" : "none",
    ...isExpanded2 ? {
      animationName: "fly-in-left",
      animationDuration: "150ms",
      animationDelay: "0",
      animationIterationCount: 1,
      animationTimingFunction: "ease-out",
      animationFillMode: "backwards"
    } : {
      transition: "transform 150ms ease-out",
      transform: "translate3d(100%, 0, 0)"
    },
    ...style2
  },
  ...props
});
function GroupField(props) {
  return React68.createElement("div", null, "Subfield: ", props.field.label || props.field.name);
}
var GroupFieldPlugin = {
  name: "group",
  Component: Group$1
};
var NestedForm = (props) => {
  const FormPortal = useFormPortal();
  const id = import_react117.default.useMemo(() => uuid(), [props.id]);
  const form = import_react117.default.useMemo(() => {
    return new Form({
      ...props,
      id,
      onChange: ({ values: values3 }) => {
        props.onChange(values3);
      },
      onSubmit: () => {
      }
    });
  }, [id]);
  return import_react117.default.createElement(FormPortal, null, ({ zIndexShift }) => import_react117.default.createElement(GroupPanel, {
    isExpanded: true,
    style: { zIndex: zIndexShift + 1e3 }
  }, import_react117.default.createElement(PanelHeader, {
    onClick: props.onClose
  }, props.label), import_react117.default.createElement(FormBuilder, {
    form,
    hideFooter: true
  })));
};
var handleCloseBase = (editor, element) => {
  const path = ReactEditor.findPath(editor, element);
  const editorEl = ReactEditor.toDOMNode(editor, editor);
  if (editorEl) {
    editorEl.focus();
    setTimeout(() => {
      Transforms.select(editor, path);
    }, 1);
  }
};
var handleRemoveBase = (editor, element) => {
  const path = ReactEditor.findPath(editor, element);
  Transforms.removeNodes(editor, {
    at: path
  });
};
var useHotkey = (key, callback) => {
  const selected = useSelected();
  import_react117.default.useEffect(() => {
    const handleEnter = (e9) => {
      if (selected) {
        if ((0, import_is_hotkey2.default)(key, e9)) {
          e9.preventDefault();
          callback();
        }
      }
    };
    document.addEventListener("keydown", handleEnter);
    return () => document.removeEventListener("keydown", handleEnter);
  }, [selected]);
};
var useEmbedHandles = (editor, element) => {
  const [isExpanded2, setIsExpanded] = import_react117.default.useState(false);
  const handleClose = () => {
    setIsExpanded(false);
    handleCloseBase(editor, element);
  };
  const handleSelect = (e9) => {
    e9.preventDefault();
    setIsExpanded(true);
  };
  const handleRemove = () => {
    handleRemoveBase(editor, element);
  };
  return { isExpanded: isExpanded2, handleClose, handleRemove, handleSelect };
};
var EditorContext2 = import_react117.default.createContext({
  rawMode: false,
  setRawMode: () => {
  },
  templates: []
});
var useEditorContext = () => {
  return import_react117.default.useContext(EditorContext2);
};
var useTemplates = () => {
  const { templates } = import_react117.default.useContext(EditorContext2);
  return templates;
};
var Wrapper = ({ inline: inline2, children }) => {
  const Component9 = inline2 ? "span" : "div";
  return import_react117.default.createElement(Component9, {
    contentEditable: false,
    style: { userSelect: "none" },
    className: "relative"
  }, children);
};
var InlineEmbed = ({
  attributes,
  children,
  element,
  onChange,
  editor
}) => {
  const selected = useSelected();
  const { handleClose, handleRemove, handleSelect, isExpanded: isExpanded2 } = useEmbedHandles(editor, element);
  useHotkey("enter", () => {
    insertNodes(editor, [{ type: ELEMENT_PARAGRAPH, children: [{ text: "" }] }]);
  });
  useHotkey("space", () => {
    insertNodes(editor, [{ text: " " }], {
      match: (n12) => {
        if (Element2.isElement(n12) && n12.type === ELEMENT_MDX_INLINE) {
          return true;
        }
      },
      select: true
    });
  });
  const templates = useTemplates();
  const activeTemplate = templates.find((template) => template.name === element.name);
  const formProps = {
    activeTemplate,
    element,
    editor,
    onChange,
    onClose: handleClose
  };
  if (!activeTemplate) {
    return null;
  }
  const label = getLabel(activeTemplate, formProps);
  return import_react117.default.createElement("span", {
    ...attributes
  }, children, import_react117.default.createElement(Wrapper, {
    inline: true
  }, import_react117.default.createElement("span", {
    style: { margin: "0 0.5px" },
    className: "relative inline-flex shadow-sm rounded-md leading-none"
  }, selected && import_react117.default.createElement("span", {
    className: "absolute inset-0 ring-2 ring-blue-100 ring-inset rounded-md z-10 pointer-events-none"
  }), import_react117.default.createElement("span", {
    style: { fontWeight: "inherit", maxWidth: "275px" },
    className: "truncate cursor-pointer relative inline-flex items-center justify-start px-2 py-0.5 rounded-l-md border border-gray-200 bg-white  hover:bg-gray-50 focus:z-10 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500",
    onMouseDown: handleSelect
  }, label), import_react117.default.createElement(DotMenu, {
    onOpen: handleSelect,
    onRemove: handleRemove
  })), isExpanded2 && import_react117.default.createElement(EmbedNestedForm, {
    ...formProps
  })));
};
var BlockEmbed = ({
  attributes,
  children,
  element,
  editor,
  onChange
}) => {
  const selected = useSelected();
  const { handleClose, handleRemove, handleSelect, isExpanded: isExpanded2 } = useEmbedHandles(editor, element);
  useHotkey("enter", () => {
    insertNodes(editor, [{ type: ELEMENT_PARAGRAPH, children: [{ text: "" }] }]);
  });
  const templates = useTemplates();
  const activeTemplate = templates.find((template) => template.name === element.name);
  const formProps = {
    activeTemplate,
    element,
    editor,
    onChange,
    onClose: handleClose
  };
  if (!activeTemplate) {
    return null;
  }
  const label = getLabel(activeTemplate, formProps);
  return import_react117.default.createElement("div", {
    ...attributes,
    className: "w-full my-2"
  }, children, import_react117.default.createElement(Wrapper, {
    inline: false
  }, import_react117.default.createElement("span", {
    className: "relative w-full inline-flex shadow-sm rounded-md"
  }, selected && import_react117.default.createElement("span", {
    className: "absolute inset-0 ring-2 ring-blue-100 ring-inset rounded-md z-10 pointer-events-none"
  }), import_react117.default.createElement("span", {
    onMouseDown: handleSelect,
    className: "truncate cursor-pointer w-full relative inline-flex items-center justify-start px-4 py-2 rounded-l-md border border-gray-200 bg-white text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
  }, label), import_react117.default.createElement(DotMenu, {
    onOpen: handleSelect,
    onRemove: handleRemove
  })), isExpanded2 && import_react117.default.createElement(EmbedNestedForm, {
    ...formProps
  })));
};
var getLabel = (activeTemplate, formProps) => {
  const titleField = activeTemplate.fields.find((field) => field.isTitle);
  let label = activeTemplate.label || activeTemplate.name;
  if (titleField) {
    const titleValue = formProps.element.props[titleField.name];
    if (titleValue) {
      label = `${label}: ${titleValue}`;
    }
  }
  return label;
};
var EmbedNestedForm = ({
  editor,
  element,
  activeTemplate,
  onClose,
  onChange
}) => {
  const path = ReactEditor.findPath(editor, element);
  const id = [...path, activeTemplate.name].join(".");
  return import_react117.default.createElement(NestedForm, {
    id,
    label: activeTemplate.label,
    fields: activeTemplate.fields,
    initialValues: element.props,
    onChange,
    onClose
  });
};
var DotMenu = ({ onOpen, onRemove }) => {
  return import_react117.default.createElement(Lt, {
    as: "span",
    className: "-ml-px relative block"
  }, import_react117.default.createElement(Lt.Button, {
    as: "span",
    className: "cursor-pointer h-full relative inline-flex items-center px-1 py-0.5 rounded-r-md border border-gray-200 bg-white text-gray-500 hover:bg-gray-50 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500"
  }, import_react117.default.createElement(EllipsisIcon, {
    title: "Open options"
  })), import_react117.default.createElement(tt2, {
    as: import_react117.default.Fragment,
    enter: "transition ease-out duration-100",
    enterFrom: "transform opacity-0 scale-95",
    enterTo: "transform opacity-100 scale-100",
    leave: "transition ease-in duration-75",
    leaveFrom: "transform opacity-100 scale-100",
    leaveTo: "transform opacity-0 scale-95"
  }, import_react117.default.createElement(Lt.Panel, {
    className: "z-30 absolute origin-top-right right-0"
  }, import_react117.default.createElement("div", {
    className: "mt-2 -mr-1 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none"
  }, import_react117.default.createElement("div", {
    className: "py-1"
  }, import_react117.default.createElement("span", {
    onClick: onOpen,
    className: classNames$1("cursor-pointer text-left w-full block px-4 py-2 text-sm hover:bg-gray-100 hover:text-gray-900")
  }, "Edit"), import_react117.default.createElement("button", {
    onMouseDown: (e9) => {
      e9.preventDefault();
      onRemove();
    },
    className: classNames$1("cursor-pointer text-left w-full block px-4 py-2 text-sm hover:bg-gray-100 hover:text-gray-900")
  }, "Remove"))))));
};
var createCodeBlockPlugin2 = createPluginFactory({
  key: "code_block",
  isElement: true,
  isVoid: true,
  isInline: false
});
var createHTMLBlockPlugin = createPluginFactory({
  key: "html",
  isElement: true,
  isVoid: true,
  isInline: false
});
var createHTMLInlinePlugin = createPluginFactory({
  key: "html_inline",
  isElement: true,
  isVoid: true,
  isInline: true
});
var textFieldClasses = "shadow-inner focus:shadow-outline focus:border-blue-500 focus:outline-none block text-base placeholder:text-gray-300 px-3 py-2 text-gray-600 w-full bg-white border border-gray-200 transition-all ease-out duration-150 focus:text-gray-900 rounded-md";
var disabledClasses = "opacity-50 pointer-events-none cursor-not-allowed";
var BaseTextField = ({ className = "", ...props }) => {
  return React68.createElement("input", {
    type: "text",
    className: `${textFieldClasses} ${(props == null ? void 0 : props.disabled) ? disabledClasses : ""} ${className}`,
    ...props
  });
};
var TextArea = ({ ...props }) => {
  return React68.createElement("textarea", {
    className: "shadow-inner text-base px-3 py-2 text-gray-600 resize-y focus:shadow-outline focus:border-blue-500 block w-full border border-gray-200 focus:text-gray-900 rounded-md",
    ...props,
    style: { minHeight: "160px" }
  });
};
var ColorFormat = ((ColorFormat2) => {
  ColorFormat2["Hex"] = "hex";
  ColorFormat2["RGB"] = "rgb";
  return ColorFormat2;
})(ColorFormat || {});
var rgbToHex2 = function(color) {
  return "#" + ((1 << 24) + (color.r << 16) + (color.g << 8) + color.b).toString(16).slice(1);
};
function ParseColorStr(color) {
  if (!color) {
    return null;
  }
  const colorDescriptor = (0, import_color_string.get)(color);
  if (!colorDescriptor)
    return null;
  const colorVals = colorDescriptor.value;
  return { r: colorVals[0], g: colorVals[1], b: colorVals[2], a: colorVals[3] };
}
var ColorFormatter = {
  ["rgb"]: {
    getLabel(color) {
      return `R${color.r} G${color.g} B${color.b}`;
    },
    getValue(color) {
      const colorVals = [color.r, color.g, color.b, color.a];
      return import_color_string.to.rgb(colorVals);
    },
    parse: ParseColorStr
  },
  ["hex"]: {
    getLabel(color) {
      return rgbToHex2(color);
    },
    getValue(color) {
      const colorVals = [color.r, color.g, color.b, color.a];
      return import_color_string.to.hex(colorVals);
    },
    parse: ParseColorStr
  }
};
var keyframes = "@keyframes color-popup-keyframes {\n  0% {\n    transform: translate3d(-50%, 0, 0) scale3d(0.5, 0.5, 1);\n  }\n  100% {\n    transform: translate3d(-50%, 8px, 0) scale3d(1, 1, 1);\n  }\n}\n\n@keyframes color-popup-open-top-keyframes {\n  0% {\n    transform: translate3d(-50%, -100%, 0) scale3d(0.5, 0.5, 1);\n  }\n  100% {\n    transform: translate3d(-50%, calc(-100% - 8px), 0) scale3d(1, 1, 1);\n  }\n}\n\n.color-picker-clip-path::before,\n.color-picker-clip-path::after {\n  clip-path: polygon(50% 0%, 0% 100%, 100% 100%);\n}\n\n.color-picker-on-top-clip-path::before,\n.color-picker-on-top-clip-path::after {\n  clip-path: polygon(0% 0%, 100% 0%, 50% 100%);\n}\n";
var GetTextColorForBackground = function(backgroundColor) {
  return !backgroundColor || backgroundColor.r * 0.299 + backgroundColor.g * 0.587 + backgroundColor.b * 0.114 > 186 ? "#000000" : "#ffffff";
};
var Swatch3 = ({
  colorRGBA,
  colorFormat,
  unselectable,
  ...props
}) => React68.createElement("div", {
  className: "bg-gray-100 rounded-3xl shadow-[0_2px_3px_rgba(0,0,0,0.12)] cursor-pointer w-full m-0",
  ...props
}, React68.createElement("div", {
  className: "swatch-inner flex items-center justify-center text-[13px] font-bold w-full h-10 rounded-3xl hover:opacity-[.6]",
  style: {
    background: colorRGBA ? `rgba(${colorRGBA.r}, ${colorRGBA.g}, ${colorRGBA.b}, ${colorRGBA.a})` : `#fff`,
    color: GetTextColorForBackground(colorRGBA),
    transition: "all var(--tina-timing-short) ease-out"
  }
}, !colorRGBA ? "Click to add color" : ColorFormatter[colorFormat].getLabel(colorRGBA)));
var Popover = ({
  triggerBoundingBox,
  openTop,
  className = "",
  style: style2 = {},
  ...props
}) => React68.createElement("div", {
  className: `fixed z-50 before:content-[""] before:absolute before:left-1/2 before:-translate-x-1/2 before:w-[18px] before:h-[14px] before:bg-gray-200 before:z-10 after:content-[""] after:absolute after:left-1/2 after:-translate-x-1/2 after:w-4 after:h-[13px] after:bg-white after:z-20 ${openTop ? "before:bottom-0 before:mt-[1px] before:translate-y-full color-picker-on-top-clip-path after:bottom-0 after:mb-0.5 after:translate-y-full" : "before:top-0 before:mb-[1px] before:-translate-y-full color-picker-clip-path after:top-0 after:mt-0.5 after:-translate-y-full"} ${className}`,
  style: {
    top: triggerBoundingBox ? openTop ? triggerBoundingBox.top : triggerBoundingBox.bottom : 0,
    left: triggerBoundingBox ? triggerBoundingBox.left + triggerBoundingBox.width / 2 : 0,
    transform: openTop ? "translate3d(-50%, calc(-100% - 8px), 0) scale3d(1, 1, 1)" : "translate3d(-50%, 8px, 0) scale3d(1, 1, 1)",
    animation: `${openTop ? "color-popup-open-top-keyframes" : "color-popup-keyframes"} 85ms ease-out both 1`,
    transformOrigin: `50% ${openTop ? "100%" : "0"}`,
    ...style2
  },
  ...props
});
var nullColor = "transparent";
var presetColors = [
  "#D0021B",
  "#F5A623",
  "#F8E71C",
  "#8B572A",
  "#7ED321",
  "#417505",
  "#BD10E0",
  "#9013FE",
  "#4A90E2",
  "#50E3C2",
  "#B8E986",
  "#000000",
  "#4A4A4A",
  "#9B9B9B",
  "#FFFFFF"
];
var SketchWidget = (props) => React68.createElement(Sketch_default, {
  presetColors: props.presetColors,
  color: props.color,
  onChange: props.onChange,
  disableAlpha: props.disableAlpha,
  width: props.width
});
var BlockWidget = (props) => React68.createElement(Block_default, {
  colors: props.presetColors,
  color: props.color,
  onChange: props.onChange,
  width: props.width
});
var WIDGETS = { sketch: SketchWidget, block: BlockWidget };
var ColorPicker = ({
  colorFormat,
  userColors = presetColors,
  widget = "sketch",
  input
}) => {
  const FormPortal = useFormPortal();
  const triggerRef = React68.useRef(null);
  const [triggerBoundingBox, setTriggerBoundingBox] = (0, import_react117.useState)(null);
  const [openTop, setOpenTop] = (0, import_react117.useState)(false);
  const updateTriggerBoundingBox = () => {
    if (triggerRef.current) {
      setTriggerBoundingBox(triggerRef.current.getBoundingClientRect());
    }
  };
  React68.useEffect(() => {
    if (triggerBoundingBox) {
      const triggerOffsetTop = triggerBoundingBox.top + triggerBoundingBox.height / 2;
      const windowHeight = window.innerHeight;
      if (triggerOffsetTop > windowHeight / 2) {
        setOpenTop(true);
      } else {
        setOpenTop(false);
      }
    }
  }, [triggerBoundingBox]);
  React68.useEffect(() => {
    const delay = 100;
    let timeout = false;
    setTimeout(() => {
      updateTriggerBoundingBox();
    }, delay);
    const handleResize = () => {
      clearTimeout(timeout);
      timeout = setTimeout(updateTriggerBoundingBox, delay);
    };
    window.addEventListener("resize", handleResize);
    return () => {
      window.removeEventListener("resize", handleResize);
    };
  }, [triggerRef.current]);
  const Widget = WIDGETS[widget];
  if (!Widget)
    throw new Error("You must specify a widget type.");
  const [displayColorPicker, setDisplayColorPicker] = (0, import_react117.useState)(false);
  const getColorFormat = (colorFormat || ColorFormat.Hex).toLowerCase();
  const getColorRGBA = input.value ? ColorFormatter[getColorFormat].parse(input.value) : null;
  const handleChange = (pickerColor) => {
    const color = pickerColor.hex === nullColor ? null : { ...pickerColor.rgb, a: 1 };
    input.onChange(color ? ColorFormatter[getColorFormat].getValue(color) : null);
  };
  const toggleColorPicker = (event) => {
    event.stopPropagation();
    const display = !displayColorPicker;
    setDisplayColorPicker(display);
    if (display) {
      updateTriggerBoundingBox();
    }
  };
  return React68.createElement("div", {
    className: "relative",
    ref: triggerRef
  }, React68.createElement("style", null, keyframes), React68.createElement(Swatch3, {
    onClick: toggleColorPicker,
    colorRGBA: getColorRGBA,
    colorFormat: getColorFormat
  }), displayColorPicker && React68.createElement(FormPortal, null, ({ zIndexShift }) => React68.createElement(Popover, {
    openTop,
    triggerBoundingBox,
    style: { zIndex: 5e3 + zIndexShift }
  }, React68.createElement(Dismissible, {
    click: true,
    escape: true,
    disabled: !displayColorPicker,
    onDismiss: toggleColorPicker
  }, React68.createElement(Widget, {
    presetColors: [...userColors, nullColor],
    color: getColorRGBA || { r: 0, g: 0, b: 0, a: 0 },
    onChange: handleChange,
    disableAlpha: true,
    width: "240px"
  })))));
};
var Toggle = ({
  input,
  field,
  name: name2,
  disabled = false
}) => {
  const checked = !!(input.value || input.checked);
  let labels = null;
  if (field.toggleLabels) {
    const fieldLabels = typeof field.toggleLabels === "object" && "true" in field.toggleLabels && "false" in field.toggleLabels && field.toggleLabels;
    labels = {
      true: fieldLabels ? fieldLabels["true"] : "Yes",
      false: fieldLabels ? fieldLabels["false"] : "No"
    };
  }
  return React68.createElement("div", {
    className: "flex gap-2 items-center"
  }, labels && React68.createElement("span", {
    className: `text-sm ${!checked ? "text-blue-500 font-bold" : "text-gray-300"}`
  }, labels.false), React68.createElement("div", {
    className: "relative w-12 h-7"
  }, React68.createElement(ToggleInput, {
    id: name2,
    type: "checkbox",
    ...input
  }), React68.createElement("label", {
    className: "bg-none p-0 outline-none w-12 h-7",
    style: {
      opacity: disabled ? 0.4 : 1,
      pointerEvents: disabled ? "none" : "inherit"
    },
    htmlFor: name2,
    role: "switch"
  }, React68.createElement("div", {
    className: "relative w-[48px] h-7 rounded-3xl bg-white shadow-inner border border-gray-200 pointer-events-none -ml-0.5"
  }, React68.createElement("span", {
    className: `absolute rounded-3xl left-0.5 top-1/2 w-[22px] h-[22px] shadow border transition-all ease-out duration-150 ${checked ? "bg-blue-500 border-blue-600" : "bg-gray-250 border-gray-300"}`,
    style: {
      transform: `translate3d(${checked ? "20px" : "0"}, -50%, 0)`
    }
  })))), labels && React68.createElement("span", {
    className: `text-sm ${checked ? "text-blue-500 font-bold" : "text-gray-300"}`
  }, labels.true));
};
var ToggleInput = ({ disabled, ...props }) => {
  return React68.createElement("input", {
    className: `absolute left-0 top-0 w-12 h-8 opacity-0 m-0 ${disabled ? `cursor-not-allowed pointer-events-none` : `cursor-pointer z-20`}`,
    ...props
  });
};
function MdKeyboardArrowDown(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0V0z" } }, { "tag": "path", "attr": { "d": "M7.41 8.59L12 13.17l4.59-4.58L18 10l-6 6-6-6 1.41-1.41z" } }] })(props);
}
function MdArrowForward(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M12 4l-1.41 1.41L16.17 11H4v2h12.17l-5.58 5.59L12 20l8-8z" } }] })(props);
}
function MdSyncProblem(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0z" } }, { "tag": "path", "attr": { "d": "M3 12c0 2.21.91 4.2 2.36 5.64L3 20h6v-6l-2.24 2.24A6.003 6.003 0 015 12a5.99 5.99 0 014-5.65V4.26C5.55 5.15 3 8.27 3 12zm8 5h2v-2h-2v2zM21 4h-6v6l2.24-2.24A6.003 6.003 0 0119 12a5.99 5.99 0 01-4 5.65v2.09c3.45-.89 6-4.01 6-7.74 0-2.21-.91-4.2-2.36-5.64L21 4zm-10 9h2V7h-2v6z" } }] })(props);
}
function MdOutlineSettings(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0V0z" } }, { "tag": "path", "attr": { "d": "M19.43 12.98c.04-.32.07-.64.07-.98 0-.34-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46a.5.5 0 00-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65A.488.488 0 0014 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1a.566.566 0 00-.18-.03c-.17 0-.34.09-.43.25l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98 0 .33.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46a.5.5 0 00.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.06.02.12.03.18.03.17 0 .34-.09.43-.25l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zm-1.98-1.71c.04.31.05.52.05.73 0 .21-.02.43-.05.73l-.14 1.13.89.7 1.08.84-.7 1.21-1.27-.51-1.04-.42-.9.68c-.43.32-.84.56-1.25.73l-1.06.43-.16 1.13-.2 1.35h-1.4l-.19-1.35-.16-1.13-1.06-.43c-.43-.18-.83-.41-1.23-.71l-.91-.7-1.06.43-1.27.51-.7-1.21 1.08-.84.89-.7-.14-1.13c-.03-.31-.05-.54-.05-.74s.02-.43.05-.73l.14-1.13-.89-.7-1.08-.84.7-1.21 1.27.51 1.04.42.9-.68c.43-.32.84-.56 1.25-.73l1.06-.43.16-1.13.2-1.35h1.39l.19 1.35.16 1.13 1.06.43c.43.18.83.41 1.23.71l.91.7 1.06-.43 1.27-.51.7 1.21-1.07.85-.89.7.14 1.13zM12 8c-2.21 0-4 1.79-4 4s1.79 4 4 4 4-1.79 4-4-1.79-4-4-4zm0 6c-1.1 0-2-.9-2-2s.9-2 2-2 2 .9 2 2-.9 2-2 2z" } }] })(props);
}
function MdOutlineClear(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0V0z" } }, { "tag": "path", "attr": { "d": "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41z" } }] })(props);
}
function MdOutlineCloud(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0V0z" } }, { "tag": "path", "attr": { "d": "M12 6c2.62 0 4.88 1.86 5.39 4.43l.3 1.5 1.53.11A2.98 2.98 0 0122 15c0 1.65-1.35 3-3 3H6c-2.21 0-4-1.79-4-4 0-2.05 1.53-3.76 3.56-3.97l1.07-.11.5-.95A5.469 5.469 0 0112 6m0-2C9.11 4 6.6 5.64 5.35 8.04A5.994 5.994 0 000 14c0 3.31 2.69 6 6 6h13c2.76 0 5-2.24 5-5 0-2.64-2.05-4.78-4.65-4.96A7.49 7.49 0 0012 4z" } }] })(props);
}
function MdOutlinePhotoLibrary(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0V0z" } }, { "tag": "path", "attr": { "d": "M20 4v12H8V4h12m0-2H8c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-8.5 9.67l1.69 2.26 2.48-3.1L19 15H9zM2 6v14c0 1.1.9 2 2 2h14v-2H4V6H2z" } }] })(props);
}
function MdOutlineArrowBackIos(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0V0z", "opacity": ".87" } }, { "tag": "path", "attr": { "d": "M17.51 3.87L15.73 2.1 5.84 12l9.9 9.9 1.77-1.77L9.38 12l8.13-8.13z" } }] })(props);
}
var selectFieldClasses = "shadow appearance-none bg-white block pl-3 pr-8 py-2 truncate w-full text-base cursor-pointer border border-gray-200 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm rounded-md";
var Select = ({ input, field, options }) => {
  const selectOptions = options || field.options;
  return React68.createElement("div", {
    className: "relative group"
  }, React68.createElement("select", {
    id: input.name,
    value: input.value,
    onChange: input.onChange,
    className: `${selectFieldClasses} ${input.value ? "text-gray-700" : "text-gray-300"} }`,
    ...input
  }, selectOptions ? selectOptions.map(toProps$1).map(toComponent) : React68.createElement("option", null, input.value)), React68.createElement(MdKeyboardArrowDown, {
    className: "absolute top-1/2 right-2 w-6 h-auto -translate-y-1/2 text-gray-300 group-hover:text-blue-500 transition duration-150 ease-out pointer-events-none"
  }));
};
function toProps$1(option) {
  if (typeof option === "object")
    return option;
  return { value: option, label: option };
}
function toComponent(option) {
  return React68.createElement("option", {
    key: option.value,
    value: option.value
  }, option.label);
}
var RadioGroup = ({
  input,
  field,
  options
}) => {
  const radioOptions = options || field.options;
  const radioRefs = {};
  const toProps2 = (option) => {
    if (typeof option === "object")
      return option;
    return { value: option, label: option };
  };
  const toComponent2 = (option) => {
    const optionId = `field-${field.name}-option-${option.value}`;
    const checked = option.value === input.value;
    return React68.createElement("div", {
      key: option.value,
      ref: (ref2) => {
        radioRefs[`radio_${option.value}`] = ref2;
      }
    }, React68.createElement("input", {
      className: "absolute w-0 h-0 opacity-0 cursor-pointer",
      type: "radio",
      id: optionId,
      name: input.name,
      value: option.value,
      onChange: (event) => {
        input.onChange(event.target.value);
      },
      checked
    }), React68.createElement(RadioOption, {
      htmlFor: optionId,
      checked
    }, option.label));
  };
  return React68.createElement(RadioOptions, {
    id: input.name,
    direction: field.direction
  }, radioOptions ? radioOptions.map(toProps2).map(toComponent2) : input.value);
};
var RadioOptions = ({ direction, children, ...props }) => React68.createElement("div", {
  className: `flex w-full ${direction === "horizontal" ? "flex-wrap gap-y-1 gap-x-3" : "flex-col gap-1"}`,
  ...props
}, children);
var RadioOption = ({ checked, htmlFor, children, ...props }) => React68.createElement("label", {
  className: "cursor-pointer flex group items-center gap-2",
  htmlFor,
  ...props
}, React68.createElement("span", {
  className: `relative h-[19px] w-[19px] rounded-full border text-indigo-600 focus:ring-indigo-500 transition ease-out duration-150 ${checked ? "border-blue-500 bg-blue-500 shadow-sm group-hover:bg-blue-400 group-hover:border-blue-400" : "border-gray-200 bg-white shadow-inner group-hover:bg-gray-100"}`
}, React68.createElement(BiCheck, {
  className: `absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[17px] h-[17px] transition ease-out duration-150 ${checked ? "opacity-100 text-white group-hover:opacity-80" : "text-blue-500 opacity-0 grou-hover:opacity-30"}`
})), React68.createElement("span", {
  className: `relative transition ease-out duration-150 ${checked ? "text-gray-800 opacity-100" : "text-gray-700 opacity-70 group-hover:opacity-100"}`
}, children));
var CheckboxGroup = ({
  input,
  field,
  options,
  disabled = false
}) => {
  const checkboxOptions = options || field.options;
  const toProps2 = (option) => {
    if (typeof option === "object")
      return option;
    return { value: option, label: option };
  };
  const toComponent2 = (option) => {
    const optionId = `field-${field.name}-option-${option.value}`;
    const checked = input.value ? input.value.includes(option.value) : false;
    return React68.createElement("div", {
      key: option.value
    }, React68.createElement("input", {
      className: "absolute w-0 h-0 opacity-0 cursor-pointer",
      type: "checkbox",
      name: input.name,
      id: optionId,
      value: option.value,
      checked,
      disabled,
      onChange: (event) => {
        if (event.target.checked === true) {
          input.onChange([...input.value, event.target.value]);
        } else {
          input.onChange([
            ...input.value.filter((v6) => v6 !== event.target.value)
          ]);
        }
      }
    }), React68.createElement("label", {
      className: "cursor-pointer flex group items-center gap-2",
      htmlFor: optionId
    }, React68.createElement("span", {
      className: `relative h-[18px] w-[18px] rounded border text-indigo-600 focus:ring-indigo-500 transition ease-out duration-150 ${checked ? "border-blue-500 bg-blue-500 shadow-sm group-hover:bg-blue-400 group-hover:border-blue-400" : "border-gray-200 bg-white shadow-inner group-hover:bg-gray-100"}`
    }, React68.createElement(BiCheck, {
      className: `absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[17px] h-[17px] transition ease-out duration-150 ${checked ? "opacity-100 text-white group-hover:opacity-80" : "text-blue-500 opacity-0 grou-hover:opacity-30"}`
    })), React68.createElement("span", {
      className: `relative transition ease-out duration-150 ${checked ? "text-gray-800 opacity-100" : "text-gray-700 opacity-70 group-hover:opacity-100"}`
    }, option.label)));
  };
  return React68.createElement("div", {
    className: `flex w-full ${field.direction === "horizontal" ? "flex-wrap gap-y-1 gap-x-3" : "flex-col gap-1"}`,
    id: input.name
  }, checkboxOptions == null ? void 0 : checkboxOptions.map(toProps2).map(toComponent2));
};
var Input = ({ ...props }) => {
  return React68.createElement("input", {
    className: textFieldClasses,
    ...props
  });
};
var NumberInput = ({
  onChange,
  value,
  step
}) => React68.createElement(Input, {
  type: "number",
  step,
  value,
  onChange
});
function useCMS() {
  return useCMS$1();
}
var supportedFileTypes = [
  "text/*",
  "application/pdf",
  "application/octet-stream",
  "application/json",
  "application/ld+json",
  "application/vnd.ms-excel",
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  "application/msword",
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  "image/*"
];
var DEFAULT_MEDIA_UPLOAD_TYPES = supportedFileTypes.join(",");
var dropzoneAcceptFromString = (str) => {
  return Object.assign({}, ...(str || DEFAULT_MEDIA_UPLOAD_TYPES).split(",").map((x7) => ({ [x7]: [] })));
};
var isImage = (filename) => {
  return /\.(gif|jpg|jpeg|tiff|png|svg|webp|avif)(\?.*)?$/i.test(filename);
};
var absoluteImgURL = (str) => {
  if (str.startsWith("http"))
    return str;
  return `${window.location.origin}${str}`;
};
var StyledImage = ({ src }) => React68.createElement("img", {
  src,
  className: "block max-w-full rounded shadow overflow-hidden max-h-48 h-auto object-contain transition-opacity duration-100 ease-out m-0 bg-gray-200 bg-auto bg-center bg-no-repeat"
});
var StyledFile = ({ src }) => {
  return React68.createElement("div", {
    className: "max-w-full w-full overflow-hidden flex-1 flex justify-start items-center gap-3"
  }, React68.createElement("div", {
    className: "w-14 h-14 bg-gray-50 shadow border border-gray-100 rounded flex justify-center flex-none"
  }, React68.createElement(BiFileBlank, {
    className: "w-3/5 h-full fill-gray-300"
  })), React68.createElement("span", {
    className: "text-base text-left flex-1 text-gray-500 w-full break-words truncate"
  }, src));
};
var ImageUpload = ({
  onDrop,
  onClear,
  onClick,
  value,
  src,
  loading
}) => {
  const cms = useCMS();
  const { getRootProps, getInputProps } = useDropzone({
    accept: dropzoneAcceptFromString(cms.media.accept || DEFAULT_MEDIA_UPLOAD_TYPES),
    onDrop,
    noClick: !!onClick
  });
  return React68.createElement("div", {
    className: "w-full max-w-full",
    ...getRootProps()
  }, React68.createElement("input", {
    ...getInputProps()
  }), value ? loading ? React68.createElement(ImageLoadingIndicator, null) : React68.createElement("div", {
    className: `relative w-full max-w-full flex justify-start gap-3 ${isImage(src) ? `items-start` : `items-center`}`
  }, React68.createElement("button", {
    className: "outline-none overflow-visible cursor-pointer border-none hover:opacity-60 transition ease-out duration-100",
    onClick
  }, isImage(src) ? React68.createElement(StyledImage, {
    src
  }) : React68.createElement(StyledFile, {
    src
  })), onClear && React68.createElement(DeleteImageButton, {
    onClick: (e9) => {
      e9.stopPropagation();
      onClear();
    }
  })) : React68.createElement("button", {
    className: "outline-none relative hover:opacity-60 w-full",
    onClick
  }, loading ? React68.createElement(ImageLoadingIndicator, null) : React68.createElement("div", {
    className: "text-center rounded-[5px] bg-gray-100 text-gray-300 leading-[1.35] py-3 text-[15px] font-normal transition-all ease-out duration-100 hover:opacity-60"
  }, "Drag 'n' drop a file here,", React68.createElement("br", null), "or click to select a file")));
};
var DeleteImageButton = ({
  onClick
}) => {
  return React68.createElement(IconButton, {
    variant: "white",
    className: "flex-none",
    onClick
  }, React68.createElement(TrashIcon, {
    className: "w-7 h-auto"
  }));
};
var ImageLoadingIndicator = () => React68.createElement("div", {
  className: "p-4 w-full min-h-[96px] flex flex-col justify-center items-center"
}, React68.createElement(LoadingDots, null));
var useGetOptionSets = (cms, collections) => {
  const [optionSets, setOptionSets] = React68.useState([]);
  const [loading, setLoading] = React68.useState(true);
  React68.useEffect(() => {
    const fetchOptionSets = async () => {
      const optionSets2 = await Promise.all(collections.map(async (collection) => {
        try {
          const response = await cms.api.tina.request(`#graphql
            query ($collection: String!){
              collection(collection: $collection) {
                documents(first: -1) {
                  edges {
                    node {
                      ...on Node {
                        id,
                      }
                      ...on Document {
                        _internalSys: _sys {
                          title
                        }
                      }
                    }
                  }
                }
              }
            }
            `, { variables: { collection } });
          return {
            collection,
            edges: response.collection.documents.edges
          };
        } catch (e9) {
          return {
            collection,
            edges: []
          };
        }
      }));
      setOptionSets(optionSets2);
      setLoading(false);
    };
    if (cms && collections.length > 0) {
      fetchOptionSets();
    } else {
      setOptionSets([]);
    }
  }, [cms, collections]);
  return { optionSets, loading };
};
var ReferenceSelect = ({
  cms,
  input,
  field
}) => {
  const { optionSets, loading } = useGetOptionSets(cms, field.collections);
  if (loading === true) {
    return React68.createElement(LoadingDots, {
      color: "var(--tina-color-primary)"
    });
  }
  return React68.createElement(React68.Fragment, null, React68.createElement("select", {
    id: input.name,
    value: input.value,
    onChange: input.onChange,
    className: selectFieldClasses,
    ...input
  }, React68.createElement("option", {
    value: ""
  }, "Choose an option"), optionSets.length > 0 && optionSets.map(({ collection, edges }) => React68.createElement("optgroup", {
    key: `${collection}-group`,
    label: collection
  }, edges.map(({
    node: {
      id,
      _internalSys: { title }
    }
  }) => React68.createElement("option", {
    key: `${id}-option`,
    value: id
  }, title || id))))), React68.createElement(MdKeyboardArrowDown, {
    className: "absolute top-1/2 right-3 w-6 h-auto -translate-y-1/2 text-gray-300 group-hover:text-blue-500 transition duration-150 ease-out"
  }));
};
var useGetNode = (cms, id) => {
  const [document2, setDocument] = React68.useState(void 0);
  React68.useEffect(() => {
    const fetchNode = async () => {
      const response = await cms.api.tina.request(`#graphql
        query($id: String!) {
          node(id:$id) {
            ... on Document {
              _sys {
                collection {
                  name
                }
                breadcrumbs
              }
            }
          }
        }`, { variables: { id } });
      setDocument(response.node);
    };
    if (cms && id) {
      fetchNode();
    } else {
      setDocument(void 0);
    }
  }, [cms, id]);
  return document2;
};
var GetReference = ({ cms, id, children }) => {
  const document2 = useGetNode(cms, id);
  if (!document2) {
    return null;
  }
  return React68.createElement(React68.Fragment, null, children(document2));
};
var ReferenceLink = ({ cms, input }) => {
  const hasTinaAdmin = cms.flags.get("tina-admin") === false ? false : true;
  const tinaPreview = cms.flags.get("tina-preview") || false;
  if (!hasTinaAdmin) {
    return null;
  }
  return React68.createElement(GetReference, {
    cms,
    id: input.value
  }, (document2) => React68.createElement("a", {
    href: `${tinaPreview ? `/${tinaPreview}/index.html#` : "/admin#"}/collections/${document2._sys.collection.name}/${document2._sys.breadcrumbs.join("/")}`,
    className: "text-gray-700 hover:text-blue-500 flex items-center uppercase text-sm mt-2 mb-2 leading-none"
  }, React68.createElement(BiEdit, {
    className: "h-5 w-auto opacity-80 mr-2"
  }), "Edit in CMS"));
};
var Reference = ({ input, field }) => {
  const cms = useCMS();
  return React68.createElement("div", null, React68.createElement("div", {
    className: "relative group"
  }, React68.createElement(ReferenceSelect, {
    cms,
    input,
    field
  })), React68.createElement(ReferenceLink, {
    cms,
    input
  }));
};
var ButtonToggle = ({
  input,
  field,
  options
}) => {
  const toggleOptions = options || field.options;
  const direction = field.direction || "horizontal";
  return React68.createElement(React68.Fragment, null, React68.createElement("input", {
    type: "text",
    id: input.name,
    className: "hidden",
    ...input
  }), React68.createElement("div", {
    className: `flex ${direction === "horizontal" ? "divide-x" : "flex-col divide-y"} divide-gray-150 shadow-inner bg-gray-50 border border-gray-200 w-full justify-between rounded-md`
  }, toggleOptions ? toggleOptions.map((toggleOption) => {
    const option = toProps(toggleOption);
    if (option.icon) {
      return React68.createElement(ButtonOption, {
        key: option.value,
        input,
        value: option.value,
        icon: option.icon
      });
    } else {
      return React68.createElement(ButtonOption, {
        key: option.value,
        input,
        value: option.value,
        label: option.label
      });
    }
  }) : input.value));
};
var ButtonOption = ({
  input,
  value,
  label = "",
  icon,
  ...props
}) => {
  const Icon = icon;
  return React68.createElement("button", {
    className: `relative whitespace-nowrap flex items-center justify-center flex-1 block font-medium text-base px-3 py-2 text-gray-400 transition-all ease-out duration-150`,
    onClick: () => {
      input.onChange(value);
    },
    ...props
  }, Icon ? React68.createElement(Icon, {
    className: "w-6 h-auto opacity-70"
  }) : React68.createElement("span", {
    className: "flex-1 truncate max-w-full w-0"
  }, label), React68.createElement("span", {
    className: `absolute whitespace-nowrap px-3 py-2 z-20 font-medium text-base flex items-center justify-center -top-0.5 -right-0.5 -bottom-0.5 -left-0.5 truncate bg-white border border-gray-200 origin-center rounded-md shadow text-blue-500 transition-all ease-out duration-150 ${input.value === value ? "opacity-100" : "opacity-0"}`
  }, Icon ? React68.createElement(Icon, {
    className: "w-6 h-auto opacity-70"
  }) : React68.createElement("span", {
    className: "flex-1 truncate max-w-full w-0"
  }, label)));
};
function toProps(option) {
  if (typeof option === "object")
    return option;
  return { value: option, label: option };
}
var ImgEmbed = ({
  attributes,
  children,
  element,
  editor,
  onChange
}) => {
  const selected = useSelected();
  const { handleClose, handleRemove, handleSelect, isExpanded: isExpanded2 } = useEmbedHandles(editor, element);
  useHotkey("enter", () => {
    insertNodes(editor, [{ type: ELEMENT_PARAGRAPH, children: [{ text: "" }] }]);
  });
  return import_react117.default.createElement("span", {
    ...attributes,
    className: ""
  }, children, import_react117.default.createElement("span", {
    className: "relative"
  }, import_react117.default.createElement("span", {
    className: "relative inline-flex shadow-sm rounded-md"
  }, selected && import_react117.default.createElement("span", {
    className: "z-10 absolute inset-0 ring-2 ring-blue-100 ring-inset rounded-md pointer-events-none"
  }), import_react117.default.createElement("div", {
    className: "z-10"
  }, import_react117.default.createElement(DeleteImageButton, {
    onClick: (e9) => {
      e9.stopPropagation();
      handleRemove();
    }
  })), import_react117.default.createElement("span", {
    onMouseDown: handleSelect,
    className: "min-w-[200px] max-w-[400px] cursor-pointer rounded-md relative bg-gray-100 overflow-hidden relative"
  }, element.url ? import_react117.default.createElement("img", {
    src: element.url,
    title: element.caption,
    alt: element.alt,
    className: "my-0 min-h-[100px]"
  }) : import_react117.default.createElement("span", {
    className: "min-h-[100px] min-w-[200px] flex items-center justify-center text-gray-300"
  }, import_react117.default.createElement("span", null, "Click to add an image")))), isExpanded2 && import_react117.default.createElement(ImageForm, {
    onChange,
    initialValues: element,
    onClose: handleClose,
    element
  })));
};
var ImageForm = (props) => {
  return import_react117.default.createElement(NestedForm, {
    id: "image-form",
    label: "Image",
    fields: [
      {
        label: "URL",
        name: "url",
        component: "image",
        clearable: true
      },
      { label: "Caption", name: "caption", component: "text" },
      { label: "Alt", name: "alt", component: "text" }
    ],
    initialValues: props.initialValues,
    onChange: props.onChange,
    onClose: props.onClose
  });
};
var ELEMENT_IMG = "img";
var createImgPlugin = createPluginFactory({
  key: ELEMENT_IMG,
  isVoid: true,
  isInline: true,
  isElement: true,
  component: (props) => {
    const handleChange = (values3) => {
      const path = ReactEditor.findPath(props.editor, props.element);
      setNodes(props.editor, values3, { at: path });
    };
    return import_react117.default.createElement(ImgEmbed, {
      ...props,
      onChange: handleChange
    });
  }
});
var insertImg = (editor, media) => {
  if (isImage(media.src)) {
    insertInlineElement(editor, {
      type: ELEMENT_IMG,
      children: [{ text: "" }],
      url: media.src,
      caption: "",
      alt: ""
    });
  } else {
    insertInlineElement(editor, {
      type: "a",
      url: media.src,
      title: media.filename,
      children: [{ text: media.filename }]
    });
  }
  normalizeEditor(editor, { force: true });
};
var onKeyDownSoftBreak2 = (editor, { options: { rules = [] } }) => (event) => {
  const entry = getBlockAbove(editor);
  if (!entry)
    return;
  rules.forEach(({ hotkey, query }) => {
    if ((0, import_is_hotkey2.default)(hotkey, event) && queryNode(entry, query)) {
      event.preventDefault();
      event.stopPropagation();
      insertNodes(editor, [
        { type: KEY_SOFT_BREAK2, children: [{ text: "" }] },
        { type: "text", text: "" }
      ], { select: true });
    }
  });
};
var KEY_SOFT_BREAK2 = "break";
var createSoftBreakPlugin2 = createPluginFactory({
  key: KEY_SOFT_BREAK2,
  isElement: true,
  isInline: true,
  isVoid: true,
  component: (props) => {
    return import_react117.default.createElement(import_react117.default.Fragment, null, import_react117.default.createElement("br", {
      className: props.className,
      ...props.attributes
    }), props.children);
  },
  handlers: {
    onKeyDown: onKeyDownSoftBreak2
  },
  options: {
    rules: [{ hotkey: "shift+enter" }]
  }
});
var preFormat = (editor) => unwrapList(editor);
var format$1 = (editor, customFormatting) => {
  if (editor.selection) {
    const parentEntry = getParentNode(editor, editor.selection);
    if (!parentEntry)
      return;
    const [node] = parentEntry;
    if (isElement2(node) && !isType(editor, node, ELEMENT_CODE_BLOCK) && !isType(editor, node, ELEMENT_CODE_LINE)) {
      customFormatting();
    }
  }
};
var formatList = (editor, elementType) => {
  format$1(editor, () => toggleList(editor, {
    type: elementType
  }));
};
var insertEmptyCodeBlock = (editor) => {
  const matchCodeElements = (node2) => node2.type === getPluginType(editor, ELEMENT_CODE_BLOCK);
  if (someNode(editor, {
    match: matchCodeElements
  })) {
    return;
  }
  const node = {
    type: ELEMENT_CODE_BLOCK,
    value: "",
    lang: "javascript",
    children: [{ type: "text", text: "" }]
  };
  if (isSelectionAtBlockStart(editor)) {
    setElements(editor, node);
  } else {
    insertNode(editor, node);
  }
};
var autoformatBlocks = [
  {
    mode: "block",
    type: ELEMENT_H1,
    match: "# ",
    preFormat
  },
  {
    mode: "block",
    type: ELEMENT_H2,
    match: "## ",
    preFormat
  },
  {
    mode: "block",
    type: ELEMENT_H3,
    match: "### ",
    preFormat
  },
  {
    mode: "block",
    type: ELEMENT_H4,
    match: "#### ",
    preFormat
  },
  {
    mode: "block",
    type: ELEMENT_H5,
    match: "##### ",
    preFormat
  },
  {
    mode: "block",
    type: ELEMENT_H6,
    match: "###### ",
    preFormat
  },
  {
    mode: "block",
    type: ELEMENT_BLOCKQUOTE,
    match: "> ",
    preFormat
  },
  {
    mode: "block",
    type: ELEMENT_CODE_BLOCK,
    match: "```",
    triggerAtBlockStart: false,
    preFormat,
    format: (editor) => {
      insertEmptyCodeBlock(editor);
    }
  },
  {
    mode: "block",
    type: ELEMENT_HR,
    match: ["---", "—-", "___ "],
    format: (editor) => {
      setNodes(editor, { type: ELEMENT_HR });
      insertNodes(editor, {
        type: ELEMENT_DEFAULT,
        children: [{ text: "" }]
      });
    }
  }
];
var autoformatLists = [
  {
    mode: "block",
    type: ELEMENT_LI,
    match: ["* ", "- "],
    preFormat,
    format: (editor) => formatList(editor, ELEMENT_UL)
  },
  {
    mode: "block",
    type: ELEMENT_LI,
    match: ["1. ", "1) "],
    preFormat,
    format: (editor) => formatList(editor, ELEMENT_OL)
  },
  {
    mode: "block",
    type: ELEMENT_TODO_LI,
    match: "[] "
  },
  {
    mode: "block",
    type: ELEMENT_TODO_LI,
    match: "[x] ",
    format: (editor) => setNodes(editor, { type: ELEMENT_TODO_LI, checked: true }, {
      match: (n12) => isBlock(editor, n12)
    })
  }
];
var autoformatMarks = [
  {
    mode: "mark",
    type: [MARK_BOLD, MARK_ITALIC],
    match: "***"
  },
  {
    mode: "mark",
    type: MARK_BOLD,
    match: "**"
  },
  {
    mode: "mark",
    type: MARK_ITALIC,
    match: "*"
  },
  {
    mode: "mark",
    type: MARK_ITALIC,
    match: "_"
  },
  {
    mode: "mark",
    type: MARK_CODE,
    match: "`"
  }
];
var autoformatRules = [
  ...autoformatBlocks,
  ...autoformatLists,
  ...autoformatMarks
];
var withCorrectVoidBehavior = (editor) => {
  const { deleteBackward: deleteBackward2, insertBreak } = editor;
  editor.insertBreak = () => {
    if (!editor.selection || !Range.isCollapsed(editor.selection)) {
      return insertBreak();
    }
    const selectedNodePath = Path.parent(editor.selection.anchor.path);
    const selectedNode = Node2.get(editor, selectedNodePath);
    if (Editor.isVoid(editor, selectedNode)) {
      Editor.insertNode(editor, {
        type: "p",
        children: [{ text: "" }]
      });
      return;
    }
    insertBreak();
  };
  editor.deleteBackward = (unit) => {
    if (!editor.selection || !Range.isCollapsed(editor.selection) || editor.selection.anchor.offset !== 0) {
      return deleteBackward2(unit);
    }
    const parentPath = Path.parent(editor.selection.anchor.path);
    const parentNode = Node2.get(editor, parentPath);
    const parentIsEmpty = Node2.string(parentNode).length === 0;
    if (parentIsEmpty && Path.hasPrevious(parentPath)) {
      const prevNodePath = Path.previous(parentPath);
      const prevNode = Node2.get(editor, prevNodePath);
      if (Editor.isVoid(editor, prevNode)) {
        Transforms.removeNodes(editor);
        Editor.normalize(editor, { force: true });
        return;
      }
    }
    deleteBackward2(unit);
  };
  return editor;
};
var HANDLES_MDX = [
  ELEMENT_H1,
  ELEMENT_H2,
  ELEMENT_H3,
  ELEMENT_H3,
  ELEMENT_H4,
  ELEMENT_H5,
  ELEMENT_H6,
  ELEMENT_PARAGRAPH
];
var resetBlockTypesCommonRule = {
  types: [
    ELEMENT_BLOCKQUOTE,
    ELEMENT_H1,
    ELEMENT_H2,
    ELEMENT_H3,
    ELEMENT_H3,
    ELEMENT_H4,
    ELEMENT_H5,
    ELEMENT_H6
  ],
  defaultType: ELEMENT_PARAGRAPH
};
var createCorrectNodeBehaviorPlugin = createPluginFactory({
  key: "WITH_CORRECT_NODE_BEHAVIOR",
  withOverrides: withCorrectVoidBehavior
});
var plugins$1 = [
  createTrailingBlockPlugin(),
  createCorrectNodeBehaviorPlugin(),
  createAutoformatPlugin({
    options: {
      rules: autoformatRules
    }
  }),
  createExitBreakPlugin({
    options: {
      rules: [
        {
          hotkey: "mod+enter"
        },
        {
          hotkey: "mod+shift+enter",
          before: true
        },
        {
          hotkey: "enter",
          query: {
            start: true,
            end: true,
            allow: KEYS_HEADING
          }
        }
      ]
    }
  }),
  createResetNodePlugin({
    options: {
      rules: [
        {
          ...resetBlockTypesCommonRule,
          hotkey: "Enter",
          predicate: isBlockAboveEmpty
        },
        {
          ...resetBlockTypesCommonRule,
          hotkey: "Backspace",
          predicate: isSelectionAtBlockStart
        }
      ]
    }
  }),
  createSoftBreakPlugin2({
    options: {
      rules: [
        { hotkey: "shift+enter" },
        {
          hotkey: "enter",
          query: {
            allow: [ELEMENT_CODE_BLOCK, ELEMENT_BLOCKQUOTE]
          }
        }
      ]
    }
  })
];
var plugins = [
  createHeadingPlugin(),
  createParagraphPlugin(),
  createCodeBlockPlugin2(),
  createHTMLBlockPlugin(),
  createHTMLInlinePlugin(),
  createBlockquotePlugin(),
  createBoldPlugin(),
  createItalicPlugin(),
  createUnderlinePlugin(),
  createCodePlugin(),
  createListPlugin(),
  createHorizontalRulePlugin(),
  createNodeIdPlugin()
];
var isNodeActive = (editor, type) => {
  const pluginType = getPluginType(editor, type);
  return !!(editor == null ? void 0 : editor.selection) && someNode(editor, { match: { type: pluginType } });
};
var isMarkActive2 = (editor, type) => {
  return !!(editor == null ? void 0 : editor.selection) && isMarkActive(editor, type);
};
var isListActive = (editor, type) => {
  const res = !!(editor == null ? void 0 : editor.selection) && getListItemEntry(editor);
  return !!res && res.list[0].type === type;
};
var normalize2 = (node) => {
  if ([ELEMENT_MDX_BLOCK, ELEMENT_MDX_INLINE, ELEMENT_IMG].includes(node.type)) {
    return {
      ...node,
      children: [{ type: "text", text: "" }],
      id: Date.now()
    };
  }
  if (node.children) {
    if (node.children.length) {
      return {
        ...node,
        children: node.children.map(normalize2),
        id: Date.now()
      };
    } else {
      return {
        ...node,
        children: [{ text: "" }],
        id: Date.now()
      };
    }
  }
  return node;
};
var insertInlineElement = (editor, inlineElement) => {
  insertNodes(editor, [inlineElement]);
  setTimeout(() => {
    Transforms.move(editor);
  }, 1);
};
var insertBlockElement = (editor, blockElement) => {
  const editorEl = ReactEditor.toDOMNode(editor, editor);
  if (editorEl) {
    editorEl.focus();
    setTimeout(() => {
      if (isCurrentBlockEmpty(editor)) {
        setNodes(editor, blockElement);
      } else {
        insertNodes(editor, [blockElement]);
      }
    }, 1);
  }
};
var isCurrentBlockEmpty = (editor) => {
  var _a;
  if (!editor.selection) {
    return false;
  }
  const [node] = Editor.node(editor, editor.selection);
  const cursor = editor.selection.focus;
  const blockAbove = getBlockAbove(editor);
  const isEmpty2 = !Node2.string(node) && !((_a = node.children) == null ? void 0 : _a.some((n12) => Editor.isInline(editor, n12))) && Editor.isStart(editor, cursor, blockAbove[1]);
  return isEmpty2;
};
var currentNodeSupportsMDX = (editor) => findNode(editor, {
  match: { type: HANDLES_MDX }
});
var helpers = {
  isNodeActive,
  isMarkActive: isMarkActive2,
  isListActive,
  currentNodeSupportsMDX,
  normalize: normalize2
};
var ELEMENT_MDX_INLINE = "mdxJsxTextElement";
var ELEMENT_MDX_BLOCK = "mdxJsxFlowElement";
var Embed = (props) => {
  const handleChange = (values3) => {
    const path = ReactEditor.findPath(props.editor, props.element);
    setNodes(props.editor, { props: values3 }, { at: path });
  };
  if (props.inline) {
    return import_react117.default.createElement(InlineEmbed, {
      ...props,
      onChange: handleChange
    });
  }
  return import_react117.default.createElement(BlockEmbed, {
    ...props,
    onChange: handleChange
  });
};
var createMdxInlinePlugin = createPluginFactory({
  key: ELEMENT_MDX_INLINE,
  isInline: true,
  isVoid: true,
  isElement: true,
  component: (props) => import_react117.default.createElement(Embed, {
    ...props,
    inline: true
  })
});
var createMdxBlockPlugin = createPluginFactory({
  key: ELEMENT_MDX_BLOCK,
  isVoid: true,
  isElement: true,
  component: (props) => import_react117.default.createElement(Embed, {
    ...props,
    inline: false
  })
});
var insertMDX = (editor, value) => {
  const flow = value.inline ? false : true;
  if (!helpers.currentNodeSupportsMDX(editor)) {
    return;
  }
  if (flow) {
    insertBlockElement(editor, {
      type: ELEMENT_MDX_BLOCK,
      name: value.name,
      children: [{ text: "" }],
      props: value.defaultItem ? value.defaultItem : {}
    });
    normalizeEditor(editor, { force: true });
  } else {
    insertInlineElement(editor, {
      type: ELEMENT_MDX_INLINE,
      name: value.name,
      children: [{ text: "" }],
      props: value.defaultItem ? value.defaultItem : {}
    });
  }
};
var wrapOrRewrapLink = (editor) => {
  const baseLink = {
    type: "a",
    url: "",
    title: "",
    children: [{ text: "" }]
  };
  if (isCollapsed(editor.selection)) {
    const [, path] = getAboveNode(editor, {
      match: (n12) => !Editor.isEditor(n12) && Element2.isElement(n12) && getPluginType(editor, ELEMENT_LINK)
    });
    Transforms.select(editor, path);
  }
  if (isLinkActive(editor)) {
    const [link] = getLinks(editor);
    baseLink.url = link[0].url;
    baseLink.title = link[0].title;
    unwrapLink(editor);
  }
  wrapNodes(editor, baseLink, { split: true });
};
var LinkForm = (props) => {
  const editor = useEditorState();
  const selection = import_react117.default.useMemo(() => editor.selection, []);
  const handleChange = (values3) => {
    const linksInSelection = getNodeEntries(editor, {
      match: (n12) => !Editor.isEditor(n12) && Element2.isElement(n12) && n12.type === ELEMENT_LINK,
      at: selection
    });
    if (linksInSelection) {
      for (const [, location] of linksInSelection) {
        setNodes(editor, values3, {
          match: (n12) => {
            return !Editor.isEditor(n12) && Element2.isElement(n12) && n12.type === ELEMENT_LINK;
          },
          at: location
        });
      }
    }
  };
  const [link] = getLinks(editor);
  return import_react117.default.createElement(NestedForm, {
    id: "link-form",
    label: "Link",
    fields: [
      { label: "URL", name: "url", component: "text" },
      { label: "Title", name: "title", component: "text" }
    ],
    initialValues: {
      url: link ? link[0].url : "",
      title: link ? link[0].title : ""
    },
    onChange: handleChange,
    onClose: props.onClose
  });
};
var isLinkActive = (editor) => {
  const [link] = getLinks(editor);
  return !!link;
};
var unwrapLink = (editor, selection) => {
  unwrapNodes(editor, {
    match: (n12) => !Editor.isEditor(n12) && Element2.isElement(n12) && n12.type === ELEMENT_LINK,
    at: selection || void 0
  });
};
var getLinks = (editor) => {
  return getNodeEntries(editor, {
    match: (n12) => !Editor.isEditor(n12) && Element2.isElement(n12) && n12.type === ELEMENT_LINK
  });
};
var ToolbarItem = ({
  hidden,
  label,
  active,
  onMouseDown,
  icon,
  options,
  name: name2,
  isLastItem = false
}) => {
  const editor = useEditorState();
  const [selection, setSelection2] = import_react117.default.useState(null);
  const cms = useCMS$1();
  import_react117.default.useEffect(() => {
    if (editor.selection) {
      setSelection2(editor.selection);
    }
  }, [JSON.stringify(editor.selection)]);
  const [isExpanded2, setIsExpanded] = import_react117.default.useState(false);
  if (options) {
    return import_react117.default.createElement(Lt, {
      as: "div",
      className: "relative z-10 w-full"
    }, import_react117.default.createElement(Lt.Button, {
      as: "span",
      className: `cursor-pointer w-full inline-flex justify-center items-center px-2 py-2 rounded-l-md border-l border-b border-t border-gray-200 bg-white text-sm font-medium text-gray-600 hover:bg-gray-50 focus:z-10 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 ${isLastItem ? "border-r rounded-r-md" : "border-r-0"}`,
      onMouseDown: (e9) => {
        e9.preventDefault();
      }
    }, import_react117.default.createElement("span", {
      className: "sr-only"
    }, "Open options"), import_react117.default.createElement(HeadingIcon, null)), import_react117.default.createElement(tt2, {
      as: import_react117.Fragment,
      enter: "transition ease-out duration-100",
      enterFrom: "transform opacity-0 scale-95",
      enterTo: "transform opacity-100 scale-100",
      leave: "transition ease-in duration-75",
      leaveFrom: "transform opacity-100 scale-100",
      leaveTo: "transform opacity-0 scale-95"
    }, import_react117.default.createElement(Lt.Panel, null, ({ close: close2 }) => import_react117.default.createElement("div", {
      className: "origin-top-left absolute left-0 mt-2 -mr-1 w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none"
    }, import_react117.default.createElement("div", {
      className: "py-2 tina-prose"
    }, import_react117.default.createElement("span", {
      onMouseDown: () => close2()
    }, options))))));
  }
  if (icon === "image") {
    return import_react117.default.createElement("span", {
      className: "relative"
    }, import_react117.default.createElement("span", {
      "data-test": `${name2}Button`,
      className: `cursor-pointer w-full inline-flex relative justify-center items-center px-2 py-2 border-l border-b border-t border-r-0 border-gray-200 text-sm font-medium  hover:bg-gray-50 focus:z-10 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 ${active ? "bg-gray-50 text-blue-500" : "bg-white text-gray-600"} ${isLastItem ? "border-r rounded-r-md" : "border-r-0"}`,
      style: {
        visibility: hidden ? "hidden" : "visible",
        pointerEvents: hidden ? "none" : "auto"
      },
      onMouseDown: (e9) => {
        e9.preventDefault();
        cms.media.open({
          allowDelete: true,
          directory: "",
          onSelect: (media) => {
            insertImg(editor, media);
          }
        });
      }
    }, import_react117.default.createElement("span", {
      className: "sr-only"
    }, label), import_react117.default.createElement(ToolbarIcon, {
      name: icon
    })));
  }
  if (icon === "link") {
    const isDisabled = !editor.selection || isCollapsed(editor.selection) && !isLinkActive(editor);
    return import_react117.default.createElement("span", {
      className: "relative"
    }, import_react117.default.createElement("span", {
      "data-test": `${name2}Button`,
      className: `cursor-pointer w-full inline-flex relative justify-center items-center px-2 py-2 border-l border-b border-t border-r-0 border-gray-200 text-sm font-medium  hover:bg-gray-50 focus:z-10 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 ${active ? "bg-gray-50 text-blue-500" : isDisabled ? "bg-gray-50 text-gray-300" : "bg-white text-gray-600"} ${isLastItem ? "border-r rounded-r-md" : "border-r-0"}`,
      style: {
        visibility: hidden ? "hidden" : "visible",
        pointerEvents: hidden ? "none" : "auto"
      },
      onMouseDown: (e9) => {
        e9.preventDefault();
        if (isDisabled) {
          return;
        }
        wrapOrRewrapLink(editor);
        setIsExpanded((isExpanded22) => !isExpanded22);
      }
    }, import_react117.default.createElement("span", {
      className: "sr-only"
    }, label), import_react117.default.createElement(ToolbarIcon, {
      name: icon
    })), isExpanded2 && import_react117.default.createElement(LinkForm, {
      selection,
      onClose: () => {
        setIsExpanded(false);
      },
      onChange: (v6) => console.log(v6)
    }));
  }
  return import_react117.default.createElement("span", {
    "data-test": `${name2}Button`,
    className: `cursor-pointer w-full inline-flex relative justify-center items-center px-2 py-2 border-l border-b border-t border-r-0 border-gray-200 text-sm font-medium  hover:bg-gray-50 focus:z-10 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 ${active ? "bg-gray-50 text-blue-500" : "bg-white text-gray-600"} ${isLastItem ? "border-r rounded-r-md" : "border-r-0"}`,
    style: {
      visibility: hidden ? "hidden" : "visible",
      pointerEvents: hidden ? "none" : "auto"
    },
    onMouseDown
  }, import_react117.default.createElement("span", {
    className: "sr-only"
  }, label), import_react117.default.createElement(ToolbarIcon, {
    name: icon
  }));
};
var EmbedButton = ({
  editor,
  templates
}) => {
  return import_react117.default.createElement(Lt, {
    as: "span",
    className: "relative z-10 block",
    style: { width: "85px" }
  }, ({ open }) => import_react117.default.createElement(import_react117.default.Fragment, null, import_react117.default.createElement(Lt.Button, {
    as: "span",
    onMouseDown: (e9) => {
      e9.preventDefault();
    },
    className: `cursor-pointer relative inline-flex items-center px-2 py-2 rounded-r-md border text-sm font-medium transition-all ease-out duration-150 focus:z-10 focus:outline-none focus:ring-1 focus:ring-blue-500 focus:border-blue-500 ${open ? `bg-gray-50 border-gray-200 text-blue-500` : `text-white border-blue-500 bg-blue-500`}`
  }, import_react117.default.createElement("span", {
    className: "text-sm font-semibold tracking-wide align-baseline mr-1"
  }, "Embed"), import_react117.default.createElement(PlusIcon, {
    className: `origin-center transition-all ease-out duration-150 ${open ? `rotate-45` : ``}`
  })), import_react117.default.createElement(tt2, {
    as: import_react117.Fragment,
    enter: "transition ease-out duration-100",
    enterFrom: "transform opacity-0 scale-95",
    enterTo: "transform opacity-100 scale-100",
    leave: "transition ease-in duration-75",
    leaveFrom: "transform opacity-100 scale-100",
    leaveTo: "transform opacity-0 scale-95"
  }, import_react117.default.createElement(Lt.Panel, null, ({ close: close2 }) => import_react117.default.createElement("div", {
    className: "origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none py-1 max-h-[10rem] overflow-y-auto"
  }, templates.map((template) => import_react117.default.createElement("span", {
    key: template.name,
    onMouseDown: (e9) => {
      e9.preventDefault();
      close2();
      insertMDX(editor, template);
    },
    className: `hover:bg-gray-50 hover:text-blue-500 cursor-pointer pointer-events-auto px-4 py-2 text-sm w-full flex items-center`
  }, template.label || template.name)))))));
};
var OverflowMenu = ({ toolbarItems, itemsShown, showEmbed }) => {
  return React68.createElement(Lt, {
    as: "span",
    className: "relative z-10 block w-full"
  }, React68.createElement(Lt.Button, {
    "data-test": "popoverRichTextButton",
    as: "span",
    className: `cursor-pointer relative w-full justify-center inline-flex border border-gray-200 focus:border-blue-500 items-center px-2 py-2 bg-white text-sm font-medium text-gray-600 hover:bg-gray-50 focus:z-10 focus:outline-none focus:ring-1 focus:ring-blue-500 pointer-events-auto ${showEmbed ? `rounded-none` : `rounded-r-md`}`,
    onMouseDown: (e9) => {
      e9.preventDefault();
    }
  }, React68.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    className: "h-5 w-5",
    fill: "none",
    viewBox: "0 0 24 24",
    stroke: "currentColor"
  }, React68.createElement("path", {
    strokeLinecap: "round",
    strokeLinejoin: "round",
    strokeWidth: 2,
    d: "M12 5v.01M12 12v.01M12 19v.01M12 6a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2zm0 7a1 1 0 110-2 1 1 0 010 2z"
  }))), React68.createElement(tt2, {
    as: import_react117.Fragment,
    enter: "transition ease-out duration-100",
    enterFrom: "transform opacity-0 scale-95",
    enterTo: "transform opacity-100 scale-100",
    leave: "transition ease-in duration-75",
    leaveFrom: "transform opacity-100 scale-100",
    leaveTo: "transform opacity-0 scale-95"
  }, React68.createElement(Lt.Panel, null, ({ close: close2 }) => React68.createElement("div", {
    className: "origin-top-right absolute right-0 mt-2 -mr-1 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none py-1"
  }, toolbarItems.map((toolbarItem, index2) => {
    if (index2 < itemsShown - 1) {
      return null;
    }
    return React68.createElement("span", {
      "data-test": `${toolbarItem.name}OverflowButton`,
      key: toolbarItem.name,
      onMouseDown: (event) => {
        event.preventDefault();
        close2();
        toolbarItem.onMouseDown(event);
      },
      className: classNames$1(toolbarItem.active ? "bg-gray-50 text-blue-500" : "bg-white text-gray-600", "hover:bg-gray-50 hover:text-blue-500 cursor-pointer pointer-events-auto px-4 py-2 text-sm w-full flex items-center")
    }, React68.createElement("div", {
      className: "mr-2 opacity-80"
    }, React68.createElement(ToolbarIcon, {
      name: toolbarItem.name
    })), " ", toolbarItem.label);
  })))));
};
var useResize = (ref2, callback) => {
  import_react117.default.useEffect(() => {
    const resizeObserver = new ResizeObserver((entries) => {
      for (const entry of entries) {
        callback(entry);
      }
    });
    if (ref2.current) {
      resizeObserver.observe(ref2.current);
    }
    return () => resizeObserver.disconnect();
  }, [ref2.current]);
};
var FloatingToolbarWrapper = ({
  children,
  position: position3
}) => {
  const ref2 = React68.useRef();
  const editor = useEditorState();
  const { selection } = editor;
  React68.useEffect(() => {
    const el = ref2.current;
    if (!el) {
      return;
    }
    if (!selection || !isEditorFocused(editor) || Range.isCollapsed(selection) || getEditorString(editor, selection) === "") {
      el.classList.add("hidden");
      el.classList.remove("block");
      return;
    }
    el.classList.add("block");
    el.classList.remove("hidden");
    const run = async () => {
      if (ref2.current) {
        const domSelection = window.getSelection();
        const domRange = domSelection.getRangeAt(0);
        const { x: x7, y: y9 } = await computePosition2(domRange, ref2.current, {
          placement: position3 || "top",
          middleware: [flip2(), shift5()]
        });
        Object.assign(ref2.current.style, {
          left: `${x7}px`,
          top: `${y9}px`
        });
      }
    };
    run();
  }, [JSON.stringify(selection), ref2.current]);
  return React68.createElement("div", {
    ref: ref2,
    className: "absolute z-10"
  }, children);
};
var headers = [
  {
    name: ELEMENT_H1,
    render: React68.createElement("h1", {
      className: "my-0 text-4xl font-medium"
    }, "Heading 1")
  },
  {
    name: ELEMENT_H2,
    render: React68.createElement("h2", {
      className: "my-0 text-3xl font-medium"
    }, "Heading 2")
  },
  {
    name: ELEMENT_H3,
    render: React68.createElement("h3", {
      className: "my-0 text-2xl font-semibold"
    }, "Heading 3")
  },
  {
    name: ELEMENT_H4,
    render: React68.createElement("h4", {
      className: "my-0 text-xl font-bold"
    }, "Heading 4")
  },
  {
    name: ELEMENT_H5,
    render: React68.createElement("h5", {
      className: "my-0 text-lg font-bold"
    }, "Heading 5")
  },
  {
    name: ELEMENT_H6,
    render: React68.createElement("h6", {
      className: "my-0 text-base font-bold"
    }, "Heading 6")
  },
  { name: ELEMENT_PARAGRAPH, render: React68.createElement("p", {
    className: "my-0"
  }, "Paragraph") }
];
var ICON_WIDTH = 40;
var EMBED_ICON_WIDTH = 85;
function Toolbar({
  templates
}) {
  const { setRawMode } = useEditorContext();
  const showEmbed = templates.length > 0;
  const toolbarRef = React68.useRef(null);
  const editor = useEditorState();
  const isBoldActive = helpers.isMarkActive(editor, MARK_BOLD);
  const isCodeActive = helpers.isMarkActive(editor, MARK_CODE);
  const isItalicActive = helpers.isMarkActive(editor, MARK_ITALIC);
  const isLinkActive2 = helpers.isNodeActive(editor, ELEMENT_LINK);
  const ulActive = helpers.isListActive(editor, ELEMENT_UL);
  const olActive = helpers.isListActive(editor, ELEMENT_OL);
  const codeBlockActive = helpers.isNodeActive(editor, ELEMENT_CODE_BLOCK);
  const blockQuoteActive = helpers.isNodeActive(editor, ELEMENT_BLOCKQUOTE);
  const isImgActive = helpers.isNodeActive(editor, ELEMENT_IMG);
  const toolbarItems = [
    {
      name: "heading",
      label: "Heading",
      active: false,
      options: headers.map((item) => React68.createElement("span", {
        key: item.name,
        onMouseDown: getPreventDefaultHandler(toggleNodeType, editor, {
          activeType: item.name
        }),
        className: classNames$1("hover:bg-gray-100 hover:text-gray-900 cursor-pointer block px-4 py-2 text-sm w-full text-left")
      }, item.render))
    },
    {
      name: "link",
      label: "Link",
      active: isLinkActive2
    },
    {
      name: "image",
      label: "Image",
      active: isImgActive
    },
    {
      name: "quote",
      label: "Quote",
      active: blockQuoteActive,
      onMouseDown: getPreventDefaultHandler(toggleNodeType, editor, {
        activeType: ELEMENT_BLOCKQUOTE
      })
    },
    {
      name: "ul",
      label: "Bullet List",
      active: ulActive,
      onMouseDown: getPreventDefaultHandler(toggleList, editor, {
        type: ELEMENT_UL
      })
    },
    {
      name: "ol",
      label: "List",
      active: olActive,
      onMouseDown: getPreventDefaultHandler(toggleList, editor, {
        type: ELEMENT_OL
      })
    },
    {
      name: "code",
      label: "Code",
      active: isCodeActive,
      onMouseDown: getPreventDefaultHandler(toggleMark, editor, {
        key: MARK_CODE
      })
    },
    {
      name: "codeBlock",
      label: "Code Block",
      active: codeBlockActive,
      onMouseDown: getPreventDefaultHandler(insertEmptyCodeBlock, editor)
    },
    {
      name: "bold",
      label: "Bold",
      active: isBoldActive,
      onMouseDown: getPreventDefaultHandler(toggleMark, editor, {
        key: MARK_BOLD
      })
    },
    {
      name: "italic",
      label: "Italic",
      active: isItalicActive,
      onMouseDown: getPreventDefaultHandler(toggleMark, editor, {
        key: MARK_ITALIC
      })
    },
    {
      name: "raw",
      label: "Raw",
      active: false,
      onMouseDown: () => setRawMode(true)
    }
  ];
  const [itemsShown, setItemsShown] = React68.useState(toolbarItems.length);
  useResize(toolbarRef, (entry) => {
    const width = entry.target.getBoundingClientRect().width;
    const itemsShown2 = (width - (showEmbed ? EMBED_ICON_WIDTH : 0)) / ICON_WIDTH;
    setItemsShown(Math.floor(itemsShown2));
  });
  return React68.createElement("div", {
    className: "sticky -top-4 inline-flex shadow rounded-md mb-2 z-50 max-w-full",
    style: {
      width: `${toolbarItems.length * ICON_WIDTH + (showEmbed ? EMBED_ICON_WIDTH : 0)}px`
    }
  }, React68.createElement("div", {
    ref: toolbarRef,
    className: "grid w-full",
    style: {
      gridTemplateColumns: showEmbed ? `1fr ${EMBED_ICON_WIDTH}px` : `1fr`
    }
  }, React68.createElement("div", {
    className: "grid",
    style: {
      gridTemplateColumns: `repeat(auto-fit, minmax(${ICON_WIDTH}px, 1fr))`,
      gridTemplateRows: "auto",
      gridAutoRows: 0
    }
  }, toolbarItems.map((toolbarItem, index2) => {
    const isLastItem = index2 + 1 === itemsShown;
    const hidden = index2 + 1 > itemsShown;
    if (itemsShown < toolbarItems.length) {
      if (isLastItem) {
        return React68.createElement(OverflowMenu, {
          key: toolbarItem.name,
          itemsShown,
          toolbarItems,
          showEmbed
        });
      } else {
        return React68.createElement(ToolbarItem, {
          key: toolbarItem.name,
          name: toolbarItem.name,
          hidden,
          active: toolbarItem.active,
          onMouseDown: toolbarItem.onMouseDown,
          label: toolbarItem.label,
          options: toolbarItem.options,
          icon: toolbarItem.name,
          isLastItem: isLastItem && !showEmbed
        });
      }
    } else {
      return React68.createElement(ToolbarItem, {
        key: toolbarItem.name,
        name: toolbarItem.name,
        hidden,
        active: toolbarItem.active,
        onMouseDown: toolbarItem.onMouseDown,
        label: toolbarItem.label,
        options: toolbarItem.options,
        icon: toolbarItem.name,
        isLastItem: isLastItem && !showEmbed
      });
    }
  })), showEmbed && React68.createElement(EmbedButton, {
    templates,
    editor
  })));
}
var FloatingLink = () => {
  const editor = useEditorState();
  const isLinkActive2 = helpers.isNodeActive(editor, ELEMENT_LINK);
  return React68.createElement(FloatingToolbarWrapper, {
    position: "bottom"
  }, isLinkActive2 && React68.createElement("button", {
    onMouseDown: (e9) => {
      e9.preventDefault();
      unwrapLink(editor);
    },
    className: "mt-2 cursor-pointer hover:bg-gray-100 border border-gray-200 rounded-md bg-gray-100 text-gray-600 py-1 px-2"
  }, "Clear"));
};
var buildError = (element) => {
  return {
    message: element.message,
    position: element.position && {
      endColumn: element.position.end.column,
      startColumn: element.position.start.column,
      startLineNumber: element.position.start.line,
      endLineNumber: element.position.end.line
    }
  };
};
var buildErrorMessage = (element) => {
  if (!element) {
    return "";
  }
  const errorMessage = buildError(element);
  const message = errorMessage ? `${errorMessage.message}${errorMessage.position ? ` at line: ${errorMessage.position.startLineNumber}, column: ${errorMessage.position.startColumn}` : ""}` : null;
  return message;
};
var ELEMENT_INVALID_MARKDOWN = "invalid_markdown";
var createInvalidMarkdownPlugin = createPluginFactory({
  key: ELEMENT_INVALID_MARKDOWN,
  isVoid: true,
  isInline: false,
  isElement: true,
  component: ({ attributes, element, children }) => {
    return import_react117.default.createElement("div", {
      ...attributes
    }, import_react117.default.createElement(ErrorMessage, {
      error: element
    }), children);
  }
});
function ErrorMessage({ error: error2 }) {
  const message = buildErrorMessage(error2);
  const { setRawMode } = useEditorContext();
  return import_react117.default.createElement("div", {
    contentEditable: false,
    className: "bg-red-50 sm:rounded-lg"
  }, import_react117.default.createElement("div", {
    className: "px-4 py-5 sm:p-6"
  }, import_react117.default.createElement("h3", {
    className: "text-lg leading-6 font-medium text-red-800"
  }, "Error parsing markdown"), import_react117.default.createElement("div", {
    className: "mt-2 max-w-xl text-sm text-red-800 space-y-4"
  }, import_react117.default.createElement("p", null, message), import_react117.default.createElement("p", null, "To fix these errors, edit the content in raw-mode."), import_react117.default.createElement("button", {
    onClick: () => setRawMode(true),
    className: "rounded-l-md border-r-0 shadow rounded-md bg-white cursor-pointer relative inline-flex items-center px-2 py-2 border border-gray-200 hover:text-white text-sm font-medium transition-all ease-out duration-150 hover:bg-gray-500 focus:z-10 focus:outline-none focus:ring-1 focus:ring-gray-500 focus:border-gray-500"
  }, "Switch to raw-mode"))));
}
var RichEditor = (props) => {
  const initialValue = import_react117.default.useMemo(() => {
    var _a, _b;
    return ((_b = (_a = props.input.value) == null ? void 0 : _a.children) == null ? void 0 : _b.length) ? props.input.value.children.map(helpers.normalize) : [{ type: "p", children: [{ type: "text", text: "" }] }];
  }, []);
  const plugins$2 = import_react117.default.useMemo(() => createPlugins([
    ...plugins$1,
    ...plugins,
    createMdxBlockPlugin(),
    createMdxInlinePlugin(),
    createImgPlugin(),
    createInvalidMarkdownPlugin(),
    createLinkPlugin()
  ], {
    components: components()
  }), []);
  const tempId = [props.tinaForm.id, props.input.name].join(".");
  const id = import_react117.default.useMemo(() => uuid() + tempId, [tempId]);
  return import_react117.default.createElement("div", {
    className: "with-toolbar"
  }, import_react117.default.createElement(Plate, {
    id,
    initialValue,
    plugins: plugins$2,
    onChange: (value) => {
      props.input.onChange({
        type: "root",
        children: value
      });
    },
    firstChildren: import_react117.default.createElement(import_react117.default.Fragment, null, import_react117.default.createElement(Toolbar, {
      templates: props.field.templates,
      inlineOnly: false
    }), import_react117.default.createElement(FloatingLink, null))
  }));
};
var MdxFieldPlugin = {
  name: "rich-text",
  Component: wrapFieldsWithMeta((props) => {
    const [rawMode, setRawMode] = import_react117.default.useState(false);
    const [key, setKey] = import_react117.default.useState(0);
    import_react117.default.useMemo(() => {
      const { reset } = props.form;
      props.form.reset = (initialValues) => {
        setKey((key2) => key2 + 1);
        return reset(initialValues);
      };
    }, []);
    return import_react117.default.createElement(EditorContext2.Provider, {
      key,
      value: { templates: props.field.templates, rawMode, setRawMode }
    }, import_react117.default.createElement("div", {
      className: "min-h-[100px] max-w-full tina-prose relative shadow-inner focus-within:shadow-outline focus-within:border-blue-500 block w-full bg-white border border-gray-200 text-gray-600 focus-within:text-gray-900 rounded-md px-3 py-2"
    }, import_react117.default.createElement(RichEditor, {
      ...props
    })));
  })
};
var MdxFieldPluginExtendible = {
  name: "rich-text",
  validate(value) {
    if (typeof value !== "undefined" && value !== null && value.children[0] && value.children[0].type === "invalid_markdown") {
      return "Unable to parse rich-text";
    } else {
      return void 0;
    }
  },
  Component: wrapFieldsWithMeta((props) => {
    const [key, setKey] = import_react117.default.useState(0);
    import_react117.default.useMemo(() => {
      const { reset } = props.form;
      props.form.reset = (initialValues) => {
        setKey((key2) => key2 + 1);
        return reset(initialValues);
      };
    }, []);
    return import_react117.default.createElement(EditorContext2.Provider, {
      key,
      value: {
        templates: props.field.templates,
        rawMode: props.rawMode,
        setRawMode: props.setRawMode
      }
    }, import_react117.default.createElement("div", {
      className: "min-h-[100px] max-w-full tina-prose relative shadow-inner focus-within:shadow-outline focus-within:border-blue-500 block w-full bg-white border border-gray-200 text-gray-600 focus-within:text-gray-900 rounded-md px-3 py-2"
    }, props.rawMode ? props.rawEditor : import_react117.default.createElement(RichEditor, {
      ...props
    })));
  })
};
var PluginTypeManager = class {
  constructor(events) {
    this.events = events;
    this.plugins = {};
  }
  getType(type) {
    return this.plugins[type] = this.plugins[type] || new PluginType(type, this.events);
  }
  findOrCreateMap(type) {
    return this.getType(type);
  }
  add(plugin) {
    this.findOrCreateMap(plugin.__type).add(plugin);
  }
  remove(plugin) {
    this.findOrCreateMap(plugin.__type).remove(plugin);
  }
  all(type) {
    return this.findOrCreateMap(type).all();
  }
};
var PluginType = class {
  constructor(__type, events) {
    this.__type = __type;
    this.events = events;
    this.__plugins = {};
  }
  add(plugin) {
    const p12 = plugin;
    if (!p12.__type) {
      p12.__type = this.__type;
    }
    this.__plugins[p12.name] = p12;
    this.events.dispatch({ type: `plugin:add:${this.__type}` });
  }
  all() {
    return Object.keys(this.__plugins).map((name2) => this.__plugins[name2]);
  }
  find(name2) {
    return this.__plugins[name2];
  }
  remove(pluginOrName) {
    const name2 = typeof pluginOrName === "string" ? pluginOrName : pluginOrName.name;
    const plugin = this.__plugins[name2];
    delete this.__plugins[name2];
    this.events.dispatch({ type: `plugin:remove:${this.__type}` });
    return plugin;
  }
  subscribe(cb) {
    return this.events.subscribe(`plugin:*:${this.__type}`, cb);
  }
};
var EventBus = class {
  constructor() {
    this.listeners = /* @__PURE__ */ new Set();
  }
  subscribe(event, callback) {
    let events;
    if (typeof event === "string") {
      events = [event];
    } else {
      events = event;
    }
    const newListeners = events.map((event2) => new Listener(event2, callback));
    newListeners.forEach((newListener) => this.listeners.add(newListener));
    return () => {
      newListeners.forEach((listener) => this.listeners.delete(listener));
    };
  }
  dispatch(event) {
    if (!this.listeners)
      return;
    const listenerSnapshot = Array.from(this.listeners.values());
    listenerSnapshot.forEach((listener) => listener.handleEvent(event));
  }
};
var Listener = class {
  constructor(eventPattern, callback) {
    this.eventPattern = eventPattern;
    this.callback = callback;
  }
  handleEvent(event) {
    if (this.watchesEvent(event)) {
      this.callback(event);
      return true;
    }
    return false;
  }
  watchesEvent(currentEvent) {
    if (this.eventPattern === "*")
      return true;
    const eventParts = currentEvent.type.split(":");
    const patternParts = this.eventPattern.split(":");
    let index2 = 0;
    let ignoresEvent = false;
    while (!ignoresEvent && index2 < patternParts.length) {
      const wildcard = patternParts[index2] === "*";
      const matchingParts = patternParts[index2] === eventParts[index2];
      ignoresEvent = !(wildcard || matchingParts);
      index2++;
    }
    return !ignoresEvent;
  }
};
var s3ErrorRegex = /<Error>.*<Code>(.+)<\/Code>.*<Message>(.+)<\/Message>.*/;
var DummyMediaStore = class {
  constructor() {
    this.accept = "*";
  }
  async persist(files) {
    return files.map(({ directory, file }) => ({
      id: file.name,
      type: "file",
      directory,
      filename: file.name
    }));
  }
  async list() {
    const items = [];
    return {
      items,
      nextOffset: 0
    };
  }
  async delete() {
  }
};
var TinaMediaStore = class {
  constructor(cms) {
    this.fetchFunction = (input, init) => {
      return fetch(input, init);
    };
    this.accept = DEFAULT_MEDIA_UPLOAD_TYPES;
    this.parse = (img) => {
      return img.src;
    };
    this.cms = cms;
  }
  setup() {
    var _a, _b, _c, _d;
    if (!this.api) {
      this.api = (_b = (_a = this.cms) == null ? void 0 : _a.api) == null ? void 0 : _b.tina;
      this.isLocal = !!this.api.isLocalMode;
      const contentApiUrl = new URL(this.api.contentApiUrl);
      this.url = `${contentApiUrl.origin}/media`;
      if (!this.isLocal) {
        if ((_d = (_c = this.api.options) == null ? void 0 : _c.tinaioConfig) == null ? void 0 : _d.assetsApiUrlOverride) {
          const url = new URL(this.api.assetsApiUrl);
          this.url = `${url.origin}/v1/${this.api.clientId}`;
        } else {
          this.url = `${contentApiUrl.origin.replace("content", "assets")}/v1/${this.api.clientId}`;
        }
      }
    }
  }
  async isAuthenticated() {
    this.setup();
    return await this.api.isAuthenticated();
  }
  async persist_cloud(media) {
    const newFiles = [];
    if (await this.isAuthenticated()) {
      for (const item of media) {
        const path = `${item.directory && item.directory !== "/" ? `${item.directory}/${item.file.name}` : item.file.name}`;
        const res = await this.api.fetchWithToken(`${this.url}/upload_url/${path}`, { method: "GET" });
        const { signedUrl } = await res.json();
        if (!signedUrl) {
          throw new Error("Unexpected error generating upload url");
        }
        const uploadRes = await this.fetchFunction(signedUrl, {
          method: "PUT",
          body: item.file,
          headers: {
            "Content-Type": item.file.type || "application/octet-stream",
            "Content-Length": String(item.file.size)
          }
        });
        if (!uploadRes.ok) {
          const xmlRes = await uploadRes.text();
          const matches = s3ErrorRegex.exec(xmlRes);
          console.error(xmlRes);
          if (!matches) {
            throw new Error("Unexpected error uploading media asset");
          } else {
            throw new Error(`Upload error: '${matches[2]}'`);
          }
        }
        const src = `https://assets.tina.io/${this.api.clientId}/${path}`;
        newFiles.push({
          directory: item.directory,
          filename: item.file.name,
          id: item.file.name,
          type: "file",
          thumbnails: {
            "75x75": src,
            "400x400": src,
            "1000x1000": src
          },
          src
        });
      }
    }
    return newFiles;
  }
  async persist_local(media) {
    var _a, _b, _c, _d, _e4, _f, _g, _h, _i;
    const newFiles = [];
    const hasTinaMedia = Object.keys(((_c = (_b = (_a = this.cms.api.tina.schema.schema) == null ? void 0 : _a.config) == null ? void 0 : _b.media) == null ? void 0 : _c.tina) || {}).includes("mediaRoot") && Object.keys(((_f = (_e4 = (_d = this.cms.api.tina.schema.schema) == null ? void 0 : _d.config) == null ? void 0 : _e4.media) == null ? void 0 : _f.tina) || {}).includes("publicFolder");
    let folder = hasTinaMedia ? (_i = (_h = (_g = this.cms.api.tina.schema.schema) == null ? void 0 : _g.config) == null ? void 0 : _h.media) == null ? void 0 : _i.tina.mediaRoot : "/";
    if (!folder.startsWith("/")) {
      folder = "/" + folder;
    }
    if (!folder.endsWith("/")) {
      folder = folder + "/";
    }
    for (const item of media) {
      const { file, directory } = item;
      const formData = new FormData();
      formData.append("file", file);
      formData.append("directory", directory);
      formData.append("filename", file.name);
      const uploadPath = `${directory ? `${directory}/${file.name}` : file.name}`;
      const filePath = `${directory ? `${directory}${folder}${file.name}` : folder + file.name}`;
      const res = await this.fetchFunction(`${this.url}/upload/${uploadPath}`, {
        method: "POST",
        body: formData
      });
      if (res.status != 200) {
        const responseData = await res.json();
        throw new Error(responseData.message);
      }
      const fileRes = await res.json();
      if (fileRes == null ? void 0 : fileRes.success) {
        const parsedRes = {
          type: "file",
          id: file.name,
          filename: file.name,
          directory,
          src: filePath
        };
        newFiles.push(parsedRes);
      } else {
        throw new Error("Unexpected error uploading media");
      }
    }
    return newFiles;
  }
  async persist(media) {
    this.setup();
    if (this.isLocal) {
      return this.persist_local(media);
    } else {
      return this.persist_cloud(media);
    }
  }
  genThumbnail(src, dimensions) {
    return !this.isLocal ? `${src}?fit=crop&max-w=${dimensions.w}&max-h=${dimensions.h}` : src;
  }
  async list(options) {
    this.setup();
    let res;
    if (!this.isLocal) {
      if (await this.isAuthenticated()) {
        res = await this.api.fetchWithToken(`${this.url}/list/${options.directory || ""}?limit=${options.limit | 20}${options.offset ? `&cursor=${options.offset}` : ""}`);
        if (res.status == 401) {
          throw E_UNAUTHORIZED;
        }
        if (res.status == 404) {
          throw E_BAD_ROUTE;
        }
      } else {
        throw new Error("Not authenticated");
      }
    } else {
      res = await this.fetchFunction(`${this.url}/list/${options.directory || ""}?limit=${options.limit | 20}${options.offset ? `&cursor=${options.offset}` : ""}`);
      if (res.status == 404) {
        throw E_BAD_ROUTE;
      }
      if (res.status >= 500) {
        const { e: e9 } = await res.json();
        const error2 = new Error("Unexpected error");
        console.error(e9);
        throw error2;
      }
    }
    const { cursor, files, directories } = await res.json();
    const items = [];
    for (const file of files) {
      items.push({
        directory: options.directory || "",
        type: "file",
        id: file.filename,
        filename: file.filename,
        src: file.src,
        thumbnails: options.thumbnailSizes.reduce((acc, { w: w7, h: h11 }) => {
          acc[`${w7}x${h11}`] = this.genThumbnail(file.src, { w: w7, h: h11 });
          return acc;
        }, {})
      });
    }
    for (const dir of directories) {
      items.push({
        type: "dir",
        id: dir,
        directory: options.directory || "",
        filename: dir
      });
    }
    return {
      items,
      nextOffset: cursor || 0
    };
  }
  async delete(media) {
    const path = `${media.directory ? `${media.directory}/${media.filename}` : media.filename}`;
    if (!this.isLocal) {
      if (await this.isAuthenticated()) {
        await this.api.fetchWithToken(`${this.url}/${path}`, {
          method: "DELETE"
        });
      } else {
        throw E_UNAUTHORIZED;
      }
    } else {
      await this.fetchFunction(`${this.url}/${path}`, {
        method: "DELETE"
      });
    }
  }
};
var MediaManager$1 = class {
  constructor(store, events) {
    this.store = store;
    this.events = events;
    this._pageSize = 20;
  }
  get isConfigured() {
    return !(this.store instanceof DummyMediaStore);
  }
  get pageSize() {
    return this._pageSize;
  }
  set pageSize(pageSize) {
    this._pageSize = pageSize;
    this.events.dispatch({
      type: "media:pageSize",
      pageSize
    });
  }
  open(options = {}) {
    this.events.dispatch({
      type: "media:open",
      ...options
    });
  }
  get accept() {
    return this.store.accept;
  }
  async persist(files) {
    try {
      this.events.dispatch({ type: "media:upload:start", uploaded: files });
      const media = await this.store.persist(files);
      this.events.dispatch({
        type: "media:upload:success",
        uploaded: files,
        media
      });
      return media;
    } catch (error2) {
      console.error(error2);
      this.events.dispatch({
        type: "media:upload:failure",
        uploaded: files,
        error: error2
      });
      throw error2;
    }
  }
  async delete(media) {
    try {
      this.events.dispatch({ type: "media:delete:start", media });
      await this.store.delete(media);
      this.events.dispatch({
        type: "media:delete:success",
        media
      });
    } catch (error2) {
      this.events.dispatch({
        type: "media:delete:failure",
        media,
        error: error2
      });
      throw error2;
    }
  }
  async list(options) {
    try {
      this.events.dispatch({ type: "media:list:start", ...options });
      const media = await this.store.list(options);
      this.events.dispatch({ type: "media:list:success", ...options, media });
      return media;
    } catch (error2) {
      this.events.dispatch({ type: "media:list:failure", ...options, error: error2 });
      throw error2;
    }
  }
};
var MediaListError = class extends Error {
  constructor(config2) {
    super(config2.message);
    this.ERR_TYPE = "MediaListError";
    this.title = config2.title;
    this.docsLink = config2.docsLink;
  }
};
var E_UNAUTHORIZED = new MediaListError({
  title: "Unauthorized",
  message: "You don't have access to this resource.",
  docsLink: "https://tina.io/docs/reference/media/overview"
});
var E_BAD_ROUTE = new MediaListError({
  title: "Bad Route",
  message: "The Cloudinary API route is missing or misconfigured.",
  docsLink: "https://tina.io/docs/reference/media/external/authentication/"
});
new MediaListError({
  title: "An Error Occurred",
  message: "Something went wrong accessing your media from Tina Cloud.",
  docsLink: ""
});
var Flags = class {
  constructor(events) {
    this.events = events;
    this._flags = /* @__PURE__ */ new Map();
  }
  get(key) {
    return this._flags.get(key);
  }
  set(key, value) {
    this._flags.set(key, value);
    this.events.dispatch({ type: "flag:set", key, value });
  }
};
var _CMS = class {
  constructor(config2 = {}) {
    this._enabled = false;
    this.api = {};
    this.unsubscribeHooks = {};
    this.events = new EventBus();
    this.media = new MediaManager$1(new DummyMediaStore(), this.events);
    this.enable = () => {
      this._enabled = true;
      this.events.dispatch(_CMS.ENABLED);
    };
    this.disable = () => {
      this._enabled = false;
      this.events.dispatch(_CMS.DISABLED);
    };
    this.toggle = () => {
      if (this.enabled) {
        this.disable();
      } else {
        this.enable();
      }
    };
    this.plugins = new PluginTypeManager(this.events);
    this.flags = new Flags(this.events);
    if (config2.media) {
      this.media.store = config2.media;
    } else {
      this.media.store = new DummyMediaStore();
    }
    if (config2.mediaOptions && config2.mediaOptions.pageSize) {
      this.media.pageSize = config2.mediaOptions.pageSize;
    }
    if (config2.plugins) {
      config2.plugins.forEach((plugin) => this.plugins.add(plugin));
    }
    if (config2.apis) {
      Object.entries(config2.apis).forEach(([name2, api]) => this.registerApi(name2, api));
    }
    if (config2.enabled) {
      this.enable();
    }
  }
  registerApi(name2, api) {
    if (this.unsubscribeHooks[name2]) {
      this.unsubscribeHooks[name2]();
    }
    if (api.events instanceof EventBus) {
      const unsubscribeHost = api.events.subscribe("*", this.events.dispatch);
      const unsubscribeGuest = this.events.subscribe("*", (e9) => api.events.dispatch(e9));
      this.unsubscribeHooks[name2] = () => {
        unsubscribeHost();
        unsubscribeGuest();
      };
    }
    this.api[name2] = api;
  }
  get enabled() {
    return this._enabled;
  }
  get disabled() {
    return !this._enabled;
  }
};
var CMS = _CMS;
CMS.ENABLED = { type: "cms:enable" };
CMS.DISABLED = { type: "cms:disable" };
var Alerts$1 = class {
  constructor(events, map5 = {}) {
    this.events = events;
    this.map = map5;
    this.alerts = /* @__PURE__ */ new Map();
    this.mapEventToAlert = (event) => {
      const toAlert = this.map[event.type];
      if (toAlert) {
        let getArgs;
        if (typeof toAlert === "function") {
          getArgs = toAlert;
        } else {
          getArgs = () => toAlert;
        }
        const { level, message, timeout } = getArgs(event);
        this.add(level, message, timeout);
      }
    };
    this.events.subscribe("*", this.mapEventToAlert);
  }
  setMap(eventsToAlerts) {
    this.map = {
      ...this.map,
      ...eventsToAlerts
    };
  }
  add(level, message, timeout = 3e3) {
    const alert = {
      level,
      message,
      timeout,
      id: `${message}|${Date.now()}`
    };
    this.alerts.set(alert.id, alert);
    this.events.dispatch({ type: "alerts:add", alert });
    let timeoutId = null;
    const dismiss = () => {
      clearTimeout(timeoutId);
      this.dismiss(alert);
    };
    timeoutId = level !== "error" ? setTimeout(dismiss, alert.timeout) : null;
    return dismiss;
  }
  dismiss(alert) {
    this.alerts.delete(alert.id);
    this.events.dispatch({ type: "alerts:remove", alert });
  }
  subscribe(cb) {
    const unsub = this.events.subscribe("alerts", cb);
    return () => unsub();
  }
  get all() {
    return Array.from(this.alerts.values());
  }
  info(message, timeout) {
    return this.add("info", message, timeout);
  }
  success(message, timeout) {
    return this.add("success", message, timeout);
  }
  warn(message, timeout) {
    return this.add("warn", message, timeout);
  }
  error(message, timeout) {
    return this.add("error", message, timeout);
  }
};
function createScreen({
  Component: Component9,
  props,
  ...options
}) {
  return {
    __type: "screen",
    layout: "popup",
    ...options,
    Component(screenProps) {
      return import_react117.default.createElement(Component9, {
        ...screenProps,
        ...props
      });
    }
  };
}
function useScreenPlugin(options, deps) {
  const memo2 = (0, import_react117.useMemo)(() => {
    return createScreen(options);
  }, deps);
  usePlugins(memo2);
}
var ScreenPluginModal = ({
  screen,
  close: close2
}) => {
  return React68.createElement(ModalLayout, {
    name: screen.name,
    close: close2,
    layout: screen.layout
  }, React68.createElement(screen.Component, {
    close: close2
  }));
};
var ModalLayout = ({ children, name: name2, close: close2, layout }) => {
  let Wrapper2;
  switch (layout) {
    case "popup":
      Wrapper2 = ModalPopup;
      break;
    case "fullscreen":
      Wrapper2 = ModalFullscreen;
      break;
    default:
      Wrapper2 = ModalPopup;
      break;
  }
  return React68.createElement(Modal, null, React68.createElement(Wrapper2, null, React68.createElement(ModalHeader, {
    close: close2
  }, name2), React68.createElement(ModalBody, {
    className: layout === "fullscreen" ? "flex h-full flex-col" : ""
  }, children)));
};
var ListFieldMeta = ({
  name: name2,
  label,
  description,
  error: error2,
  margin = true,
  children,
  actions,
  index: index2,
  tinaForm,
  triggerHoverEvents,
  ...props
}) => {
  const { dispatch: setHoveredField } = useEvent2("field:hover");
  const { dispatch: setFocusedField } = useEvent2("field:focus");
  const hoverEvents = {};
  if (triggerHoverEvents) {
    hoverEvents["onMouseOver"] = () => setHoveredField({ id: tinaForm.id, fieldName: name2 });
    hoverEvents["onMouseOut"] = () => setHoveredField({ id: null, fieldName: null });
  }
  return React68.createElement(FieldWrapper, {
    margin,
    ...hoverEvents,
    onClick: () => setFocusedField({ id: tinaForm.id, fieldName: name2 }),
    style: { zIndex: index2 ? 1e3 - index2 : void 0 },
    ...props
  }, React68.createElement(ListHeader, null, React68.createElement(ListMeta, null, label !== false && React68.createElement(ListLabel, null, label || name2), description && React68.createElement(FieldDescription, {
    className: "whitespace-nowrap text-ellipsis overflow-hidden"
  }, description)), actions && actions), children, error2 && typeof error2 === "string" && React68.createElement(FieldError, null, error2));
};
var ListHeader = ({ children }) => {
  return React68.createElement("span", {
    className: "relative flex gap-2 w-full justify-between items-center mb-2"
  }, children);
};
var ListMeta = ({ children }) => {
  return React68.createElement("div", {
    className: "flex-1 truncate"
  }, children);
};
var ListLabel = ({ children }) => {
  return React68.createElement("span", {
    className: `m-0 text-xs font-semibold flex-1 text-ellipsis overflow-hidden transition-all ease-out duration-100 text-left`
  }, children);
};
var ListPanel = ({ className = "", ...props }) => React68.createElement("div", {
  className: `max-h-[initial] relative h-auto rounded-md shadow bg-gray-100 ${className}`,
  ...props
});
var EmptyList = ({ message = "There are no items" }) => React68.createElement("div", {
  className: "text-center bg-gray-100 text-gray-300 leading-[1.35] py-3 text-[15px] font-normal"
}, message);
var Group = ({ tinaForm, form, field, input, meta, index: index2 }) => {
  const addItem = React68.useCallback(() => {
    let obj = {};
    if (typeof field.defaultItem === "function") {
      obj = field.defaultItem();
    } else {
      obj = field.defaultItem || {};
    }
    form.mutators.insert(field.name, 0, obj);
  }, [form, field]);
  const items = input.value || [];
  const itemProps = React68.useCallback((item) => {
    if (!field.itemProps)
      return {};
    return field.itemProps(item);
  }, [field.itemProps]);
  const isMax = items.length >= (field.max || Infinity);
  const isMin = items.length <= (field.min || 0);
  const fixedLength = field.min === field.max;
  return React68.createElement(ListFieldMeta, {
    name: input.name,
    label: field.label,
    description: field.description,
    error: meta.error,
    index: index2,
    triggerHoverEvents: false,
    tinaForm,
    actions: (!fixedLength || fixedLength && !isMax) && React68.createElement(IconButton, {
      onClick: addItem,
      disabled: isMax,
      variant: "primary",
      size: "small"
    }, React68.createElement(AddIcon, {
      className: "w-5/6 h-auto"
    }))
  }, React68.createElement(ListPanel, null, React68.createElement("div", null, React68.createElement(ConnectedDroppable, {
    droppableId: field.name,
    type: field.name
  }, (provider) => React68.createElement("div", {
    ref: provider.innerRef
  }, items.length === 0 && React68.createElement(EmptyList, null), items.map((item, index22) => React68.createElement(Item$1, {
    key: index22,
    tinaForm,
    field,
    item,
    index: index22,
    isMin,
    fixedLength,
    ...itemProps(item)
  })), provider.placeholder)))));
};
var Item$1 = ({
  tinaForm,
  field,
  index: index2,
  item,
  label,
  isMin,
  fixedLength,
  ...p12
}) => {
  const cms = useCMS$1();
  const FormPortal = useFormPortal();
  const [isExpanded2, setExpanded] = React68.useState(false);
  const removeItem = React68.useCallback(() => {
    tinaForm.mutators.remove(field.name, index2);
  }, [tinaForm, field, index2]);
  const title = label || (field.label || field.name) + " Item";
  const { dispatch: setHoveredField } = useEvent2("field:hover");
  const { dispatch: setFocusedField } = useEvent2("field:focus");
  return React68.createElement(PublicDraggable, {
    type: field.name,
    draggableId: `${field.name}.${index2}`,
    index: index2
  }, (provider, snapshot) => React68.createElement(React68.Fragment, null, React68.createElement(ItemHeader, {
    provider,
    isDragging: snapshot.isDragging,
    ...p12
  }, React68.createElement(DragHandle, {
    isDragging: snapshot.isDragging
  }), React68.createElement(ItemClickTarget, {
    onMouseOver: () => setHoveredField({
      id: tinaForm.id,
      fieldName: `${field.name}.${index2}`
    }),
    onMouseOut: () => setHoveredField({ id: null, fieldName: null }),
    onClick: () => {
      const state = tinaForm.finalForm.getState();
      if (state.invalid === true) {
        cms.alerts.error("Cannot navigate away from an invalid form.");
        return;
      }
      setExpanded(true);
      setFocusedField({
        id: tinaForm.id,
        fieldName: `${field.name}.${index2}`
      });
    }
  }, React68.createElement(GroupLabel, null, title), React68.createElement(BiPencil, {
    className: "h-5 w-auto fill-current text-gray-200 group-hover:text-inherit transition-colors duration-150 ease-out"
  })), (!fixedLength || fixedLength && !isMin) && React68.createElement(ItemDeleteButton, {
    disabled: isMin,
    onClick: removeItem
  })), React68.createElement(FormPortal, null, ({ zIndexShift }) => React68.createElement(Panel$1, {
    isExpanded: isExpanded2,
    setExpanded,
    field,
    index: index2,
    tinaForm,
    itemTitle: title,
    zIndexShift
  }))));
};
var ItemClickTarget = ({ children, ...props }) => {
  return React68.createElement("div", {
    className: "group text-gray-400 hover:text-blue-600 flex-1 min-w-0 relative flex justify-between items-center p-2",
    ...props
  }, children);
};
var GroupLabel = ({
  error: error2,
  children
}) => {
  return React68.createElement("span", {
    className: `m-0 text-xs font-semibold flex-1 text-ellipsis overflow-hidden transition-all ease-out duration-100 text-left ${error2 ? `text-red-500` : `text-gray-600 group-hover:text-inherit`}`
  }, children);
};
var ItemHeader = ({
  isDragging,
  children,
  provider,
  ...props
}) => {
  return React68.createElement("div", {
    className: `relative group cursor-pointer flex justify-between items-stretch bg-white border border-gray-100 -mb-px overflow-visible p-0 text-sm font-normal ${isDragging ? `rounded shadow text-blue-600` : `text-gray-600 first:rounded-t last:rounded-b`}`,
    ref: provider.innerRef,
    ...provider.draggableProps,
    ...provider.dragHandleProps,
    ...props
  }, children);
};
var ItemDeleteButton = ({ onClick, disabled = false }) => {
  return React68.createElement("button", {
    className: `w-8 px-1 py-2.5 flex items-center justify-center hover:bg-gray-50 text-gray-200 hover:text-red-500 ${disabled && "pointer-events-none opacity-30 cursor-not-allowed"}`,
    onClick
  }, React68.createElement(TrashIcon, {
    className: "fill-current transition-colors ease-out duration-100"
  }));
};
var DragHandle = ({ isDragging }) => {
  return React68.createElement("div", {
    className: `relative w-8 px-1 py-2.5 flex items-center justify-center hover:bg-gray-50 group cursor-[grab] ${isDragging ? `text-blue-500` : `text-gray-200 hover:text-gray-600`}`
  }, isDragging ? React68.createElement(ReorderIcon, {
    className: "fill-current w-7 h-auto"
  }) : React68.createElement(React68.Fragment, null, React68.createElement(DragIcon, {
    className: "fill-current w-7 h-auto group-hover:opacity-0 transition-opacity duration-150 ease-out"
  }), React68.createElement(ReorderIcon, {
    className: "fill-current w-7 h-auto absolute top-1/2 left-1/2 -translate-y-1/2 -translate-x-1/2 opacity-0 group-hover:opacity-100 transition-opacity duration-150 ease-out"
  })));
};
var Panel$1 = function Panel22({
  setExpanded,
  isExpanded: isExpanded2,
  tinaForm,
  field,
  index: index2,
  itemTitle,
  zIndexShift
}) {
  const cms = useCMS$1();
  const fields = React68.useMemo(() => {
    return field.fields.map((subField) => ({
      ...subField,
      name: `${field.name}.${index2}.${subField.name}`
    }));
  }, [field.fields, field.name, index2]);
  return React68.createElement(GroupPanel, {
    isExpanded: isExpanded2,
    style: { zIndex: zIndexShift + 1e3 }
  }, React68.createElement(PanelHeader, {
    onClick: () => {
      const state = tinaForm.finalForm.getState();
      if (state.invalid === true) {
        cms.alerts.error("Cannot navigate away from an invalid form.");
        return;
      }
      setExpanded(false);
    }
  }, itemTitle), React68.createElement(PanelBody, {
    id: tinaForm.id
  }, isExpanded2 ? React68.createElement(FieldsBuilder, {
    form: tinaForm,
    fields
  }) : null));
};
var GroupListField = Group;
var GroupListFieldPlugin = {
  name: "group-list",
  Component: GroupListField
};
var BlockSelector = ({
  templates,
  addItem
}) => {
  const showFilter = React68.useMemo(() => {
    return Object.entries(templates).length > 6;
  }, [templates]);
  const [filter, setFilter] = React68.useState("");
  const filteredBlocks = React68.useMemo(() => {
    return Object.entries(templates).filter(([name2, template]) => {
      return template.label ? template.label.toLowerCase().includes(filter.toLowerCase()) || name2.toLowerCase().includes(filter.toLowerCase()) : name2.toLowerCase().includes(filter.toLowerCase());
    });
  }, [filter]);
  return React68.createElement(Lt, null, ({ open }) => React68.createElement(React68.Fragment, null, React68.createElement(Lt.Button, {
    as: "span"
  }, React68.createElement(IconButton, {
    variant: open ? "secondary" : "primary",
    size: "small",
    className: `${open ? `rotate-45 pointer-events-none` : ``}`
  }, React68.createElement(AddIcon, {
    className: "w-5/6 h-auto"
  }))), React68.createElement("div", {
    className: "transform translate-y-full absolute -bottom-1 right-0 z-50"
  }, React68.createElement(tt2, {
    enter: "transition duration-150 ease-out",
    enterFrom: "transform opacity-0 -translate-y-2",
    enterTo: "transform opacity-100 translate-y-0",
    leave: "transition duration-75 ease-in",
    leaveFrom: "transform opacity-100 translate-y-0",
    leaveTo: "transform opacity-0 -translate-y-2"
  }, React68.createElement(Lt.Panel, {
    className: "relative overflow-hidden rounded-lg shadow-lg bg-white border border-gray-100"
  }, ({ close: close2 }) => React68.createElement("div", {
    className: "min-w-[192px] max-h-[24rem] overflow-y-auto flex flex-col w-full h-full"
  }, showFilter && React68.createElement("div", {
    className: "sticky top-0 bg-gray-50 p-2 border-b border-gray-100 z-10"
  }, React68.createElement("input", {
    type: "text",
    className: "bg-white text-xs rounded-sm border border-gray-100 shadow-inner py-1 px-2 w-full block placeholder-gray-200",
    onClick: (event) => {
      event.stopPropagation();
      event.preventDefault();
    },
    value: filter,
    onChange: (event) => {
      setFilter(event.target.value);
    },
    placeholder: "Filter..."
  })), filteredBlocks.length === 0 && React68.createElement("span", {
    className: "relative text-center text-xs px-2 py-3 text-gray-300 bg-gray-50 italic"
  }, "No matches found"), filteredBlocks.length > 0 && filteredBlocks.map(([name2, template]) => React68.createElement("button", {
    className: "relative text-center text-xs py-2 px-4 border-l-0 border-t-0 border-r-0 border-b border-gray-50 w-full outline-none transition-all ease-out duration-150 hover:text-blue-500 focus:text-blue-500 focus:bg-gray-50 hover:bg-gray-50",
    key: name2,
    onClick: () => {
      addItem(name2, template);
      setFilter("");
      close2();
    }
  }, template.label ? template.label : name2))))))));
};
var BlockSelectorBig = ({
  templates,
  addItem,
  label
}) => {
  const FormPortal = useFormPortal();
  const [pickerIsOpen, setPickerIsOpen] = React68.useState(false);
  const showFilter = React68.useMemo(() => {
    return Object.entries(templates).length > 6;
  }, [templates]);
  const [filter, setFilter] = React68.useState("");
  const filteredTemplates = React68.useMemo(() => {
    return Object.entries(templates).filter(([name2, template]) => {
      return template.label ? template.label.toLowerCase().includes(filter.toLowerCase()) || name2.toLowerCase().includes(filter.toLowerCase()) : name2.toLowerCase().includes(filter.toLowerCase());
    });
  }, [filter]);
  const categories = React68.useMemo(() => {
    return [
      ...new Set(Object.entries(templates).filter(([name2, template]) => {
        return template.category ? template.category : false;
      }).map(([name2, template]) => {
        return template.category;
      }))
    ];
  }, [templates]);
  const hasUncategorized = React68.useMemo(() => {
    return Object.entries(templates).filter(([name2, template]) => {
      return !template.category;
    }).length > 0;
  }, [templates]);
  const uncategorized = React68.useMemo(() => {
    return filteredTemplates.filter(([name2, template]) => {
      return !template.category;
    });
  }, [filteredTemplates]);
  const close2 = (name2, template) => {
    if (name2 && template) {
      addItem(name2, template);
    }
    setFilter("");
    setPickerIsOpen(false);
  };
  return React68.createElement(React68.Fragment, null, React68.createElement(IconButton, {
    variant: pickerIsOpen ? "secondary" : "primary",
    size: "small",
    className: `${pickerIsOpen ? `rotate-45 pointer-events-none` : ``}`,
    onClick: () => setPickerIsOpen(!pickerIsOpen)
  }, React68.createElement(AddIcon, {
    className: "w-5/6 h-auto"
  })), React68.createElement(FormPortal, null, ({ zIndexShift }) => React68.createElement(tt2, {
    show: pickerIsOpen
  }, React68.createElement(tt2.Child, {
    as: React68.Fragment,
    enter: "transform transition-all ease-out duration-200",
    enterFrom: "opacity-0 -translate-x-1/2",
    enterTo: "opacity-100 translate-x-0",
    leave: "transform transition-all ease-in duration-150",
    leaveFrom: "opacity-100 translate-x-0",
    leaveTo: "opacity-0 -translate-x-1/2"
  }, React68.createElement("div", {
    className: "absolute left-0 top-0 z-panel h-full w-full transform bg-gray-50",
    style: { zIndex: zIndexShift + 1e3 }
  }, React68.createElement(PanelHeader, {
    onClick: () => {
      setPickerIsOpen(false);
    }
  }, label, " ⁠– Add New"), React68.createElement("div", {
    className: "h-full overflow-y-auto max-h-full bg-gray-50 pt-4 px-6 pb-12"
  }, React68.createElement("div", {
    className: "w-full flex justify-center"
  }, React68.createElement("div", {
    className: "w-full max-w-form"
  }, showFilter && React68.createElement("div", {
    className: "block relative group mb-1"
  }, React68.createElement("input", {
    type: "text",
    className: "shadow-inner focus:shadow-outline focus:border-blue-400 focus:outline-none block text-sm pl-2.5 pr-8 py-1.5 text-gray-600 w-full bg-white border border-gray-200 focus:text-gray-900 rounded-md placeholder-gray-400 hover:placeholder-gray-600 transition-all ease-out duration-150",
    onClick: (event) => {
      event.stopPropagation();
      event.preventDefault();
    },
    value: filter,
    onChange: (event) => {
      setFilter(event.target.value);
    },
    placeholder: "Search"
  }), filter === "" ? React68.createElement(BiSearch, {
    className: "absolute right-3 top-1/2 -translate-y-1/2 w-5 h-auto text-blue-500 opacity-70 group-hover:opacity-100 transition-all ease-out duration-150"
  }) : React68.createElement("button", {
    onClick: () => {
      setFilter("");
    },
    className: "outline-none focus:outline-none bg-transparent border-0 p-0 m-0 absolute right-2.5 top-1/2 -translate-y-1/2 opacity-50 hover:opacity-100 transition-all ease-out duration-150"
  }, React68.createElement(MdOutlineClear, {
    className: "w-5 h-auto text-gray-600"
  }))), uncategorized.length === 0 && categories.length === 0 && React68.createElement(EmptyState, null, "No blocks to display."), uncategorized.length > 0 && categories.length === 0 && React68.createElement(CardColumns, {
    className: "pt-3"
  }, uncategorized.map(([name2, template]) => React68.createElement(BlockCard, {
    key: `${template}-${name2}`,
    close: close2,
    name: name2,
    template
  }))), categories.map((category, index2) => {
    return React68.createElement(BlockGroup, {
      key: index2,
      templates: filteredTemplates.filter(([name2, template]) => {
        return template.category && template.category === category ? true : false;
      }),
      category,
      isLast: index2 === categories.length - 1 && !hasUncategorized,
      close: close2
    });
  }), hasUncategorized && uncategorized.length === 0 && React68.createElement("div", {
    className: "relative text-gray-500 block text-left w-full text-base font-bold tracking-wide py-2 truncate pointer-events-none opacity-50"
  }, "Uncategorized"), uncategorized.length > 0 && categories.length > 0 && React68.createElement(BlockGroup, {
    templates: uncategorized,
    category: "Uncategorized",
    close: close2,
    isLast: true
  })))))))));
};
var BlockGroup = ({ category, templates, close: close2, isLast = false }) => {
  return React68.createElement(ve, {
    defaultOpen: true,
    as: "div",
    className: `left-0 right-0 relative`
  }, ({ open }) => React68.createElement(React68.Fragment, null, React68.createElement(ve.Button, {
    className: `relative block group text-left w-full text-base font-bold tracking-wide py-2 truncate ${templates.length === 0 ? `pointer-events-none` : ``} ${!isLast && (!open || templates.length === 0) && `border-b border-gray-100`}`
  }, React68.createElement("span", {
    className: `text-gray-500 group-hover:text-gray-800 transition-all ease-out duration-150 ${templates.length === 0 ? `opacity-50` : ``}`
  }, category), templates.length > 0 && React68.createElement(MdKeyboardArrowDown, {
    className: `absolute top-1/2 right-0 w-6 h-auto -translate-y-1/2 text-gray-300 origin-center group-hover:text-blue-500 transition-all duration-150 ease-out ${open ? `` : `-rotate-90 opacity-70 group-hover:opacity-100`}`
  })), React68.createElement(tt2, {
    enter: "transition duration-100 ease-out",
    enterFrom: "transform scale-95 opacity-0",
    enterTo: "transform scale-100 opacity-100",
    leave: "transition duration-75 ease-out",
    leaveFrom: "transform scale-100 opacity-100",
    leaveTo: "transform scale-95 opacity-0"
  }, React68.createElement(ve.Panel, null, templates.length > 0 && React68.createElement(CardColumns, null, templates.map(([name2, template]) => React68.createElement(BlockCard, {
    close: close2,
    name: name2,
    template
  })))))));
};
var CardColumns = ({ children, className = "" }) => {
  return React68.createElement("div", {
    className: `w-full mb-1 -mt-2 ${className}`,
    style: { columns: "320px", columnGap: "16px" }
  }, children);
};
var BlockCard = ({ close: close2, name: name2, template }) => {
  return React68.createElement("button", {
    className: "mb-2 mt-2 group relative text-xs font-bold border border-gray-100 w-full outline-none transition-all ease-out duration-150 hover:text-blue-500 focus:text-blue-500 focus:bg-gray-50 hover:bg-gray-50 rounded-md bg-white shadow overflow-hidden",
    style: { breakInside: "avoid", transform: "translateZ(0)" },
    key: name2,
    onClick: () => {
      close2(name2, template);
    }
  }, template.previewSrc && React68.createElement("img", {
    src: template.previewSrc,
    className: "w-full h-auto transition-all ease-out duration-150 group-hover:opacity-50"
  }), React68.createElement("span", {
    className: `relative flex justify-between items-center gap-4 w-full px-4 text-left ${template.previewSrc ? `py-2 border-t border-gray-100 ` : `py-3`}`
  }, template.label ? template.label : name2, React68.createElement(AddIcon, {
    className: "w-5 h-auto group-hover:text-blue-500 opacity-30 transition-all ease-out duration-150 group-hover:opacity-80"
  })));
};
var EmptyState = ({ children }) => {
  return React68.createElement("div", {
    className: "block relative text-gray-300 italic py-1"
  }, children);
};
var Blocks = ({
  tinaForm,
  form,
  field,
  input,
  meta,
  index: index2
}) => {
  const addItem = React68.useCallback((name2, template) => {
    let obj = {};
    if (typeof template.defaultItem === "function") {
      obj = template.defaultItem();
    } else {
      obj = template.defaultItem || {};
    }
    obj._template = name2;
    form.mutators.insert(field.name, 0, obj);
  }, [field.name, form.mutators]);
  const items = input.value || [];
  const isMax = items.length >= (field.max || Infinity);
  const isMin = items.length <= (field.min || 0);
  const fixedLength = field.min === field.max;
  return React68.createElement(ListFieldMeta, {
    name: input.name,
    label: field.label,
    description: field.description,
    error: meta.error,
    triggerHoverEvents: false,
    index: index2,
    tinaForm,
    actions: (!fixedLength || fixedLength && !isMax) && (!field.visualSelector ? React68.createElement(BlockSelector, {
      templates: field.templates,
      addItem
    }) : React68.createElement(BlockSelectorBig, {
      label: field.label || field.name,
      templates: field.templates,
      addItem
    }))
  }, React68.createElement(ListPanel, null, React68.createElement(ConnectedDroppable, {
    droppableId: field.name,
    type: field.name
  }, (provider) => React68.createElement("div", {
    ref: provider.innerRef,
    className: "edit-page--list-parent"
  }, items.length === 0 && React68.createElement(EmptyList, null), items.map((block, index22) => {
    const template = field.templates[block._template];
    if (!template) {
      return React68.createElement(InvalidBlockListItem, {
        key: index22,
        index: index22,
        field,
        tinaForm
      });
    }
    const itemProps = (item) => {
      if (!template.itemProps)
        return {};
      return template.itemProps(item);
    };
    return React68.createElement(BlockListItem, {
      key: index22,
      block,
      template,
      index: index22,
      field,
      tinaForm,
      isMin,
      fixedLength,
      ...itemProps(block)
    });
  }), provider.placeholder))));
};
var BlockListItem = ({
  label,
  tinaForm,
  field,
  index: index2,
  template,
  block,
  isMin,
  fixedLength
}) => {
  const cms = useCMS$1();
  const FormPortal = useFormPortal();
  const [isExpanded2, setExpanded] = React68.useState(false);
  const removeItem = React68.useCallback(() => {
    tinaForm.mutators.remove(field.name, index2);
  }, [tinaForm, field, index2]);
  const { dispatch: setHoveredField } = useEvent2("field:hover");
  const { dispatch: setFocusedField } = useEvent2("field:focus");
  return React68.createElement(PublicDraggable, {
    key: index2,
    type: field.name,
    draggableId: `${field.name}.${index2}`,
    index: index2
  }, (provider, snapshot) => React68.createElement(React68.Fragment, null, React68.createElement(ItemHeader, {
    provider,
    isDragging: snapshot.isDragging
  }, React68.createElement(DragHandle, {
    isDragging: snapshot.isDragging
  }), React68.createElement(ItemClickTarget, {
    onClick: () => {
      const state = tinaForm.finalForm.getState();
      if (state.invalid === true) {
        cms.alerts.error("Cannot navigate away from an invalid form.");
        return;
      }
      setExpanded(true);
      setFocusedField({
        id: tinaForm.id,
        fieldName: `${field.name}.${index2}`
      });
    },
    onMouseOver: () => setHoveredField({
      id: tinaForm.id,
      fieldName: `${field.name}.${index2}`
    }),
    onMouseOut: () => setHoveredField({ id: null, fieldName: null })
  }, React68.createElement(GroupLabel, null, label || template.label), React68.createElement(BiPencil, {
    className: "h-5 w-auto fill-current text-gray-200 group-hover:text-inherit transition-colors duration-150 ease-out"
  })), (!fixedLength || fixedLength && !isMin) && React68.createElement(ItemDeleteButton, {
    disabled: isMin,
    onClick: removeItem
  })), React68.createElement(FormPortal, null, ({ zIndexShift }) => React68.createElement(Panel, {
    zIndexShift,
    isExpanded: isExpanded2,
    setExpanded,
    field,
    item: block,
    index: index2,
    tinaForm,
    label: label || template.label,
    template
  }))));
};
var InvalidBlockListItem = ({
  tinaForm,
  field,
  index: index2
}) => {
  const removeItem = React68.useCallback(() => {
    tinaForm.mutators.remove(field.name, index2);
  }, [tinaForm, field, index2]);
  return React68.createElement(PublicDraggable, {
    key: index2,
    type: field.name,
    draggableId: `${field.name}.${index2}`,
    index: index2
  }, (provider, snapshot) => React68.createElement(ItemHeader, {
    provider,
    isDragging: snapshot.isDragging
  }, React68.createElement(DragHandle, {
    isDragging: snapshot.isDragging
  }), React68.createElement(ItemClickTarget, null, React68.createElement(GroupLabel, {
    error: true
  }, "Invalid Block")), React68.createElement(ItemDeleteButton, {
    onClick: removeItem
  })));
};
var Panel = function Panel23({
  setExpanded,
  isExpanded: isExpanded2,
  tinaForm,
  field,
  index: index2,
  label,
  template,
  zIndexShift
}) {
  const cms = useCMS$1();
  const fields = React68.useMemo(() => {
    if (!template.fields)
      return [];
    return template.fields.map((subField) => ({
      ...subField,
      name: `${field.name}.${index2}.${subField.name}`
    }));
  }, [field.name, index2, template.fields]);
  return React68.createElement(GroupPanel, {
    isExpanded: isExpanded2,
    style: { zIndex: zIndexShift + 1e3 }
  }, React68.createElement(PanelHeader, {
    onClick: () => {
      const state = tinaForm.finalForm.getState();
      if (state.invalid === true) {
        cms.alerts.error("Cannot navigate away from an invalid form.");
        return;
      }
      setExpanded(false);
    }
  }, label), React68.createElement(PanelBody, {
    id: tinaForm.id
  }, isExpanded2 ? React68.createElement(FieldsBuilder, {
    form: tinaForm,
    fields
  }) : null));
};
var BlocksField = Blocks;
var BlocksFieldPlugin = {
  name: "blocks",
  Component: BlocksField
};
var parse$2 = (value) => value || "";
var ColorField = wrapFieldsWithMeta(({ input, field }) => {
  return React68.createElement(ColorPicker, {
    colorFormat: field.colorFormat,
    userColors: field.colors,
    widget: field.widget,
    input
  });
});
var ColorFieldPlugin = {
  name: "color",
  Component: ColorField,
  parse: parse$2,
  validate(value, values3, meta, field) {
    if (field.required && !value)
      return "Required";
  }
};
var List = ({ tinaForm, form, field, input, meta, index: index2 }) => {
  const addItem = React68.useCallback(() => {
    let newItem = "";
    if (typeof field.defaultItem === "function") {
      newItem = field.defaultItem();
    } else if (typeof field.defaultItem !== "undefined") {
      newItem = field.defaultItem;
    }
    form.mutators.insert(field.name, 0, newItem);
  }, [form, field]);
  const items = input.value || [];
  const itemProps = React68.useCallback((item) => {
    if (!field.itemProps)
      return {};
    return field.itemProps(item);
  }, [field.itemProps]);
  const isMax = items.length >= (field.max || Infinity);
  const isMin = items.length <= (field.min || 0);
  const fixedLength = field.min === field.max;
  return React68.createElement(ListFieldMeta, {
    name: input.name,
    label: field.label,
    description: field.description,
    error: meta.error,
    index: index2,
    tinaForm,
    actions: (!fixedLength || fixedLength && !isMax) && React68.createElement(IconButton, {
      onClick: addItem,
      variant: "primary",
      size: "small"
    }, React68.createElement(AddIcon, {
      className: "w-5/6 h-auto"
    }))
  }, React68.createElement(ListPanel, null, React68.createElement("div", null, React68.createElement(ConnectedDroppable, {
    droppableId: field.name,
    type: field.name
  }, (provider) => React68.createElement("div", {
    ref: provider.innerRef
  }, items.length === 0 && React68.createElement(EmptyList, null), items.map((item, index22) => React68.createElement(Item, {
    key: index22,
    tinaForm,
    field,
    item,
    index: index22,
    isMin,
    fixedLength,
    ...itemProps(item)
  })), provider.placeholder)))));
};
var Item = ({
  tinaForm,
  field,
  index: index2,
  item,
  label,
  isMin,
  fixedLength,
  ...p12
}) => {
  const removeItem = React68.useCallback(() => {
    tinaForm.mutators.remove(field.name, index2);
  }, [tinaForm, field, index2]);
  const fields = [
    {
      type: field.type,
      list: field.list,
      parentTypename: field.parentTypename,
      ...field.field,
      label: false,
      name: field.name + "." + index2
    }
  ];
  return React68.createElement(PublicDraggable, {
    type: field.name,
    draggableId: `${field.name}.${index2}`,
    index: index2
  }, (provider, snapshot) => React68.createElement(ItemHeader, {
    provider,
    isDragging: snapshot.isDragging,
    ...p12
  }, React68.createElement(DragHandle, {
    isDragging: snapshot.isDragging
  }), React68.createElement(ItemClickTarget, null, React68.createElement(FieldsBuilder, {
    padding: false,
    form: tinaForm,
    fields
  })), (!fixedLength || fixedLength && !isMin) && React68.createElement(ItemDeleteButton, {
    disabled: isMin,
    onClick: removeItem
  })));
};
var ListField = List;
var ListFieldPlugin = {
  name: "list",
  Component: ListField,
  validate(value, values3, meta, field) {
    if (field.required && !value)
      return "Required";
  }
};
var ImageField = wrapFieldsWithMeta((props) => {
  const cms = useCMS$1();
  const { value } = props.input;
  const src = value;
  const [isImgUploading, setIsImgUploading] = (0, import_react117.useState)(false);
  let onClear;
  if (props.field.clearable) {
    onClear = () => props.input.onChange("");
  }
  async function onChange(media) {
    var _a, _b;
    if (media) {
      const parsedValue = typeof ((_b = (_a = cms == null ? void 0 : cms.media) == null ? void 0 : _a.store) == null ? void 0 : _b.parse) === "function" ? cms.media.store.parse(media) : media;
      props.input.onChange(parsedValue);
    }
  }
  const uploadDir = props.field.uploadDir || (() => "");
  return React68.createElement(ImageUpload, {
    value,
    src,
    loading: isImgUploading,
    onClick: () => {
      const directory = uploadDir(props.form.getState().values);
      cms.media.open({
        allowDelete: true,
        directory,
        onSelect: onChange
      });
    },
    onDrop: async ([file], fileRejections) => {
      setIsImgUploading(true);
      try {
        if (file) {
          const directory = uploadDir(props.form.getState().values);
          const [media] = await cms.media.persist([
            {
              directory,
              file
            }
          ]);
          if (media) {
            await onChange(media);
          }
        }
        const errorCodes = {
          "file-invalid-type": "Invalid file type",
          "file-too-large": "File too large",
          "file-too-small": "File too small",
          "too-many-files": "Too many files"
        };
        const printError = (error2) => {
          const message = errorCodes[error2.code];
          if (message) {
            return message;
          }
          console.error(error2);
          return "Unknown error";
        };
        if (fileRejections.length > 0) {
          const messages = [];
          fileRejections.map((fileRejection) => {
            messages.push(`${fileRejection.file.name}: ${fileRejection.errors.map((error2) => printError(error2)).join(", ")}`);
          });
          cms.alerts.error(() => {
            return React68.createElement(React68.Fragment, null, "Upload Failed. ", React68.createElement("br", null), messages.join(". "), ".");
          });
        }
      } catch (error2) {
        console.error("Error uploading media asset: ", error2);
      } finally {
        setIsImgUploading(false);
      }
    },
    onClear
  });
});
var ImageFieldPlugin = {
  name: "image",
  Component: ImageField,
  parse: parse$2,
  validate(value, values3, meta, field) {
    if (field.required && !value)
      return "Required";
  }
};
var parse$1 = (value) => value && +value;
var NumberField = wrapFieldsWithMeta(({ input, field }) => {
  return React68.createElement(NumberInput, {
    ...input,
    step: field.step
  });
});
var NumberFieldPlugin = {
  name: "number",
  Component: NumberField,
  parse: parse$1,
  validate(value, values3, meta, field) {
    if (field.required && typeof value !== "number")
      return "Required";
  }
};
var SelectField = wrapFieldsWithMeta(Select);
var SelectFieldPlugin = {
  name: "select",
  type: "select",
  Component: SelectField,
  parse: parse$2,
  validate(value, values3, meta, field) {
    if (field.required && !value)
      return "Required";
  }
};
var RadioGroupField = wrapFieldsWithMeta(RadioGroup);
var RadioGroupFieldPlugin = {
  name: "radio-group",
  Component: RadioGroupField,
  validate(value, values3, meta, field) {
    if (field.required && !value)
      return "Required";
  }
};
var TextareaField = wrapFieldsWithMeta(({ input }) => React68.createElement(TextArea, {
  ...input
}));
var TextareaFieldPlugin = {
  name: "textarea",
  Component: TextareaField,
  parse: parse$2,
  validate(value, values3, meta, field) {
    if (field.required && !value)
      return "Required";
  }
};
var TextField = wrapFieldsWithMeta(({ input, field }) => {
  var _a;
  return React68.createElement(BaseTextField, {
    ...input,
    disabled: (_a = field == null ? void 0 : field.disabled) != null ? _a : false,
    placeholder: field.placeholder
  });
});
var TextFieldPlugin = {
  name: "text",
  Component: TextField,
  validate(value, values3, meta, field) {
    if (field.required && !value)
      return "Required";
  },
  parse: parse$2
};
var ToggleField = wrapFieldsWithMeta(Toggle);
var ToggleFieldPlugin = {
  name: "toggle",
  type: "checkbox",
  Component: ToggleField,
  validate(value, values3, meta, field) {
    if (field.required && (typeof value === "undefined" || value === null))
      return "Required";
  }
};
var TagsField = wrapFieldsWithMeta(({ input, field, form, tinaForm }) => {
  const [value, setValue] = React68.useState("");
  const addTag = React68.useCallback((tag) => {
    var _a, _b;
    if ((_b = (_a = form.getFieldState(field.name)) == null ? void 0 : _a.value) == null ? void 0 : _b.includes(tag)) {
      return;
    }
    if (!tag.length) {
      return;
    }
    form.mutators.insert(field.name, 0, tag);
    setValue("");
  }, [form, field.name]);
  const items = input.value || [];
  return React68.createElement(React68.Fragment, null, React68.createElement("div", {
    className: "flex items-center gap-3"
  }, React68.createElement(BaseTextField, {
    value,
    onChange: (event) => setValue(event.target.value),
    placeholder: field.placeholder ? field.placeholder : "Add a tag",
    onKeyPress: (event) => {
      if (event.key === "," || event.key === "Enter") {
        event.preventDefault();
        addTag(value);
      }
    },
    className: "flex-1"
  }), React68.createElement(IconButton, {
    onClick: () => {
      addTag(value);
    },
    variant: "primary",
    size: "small",
    className: "flex-shrink-0"
  }, React68.createElement(AddIcon, {
    className: "w-5/6 h-auto"
  }))), React68.createElement("span", {
    className: "flex gap-2 flex-wrap mt-2 mb-0"
  }, items.length === 0 && React68.createElement("span", {
    className: "text-gray-300 text-sm italic"
  }, "No tags"), items.map((tag, index2) => React68.createElement(Tag, {
    key: tag,
    tinaForm,
    field,
    index: index2
  }, tag))));
});
var Tag = ({ tinaForm, field, index: index2, children, ...styleProps }) => {
  const removeItem = React68.useCallback(() => {
    tinaForm.mutators.remove(field.name, index2);
  }, [tinaForm, field, index2]);
  return React68.createElement("span", {
    className: "rounded-full shadow bg-white border border-gray-150 flex items-center tracking-[0.01em] leading-none text-gray-700",
    ...styleProps
  }, React68.createElement("span", {
    style: { maxHeight: "calc(var(--tina-sidebar-width) - 50px)" },
    className: "text-sm flex-1 pl-3 pr-1 py-1 truncate"
  }, children), React68.createElement("button", {
    className: "group text-center flex-shrink-0 border-0 bg-transparent pl-1 pr-2 py-1 text-gray-300 hover:text-blue-500 flex items-center justify-center cursor-pointer",
    onClick: removeItem
  }, React68.createElement(BiX, {
    className: "w-4 h-auto transition ease-out duration-100 group-hover:scale-110 origin-center"
  })));
};
var TagsFieldPlugin = {
  name: "tags",
  Component: TagsField,
  parse: parse$2
};
function ViewNavigation({
  onClickPrev,
  onClickSwitch,
  onClickNext,
  switchContent,
  switchColSpan,
  switchProps
}) {
  return import_react117.default.createElement("tr", null, import_react117.default.createElement("th", {
    className: "rdtPrev",
    onClick: onClickPrev
  }, import_react117.default.createElement("span", null, "‹")), import_react117.default.createElement("th", {
    className: "rdtSwitch",
    colSpan: switchColSpan,
    onClick: onClickSwitch,
    ...switchProps
  }, switchContent), import_react117.default.createElement("th", {
    className: "rdtNext",
    onClick: onClickNext
  }, import_react117.default.createElement("span", null, "›")));
}
var DaysView = class extends import_react117.default.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "_setDate", (e9) => {
      this.props.updateDate(e9);
    });
  }
  render() {
    return import_react117.default.createElement("div", {
      className: "rdtDays"
    }, import_react117.default.createElement("table", null, import_react117.default.createElement("thead", null, this.renderNavigation(), this.renderDayHeaders()), import_react117.default.createElement("tbody", null, this.renderDays()), this.renderFooter()));
  }
  renderNavigation() {
    const date2 = this.props.viewDate;
    const locale2 = date2.localeData();
    return import_react117.default.createElement(ViewNavigation, {
      onClickPrev: () => this.props.navigate(-1, "months"),
      onClickSwitch: () => this.props.showView("months"),
      onClickNext: () => this.props.navigate(1, "months"),
      switchContent: locale2.months(date2) + " " + date2.year(),
      switchColSpan: 5,
      switchProps: { "data-value": this.props.viewDate.month() }
    });
  }
  renderDayHeaders() {
    const locale2 = this.props.viewDate.localeData();
    let dayItems = getDaysOfWeek(locale2).map((day, index2) => import_react117.default.createElement("th", {
      key: day + index2,
      className: "dow"
    }, day));
    return import_react117.default.createElement("tr", null, dayItems);
  }
  renderDays() {
    const date2 = this.props.viewDate;
    const startOfMonth = date2.clone().startOf("month");
    const endOfMonth = date2.clone().endOf("month");
    let rows = [[], [], [], [], [], []];
    let startDate = date2.clone().subtract(1, "months");
    startDate.date(startDate.daysInMonth()).startOf("week");
    let endDate = startDate.clone().add(42, "d");
    let i15 = 0;
    while (startDate.isBefore(endDate)) {
      let row = getRow$2(rows, i15++);
      row.push(this.renderDay(startDate, startOfMonth, endOfMonth));
      startDate.add(1, "d");
    }
    return rows.map((r15, i22) => import_react117.default.createElement("tr", {
      key: `${endDate.month()}_${i22}`
    }, r15));
  }
  renderDay(date2, startOfMonth, endOfMonth) {
    let selectedDate = this.props.selectedDate;
    let dayProps = {
      key: date2.format("M_D"),
      "data-value": date2.date(),
      "data-month": date2.month(),
      "data-year": date2.year()
    };
    let className = "rdtDay";
    if (date2.isBefore(startOfMonth)) {
      className += " rdtOld";
    } else if (date2.isAfter(endOfMonth)) {
      className += " rdtNew";
    }
    if (selectedDate && date2.isSame(selectedDate, "day")) {
      className += " rdtActive";
    }
    if (date2.isSame(this.props.moment(), "day")) {
      className += " rdtToday";
    }
    if (this.props.isValidDate(date2)) {
      dayProps.onClick = this._setDate;
    } else {
      className += " rdtDisabled";
    }
    dayProps.className = className;
    return this.props.renderDay(dayProps, date2.clone(), selectedDate && selectedDate.clone());
  }
  renderFooter() {
    if (!this.props.timeFormat)
      return;
    const date2 = this.props.viewDate;
    return import_react117.default.createElement("tfoot", null, import_react117.default.createElement("tr", null, import_react117.default.createElement("td", {
      onClick: () => this.props.showView("time"),
      colSpan: 7,
      className: "rdtTimeToggle"
    }, date2.format(this.props.timeFormat))));
  }
};
__publicField(DaysView, "defaultProps", {
  isValidDate: () => true,
  renderDay: (props, date2) => import_react117.default.createElement("td", {
    ...props
  }, date2.date())
});
function getRow$2(rows, day) {
  return rows[Math.floor(day / 7)];
}
function getDaysOfWeek(locale2) {
  const first = locale2.firstDayOfWeek();
  let dow = [];
  let i15 = 0;
  locale2._weekdaysMin.forEach(function(day) {
    dow[(7 + i15++ - first) % 7] = day;
  });
  return dow;
}
var MonthsView = class extends import_react117.default.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "_updateSelectedMonth", (event) => {
      this.props.updateDate(event);
    });
  }
  render() {
    return import_react117.default.createElement("div", {
      className: "rdtMonths"
    }, import_react117.default.createElement("table", null, import_react117.default.createElement("thead", null, this.renderNavigation())), import_react117.default.createElement("table", null, import_react117.default.createElement("tbody", null, this.renderMonths())));
  }
  renderNavigation() {
    let year = this.props.viewDate.year();
    return import_react117.default.createElement(ViewNavigation, {
      onClickPrev: () => this.props.navigate(-1, "years"),
      onClickSwitch: () => this.props.showView("years"),
      onClickNext: () => this.props.navigate(1, "years"),
      switchContent: year,
      switchColSpan: "2"
    });
  }
  renderMonths() {
    let rows = [[], [], []];
    for (let month = 0; month < 12; month++) {
      let row = getRow$1(rows, month);
      row.push(this.renderMonth(month));
    }
    return rows.map((months2, i15) => import_react117.default.createElement("tr", {
      key: i15
    }, months2));
  }
  renderMonth(month) {
    const selectedDate = this.props.selectedDate;
    let className = "rdtMonth";
    let onClick;
    if (this.isDisabledMonth(month)) {
      className += " rdtDisabled";
    } else {
      onClick = this._updateSelectedMonth;
    }
    if (selectedDate && selectedDate.year() === this.props.viewDate.year() && selectedDate.month() === month) {
      className += " rdtActive";
    }
    let props = { key: month, className, "data-value": month, onClick };
    if (this.props.renderMonth) {
      return this.props.renderMonth(props, month, this.props.viewDate.year(), this.props.selectedDate && this.props.selectedDate.clone());
    }
    return import_react117.default.createElement("td", {
      ...props
    }, this.getMonthText(month));
  }
  isDisabledMonth(month) {
    let isValidDate = this.props.isValidDate;
    if (!isValidDate) {
      return false;
    }
    let date2 = this.props.viewDate.clone().set({ month });
    let day = date2.endOf("month").date() + 1;
    while (day-- > 1) {
      if (isValidDate(date2.date(day))) {
        return false;
      }
    }
    return true;
  }
  getMonthText(month) {
    const localMoment = this.props.viewDate;
    const monthStr = localMoment.localeData().monthsShort(localMoment.month(month));
    return capitalize(monthStr.substring(0, 3));
  }
};
function getRow$1(rows, year) {
  if (year < 4) {
    return rows[0];
  }
  if (year < 8) {
    return rows[1];
  }
  return rows[2];
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
var YearsView = class extends import_react117.default.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "disabledYearsCache", {});
    __publicField(this, "_updateSelectedYear", (event) => {
      this.props.updateDate(event);
    });
  }
  render() {
    return import_react117.default.createElement("div", {
      className: "rdtYears"
    }, import_react117.default.createElement("table", null, import_react117.default.createElement("thead", null, this.renderNavigation())), import_react117.default.createElement("table", null, import_react117.default.createElement("tbody", null, this.renderYears())));
  }
  renderNavigation() {
    const viewYear = this.getViewYear();
    return import_react117.default.createElement(ViewNavigation, {
      onClickPrev: () => this.props.navigate(-10, "years"),
      onClickSwitch: () => this.props.showView("years"),
      onClickNext: () => this.props.navigate(10, "years"),
      switchContent: `${viewYear}-${viewYear + 9}`
    });
  }
  renderYears() {
    const viewYear = this.getViewYear();
    let rows = [[], [], []];
    for (let year = viewYear - 1; year < viewYear + 11; year++) {
      let row = getRow(rows, year - viewYear);
      row.push(this.renderYear(year));
    }
    return rows.map((years2, i15) => import_react117.default.createElement("tr", {
      key: i15
    }, years2));
  }
  renderYear(year) {
    const selectedYear = this.getSelectedYear();
    let className = "rdtYear";
    let onClick;
    if (this.isDisabledYear(year)) {
      className += " rdtDisabled";
    } else {
      onClick = this._updateSelectedYear;
    }
    if (selectedYear === year) {
      className += " rdtActive";
    }
    let props = { key: year, className, "data-value": year, onClick };
    return this.props.renderYear(props, year, this.props.selectedDate && this.props.selectedDate.clone());
  }
  getViewYear() {
    return parseInt(this.props.viewDate.year() / 10, 10) * 10;
  }
  getSelectedYear() {
    return this.props.selectedDate && this.props.selectedDate.year();
  }
  isDisabledYear(year) {
    let cache = this.disabledYearsCache;
    if (cache[year] !== void 0) {
      return cache[year];
    }
    let isValidDate = this.props.isValidDate;
    if (!isValidDate) {
      return false;
    }
    let date2 = this.props.viewDate.clone().set({ year });
    let day = date2.endOf("year").dayOfYear() + 1;
    while (day-- > 1) {
      if (isValidDate(date2.dayOfYear(day))) {
        cache[year] = false;
        return false;
      }
    }
    cache[year] = true;
    return true;
  }
};
__publicField(YearsView, "defaultProps", {
  renderYear: (props, year) => import_react117.default.createElement("td", {
    ...props
  }, year)
});
function getRow(rows, year) {
  if (year < 3) {
    return rows[0];
  }
  if (year < 7) {
    return rows[1];
  }
  return rows[2];
}
var timeConstraints = {
  hours: {
    min: 0,
    max: 23,
    step: 1
  },
  minutes: {
    min: 0,
    max: 59,
    step: 1
  },
  seconds: {
    min: 0,
    max: 59,
    step: 1
  },
  milliseconds: {
    min: 0,
    max: 999,
    step: 1
  }
};
function createConstraints(overrideTimeConstraints) {
  let constraints = {};
  Object.keys(timeConstraints).forEach((type) => {
    constraints[type] = {
      ...timeConstraints[type],
      ...overrideTimeConstraints[type] || {}
    };
  });
  return constraints;
}
var TimeView = class extends import_react117.default.Component {
  constructor(props) {
    super(props);
    this.constraints = createConstraints(props.timeConstraints);
    this.state = this.getTimeParts(props.selectedDate || props.viewDate);
  }
  render() {
    let items = [];
    const timeParts = this.state;
    this.getCounters().forEach((c16, i15) => {
      if (i15 && c16 !== "ampm") {
        items.push(import_react117.default.createElement("div", {
          key: `sep${i15}`,
          className: "rdtCounterSeparator"
        }, ":"));
      }
      items.push(this.renderCounter(c16, timeParts[c16]));
    });
    return import_react117.default.createElement("div", {
      className: "rdtTime"
    }, import_react117.default.createElement("table", null, this.renderHeader(), import_react117.default.createElement("tbody", null, import_react117.default.createElement("tr", null, import_react117.default.createElement("td", null, import_react117.default.createElement("div", {
      className: "rdtCounters"
    }, items))))));
  }
  renderCounter(type, value) {
    if (type === "hours" && this.isAMPM()) {
      value = (value - 1) % 12 + 1;
      if (value === 0) {
        value = 12;
      }
    }
    if (type === "ampm") {
      if (this.props.timeFormat.indexOf(" A") !== -1) {
        value = this.props.viewDate.format("A");
      } else {
        value = this.props.viewDate.format("a");
      }
    }
    return import_react117.default.createElement("div", {
      key: type,
      className: "rdtCounter"
    }, import_react117.default.createElement("span", {
      className: "rdtBtn",
      onMouseDown: (e9) => this.onStartClicking(e9, "increase", type)
    }, "▲"), import_react117.default.createElement("div", {
      className: "rdtCount"
    }, value), import_react117.default.createElement("span", {
      className: "rdtBtn",
      onMouseDown: (e9) => this.onStartClicking(e9, "decrease", type)
    }, "▼"));
  }
  renderHeader() {
    if (!this.props.dateFormat)
      return;
    const date2 = this.props.selectedDate || this.props.viewDate;
    return import_react117.default.createElement("thead", null, import_react117.default.createElement("tr", null, import_react117.default.createElement("td", {
      className: "rdtSwitch",
      colSpan: "4",
      onClick: () => this.props.showView("days")
    }, date2.format(this.props.dateFormat))));
  }
  onStartClicking(e9, action, type) {
    if (e9 && e9.button && e9.button !== 0) {
      return;
    }
    if (type === "ampm")
      return this.toggleDayPart();
    let update4 = {};
    let body = document.body;
    update4[type] = this[action](type);
    this.setState(update4);
    this.timer = setTimeout(() => {
      this.increaseTimer = setInterval(() => {
        update4[type] = this[action](type);
        this.setState(update4);
      }, 70);
    }, 500);
    this.mouseUpListener = () => {
      clearTimeout(this.timer);
      clearInterval(this.increaseTimer);
      this.props.setTime(type, parseInt(this.state[type], 10));
      body.removeEventListener("mouseup", this.mouseUpListener);
      body.removeEventListener("touchend", this.mouseUpListener);
    };
    body.addEventListener("mouseup", this.mouseUpListener);
    body.addEventListener("touchend", this.mouseUpListener);
  }
  toggleDayPart() {
    let hours2 = parseInt(this.state.hours, 10);
    if (hours2 >= 12) {
      hours2 -= 12;
    } else {
      hours2 += 12;
    }
    this.props.setTime("hours", hours2);
  }
  increase(type) {
    const tc = this.constraints[type];
    let value = parseInt(this.state[type], 10) + tc.step;
    if (value > tc.max)
      value = tc.min + (value - (tc.max + 1));
    return pad(type, value);
  }
  decrease(type) {
    const tc = this.constraints[type];
    let value = parseInt(this.state[type], 10) - tc.step;
    if (value < tc.min)
      value = tc.max + 1 - (tc.min - value);
    return pad(type, value);
  }
  getCounters() {
    let counters = [];
    let format22 = this.props.timeFormat;
    if (format22.toLowerCase().indexOf("h") !== -1) {
      counters.push("hours");
      if (format22.indexOf("m") !== -1) {
        counters.push("minutes");
        if (format22.indexOf("s") !== -1) {
          counters.push("seconds");
          if (format22.indexOf("S") !== -1) {
            counters.push("milliseconds");
          }
        }
      }
    }
    if (this.isAMPM()) {
      counters.push("ampm");
    }
    return counters;
  }
  isAMPM() {
    return this.props.timeFormat.toLowerCase().indexOf(" a") !== -1;
  }
  getTimeParts(date2) {
    const hours2 = date2.hours();
    return {
      hours: pad("hours", hours2),
      minutes: pad("minutes", date2.minutes()),
      seconds: pad("seconds", date2.seconds()),
      milliseconds: pad("milliseconds", date2.milliseconds()),
      ampm: hours2 < 12 ? "am" : "pm"
    };
  }
  componentDidUpdate(prevProps) {
    if (this.props.selectedDate) {
      if (this.props.selectedDate !== prevProps.selectedDate) {
        this.setState(this.getTimeParts(this.props.selectedDate));
      }
    } else if (prevProps.viewDate !== this.props.viewDate) {
      this.setState(this.getTimeParts(this.props.viewDate));
    }
  }
};
function pad(type, value) {
  const padValues = {
    hours: 1,
    minutes: 2,
    seconds: 2,
    milliseconds: 3
  };
  let str = value + "";
  while (str.length < padValues[type])
    str = "0" + str;
  return str;
}
var viewModes = {
  YEARS: "years",
  MONTHS: "months",
  DAYS: "days",
  TIME: "time"
};
var TYPES = import_prop_types20.default;
var nofn = function() {
};
var datetype = TYPES.oneOfType([
  TYPES.instanceOf(moment_default),
  TYPES.instanceOf(Date),
  TYPES.string
]);
var Datetime = class extends import_react117.default.Component {
  constructor(props) {
    super(props);
    __publicField(this, "_renderCalendar", () => {
      const props2 = this.props;
      const state = this.state;
      let viewProps = {
        viewDate: state.viewDate.clone(),
        selectedDate: this.getSelectedDate(),
        isValidDate: props2.isValidDate,
        updateDate: this._updateDate,
        navigate: this._viewNavigate,
        moment: moment_default,
        showView: this._showView
      };
      switch (state.currentView) {
        case viewModes.YEARS:
          viewProps.renderYear = props2.renderYear;
          return import_react117.default.createElement(YearsView, {
            ...viewProps
          });
        case viewModes.MONTHS:
          viewProps.renderMonth = props2.renderMonth;
          return import_react117.default.createElement(MonthsView, {
            ...viewProps
          });
        case viewModes.DAYS:
          viewProps.renderDay = props2.renderDay;
          viewProps.timeFormat = this.getFormat("time");
          return import_react117.default.createElement(DaysView, {
            ...viewProps
          });
        default:
          viewProps.dateFormat = this.getFormat("date");
          viewProps.timeFormat = this.getFormat("time");
          viewProps.timeConstraints = props2.timeConstraints;
          viewProps.setTime = this._setTime;
          return import_react117.default.createElement(TimeView, {
            ...viewProps
          });
      }
    });
    __publicField(this, "_showView", (view, date2) => {
      const d17 = (date2 || this.state.viewDate).clone();
      const nextView = this.props.onBeforeNavigate(view, this.state.currentView, d17);
      if (nextView && this.state.currentView !== nextView) {
        this.props.onNavigate(nextView);
        this.setState({ currentView: nextView });
      }
    });
    __publicField(this, "viewToMethod", { days: "date", months: "month", years: "year" });
    __publicField(this, "nextView", { days: "time", months: "days", years: "months" });
    __publicField(this, "_updateDate", (e9) => {
      let state = this.state;
      let currentView = state.currentView;
      let updateOnView = this.getUpdateOn(this.getFormat("date"));
      let viewDate = this.state.viewDate.clone();
      viewDate[this.viewToMethod[currentView]](parseInt(e9.target.getAttribute("data-value"), 10));
      if (currentView === "days") {
        viewDate.month(parseInt(e9.target.getAttribute("data-month"), 10));
        viewDate.year(parseInt(e9.target.getAttribute("data-year"), 10));
      }
      let update4 = { viewDate };
      if (currentView === updateOnView) {
        update4.selectedDate = viewDate.clone();
        update4.inputValue = viewDate.format(this.getFormat("datetime"));
        if (this.props.open === void 0 && this.props.input && this.props.closeOnSelect) {
          this._closeCalendar();
        }
        this.props.onChange(viewDate.clone());
      } else {
        this._showView(this.nextView[currentView], viewDate);
      }
      this.setState(update4);
    });
    __publicField(this, "_viewNavigate", (modifier, unit) => {
      let viewDate = this.state.viewDate.clone();
      viewDate.add(modifier, unit);
      if (modifier > 0) {
        this.props.onNavigateForward(modifier, unit);
      } else {
        this.props.onNavigateBack(-modifier, unit);
      }
      this.setState({ viewDate });
    });
    __publicField(this, "_setTime", (type, value) => {
      let date2 = (this.getSelectedDate() || this.state.viewDate).clone();
      date2[type](value);
      if (!this.props.value) {
        this.setState({
          selectedDate: date2,
          viewDate: date2.clone(),
          inputValue: date2.format(this.getFormat("datetime"))
        });
      }
      this.props.onChange(date2);
    });
    __publicField(this, "_openCalendar", () => {
      if (this.isOpen())
        return;
      this.setState({ open: true }, this.props.onOpen);
    });
    __publicField(this, "_closeCalendar", () => {
      if (!this.isOpen())
        return;
      this.setState({ open: false }, () => {
        this.props.onClose(this.state.selectedDate || this.state.inputValue);
      });
    });
    __publicField(this, "_handleClickOutside", () => {
      let props2 = this.props;
      if (props2.input && this.state.open && props2.open === void 0 && props2.closeOnClickOutside) {
        this._closeCalendar();
      }
    });
    __publicField(this, "_onInputFocus", (e9) => {
      if (!this.callHandler(this.props.inputProps.onFocus, e9))
        return;
      this._openCalendar();
    });
    __publicField(this, "_onInputChange", (e9) => {
      if (!this.callHandler(this.props.inputProps.onChange, e9))
        return;
      const value = e9.target ? e9.target.value : e9;
      const localMoment = this.localMoment(value, this.getFormat("datetime"));
      let update4 = { inputValue: value };
      if (localMoment.isValid()) {
        update4.selectedDate = localMoment;
        update4.viewDate = localMoment.clone().startOf("month");
      } else {
        update4.selectedDate = null;
      }
      this.setState(update4, () => {
        this.props.onChange(localMoment.isValid() ? localMoment : this.state.inputValue);
      });
    });
    __publicField(this, "_onInputKeyDown", (e9) => {
      if (!this.callHandler(this.props.inputProps.onKeyDown, e9))
        return;
      if (e9.which === 9 && this.props.closeOnTab) {
        this._closeCalendar();
      }
    });
    __publicField(this, "_onInputClick", (e9) => {
      if (!this.callHandler(this.props.inputProps.onClick, e9))
        return;
      this._openCalendar();
    });
    this.state = this.getInitialState();
  }
  render() {
    return import_react117.default.createElement(ClickableWrapper, {
      className: this.getClassName(),
      onClickOut: this._handleClickOutside
    }, this.renderInput(), import_react117.default.createElement("div", {
      className: "rdtPicker"
    }, this.renderView()));
  }
  renderInput() {
    if (!this.props.input)
      return;
    const finalInputProps = {
      type: "text",
      className: "form-control",
      value: this.getInputValue(),
      ...this.props.inputProps,
      onFocus: this._onInputFocus,
      onChange: this._onInputChange,
      onKeyDown: this._onInputKeyDown,
      onClick: this._onInputClick
    };
    if (this.props.renderInput) {
      return import_react117.default.createElement("div", null, this.props.renderInput(finalInputProps, this._openCalendar, this._closeCalendar));
    }
    return import_react117.default.createElement("input", {
      ...finalInputProps
    });
  }
  renderView() {
    return this.props.renderView(this.state.currentView, this._renderCalendar);
  }
  getInitialState() {
    let props = this.props;
    let inputFormat = this.getFormat("datetime");
    let selectedDate = this.parseDate(props.value || props.initialValue, inputFormat);
    this.checkTZ();
    return {
      open: !props.input,
      currentView: props.initialViewMode || this.getInitialView(),
      viewDate: this.getInitialViewDate(selectedDate),
      selectedDate: selectedDate && selectedDate.isValid() ? selectedDate : void 0,
      inputValue: this.getInitialInputValue(selectedDate)
    };
  }
  getInitialViewDate(selectedDate) {
    const propDate = this.props.initialViewDate;
    let viewDate;
    if (propDate) {
      viewDate = this.parseDate(propDate, this.getFormat("datetime"));
      if (viewDate && viewDate.isValid()) {
        return viewDate;
      } else {
        log2('The initialViewDated given "' + propDate + '" is not valid. Using current date instead.');
      }
    } else if (selectedDate && selectedDate.isValid()) {
      return selectedDate.clone();
    }
    return this.getInitialDate();
  }
  getInitialDate() {
    let m10 = this.localMoment();
    m10.hour(0).minute(0).second(0).millisecond(0);
    return m10;
  }
  getInitialView() {
    const dateFormat = this.getFormat("date");
    return dateFormat ? this.getUpdateOn(dateFormat) : viewModes.TIME;
  }
  parseDate(date2, dateFormat) {
    let parsedDate;
    if (date2 && typeof date2 === "string")
      parsedDate = this.localMoment(date2, dateFormat);
    else if (date2)
      parsedDate = this.localMoment(date2);
    if (parsedDate && !parsedDate.isValid())
      parsedDate = null;
    return parsedDate;
  }
  getClassName() {
    let cn2 = "rdt";
    let props = this.props;
    let propCn = props.className;
    if (Array.isArray(propCn)) {
      cn2 += " " + propCn.join(" ");
    } else if (propCn) {
      cn2 += " " + propCn;
    }
    if (!props.input) {
      cn2 += " rdtStatic";
    }
    if (this.isOpen()) {
      cn2 += " rdtOpen";
    }
    return cn2;
  }
  isOpen() {
    return !this.props.input || (this.props.open === void 0 ? this.state.open : this.props.open);
  }
  getUpdateOn(dateFormat) {
    if (this.props.updateOnView) {
      return this.props.updateOnView;
    }
    if (dateFormat.match(/[lLD]/)) {
      return viewModes.DAYS;
    }
    if (dateFormat.indexOf("M") !== -1) {
      return viewModes.MONTHS;
    }
    if (dateFormat.indexOf("Y") !== -1) {
      return viewModes.YEARS;
    }
    return viewModes.DAYS;
  }
  getLocaleData() {
    let p12 = this.props;
    return this.localMoment(p12.value || p12.defaultValue || new Date()).localeData();
  }
  getDateFormat() {
    const locale2 = this.getLocaleData();
    let format22 = this.props.dateFormat;
    if (format22 === true)
      return locale2.longDateFormat("L");
    if (format22)
      return format22;
    return "";
  }
  getTimeFormat() {
    const locale2 = this.getLocaleData();
    let format22 = this.props.timeFormat;
    if (format22 === true) {
      return locale2.longDateFormat("LT");
    }
    return format22 || "";
  }
  getFormat(type) {
    if (type === "date") {
      return this.getDateFormat();
    } else if (type === "time") {
      return this.getTimeFormat();
    }
    let dateFormat = this.getDateFormat();
    let timeFormat = this.getTimeFormat();
    return dateFormat && timeFormat ? dateFormat + " " + timeFormat : dateFormat || timeFormat;
  }
  updateTime(op, amount, type, toSelected) {
    let update4 = {};
    const date2 = toSelected ? "selectedDate" : "viewDate";
    update4[date2] = this.state[date2].clone()[op](amount, type);
    this.setState(update4);
  }
  localMoment(date2, format22, props) {
    props = props || this.props;
    let m10 = null;
    if (props.utc) {
      m10 = moment_default.utc(date2, format22, props.strictParsing);
    } else if (props.displayTimeZone) {
      m10 = moment_default.tz(date2, format22, props.displayTimeZone);
    } else {
      m10 = moment_default(date2, format22, props.strictParsing);
    }
    if (props.locale)
      m10.locale(props.locale);
    return m10;
  }
  checkTZ() {
    const { displayTimeZone } = this.props;
    if (displayTimeZone && !this.tzWarning && !moment_default.tz) {
      this.tzWarning = true;
      log2('displayTimeZone prop with value "' + displayTimeZone + '" is used but moment.js timezone is not loaded.', "error");
    }
  }
  componentDidUpdate(prevProps) {
    if (prevProps === this.props)
      return;
    let needsUpdate = false;
    let thisProps = this.props;
    ["locale", "utc", "displayZone", "dateFormat", "timeFormat"].forEach(function(p12) {
      prevProps[p12] !== thisProps[p12] && (needsUpdate = true);
    });
    if (needsUpdate) {
      this.regenerateDates();
    }
    if (thisProps.value && thisProps.value !== prevProps.value) {
      this.setViewDate(thisProps.value);
    }
    this.checkTZ();
  }
  regenerateDates() {
    const props = this.props;
    let viewDate = this.state.viewDate.clone();
    let selectedDate = this.state.selectedDate && this.state.selectedDate.clone();
    if (props.locale) {
      viewDate.locale(props.locale);
      selectedDate && selectedDate.locale(props.locale);
    }
    if (props.utc) {
      viewDate.utc();
      selectedDate && selectedDate.utc();
    } else if (props.displayTimeZone) {
      viewDate.tz(props.displayTimeZone);
      selectedDate && selectedDate.tz(props.displayTimeZone);
    } else {
      viewDate.locale();
      selectedDate && selectedDate.locale();
    }
    let update4 = { viewDate, selectedDate };
    if (selectedDate && selectedDate.isValid()) {
      update4.inputValue = selectedDate.format(this.getFormat("datetime"));
    }
    this.setState(update4);
  }
  getSelectedDate() {
    if (this.props.value === void 0)
      return this.state.selectedDate;
    let selectedDate = this.parseDate(this.props.value, this.getFormat("datetime"));
    return selectedDate && selectedDate.isValid() ? selectedDate : false;
  }
  getInitialInputValue(selectedDate) {
    const props = this.props;
    if (props.inputProps.value)
      return props.inputProps.value;
    if (selectedDate && selectedDate.isValid())
      return selectedDate.format(this.getFormat("datetime"));
    if (props.value && typeof props.value === "string")
      return props.value;
    if (props.initialValue && typeof props.initialValue === "string")
      return props.initialValue;
    return "";
  }
  getInputValue() {
    let selectedDate = this.getSelectedDate();
    return selectedDate ? selectedDate.format(this.getFormat("datetime")) : this.state.inputValue;
  }
  setViewDate(date2) {
    let logError = function() {
      return log2("Invalid date passed to the `setViewDate` method: " + date2);
    };
    if (!date2)
      return logError();
    let viewDate;
    if (typeof date2 === "string") {
      viewDate = this.localMoment(date2, this.getFormat("datetime"));
    } else {
      viewDate = this.localMoment(date2);
    }
    if (!viewDate || !viewDate.isValid())
      return logError();
    this.setState({ viewDate });
  }
  navigate(mode) {
    this._showView(mode);
  }
  callHandler(method, e9) {
    if (!method)
      return true;
    return method(e9) !== false;
  }
};
__publicField(Datetime, "propTypes", {
  value: datetype,
  initialValue: datetype,
  initialViewDate: datetype,
  initialViewMode: TYPES.oneOf([
    viewModes.YEARS,
    viewModes.MONTHS,
    viewModes.DAYS,
    viewModes.TIME
  ]),
  onOpen: TYPES.func,
  onClose: TYPES.func,
  onChange: TYPES.func,
  onNavigate: TYPES.func,
  onBeforeNavigate: TYPES.func,
  onNavigateBack: TYPES.func,
  onNavigateForward: TYPES.func,
  updateOnView: TYPES.string,
  locale: TYPES.string,
  utc: TYPES.bool,
  displayTimeZone: TYPES.string,
  input: TYPES.bool,
  dateFormat: TYPES.oneOfType([TYPES.string, TYPES.bool]),
  timeFormat: TYPES.oneOfType([TYPES.string, TYPES.bool]),
  inputProps: TYPES.object,
  timeConstraints: TYPES.object,
  isValidDate: TYPES.func,
  open: TYPES.bool,
  strictParsing: TYPES.bool,
  closeOnSelect: TYPES.bool,
  closeOnTab: TYPES.bool,
  renderView: TYPES.func,
  renderInput: TYPES.func,
  renderDay: TYPES.func,
  renderMonth: TYPES.func,
  renderYear: TYPES.func
});
__publicField(Datetime, "defaultProps", {
  onOpen: nofn,
  onClose: nofn,
  onCalendarOpen: nofn,
  onCalendarClose: nofn,
  onChange: nofn,
  onNavigate: nofn,
  onBeforeNavigate: function(next) {
    return next;
  },
  onNavigateBack: nofn,
  onNavigateForward: nofn,
  dateFormat: true,
  timeFormat: true,
  utc: false,
  className: "",
  input: true,
  inputProps: {},
  timeConstraints: {},
  isValidDate: function() {
    return true;
  },
  strictParsing: true,
  closeOnSelect: false,
  closeOnTab: true,
  closeOnClickOutside: true,
  renderView: (_7, renderFunc) => renderFunc()
});
__publicField(Datetime, "moment", moment_default);
function log2(message, method) {
  let con = typeof window !== "undefined" && window.console;
  if (!con)
    return;
  if (!method) {
    method = "warn";
  }
  con[method]("***react-datetime:" + message);
}
var ClickOutBase = class extends import_react117.default.Component {
  constructor() {
    super(...arguments);
    __publicField(this, "container", import_react117.default.createRef());
  }
  render() {
    return import_react117.default.createElement("div", {
      className: this.props.className,
      ref: this.container
    }, this.props.children);
  }
  handleClickOutside(e9) {
    this.props.onClickOut(e9);
  }
  setClickOutsideRef() {
    return this.container.current;
  }
};
var ClickableWrapper = react_onclickoutside_es_default(ClickOutBase);
var DEFAULT_DATE_DISPLAY_FORMAT = "MMM DD, YYYY";
var DEFAULT_TIME_DISPLAY_FORMAT = "h:mm A";
var format2 = (val, _name, field) => {
  if (!val)
    return val;
  const dateFormat = parseDateFormat(field.dateFormat);
  const timeFormat = parseTimeFormat(field.timeFormat);
  const combinedFormat = typeof timeFormat === "string" ? `${dateFormat} ${timeFormat}` : dateFormat;
  if (typeof val === "string") {
    const date2 = moment_default(val);
    return date2.isValid() ? date2.format(combinedFormat) : val;
  }
  return moment_default(val).format(combinedFormat);
};
var parse5 = (val) => {
  if (!val)
    return val;
  const date2 = new Date(val);
  if (!isNaN(date2.getTime())) {
    return new Date(val).toISOString();
  }
  return val;
};
function parseDateFormat(format22) {
  if (typeof format22 === "string") {
    return format22;
  }
  return DEFAULT_DATE_DISPLAY_FORMAT;
}
function parseTimeFormat(format22) {
  if (typeof format22 === "string") {
    return format22;
  } else if (format22) {
    return DEFAULT_TIME_DISPLAY_FORMAT;
  }
}
var DateFieldPluginCSS = ".tina-date-field .rdt {\n  position: relative;\n}\n\n.tina-date-field .rdtPicker {\n  display: none;\n  position: absolute;\n  width: 100%;\n  max-width: 350px;\n  padding: 4px;\n  margin-top: 4px;\n  z-index: 99999 !important;\n  background: var(--tina-color-grey-0);\n  border-radius: var(--tina-radius-small);\n  box-shadow: var(--tina-shadow-big);\n  border: 1px solid var(--tina-color-grey-2);\n}\n\n.tina-date-field .rdtOpen .rdtPicker {\n  display: block;\n}\n\n.tina-date-field .rdtStatic .rdtPicker {\n  box-shadow: none;\n  position: static;\n}\n\n.tina-date-field .rdtPicker .rdtTimeToggle {\n  text-align: center;\n}\n\n.tina-date-field .rdtPicker table {\n  width: 100%;\n  margin: 0;\n}\n\n.tina-date-field .rdtPicker td,\n.rdtPicker th {\n  text-align: center;\n  height: 28px;\n}\n\n.tina-date-field .rdtPicker td {\n  cursor: pointer;\n}\n\n.tina-date-field .rdtPicker td.rdtDay:hover,\n.tina-date-field .rdtPicker td.rdtHour:hover,\n.tina-date-field .rdtPicker td.rdtMinute:hover,\n.tina-date-field .rdtPicker td.rdtSecond:hover,\n.tina-date-field .rdtPicker .rdtTimeToggle:hover {\n  background: var(--tina-color-grey-2);\n  color: var(--tina-color-primary);\n  border-radius: var(--tina-radius-small);\n  cursor: pointer;\n}\n\n.tina-date-field .rdtPicker td.rdtDay:hover:active,\n.tina-date-field .rdtPicker td.rdtHour:hover:active,\n.tina-date-field .rdtPicker td.rdtMinute:hover:active,\n.tina-date-field .rdtPicker td.rdtSecond:hover:active,\n.tina-date-field .rdtPicker .rdtTimeToggle:hover:active {\n  background: var(--tina-color-primary);\n  color: var(--tina-color-grey-0);\n  border-radius: var(--tina-radius-small);\n}\n\n.tina-date-field .rdtPicker td.rdtOld,\n.rdtPicker td.rdtNew {\n  color: var(--tina-color-grey-6);\n}\n\n.tina-date-field .rdtPicker td.rdtToday {\n  position: relative;\n}\n\n.tina-date-field .rdtPicker td.rdtToday:before {\n  content: '';\n  display: inline-block;\n  border-left: 7px solid transparent;\n  border-bottom: 7px solid var(--tina-color-primary);\n  border-radius: 20px;\n  border-top-color: rgba(0, 0, 0, 0.2);\n  position: absolute;\n  bottom: 4px;\n  right: 4px;\n}\n\n.tina-date-field .rdtPicker td.rdtActive,\n.rdtPicker td.rdtActive:hover {\n  background-color: var(--tina-color-primary);\n  color: var(--tina-color-grey-0);\n  text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);\n}\n\n.tina-date-field .rdtPicker td.rdtActive.rdtToday:before {\n  border-bottom-color: var(--tina-color-grey-0);\n}\n\n.tina-date-field .rdtPicker td.rdtDisabled,\n.rdtPicker td.rdtDisabled:hover {\n  background: none;\n  color: var(--tina-color-grey-6);\n  cursor: not-allowed;\n}\n\n.tina-date-field .rdtPicker td span.rdtOld {\n  color: var(--tina-color-grey-6);\n}\n\n.tina-date-field .rdtPicker td span.rdtDisabled,\n.rdtPicker td span.rdtDisabled:hover {\n  background: none;\n  color: var(--tina-color-grey-6);\n  cursor: not-allowed;\n}\n\n.tina-date-field .rdtPicker th {\n  border-bottom: 1px solid var(--tina-color-grey-1);\n}\n\n.tina-date-field .rdtPicker .dow {\n  width: 14.2857%;\n  border-bottom: none;\n  cursor: default;\n}\n\n.tina-date-field .rdtPicker th.rdtSwitch {\n  width: 100px;\n}\n\n.tina-date-field .rdtPicker th.rdtNext,\n.rdtPicker th.rdtPrev {\n  font-size: 21px;\n  vertical-align: top;\n}\n\n.tina-date-field .rdtPrev span,\n.rdtNext span {\n  display: block;\n  -webkit-touch-callout: none;\n  /* iOS Safari */\n  -webkit-user-select: none;\n  /* Chrome/Safari/Opera */\n  -khtml-user-select: none;\n  /* Konqueror */\n  -moz-user-select: none;\n  /* Firefox */\n  -ms-user-select: none;\n  /* Internet Explorer/Edge */\n  user-select: none;\n}\n\n.tina-date-field .rdtPicker th.rdtDisabled,\n.rdtPicker th.rdtDisabled:hover {\n  background: none;\n  color: var(--tina-color-grey-6);\n  cursor: not-allowed;\n}\n\n.tina-date-field .rdtPicker thead tr:first-child th {\n  cursor: pointer;\n}\n\n.tina-date-field .rdtPicker thead tr:first-child th:hover {\n  background: var(--tina-color-grey-2);\n  color: var(--tina-color-primary);\n  border-radius: var(--tina-radius-small);\n}\n\n.tina-date-field .rdtPicker tfoot {\n  border-top: 1px solid var(--tina-color-grey-1);\n}\n\n.tina-date-field .rdtPicker button {\n  border: none;\n  background: none;\n  cursor: pointer;\n}\n\n.tina-date-field .rdtPicker button:hover {\n  background: var(--tina-color-grey-2);\n  color: var(--tina-color-primary);\n  border-radius: var(--tina-radius-small);\n}\n\n.tina-date-field .rdtPicker thead button {\n  width: 100%;\n  height: 100%;\n}\n\n.tina-date-field td.rdtMonth,\ntd.rdtYear {\n  height: 50px;\n  width: 25%;\n  cursor: pointer;\n}\n\n.tina-date-field td.rdtMonth:hover,\ntd.rdtYear:hover {\n  background: var(--tina-color-grey-2);\n  color: var(--tina-color-primary);\n  border-radius: var(--tina-radius-small);\n}\n\n.tina-date-field .rdtCounters {\n  display: inline-block;\n}\n\n.tina-date-field .rdtCounters > div {\n  float: left;\n}\n\n.tina-date-field .rdtCounter {\n  height: 100px;\n  width: 40px;\n}\n\n.tina-date-field .rdtCounterSeparator {\n  line-height: 100px;\n}\n\n.tina-date-field .rdtCounter .rdtBtn {\n  height: 40%;\n  line-height: 40px;\n  cursor: pointer;\n  display: block;\n  -webkit-touch-callout: none;\n  /* iOS Safari */\n  -webkit-user-select: none;\n  /* Chrome/Safari/Opera */\n  -khtml-user-select: none;\n  /* Konqueror */\n  -moz-user-select: none;\n  /* Firefox */\n  -ms-user-select: none;\n  /* Internet Explorer/Edge */\n  user-select: none;\n}\n\n.tina-date-field .rdtCounter .rdtBtn:hover {\n  background: var(--tina-color-grey-2);\n  color: var(--tina-color-primary);\n  border-radius: var(--tina-radius-small);\n}\n\n.tina-date-field .rdtCounter .rdtCount {\n  height: 20%;\n  font-size: 1.2em;\n}\n\n.tina-date-field .rdtMilli {\n  vertical-align: middle;\n  padding-left: 8px;\n  width: 48px;\n}\n\n.tina-date-field .rdtMilli input {\n  width: 100%;\n  font-size: 1.2em;\n  margin-top: 37px;\n}\n\n.tina-date-field .rdtTime td {\n  cursor: default;\n}\n";
var DateField = wrapFieldsWithMeta(({ input, field: { dateFormat, timeFormat, ...rest } }) => {
  return React68.createElement(React68.Fragment, null, React68.createElement(ReactDateTimeWithStyles, {
    value: input.value,
    onFocus: input.onFocus,
    onChange: input.onChange,
    dateFormat: dateFormat || DEFAULT_DATE_DISPLAY_FORMAT,
    timeFormat: timeFormat || false,
    inputProps: { className: textFieldClasses },
    ...rest
  }));
});
var ReactDateTimeWithStyles = (props) => {
  const [isOpen, setIsOpen] = (0, import_react117.useState)(false);
  const area = (0, import_react117.useRef)(null);
  (0, import_react117.useEffect)(() => {
    const handleClick = (event) => {
      if (!area.current)
        return;
      if (!event.target)
        return;
      if (!area.current.contains(event.target)) {
        setIsOpen(false);
      } else {
        setIsOpen(true);
      }
    };
    document.addEventListener("mouseup", handleClick, false);
    return () => {
      document.removeEventListener("mouseup", handleClick, false);
    };
  }, [document]);
  return React68.createElement(React68.Fragment, null, React68.createElement("style", null, DateFieldPluginCSS), React68.createElement("div", {
    className: "tina-date-field",
    ref: area
  }, React68.createElement(Datetime, {
    ...props,
    isOpen
  })));
};
var DateFieldPlugin = {
  __type: "field",
  name: "date",
  Component: DateField,
  format: format2,
  parse: parse5,
  validate(value, values3, meta, field) {
    if (field.required && !value)
      return "Required";
  }
};
var CheckboxGroupField = wrapFieldsWithMeta(CheckboxGroup);
var CheckboxGroupFieldPlugin = {
  name: "checkbox-group",
  Component: CheckboxGroupField,
  validate(value, values3, meta, field) {
    if (field.required && (typeof value === "undefined" || value === null))
      return "Required";
  }
};
var ReferenceField = wrapFieldsWithMeta(Reference);
var ReferenceFieldPlugin = {
  name: "reference",
  type: "reference",
  Component: ReferenceField,
  parse: parse$2,
  validate(value, values3, meta, field) {
    if (field.required && !value)
      return "Required";
  }
};
var ButtonToggleField = wrapFieldsWithMeta(ButtonToggle);
var ButtonToggleFieldPlugin = {
  name: "button-toggle",
  Component: ButtonToggleField
};
var HiddenField = () => {
  return React68.createElement(React68.Fragment, null);
};
var HiddenFieldPlugin = {
  name: "hidden",
  Component: HiddenField,
  parse: parse$2
};
var PendingFormsPlaceholder = () => React68.createElement("div", {
  className: "relative flex flex-col items-center justify-center text-center p-5 pb-16 w-full h-full overflow-y-auto",
  style: {
    animationName: "fade-in",
    animationDelay: "300ms",
    animationTimingFunction: "ease-out",
    animationIterationCount: 1,
    animationFillMode: "both",
    animationDuration: "150ms"
  }
}, React68.createElement("p", {
  className: "block pb-5"
}, "Please wait while Tina", React68.createElement("br", null), "loads your forms"), React68.createElement(LoadingDots, {
  color: "var(--tina-color-primary)"
}));
var NoFormsPlaceholder = () => React68.createElement("div", {
  className: "relative flex flex-col items-center justify-center text-center p-5 pb-16 w-full h-full overflow-y-auto",
  style: {
    animationName: "fade-in",
    animationDelay: "300ms",
    animationTimingFunction: "ease-out",
    animationIterationCount: 1,
    animationFillMode: "both",
    animationDuration: "150ms"
  }
}, React68.createElement(Emoji, {
  className: "pb-5"
}, "🔎"), React68.createElement("p", {
  className: "block pb-5"
}, "Looks like there's ", React68.createElement("br", null), "nothing to edit on ", React68.createElement("br", null), "this page."), React68.createElement("p", {
  className: "block"
}, React68.createElement(Button, {
  href: "https://tina.io/docs/tinacms-context/",
  target: "_blank",
  as: "a"
}, React68.createElement(Emoji, {
  className: "mr-1.5"
}, "📖"), " Contextual Editing")));
var Emoji = ({ className = "", ...props }) => React68.createElement("span", {
  className: `text-[24px] leading-none inline-block ${className}`,
  ...props
});
var SidebarState = class {
  constructor(events, options = {}) {
    var _a, _b;
    this.events = events;
    this._isOpen = false;
    this.position = "displace";
    this.renderNav = true;
    this.buttons = {
      save: "Save",
      reset: "Reset"
    };
    this.position = options.position || "displace";
    this.renderNav = options.renderNav || true;
    this.placeholder = options.placeholder || NoFormsPlaceholder;
    if ((_a = options.buttons) == null ? void 0 : _a.save) {
      this.buttons.save = options.buttons.save;
    }
    if ((_b = options.buttons) == null ? void 0 : _b.reset) {
      this.buttons.reset = options.buttons.reset;
    }
  }
  get isOpen() {
    return this._isOpen;
  }
  set isOpen(nextValue) {
    if (this._isOpen === nextValue) {
      return;
    }
    this._isOpen = nextValue;
    if (nextValue) {
      this.events.dispatch({ type: "sidebar:opened" });
    } else {
      this.events.dispatch({ type: "sidebar:closed" });
    }
  }
  subscribe(callback) {
    const unsub = this.events.subscribe("sidebar", callback);
    return () => unsub();
  }
};
function BsArrowsAngleContract(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "currentColor", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "fillRule": "evenodd", "d": "M.172 15.828a.5.5 0 0 0 .707 0l4.096-4.096V14.5a.5.5 0 1 0 1 0v-3.975a.5.5 0 0 0-.5-.5H1.5a.5.5 0 0 0 0 1h2.768L.172 15.121a.5.5 0 0 0 0 .707zM15.828.172a.5.5 0 0 0-.707 0l-4.096 4.096V1.5a.5.5 0 1 0-1 0v3.975a.5.5 0 0 0 .5.5H14.5a.5.5 0 0 0 0-1h-2.768L15.828.879a.5.5 0 0 0 0-.707z" } }] })(props);
}
function BsArrowsAngleExpand(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "currentColor", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "fillRule": "evenodd", "d": "M5.828 10.172a.5.5 0 0 0-.707 0l-4.096 4.096V11.5a.5.5 0 0 0-1 0v3.975a.5.5 0 0 0 .5.5H4.5a.5.5 0 0 0 0-1H1.732l4.096-4.096a.5.5 0 0 0 0-.707zm4.344-4.344a.5.5 0 0 0 .707 0l4.096-4.096V4.5a.5.5 0 1 0 1 0V.525a.5.5 0 0 0-.5-.5H11.5a.5.5 0 0 0 0 1h2.768l-4.096 4.096a.5.5 0 0 0 0 .707z" } }] })(props);
}
function BsCheckCircleFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "currentColor", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0zm-3.97-3.03a.75.75 0 0 0-1.08.022L7.477 9.417 5.384 7.323a.75.75 0 0 0-1.06 1.06L6.97 11.03a.75.75 0 0 0 1.079-.02l3.992-4.99a.75.75 0 0 0-.01-1.05z" } }] })(props);
}
function BsExclamationOctagonFill(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "currentColor", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M11.46.146A.5.5 0 0 0 11.107 0H4.893a.5.5 0 0 0-.353.146L.146 4.54A.5.5 0 0 0 0 4.893v6.214a.5.5 0 0 0 .146.353l4.394 4.394a.5.5 0 0 0 .353.146h6.214a.5.5 0 0 0 .353-.146l4.394-4.394a.5.5 0 0 0 .146-.353V4.893a.5.5 0 0 0-.146-.353L11.46.146zM8 4c.535 0 .954.462.9.995l-.35 3.507a.552.552 0 0 1-1.1 0L7.1 4.995A.905.905 0 0 1 8 4zm.002 6a1 1 0 1 1 0 2 1 1 0 0 1 0-2z" } }] })(props);
}
var FormList = ({
  hidden = false,
  forms,
  setActiveFormId
}) => {
  return React68.createElement(tt2, {
    appear: true,
    show: !hidden,
    enter: "transition-all ease-out duration-150",
    enterFrom: "opacity-0 -translate-x-1/2",
    enterTo: "opacity-100",
    leave: "transition-all ease-out duration-150",
    leaveFrom: "opacity-100",
    leaveTo: "opacity-0 -translate-x-1/2"
  }, React68.createElement("ul", {
    className: "pt-16"
  }, forms.sort(byId).map((form, index2) => React68.createElement("li", {
    key: form.id,
    className: `relative px-6 py-2`
  }, React68.createElement("button", {
    onClick: () => setActiveFormId(form.id),
    className: "w-full h-full bg-transparent border-none text-lg text-gray-700 hover:text-blue-500 transition-all ease-out duration-150 flex items-center gap-2 p-1 m-0"
  }, React68.createElement(BiPencil, {
    className: "opacity-70 w-5 h-auto fill-current"
  }), form.label), index2 !== forms.length - 1 && React68.createElement("hr", {
    className: "absolute bottom-0 left-0 border-t border-gray-100 w-full"
  })))));
};
var byId = (b6, a13) => {
  if (a13.id < b6.id) {
    return -1;
  }
  if (a13.id > b6.id) {
    return 1;
  }
  return 0;
};
var FormsView = ({
  children
}) => {
  var _a;
  const [activeFormId, setActiveFormId] = (0, import_react117.useState)("");
  const cms = useCMS$1();
  const renderNav = typeof ((_a = cms == null ? void 0 : cms.sidebar) == null ? void 0 : _a.renderNav) !== "undefined" ? cms.sidebar.renderNav : true;
  const formPlugins = cms.plugins.getType("form");
  const { setFormIsPristine } = React68.useContext(SidebarContext);
  const { formsRegistering, setFormsRegistering } = React68.useContext(EditContext);
  React68.useMemo(() => cms.events.subscribe("forms:register", (event) => {
    if (event.value === "start") {
      setFormsRegistering(true);
    } else {
      setFormsRegistering(false);
    }
  }), []);
  function setSingleActiveForm() {
    if (formPlugins.all().length === 1) {
      setActiveFormId(formPlugins.all()[0].id);
    }
  }
  useSubscribable(formPlugins, () => {
    setSingleActiveForm();
  });
  React68.useEffect(() => {
    setSingleActiveForm();
  }, []);
  const forms = formPlugins.all();
  const isMultiform = forms.length > 1;
  const activeForm = formPlugins.find(activeFormId);
  const isEditing = !!activeForm;
  if (!forms.length) {
    if (formsRegistering)
      return React68.createElement(PendingFormsPlaceholder, null);
    return React68.createElement(React68.Fragment, null, " ", children, " ");
  }
  if (isMultiform && !activeForm) {
    return React68.createElement(FormList, {
      isEditing,
      forms,
      setActiveFormId
    });
  }
  const formMetas = cms.plugins.all("form:meta");
  return React68.createElement(React68.Fragment, null, activeForm && React68.createElement(FormWrapper, {
    isEditing,
    isMultiform
  }, isMultiform && React68.createElement(MultiformFormHeader, {
    renderNav,
    activeForm,
    setActiveFormId
  }), !isMultiform && React68.createElement(FormHeader, {
    renderNav,
    activeForm
  }), formMetas && formMetas.map((meta) => React68.createElement(React68.Fragment, {
    key: meta.name
  }, React68.createElement(meta.Component, null))), React68.createElement(FormBuilder, {
    form: activeForm,
    onPristineChange: setFormIsPristine
  })));
};
var FormWrapper = ({ isEditing, children }) => {
  return React68.createElement("div", {
    className: "flex-1 flex flex-col flex-nowrap overflow-hidden h-full w-full relative bg-white",
    style: isEditing ? {
      transform: "none",
      animationName: "fly-in-left",
      animationDuration: "150ms",
      animationDelay: "0",
      animationIterationCount: 1,
      animationTimingFunction: "ease-out"
    } : {
      transform: "translate3d(100%, 0, 0)"
    }
  }, children);
};
var MultiformFormHeader = ({
  activeForm,
  setActiveFormId,
  renderNav
}) => {
  const cms = useCMS$1();
  const { sidebarWidth, formIsPristine } = React68.useContext(SidebarContext);
  return React68.createElement("div", {
    className: `py-4 border-b border-gray-200 bg-white ${sidebarWidth > navBreakpoint && renderNav ? `px-6` : renderNav ? `pl-20 pr-28` : `pl-6 pr-28`}`
  }, React68.createElement("div", {
    className: "max-w-form mx-auto flex flex-col items-start justify-center min-h-[2.5rem]"
  }, React68.createElement("button", {
    className: "pointer-events-auto text-xs mb-1 text-gray-400 hover:text-blue-500 hover:underline transition-all ease-out duration-150 font-medium flex items-center justify-start gap-0.5",
    onClick: () => {
      const state = activeForm.finalForm.getState();
      if (state.invalid === true) {
        cms.alerts.error("Cannot navigate away from an invalid form.");
      } else {
        setActiveFormId("");
      }
    }
  }, React68.createElement(BiChevronLeft, {
    className: "h-auto w-5 inline-block opacity-70 -mt-0.5 -mx-0.5"
  }), "Return to Form List"), React68.createElement("span", {
    className: "block w-full text-xl mb-[6px] text-gray-700 font-medium leading-tight"
  }, activeForm.label || activeForm.name), React68.createElement(FormStatus, {
    pristine: formIsPristine
  })));
};
var FormHeader = ({ renderNav, activeForm }) => {
  const { sidebarWidth, formIsPristine, displayState } = React68.useContext(SidebarContext);
  const headerPadding = {
    navOpen: "px-6",
    navClosed: "pl-20 pr-28",
    noNav: "pl-6 pr-28"
  };
  const windowWidth = useWindowWidth();
  const navState = !renderNav ? "noNav" : sidebarWidth > navBreakpoint && windowWidth > navBreakpoint || displayState === "fullscreen" && windowWidth > navBreakpoint ? "navOpen" : "navClosed";
  const shortFormLabel = activeForm.label ? activeForm.label.replace(/^.*[\\\/]/, "") : false;
  return React68.createElement("div", {
    className: `py-4 border-b border-gray-200 bg-white ${headerPadding[navState]}`
  }, React68.createElement("div", {
    className: "max-w-form mx-auto  flex flex-col items-start justify-center min-h-[2.5rem]"
  }, shortFormLabel && React68.createElement("span", {
    className: "block w-full text-lg mb-[6px] text-gray-700 font-medium leading-tight text-ellipsis overflow-hidden whitespace-nowrap"
  }, shortFormLabel), React68.createElement(FormStatus, {
    pristine: formIsPristine
  })));
};
function ImFilesEmpty(props) {
  return GenIcon({ "tag": "svg", "attr": { "version": "1.1", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M14.341 5.579c-0.347-0.473-0.831-1.027-1.362-1.558s-1.085-1.015-1.558-1.362c-0.806-0.591-1.197-0.659-1.421-0.659h-5.75c-0.689 0-1.25 0.561-1.25 1.25v11.5c0 0.689 0.561 1.25 1.25 1.25h9.5c0.689 0 1.25-0.561 1.25-1.25v-7.75c0-0.224-0.068-0.615-0.659-1.421zM12.271 4.729c0.48 0.48 0.856 0.912 1.134 1.271h-2.406v-2.405c0.359 0.278 0.792 0.654 1.271 1.134v0zM14 14.75c0 0.136-0.114 0.25-0.25 0.25h-9.5c-0.136 0-0.25-0.114-0.25-0.25v-11.5c0-0.135 0.114-0.25 0.25-0.25 0 0 5.749-0 5.75 0v3.5c0 0.276 0.224 0.5 0.5 0.5h3.5v7.75z" } }, { "tag": "path", "attr": { "d": "M9.421 0.659c-0.806-0.591-1.197-0.659-1.421-0.659h-5.75c-0.689 0-1.25 0.561-1.25 1.25v11.5c0 0.604 0.43 1.109 1 1.225v-12.725c0-0.135 0.115-0.25 0.25-0.25h7.607c-0.151-0.124-0.297-0.238-0.437-0.341z" } }] })(props);
}
function AiFillWarning(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 1024 1024" }, "child": [{ "tag": "path", "attr": { "d": "M955.7 856l-416-720c-6.2-10.7-16.9-16-27.7-16s-21.6 5.3-27.7 16l-416 720C56 877.4 71.4 904 96 904h832c24.6 0 40-26.6 27.7-48zM480 416c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v184c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V416zm32 352a48.01 48.01 0 0 1 0-96 48.01 48.01 0 0 1 0 96z" } }] })(props);
}
var LocalWarning = () => {
  return React68.createElement("a", {
    className: "flex-grow-0 flex w-full text-xs items-center py-1 px-4 text-yellow-600 bg-gradient-to-r from-yellow-50 to-yellow-100 border-b border-gray-150 shadow-sm",
    href: "https://tina.io/docs/tina-cloud/",
    target: "_blank"
  }, React68.createElement(AiFillWarning, {
    className: "w-5 h-auto inline-block mr-1 opacity-70 text-yellow-600"
  }), " ", "You are currently in", React68.createElement("strong", {
    className: "ml-1 font-bold text-yellow-700"
  }, "Local Mode"));
};
var BillingWarning = () => {
  var _a;
  const cms = useCMS$1();
  const api = (_a = cms == null ? void 0 : cms.api) == null ? void 0 : _a.tina;
  const isLocalMode = (api == null ? void 0 : api.isLocalMode) || false;
  const [billingState, setBillingState] = React68.useState(null);
  React68.useEffect(() => {
    const fetchBillingState = async () => {
      if (typeof (api == null ? void 0 : api.getBillingState) !== "function")
        return;
      const billingRes = await (api == null ? void 0 : api.getBillingState());
      setBillingState(billingRes);
    };
    if (!isLocalMode)
      fetchBillingState();
  }, []);
  if (isLocalMode || !billingState || billingState.billingState === "current") {
    return React68.createElement(React68.Fragment, null);
  }
  return React68.createElement("div", {
    className: "flex-grow-0 flex flex-wrap w-full text-xs items-center justify-between gap-1.5 py-1.5 px-3 text-red-700 bg-gradient-to-br from-white via-red-50 to-red-100 border-b border-red-200"
  }, React68.createElement("span", {
    className: "flex items-center gap-1 font-bold"
  }, React68.createElement(BiError, {
    className: "w-5 h-auto flex-shrink-0 flex-grow-0 inline-block opacity-70 text-red-600"
  }), React68.createElement("span", {
    className: "flex whitespace-nowrap"
  }, "There is an issue with your billing.")), React68.createElement("a", {
    className: "text-xs text-blue-600 underline decoration-blue-200 hover:text-blue-500 hover:decoration-blue-500 transition-all ease-out duration-150 flex items-center gap-1 self-end",
    href: `https://app.tina.io/projects/${billingState.clientId}/billing`,
    target: "_blank"
  }, "Visit Billing Page", React68.createElement(BiRightArrowAlt, {
    className: "w-5 h-full opacity-70"
  })));
};
function FiInfo(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "circle", "attr": { "cx": "12", "cy": "12", "r": "10" } }, { "tag": "line", "attr": { "x1": "12", "y1": "16", "x2": "12", "y2": "12" } }, { "tag": "line", "attr": { "x1": "12", "y1": "8", "x2": "12.01", "y2": "8" } }] })(props);
}
function FiMoreVertical(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24", "fill": "none", "stroke": "currentColor", "strokeWidth": "2", "strokeLinecap": "round", "strokeLinejoin": "round" }, "child": [{ "tag": "circle", "attr": { "cx": "12", "cy": "12", "r": "1" } }, { "tag": "circle", "attr": { "cx": "12", "cy": "5", "r": "1" } }, { "tag": "circle", "attr": { "cx": "12", "cy": "19", "r": "1" } }] })(props);
}
function VscNewFile(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 16 16", "fill": "currentColor" }, "child": [{ "tag": "path", "attr": { "fillRule": "evenodd", "clipRule": "evenodd", "d": "M9.5 1.1l3.4 3.5.1.4v2h-1V6H8V2H3v11h4v1H2.5l-.5-.5v-12l.5-.5h6.7l.3.1zM9 2v3h2.9L9 2zm4 14h-1v-3H9v-1h3V9h1v3h3v1h-3v3z" } }] })(props);
}
var FormModal = ({ plugin, close: close2 }) => {
  const cms = useCMS$1();
  const form = (0, import_react117.useMemo)(() => new Form({
    id: "create-form-id",
    label: "create-form",
    fields: plugin.fields,
    actions: plugin.actions,
    buttons: plugin.buttons,
    initialValues: plugin.initialValues || {},
    reset: plugin.reset,
    onChange: plugin.onChange,
    onSubmit: async (values3) => {
      await plugin.onSubmit(values3, cms).then(() => {
        close2();
      });
    }
  }), [close2, cms, plugin]);
  return React68.createElement(Modal, {
    id: "content-creator-modal",
    onClick: (e9) => e9.stopPropagation()
  }, React68.createElement(PopupModal, null, React68.createElement(ModalHeader, {
    close: close2
  }, plugin.name), React68.createElement(ModalBody, null, React68.createElement(FormBuilder, {
    form
  }))));
};
function HiOutlineClipboardList(props) {
  return GenIcon({ "tag": "svg", "attr": { "fill": "none", "viewBox": "0 0 24 24", "stroke": "currentColor" }, "child": [{ "tag": "path", "attr": { "strokeLinecap": "round", "strokeLinejoin": "round", "strokeWidth": "2", "d": "M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" } }] })(props);
}
var useGetEvents = (cms, cursor, existingEvents) => {
  const [events, setEvents] = (0, import_react117.useState)([]);
  const [nextCursor, setNextCursor] = (0, import_react117.useState)(void 0);
  const [loading, setLoading] = (0, import_react117.useState)(true);
  const [error2, setError] = (0, import_react117.useState)(void 0);
  React68.useEffect(() => {
    const fetchEvents = async () => {
      if (cms.api.tina.isAuthorized()) {
        try {
          const { events: nextEvents, cursor: nextCursor2 } = await cms.api.tina.fetchEvents(15, cursor);
          setEvents([...existingEvents, ...nextEvents]);
          setNextCursor(nextCursor2);
        } catch (error22) {
          cms.alerts.error(`[${error22.name}] GetEvents failed: ${error22.message}`, 30 * 1e3);
          console.error(error22);
          setEvents(void 0);
          setError(error22);
        }
        setLoading(false);
      }
    };
    setLoading(true);
    fetchEvents();
  }, [cms, cursor]);
  return { events, cursor: nextCursor, loading, error: error2 };
};
function useSyncStatus(cms) {
  const [syncStatus, setSyncStatus] = (0, import_react117.useState)({ state: "loading", message: "Loading..." });
  React68.useEffect(() => {
    const interval = setInterval(async () => {
      if (cms.api.tina.isAuthorized()) {
        const { events } = await cms.api.tina.fetchEvents();
        if (events.length === 0) {
          setSyncStatus({ state: "success", message: "No Events" });
        } else {
          if (events[0].isError) {
            setSyncStatus({
              state: "error",
              message: `Sync Failure ${events[0].message}`
            });
          } else {
            setSyncStatus({ state: "success", message: "Sync Successful" });
          }
        }
      } else {
        setSyncStatus({ state: "unauthorized", message: "Not Authenticated" });
      }
    }, 5e3);
    return () => clearInterval(interval);
  }, [cms]);
  return syncStatus;
}
var SyncErrorWidget = ({ cms }) => {
  const syncStatus = useSyncStatus(cms);
  if (syncStatus.state !== "error") {
    return null;
  }
  return React68.createElement("div", {
    title: syncStatus.message,
    className: "flex-grow-0 flex text-xs items-center"
  }, React68.createElement(MdSyncProblem, {
    className: "w-6 h-full ml-2 text-red-500 fill-current"
  }));
};
var EventsList = ({ cms }) => {
  const [cursor, setCursor] = React68.useState(void 0);
  const [existingEvents, setExistingEvents] = React68.useState([]);
  const {
    events,
    cursor: nextCursor,
    loading,
    error: error2
  } = useGetEvents(cms, cursor, existingEvents);
  return React68.createElement("div", {
    className: "flex flex-col gap-4 w-full h-full grow-0"
  }, events.length > 0 && React68.createElement("div", {
    className: "shrink grow-0 overflow-scroll w-full rounded-md shadow ring-1 ring-black ring-opacity-5"
  }, React68.createElement("table", {
    className: "w-full divide-y divide-gray-100"
  }, events.map((event, index2) => {
    const date2 = new Date(event.timestamp).toDateString();
    const time = new Date(event.timestamp).toTimeString();
    return React68.createElement("tr", {
      className: index2 % 2 === 0 ? "" : "bg-gray-50"
    }, event.isError ? React68.createElement("td", {
      key: `${event.id}_error_icon`,
      className: "py-3 pl-4 pr-0 w-0"
    }, React68.createElement(BsExclamationOctagonFill, {
      className: "text-red-500 fill-current w-5 h-auto"
    })) : React68.createElement("td", {
      key: `${event.id}_ok_icon`,
      className: "py-3 pl-4 pr-0 w-0"
    }, React68.createElement(BsCheckCircleFill, {
      className: "text-green-500 fill-current w-5 h-auto"
    })), React68.createElement("td", {
      key: `${event.id}_msg`,
      className: "whitespace-nowrap p-3 text-base text-gray-500"
    }, event.message, event.isError && React68.createElement("div", {
      className: "w-full text-gray-300 text-xs mt-0.5"
    }, event.id)), React68.createElement("td", {
      key: `${event.id}_ts`,
      className: "whitespace-nowrap py-3 pl-3 pr-4 text-sm text-gray-500"
    }, date2, React68.createElement("span", {
      className: "w-full block text-gray-300 text-xs mt-0.5"
    }, time)));
  }).flat())), loading && React68.createElement("div", {
    className: "text-sm text-gray-400 text-center"
  }, "Loading..."), error2 && React68.createElement("div", null, "Error: ", error2.message), React68.createElement("div", {
    className: "text-center flex-1"
  }, React68.createElement(Button, {
    onClick: () => {
      setExistingEvents(events);
      setCursor(nextCursor);
    }
  }, "Load More Events")));
};
var SyncStatusModal = ({ closeEventsModal, cms }) => React68.createElement(Modal, null, React68.createElement(FullscreenModal, null, React68.createElement(ModalHeader, {
  close: closeEventsModal
}, "Event Log"), React68.createElement(ModalBody, {
  className: "flex h-full flex-col",
  padded: true
}, React68.createElement(EventsList, {
  cms
}))));
var SyncStatus = ({ cms, setEventsOpen }) => {
  var _a, _b;
  const syncStatus = useSyncStatus(cms);
  function openEventsModal() {
    setEventsOpen(true);
  }
  if ((_b = (_a = cms.api) == null ? void 0 : _a.tina) == null ? void 0 : _b.isLocalMode) {
    return null;
  }
  return React68.createElement(React68.Fragment, null, React68.createElement("button", {
    className: `text-lg px-4 py-2 first:pt-3 last:pb-3 tracking-wide whitespace-nowrap flex items-center opacity-80 text-gray-600 hover:text-blue-400 hover:bg-gray-50 hover:opacity-100`,
    onClick: openEventsModal
  }, syncStatus.state !== "error" ? React68.createElement(HiOutlineClipboardList, {
    className: "w-6 h-auto mr-2 text-blue-400"
  }) : React68.createElement(MdSyncProblem, {
    className: "w-6 h-auto mr-2 text-red-400"
  }), " ", "Event Log"));
};
var Nav = ({
  isLocalMode,
  className = "",
  children,
  showCollections,
  collectionsInfo,
  screens,
  cloudConfigs,
  contentCreators,
  sidebarWidth,
  RenderNavSite,
  RenderNavCloud,
  RenderNavCollection,
  ...props
}) => {
  const cms = useCMS$1();
  const { setEdit } = useEditState();
  const [eventsOpen, setEventsOpen] = React68.useState(false);
  function closeEventsModal() {
    setEventsOpen(false);
  }
  return React68.createElement("div", {
    className: `relative z-30 flex flex-col bg-white border-r border-gray-200 w-96 h-full ${className}`,
    style: { maxWidth: sidebarWidth + "px" },
    ...props
  }, React68.createElement("div", {
    className: "border-b border-gray-200"
  }, React68.createElement(ot2, {
    as: "div",
    className: "relative block"
  }, ({ open }) => React68.createElement("div", null, React68.createElement(ot2.Button, {
    className: `group w-full px-6 py-3 gap-2 flex justify-between items-center transition-colors duration-150 ease-out ${open ? `bg-gray-50` : `bg-transparent`}`
  }, React68.createElement("span", {
    className: "text-left inline-flex items-center text-xl tracking-wide text-gray-800 flex-1 gap-1 opacity-80 group-hover:opacity-100 transition-opacity duration-150 ease-out"
  }, React68.createElement("svg", {
    viewBox: "0 0 32 32",
    fill: "#EC4815",
    xmlns: "http://www.w3.org/2000/svg",
    className: "w-10 h-auto -ml-1"
  }, React68.createElement("path", {
    d: "M18.6466 14.5553C19.9018 13.5141 20.458 7.36086 21.0014 5.14903C21.5447 2.9372 23.7919 3.04938 23.7919 3.04938C23.7919 3.04938 23.2085 4.06764 23.4464 4.82751C23.6844 5.58738 25.3145 6.26662 25.3145 6.26662L24.9629 7.19622C24.9629 7.19622 24.2288 7.10204 23.7919 7.9785C23.355 8.85496 24.3392 17.4442 24.3392 17.4442C24.3392 17.4442 21.4469 22.7275 21.4469 24.9206C21.4469 27.1136 22.4819 28.9515 22.4819 28.9515H21.0296C21.0296 28.9515 18.899 26.4086 18.462 25.1378C18.0251 23.8669 18.1998 22.596 18.1998 22.596C18.1998 22.596 15.8839 22.4646 13.8303 22.596C11.7767 22.7275 10.4072 24.498 10.16 25.4884C9.91287 26.4787 9.81048 28.9515 9.81048 28.9515H8.66211C7.96315 26.7882 7.40803 26.0129 7.70918 24.9206C8.54334 21.8949 8.37949 20.1788 8.18635 19.4145C7.99321 18.6501 6.68552 17.983 6.68552 17.983C7.32609 16.6741 7.97996 16.0452 10.7926 15.9796C13.6052 15.914 17.3915 15.5965 18.6466 14.5553Z"
  }), React68.createElement("path", {
    d: "M11.1268 24.7939C11.1268 24.7939 11.4236 27.5481 13.0001 28.9516H14.3511C13.0001 27.4166 12.8527 23.4155 12.8527 23.4155C12.1656 23.6399 11.3045 24.3846 11.1268 24.7939Z"
  })), React68.createElement("span", null, "Tina")), React68.createElement(SyncErrorWidget, {
    cms
  }), React68.createElement(FiMoreVertical, {
    className: `flex-0 w-6 h-full inline-block group-hover:opacity-80 transition-all duration-300 ease-in-out transform ${open ? `opacity-100 text-blue-400` : `text-gray-400 opacity-50 hover:opacity-70`}`
  })), React68.createElement("div", {
    className: "transform translate-y-full absolute bottom-3 right-5 z-50"
  }, React68.createElement(tt2, {
    enter: "transition duration-150 ease-out",
    enterFrom: "transform opacity-0 -translate-y-2",
    enterTo: "transform opacity-100 translate-y-0",
    leave: "transition duration-75 ease-in",
    leaveFrom: "transform opacity-100 translate-y-0",
    leaveTo: "transform opacity-0 -translate-y-2"
  }, React68.createElement(ot2.Items, {
    className: "bg-white border border-gray-150 rounded-lg shadow-lg flex flex-col items-stretch overflow-hidden"
  }, React68.createElement(ot2.Item, null, React68.createElement("button", {
    className: `text-lg px-4 py-2 first:pt-3 last:pb-3 tracking-wide whitespace-nowrap flex items-center opacity-80 text-gray-600 hover:text-blue-400 hover:bg-gray-50 hover:opacity-100`,
    onClick: async () => {
      var _a, _b, _c, _d, _e4, _f;
      updateBodyDisplacement({
        displayState: "closed",
        sidebarWidth: null,
        resizingSidebar: false
      });
      if ((_b = (_a = cms == null ? void 0 : cms.api) == null ? void 0 : _a.tina) == null ? void 0 : _b.logout) {
        await cms.api.tina.logout();
        if ((_d = (_c = cms == null ? void 0 : cms.api) == null ? void 0 : _c.tina) == null ? void 0 : _d.onLogout) {
          await ((_f = (_e4 = cms == null ? void 0 : cms.api) == null ? void 0 : _e4.tina) == null ? void 0 : _f.onLogout());
        }
      }
      setEdit(false);
    }
  }, React68.createElement(BiExit, {
    className: "w-6 h-auto mr-2 text-blue-400"
  }), " Log Out")), React68.createElement(ot2.Item, null, React68.createElement(SyncStatus, {
    cms,
    setEventsOpen
  })))))))), eventsOpen && React68.createElement(SyncStatusModal, {
    cms,
    closeEventsModal
  }), children, React68.createElement("div", {
    className: "px-6 flex-1 overflow-auto"
  }, showCollections && React68.createElement(React68.Fragment, null, React68.createElement("h4", {
    className: "flex space-x-1 justify-items-start uppercase font-sans font-bold text-sm mb-3 mt-8 text-gray-700"
  }, React68.createElement("span", null, "Collections"), isLocalMode && React68.createElement("span", {
    className: "flex items-center"
  }, React68.createElement("a", {
    href: "https://tina.io/docs/schema/#defining-collections",
    target: "_blank"
  }, React68.createElement(FiInfo, null)))), React68.createElement(CollectionsList, {
    RenderNavCollection,
    ...collectionsInfo
  })), (screens.length > 0 || contentCreators.length) > 0 && React68.createElement(React68.Fragment, null, React68.createElement("h4", {
    className: "uppercase font-sans font-bold text-sm mb-3 mt-8 text-gray-700"
  }, "Site"), React68.createElement("ul", {
    className: "flex flex-col gap-4"
  }, screens.map((view) => {
    return React68.createElement("li", {
      key: `nav-site-${view.name}`
    }, React68.createElement(RenderNavSite, {
      view
    }));
  }), contentCreators.map((plugin, idx) => {
    return React68.createElement(CreateContentNavItem, {
      key: `plugin-${idx}`,
      plugin
    });
  }))), !!(cloudConfigs == null ? void 0 : cloudConfigs.length) && React68.createElement(React68.Fragment, null, React68.createElement("h4", {
    className: "uppercase font-sans font-bold text-sm mb-3 mt-8 text-gray-700"
  }, "Cloud"), React68.createElement("ul", {
    className: "flex flex-col gap-4"
  }, cloudConfigs.map((config2) => {
    return React68.createElement("li", {
      key: `nav-site-${config2.name}`
    }, React68.createElement(RenderNavCloud, {
      config: config2
    }));
  })))));
};
var CollectionsList = ({
  collections,
  RenderNavCollection
}) => {
  if (collections.length === 0) {
    return React68.createElement("div", null, "No collections found");
  }
  return React68.createElement("ul", {
    className: "flex flex-col gap-4"
  }, collections.map((collection) => {
    return React68.createElement("li", {
      key: `nav-collection-${collection.name}`
    }, React68.createElement(RenderNavCollection, {
      collection
    }));
  }));
};
var CreateContentNavItem = ({ plugin }) => {
  const [open, setOpen] = React68.useState(false);
  return React68.createElement("li", {
    key: plugin.name
  }, React68.createElement("button", {
    className: "text-base tracking-wide text-gray-500 hover:text-blue-600 flex items-center opacity-90 hover:opacity-100",
    onClick: () => {
      setOpen(true);
    }
  }, React68.createElement(VscNewFile, {
    className: "mr-3 h-6 opacity-80 w-auto"
  }), " ", plugin.name), open && React68.createElement(FormModal, {
    plugin,
    close: () => setOpen(false)
  }));
};
var ResizeHandle = () => {
  const {
    resizingSidebar,
    setResizingSidebar,
    fullscreen,
    setSidebarWidth,
    displayState
  } = React68.useContext(SidebarContext);
  React68.useEffect(() => {
    const handleMouseUp = () => setResizingSidebar(false);
    window.addEventListener("mouseup", handleMouseUp);
    return () => {
      window.removeEventListener("mouseup", handleMouseUp);
    };
  }, []);
  React68.useEffect(() => {
    const handleMouseMove = (e9) => {
      setSidebarWidth((sidebarWidth) => {
        const newWidth = sidebarWidth + e9.movementX;
        const maxWidth = window.innerWidth - 8;
        if (newWidth < minSidebarWidth) {
          return minSidebarWidth;
        } else if (newWidth > maxWidth) {
          return maxWidth;
        } else {
          return newWidth;
        }
      });
    };
    if (resizingSidebar) {
      window.addEventListener("mousemove", handleMouseMove);
      document.body.classList.add("select-none");
    }
    return () => {
      window.removeEventListener("mousemove", handleMouseMove);
      document.body.classList.remove("select-none");
    };
  }, [resizingSidebar]);
  const handleresizingSidebar = () => setResizingSidebar(true);
  if (fullscreen) {
    return null;
  }
  return React68.createElement("div", {
    onMouseDown: handleresizingSidebar,
    className: `z-100 absolute top-1/2 right-px w-2 h-32 bg-white rounded-r-md border border-gray-150 shadow-sm hover:shadow-md origin-left transition-all duration-150 ease-out transform translate-x-full -translate-y-1/2 group hover:bg-gray-50 ${displayState !== "closed" ? `opacity-100` : `opacity-0`} ${resizingSidebar ? `scale-110` : `scale-90 hover:scale-100`}`,
    style: { cursor: "grab" }
  }, React68.createElement("span", {
    className: "absolute top-1/2 left-1/2 h-4/6 w-px bg-gray-200 transform -translate-y-1/2 -translate-x-1/2 opacity-30 transition-opacity duration-150 ease-out group-hover:opacity-100"
  }));
};
var BranchContext = React68.createContext({
  currentBranch: null,
  setCurrentBranch: (branch) => {
    console.warn("BranchContext not initialized");
  }
});
var BranchDataProvider = ({
  currentBranch,
  setCurrentBranch,
  children
}) => {
  return React68.createElement(BranchContext.Provider, {
    value: {
      currentBranch,
      setCurrentBranch
    }
  }, children);
};
var useBranchData = () => {
  const branchData = React68.useContext(BranchContext);
  const { dispatch } = useEvent2("branch:change");
  React68.useEffect(() => {
    dispatch({ branchName: branchData.currentBranch });
  }, [branchData.currentBranch]);
  return branchData;
};
function GrCircleQuestion(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "stroke": "#000", "strokeWidth": "2", "d": "M12,22 C17.5228475,22 22,17.5228475 22,12 C22,6.4771525 17.5228475,2 12,2 C6.4771525,2 2,6.4771525 2,12 C2,17.5228475 6.4771525,22 12,22 Z M12,15 L12,14 C12,13 12,12.5 13,12 C14,11.5 15,11 15,9.5 C15,8.5 14,7 12,7 C10,7 9,8.26413718 9,10 M12,16 L12,18" } }] })(props);
}
function FaSpinner(props) {
  return GenIcon({ "tag": "svg", "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M304 48c0 26.51-21.49 48-48 48s-48-21.49-48-48 21.49-48 48-48 48 21.49 48 48zm-48 368c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zm208-208c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.49-48-48-48zM96 256c0-26.51-21.49-48-48-48S0 229.49 0 256s21.49 48 48 48 48-21.49 48-48zm12.922 99.078c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.491-48-48-48zm294.156 0c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48c0-26.509-21.49-48-48-48zM108.922 60.922c-26.51 0-48 21.49-48 48s21.49 48 48 48 48-21.49 48-48-21.491-48-48-48z" } }] })(props);
}
function formatBranchName(str) {
  const pattern = /[^/\w-]+/g;
  const formattedStr = str.replace(pattern, "");
  return formattedStr.toLowerCase();
}
var BranchSwitcher = ({
  listBranches,
  createBranch,
  chooseBranch
}) => {
  var _a, _b;
  const cms = useCMS$1();
  const isLocalMode = (_b = (_a = cms.api) == null ? void 0 : _a.tina) == null ? void 0 : _b.isLocalMode;
  const [listState, setListState] = React68.useState("loading");
  const [branchList, setBranchList] = React68.useState([]);
  const { currentBranch } = useBranchData();
  const initialBranch = React68.useMemo(() => currentBranch, []);
  React68.useEffect(() => {
    return () => {
      if (initialBranch != currentBranch) {
        window.location.reload();
      }
    };
  }, [currentBranch]);
  const handleCreateBranch = React68.useCallback((value) => {
    setListState("loading");
    createBranch({
      branchName: formatBranchName(value),
      baseBranch: currentBranch
    }).then(async (createdBranchName) => {
      cms.alerts.success("Branch created.");
      setBranchList((oldBranchList) => {
        return [
          ...oldBranchList,
          {
            indexStatus: { status: "unknown" },
            name: createdBranchName
          }
        ];
      });
      setListState("ready");
    });
  }, []);
  const refreshBranchList = React68.useCallback(async () => {
    setListState("loading");
    await listBranches().then((data) => {
      setBranchList(data);
      setListState("ready");
    }).catch(() => setListState("error"));
  }, []);
  React68.useEffect(() => {
    refreshBranchList();
  }, []);
  React68.useEffect(() => {
    if (listState === "ready") {
      const cancelFuncs = [];
      branchList.filter((x7) => {
        var _a2, _b2;
        return ((_a2 = x7 == null ? void 0 : x7.indexStatus) == null ? void 0 : _a2.status) === "inprogress" || ((_b2 = x7 == null ? void 0 : x7.indexStatus) == null ? void 0 : _b2.status) === "unknown";
      }).forEach(async (x7) => {
        const [
          waitForIndexStatusPromise,
          cancelWaitForIndexFunc
        ] = cms.api.tina.waitForIndexStatus({
          ref: x7.name
        });
        cancelFuncs.push(cancelWaitForIndexFunc);
        waitForIndexStatusPromise.then((indexStatus) => {
          setBranchList((previousBranchList) => {
            const newBranchList = Array.from(previousBranchList);
            const index2 = newBranchList.findIndex((y9) => y9.name === x7.name);
            newBranchList[index2].indexStatus = indexStatus;
            return newBranchList;
          });
        }).catch((e9) => {
          if (e9.message === "AsyncPoller: cancelled")
            return;
          console.error(e9);
        });
      });
      return () => {
        cancelFuncs.forEach((x7) => {
          x7();
        });
      };
    }
  }, [listState, branchList.length]);
  return React68.createElement("div", {
    className: "w-full flex justify-center p-5"
  }, React68.createElement("div", {
    className: "w-full max-w-form"
  }, isLocalMode ? React68.createElement("div", {
    className: "px-6 py-8 w-full h-full flex flex-col items-center justify-center"
  }, React68.createElement("p", {
    className: "text-base mb-4 text-center"
  }, React68.createElement(AiFillWarning, {
    className: "w-7 h-auto inline-block mr-0.5 opacity-70 text-yellow-600"
  })), React68.createElement("p", {
    className: "text-base mb-6 text-center"
  }, "Tina's branch switcher isn't available in local mode.", " ", React68.createElement("a", {
    target: "_blank",
    className: "transition-all duration-150 ease-out text-blue-600 hover:text-blue-400 hover:underline no-underline",
    href: "https://tina.io/docs/tina-cloud/"
  }, "Learn more about moving to production with Tina Cloud.")), React68.createElement("p", null, React68.createElement(Button, {
    href: "https://tina.io/docs/tina-cloud/",
    target: "_blank",
    as: "a"
  }, "Read Our Docs", " ", React68.createElement(MdArrowForward, {
    className: "w-5 h-auto ml-1.5 opacity-80"
  })))) : listState === "loading" ? React68.createElement("div", {
    style: { margin: "32px auto", textAlign: "center" }
  }, React68.createElement(LoadingDots, {
    color: "var(--tina-color-primary)"
  })) : React68.createElement(React68.Fragment, null, listState === "ready" ? React68.createElement(BranchSelector, {
    currentBranch,
    branchList,
    onCreateBranch: (newBranch) => {
      handleCreateBranch(newBranch);
    },
    onChange: (branchName) => {
      chooseBranch(branchName);
    }
  }) : React68.createElement("div", {
    className: "px-6 py-8 w-full h-full flex flex-col items-center justify-center"
  }, React68.createElement("p", {
    className: "text-base mb-4 text-center"
  }, "An error occurred while retrieving the branch list."), React68.createElement(Button, {
    className: "mb-4",
    onClick: refreshBranchList
  }, "Try again ", React68.createElement(BiRefresh, {
    className: "w-6 h-full ml-1 opacity-70"
  }))))));
};
var getFilteredBranchList = (branchList, filter, currentBranchName) => {
  const filteredBranchList = branchList.filter((branch) => !filter || branch.name.includes(filter) || branch.name === currentBranchName);
  const currentBranchItem = branchList.find((branch) => branch.name === currentBranchName);
  return [
    currentBranchItem || {
      name: currentBranchName,
      indexStatus: { status: "failed" }
    },
    ...filteredBranchList.filter((branch) => branch.name !== currentBranchName)
  ];
};
var BranchSelector = ({
  branchList,
  currentBranch,
  onCreateBranch,
  onChange
}) => {
  const [newBranchName, setNewBranchName] = React68.useState("");
  const [filter, setFilter] = React68.useState("");
  const filteredBranchList = getFilteredBranchList(branchList, filter, currentBranch);
  return React68.createElement("div", {
    className: "flex flex-col gap-3"
  }, React68.createElement("div", {
    className: "block relative group"
  }, React68.createElement(BaseTextField, {
    placeholder: "Search",
    value: filter,
    onChange: (e9) => setFilter(e9.target.value)
  }), filter === "" ? React68.createElement(BiSearch, {
    className: "absolute right-3 top-1/2 -translate-y-1/2 w-5 h-auto text-blue-500 opacity-70 group-hover:opacity-100 transition-all ease-out duration-150"
  }) : React68.createElement("button", {
    onClick: () => {
      setFilter("");
    },
    className: "outline-none focus:outline-none bg-transparent border-0 p-0 m-0 absolute right-2.5 top-1/2 -translate-y-1/2 opacity-50 hover:opacity-100 transition-all ease-out duration-150"
  }, React68.createElement(MdOutlineClear, {
    className: "w-5 h-auto text-gray-600"
  }))), filteredBranchList.length === 0 && React68.createElement("div", {
    className: "block relative text-gray-300 italic py-1"
  }, "No branches to display"), filteredBranchList.length > 0 && React68.createElement("div", {
    className: "min-w-[192px] max-h-[24rem] overflow-y-auto flex flex-col w-full h-full rounded-lg shadow-inner bg-white border border-gray-200"
  }, filteredBranchList.map((branch) => {
    var _a;
    const isCurrentBranch = branch.name === currentBranch;
    const indexingStatus = (_a = branch == null ? void 0 : branch.indexStatus) == null ? void 0 : _a.status;
    return React68.createElement("div", {
      className: `relative text-base py-1.5 px-3 flex items-center gap-1.5 border-l-0 border-t-0 border-r-0 border-b border-gray-50 w-full outline-none transition-all ease-out duration-150 ${indexingStatus !== "complete" ? "bg-gray-50 text-gray-400 pointer-events-none" : isCurrentBranch ? "cursor-pointer bg-blue-50 text-blue-800 pointer-events-none hover:text-blue-500 focus:text-blue-500 focus:bg-gray-50 hover:bg-gray-50" : "cursor-pointer hover:text-blue-500 focus:text-blue-500 focus:bg-gray-50 hover:bg-gray-50"}`,
      key: branch.name,
      onClick: () => {
        if (indexingStatus === "complete") {
          onChange(branch.name);
        }
      }
    }, isCurrentBranch && React68.createElement(BiGitBranch, {
      className: "w-5 h-auto text-blue-500/70"
    }), branch.name, indexingStatus === "unknown" && React68.createElement("span", {
      className: "flex-1 w-full flex justify-end items-center gap-2 text-blue-500"
    }, React68.createElement("span", {
      className: "opacity-50 italic"
    }, `Unknown`), React68.createElement(GrCircleQuestion, {
      className: "w-5 h-auto opacity-70"
    })), indexingStatus === "inprogress" && React68.createElement("span", {
      className: "flex-1 w-full flex justify-end items-center gap-2 text-blue-500"
    }, React68.createElement("span", {
      className: "opacity-50 italic"
    }, `Indexing`), React68.createElement(FaSpinner, {
      className: "w-5 h-auto opacity-70 animate-spin"
    })), indexingStatus === "failed" && React68.createElement("span", {
      className: "flex-1 w-full flex justify-end items-center gap-2 text-red-500"
    }, React68.createElement("span", {
      className: "opacity-50 italic"
    }, `Indexing failed`), React68.createElement(BiError, {
      className: "w-5 h-auto opacity-70"
    })), indexingStatus === "timeout" && React68.createElement("span", {
      className: "flex-1 w-full flex justify-end items-center gap-2 text-red-500"
    }, React68.createElement("span", {
      className: "opacity-50 italic"
    }, `Indexing timed out`), React68.createElement(BiError, {
      className: "w-5 h-auto opacity-70"
    })), isCurrentBranch && React68.createElement("span", {
      className: "opacity-70 italic"
    }, ` (current)`));
  })), React68.createElement("div", {
    className: "border-t border-gray-150 pt-4 mt-3 flex flex-col gap-3"
  }, React68.createElement("div", {
    className: "text-sm"
  }, "Create a new branch from ", React68.createElement("b", null, currentBranch), ". Once created you will need to wait for indexing to complete before you can switch branches."), React68.createElement("div", {
    className: "flex justify-between items-center w-full gap-3"
  }, React68.createElement(BaseTextField, {
    placeholder: "Branch Name",
    value: newBranchName,
    onChange: (e9) => setNewBranchName(e9.target.value)
  }), React68.createElement(Button, {
    className: "flex-0 flex items-center gap-2 whitespace-nowrap",
    size: "medium",
    variant: "white",
    disabled: newBranchName === "",
    onClick: () => onCreateBranch(newBranchName)
  }, React68.createElement(BiPlus, {
    className: "w-5 h-auto opacity-70"
  }), " Create Branch"))));
};
var BranchSwitcherPlugin = class {
  constructor(options) {
    this.__type = "screen";
    this.Icon = BiGitRepoForked;
    this.name = "Select Branch";
    this.layout = "popup";
    this.Component = () => {
      return React68.createElement(BranchSwitcher, {
        listBranches: this.listBranches,
        createBranch: this.createBranch,
        chooseBranch: this.chooseBranch
      });
    };
    this.listBranches = options.listBranches;
    this.createBranch = options.createBranch;
    this.chooseBranch = options.chooseBranch;
  }
};
var GlobalFormPlugin = class {
  constructor(form, icon, layout) {
    this.form = form;
    this.__type = "screen";
    this.name = form.label;
    this.Icon = icon || MdOutlineSettings;
    this.layout = layout || "popup";
    this.Component = () => {
      return React68.createElement(FormBuilder, {
        form
      });
    };
  }
};
function useGlobalForm(options, watch = {}) {
  const [values3, form] = useForm2(options, watch);
  const GlobalForm = (0, import_react117.useMemo)(() => {
    if (!form)
      return;
    return new GlobalFormPlugin(form);
  }, [form]);
  usePlugins(GlobalForm);
  return [values3, form];
}
function useFormScreenPlugin(form, icon, layout) {
  const GlobalForm = (0, import_react117.useMemo)(() => {
    if (!form)
      return;
    return new GlobalFormPlugin(form, icon, layout);
  }, [form, icon, layout]);
  usePlugins(GlobalForm);
}
var MarkdownFieldPlaceholder = {
  __type: "field",
  name: "markdown",
  Component: createPlaceholder("Markdown")
};
var HtmlFieldPlaceholder = {
  __type: "field",
  name: "html",
  Component: createPlaceholder("HTML")
};
function createPlaceholder(name2, _pr) {
  return (props) => {
    return import_react117.default.createElement(FieldMeta, {
      name: props.input.name,
      label: `${name2} Field not Registered`,
      tinaForm: props.tinaForm
    }, import_react117.default.createElement("p", {
      className: "whitespace-normal text-[15px] mt-2"
    }, "The ", name2, " field is not registered. Some built-in field types are not bundled by default in an effort to control bundle size. Consult the Tina docs to learn how to use this field type."), import_react117.default.createElement("p", {
      className: "whitespace-normal text-[15px] mt-2"
    }, import_react117.default.createElement("a", {
      className: "text-blue-500 underline",
      href: "https://tina.io/docs/editing/markdown/#registering-the-field-plugins",
      target: "_blank",
      rel: "noreferrer noopener"
    }, "Tina Docs: Registering Field Plugins")));
  };
}
function CursorPaginator({
  navigateNext,
  navigatePrev,
  hasNext,
  hasPrev,
  variant = "white"
}) {
  return import_react117.default.createElement("div", {
    className: "w-full flex flex-shrink-0 justify-end gap-2 items-center"
  }, import_react117.default.createElement(Button, {
    variant,
    disabled: !hasPrev,
    onClick: navigatePrev
  }, import_react117.default.createElement(BiLeftArrowAlt, {
    className: "w-6 h-full mr-2 opacity-70"
  }), " Previous"), import_react117.default.createElement(Button, {
    variant,
    disabled: !hasNext,
    onClick: navigateNext
  }, "Next ", import_react117.default.createElement(BiRightArrowAlt, {
    className: "w-6 h-full ml-2 opacity-70"
  })));
}
function ListMediaItem({ item, onClick, active }) {
  const FileIcon = item.type === "dir" ? BiFolder : BiFile;
  const thumbnail = (item.thumbnails || {})["75x75"];
  return import_react117.default.createElement("li", {
    className: `flex shrink-0 gap-3 items-center py-2 pl-2 pr-3 transition duration-150 ease-out cursor-pointer border-b border-gray-150 ${active ? "bg-gradient-to-r from-white to-gray-50/50 text-blue-500 hover:bg-gray-50" : "bg-white hover:bg-gray-50/50"}`,
    onClick: () => {
      if (!active) {
        onClick(item);
      } else {
        onClick(false);
      }
    }
  }, import_react117.default.createElement("div", {
    className: "w-20 h-20 bg-gray-50 shadow border border-gray-100 rounded overflow-hidden flex justify-center flex-shrink-0"
  }, isImage(thumbnail) ? import_react117.default.createElement("img", {
    className: "object-cover w-full h-full object-center",
    src: thumbnail,
    alt: item.filename
  }) : import_react117.default.createElement(FileIcon, {
    className: "w-3/5 h-full fill-gray-300"
  })), import_react117.default.createElement("span", {
    className: "text-base flex-grow w-full break-words truncate"
  }, item.filename));
}
function GridMediaItem({ item, active, onClick }) {
  const FileIcon = item.type === "dir" ? BiFolder : BiFile;
  const thumbnail = (item.thumbnails || {})["400x400"];
  return import_react117.default.createElement("li", {
    className: `relative pb-[100%] h-0 block border border-gray-100 rounded-md overflow-hidden flex justify-center shrink-0 w-full transition duration-150 ease-out ${active ? "shadow-outline" : "shadow hover:shadow-md hover:scale-103 hover:border-gray-150"} ${item.type === "dir" ? "cursor-pointer" : ""}`
  }, import_react117.default.createElement("button", {
    className: "absolute w-full h-full flex items-center justify-center bg-white",
    onClick: () => {
      if (!active) {
        onClick(item);
      } else {
        onClick(false);
      }
    }
  }, isImage(thumbnail) ? import_react117.default.createElement("img", {
    className: "object-cover w-full h-full object-center",
    src: thumbnail,
    alt: item.filename
  }) : import_react117.default.createElement("div", {
    className: "p-4 w-full flex flex-col gap-4 items-center justify-center"
  }, import_react117.default.createElement(FileIcon, {
    className: "w-[30%] h-auto fill-gray-300"
  }), import_react117.default.createElement("span", {
    className: "block text-base text-gray-600 w-full break-words truncate"
  }, item.filename))));
}
function dirname(path) {
  var _a, _b;
  const pattern = new RegExp("(?<prevDir>.*)/");
  return (_b = (_a = path.match(pattern)) == null ? void 0 : _a.groups) == null ? void 0 : _b.prevDir;
}
var BreadcrumbButton = ({ className = "", ...props }) => import_react117.default.createElement("button", {
  className: "capitalize transition-colors duration-150 border-0 bg-transparent hover:text-blue-500 " + className,
  ...props
});
function Breadcrumb({ directory = "", setDirectory }) {
  directory = directory.replace(/^\/|\/$/g, "");
  let prevDir = dirname(directory) || "";
  if (prevDir === ".") {
    prevDir = "";
  }
  return import_react117.default.createElement("div", {
    className: "w-full flex items-center text-[16px] text-gray-300"
  }, directory !== "" && import_react117.default.createElement(IconButton, {
    variant: "ghost",
    className: "mr-2",
    onClick: () => setDirectory(prevDir)
  }, import_react117.default.createElement(LeftArrowIcon, {
    className: `w-7 h-auto fill-gray-300 hover:fill-gray-900 transition duration-150 ease-out`
  })), import_react117.default.createElement(BreadcrumbButton, {
    onClick: () => setDirectory(""),
    className: directory === "" ? "text-gray-500 font-bold" : "text-gray-300 font-medium after:pl-1.5 after:content-['/']"
  }, "Media"), directory && directory.split("/").map((part, index2, parts) => {
    const currentDir = parts.slice(0, index2 + 1).join("/");
    return import_react117.default.createElement(BreadcrumbButton, {
      className: "pl-1.5 " + (index2 + 1 === parts.length ? "text-gray-500 font-bold" : "text-gray-300 font-medium after:pl-1.5 after:content-['/']"),
      key: currentDir,
      onClick: () => {
        setDirectory(currentDir);
      }
    }, part);
  }));
}
var DeleteModal = ({
  close: close2,
  deleteFunc,
  filename
}) => {
  return import_react117.default.createElement(Modal, null, import_react117.default.createElement(PopupModal, null, import_react117.default.createElement(ModalHeader, {
    close: close2
  }, "Delete ", filename), import_react117.default.createElement(ModalBody, {
    padded: true
  }, import_react117.default.createElement("p", null, "Are you sure you want to delete ", import_react117.default.createElement("strong", null, filename), "?")), import_react117.default.createElement(ModalActions, null, import_react117.default.createElement(Button, {
    style: { flexGrow: 2 },
    onClick: close2
  }, "Cancel"), import_react117.default.createElement(Button, {
    style: { flexGrow: 3 },
    variant: "danger",
    onClick: () => {
      deleteFunc();
      close2();
    }
  }, "Delete"))));
};
var SyncModal = ({ close: close2, syncFunc, folder, branch }) => {
  return import_react117.default.createElement(Modal, null, import_react117.default.createElement(PopupModal, null, import_react117.default.createElement(ModalHeader, {
    close: close2
  }, "Sync Media"), import_react117.default.createElement(ModalBody, {
    padded: true
  }, import_react117.default.createElement("p", null, `This will copy media assets from the \`${folder}\` folder on branch \`${branch}\` in your git repository to Tina Cloud's asset service. This will allow you to use these assets in your site with Tina Cloud`)), import_react117.default.createElement(ModalActions, null, import_react117.default.createElement(Button, {
    style: { flexGrow: 2 },
    onClick: close2
  }, "Cancel"), import_react117.default.createElement(Button, {
    style: { flexGrow: 3 },
    variant: "primary",
    onClick: async () => {
      await syncFunc();
      close2();
    }
  }, "Sync Media"))));
};
var CopyField = ({ label, description, value }) => {
  const [copied, setCopied] = import_react117.default.useState(false);
  const [fadeOut, setFadeOut] = import_react117.default.useState(false);
  return import_react117.default.createElement("div", {
    className: "w-full"
  }, label && import_react117.default.createElement("label", {
    className: "w-full mb-1 block flex-1  text-sm font-bold leading-5 text-gray-700"
  }, label), import_react117.default.createElement("span", {
    onClick: () => {
      if (copied === true)
        return;
      setCopied(true);
      setTimeout(() => {
        setFadeOut(true);
      }, 2500);
      setTimeout(() => {
        setCopied(false);
        setFadeOut(false);
      }, 3e3);
      navigator.clipboard.writeText(value);
    },
    className: `shadow-inner text-base leading-5 whitespace-normal break-all px-3 py-2 text-gray-600 w-full bg-gray-50 border border-gray-200 transition-all ease-out duration-150 rounded-md relative overflow-hidden appearance-none flex items-center w-full cursor-pointer hover:bg-white hover:text-blue-500  ${copied ? `pointer-events-none` : ``}`
  }, import_react117.default.createElement(BiCopyAlt, {
    className: "relative text-blue-500 shrink-0 w-5 h-auto mr-1.5 -ml-0.5 z-20"
  }), " ", value, " ", copied && import_react117.default.createElement("span", {
    className: `${fadeOut ? `opacity-0` : `opacity-100`} text-blue-500 transition-opacity	duration-500 absolute right-0 w-full h-full px-3 py-2 bg-white bg-opacity-90 flex items-center justify-center text-center tracking-wide font-medium z-10`
  }, import_react117.default.createElement("span", null, "Copied to clipboard!"))), description && import_react117.default.createElement("p", {
    className: "mt-2 text-sm text-gray-500"
  }, description));
};
async function poll(fn2, timeout, interval) {
  const endTime = Number(new Date()) + (timeout || 2e3);
  interval = interval || 100;
  const checkCondition = async function(resolve, reject) {
    const result = await fn2();
    if (result.complete) {
      resolve(result);
    } else if (Number(new Date()) < endTime) {
      setTimeout(checkCondition, interval, resolve, reject);
    } else {
      reject(new Error("Time out error"));
    }
  };
  return new Promise(checkCondition);
}
var join = function(...parts) {
  const [first, last2, slash] = [0, parts.length - 1, "/"];
  const matchLeadingSlash = new RegExp("^" + slash);
  const matchTrailingSlash = new RegExp(slash + "$");
  parts = parts.map(function(part, index2) {
    if (index2 === first && part === "file://")
      return part;
    if (index2 > first)
      part = part.replace(matchLeadingSlash, "");
    if (index2 < last2)
      part = part.replace(matchTrailingSlash, "");
    return part;
  });
  return parts.join(slash);
};
function MediaManager() {
  const cms = useCMS();
  const [request, setRequest] = (0, import_react117.useState)();
  (0, import_react117.useEffect)(() => {
    return cms.events.subscribe("media:open", ({ type, ...request2 }) => {
      setRequest(request2);
    });
  }, []);
  if (!request)
    return null;
  const close2 = () => setRequest(void 0);
  return import_react117.default.createElement(Modal, null, import_react117.default.createElement(FullscreenModal, null, import_react117.default.createElement("div", {
    className: "w-full bg-gray-50 flex items-center justify-between px-5 pt-3 m-0"
  }, import_react117.default.createElement("h2", {
    className: "text-gray-500 font-sans font-medium text-base leading-none m-0 block truncate"
  }, "Media Manager"), import_react117.default.createElement("div", {
    onClick: close2,
    className: "flex items-center fill-gray-400 cursor-pointer transition-colors duration-100 ease-out hover:fill-gray-700"
  }, import_react117.default.createElement(CloseIcon, {
    className: "w-6 h-auto"
  }))), import_react117.default.createElement(ModalBody, {
    className: "flex h-full flex-col"
  }, import_react117.default.createElement(MediaPicker, {
    ...request,
    close: close2
  }))));
}
var defaultListError = new MediaListError({
  title: "Error fetching media",
  message: "Something went wrong while requesting the resource.",
  docsLink: "https://tina.io/docs/media/#media-store"
});
function MediaPicker({
  allowDelete,
  onSelect,
  close: close2,
  ...props
}) {
  var _a, _b, _c, _d, _e4, _f, _g, _h, _i, _j, _k, _l, _m;
  const cms = useCMS();
  const [listState, setListState] = (0, import_react117.useState)(() => {
    if (cms.media.isConfigured)
      return "loading";
    return "not-configured";
  });
  const [deleteModalOpen, setDeleteModalOpen] = import_react117.default.useState(false);
  const [listError, setListError] = (0, import_react117.useState)(defaultListError);
  const [directory, setDirectory] = (0, import_react117.useState)(props.directory);
  const [list, setList] = (0, import_react117.useState)({
    items: [],
    nextOffset: void 0
  });
  const [showSync, setShowSync] = (0, import_react117.useState)(false);
  const [viewMode, setViewMode] = (0, import_react117.useState)("grid");
  const [activeItem, setActiveItem] = (0, import_react117.useState)(false);
  const closePreview = () => setActiveItem(false);
  const [offsetHistory, setOffsetHistory] = (0, import_react117.useState)([]);
  const [loadingText, setLoadingText] = (0, import_react117.useState)("");
  const offset5 = offsetHistory[offsetHistory.length - 1];
  const resetOffset = () => setOffsetHistory([]);
  const navigateNext = () => {
    if (!list.nextOffset)
      return;
    setOffsetHistory([...offsetHistory, list.nextOffset]);
  };
  const navigatePrev = () => {
    const offsets = offsetHistory.slice(0, offsetHistory.length - 1);
    setOffsetHistory(offsets);
  };
  const hasPrev = offsetHistory.length > 0;
  const hasNext = !!list.nextOffset;
  const isLocal2 = cms.api.tina.isLocalMode;
  const hasTinaMedia = Object.keys(((_c = (_b = (_a = cms.api.tina.schema.schema) == null ? void 0 : _a.config) == null ? void 0 : _b.media) == null ? void 0 : _c.tina) || {}).includes("mediaRoot") && Object.keys(((_f = (_e4 = (_d = cms.api.tina.schema.schema) == null ? void 0 : _d.config) == null ? void 0 : _e4.media) == null ? void 0 : _f.tina) || {}).includes("publicFolder");
  const folder = hasTinaMedia ? join((_i = (_h = (_g = cms.api.tina.schema.schema) == null ? void 0 : _g.config) == null ? void 0 : _h.media) == null ? void 0 : _i.tina.publicFolder, (_l = (_k = (_j = cms.api.tina.schema.schema) == null ? void 0 : _j.config) == null ? void 0 : _k.media) == null ? void 0 : _l.tina.mediaRoot) : "";
  const branch = (_m = cms.api.tina) == null ? void 0 : _m.branch;
  function loadMedia() {
    setListState("loading");
    cms.media.list({
      offset: offset5,
      limit: cms.media.pageSize,
      directory,
      thumbnailSizes: [
        { w: 75, h: 75 },
        { w: 400, h: 400 },
        { w: 1e3, h: 1e3 }
      ]
    }).then((list2) => {
      setList(list2);
      setListState("loaded");
    }).catch((e9) => {
      console.error(e9);
      if (e9.ERR_TYPE === "MediaListError") {
        setListError(e9);
      } else {
        setListError(defaultListError);
      }
      setListState("error");
    });
  }
  (0, import_react117.useEffect)(() => {
    if (!cms.media.isConfigured)
      return;
    loadMedia();
    return cms.events.subscribe(["media:upload:success", "media:delete:success", "media:pageSize"], loadMedia);
  }, [offset5, directory, cms.media.isConfigured]);
  const onClickMediaItem = (item) => {
    if (!item) {
      setActiveItem(false);
    } else if (item.type === "dir") {
      setDirectory(item.directory === "." || item.directory === "" ? item.filename : join(item.directory, item.filename));
      resetOffset();
    } else {
      setActiveItem(item);
    }
  };
  let deleteMediaItem;
  if (allowDelete) {
    deleteMediaItem = (item) => {
      cms.media.delete(item);
    };
  }
  let selectMediaItem;
  if (onSelect) {
    selectMediaItem = (item) => {
      onSelect(item);
      if (close2)
        close2();
    };
  }
  const [uploading, setUploading] = (0, import_react117.useState)(false);
  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    accept: dropzoneAcceptFromString(cms.media.accept || DEFAULT_MEDIA_UPLOAD_TYPES),
    multiple: true,
    onDrop: async (files, fileRejections) => {
      try {
        setUploading(true);
        await cms.media.persist(files.map((file) => {
          return {
            directory: directory || "/",
            file
          };
        }));
        const errorCodes = {
          "file-invalid-type": "Invalid file type",
          "file-too-large": "File too large",
          "file-too-small": "File too small",
          "too-many-files": "Too many files"
        };
        const printError = (error2) => {
          const message = errorCodes[error2.code];
          if (message) {
            return message;
          }
          console.error(error2);
          return "Unknown error";
        };
        if (fileRejections.length > 0) {
          const messages = [];
          fileRejections.map((fileRejection) => {
            messages.push(`${fileRejection.file.name}: ${fileRejection.errors.map((error2) => printError(error2)).join(", ")}`);
          });
          cms.alerts.error(() => {
            return import_react117.default.createElement(import_react117.default.Fragment, null, "Upload Failed. ", import_react117.default.createElement("br", null), messages.join(". "), ".");
          });
        }
      } catch {
      }
      setUploading(false);
    }
  });
  const syncMedia = async () => {
    if (hasTinaMedia) {
      const res = await cms.api.tina.syncTinaMedia();
      if (res == null ? void 0 : res.assetsSyncing) {
        try {
          setListState("loading");
          await poll(async () => {
            var _a2, _b2;
            const status = await cms.api.tina.checkSyncStatus({
              assetsSyncing: res.assetsSyncing
            });
            const totalDone = (_a2 = Object.values(status.status).filter(Boolean)) == null ? void 0 : _a2.length;
            const total = (_b2 = Object.keys(status.status)) == null ? void 0 : _b2.length;
            setLoadingText(`${totalDone}/${total} Media items loaded`);
            return status;
          }, 6e4, 3e3);
          setLoadingText("");
          loadMedia();
        } catch (e9) {
          cms.alerts.error("Error in syncing media, check console for more details");
          console.error("'Error in syncing media, check below for more details");
          console.error(e9);
        }
      } else {
        cms.alerts.warn("Whoops, Looks media is not set up correctly in Tina Cloud. Check console for more details");
        console.warn("Whoops, Looks media is not set up correctly. Check below for more details");
        console.warn(res);
      }
    }
  };
  const { onClick, ...rootProps } = getRootProps();
  function disableScrollBody() {
    const body = document == null ? void 0 : document.body;
    body.style.overflow = "hidden";
    return () => {
      body.style.overflow = "auto";
    };
  }
  (0, import_react117.useEffect)(disableScrollBody, []);
  if (listState === "loading" || uploading) {
    return import_react117.default.createElement(LoadingMediaList, {
      extraText: loadingText
    });
  }
  if (listState === "not-configured") {
    return import_react117.default.createElement(DocsLink, {
      title: "No Media Store Configured",
      message: "To use the media manager, you need to configure a Media Store.",
      docsLink: "https://tina.io/docs/reference/media/overview/"
    });
  }
  if (listState === "error") {
    const { title, message, docsLink } = listError;
    return import_react117.default.createElement(DocsLink, {
      title,
      message,
      docsLink
    });
  }
  return import_react117.default.createElement(import_react117.default.Fragment, null, deleteModalOpen && import_react117.default.createElement(DeleteModal, {
    filename: activeItem ? activeItem.filename : "",
    deleteFunc: () => {
      if (activeItem) {
        deleteMediaItem(activeItem);
        setActiveItem(false);
      }
    },
    close: () => setDeleteModalOpen(false)
  }), import_react117.default.createElement(MediaPickerWrap, null, import_react117.default.createElement("div", {
    className: "flex items-center bg-gray-50 border-b border-gray-150 gap-x-4 py-3 px-5 shadow-sm flex-shrink-0"
  }, import_react117.default.createElement(ViewModeToggle, {
    viewMode,
    setViewMode
  }), import_react117.default.createElement(Breadcrumb, {
    directory,
    setDirectory
  }), !isLocal2 && hasTinaMedia && import_react117.default.createElement(Button, {
    busy: false,
    variant: "white",
    onClick: () => {
      setShowSync(true);
    }
  }, "Sync ", import_react117.default.createElement(IoMdSync, {
    className: "w-6 h-full ml-2 opacity-70"
  })), import_react117.default.createElement(UploadButton, {
    onClick,
    uploading
  })), import_react117.default.createElement("div", {
    className: "flex h-full overflow-hidden bg-white"
  }, import_react117.default.createElement("div", {
    className: "flex w-full flex-col h-full @container"
  }, import_react117.default.createElement("ul", {
    ...rootProps,
    className: `h-full grow overflow-y-auto transition duration-150 ease-out bg-gradient-to-b from-gray-50/50 to-gray-50 ${list.items.length === 0 || viewMode === "list" && "w-full flex flex-1 flex-col justify-start -mb-px"} ${list.items.length > 0 && viewMode === "grid" && "w-full p-4 gap-4 grid grid-cols-1 @sm:grid-cols-2 @lg:grid-cols-3 @2xl:grid-cols-4 @4xl:grid-cols-6 @6xl:grid-cols-8 auto-rows-auto content-start justify-start"} ${isDragActive ? `border-2 border-blue-500 rounded-lg` : ``}`
  }, import_react117.default.createElement("input", {
    ...getInputProps()
  }), listState === "loaded" && list.items.length === 0 && import_react117.default.createElement(EmptyMediaList, {
    hasTinaMedia
  }), viewMode === "list" && list.items.map((item) => import_react117.default.createElement(ListMediaItem, {
    key: item.id,
    item,
    onClick: onClickMediaItem,
    active: activeItem && activeItem.id === item.id
  })), viewMode === "grid" && list.items.map((item) => import_react117.default.createElement(GridMediaItem, {
    key: item.id,
    item,
    onClick: onClickMediaItem,
    active: activeItem && activeItem.id === item.id
  }))), import_react117.default.createElement("div", {
    className: "bg-gradient-to-r to-gray-50/50 from-gray-50 shrink-0 grow-0 border-t border-gray-150 py-3 px-5 shadow-sm z-10"
  }, import_react117.default.createElement(CursorPaginator, {
    hasNext,
    navigateNext,
    hasPrev,
    navigatePrev
  }))), import_react117.default.createElement(ActiveItemPreview, {
    activeItem,
    close: closePreview,
    selectMediaItem,
    allowDelete,
    deleteMediaItem: () => {
      setDeleteModalOpen(true);
    }
  }))), showSync && import_react117.default.createElement(SyncModal, {
    folder,
    branch,
    syncFunc: syncMedia,
    close: () => {
      setShowSync(false);
    }
  }));
}
var ActiveItemPreview = ({
  activeItem,
  close: close2,
  selectMediaItem,
  deleteMediaItem,
  allowDelete
}) => {
  const thumbnail = activeItem ? (activeItem.thumbnails || {})["1000x1000"] : "";
  return import_react117.default.createElement("div", {
    className: `shrink-0 h-full flex flex-col items-start gap-3 overflow-y-auto bg-white border-l border-gray-100 bg-white shadow-md transition ease-out duration-150 ${activeItem ? `p-4 opacity-100 w-[35%] max-w-[560px] min-w-[240px]` : `translate-x-8 opacity-0 w-[0px]`}`
  }, activeItem && import_react117.default.createElement(import_react117.default.Fragment, null, import_react117.default.createElement("div", {
    className: "flex grow-0 shrink-0 gap-2 w-full items-center justify-between"
  }, import_react117.default.createElement("h3", {
    className: "text-lg text-gray-600 w-full max-w-full break-words block truncate flex-1"
  }, activeItem.filename), import_react117.default.createElement(IconButton, {
    variant: "ghost",
    className: "group grow-0 shrink-0",
    onClick: close2
  }, import_react117.default.createElement(BiX, {
    className: `w-7 h-auto text-gray-500 opacity-50 group-hover:opacity-100 transition duration-150 ease-out`
  }))), isImage(thumbnail) ? import_react117.default.createElement("div", {
    className: "w-full max-h-[75%]"
  }, import_react117.default.createElement("img", {
    className: "block border border-gray-100 rounded-md overflow-hidden max-w-full max-h-full object-fit h-auto shadow",
    src: thumbnail,
    alt: activeItem.filename
  })) : import_react117.default.createElement("span", {
    className: "p-3 border border-gray-100 rounded-md overflow-hidden bg-gray-50 shadow"
  }, import_react117.default.createElement(BiFile, {
    className: "w-14 h-auto fill-gray-300"
  })), import_react117.default.createElement("div", {
    className: "grow h-full w-full shrink flex flex-col gap-3 items-start justify-start"
  }, import_react117.default.createElement(CopyField, {
    value: absoluteImgURL(activeItem.src),
    label: "URL"
  })), import_react117.default.createElement("div", {
    className: "shrink-0 w-full flex flex-col justify-end items-start"
  }, import_react117.default.createElement("div", {
    className: "flex w-full gap-3"
  }, selectMediaItem && import_react117.default.createElement(Button, {
    size: "medium",
    variant: "primary",
    className: "grow",
    onClick: () => selectMediaItem(activeItem)
  }, "Insert", import_react117.default.createElement(BiArrowToBottom, {
    className: "ml-1 -mr-0.5 w-6 h-auto text-white opacity-70"
  })), allowDelete && import_react117.default.createElement(Button, {
    variant: "white",
    size: "medium",
    className: "grow max-w-[40%]",
    onClick: deleteMediaItem
  }, "Delete", import_react117.default.createElement(TrashIcon, {
    className: "ml-1 -mr-0.5 w-6 h-auto text-red-500 opacity-70"
  }))))));
};
var UploadButton = ({ onClick, uploading }) => {
  return import_react117.default.createElement(Button, {
    variant: "primary",
    size: "custom",
    className: "text-sm h-10 px-6",
    busy: uploading,
    onClick
  }, uploading ? import_react117.default.createElement(LoadingDots, null) : import_react117.default.createElement(import_react117.default.Fragment, null, "Upload ", import_react117.default.createElement(BiCloudUpload, {
    className: "w-6 h-full ml-2 opacity-70"
  })));
};
var LoadingMediaList = (props) => {
  return import_react117.default.createElement("div", {
    className: "w-full h-full flex flex-col items-center justify-center",
    ...props
  }, props.extraText && import_react117.default.createElement("p", null, props.extraText), import_react117.default.createElement(LoadingDots, {
    color: "var(--tina-color-primary)"
  }));
};
var MediaPickerWrap = ({ children }) => {
  return import_react117.default.createElement("div", {
    className: "h-full flex-1 text-gray-700 flex flex-col relative bg-gray-50 outline-none active:outline-none focus:outline-none"
  }, children);
};
var EmptyMediaList = (props) => {
  return import_react117.default.createElement("div", {
    className: `p-12 text-xl opacity-50 text-center`,
    ...props
  }, "Drag and drop assets here", props.hasTinaMedia && " or click 'Sync' to sync your media to Tina Cloud.");
};
var DocsLink = ({ title, message, docsLink, ...props }) => {
  return import_react117.default.createElement("div", {
    className: "h-3/4 text-center flex flex-col justify-center",
    ...props
  }, import_react117.default.createElement("h2", {
    className: "mb-3 text-xl text-gray-600"
  }, title), import_react117.default.createElement("div", {
    className: "mb-3 text-base text-gray-700"
  }, message), import_react117.default.createElement("a", {
    href: docsLink,
    target: "_blank",
    rel: "noreferrer noopener",
    className: "font-bold text-blue-500 hover:text-blue-600 hover:underline transition-all ease-out duration-150"
  }, "Learn More"));
};
var ViewModeToggle = ({ viewMode, setViewMode }) => {
  const toggleClasses = {
    base: "relative whitespace-nowrap flex items-center justify-center flex-1 block font-medium text-base py-1 transition-all ease-out duration-150 border",
    active: "bg-white text-blue-500 shadow-inner border-gray-50 border-t-gray-100",
    inactive: "bg-gray-50 text-gray-400 shadow border-gray-100 border-t-white"
  };
  return import_react117.default.createElement("div", {
    className: `grow-0 flex justify-between rounded-md border border-gray-100`
  }, import_react117.default.createElement("button", {
    className: `${toggleClasses.base} px-2.5 rounded-l-md ${viewMode === "grid" ? toggleClasses.active : toggleClasses.inactive}`,
    onClick: () => {
      setViewMode("grid");
    }
  }, import_react117.default.createElement(BiGridAlt, {
    className: "w-6 h-full opacity-70"
  })), import_react117.default.createElement("button", {
    className: `${toggleClasses.base} px-2 rounded-r-md ${viewMode === "list" ? toggleClasses.active : toggleClasses.inactive}`,
    onClick: () => {
      setViewMode("list");
    }
  }, import_react117.default.createElement(BiListUl, {
    className: "w-8 h-full opacity-70"
  })));
};
var MediaManagerScreenPlugin = createScreen({
  name: "Media Manager",
  Component: MediaPicker,
  Icon: MdOutlinePhotoLibrary,
  layout: "fullscreen",
  props: {
    allowDelete: true
  }
});
function createCloudConfig({
  ...options
}) {
  return {
    __type: "cloud-config",
    Icon: MdOutlineCloud,
    ...options
  };
}
var DEFAULT_FIELDS = [
  TextFieldPlugin,
  TextareaFieldPlugin,
  ImageFieldPlugin,
  ColorFieldPlugin,
  NumberFieldPlugin,
  ToggleFieldPlugin,
  SelectFieldPlugin,
  MdxFieldPlugin,
  RadioGroupFieldPlugin,
  GroupFieldPlugin,
  GroupListFieldPlugin,
  ListFieldPlugin,
  BlocksFieldPlugin,
  TagsFieldPlugin,
  DateFieldPlugin,
  MarkdownFieldPlaceholder,
  HtmlFieldPlaceholder,
  CheckboxGroupFieldPlugin,
  ReferenceFieldPlugin,
  ButtonToggleFieldPlugin,
  HiddenFieldPlugin
];
var TinaCMS = class extends CMS {
  constructor({
    sidebar,
    alerts = {},
    isLocalClient,
    clientId,
    ...config2
  } = {}) {
    super(config2);
    this.alerts.setMap({
      "media:upload:failure": (event) => {
        return {
          error: event.error,
          level: "error",
          message: `Failed to upload file(s) ${event == null ? void 0 : event.uploaded.map((x7) => x7.file.name).join(", ")}. See error message: 

 ${event == null ? void 0 : event.error.toString()}`
        };
      },
      "media:delete:failure": () => ({
        level: "error",
        message: "Failed to delete file."
      }),
      ...alerts
    });
    if (sidebar) {
      const sidebarConfig = typeof sidebar === "object" ? sidebar : void 0;
      this.sidebar = new SidebarState(this.events, sidebarConfig);
    }
    DEFAULT_FIELDS.forEach((field) => {
      if (!this.fields.find(field.name)) {
        this.fields.add(field);
      }
    });
    this.plugins.add(MediaManagerScreenPlugin);
    if (isLocalClient !== true) {
      if (clientId) {
        this.plugins.add(createCloudConfig({
          name: "Project Config",
          link: {
            text: "Project Config",
            href: `https://app.tina.io/projects/${clientId}/overview`
          }
        }));
        this.plugins.add(createCloudConfig({
          name: "User Management",
          link: {
            text: "User Management",
            href: `https://app.tina.io/projects/${clientId}/collaborators`
          }
        }));
      } else {
        this.plugins.add(createCloudConfig({
          name: "Setup Cloud",
          text: "No project configured, set one up ",
          link: {
            text: "here",
            href: `https://app.tina.io`
          }
        }));
      }
    }
  }
  get alerts() {
    if (!this._alerts) {
      this._alerts = new Alerts$1(this.events);
    }
    return this._alerts;
  }
  registerApi(name2, api) {
    if (api.alerts) {
      this.alerts.setMap(api.alerts);
    }
    super.registerApi(name2, api);
  }
  get forms() {
    return this.plugins.findOrCreateMap("form");
  }
  get fields() {
    return this.plugins.findOrCreateMap("field");
  }
  get screens() {
    return this.plugins.findOrCreateMap("screen");
  }
};
var INVALID_CMS_ERROR = "The `cms` prop must be an instance of `TinaCMS`.";
var TinaCMSProvider = ({
  cms,
  children
}) => {
  if (!(cms instanceof TinaCMS)) {
    throw new Error(INVALID_CMS_ERROR);
  }
  return React68.createElement(CMSContext.Provider, {
    value: cms
  }, children);
};
function Alerts({ alerts }) {
  useSubscribable(alerts);
  if (!alerts.all.length) {
    return null;
  }
  return import_react117.default.createElement(import_react117.default.Fragment, null, import_react117.default.createElement("div", {
    className: "fixed bottom-0 left-0 right-0 p-6 flex flex-col items-center z-[999999] pointer-events-none"
  }, alerts.all.filter((alert) => {
    return alert.level !== "error";
  }).map((alert) => {
    return import_react117.default.createElement(Alert, {
      key: alert.id,
      level: alert.level
    }, alert.level === "info" && import_react117.default.createElement(InfoIcon, {
      className: "w-5 h-5 mr-2"
    }), alert.level === "success" && import_react117.default.createElement(AlertIcon, {
      className: "w-5 h-5 mr-2"
    }), alert.level === "warn" && import_react117.default.createElement(WarningIcon, {
      className: "w-5 h-5 mr-2"
    }), import_react117.default.createElement("p", {
      className: "m-0 flex-1 max-w-[680px] text-left"
    }, alert.message), import_react117.default.createElement(CloseAlert, {
      onClick: () => {
        alerts.dismiss(alert);
      }
    }));
  })), alerts.all.filter((alert) => {
    return alert.level === "error";
  }).map((alert) => {
    const AlertMessage = typeof alert.message === "string" ? () => {
      return import_react117.default.createElement("p", {
        className: "text-base mb-3 overflow-y-auto"
      }, alert.message);
    } : alert.message;
    return import_react117.default.createElement(Modal, {
      key: alert.id
    }, import_react117.default.createElement(PopupModal, null, import_react117.default.createElement(ModalHeader, {
      close: () => {
        alerts.dismiss(alert);
      }
    }, import_react117.default.createElement(ErrorIcon, {
      className: "mr-1 w-6 h-auto fill-current inline-block text-red-600"
    }), " ", "Error"), import_react117.default.createElement(ModalBody, {
      padded: true
    }, import_react117.default.createElement("div", {
      className: "tina-prose"
    }, import_react117.default.createElement(AlertMessage, null))), import_react117.default.createElement(ModalActions, null, import_react117.default.createElement("div", {
      className: "flex-1"
    }), import_react117.default.createElement(Button, {
      style: { flexGrow: 1 },
      onClick: () => {
        alerts.dismiss(alert);
      }
    }, "Close"))));
  }));
}
var Alert = ({ level, ...props }) => {
  const fillColor = {
    info: "var(--tina-color-primary)",
    success: "var(--tina-color-success)",
    warn: "var(--tina-color-dark)",
    error: "var(--tina-color-error)"
  };
  const borderColor = {
    info: "var(--tina-color-primary)",
    success: "var(--tina-color-success)",
    warn: "var(--tina-color-warning)",
    error: "var(--tina-color-error)"
  };
  return import_react117.default.createElement("div", {
    className: `text-center rounded-[5px] bg-gray-50 border border-solid border-gray-100 text-gray-800 fill-blue-500 font-normal cursor-pointer text-[15px] py-2 pr-1 pl-3 transition-all duration-100 ease-out mb-4 flex items-center min-w-[350px] max-w-full `,
    style: {
      pointerEvents: "all",
      animationName: "fly-in-up, fade-in",
      animationTimingFunction: "ease-out",
      animationIterationCount: 1,
      animationFillMode: "both",
      animationDuration: "150ms",
      fill: fillColor[level],
      borderLeft: `6px solid ${borderColor[level]}`
    },
    ...props
  });
};
var CloseAlert = ({ ...styleProps }) => import_react117.default.createElement("button", {
  className: "border-none bg-transparent p-0 ml-[14px] outline-none fill-gray-400 flex items-center",
  ...styleProps
}, import_react117.default.createElement(CloseIcon, {
  className: "w-5 h-5 flex-grow-0 flex-shrink-0 basis-[auto] mr-2"
}));
var MutationSignalContext = React68.createContext(-1);
var MutationSignalProvider = ({ children }) => {
  const observerAreaRef = React68.useRef(null);
  const [signal, setSignal] = React68.useState(0);
  React68.useEffect(() => {
    if (!observerAreaRef)
      return;
    const observer = new MutationObserver(() => setSignal((s20) => s20 + 1));
    observer.observe(observerAreaRef.current, {
      childList: true,
      subtree: true,
      characterData: true
    });
    return () => observer.disconnect();
  }, []);
  return React68.createElement(MutationSignalContext.Provider, {
    value: signal
  }, React68.createElement("div", {
    ref: observerAreaRef
  }, children));
};
var useFieldReference = (fieldName) => {
  const signal = React68.useContext(MutationSignalContext);
  const [ele, setEle] = React68.useState(null);
  React68.useEffect(() => {
    let doc;
    const iframe = document.getElementById("tina-iframe");
    if (iframe) {
      doc = iframe.contentDocument;
    } else {
      doc = document;
    }
    const fieldEle = doc.querySelector(`[data-tinafield="${fieldName}"]`);
    if (!fieldEle) {
      if (fieldName == null ? void 0 : fieldName.includes("#")) {
        const fieldNameWithoutFormId = fieldName.split("#")[1];
        const fieldEle2 = doc.querySelector(`[data-tinafield="${fieldNameWithoutFormId}"]`);
        setEle(fieldEle2);
      }
    } else {
      setEle(fieldEle);
    }
  }, [signal, fieldName]);
  return ele;
};
var IndicatorWrap = ({ style: style2 = {}, position: position3, ...props }) => React68.createElement("div", {
  className: "fixed left-0 py-2 px-0 text-center",
  style: {
    ...style2,
    marginLeft: "var(--tina-sidebar-width)",
    width: "calc(100% - var(--tina-sidebar-width))",
    top: position3 === "top" ? 0 : "auto",
    bottom: position3 === "top" ? "auto" : 0,
    zIndex: "var(--tina-z-index-3)"
  },
  ...props
});
var ArrowWrap = (props) => React68.createElement("div", {
  className: "inline-block fill-white rounded-[50%] bg-blue-500 shadow-md",
  ...props
});
var AboveViewportIndicator = () => {
  return React68.createElement(IndicatorWrap, {
    position: "top"
  }, React68.createElement(ArrowWrap, null, React68.createElement(ChevronUpIcon, {
    className: "w-8 h-auto"
  })));
};
var BelowViewportIndicator = () => {
  return React68.createElement(IndicatorWrap, {
    position: "bottom"
  }, React68.createElement(ArrowWrap, null, React68.createElement(ChevronDownIcon$2, {
    className: "w-8 h-auto"
  })));
};
var useScrollToFocusedField = () => {
  const { subscribe } = useEvent2("field:focus");
  React68.useEffect(() => subscribe(({ fieldName }) => {
    const ele = document.querySelector(`[data-tinafield="${fieldName}"]`);
    if (!ele)
      return;
    const { top, height } = ele.getBoundingClientRect();
    const eleTopY = top + window.scrollY;
    const eleBottomY = top + height + window.scrollY;
    const viewportTopY = window.scrollY;
    const viewportBottomY = window.innerHeight + window.scrollY;
    if (height < window.innerHeight) {
      if (eleBottomY > viewportBottomY) {
        window.scrollTo({
          top: eleBottomY - window.innerHeight,
          behavior: "smooth"
        });
      } else if (eleTopY < viewportTopY) {
        window.scrollTo({
          top: eleTopY,
          behavior: "smooth"
        });
      }
    } else {
      if (eleBottomY < viewportBottomY) {
        window.scrollTo({
          top: eleBottomY - window.innerHeight,
          behavior: "smooth"
        });
      } else if (eleTopY > viewportTopY) {
        window.scrollTo({
          top: eleTopY,
          behavior: "smooth"
        });
      }
    }
  }));
};
var ActiveFieldIndicator = () => {
  const [activeFieldName, setActiveFieldName] = React68.useState(null);
  const [display, setDisplay] = React68.useState(false);
  const [position3, setPosition] = React68.useState(false);
  const [iframePosition, setIframePosition] = React68.useState({ left: 0 });
  const activeEle = useFieldReference(activeFieldName);
  React68.useEffect(() => {
    let displayTimeout;
    if (activeEle) {
      setDisplay(true);
      setPosition(activeEle.getBoundingClientRect());
      const iframe = document.getElementById("tina-iframe");
      if (iframe) {
        setIframePosition(iframe.getBoundingClientRect());
      }
    } else {
      displayTimeout = setTimeout(() => {
        setDisplay(false);
      }, 150);
    }
    return () => {
      clearTimeout(displayTimeout);
    };
  }, [activeEle]);
  const [, setArbitraryValue] = React68.useState(0);
  const rerender = () => setArbitraryValue((s20) => s20 + 1);
  React68.useEffect(() => {
    window.addEventListener("scroll", rerender);
    return () => {
      window.removeEventListener("scroll", rerender);
    };
  }, []);
  const { subscribe } = useEvent2("field:hover");
  React68.useEffect(() => subscribe(({ fieldName, id }) => {
    setActiveFieldName(`${id}#${fieldName}`);
  }));
  useScrollToFocusedField();
  if (!display)
    return null;
  const eleTopY = position3.top + window.scrollY;
  const eleBottomY = position3.top + position3.height + window.scrollY;
  const viewportTopY = window.scrollY;
  const viewportBottomY = window.innerHeight + window.scrollY;
  if (eleTopY > viewportBottomY) {
    return React68.createElement(BelowViewportIndicator, null);
  }
  if (eleBottomY < viewportTopY) {
    return React68.createElement(AboveViewportIndicator, null);
  }
  return React68.createElement("div", {
    style: {
      position: "absolute",
      zIndex: "var(--tina-z-index-3)",
      top: position3.top + window.scrollY,
      left: position3.left + window.scrollX + iframePosition.left,
      width: position3.width,
      height: position3.height,
      outline: "2px dashed var(--tina-color-indicator)",
      borderRadius: "var(--tina-radius-small)",
      transition: display ? activeEle ? `opacity 300ms ease-out` : `opacity 150ms ease-in` : `none`,
      opacity: activeEle && display ? 0.8 : 0
    }
  });
};
var styles3 = `:root {
  --tina-color-primary-light: #2296fe;
  --tina-color-primary: #0084ff;
  --tina-color-primary-dark: #0574e4;
  --tina-color-error-light: #eb6337;
  --tina-color-error: #ec4815;
  --tina-color-error-dark: #dc4419;
  --tina-color-warning-light: #f5e06e;
  --tina-color-warning: #e9d050;
  --tina-color-warning-dark: #d3ba38;
  --tina-color-success-light: #57c355;
  --tina-color-success: #3cad3a;
  --tina-color-success-dark: #249a21;
  --tina-color-grey-0: #ffffff;
  --tina-color-grey-1: #f6f6f9;
  --tina-color-grey-2: #edecf3;
  --tina-color-grey-3: #e1ddec;
  --tina-color-grey-4: #b2adbe;
  --tina-color-grey-5: #918c9e;
  --tina-color-grey-6: #716c7f;
  --tina-color-grey-7: #565165;
  --tina-color-grey-8: #433e52;
  --tina-color-grey-9: #363145;
  --tina-color-grey-10: #252336;
  --tina-color-indicator: var(--tina-color-primary);

  --tina-radius-small: 5px;
  --tina-radius-big: 24px;

  --tina-padding-small: 12px;
  --tina-padding-big: 20px;

  --tina-font-size-0: 12px;
  --tina-font-size-1: 13px;
  --tina-font-size-2: 15px;
  --tina-font-size-3: 16px;
  --tina-font-size-4: 18px;
  --tina-font-size-5: 20px;
  --tina-font-size-6: 22px;
  --tina-font-size-7: 26px;
  --tina-font-size-8: 32px;

  --tina-font-family: 'Inter', sans-serif;

  --tina-font-weight-regular: 400;
  --tina-font-weight-bold: 600;

  --tina-shadow-big: 0px 2px 3px rgba(0, 0, 0, 0.05),
    0 4px 12px rgba(0, 0, 0, 0.1);
  --tina-shadow-small: 0px 2px 3px rgba(0, 0, 0, 0.12);

  --tina-timing-short: 85ms;
  --tina-timing-medium: 150ms;
  --tina-timing-long: 250ms;

  --tina-z-index-0: 0;
  --tina-z-index-1: 10;
  --tina-z-index-2: 20;
  --tina-z-index-3: 30;
  --tina-z-index-4: 40;
  --tina-z-index-5: 50;

  --tina-sidebar-width: 340px;
  --tina-sidebar-header-height: 60px;
  --tina-toolbar-height: 62px;
}

@keyframes fly-in-left {
  0% {
    transform: translate3d(100%, 0, 0);
  }

  100% {
    transform: translate3d(0, 0, 0);
  }
}

@keyframes fly-in-up {
  0% {
    transform: translate3d(0, 100%, 0);
  }

  100% {
    transform: translate3d(0, 0, 0);
  }
}

@keyframes fade-in {
  0% {
    opacity: 0;
  }

  100% {
    opacity: 1;
  }
}

@keyframes popup-right {
  0% {
    transform: translate3d(-2rem, 0, 0);
    opacity: 0;
  }

  100% {
    transform: translate3d(0, 0, 0);
    opacity: 1;
  }
}

@keyframes popup-down {
  0% {
    transform: translate3d(0, -2rem, 0);
    opacity: 0;
  }

  100% {
    transform: translate3d(0, 0, 0);
    opacity: 1;
  }
}

.tina-tailwind {
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  -moz-tab-size: 4;
  tab-size: 4;
}

.tina-tailwind *,
  .tina-tailwind ::before,
  .tina-tailwind ::after {
    box-sizing: border-box;
    border-width: 0;
    border-style: solid;
    border-color: transparent;
  }

.tina-tailwind ::before,
  .tina-tailwind ::after {
    --tw-content: '';
  }

.tina-tailwind hr {
    height: 0; /* 1 */
    color: inherit; /* 2 */
    border-top-width: 1px; /* 3 */
  }

.tina-tailwind abbr:where([title]) {
    text-decoration: underline dotted;
  }

.tina-tailwind h1,
  .tina-tailwind h2,
  .tina-tailwind h3,
  .tina-tailwind h4,
  .tina-tailwind h5,
  .tina-tailwind h6 {
    font-size: inherit;
    font-weight: inherit;
  }

.tina-tailwind a {
    color: inherit;
    text-decoration: inherit;
  }

.tina-tailwind b,
  .tina-tailwind strong {
    font-weight: bolder;
  }

.tina-tailwind code,
  .tina-tailwind kbd,
  .tina-tailwind samp,
  .tina-tailwind pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* 1 */
    font-size: 1em; /* 2 */
  }

.tina-tailwind small {
    font-size: 80%;
  }

.tina-tailwind sub,
  .tina-tailwind sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
  }

.tina-tailwind sub {
    bottom: -0.25em;
  }

.tina-tailwind sup {
    top: -0.5em;
  }

.tina-tailwind table {
    text-indent: 0; /* 1 */
    border-color: inherit; /* 2 */
    border-collapse: collapse; /* 3 */
  }

.tina-tailwind button,
  .tina-tailwind input,
  .tina-tailwind optgroup,
  .tina-tailwind select,
  .tina-tailwind textarea {
    font-family: inherit; /* 1 */
    font-size: 100%; /* 1 */
    line-height: inherit; /* 1 */
    color: inherit; /* 1 */
    margin: 0; /* 2 */
    padding: 0; /* 3 */
  }

.tina-tailwind button,
  .tina-tailwind select {
    text-transform: none;
  }

.tina-tailwind button,
  .tina-tailwind [type='button'],
  .tina-tailwind [type='reset'],
  .tina-tailwind [type='submit'] {
    -webkit-appearance: button; /* 1 */
    background-color: transparent; /* 2 */
    background-image: none; /* 2 */
  }

.tina-tailwind :-moz-focusring {
    outline: auto;
  }

.tina-tailwind :-moz-ui-invalid {
    box-shadow: none;
  }

.tina-tailwind progress {
    vertical-align: baseline;
  }

.tina-tailwind ::-webkit-inner-spin-button,
  .tina-tailwind ::-webkit-outer-spin-button {
    height: auto;
  }

.tina-tailwind [type='search'] {
    -webkit-appearance: textfield; /* 1 */
    outline-offset: -2px; /* 2 */
  }

.tina-tailwind ::-webkit-search-decoration {
    -webkit-appearance: none;
  }

.tina-tailwind ::-webkit-file-upload-button {
    -webkit-appearance: button; /* 1 */
    font: inherit; /* 2 */
  }

.tina-tailwind summary {
    display: list-item;
  }

.tina-tailwind blockquote,
  .tina-tailwind dl,
  .tina-tailwind dd,
  .tina-tailwind h1,
  .tina-tailwind h2,
  .tina-tailwind h3,
  .tina-tailwind h4,
  .tina-tailwind h5,
  .tina-tailwind h6,
  .tina-tailwind hr,
  .tina-tailwind figure,
  .tina-tailwind p,
  .tina-tailwind pre {
    margin: 0;
  }

.tina-tailwind fieldset {
    margin: 0;
    padding: 0;
  }

.tina-tailwind legend {
    padding: 0;
  }

.tina-tailwind ol,
  .tina-tailwind ul,
  .tina-tailwind menu {
    list-style: none;
    margin: 0;
    padding: 0;
  }

.tina-tailwind li:before {
    display: none;
  }

.tina-tailwind textarea {
    resize: vertical;
  }

.tina-tailwind input::placeholder,
  .tina-tailwind textarea::placeholder {
    opacity: 1; /* 1 */
    color: #918c9e; /* 2 */
  }

.tina-tailwind button,
  .tina-tailwind [role='button'] {
    cursor: pointer;
  }

.tina-tailwind :disabled {
    cursor: default;
  }

.tina-tailwind img,
  .tina-tailwind svg,
  .tina-tailwind video,
  .tina-tailwind canvas,
  .tina-tailwind audio,
  .tina-tailwind iframe,
  .tina-tailwind embed,
  .tina-tailwind object {
    display: block; /* 1 */
    vertical-align: middle; /* 2 */
  }

.tina-tailwind img,
  .tina-tailwind video {
    max-width: 100%;
    height: auto;
  }

.tina-tailwind [hidden] {
    display: none;
  }

*, ::before, ::after {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(0 132 255 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
}

::backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(0 132 255 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
}

.container {
  width: 100%;
}

@media (min-width: 320px) {

  .container {
    max-width: 320px;
  }
}

@media (min-width: 560px) {

  .container {
    max-width: 560px;
  }
}

@media (min-width: 720px) {

  .container {
    max-width: 720px;
  }
}

@media (min-width: 1030px) {

  .container {
    max-width: 1030px;
  }
}

@media (min-width: 1280px) {

  .container {
    max-width: 1280px;
  }
}

@media (min-width: 1536px) {

  .container {
    max-width: 1536px;
  }
}

.tina-prose {
  color: var(--tw-prose-body);
  max-width: 65ch;
}

.tina-prose :where([class~="lead"]):not(:where([class~="not-tina-prose"] *)) {
  color: var(--tw-prose-lead);
  font-size: 1.25em;
  line-height: 1.6;
  margin-top: 1.2em;
  margin-bottom: 1.2em;
}

.tina-prose :where(a):not(:where([class~="not-tina-prose"] *)) {
  color: var(--tw-prose-links);
  text-decoration: underline;
  font-weight: 500;
}

.tina-prose :where(strong):not(:where([class~="not-tina-prose"] *)) {
  color: var(--tw-prose-bold);
  font-weight: 600;
}

.tina-prose :where(ol):not(:where([class~="not-tina-prose"] *)) {
  list-style-type: decimal;
  padding-left: 1.625em;
}

.tina-prose :where(ol[type="A"]):not(:where([class~="not-tina-prose"] *)) {
  list-style-type: upper-alpha;
}

.tina-prose :where(ol[type="a"]):not(:where([class~="not-tina-prose"] *)) {
  list-style-type: lower-alpha;
}

.tina-prose :where(ol[type="A" s]):not(:where([class~="not-tina-prose"] *)) {
  list-style-type: upper-alpha;
}

.tina-prose :where(ol[type="a" s]):not(:where([class~="not-tina-prose"] *)) {
  list-style-type: lower-alpha;
}

.tina-prose :where(ol[type="I"]):not(:where([class~="not-tina-prose"] *)) {
  list-style-type: upper-roman;
}

.tina-prose :where(ol[type="i"]):not(:where([class~="not-tina-prose"] *)) {
  list-style-type: lower-roman;
}

.tina-prose :where(ol[type="I" s]):not(:where([class~="not-tina-prose"] *)) {
  list-style-type: upper-roman;
}

.tina-prose :where(ol[type="i" s]):not(:where([class~="not-tina-prose"] *)) {
  list-style-type: lower-roman;
}

.tina-prose :where(ol[type="1"]):not(:where([class~="not-tina-prose"] *)) {
  list-style-type: decimal;
}

.tina-prose :where(ul):not(:where([class~="not-tina-prose"] *)) {
  list-style-type: disc;
  padding-left: 1.625em;
}

.tina-prose :where(ol > li):not(:where([class~="not-tina-prose"] *))::marker {
  font-weight: 400;
  color: var(--tw-prose-counters);
}

.tina-prose :where(ul > li):not(:where([class~="not-tina-prose"] *))::marker {
  color: var(--tw-prose-bullets);
}

.tina-prose :where(hr):not(:where([class~="not-tina-prose"] *)) {
  border-color: var(--tw-prose-hr);
  border-top-width: 1px;
  margin-top: 3em;
  margin-bottom: 3em;
}

.tina-prose :where(blockquote):not(:where([class~="not-tina-prose"] *)) {
  font-weight: 500;
  font-style: italic;
  color: var(--tw-prose-quotes);
  border-left-width: 0.25rem;
  border-left-color: var(--tw-prose-quote-borders);
  quotes: "\\201C""\\201D""\\2018""\\2019";
  margin-top: 1.6em;
  margin-bottom: 1.6em;
  padding-left: 1em;
}

.tina-prose :where(blockquote p:first-of-type):not(:where([class~="not-tina-prose"] *))::before {
  content: open-quote;
}

.tina-prose :where(blockquote p:last-of-type):not(:where([class~="not-tina-prose"] *))::after {
  content: close-quote;
}

.tina-prose :where(h1):not(:where([class~="not-tina-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 800;
  font-size: 2.25em;
  margin-top: 0;
  margin-bottom: 0.8888889em;
  line-height: 1.1111111;
}

.tina-prose :where(h1 strong):not(:where([class~="not-tina-prose"] *)) {
  font-weight: 900;
}

.tina-prose :where(h2):not(:where([class~="not-tina-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 700;
  font-size: 1.5em;
  margin-top: 2em;
  margin-bottom: 1em;
  line-height: 1.3333333;
}

.tina-prose :where(h2 strong):not(:where([class~="not-tina-prose"] *)) {
  font-weight: 800;
}

.tina-prose :where(h3):not(:where([class~="not-tina-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 600;
  font-size: 1.25em;
  margin-top: 1.6em;
  margin-bottom: 0.6em;
  line-height: 1.6;
}

.tina-prose :where(h3 strong):not(:where([class~="not-tina-prose"] *)) {
  font-weight: 700;
}

.tina-prose :where(h4):not(:where([class~="not-tina-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 600;
  margin-top: 1.5em;
  margin-bottom: 0.5em;
  line-height: 1.5;
}

.tina-prose :where(h4 strong):not(:where([class~="not-tina-prose"] *)) {
  font-weight: 700;
}

.tina-prose :where(figure > *):not(:where([class~="not-tina-prose"] *)) {
  margin-top: 0;
  margin-bottom: 0;
}

.tina-prose :where(figcaption):not(:where([class~="not-tina-prose"] *)) {
  color: var(--tw-prose-captions);
  font-size: 0.875em;
  line-height: 1.4285714;
  margin-top: 0.8571429em;
}

.tina-prose :where(code):not(:where([class~="not-tina-prose"] *)) {
  color: var(--tw-prose-code);
  font-weight: 600;
  font-size: 0.875em;
}

.tina-prose :where(code):not(:where([class~="not-tina-prose"] *))::before {
  content: "\`";
}

.tina-prose :where(code):not(:where([class~="not-tina-prose"] *))::after {
  content: "\`";
}

.tina-prose :where(a code):not(:where([class~="not-tina-prose"] *)) {
  color: var(--tw-prose-links);
}

.tina-prose :where(pre):not(:where([class~="not-tina-prose"] *)) {
  color: var(--tw-prose-pre-code);
  background-color: var(--tw-prose-pre-bg);
  overflow-x: auto;
  font-weight: 400;
  font-size: 0.875em;
  line-height: 1.7142857;
  margin-top: 1.7142857em;
  margin-bottom: 1.7142857em;
  border-radius: 0.375rem;
  padding-top: 0.8571429em;
  padding-right: 1.1428571em;
  padding-bottom: 0.8571429em;
  padding-left: 1.1428571em;
}

.tina-prose :where(pre code):not(:where([class~="not-tina-prose"] *)) {
  background-color: transparent;
  border-width: 0;
  border-radius: 0;
  padding: 0;
  font-weight: inherit;
  color: inherit;
  font-size: inherit;
  font-family: inherit;
  line-height: inherit;
}

.tina-prose :where(pre code):not(:where([class~="not-tina-prose"] *))::before {
  content: none;
}

.tina-prose :where(pre code):not(:where([class~="not-tina-prose"] *))::after {
  content: none;
}

.tina-prose :where(table):not(:where([class~="not-tina-prose"] *)) {
  width: 100%;
  table-layout: auto;
  text-align: left;
  margin-top: 2em;
  margin-bottom: 2em;
  font-size: 0.875em;
  line-height: 1.7142857;
}

.tina-prose :where(thead):not(:where([class~="not-tina-prose"] *)) {
  border-bottom-width: 1px;
  border-bottom-color: var(--tw-prose-th-borders);
}

.tina-prose :where(thead th):not(:where([class~="not-tina-prose"] *)) {
  color: var(--tw-prose-headings);
  font-weight: 600;
  vertical-align: bottom;
  padding-right: 0.5714286em;
  padding-bottom: 0.5714286em;
  padding-left: 0.5714286em;
}

.tina-prose :where(tbody tr):not(:where([class~="not-tina-prose"] *)) {
  border-bottom-width: 1px;
  border-bottom-color: var(--tw-prose-td-borders);
}

.tina-prose :where(tbody tr:last-child):not(:where([class~="not-tina-prose"] *)) {
  border-bottom-width: 0;
}

.tina-prose :where(tbody td):not(:where([class~="not-tina-prose"] *)) {
  vertical-align: baseline;
  padding-top: 0.5714286em;
  padding-right: 0.5714286em;
  padding-bottom: 0.5714286em;
  padding-left: 0.5714286em;
}

.tina-prose {
  --tw-prose-body: #374151;
  --tw-prose-headings: #111827;
  --tw-prose-lead: #4b5563;
  --tw-prose-links: #111827;
  --tw-prose-bold: #111827;
  --tw-prose-counters: #6b7280;
  --tw-prose-bullets: #d1d5db;
  --tw-prose-hr: #e5e7eb;
  --tw-prose-quotes: #111827;
  --tw-prose-quote-borders: #e5e7eb;
  --tw-prose-captions: #6b7280;
  --tw-prose-code: #111827;
  --tw-prose-pre-code: #e5e7eb;
  --tw-prose-pre-bg: #1f2937;
  --tw-prose-th-borders: #d1d5db;
  --tw-prose-td-borders: #e5e7eb;
  --tw-prose-invert-body: #d1d5db;
  --tw-prose-invert-headings: #fff;
  --tw-prose-invert-lead: #9ca3af;
  --tw-prose-invert-links: #fff;
  --tw-prose-invert-bold: #fff;
  --tw-prose-invert-counters: #9ca3af;
  --tw-prose-invert-bullets: #4b5563;
  --tw-prose-invert-hr: #374151;
  --tw-prose-invert-quotes: #f3f4f6;
  --tw-prose-invert-quote-borders: #374151;
  --tw-prose-invert-captions: #9ca3af;
  --tw-prose-invert-code: #fff;
  --tw-prose-invert-pre-code: #d1d5db;
  --tw-prose-invert-pre-bg: rgb(0 0 0 / 50%);
  --tw-prose-invert-th-borders: #4b5563;
  --tw-prose-invert-td-borders: #374151;
  font-size: 1rem;
  line-height: 1.75;
}

.tina-prose :where(p):not(:where([class~="not-tina-prose"] *)) {
  margin-top: 1.25em;
  margin-bottom: 1.25em;
}

.tina-prose :where(img):not(:where([class~="not-tina-prose"] *)) {
  margin-top: 2em;
  margin-bottom: 2em;
}

.tina-prose :where(video):not(:where([class~="not-tina-prose"] *)) {
  margin-top: 2em;
  margin-bottom: 2em;
}

.tina-prose :where(figure):not(:where([class~="not-tina-prose"] *)) {
  margin-top: 2em;
  margin-bottom: 2em;
}

.tina-prose :where(h2 code):not(:where([class~="not-tina-prose"] *)) {
  font-size: 0.875em;
}

.tina-prose :where(h3 code):not(:where([class~="not-tina-prose"] *)) {
  font-size: 0.9em;
}

.tina-prose :where(li):not(:where([class~="not-tina-prose"] *)) {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

.tina-prose :where(ol > li):not(:where([class~="not-tina-prose"] *)) {
  padding-left: 0.375em;
}

.tina-prose :where(ul > li):not(:where([class~="not-tina-prose"] *)) {
  padding-left: 0.375em;
}

.tina-prose > :where(ul > li p):not(:where([class~="not-tina-prose"] *)) {
  margin-top: 0.75em;
  margin-bottom: 0.75em;
}

.tina-prose > :where(ul > li > *:first-child):not(:where([class~="not-tina-prose"] *)) {
  margin-top: 1.25em;
}

.tina-prose > :where(ul > li > *:last-child):not(:where([class~="not-tina-prose"] *)) {
  margin-bottom: 1.25em;
}

.tina-prose > :where(ol > li > *:first-child):not(:where([class~="not-tina-prose"] *)) {
  margin-top: 1.25em;
}

.tina-prose > :where(ol > li > *:last-child):not(:where([class~="not-tina-prose"] *)) {
  margin-bottom: 1.25em;
}

.tina-prose :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~="not-tina-prose"] *)) {
  margin-top: 0.75em;
  margin-bottom: 0.75em;
}

.tina-prose :where(hr + *):not(:where([class~="not-tina-prose"] *)) {
  margin-top: 0;
}

.tina-prose :where(h2 + *):not(:where([class~="not-tina-prose"] *)) {
  margin-top: 0;
}

.tina-prose :where(h3 + *):not(:where([class~="not-tina-prose"] *)) {
  margin-top: 0;
}

.tina-prose :where(h4 + *):not(:where([class~="not-tina-prose"] *)) {
  margin-top: 0;
}

.tina-prose :where(thead th:first-child):not(:where([class~="not-tina-prose"] *)) {
  padding-left: 0;
}

.tina-prose :where(thead th:last-child):not(:where([class~="not-tina-prose"] *)) {
  padding-right: 0;
}

.tina-prose :where(tbody td:first-child):not(:where([class~="not-tina-prose"] *)) {
  padding-left: 0;
}

.tina-prose :where(tbody td:last-child):not(:where([class~="not-tina-prose"] *)) {
  padding-right: 0;
}

.tina-prose > :where(:first-child):not(:where([class~="not-tina-prose"] *)) {
  margin-top: 0;
}

.tina-prose > :where(:last-child):not(:where([class~="not-tina-prose"] *)) {
  margin-bottom: 0;
}

.tina-tailwind .sr-only {
  position: absolute;
  width: 1px;
  height: 1px;
  padding: 0;
  margin: -1px;
  overflow: hidden;
  clip: rect(0, 0, 0, 0);
  white-space: nowrap;
  border-width: 0;
}

.tina-tailwind .pointer-events-none {
  pointer-events: none;
}

.tina-tailwind .pointer-events-auto {
  pointer-events: auto;
}

.tina-tailwind .visible {
  visibility: visible;
}

.tina-tailwind .static {
  position: static;
}

.tina-tailwind .fixed {
  position: fixed;
}

.tina-tailwind .absolute {
  position: absolute;
}

.tina-tailwind .relative {
  position: relative;
}

.tina-tailwind .sticky {
  position: sticky;
}

.tina-tailwind .inset-0 {
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;
}

.tina-tailwind .inset-y-0 {
  top: 0px;
  bottom: 0px;
}

.tina-tailwind .-bottom-0 {
  bottom: -0px;
}

.tina-tailwind .-bottom-0\\.5 {
  bottom: -2px;
}

.tina-tailwind .-bottom-1 {
  bottom: -4px;
}

.tina-tailwind .-left-0 {
  left: -0px;
}

.tina-tailwind .-left-0\\.5 {
  left: -2px;
}

.tina-tailwind .-right-0 {
  right: -0px;
}

.tina-tailwind .-right-0\\.5 {
  right: -2px;
}

.tina-tailwind .-right-3 {
  right: -12px;
}

.tina-tailwind .-top-0 {
  top: -0px;
}

.tina-tailwind .-top-0\\.5 {
  top: -2px;
}

.tina-tailwind .-top-2 {
  top: -8px;
}

.tina-tailwind .-top-4 {
  top: -16px;
}

.tina-tailwind .bottom-0 {
  bottom: 0px;
}

.tina-tailwind .bottom-3 {
  bottom: 12px;
}

.tina-tailwind .bottom-5 {
  bottom: 20px;
}

.tina-tailwind .left-0 {
  left: 0px;
}

.tina-tailwind .left-0\\.5 {
  left: 2px;
}

.tina-tailwind .left-1\\/2 {
  left: 50%;
}

.tina-tailwind .left-5 {
  left: 20px;
}

.tina-tailwind .right-0 {
  right: 0px;
}

.tina-tailwind .right-2 {
  right: 8px;
}

.tina-tailwind .right-2\\.5 {
  right: 10px;
}

.tina-tailwind .right-3 {
  right: 12px;
}

.tina-tailwind .right-5 {
  right: 20px;
}

.tina-tailwind .right-px {
  right: 1px;
}

.tina-tailwind .top-0 {
  top: 0px;
}

.tina-tailwind .top-1\\/2 {
  top: 50%;
}

.tina-tailwind .top-8 {
  top: 32px;
}

.tina-tailwind .-z-1 {
  z-index: -1;
}

.tina-tailwind .z-0 {
  z-index: 0;
}

.tina-tailwind .z-10 {
  z-index: 10;
}

.tina-tailwind .z-100 {
  z-index: 100;
}

.tina-tailwind .z-20 {
  z-index: 20;
}

.tina-tailwind .z-30 {
  z-index: 30;
}

.tina-tailwind .z-40 {
  z-index: 40;
}

.tina-tailwind .z-50 {
  z-index: 50;
}

.tina-tailwind .z-\\[999999\\] {
  z-index: 999999;
}

.tina-tailwind .z-base {
  z-index: 9000;
}

.tina-tailwind .z-menu {
  z-index: 9800;
}

.tina-tailwind .z-modal {
  z-index: 10800;
}

.tina-tailwind .z-overlay {
  z-index: 10600;
}

.tina-tailwind .z-panel {
  z-index: 9400;
}

.tina-tailwind .m-0 {
  margin: 0px;
}

.tina-tailwind .-mx-0 {
  margin-left: -0px;
  margin-right: -0px;
}

.tina-tailwind .-mx-0\\.5 {
  margin-left: -2px;
  margin-right: -2px;
}

.tina-tailwind .-mx-1 {
  margin-left: -4px;
  margin-right: -4px;
}

.tina-tailwind .mx-auto {
  margin-left: auto;
  margin-right: auto;
}

.tina-tailwind .my-0 {
  margin-top: 0px;
  margin-bottom: 0px;
}

.tina-tailwind .my-10 {
  margin-top: 40px;
  margin-bottom: 40px;
}

.tina-tailwind .my-2 {
  margin-top: 8px;
  margin-bottom: 8px;
}

.tina-tailwind .my-4 {
  margin-top: 16px;
  margin-bottom: 16px;
}

.tina-tailwind .-mb-14 {
  margin-bottom: -56px;
}

.tina-tailwind .-mb-px {
  margin-bottom: -1px;
}

.tina-tailwind .-ml-0 {
  margin-left: -0px;
}

.tina-tailwind .-ml-0\\.5 {
  margin-left: -2px;
}

.tina-tailwind .-ml-1 {
  margin-left: -4px;
}

.tina-tailwind .-ml-px {
  margin-left: -1px;
}

.tina-tailwind .-mr-0 {
  margin-right: -0px;
}

.tina-tailwind .-mr-0\\.5 {
  margin-right: -2px;
}

.tina-tailwind .-mr-1 {
  margin-right: -4px;
}

.tina-tailwind .-mr-4 {
  margin-right: -16px;
}

.tina-tailwind .-mr-px {
  margin-right: -1px;
}

.tina-tailwind .-mt-0 {
  margin-top: -0px;
}

.tina-tailwind .-mt-0\\.5 {
  margin-top: -2px;
}

.tina-tailwind .-mt-2 {
  margin-top: -8px;
}

.tina-tailwind .-mt-px {
  margin-top: -1px;
}

.tina-tailwind .mb-0 {
  margin-bottom: 0px;
}

.tina-tailwind .mb-1 {
  margin-bottom: 4px;
}

.tina-tailwind .mb-2 {
  margin-bottom: 8px;
}

.tina-tailwind .mb-3 {
  margin-bottom: 12px;
}

.tina-tailwind .mb-4 {
  margin-bottom: 16px;
}

.tina-tailwind .mb-5 {
  margin-bottom: 20px;
}

.tina-tailwind .mb-6 {
  margin-bottom: 24px;
}

.tina-tailwind .mb-\\[6px\\] {
  margin-bottom: 6px;
}

.tina-tailwind .ml-1 {
  margin-left: 4px;
}

.tina-tailwind .ml-1\\.5 {
  margin-left: 6px;
}

.tina-tailwind .ml-2 {
  margin-left: 8px;
}

.tina-tailwind .ml-3 {
  margin-left: 12px;
}

.tina-tailwind .ml-\\[14px\\] {
  margin-left: 14px;
}

.tina-tailwind .mr-0 {
  margin-right: 0px;
}

.tina-tailwind .mr-0\\.5 {
  margin-right: 2px;
}

.tina-tailwind .mr-1 {
  margin-right: 4px;
}

.tina-tailwind .mr-1\\.5 {
  margin-right: 6px;
}

.tina-tailwind .mr-2 {
  margin-right: 8px;
}

.tina-tailwind .mr-3 {
  margin-right: 12px;
}

.tina-tailwind .mt-0 {
  margin-top: 0px;
}

.tina-tailwind .mt-0\\.5 {
  margin-top: 2px;
}

.tina-tailwind .mt-1 {
  margin-top: 4px;
}

.tina-tailwind .mt-2 {
  margin-top: 8px;
}

.tina-tailwind .mt-3 {
  margin-top: 12px;
}

.tina-tailwind .mt-4 {
  margin-top: 16px;
}

.tina-tailwind .mt-5 {
  margin-top: 20px;
}

.tina-tailwind .mt-6 {
  margin-top: 24px;
}

.tina-tailwind .mt-8 {
  margin-top: 32px;
}

.tina-tailwind .block {
  display: block;
}

.tina-tailwind .inline-block {
  display: inline-block;
}

.tina-tailwind .inline {
  display: inline;
}

.tina-tailwind .flex {
  display: flex;
}

.tina-tailwind .inline-flex {
  display: inline-flex;
}

.tina-tailwind .table {
  display: table;
}

.tina-tailwind .grid {
  display: grid;
}

.tina-tailwind .contents {
  display: contents;
}

.tina-tailwind .\\!hidden {
  display: none !important;
}

.tina-tailwind .hidden {
  display: none;
}

.tina-tailwind .h-0 {
  height: 0px;
}

.tina-tailwind .h-10 {
  height: 40px;
}

.tina-tailwind .h-14 {
  height: 56px;
}

.tina-tailwind .h-16 {
  height: 64px;
}

.tina-tailwind .h-20 {
  height: 80px;
}

.tina-tailwind .h-3 {
  height: 12px;
}

.tina-tailwind .h-3\\/4 {
  height: 75%;
}

.tina-tailwind .h-32 {
  height: 128px;
}

.tina-tailwind .h-4 {
  height: 16px;
}

.tina-tailwind .h-4\\/6 {
  height: 66.666667%;
}

.tina-tailwind .h-5 {
  height: 20px;
}

.tina-tailwind .h-6 {
  height: 24px;
}

.tina-tailwind .h-7 {
  height: 28px;
}

.tina-tailwind .h-8 {
  height: 32px;
}

.tina-tailwind .h-9 {
  height: 36px;
}

.tina-tailwind .h-\\[17px\\] {
  height: 17px;
}

.tina-tailwind .h-\\[18px\\] {
  height: 18px;
}

.tina-tailwind .h-\\[19px\\] {
  height: 19px;
}

.tina-tailwind .h-\\[22px\\] {
  height: 22px;
}

.tina-tailwind .h-auto {
  height: auto;
}

.tina-tailwind .h-full {
  height: 100%;
}

.tina-tailwind .h-screen {
  height: 100vh;
}

.tina-tailwind .max-h-48 {
  max-height: 192px;
}

.tina-tailwind .max-h-\\[10rem\\] {
  max-height: 10rem;
}

.tina-tailwind .max-h-\\[200px\\] {
  max-height: 200px;
}

.tina-tailwind .max-h-\\[24rem\\] {
  max-height: 24rem;
}

.tina-tailwind .max-h-\\[300px\\] {
  max-height: 300px;
}

.tina-tailwind .max-h-\\[75\\%\\] {
  max-height: 75%;
}

.tina-tailwind .max-h-\\[initial\\] {
  max-height: initial;
}

.tina-tailwind .max-h-full {
  max-height: 100%;
}

.tina-tailwind .min-h-\\[100px\\] {
  min-height: 100px;
}

.tina-tailwind .min-h-\\[160px\\] {
  min-height: 160px;
}

.tina-tailwind .min-h-\\[2\\.5rem\\] {
  min-height: 2.5rem;
}

.tina-tailwind .min-h-\\[96px\\] {
  min-height: 96px;
}

.tina-tailwind .w-0 {
  width: 0px;
}

.tina-tailwind .w-10 {
  width: 40px;
}

.tina-tailwind .w-12 {
  width: 48px;
}

.tina-tailwind .w-14 {
  width: 56px;
}

.tina-tailwind .w-2 {
  width: 8px;
}

.tina-tailwind .w-20 {
  width: 80px;
}

.tina-tailwind .w-3 {
  width: 12px;
}

.tina-tailwind .w-3\\/5 {
  width: 60%;
}

.tina-tailwind .w-32 {
  width: 128px;
}

.tina-tailwind .w-4 {
  width: 16px;
}

.tina-tailwind .w-48 {
  width: 192px;
}

.tina-tailwind .w-5 {
  width: 20px;
}

.tina-tailwind .w-5\\/6 {
  width: 83.333333%;
}

.tina-tailwind .w-56 {
  width: 224px;
}

.tina-tailwind .w-6 {
  width: 24px;
}

.tina-tailwind .w-7 {
  width: 28px;
}

.tina-tailwind .w-8 {
  width: 32px;
}

.tina-tailwind .w-9 {
  width: 36px;
}

.tina-tailwind .w-96 {
  width: 384px;
}

.tina-tailwind .w-\\[0px\\] {
  width: 0px;
}

.tina-tailwind .w-\\[17px\\] {
  width: 17px;
}

.tina-tailwind .w-\\[18px\\] {
  width: 18px;
}

.tina-tailwind .w-\\[19px\\] {
  width: 19px;
}

.tina-tailwind .w-\\[22px\\] {
  width: 22px;
}

.tina-tailwind .w-\\[30\\%\\] {
  width: 30%;
}

.tina-tailwind .w-\\[300px\\] {
  width: 300px;
}

.tina-tailwind .w-\\[35\\%\\] {
  width: 35%;
}

.tina-tailwind .w-\\[460px\\] {
  width: 460px;
}

.tina-tailwind .w-\\[48px\\] {
  width: 48px;
}

.tina-tailwind .w-auto {
  width: auto;
}

.tina-tailwind .w-full {
  width: 100%;
}

.tina-tailwind .w-px {
  width: 1px;
}

.tina-tailwind .w-screen {
  width: 100vw;
}

.tina-tailwind .min-w-0 {
  min-width: 0px;
}

.tina-tailwind .min-w-\\[192px\\] {
  min-width: 192px;
}

.tina-tailwind .min-w-\\[200px\\] {
  min-width: 200px;
}

.tina-tailwind .min-w-\\[240px\\] {
  min-width: 240px;
}

.tina-tailwind .min-w-\\[350px\\] {
  min-width: 350px;
}

.tina-tailwind .min-w-\\[5rem\\] {
  min-width: 5rem;
}

.tina-tailwind .max-w-\\[1500px\\] {
  max-width: 1500px;
}

.tina-tailwind .max-w-\\[40\\%\\] {
  max-width: 40%;
}

.tina-tailwind .max-w-\\[400px\\] {
  max-width: 400px;
}

.tina-tailwind .max-w-\\[560px\\] {
  max-width: 560px;
}

.tina-tailwind .max-w-\\[680px\\] {
  max-width: 680px;
}

.tina-tailwind .max-w-\\[90\\%\\] {
  max-width: 90%;
}

.tina-tailwind .max-w-form {
  max-width: 900px;
}

.tina-tailwind .max-w-full {
  max-width: 100%;
}

.tina-tailwind .max-w-prose {
  max-width: 65ch;
}

.tina-tailwind .max-w-screen-xl {
  max-width: 1280px;
}

.tina-tailwind .max-w-xl {
  max-width: 36rem;
}

.tina-tailwind .flex-1 {
  flex: 1 1 0%;
}

.tina-tailwind .flex-none {
  flex: none;
}

.tina-tailwind .flex-shrink-0 {
  flex-shrink: 0;
}

.tina-tailwind .shrink {
  flex-shrink: 1;
}

.tina-tailwind .shrink-0 {
  flex-shrink: 0;
}

.tina-tailwind .flex-grow {
  flex-grow: 1;
}

.tina-tailwind .flex-grow-0 {
  flex-grow: 0;
}

.tina-tailwind .grow {
  flex-grow: 1;
}

.tina-tailwind .grow-0 {
  flex-grow: 0;
}

.tina-tailwind .basis-\\[auto\\] {
  flex-basis: auto;
}

.tina-tailwind .origin-bottom-right {
  transform-origin: bottom right;
}

.tina-tailwind .origin-center {
  transform-origin: center;
}

.tina-tailwind .origin-left {
  transform-origin: left;
}

.tina-tailwind .origin-top-left {
  transform-origin: top left;
}

.tina-tailwind .origin-top-right {
  transform-origin: top right;
}

.tina-tailwind .-translate-x-1\\/2 {
  --tw-translate-x: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .-translate-x-full {
  --tw-translate-x: -100%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .-translate-y-1\\/2 {
  --tw-translate-y: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .-translate-y-2 {
  --tw-translate-y: -8px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .translate-x-0 {
  --tw-translate-x: 0px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .translate-x-8 {
  --tw-translate-x: 32px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .translate-x-full {
  --tw-translate-x: 100%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .translate-y-0 {
  --tw-translate-y: 0px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .translate-y-1 {
  --tw-translate-y: 4px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .translate-y-full {
  --tw-translate-y: 100%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .-rotate-90 {
  --tw-rotate: -90deg;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .rotate-45 {
  --tw-rotate: 45deg;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .scale-100 {
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .scale-110 {
  --tw-scale-x: 1.1;
  --tw-scale-y: 1.1;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .scale-90 {
  --tw-scale-x: .9;
  --tw-scale-y: .9;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .scale-95 {
  --tw-scale-x: .95;
  --tw-scale-y: .95;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .transform {
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

@keyframes slideIn {

  0% {
    opacity: 0;
    transform: translateY(-1rem);
  }

  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

.tina-tailwind .animate-slide-in {
  animation: slideIn 150ms ease-out 1 normal forwards;
}

@keyframes spin {

  to {
    transform: rotate(360deg);
  }
}

.tina-tailwind .animate-spin {
  animation: spin 1s linear infinite;
}

.tina-tailwind .cursor-\\[grab\\] {
  cursor: grab;
}

.tina-tailwind .cursor-default {
  cursor: default;
}

.tina-tailwind .cursor-not-allowed {
  cursor: not-allowed;
}

.tina-tailwind .cursor-pointer {
  cursor: pointer;
}

.tina-tailwind .cursor-wait {
  cursor: wait;
}

.tina-tailwind .select-none {
  user-select: none;
}

.tina-tailwind .resize-y {
  resize: vertical;
}

.tina-tailwind .resize {
  resize: both;
}

.tina-tailwind .list-inside {
  list-style-position: inside;
}

.tina-tailwind .list-outside {
  list-style-position: outside;
}

.tina-tailwind .list-decimal {
  list-style-type: decimal;
}

.tina-tailwind .list-disc {
  list-style-type: disc;
}

.tina-tailwind .appearance-none {
  appearance: none;
}

.tina-tailwind .auto-rows-auto {
  grid-auto-rows: auto;
}

.tina-tailwind .grid-cols-1 {
  grid-template-columns: repeat(1, minmax(0, 1fr));
}

.tina-tailwind .flex-col {
  flex-direction: column;
}

.tina-tailwind .flex-wrap {
  flex-wrap: wrap;
}

.tina-tailwind .flex-nowrap {
  flex-wrap: nowrap;
}

.tina-tailwind .content-start {
  align-content: flex-start;
}

.tina-tailwind .items-start {
  align-items: flex-start;
}

.tina-tailwind .items-center {
  align-items: center;
}

.tina-tailwind .items-stretch {
  align-items: stretch;
}

.tina-tailwind .justify-start {
  justify-content: flex-start;
}

.tina-tailwind .justify-end {
  justify-content: flex-end;
}

.tina-tailwind .justify-center {
  justify-content: center;
}

.tina-tailwind .justify-between {
  justify-content: space-between;
}

.tina-tailwind .justify-items-start {
  justify-items: start;
}

.tina-tailwind .gap-0 {
  gap: 0px;
}

.tina-tailwind .gap-0\\.5 {
  gap: 2px;
}

.tina-tailwind .gap-1 {
  gap: 4px;
}

.tina-tailwind .gap-1\\.5 {
  gap: 6px;
}

.tina-tailwind .gap-2 {
  gap: 8px;
}

.tina-tailwind .gap-3 {
  gap: 12px;
}

.tina-tailwind .gap-4 {
  gap: 16px;
}

.tina-tailwind .gap-x-3 {
  column-gap: 12px;
}

.tina-tailwind .gap-x-4 {
  column-gap: 16px;
}

.tina-tailwind .gap-x-6 {
  column-gap: 24px;
}

.tina-tailwind .gap-y-1 {
  row-gap: 4px;
}

.tina-tailwind .gap-y-3 {
  row-gap: 12px;
}

.tina-tailwind .space-x-1 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-x-reverse: 0;
  margin-right: calc(4px * var(--tw-space-x-reverse));
  margin-left: calc(4px * calc(1 - var(--tw-space-x-reverse)));
}

.tina-tailwind .space-y-4 > :not([hidden]) ~ :not([hidden]) {
  --tw-space-y-reverse: 0;
  margin-top: calc(16px * calc(1 - var(--tw-space-y-reverse)));
  margin-bottom: calc(16px * var(--tw-space-y-reverse));
}

.tina-tailwind .divide-x > :not([hidden]) ~ :not([hidden]) {
  --tw-divide-x-reverse: 0;
  border-right-width: calc(1px * var(--tw-divide-x-reverse));
  border-left-width: calc(1px * calc(1 - var(--tw-divide-x-reverse)));
}

.tina-tailwind .divide-y > :not([hidden]) ~ :not([hidden]) {
  --tw-divide-y-reverse: 0;
  border-top-width: calc(1px * calc(1 - var(--tw-divide-y-reverse)));
  border-bottom-width: calc(1px * var(--tw-divide-y-reverse));
}

.tina-tailwind .divide-gray-100 > :not([hidden]) ~ :not([hidden]) {
  --tw-divide-opacity: 1;
  border-color: rgb(237 236 243 / var(--tw-divide-opacity));
}

.tina-tailwind .divide-gray-150 > :not([hidden]) ~ :not([hidden]) {
  --tw-divide-opacity: 1;
  border-color: rgb(230 227 239 / var(--tw-divide-opacity));
}

.tina-tailwind .self-end {
  align-self: flex-end;
}

.tina-tailwind .self-stretch {
  align-self: stretch;
}

.tina-tailwind .overflow-auto {
  overflow: auto;
}

.tina-tailwind .overflow-hidden {
  overflow: hidden;
}

.tina-tailwind .overflow-visible {
  overflow: visible;
}

.tina-tailwind .overflow-scroll {
  overflow: scroll;
}

.tina-tailwind .overflow-y-auto {
  overflow-y: auto;
}

.tina-tailwind .overflow-x-visible {
  overflow-x: visible;
}

.tina-tailwind .truncate {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}

.tina-tailwind .text-ellipsis {
  text-overflow: ellipsis;
}

.tina-tailwind .whitespace-normal {
  white-space: normal;
}

.tina-tailwind .whitespace-nowrap {
  white-space: nowrap;
}

.tina-tailwind .whitespace-pre-wrap {
  white-space: pre-wrap;
}

.tina-tailwind .break-words {
  overflow-wrap: break-word;
}

.tina-tailwind .break-all {
  word-break: break-all;
}

.tina-tailwind .rounded {
  border-radius: 4px;
}

.tina-tailwind .rounded-3xl {
  border-radius: 24px;
}

.tina-tailwind .rounded-\\[50\\%\\] {
  border-radius: 50%;
}

.tina-tailwind .rounded-\\[5px\\] {
  border-radius: 5px;
}

.tina-tailwind .rounded-full {
  border-radius: 9999px;
}

.tina-tailwind .rounded-lg {
  border-radius: 8px;
}

.tina-tailwind .rounded-md {
  border-radius: 6px;
}

.tina-tailwind .rounded-none {
  border-radius: 0px;
}

.tina-tailwind .rounded-sm {
  border-radius: 2px;
}

.tina-tailwind .rounded-b-md {
  border-bottom-right-radius: 6px;
  border-bottom-left-radius: 6px;
}

.tina-tailwind .rounded-l-full {
  border-top-left-radius: 9999px;
  border-bottom-left-radius: 9999px;
}

.tina-tailwind .rounded-l-md {
  border-top-left-radius: 6px;
  border-bottom-left-radius: 6px;
}

.tina-tailwind .rounded-r-full {
  border-top-right-radius: 9999px;
  border-bottom-right-radius: 9999px;
}

.tina-tailwind .rounded-r-md {
  border-top-right-radius: 6px;
  border-bottom-right-radius: 6px;
}

.tina-tailwind .border {
  border-width: 1px;
}

.tina-tailwind .border-0 {
  border-width: 0;
}

.tina-tailwind .border-2 {
  border-width: 2px;
}

.tina-tailwind .border-b {
  border-bottom-width: 1px;
}

.tina-tailwind .border-b-\\[1px\\] {
  border-bottom-width: 1px;
}

.tina-tailwind .border-l {
  border-left-width: 1px;
}

.tina-tailwind .border-l-0 {
  border-left-width: 0;
}

.tina-tailwind .border-l-3 {
  border-left-width: 3px;
}

.tina-tailwind .border-r {
  border-right-width: 1px;
}

.tina-tailwind .border-r-0 {
  border-right-width: 0;
}

.tina-tailwind .border-t {
  border-top-width: 1px;
}

.tina-tailwind .border-t-0 {
  border-top-width: 0;
}

.tina-tailwind .border-solid {
  border-style: solid;
}

.tina-tailwind .border-none {
  border-style: none;
}

.tina-tailwind .border-\\[\\#efefef\\] {
  --tw-border-opacity: 1;
  border-color: rgb(239 239 239 / var(--tw-border-opacity));
}

.tina-tailwind .border-blue-500 {
  --tw-border-opacity: 1;
  border-color: rgb(0 132 255 / var(--tw-border-opacity));
}

.tina-tailwind .border-blue-600 {
  --tw-border-opacity: 1;
  border-color: rgb(5 116 228 / var(--tw-border-opacity));
}

.tina-tailwind .border-gray-100 {
  --tw-border-opacity: 1;
  border-color: rgb(237 236 243 / var(--tw-border-opacity));
}

.tina-tailwind .border-gray-150 {
  --tw-border-opacity: 1;
  border-color: rgb(230 227 239 / var(--tw-border-opacity));
}

.tina-tailwind .border-gray-200 {
  --tw-border-opacity: 1;
  border-color: rgb(225 221 236 / var(--tw-border-opacity));
}

.tina-tailwind .border-gray-300 {
  --tw-border-opacity: 1;
  border-color: rgb(178 173 190 / var(--tw-border-opacity));
}

.tina-tailwind .border-gray-50 {
  --tw-border-opacity: 1;
  border-color: rgb(246 246 249 / var(--tw-border-opacity));
}

.tina-tailwind .border-green-400 {
  --tw-border-opacity: 1;
  border-color: rgb(74 222 128 / var(--tw-border-opacity));
}

.tina-tailwind .border-red-200 {
  --tw-border-opacity: 1;
  border-color: rgb(254 202 202 / var(--tw-border-opacity));
}

.tina-tailwind .border-transparent {
  border-color: transparent;
}

.tina-tailwind .border-yellow-500 {
  --tw-border-opacity: 1;
  border-color: rgb(234 179 8 / var(--tw-border-opacity));
}

.tina-tailwind .border-b-\\[\\#edecf3\\] {
  --tw-border-opacity: 1;
  border-bottom-color: rgb(237 236 243 / var(--tw-border-opacity));
}

.tina-tailwind .border-t-gray-100 {
  --tw-border-opacity: 1;
  border-top-color: rgb(237 236 243 / var(--tw-border-opacity));
}

.tina-tailwind .border-t-white {
  --tw-border-opacity: 1;
  border-top-color: rgb(255 255 255 / var(--tw-border-opacity));
}

.tina-tailwind .bg-blue-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(220 238 255 / var(--tw-bg-opacity));
}

.tina-tailwind .bg-blue-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(0 132 255 / var(--tw-bg-opacity));
}

.tina-tailwind .bg-gray-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(237 236 243 / var(--tw-bg-opacity));
}

.tina-tailwind .bg-gray-200 {
  --tw-bg-opacity: 1;
  background-color: rgb(225 221 236 / var(--tw-bg-opacity));
}

.tina-tailwind .bg-gray-250 {
  --tw-bg-opacity: 1;
  background-color: rgb(201 197 213 / var(--tw-bg-opacity));
}

.tina-tailwind .bg-gray-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(246 246 249 / var(--tw-bg-opacity));
}

.tina-tailwind .bg-green-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(220 252 231 / var(--tw-bg-opacity));
}

.tina-tailwind .bg-green-300 {
  --tw-bg-opacity: 1;
  background-color: rgb(134 239 172 / var(--tw-bg-opacity));
}

.tina-tailwind .bg-red-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(254 242 242 / var(--tw-bg-opacity));
}

.tina-tailwind .bg-red-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(239 68 68 / var(--tw-bg-opacity));
}

.tina-tailwind .bg-transparent {
  background-color: transparent;
}

.tina-tailwind .bg-white {
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity));
}

.tina-tailwind .bg-yellow-400 {
  --tw-bg-opacity: 1;
  background-color: rgb(250 204 21 / var(--tw-bg-opacity));
}

.tina-tailwind .bg-opacity-90 {
  --tw-bg-opacity: .9;
}

.tina-tailwind .bg-gradient-to-b {
  background-image: linear-gradient(to bottom, var(--tw-gradient-stops));
}

.tina-tailwind .bg-gradient-to-br {
  background-image: linear-gradient(to bottom right, var(--tw-gradient-stops));
}

.tina-tailwind .bg-gradient-to-r {
  background-image: linear-gradient(to right, var(--tw-gradient-stops));
}

.tina-tailwind .bg-none {
  background-image: none;
}

.tina-tailwind .from-gray-50 {
  --tw-gradient-from: #F6F6F9;
  --tw-gradient-to: rgb(246 246 249 / 0);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}

.tina-tailwind .from-gray-50\\/50 {
  --tw-gradient-from: rgb(246 246 249 / .5);
  --tw-gradient-to: rgb(246 246 249 / 0);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}

.tina-tailwind .from-gray-800 {
  --tw-gradient-from: #363145;
  --tw-gradient-to: rgb(54 49 69 / 0);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}

.tina-tailwind .from-white {
  --tw-gradient-from: #fff;
  --tw-gradient-to: rgb(255 255 255 / 0);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}

.tina-tailwind .from-yellow-50 {
  --tw-gradient-from: #fefce8;
  --tw-gradient-to: rgb(254 252 232 / 0);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}

.tina-tailwind .via-gray-900 {
  --tw-gradient-to: rgb(37 35 54 / 0);
  --tw-gradient-stops: var(--tw-gradient-from), #252336, var(--tw-gradient-to);
}

.tina-tailwind .via-red-50 {
  --tw-gradient-to: rgb(254 242 242 / 0);
  --tw-gradient-stops: var(--tw-gradient-from), #fef2f2, var(--tw-gradient-to);
}

.tina-tailwind .to-black {
  --tw-gradient-to: #000;
}

.tina-tailwind .to-gray-50 {
  --tw-gradient-to: #F6F6F9;
}

.tina-tailwind .to-gray-50\\/50 {
  --tw-gradient-to: rgb(246 246 249 / .5);
}

.tina-tailwind .to-red-100 {
  --tw-gradient-to: #fee2e2;
}

.tina-tailwind .to-yellow-100 {
  --tw-gradient-to: #fef9c3;
}

.tina-tailwind .bg-\\[length\\:auto_18px\\] {
  background-size: auto 18px;
}

.tina-tailwind .bg-auto {
  background-size: auto;
}

.tina-tailwind .bg-center {
  background-position: center;
}

.tina-tailwind .bg-no-repeat {
  background-repeat: no-repeat;
}

.tina-tailwind .fill-blue-500 {
  fill: #0084FF;
}

.tina-tailwind .fill-current {
  fill: currentColor;
}

.tina-tailwind .fill-gray-300 {
  fill: #b2adbe;
}

.tina-tailwind .fill-gray-400 {
  fill: #918c9e;
}

.tina-tailwind .fill-white {
  fill: #fff;
}

.tina-tailwind .object-contain {
  object-fit: contain;
}

.tina-tailwind .object-cover {
  object-fit: cover;
}

.tina-tailwind .object-center {
  object-position: center;
}

.tina-tailwind .p-0 {
  padding: 0px;
}

.tina-tailwind .p-1 {
  padding: 4px;
}

.tina-tailwind .p-12 {
  padding: 48px;
}

.tina-tailwind .p-2 {
  padding: 8px;
}

.tina-tailwind .p-3 {
  padding: 12px;
}

.tina-tailwind .p-4 {
  padding: 16px;
}

.tina-tailwind .p-5 {
  padding: 20px;
}

.tina-tailwind .p-6 {
  padding: 24px;
}

.tina-tailwind .px-0 {
  padding-left: 0px;
  padding-right: 0px;
}

.tina-tailwind .px-1 {
  padding-left: 4px;
  padding-right: 4px;
}

.tina-tailwind .px-2 {
  padding-left: 8px;
  padding-right: 8px;
}

.tina-tailwind .px-2\\.5 {
  padding-left: 10px;
  padding-right: 10px;
}

.tina-tailwind .px-3 {
  padding-left: 12px;
  padding-right: 12px;
}

.tina-tailwind .px-4 {
  padding-left: 16px;
  padding-right: 16px;
}

.tina-tailwind .px-5 {
  padding-left: 20px;
  padding-right: 20px;
}

.tina-tailwind .px-6 {
  padding-left: 24px;
  padding-right: 24px;
}

.tina-tailwind .py-0 {
  padding-top: 0px;
  padding-bottom: 0px;
}

.tina-tailwind .py-0\\.5 {
  padding-top: 2px;
  padding-bottom: 2px;
}

.tina-tailwind .py-1 {
  padding-top: 4px;
  padding-bottom: 4px;
}

.tina-tailwind .py-1\\.5 {
  padding-top: 6px;
  padding-bottom: 6px;
}

.tina-tailwind .py-2 {
  padding-top: 8px;
  padding-bottom: 8px;
}

.tina-tailwind .py-2\\.5 {
  padding-top: 10px;
  padding-bottom: 10px;
}

.tina-tailwind .py-3 {
  padding-top: 12px;
  padding-bottom: 12px;
}

.tina-tailwind .py-4 {
  padding-top: 16px;
  padding-bottom: 16px;
}

.tina-tailwind .py-5 {
  padding-top: 20px;
  padding-bottom: 20px;
}

.tina-tailwind .py-8 {
  padding-top: 32px;
  padding-bottom: 32px;
}

.tina-tailwind .pb-12 {
  padding-bottom: 48px;
}

.tina-tailwind .pb-16 {
  padding-bottom: 64px;
}

.tina-tailwind .pb-2 {
  padding-bottom: 8px;
}

.tina-tailwind .pb-5 {
  padding-bottom: 20px;
}

.tina-tailwind .pb-\\[100\\%\\] {
  padding-bottom: 100%;
}

.tina-tailwind .pl-1 {
  padding-left: 4px;
}

.tina-tailwind .pl-1\\.5 {
  padding-left: 6px;
}

.tina-tailwind .pl-14 {
  padding-left: 56px;
}

.tina-tailwind .pl-2 {
  padding-left: 8px;
}

.tina-tailwind .pl-2\\.5 {
  padding-left: 10px;
}

.tina-tailwind .pl-20 {
  padding-left: 80px;
}

.tina-tailwind .pl-3 {
  padding-left: 12px;
}

.tina-tailwind .pl-4 {
  padding-left: 16px;
}

.tina-tailwind .pl-6 {
  padding-left: 24px;
}

.tina-tailwind .pr-0 {
  padding-right: 0px;
}

.tina-tailwind .pr-1 {
  padding-right: 4px;
}

.tina-tailwind .pr-10 {
  padding-right: 40px;
}

.tina-tailwind .pr-2 {
  padding-right: 8px;
}

.tina-tailwind .pr-28 {
  padding-right: 114px;
}

.tina-tailwind .pr-3 {
  padding-right: 12px;
}

.tina-tailwind .pr-4 {
  padding-right: 16px;
}

.tina-tailwind .pr-5 {
  padding-right: 20px;
}

.tina-tailwind .pr-8 {
  padding-right: 32px;
}

.tina-tailwind .pt-0 {
  padding-top: 0px;
}

.tina-tailwind .pt-0\\.5 {
  padding-top: 2px;
}

.tina-tailwind .pt-1 {
  padding-top: 4px;
}

.tina-tailwind .pt-16 {
  padding-top: 64px;
}

.tina-tailwind .pt-3 {
  padding-top: 12px;
}

.tina-tailwind .pt-4 {
  padding-top: 16px;
}

.tina-tailwind .text-left {
  text-align: left;
}

.tina-tailwind .text-center {
  text-align: center;
}

.tina-tailwind .text-right {
  text-align: right;
}

.tina-tailwind .align-baseline {
  vertical-align: baseline;
}

.tina-tailwind .align-top {
  vertical-align: top;
}

.tina-tailwind .font-mono {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
}

.tina-tailwind .font-sans {
  font-family: Inter, ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}

.tina-tailwind .text-2xl {
  font-size: 24px;
  line-height: 1.33;
}

.tina-tailwind .text-3xl {
  font-size: 30px;
  line-height: 1.2;
}

.tina-tailwind .text-4xl {
  font-size: 36px;
  line-height: 1.1;
}

.tina-tailwind .text-\\[12px\\] {
  font-size: 12px;
}

.tina-tailwind .text-\\[13px\\] {
  font-size: 13px;
}

.tina-tailwind .text-\\[15px\\] {
  font-size: 15px;
}

.tina-tailwind .text-\\[16px\\] {
  font-size: 16px;
}

.tina-tailwind .text-\\[24px\\] {
  font-size: 24px;
}

.tina-tailwind .text-\\[40px\\] {
  font-size: 40px;
}

.tina-tailwind .text-base {
  font-size: 16px;
  line-height: 1.5;
}

.tina-tailwind .text-lg {
  font-size: 18px;
  line-height: 1.55;
}

.tina-tailwind .text-sm {
  font-size: 14px;
  line-height: 1.43;
}

.tina-tailwind .text-xl {
  font-size: 20px;
  line-height: 1.4;
}

.tina-tailwind .text-xs {
  font-size: 13px;
  line-height: 1.33;
}

.tina-tailwind .font-bold {
  font-weight: 700;
}

.tina-tailwind .font-light {
  font-weight: 300;
}

.tina-tailwind .font-medium {
  font-weight: 500;
}

.tina-tailwind .font-normal {
  font-weight: 400;
}

.tina-tailwind .font-semibold {
  font-weight: 600;
}

.tina-tailwind .uppercase {
  text-transform: uppercase;
}

.tina-tailwind .capitalize {
  text-transform: capitalize;
}

.tina-tailwind .italic {
  font-style: italic;
}

.tina-tailwind .not-italic {
  font-style: normal;
}

.tina-tailwind .leading-5 {
  line-height: 20px;
}

.tina-tailwind .leading-6 {
  line-height: 24px;
}

.tina-tailwind .leading-\\[1\\.35\\] {
  line-height: 1.35;
}

.tina-tailwind .leading-none {
  line-height: 1;
}

.tina-tailwind .leading-tight {
  line-height: 1.25;
}

.tina-tailwind .tracking-\\[0\\.01em\\] {
  letter-spacing: 0.01em;
}

.tina-tailwind .tracking-wide {
  letter-spacing: 0.025em;
}

.tina-tailwind .text-blue-400 {
  --tw-text-opacity: 1;
  color: rgb(34 150 254 / var(--tw-text-opacity));
}

.tina-tailwind .text-blue-500 {
  --tw-text-opacity: 1;
  color: rgb(0 132 255 / var(--tw-text-opacity));
}

.tina-tailwind .text-blue-500\\/70 {
  color: rgb(0 132 255 / .7);
}

.tina-tailwind .text-blue-600 {
  --tw-text-opacity: 1;
  color: rgb(5 116 228 / var(--tw-text-opacity));
}

.tina-tailwind .text-blue-800 {
  --tw-text-opacity: 1;
  color: rgb(20 70 150 / var(--tw-text-opacity));
}

.tina-tailwind .text-gray-200 {
  --tw-text-opacity: 1;
  color: rgb(225 221 236 / var(--tw-text-opacity));
}

.tina-tailwind .text-gray-300 {
  --tw-text-opacity: 1;
  color: rgb(178 173 190 / var(--tw-text-opacity));
}

.tina-tailwind .text-gray-400 {
  --tw-text-opacity: 1;
  color: rgb(145 140 158 / var(--tw-text-opacity));
}

.tina-tailwind .text-gray-500 {
  --tw-text-opacity: 1;
  color: rgb(113 108 127 / var(--tw-text-opacity));
}

.tina-tailwind .text-gray-600 {
  --tw-text-opacity: 1;
  color: rgb(86 81 101 / var(--tw-text-opacity));
}

.tina-tailwind .text-gray-700 {
  --tw-text-opacity: 1;
  color: rgb(67 62 82 / var(--tw-text-opacity));
}

.tina-tailwind .text-gray-800 {
  --tw-text-opacity: 1;
  color: rgb(54 49 69 / var(--tw-text-opacity));
}

.tina-tailwind .text-gray-900 {
  --tw-text-opacity: 1;
  color: rgb(37 35 54 / var(--tw-text-opacity));
}

.tina-tailwind .text-green-500 {
  --tw-text-opacity: 1;
  color: rgb(34 197 94 / var(--tw-text-opacity));
}

.tina-tailwind .text-indigo-600 {
  --tw-text-opacity: 1;
  color: rgb(79 70 229 / var(--tw-text-opacity));
}

.tina-tailwind .text-red-400 {
  --tw-text-opacity: 1;
  color: rgb(248 113 113 / var(--tw-text-opacity));
}

.tina-tailwind .text-red-500 {
  --tw-text-opacity: 1;
  color: rgb(239 68 68 / var(--tw-text-opacity));
}

.tina-tailwind .text-red-600 {
  --tw-text-opacity: 1;
  color: rgb(220 38 38 / var(--tw-text-opacity));
}

.tina-tailwind .text-red-700 {
  --tw-text-opacity: 1;
  color: rgb(185 28 28 / var(--tw-text-opacity));
}

.tina-tailwind .text-red-800 {
  --tw-text-opacity: 1;
  color: rgb(153 27 27 / var(--tw-text-opacity));
}

.tina-tailwind .text-white {
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity));
}

.tina-tailwind .text-yellow-600 {
  --tw-text-opacity: 1;
  color: rgb(202 138 4 / var(--tw-text-opacity));
}

.tina-tailwind .text-yellow-700 {
  --tw-text-opacity: 1;
  color: rgb(161 98 7 / var(--tw-text-opacity));
}

.tina-tailwind .underline {
  text-decoration-line: underline;
}

.tina-tailwind .no-underline {
  text-decoration-line: none;
}

.tina-tailwind .decoration-blue-200 {
  text-decoration-color: #85C5FE;
}

.tina-tailwind .placeholder-gray-200::placeholder {
  --tw-placeholder-opacity: 1;
  color: rgb(225 221 236 / var(--tw-placeholder-opacity));
}

.tina-tailwind .placeholder-gray-400::placeholder {
  --tw-placeholder-opacity: 1;
  color: rgb(145 140 158 / var(--tw-placeholder-opacity));
}

.tina-tailwind .opacity-0 {
  opacity: 0;
}

.tina-tailwind .opacity-100 {
  opacity: 1;
}

.tina-tailwind .opacity-30 {
  opacity: .3;
}

.tina-tailwind .opacity-50 {
  opacity: .5;
}

.tina-tailwind .opacity-70 {
  opacity: .7;
}

.tina-tailwind .opacity-80 {
  opacity: .8;
}

.tina-tailwind .opacity-90 {
  opacity: .9;
}

.tina-tailwind .shadow {
  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}

.tina-tailwind .shadow-\\[0_2px_3px_rgba\\(0\\2c 0\\2c 0\\2c 0\\.05\\)\\] {
  --tw-shadow: 0 2px 3px rgba(0,0,0,0.05);
  --tw-shadow-colored: 0 2px 3px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}

.tina-tailwind .shadow-\\[0_2px_3px_rgba\\(0\\2c 0\\2c 0\\2c 0\\.12\\)\\] {
  --tw-shadow: 0 2px 3px rgba(0,0,0,0.12);
  --tw-shadow-colored: 0 2px 3px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}

.tina-tailwind .shadow-inner {
  --tw-shadow: inset 0 2px 4px 0 rgb(0 0 0 / 0.05);
  --tw-shadow-colored: inset 0 2px 4px 0 var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}

.tina-tailwind .shadow-lg {
  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}

.tina-tailwind .shadow-md {
  --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}

.tina-tailwind .shadow-outline {
  --tw-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);
  --tw-shadow-colored: 0 0 0 3px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}

.tina-tailwind .shadow-sm {
  --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / 0.05);
  --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}

.tina-tailwind .outline-none {
  outline: 2px solid transparent;
  outline-offset: 2px;
}

.tina-tailwind .outline {
  outline-style: solid;
}

.tina-tailwind .ring-1 {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}

.tina-tailwind .ring-2 {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}

.tina-tailwind .ring-inset {
  --tw-ring-inset: inset;
}

.tina-tailwind .ring-black {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(0 0 0 / var(--tw-ring-opacity));
}

.tina-tailwind .ring-blue-100 {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(180 219 255 / var(--tw-ring-opacity));
}

.tina-tailwind .ring-opacity-5 {
  --tw-ring-opacity: .05;
}

.tina-tailwind .\\!filter {
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow) !important;
}

.tina-tailwind .filter {
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}

.tina-tailwind .transition {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

.tina-tailwind .transition-all {
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

.tina-tailwind .transition-colors {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

.tina-tailwind .transition-none {
  transition-property: none;
}

.tina-tailwind .transition-opacity {
  transition-property: opacity;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

.tina-tailwind .duration-100 {
  transition-duration: 100ms;
}

.tina-tailwind .duration-150 {
  transition-duration: 150ms;
}

.tina-tailwind .duration-200 {
  transition-duration: 200ms;
}

.tina-tailwind .duration-300 {
  transition-duration: 300ms;
}

.tina-tailwind .duration-500 {
  transition-duration: 500ms;
}

.tina-tailwind .duration-75 {
  transition-duration: 75ms;
}

.tina-tailwind .duration-\\[150ms\\] {
  transition-duration: 150ms;
}

.tina-tailwind .ease-in {
  transition-timing-function: cubic-bezier(0.4, 0, 1, 1);
}

.tina-tailwind .ease-in-out {
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
}

.tina-tailwind .ease-out {
  transition-timing-function: cubic-bezier(0, 0, 0.2, 1);
}

.tina-tailwind .\\@container {
  container-type: inline-size;
}

.tina-tailwind .icon-parent svg {
      fill: currentColor;
    }

.tina-tailwind {
  font-family: Inter, ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
  font-size: 16px;
  line-height: 1.5;
  --tw-text-opacity: 1;
  color: rgb(86 81 101 / var(--tw-text-opacity));
}

/* if the last block has margin-bottom it makes the text box larger but some of it isn't clickable */

.tina-prose [data-slate-editor='true'] {
  padding-bottom: 0.5em;
}

/* prose adds backticks, which look like they should be editable */

.tina-prose [data-slate-editor='true'] .slate-code::before {
  content: '';
}

.tina-prose [data-slate-editor='true'] .slate-code::after {
  content: '';
}

.tina-prose [data-slate-editor='true'] .slate-code_block {
  margin: 0;
}

/* code lines as part of a block don't need the same background formatting */

.tina-prose [data-slate-editor='true'] .slate-code_block .slate-code {
  background: none;
}

/* prose makes the first p in a block slightly larger */

.tina-prose [data-slate-editor='true'] p:first-of-type {
  font-size: 1em;
}

/* experimental floating toolbar doesn't need a large text area */

.with-toolbar [data-slate-editor='true'] {
  min-height: 72px;
}

.tina-tailwind .placeholder\\:text-gray-300::placeholder {
  --tw-text-opacity: 1;
  color: rgb(178 173 190 / var(--tw-text-opacity));
}

.tina-tailwind .before\\:absolute::before {
  content: var(--tw-content);
  position: absolute;
}

.tina-tailwind .before\\:bottom-0::before {
  content: var(--tw-content);
  bottom: 0px;
}

.tina-tailwind .before\\:left-1\\/2::before {
  content: var(--tw-content);
  left: 50%;
}

.tina-tailwind .before\\:top-0::before {
  content: var(--tw-content);
  top: 0px;
}

.tina-tailwind .before\\:z-10::before {
  content: var(--tw-content);
  z-index: 10;
}

.tina-tailwind .before\\:mb-\\[1px\\]::before {
  content: var(--tw-content);
  margin-bottom: 1px;
}

.tina-tailwind .before\\:mt-\\[1px\\]::before {
  content: var(--tw-content);
  margin-top: 1px;
}

.tina-tailwind .before\\:h-\\[14px\\]::before {
  content: var(--tw-content);
  height: 14px;
}

.tina-tailwind .before\\:w-\\[18px\\]::before {
  content: var(--tw-content);
  width: 18px;
}

.tina-tailwind .before\\:-translate-x-1\\/2::before {
  content: var(--tw-content);
  --tw-translate-x: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .before\\:-translate-y-full::before {
  content: var(--tw-content);
  --tw-translate-y: -100%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .before\\:translate-y-full::before {
  content: var(--tw-content);
  --tw-translate-y: 100%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .before\\:bg-gray-200::before {
  content: var(--tw-content);
  --tw-bg-opacity: 1;
  background-color: rgb(225 221 236 / var(--tw-bg-opacity));
}

.tina-tailwind .before\\:content-\\[\\"\\"\\]::before {
  --tw-content: "";
  content: var(--tw-content);
}

.tina-tailwind .after\\:absolute::after {
  content: var(--tw-content);
  position: absolute;
}

.tina-tailwind .after\\:bottom-0::after {
  content: var(--tw-content);
  bottom: 0px;
}

.tina-tailwind .after\\:left-1\\/2::after {
  content: var(--tw-content);
  left: 50%;
}

.tina-tailwind .after\\:top-0::after {
  content: var(--tw-content);
  top: 0px;
}

.tina-tailwind .after\\:z-20::after {
  content: var(--tw-content);
  z-index: 20;
}

.tina-tailwind .after\\:mb-0::after {
  content: var(--tw-content);
  margin-bottom: 0px;
}

.tina-tailwind .after\\:mb-0\\.5::after {
  content: var(--tw-content);
  margin-bottom: 2px;
}

.tina-tailwind .after\\:mt-0::after {
  content: var(--tw-content);
  margin-top: 0px;
}

.tina-tailwind .after\\:mt-0\\.5::after {
  content: var(--tw-content);
  margin-top: 2px;
}

.tina-tailwind .after\\:h-\\[13px\\]::after {
  content: var(--tw-content);
  height: 13px;
}

.tina-tailwind .after\\:w-4::after {
  content: var(--tw-content);
  width: 16px;
}

.tina-tailwind .after\\:-translate-x-1\\/2::after {
  content: var(--tw-content);
  --tw-translate-x: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .after\\:-translate-y-full::after {
  content: var(--tw-content);
  --tw-translate-y: -100%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .after\\:translate-y-full::after {
  content: var(--tw-content);
  --tw-translate-y: 100%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .after\\:bg-white::after {
  content: var(--tw-content);
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity));
}

.tina-tailwind .after\\:pl-1::after {
  content: var(--tw-content);
  padding-left: 4px;
}

.tina-tailwind .after\\:pl-1\\.5::after {
  content: var(--tw-content);
  padding-left: 6px;
}

.tina-tailwind .after\\:content-\\[\\"\\"\\]::after {
  --tw-content: "";
  content: var(--tw-content);
}

.tina-tailwind .after\\:content-\\[\\'\\/\\'\\]::after {
  --tw-content: '/';
  content: var(--tw-content);
}

.tina-tailwind .first\\:mt-0:first-child {
  margin-top: 0px;
}

.tina-tailwind .first\\:rounded-t:first-child {
  border-top-left-radius: 4px;
  border-top-right-radius: 4px;
}

.tina-tailwind .first\\:pt-3:first-child {
  padding-top: 12px;
}

.tina-tailwind .last\\:mb-0:last-child {
  margin-bottom: 0px;
}

.tina-tailwind .last\\:rounded-b:last-child {
  border-bottom-right-radius: 4px;
  border-bottom-left-radius: 4px;
}

.tina-tailwind .last\\:pb-3:last-child {
  padding-bottom: 12px;
}

.tina-tailwind .focus-within\\:border-blue-500:focus-within {
  --tw-border-opacity: 1;
  border-color: rgb(0 132 255 / var(--tw-border-opacity));
}

.tina-tailwind .focus-within\\:text-gray-900:focus-within {
  --tw-text-opacity: 1;
  color: rgb(37 35 54 / var(--tw-text-opacity));
}

.tina-tailwind .focus-within\\:shadow-outline:focus-within {
  --tw-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);
  --tw-shadow-colored: 0 0 0 3px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}

.tina-tailwind .hover\\:scale-100:hover {
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .hover\\:scale-103:hover {
  --tw-scale-x: 1.03;
  --tw-scale-y: 1.03;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .hover\\:border-gray-150:hover {
  --tw-border-opacity: 1;
  border-color: rgb(230 227 239 / var(--tw-border-opacity));
}

.tina-tailwind .hover\\:border-gray-200:hover {
  --tw-border-opacity: 1;
  border-color: rgb(225 221 236 / var(--tw-border-opacity));
}

.tina-tailwind .hover\\:bg-blue-500:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(0 132 255 / var(--tw-bg-opacity));
}

.tina-tailwind .hover\\:bg-blue-600:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(5 116 228 / var(--tw-bg-opacity));
}

.tina-tailwind .hover\\:bg-gray-100:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(237 236 243 / var(--tw-bg-opacity));
}

.tina-tailwind .hover\\:bg-gray-50:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(246 246 249 / var(--tw-bg-opacity));
}

.tina-tailwind .hover\\:bg-gray-50\\/50:hover {
  background-color: rgb(246 246 249 / .5);
}

.tina-tailwind .hover\\:bg-gray-500:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(113 108 127 / var(--tw-bg-opacity));
}

.tina-tailwind .hover\\:bg-red-600:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(220 38 38 / var(--tw-bg-opacity));
}

.tina-tailwind .hover\\:bg-white:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity));
}

.tina-tailwind .hover\\:fill-gray-700:hover {
  fill: #433e52;
}

.tina-tailwind .hover\\:fill-gray-900:hover {
  fill: #252336;
}

.tina-tailwind .hover\\:text-blue-400:hover {
  --tw-text-opacity: 1;
  color: rgb(34 150 254 / var(--tw-text-opacity));
}

.tina-tailwind .hover\\:text-blue-500:hover {
  --tw-text-opacity: 1;
  color: rgb(0 132 255 / var(--tw-text-opacity));
}

.tina-tailwind .hover\\:text-blue-600:hover {
  --tw-text-opacity: 1;
  color: rgb(5 116 228 / var(--tw-text-opacity));
}

.tina-tailwind .hover\\:text-gray-600:hover {
  --tw-text-opacity: 1;
  color: rgb(86 81 101 / var(--tw-text-opacity));
}

.tina-tailwind .hover\\:text-gray-900:hover {
  --tw-text-opacity: 1;
  color: rgb(37 35 54 / var(--tw-text-opacity));
}

.tina-tailwind .hover\\:text-red-500:hover {
  --tw-text-opacity: 1;
  color: rgb(239 68 68 / var(--tw-text-opacity));
}

.tina-tailwind .hover\\:text-white:hover {
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity));
}

.tina-tailwind .hover\\:underline:hover {
  text-decoration-line: underline;
}

.tina-tailwind .hover\\:decoration-blue-500:hover {
  text-decoration-color: #0084FF;
}

.tina-tailwind .hover\\:placeholder-gray-600:hover::placeholder {
  --tw-placeholder-opacity: 1;
  color: rgb(86 81 101 / var(--tw-placeholder-opacity));
}

.tina-tailwind .hover\\:opacity-100:hover {
  opacity: 1;
}

.tina-tailwind .hover\\:opacity-60:hover {
  opacity: .6;
}

.tina-tailwind .hover\\:opacity-70:hover {
  opacity: .7;
}

.tina-tailwind .hover\\:opacity-\\[\\.6\\]:hover {
  opacity: .6;
}

.tina-tailwind .hover\\:shadow:hover {
  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}

.tina-tailwind .hover\\:shadow-md:hover {
  --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}

.tina-tailwind .focus\\:z-10:focus {
  z-index: 10;
}

.tina-tailwind .focus\\:border-blue-300:focus {
  --tw-border-opacity: 1;
  border-color: rgb(78 171 254 / var(--tw-border-opacity));
}

.tina-tailwind .focus\\:border-blue-400:focus {
  --tw-border-opacity: 1;
  border-color: rgb(34 150 254 / var(--tw-border-opacity));
}

.tina-tailwind .focus\\:border-blue-500:focus {
  --tw-border-opacity: 1;
  border-color: rgb(0 132 255 / var(--tw-border-opacity));
}

.tina-tailwind .focus\\:border-gray-500:focus {
  --tw-border-opacity: 1;
  border-color: rgb(113 108 127 / var(--tw-border-opacity));
}

.tina-tailwind .focus\\:bg-gray-50:focus {
  --tw-bg-opacity: 1;
  background-color: rgb(246 246 249 / var(--tw-bg-opacity));
}

.tina-tailwind .focus\\:text-blue-500:focus {
  --tw-text-opacity: 1;
  color: rgb(0 132 255 / var(--tw-text-opacity));
}

.tina-tailwind .focus\\:text-gray-900:focus {
  --tw-text-opacity: 1;
  color: rgb(37 35 54 / var(--tw-text-opacity));
}

.tina-tailwind .focus\\:opacity-80:focus {
  opacity: .8;
}

.tina-tailwind .focus\\:shadow-outline:focus {
  --tw-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);
  --tw-shadow-colored: 0 0 0 3px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}

.tina-tailwind .focus\\:outline-none:focus {
  outline: 2px solid transparent;
  outline-offset: 2px;
}

.tina-tailwind .focus\\:ring-0:focus {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}

.tina-tailwind .focus\\:ring-1:focus {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}

.tina-tailwind .focus\\:ring-2:focus {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}

.tina-tailwind .focus\\:ring-blue-500:focus {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(0 132 255 / var(--tw-ring-opacity));
}

.tina-tailwind .focus\\:ring-gray-500:focus {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(113 108 127 / var(--tw-ring-opacity));
}

.tina-tailwind .focus\\:ring-indigo-500:focus {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(99 102 241 / var(--tw-ring-opacity));
}

.tina-tailwind .focus\\:ring-red-500:focus {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(239 68 68 / var(--tw-ring-opacity));
}

.tina-tailwind .focus\\:ring-offset-2:focus {
  --tw-ring-offset-width: 2px;
}

.tina-tailwind .focus\\:ring-offset-gray-100:focus {
  --tw-ring-offset-color: #EDECF3;
}

.tina-tailwind .focus-visible\\:ring-2:focus-visible {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}

.tina-tailwind .focus-visible\\:ring-white:focus-visible {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(255 255 255 / var(--tw-ring-opacity));
}

.tina-tailwind .focus-visible\\:ring-opacity-75:focus-visible {
  --tw-ring-opacity: .75;
}

.tina-tailwind .focus-visible\\:ring-offset-2:focus-visible {
  --tw-ring-offset-width: 2px;
}

.tina-tailwind .focus-visible\\:ring-offset-teal-300:focus-visible {
  --tw-ring-offset-color: #5eead4;
}

.tina-tailwind .active\\:outline-none:active {
  outline: 2px solid transparent;
  outline-offset: 2px;
}

.tina-tailwind .group:hover .group-hover\\:scale-110 {
  --tw-scale-x: 1.1;
  --tw-scale-y: 1.1;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}

.tina-tailwind .group:hover .group-hover\\:border-blue-400 {
  --tw-border-opacity: 1;
  border-color: rgb(34 150 254 / var(--tw-border-opacity));
}

.tina-tailwind .group:hover .group-hover\\:bg-blue-400 {
  --tw-bg-opacity: 1;
  background-color: rgb(34 150 254 / var(--tw-bg-opacity));
}

.tina-tailwind .group:hover .group-hover\\:bg-gray-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(237 236 243 / var(--tw-bg-opacity));
}

.tina-tailwind .group:hover .group-hover\\:text-blue-400 {
  --tw-text-opacity: 1;
  color: rgb(34 150 254 / var(--tw-text-opacity));
}

.tina-tailwind .group:hover .group-hover\\:text-blue-500 {
  --tw-text-opacity: 1;
  color: rgb(0 132 255 / var(--tw-text-opacity));
}

.tina-tailwind .group:hover .group-hover\\:text-gray-800 {
  --tw-text-opacity: 1;
  color: rgb(54 49 69 / var(--tw-text-opacity));
}

.tina-tailwind .group:hover .group-hover\\:text-inherit {
  color: inherit;
}

.tina-tailwind .group:hover .group-hover\\:opacity-0 {
  opacity: 0;
}

.tina-tailwind .group:hover .group-hover\\:opacity-100 {
  opacity: 1;
}

.tina-tailwind .group:hover .group-hover\\:opacity-50 {
  opacity: .5;
}

.tina-tailwind .group:hover .group-hover\\:opacity-80 {
  opacity: .8;
}

.tina-tailwind .group:hover .group-hover\\:opacity-90 {
  opacity: .9;
}

@container (min-width: 24rem) {

  .tina-tailwind .\\@sm\\:grid-cols-2 {
    grid-template-columns: repeat(2, minmax(0, 1fr));
  }
}

@container (min-width: 32rem) {

  .tina-tailwind .\\@lg\\:grid-cols-3 {
    grid-template-columns: repeat(3, minmax(0, 1fr));
  }
}

@container (min-width: 42rem) {

  .tina-tailwind .\\@2xl\\:grid-cols-4 {
    grid-template-columns: repeat(4, minmax(0, 1fr));
  }
}

@container (min-width: 56rem) {

  .tina-tailwind .\\@4xl\\:grid-cols-6 {
    grid-template-columns: repeat(6, minmax(0, 1fr));
  }
}

@container (min-width: 72rem) {

  .tina-tailwind .\\@6xl\\:grid-cols-8 {
    grid-template-columns: repeat(8, minmax(0, 1fr));
  }
}

@media (min-width: 560px) {

  .tina-tailwind .sm\\:rounded-lg {
    border-radius: 8px;
  }

  .tina-tailwind .sm\\:p-6 {
    padding: 24px;
  }

  .tina-tailwind .sm\\:px-0 {
    padding-left: 0px;
    padding-right: 0px;
  }

  .tina-tailwind .sm\\:text-sm {
    font-size: 14px;
    line-height: 1.43;
  }
}

@media (min-width: 720px) {

  .tina-tailwind .md\\:w-\\[calc\\(100\\%-170px\\)\\] {
    width: calc(100% - 170px);
  }
}

.tina-tailwind .\\[\\&\\:last-child\\]\\:rounded-\\[0_0_5px_5px\\]:last-child {
  border-radius: 0 0 5px 5px;
}
`;
var TinaUI = ({ children, position: position3 }) => {
  const cms = useCMS();
  const [resizingSidebar, setResizingSidebar] = React68.useState(false);
  return React68.createElement(MutationSignalProvider, null, React68.createElement("style", null, styles3), React68.createElement("link", {
    rel: "stylesheet",
    href: "https://fonts.googleapis.com/css?family=Inter:400,600",
    media: "all"
  }), React68.createElement(ModalProvider, null, React68.createElement("div", {
    className: "tina-tailwind"
  }, React68.createElement(Alerts, {
    alerts: cms.alerts
  }), React68.createElement(MediaManager, null), cms.sidebar && React68.createElement(SidebarProvider, {
    resizingSidebar,
    setResizingSidebar,
    position: position3,
    sidebar: cms.sidebar
  }), React68.createElement(ActiveFieldIndicator, null)), React68.createElement("div", {
    className: `${resizingSidebar ? "pointer-events-none" : ""}`
  }, children)));
};
var TinaProvider = ({
  cms,
  children,
  position: position3,
  styled = true
}) => {
  return React68.createElement(TinaCMSProvider, {
    cms
  }, React68.createElement(TinaUI, {
    position: position3,
    styled
  }, children));
};
var Tina = TinaProvider;
function withTina(Component9, config2) {
  return (props) => {
    const cms = React68.useMemo(() => new TinaCMS(config2), [config2]);
    return React68.createElement(TinaProvider, {
      cms
    }, React68.createElement(Component9, {
      ...props
    }));
  };
}
var BranchBanner = () => {
  const [open, setOpen] = React68.useState(false);
  const openModal = () => setOpen(true);
  const { currentBranch } = useBranchData();
  return React68.createElement(React68.Fragment, null, React68.createElement("div", {
    className: "flex-grow-0 flex justify-between items-center gap-2 w-full max-w-full text-xs items-center py-2 px-4 text-gray-500 bg-gradient-to-r from-white to-gray-50 border-b border-gray-150 gap-2"
  }, React68.createElement(BiGitBranch, {
    className: "shrink-0 w-5 h-auto text-blue-500/70"
  }), " ", React68.createElement("span", {
    className: "shrink-"
  }, "Branch"), React68.createElement("div", {
    className: "flex-1 min-w-0 flex items-center justify-start"
  }, React68.createElement(BranchButton, {
    currentBranch,
    openModal
  }))), open && React68.createElement(BranchModal, {
    close: () => {
      setOpen(false);
    }
  }));
};
var BranchButton = ({ currentBranch = "main", openModal }) => {
  return React68.createElement("button", {
    className: "flex min-w-0	shrink gap-1.5 items-center justify-between form-select h-7 px-2.5 border border-gray-200 bg-white text-gray-700 hover:text-blue-500 transition-color duration-150 ease-out rounded-md shadow-sm focus:outline-none focus:shadow-outline-blue focus:border-blue-300 transition duration-150 ease-in-out text-[12px] leading-tight capitalize min-w-[5rem]",
    onClick: openModal
  }, React68.createElement("span", {
    className: "truncate max-w-full"
  }, currentBranch), React68.createElement(BiChevronDown, {
    className: "-mr-1 -ml-1 h-4 w-4 opacity-70 shrink-0",
    "aria-hidden": "true"
  }));
};
var BranchModal = ({ close: close2 }) => {
  const tinaApi = useCMS().api.tina;
  const { setCurrentBranch } = useBranchData();
  return React68.createElement(Modal, null, React68.createElement(PopupModal, null, React68.createElement(ModalHeader, {
    close: close2
  }, "Select Branch"), React68.createElement(ModalBody, {
    padded: false
  }, React68.createElement(BranchSwitcher, {
    listBranches: tinaApi.listBranches.bind(tinaApi),
    createBranch: async (data) => {
      return await tinaApi.createBranch(data);
    },
    chooseBranch: setCurrentBranch
  }))));
};
var SidebarContext = React68.createContext(null);
var minPreviewWidth = 440;
var minSidebarWidth = 360;
var navBreakpoint = 1e3;
var LOCALSTATEKEY = "tina.sidebarState";
var LOCALWIDTHKEY = "tina.sidebarWidth";
var defaultSidebarWidth = 440;
var defaultSidebarPosition = "displace";
var defaultSidebarState = "open";
function SidebarProvider({
  position: position3 = defaultSidebarPosition,
  resizingSidebar,
  setResizingSidebar,
  defaultWidth = defaultSidebarWidth,
  defaultState = defaultSidebarState,
  sidebar
}) {
  var _a, _b, _c, _d;
  useSubscribable(sidebar);
  const cms = useCMS$1();
  if (!cms.enabled)
    return null;
  return React68.createElement(Sidebar, {
    position: ((_a = cms == null ? void 0 : cms.sidebar) == null ? void 0 : _a.position) || position3,
    defaultWidth: ((_b = cms == null ? void 0 : cms.sidebar) == null ? void 0 : _b.defaultWidth) || defaultWidth,
    defaultState: ((_c = cms == null ? void 0 : cms.sidebar) == null ? void 0 : _c.defaultState) || defaultState,
    resizingSidebar,
    setResizingSidebar,
    renderNav: typeof ((_d = cms == null ? void 0 : cms.sidebar) == null ? void 0 : _d.renderNav) !== "undefined" ? cms.sidebar.renderNav : true,
    sidebar
  });
}
var useFetchCollections = (cms) => {
  return { collections: cms.api.admin.fetchCollections(), loading: false };
};
var Sidebar = ({
  sidebar,
  defaultWidth,
  defaultState,
  position: position3,
  renderNav,
  resizingSidebar,
  setResizingSidebar
}) => {
  var _a, _b, _c, _d, _e4, _f;
  const cms = useCMS$1();
  const collectionsInfo = useFetchCollections(cms);
  const [branchingEnabled, setBranchingEnabled] = React68.useState(() => cms.flags.get("branch-switcher"));
  React68.useEffect(() => {
    cms.events.subscribe("flag:set", ({ key, value }) => {
      if (key === "branch-switcher") {
        setBranchingEnabled(value);
      }
    });
  }, [cms.events]);
  const screens = cms.plugins.getType("screen");
  const cloudConfigs = cms.plugins.getType("cloud-config");
  useSubscribable(sidebar);
  useSubscribable(screens);
  const allScreens = screens.all();
  const allConfigs = cloudConfigs.all();
  const [menuIsOpen, setMenuIsOpen] = (0, import_react117.useState)(false);
  const [activeScreen, setActiveView] = (0, import_react117.useState)(null);
  const [displayState, setDisplayState] = React68.useState(defaultState);
  const [sidebarWidth, setSidebarWidth] = React68.useState(defaultWidth);
  const [formIsPristine, setFormIsPristine] = React68.useState(true);
  React68.useEffect(() => {
    if (typeof window !== "undefined") {
      const localSidebarState = window.localStorage.getItem(LOCALSTATEKEY);
      const localSidebarWidth = window.localStorage.getItem(LOCALWIDTHKEY);
      if (localSidebarState !== null) {
        setDisplayState(JSON.parse(localSidebarState));
      }
      if (localSidebarWidth !== null) {
        setSidebarWidth(JSON.parse(localSidebarWidth));
      }
    }
  }, []);
  React68.useEffect(() => {
    if (typeof window !== "undefined") {
      const localSidebarState = window.localStorage.getItem(LOCALSTATEKEY);
      if (localSidebarState === null) {
        setDisplayState(defaultState);
      }
    }
  }, [defaultState]);
  React68.useEffect(() => {
    if (typeof window !== "undefined" && cms.enabled) {
      window.localStorage.setItem(LOCALSTATEKEY, JSON.stringify(displayState));
    }
  }, [displayState, cms]);
  React68.useEffect(() => {
    if (resizingSidebar) {
      window.localStorage.setItem(LOCALWIDTHKEY, JSON.stringify(sidebarWidth));
    }
  }, [sidebarWidth, resizingSidebar]);
  const isTinaAdminEnabled = cms.flags.get("tina-admin") === false ? false : true;
  const contentCreators = isTinaAdminEnabled ? [] : cms.plugins.getType("content-creator").all();
  const toggleFullscreen = () => {
    if (displayState === "fullscreen") {
      setDisplayState("open");
    } else {
      setDisplayState("fullscreen");
    }
  };
  const toggleSidebarOpen = () => {
    if (displayState === "closed") {
      setDisplayState("open");
    } else {
      setDisplayState("closed");
    }
  };
  const toggleMenu = () => {
    setMenuIsOpen((menuIsOpen2) => !menuIsOpen2);
  };
  React68.useEffect(() => {
    const updateLayout = () => {
      if (displayState === "fullscreen") {
        return;
      }
      updateBodyDisplacement({
        position: position3,
        displayState,
        sidebarWidth,
        resizingSidebar
      });
    };
    updateLayout();
    window.addEventListener("resize", updateLayout);
    return () => {
      window.removeEventListener("resize", updateLayout);
    };
  }, [displayState, position3, sidebarWidth, resizingSidebar]);
  const windowWidth = useWindowWidth();
  const displayNav = renderNav && (sidebarWidth > navBreakpoint && windowWidth > navBreakpoint || displayState === "fullscreen" && windowWidth > navBreakpoint);
  const renderMobileNav = renderNav && (sidebarWidth < navBreakpoint + 1 || windowWidth < navBreakpoint + 1);
  return React68.createElement(SidebarContext.Provider, {
    value: {
      sidebarWidth,
      setSidebarWidth,
      displayState,
      setDisplayState,
      position: position3,
      toggleFullscreen,
      toggleSidebarOpen,
      resizingSidebar,
      setResizingSidebar,
      menuIsOpen,
      setMenuIsOpen,
      toggleMenu,
      setActiveView,
      formIsPristine,
      setFormIsPristine
    }
  }, React68.createElement(React68.Fragment, null, React68.createElement(SidebarWrapper, null, React68.createElement(EditButton, null), displayNav && React68.createElement(Nav, {
    isLocalMode: (_b = (_a = cms.api) == null ? void 0 : _a.tina) == null ? void 0 : _b.isLocalMode,
    showCollections: isTinaAdminEnabled,
    collectionsInfo,
    screens: allScreens,
    cloudConfigs: allConfigs,
    contentCreators,
    sidebarWidth,
    RenderNavSite: ({ view }) => React68.createElement(SidebarSiteLink, {
      view,
      onClick: () => {
        setActiveView(view);
        setMenuIsOpen(false);
      }
    }),
    RenderNavCloud: ({ config: config2 }) => React68.createElement(SidebarCloudLink, {
      config: config2
    }),
    RenderNavCollection: ({ collection }) => React68.createElement(SidebarCollectionLink, {
      onClick: () => {
        setMenuIsOpen(false);
      },
      collection
    })
  }), React68.createElement(SidebarBody, null, React68.createElement(SidebarHeader, {
    displayNav,
    renderNav,
    isLocalMode: (_d = (_c = cms.api) == null ? void 0 : _c.tina) == null ? void 0 : _d.isLocalMode,
    branchingEnabled
  }), React68.createElement(FormsView, null, React68.createElement(sidebar.placeholder, null)), activeScreen && React68.createElement(ScreenPluginModal, {
    screen: activeScreen,
    close: () => setActiveView(null)
  })), React68.createElement(ResizeHandle, null)), renderMobileNav && React68.createElement(tt2, {
    show: menuIsOpen
  }, React68.createElement(tt2.Child, {
    as: React68.Fragment,
    enter: "transform transition-all ease-out duration-300",
    enterFrom: "opacity-0 -translate-x-full",
    enterTo: "opacity-100 translate-x-0",
    leave: "transform transition-all ease-in duration-200",
    leaveFrom: "opacity-100 translate-x-0",
    leaveTo: "opacity-0 -translate-x-full"
  }, React68.createElement("div", {
    className: "fixed left-0 top-0 z-overlay h-full transform"
  }, React68.createElement(Nav, {
    isLocalMode: (_f = (_e4 = cms.api) == null ? void 0 : _e4.tina) == null ? void 0 : _f.isLocalMode,
    className: "rounded-r-md",
    showCollections: isTinaAdminEnabled,
    collectionsInfo,
    screens: allScreens,
    cloudConfigs: allConfigs,
    contentCreators,
    sidebarWidth,
    RenderNavSite: ({ view }) => React68.createElement(SidebarSiteLink, {
      view,
      onClick: () => {
        setActiveView(view);
        setMenuIsOpen(false);
      }
    }),
    RenderNavCloud: ({ config: config2 }) => React68.createElement(SidebarCloudLink, {
      config: config2
    }),
    RenderNavCollection: ({ collection }) => React68.createElement(SidebarCollectionLink, {
      onClick: () => {
        setMenuIsOpen(false);
      },
      collection
    })
  }, React68.createElement("div", {
    className: "absolute top-8 right-0 transform translate-x-full overflow-hidden"
  }, React68.createElement(Button, {
    rounded: "right",
    variant: "secondary",
    onClick: () => {
      setMenuIsOpen(false);
    },
    className: `transition-opacity duration-150 ease-out`
  }, React68.createElement(IoMdClose, {
    className: "h-6 w-auto"
  })))))), React68.createElement(tt2.Child, {
    as: React68.Fragment,
    enter: "ease-out duration-300",
    enterFrom: "opacity-0",
    enterTo: "opacity-80",
    entered: "opacity-80",
    leave: "ease-in duration-200",
    leaveFrom: "opacity-80",
    leaveTo: "opacity-0"
  }, React68.createElement("div", {
    onClick: () => {
      setMenuIsOpen(false);
    },
    className: "fixed z-menu inset-0 bg-gradient-to-br from-gray-800 via-gray-900 to-black"
  })))));
};
var updateBodyDisplacement = ({
  position: position3 = "overlay",
  displayState,
  sidebarWidth,
  resizingSidebar
}) => {
  const body = document.getElementsByTagName("body")[0];
  const windowWidth = window.innerWidth;
  if (position3 === "displace") {
    if (!resizingSidebar) {
      body.style.transition = "all 200ms ease-out";
    } else {
      body.style.transition = "";
    }
    if (displayState === "open") {
      const bodyDisplacement = Math.min(sidebarWidth, windowWidth - minPreviewWidth);
      body.style.paddingLeft = bodyDisplacement + "px";
    } else {
      body.style.paddingLeft = "0";
    }
  } else {
    body.style.transition = "";
    body.style.paddingLeft = "0";
  }
};
var SidebarHeader = ({
  branchingEnabled,
  renderNav,
  displayNav,
  isLocalMode
}) => {
  const { toggleFullscreen, displayState, setMenuIsOpen, toggleSidebarOpen } = React68.useContext(SidebarContext);
  const displayMenuButton = renderNav && !displayNav;
  return React68.createElement("div", {
    className: "flex-grow-0 w-full overflow-visible z-20"
  }, isLocalMode && React68.createElement(LocalWarning, null), !isLocalMode && React68.createElement(BillingWarning, null), branchingEnabled && !isLocalMode && React68.createElement(BranchBanner, null), React68.createElement("div", {
    className: "mt-4 -mb-14 w-full flex items-center justify-between pointer-events-none"
  }, displayMenuButton && React68.createElement(Button, {
    rounded: "right",
    variant: "secondary",
    onClick: () => {
      setMenuIsOpen(true);
    },
    className: "pointer-events-auto -ml-px"
  }, React68.createElement(BiMenu, {
    className: "h-7 w-auto"
  })), React68.createElement("div", {
    className: "flex-1"
  }), React68.createElement("div", {
    className: `flex items-center gap-2 pointer-events-auto transition-opacity duration-150 ease-in-out -mr-px`
  }, React68.createElement(Button, {
    rounded: "full",
    variant: "ghost",
    onClick: toggleFullscreen,
    className: "pointer-events-auto opacity-50 hover:opacity-100 focus:opacity-80"
  }, displayState === "fullscreen" ? React68.createElement(BsArrowsAngleContract, {
    className: "h-5 w-auto -mx-1"
  }) : React68.createElement(BsArrowsAngleExpand, {
    className: "h-5 w-auto -mx-1"
  })), React68.createElement(Button, {
    rounded: "left",
    variant: "secondary",
    onClick: toggleSidebarOpen,
    "aria-label": "closes cms sidebar",
    className: ``
  }, React68.createElement(MdOutlineArrowBackIos, {
    className: "h-6 w-auto"
  })))));
};
var SidebarSiteLink = ({
  view,
  onClick
}) => {
  return React68.createElement("button", {
    className: "text-base tracking-wide text-gray-500 hover:text-blue-600 flex items-center opacity-90 hover:opacity-100",
    value: view.name,
    onClick
  }, React68.createElement(view.Icon, {
    className: "mr-2 h-6 opacity-80 w-auto"
  }), " ", view.name);
};
var SidebarCloudLink = ({ config: config2 }) => {
  if (config2.text) {
    return React68.createElement("span", {
      className: "text-base tracking-wide text-gray-500 flex items-center opacity-90"
    }, config2.text, " ", React68.createElement("a", {
      target: "_blank",
      className: "ml-1 text-blue-600 hover:opacity-60",
      href: config2.link.href
    }, config2.link.text));
  }
  return React68.createElement("span", {
    className: "text-base tracking-wide text-gray-500 hover:text-blue-600 flex items-center opacity-90 hover:opacity-100"
  }, React68.createElement(config2.Icon, {
    className: "mr-2 h-6 opacity-80 w-auto"
  }), React68.createElement("a", {
    target: "_blank",
    href: config2.link.href
  }, config2.link.text));
};
var SidebarCollectionLink = ({
  collection,
  onClick
}) => {
  const cms = useCMS$1();
  const tinaPreview = cms.flags.get("tina-preview") || false;
  return React68.createElement("a", {
    onClick,
    href: `${tinaPreview ? `/${tinaPreview}/index.html#` : "/admin#"}/collections/${collection.name}`,
    className: "text-base tracking-wide text-gray-500 hover:text-blue-600 flex items-center opacity-90 hover:opacity-100"
  }, React68.createElement(ImFilesEmpty, {
    className: "mr-2 h-6 opacity-80 w-auto"
  }), " ", collection.label ? collection.label : collection.name);
};
var EditButton = ({}) => {
  const { displayState, toggleSidebarOpen } = React68.useContext(SidebarContext);
  return React68.createElement(Button, {
    rounded: "right",
    variant: "primary",
    onClick: toggleSidebarOpen,
    className: ` absolute top-8 right-0 transition-all duration-150 ease-out ${displayState !== "closed" ? "opacity-0" : "translate-x-full pointer-events-auto"}`,
    "aria-label": "opens cms sidebar"
  }, React68.createElement(BiPencil, {
    className: "h-6 w-auto"
  }));
};
var SidebarWrapper = ({ children }) => {
  const { displayState, sidebarWidth, resizingSidebar } = React68.useContext(SidebarContext);
  return React68.createElement("div", {
    className: `fixed top-0 left-0 h-screen z-base ${displayState === "closed" ? `pointer-events-none` : ``}`
  }, React68.createElement("div", {
    className: `relative h-screen transform flex ${displayState !== "closed" ? `` : `-translate-x-full`} ${resizingSidebar ? `transition-none` : displayState === "fullscreen" ? `transition-all duration-150 ease-out` : `transition-all duration-300 ease-out`}`,
    style: {
      width: displayState === "fullscreen" ? "100vw" : sidebarWidth + "px",
      maxWidth: displayState === "fullscreen" ? "100vw" : "calc(100vw - 8px)",
      minWidth: "360px"
    }
  }, children));
};
var SidebarBody = ({ children }) => {
  const { displayState } = React68.useContext(SidebarContext);
  return React68.createElement("div", {
    className: `relative left-0 w-full h-full flex flex-col items-stretch bg-white border-r border-gray-200 overflow-hidden transition-opacity duration-300 ease-out ${displayState !== "closed" ? "opacity-100" : "opacity-0"} ${displayState === "fullscreen" ? "" : ""}`
  }, children);
};
var FormMetaPlugin = class {
  constructor(options) {
    this.__type = "form:meta";
    this.name = options.name;
    this.Component = options.Component;
  }
};
function useLocalStorage(key, initialValue) {
  const [storedValue, setStoredValue] = React68.useState(initialValue);
  React68.useEffect(() => {
    const valueFromStorage = window.localStorage && window.localStorage.getItem(key);
    if (valueFromStorage != null && valueFromStorage != void 0) {
      setStoredValue(JSON.parse(valueFromStorage));
    }
  }, [key]);
  const setValue = (value) => {
    try {
      const valueToStore = value instanceof Function ? value(storedValue) : value;
      setStoredValue(valueToStore);
      localStorage.setItem(key, JSON.stringify(valueToStore));
    } catch (error2) {
      console.log(error2);
    }
  };
  return [storedValue, setValue];
}

// node_modules/graphql-tag/lib/index.js
var docCache = /* @__PURE__ */ new Map();
var fragmentSourceMap = /* @__PURE__ */ new Map();
var printFragmentWarnings = true;
var experimentalFragmentVariables = false;
function normalize3(string2) {
  return string2.replace(/[\s,]+/g, " ").trim();
}
function cacheKeyFromLoc(loc) {
  return normalize3(loc.source.body.substring(loc.start, loc.end));
}
function processFragments(ast) {
  var seenKeys = /* @__PURE__ */ new Set();
  var definitions = [];
  ast.definitions.forEach(function(fragmentDefinition) {
    if (fragmentDefinition.kind === "FragmentDefinition") {
      var fragmentName = fragmentDefinition.name.value;
      var sourceKey = cacheKeyFromLoc(fragmentDefinition.loc);
      var sourceKeySet = fragmentSourceMap.get(fragmentName);
      if (sourceKeySet && !sourceKeySet.has(sourceKey)) {
        if (printFragmentWarnings) {
          console.warn("Warning: fragment with name " + fragmentName + " already exists.\ngraphql-tag enforces all fragment names across your application to be unique; read more about\nthis in the docs: http://dev.apollodata.com/core/fragments.html#unique-names");
        }
      } else if (!sourceKeySet) {
        fragmentSourceMap.set(fragmentName, sourceKeySet = /* @__PURE__ */ new Set());
      }
      sourceKeySet.add(sourceKey);
      if (!seenKeys.has(sourceKey)) {
        seenKeys.add(sourceKey);
        definitions.push(fragmentDefinition);
      }
    } else {
      definitions.push(fragmentDefinition);
    }
  });
  return __assign(__assign({}, ast), { definitions });
}
function stripLoc(doc) {
  var workSet = new Set(doc.definitions);
  workSet.forEach(function(node) {
    if (node.loc)
      delete node.loc;
    Object.keys(node).forEach(function(key) {
      var value = node[key];
      if (value && typeof value === "object") {
        workSet.add(value);
      }
    });
  });
  var loc = doc.loc;
  if (loc) {
    delete loc.startToken;
    delete loc.endToken;
  }
  return doc;
}
function parseDocument(source) {
  var cacheKey = normalize3(source);
  if (!docCache.has(cacheKey)) {
    var parsed = parse(source, {
      experimentalFragmentVariables,
      allowLegacyFragmentVariables: experimentalFragmentVariables
    });
    if (!parsed || parsed.kind !== "Document") {
      throw new Error("Not a valid GraphQL document.");
    }
    docCache.set(cacheKey, stripLoc(processFragments(parsed)));
  }
  return docCache.get(cacheKey);
}
function gql(literals) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  if (typeof literals === "string") {
    literals = [literals];
  }
  var result = literals[0];
  args.forEach(function(arg, i15) {
    if (arg && arg.kind === "Document") {
      result += arg.loc.source.body;
    } else {
      result += arg;
    }
    result += literals[i15 + 1];
  });
  return parseDocument(result);
}
function resetCaches() {
  docCache.clear();
  fragmentSourceMap.clear();
}
function disableFragmentWarnings() {
  printFragmentWarnings = false;
}
function enableExperimentalFragmentVariables() {
  experimentalFragmentVariables = true;
}
function disableExperimentalFragmentVariables() {
  experimentalFragmentVariables = false;
}
var extras = {
  gql,
  resetCaches,
  disableFragmentWarnings,
  enableExperimentalFragmentVariables,
  disableExperimentalFragmentVariables
};
(function(gql_1) {
  gql_1.gql = extras.gql, gql_1.resetCaches = extras.resetCaches, gql_1.disableFragmentWarnings = extras.disableFragmentWarnings, gql_1.enableExperimentalFragmentVariables = extras.enableExperimentalFragmentVariables, gql_1.disableExperimentalFragmentVariables = extras.disableExperimentalFragmentVariables;
})(gql || (gql = {}));
gql["default"] = gql;
var lib_default = gql;

// node_modules/@tinacms/schema-tools/dist/index.es.js
var import_micromatch = __toESM(require_micromatch());

// node_modules/yup/es/index.js
var es_exports = {};
__export(es_exports, {
  ArraySchema: () => ArraySchema,
  BaseSchema: () => BaseSchema,
  BooleanSchema: () => BooleanSchema,
  DateSchema: () => DateSchema,
  MixedSchema: () => mixed_default,
  NumberSchema: () => NumberSchema,
  ObjectSchema: () => ObjectSchema,
  StringSchema: () => StringSchema,
  ValidationError: () => ValidationError,
  addMethod: () => addMethod,
  array: () => create12,
  bool: () => create7,
  boolean: () => create7,
  date: () => create10,
  isSchema: () => isSchema_default,
  lazy: () => create13,
  mixed: () => create6,
  number: () => create9,
  object: () => create11,
  reach: () => reach_default,
  ref: () => create5,
  setLocale: () => setLocale,
  string: () => create8
});

// node_modules/nanoclone/src/index.js
var map4;
try {
  map4 = Map;
} catch (_7) {
}
var set2;
try {
  set2 = Set;
} catch (_7) {
}
function baseClone4(src, circulars, clones) {
  if (!src || typeof src !== "object" || typeof src === "function") {
    return src;
  }
  if (src.nodeType && "cloneNode" in src) {
    return src.cloneNode(true);
  }
  if (src instanceof Date) {
    return new Date(src.getTime());
  }
  if (src instanceof RegExp) {
    return new RegExp(src);
  }
  if (Array.isArray(src)) {
    return src.map(clone3);
  }
  if (map4 && src instanceof map4) {
    return new Map(Array.from(src.entries()));
  }
  if (set2 && src instanceof set2) {
    return new Set(Array.from(src.values()));
  }
  if (src instanceof Object) {
    circulars.push(src);
    var obj = Object.create(src);
    clones.push(obj);
    for (var key in src) {
      var idx = circulars.findIndex(function(i15) {
        return i15 === src[key];
      });
      obj[key] = idx > -1 ? clones[idx] : baseClone4(src[key], circulars, clones);
    }
    return obj;
  }
  return src;
}
function clone3(src) {
  return baseClone4(src, [], []);
}

// node_modules/yup/es/util/printValue.js
var toString6 = Object.prototype.toString;
var errorToString = Error.prototype.toString;
var regExpToString = RegExp.prototype.toString;
var symbolToString4 = typeof Symbol !== "undefined" ? Symbol.prototype.toString : () => "";
var SYMBOL_REGEXP = /^Symbol\((.*)\)(.*)$/;
function printNumber(val) {
  if (val != +val)
    return "NaN";
  const isNegativeZero = val === 0 && 1 / val < 0;
  return isNegativeZero ? "-0" : "" + val;
}
function printSimpleValue(val, quoteStrings = false) {
  if (val == null || val === true || val === false)
    return "" + val;
  const typeOf = typeof val;
  if (typeOf === "number")
    return printNumber(val);
  if (typeOf === "string")
    return quoteStrings ? `"${val}"` : val;
  if (typeOf === "function")
    return "[Function " + (val.name || "anonymous") + "]";
  if (typeOf === "symbol")
    return symbolToString4.call(val).replace(SYMBOL_REGEXP, "Symbol($1)");
  const tag = toString6.call(val).slice(8, -1);
  if (tag === "Date")
    return isNaN(val.getTime()) ? "" + val : val.toISOString(val);
  if (tag === "Error" || val instanceof Error)
    return "[" + errorToString.call(val) + "]";
  if (tag === "RegExp")
    return regExpToString.call(val);
  return null;
}
function printValue(value, quoteStrings) {
  let result = printSimpleValue(value, quoteStrings);
  if (result !== null)
    return result;
  return JSON.stringify(value, function(key, value2) {
    let result2 = printSimpleValue(this[key], quoteStrings);
    if (result2 !== null)
      return result2;
    return value2;
  }, 2);
}

// node_modules/yup/es/locale.js
var mixed = {
  default: "${path} is invalid",
  required: "${path} is a required field",
  oneOf: "${path} must be one of the following values: ${values}",
  notOneOf: "${path} must not be one of the following values: ${values}",
  notType: ({
    path,
    type,
    value,
    originalValue
  }) => {
    let isCast = originalValue != null && originalValue !== value;
    let msg = `${path} must be a \`${type}\` type, but the final value was: \`${printValue(value, true)}\`` + (isCast ? ` (cast from the value \`${printValue(originalValue, true)}\`).` : ".");
    if (value === null) {
      msg += `
 If "null" is intended as an empty value be sure to mark the schema as \`.nullable()\``;
    }
    return msg;
  },
  defined: "${path} must be defined"
};
var string = {
  length: "${path} must be exactly ${length} characters",
  min: "${path} must be at least ${min} characters",
  max: "${path} must be at most ${max} characters",
  matches: '${path} must match the following: "${regex}"',
  email: "${path} must be a valid email",
  url: "${path} must be a valid URL",
  uuid: "${path} must be a valid UUID",
  trim: "${path} must be a trimmed string",
  lowercase: "${path} must be a lowercase string",
  uppercase: "${path} must be a upper case string"
};
var number = {
  min: "${path} must be greater than or equal to ${min}",
  max: "${path} must be less than or equal to ${max}",
  lessThan: "${path} must be less than ${less}",
  moreThan: "${path} must be greater than ${more}",
  positive: "${path} must be a positive number",
  negative: "${path} must be a negative number",
  integer: "${path} must be an integer"
};
var date = {
  min: "${path} field must be later than ${min}",
  max: "${path} field must be at earlier than ${max}"
};
var boolean = {
  isValue: "${path} field must be ${value}"
};
var object = {
  noUnknown: "${path} field has unspecified keys: ${unknown}"
};
var array = {
  min: "${path} field must have at least ${min} items",
  max: "${path} field must have less than or equal to ${max} items",
  length: "${path} must have ${length} items"
};
var locale_default = Object.assign(/* @__PURE__ */ Object.create(null), {
  mixed,
  string,
  number,
  date,
  object,
  array,
  boolean
});

// node_modules/yup/es/Condition.js
var import_has = __toESM(require_has());

// node_modules/yup/es/util/isSchema.js
var isSchema = (obj) => obj && obj.__isYupSchema__;
var isSchema_default = isSchema;

// node_modules/yup/es/Condition.js
var Condition = class {
  constructor(refs, options) {
    this.fn = void 0;
    this.refs = refs;
    this.refs = refs;
    if (typeof options === "function") {
      this.fn = options;
      return;
    }
    if (!(0, import_has.default)(options, "is"))
      throw new TypeError("`is:` is required for `when()` conditions");
    if (!options.then && !options.otherwise)
      throw new TypeError("either `then:` or `otherwise:` is required for `when()` conditions");
    let {
      is: is3,
      then,
      otherwise
    } = options;
    let check = typeof is3 === "function" ? is3 : (...values3) => values3.every((value) => value === is3);
    this.fn = function(...args) {
      let options2 = args.pop();
      let schema = args.pop();
      let branch = check(...args) ? then : otherwise;
      if (!branch)
        return void 0;
      if (typeof branch === "function")
        return branch(schema);
      return schema.concat(branch.resolve(options2));
    };
  }
  resolve(base, options) {
    let values3 = this.refs.map((ref2) => ref2.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context));
    let schema = this.fn.apply(base, values3.concat(base, options));
    if (schema === void 0 || schema === base)
      return base;
    if (!isSchema_default(schema))
      throw new TypeError("conditions must return a schema object");
    return schema.resolve(options);
  }
};
var Condition_default = Condition;

// node_modules/yup/es/util/toArray.js
function toArray3(value) {
  return value == null ? [] : [].concat(value);
}

// node_modules/yup/es/ValidationError.js
function _extends16() {
  _extends16 = Object.assign || function(target) {
    for (var i15 = 1; i15 < arguments.length; i15++) {
      var source = arguments[i15];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends16.apply(this, arguments);
}
var strReg = /\$\{\s*(\w+)\s*\}/g;
var ValidationError = class extends Error {
  static formatError(message, params) {
    const path = params.label || params.path || "this";
    if (path !== params.path)
      params = _extends16({}, params, {
        path
      });
    if (typeof message === "string")
      return message.replace(strReg, (_7, key) => printValue(params[key]));
    if (typeof message === "function")
      return message(params);
    return message;
  }
  static isError(err) {
    return err && err.name === "ValidationError";
  }
  constructor(errorOrErrors, value, field, type) {
    super();
    this.value = void 0;
    this.path = void 0;
    this.type = void 0;
    this.errors = void 0;
    this.params = void 0;
    this.inner = void 0;
    this.name = "ValidationError";
    this.value = value;
    this.path = field;
    this.type = type;
    this.errors = [];
    this.inner = [];
    toArray3(errorOrErrors).forEach((err) => {
      if (ValidationError.isError(err)) {
        this.errors.push(...err.errors);
        this.inner = this.inner.concat(err.inner.length ? err.inner : err);
      } else {
        this.errors.push(err);
      }
    });
    this.message = this.errors.length > 1 ? `${this.errors.length} errors occurred` : this.errors[0];
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, ValidationError);
  }
};

// node_modules/yup/es/util/runTests.js
var once = (cb) => {
  let fired = false;
  return (...args) => {
    if (fired)
      return;
    fired = true;
    cb(...args);
  };
};
function runTests(options, cb) {
  let {
    endEarly,
    tests,
    args,
    value,
    errors,
    sort,
    path
  } = options;
  let callback = once(cb);
  let count2 = tests.length;
  const nestedErrors = [];
  errors = errors ? errors : [];
  if (!count2)
    return errors.length ? callback(new ValidationError(errors, value, path)) : callback(null, value);
  for (let i15 = 0; i15 < tests.length; i15++) {
    const test = tests[i15];
    test(args, function finishTestRun(err) {
      if (err) {
        if (!ValidationError.isError(err)) {
          return callback(err, value);
        }
        if (endEarly) {
          err.value = value;
          return callback(err, value);
        }
        nestedErrors.push(err);
      }
      if (--count2 <= 0) {
        if (nestedErrors.length) {
          if (sort)
            nestedErrors.sort(sort);
          if (errors.length)
            nestedErrors.push(...errors);
          errors = nestedErrors;
        }
        if (errors.length) {
          callback(new ValidationError(errors, value, path), value);
          return;
        }
        callback(null, value);
      }
    });
  }
}

// node_modules/yup/es/util/createValidation.js
var import_mapValues = __toESM(require_mapValues());

// node_modules/yup/es/Reference.js
var import_property_expr = __toESM(require_property_expr());
var prefixes = {
  context: "$",
  value: "."
};
function create5(key, options) {
  return new Reference2(key, options);
}
var Reference2 = class {
  constructor(key, options = {}) {
    this.key = void 0;
    this.isContext = void 0;
    this.isValue = void 0;
    this.isSibling = void 0;
    this.path = void 0;
    this.getter = void 0;
    this.map = void 0;
    if (typeof key !== "string")
      throw new TypeError("ref must be a string, got: " + key);
    this.key = key.trim();
    if (key === "")
      throw new TypeError("ref must be a non-empty string");
    this.isContext = this.key[0] === prefixes.context;
    this.isValue = this.key[0] === prefixes.value;
    this.isSibling = !this.isContext && !this.isValue;
    let prefix3 = this.isContext ? prefixes.context : this.isValue ? prefixes.value : "";
    this.path = this.key.slice(prefix3.length);
    this.getter = this.path && (0, import_property_expr.getter)(this.path, true);
    this.map = options.map;
  }
  getValue(value, parent2, context) {
    let result = this.isContext ? context : this.isValue ? value : parent2;
    if (this.getter)
      result = this.getter(result || {});
    if (this.map)
      result = this.map(result);
    return result;
  }
  /**
   *
   * @param {*} value
   * @param {Object} options
   * @param {Object=} options.context
   * @param {Object=} options.parent
   */
  cast(value, options) {
    return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);
  }
  resolve() {
    return this;
  }
  describe() {
    return {
      type: "ref",
      key: this.key
    };
  }
  toString() {
    return `Ref(${this.key})`;
  }
  static isRef(value) {
    return value && value.__isYupRef;
  }
};
Reference2.prototype.__isYupRef = true;

// node_modules/yup/es/util/createValidation.js
function _extends17() {
  _extends17 = Object.assign || function(target) {
    for (var i15 = 1; i15 < arguments.length; i15++) {
      var source = arguments[i15];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends17.apply(this, arguments);
}
function _objectWithoutPropertiesLoose6(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i15;
  for (i15 = 0; i15 < sourceKeys.length; i15++) {
    key = sourceKeys[i15];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function createValidation(config2) {
  function validate3(_ref, cb) {
    let {
      value,
      path = "",
      label,
      options,
      originalValue,
      sync
    } = _ref, rest = _objectWithoutPropertiesLoose6(_ref, ["value", "path", "label", "options", "originalValue", "sync"]);
    const {
      name: name2,
      test,
      params,
      message
    } = config2;
    let {
      parent: parent2,
      context
    } = options;
    function resolve(item) {
      return Reference2.isRef(item) ? item.getValue(value, parent2, context) : item;
    }
    function createError(overrides = {}) {
      const nextParams = (0, import_mapValues.default)(_extends17({
        value,
        originalValue,
        label,
        path: overrides.path || path
      }, params, overrides.params), resolve);
      const error2 = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name2);
      error2.params = nextParams;
      return error2;
    }
    let ctx = _extends17({
      path,
      parent: parent2,
      type: name2,
      createError,
      resolve,
      options,
      originalValue
    }, rest);
    if (!sync) {
      try {
        Promise.resolve(test.call(ctx, value, ctx)).then((validOrError) => {
          if (ValidationError.isError(validOrError))
            cb(validOrError);
          else if (!validOrError)
            cb(createError());
          else
            cb(null, validOrError);
        }).catch(cb);
      } catch (err) {
        cb(err);
      }
      return;
    }
    let result;
    try {
      var _ref2;
      result = test.call(ctx, value, ctx);
      if (typeof ((_ref2 = result) == null ? void 0 : _ref2.then) === "function") {
        throw new Error(`Validation test of type: "${ctx.type}" returned a Promise during a synchronous validate. This test will finish after the validate call has returned`);
      }
    } catch (err) {
      cb(err);
      return;
    }
    if (ValidationError.isError(result))
      cb(result);
    else if (!result)
      cb(createError());
    else
      cb(null, result);
  }
  validate3.OPTIONS = config2;
  return validate3;
}

// node_modules/yup/es/util/reach.js
var import_property_expr2 = __toESM(require_property_expr());
var trim = (part) => part.substr(0, part.length - 1).substr(1);
function getIn3(schema, path, value, context = value) {
  let parent2, lastPart, lastPartDebug;
  if (!path)
    return {
      parent: parent2,
      parentPath: path,
      schema
    };
  (0, import_property_expr2.forEach)(path, (_part, isBracket, isArray10) => {
    let part = isBracket ? trim(_part) : _part;
    schema = schema.resolve({
      context,
      parent: parent2,
      value
    });
    if (schema.innerType) {
      let idx = isArray10 ? parseInt(part, 10) : 0;
      if (value && idx >= value.length) {
        throw new Error(`Yup.reach cannot resolve an array item at index: ${_part}, in the path: ${path}. because there is no value at that index. `);
      }
      parent2 = value;
      value = value && value[idx];
      schema = schema.innerType;
    }
    if (!isArray10) {
      if (!schema.fields || !schema.fields[part])
        throw new Error(`The schema does not contain the path: ${path}. (failed at: ${lastPartDebug} which is a type: "${schema._type}")`);
      parent2 = value;
      value = value && value[part];
      schema = schema.fields[part];
    }
    lastPart = part;
    lastPartDebug = isBracket ? "[" + _part + "]" : "." + _part;
  });
  return {
    schema,
    parent: parent2,
    parentPath: lastPart
  };
}
var reach = (obj, path, value, context) => getIn3(obj, path, value, context).schema;
var reach_default = reach;

// node_modules/yup/es/util/ReferenceSet.js
var ReferenceSet = class {
  constructor() {
    this.list = void 0;
    this.refs = void 0;
    this.list = /* @__PURE__ */ new Set();
    this.refs = /* @__PURE__ */ new Map();
  }
  get size() {
    return this.list.size + this.refs.size;
  }
  describe() {
    const description = [];
    for (const item of this.list)
      description.push(item);
    for (const [, ref2] of this.refs)
      description.push(ref2.describe());
    return description;
  }
  toArray() {
    return Array.from(this.list).concat(Array.from(this.refs.values()));
  }
  resolveAll(resolve) {
    return this.toArray().reduce((acc, e9) => acc.concat(Reference2.isRef(e9) ? resolve(e9) : e9), []);
  }
  add(value) {
    Reference2.isRef(value) ? this.refs.set(value.key, value) : this.list.add(value);
  }
  delete(value) {
    Reference2.isRef(value) ? this.refs.delete(value.key) : this.list.delete(value);
  }
  clone() {
    const next = new ReferenceSet();
    next.list = new Set(this.list);
    next.refs = new Map(this.refs);
    return next;
  }
  merge(newItems, removeItems) {
    const next = this.clone();
    newItems.list.forEach((value) => next.add(value));
    newItems.refs.forEach((value) => next.add(value));
    removeItems.list.forEach((value) => next.delete(value));
    removeItems.refs.forEach((value) => next.delete(value));
    return next;
  }
};

// node_modules/yup/es/schema.js
function _extends18() {
  _extends18 = Object.assign || function(target) {
    for (var i15 = 1; i15 < arguments.length; i15++) {
      var source = arguments[i15];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends18.apply(this, arguments);
}
var BaseSchema = class {
  constructor(options) {
    this.deps = [];
    this.tests = void 0;
    this.transforms = void 0;
    this.conditions = [];
    this._mutate = void 0;
    this._typeError = void 0;
    this._whitelist = new ReferenceSet();
    this._blacklist = new ReferenceSet();
    this.exclusiveTests = /* @__PURE__ */ Object.create(null);
    this.spec = void 0;
    this.tests = [];
    this.transforms = [];
    this.withMutation(() => {
      this.typeError(mixed.notType);
    });
    this.type = (options == null ? void 0 : options.type) || "mixed";
    this.spec = _extends18({
      strip: false,
      strict: false,
      abortEarly: true,
      recursive: true,
      nullable: false,
      presence: "optional"
    }, options == null ? void 0 : options.spec);
  }
  // TODO: remove
  get _type() {
    return this.type;
  }
  _typeCheck(_value) {
    return true;
  }
  clone(spec) {
    if (this._mutate) {
      if (spec)
        Object.assign(this.spec, spec);
      return this;
    }
    const next = Object.create(Object.getPrototypeOf(this));
    next.type = this.type;
    next._typeError = this._typeError;
    next._whitelistError = this._whitelistError;
    next._blacklistError = this._blacklistError;
    next._whitelist = this._whitelist.clone();
    next._blacklist = this._blacklist.clone();
    next.exclusiveTests = _extends18({}, this.exclusiveTests);
    next.deps = [...this.deps];
    next.conditions = [...this.conditions];
    next.tests = [...this.tests];
    next.transforms = [...this.transforms];
    next.spec = clone3(_extends18({}, this.spec, spec));
    return next;
  }
  label(label) {
    let next = this.clone();
    next.spec.label = label;
    return next;
  }
  meta(...args) {
    if (args.length === 0)
      return this.spec.meta;
    let next = this.clone();
    next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);
    return next;
  }
  // withContext<TContext extends AnyObject>(): BaseSchema<
  //   TCast,
  //   TContext,
  //   TOutput
  // > {
  //   return this as any;
  // }
  withMutation(fn2) {
    let before = this._mutate;
    this._mutate = true;
    let result = fn2(this);
    this._mutate = before;
    return result;
  }
  concat(schema) {
    if (!schema || schema === this)
      return this;
    if (schema.type !== this.type && this.type !== "mixed")
      throw new TypeError(`You cannot \`concat()\` schema's of different types: ${this.type} and ${schema.type}`);
    let base = this;
    let combined = schema.clone();
    const mergedSpec = _extends18({}, base.spec, combined.spec);
    combined.spec = mergedSpec;
    combined._typeError || (combined._typeError = base._typeError);
    combined._whitelistError || (combined._whitelistError = base._whitelistError);
    combined._blacklistError || (combined._blacklistError = base._blacklistError);
    combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);
    combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);
    combined.tests = base.tests;
    combined.exclusiveTests = base.exclusiveTests;
    combined.withMutation((next) => {
      schema.tests.forEach((fn2) => {
        next.test(fn2.OPTIONS);
      });
    });
    combined.transforms = [...base.transforms, ...combined.transforms];
    return combined;
  }
  isType(v6) {
    if (this.spec.nullable && v6 === null)
      return true;
    return this._typeCheck(v6);
  }
  resolve(options) {
    let schema = this;
    if (schema.conditions.length) {
      let conditions = schema.conditions;
      schema = schema.clone();
      schema.conditions = [];
      schema = conditions.reduce((schema2, condition) => condition.resolve(schema2, options), schema);
      schema = schema.resolve(options);
    }
    return schema;
  }
  /**
   *
   * @param {*} value
   * @param {Object} options
   * @param {*=} options.parent
   * @param {*=} options.context
   */
  cast(value, options = {}) {
    let resolvedSchema = this.resolve(_extends18({
      value
    }, options));
    let result = resolvedSchema._cast(value, options);
    if (value !== void 0 && options.assert !== false && resolvedSchema.isType(result) !== true) {
      let formattedValue = printValue(value);
      let formattedResult = printValue(result);
      throw new TypeError(`The value of ${options.path || "field"} could not be cast to a value that satisfies the schema type: "${resolvedSchema._type}". 

attempted value: ${formattedValue} 
` + (formattedResult !== formattedValue ? `result of cast: ${formattedResult}` : ""));
    }
    return result;
  }
  _cast(rawValue, _options) {
    let value = rawValue === void 0 ? rawValue : this.transforms.reduce((value2, fn2) => fn2.call(this, value2, rawValue, this), rawValue);
    if (value === void 0) {
      value = this.getDefault();
    }
    return value;
  }
  _validate(_value, options = {}, cb) {
    let {
      sync,
      path,
      from: from2 = [],
      originalValue = _value,
      strict = this.spec.strict,
      abortEarly = this.spec.abortEarly
    } = options;
    let value = _value;
    if (!strict) {
      value = this._cast(value, _extends18({
        assert: false
      }, options));
    }
    let args = {
      value,
      path,
      options,
      originalValue,
      schema: this,
      label: this.spec.label,
      sync,
      from: from2
    };
    let initialTests = [];
    if (this._typeError)
      initialTests.push(this._typeError);
    let finalTests = [];
    if (this._whitelistError)
      finalTests.push(this._whitelistError);
    if (this._blacklistError)
      finalTests.push(this._blacklistError);
    runTests({
      args,
      value,
      path,
      sync,
      tests: initialTests,
      endEarly: abortEarly
    }, (err) => {
      if (err)
        return void cb(err, value);
      runTests({
        tests: this.tests.concat(finalTests),
        args,
        path,
        sync,
        value,
        endEarly: abortEarly
      }, cb);
    });
  }
  validate(value, options, maybeCb) {
    let schema = this.resolve(_extends18({}, options, {
      value
    }));
    return typeof maybeCb === "function" ? schema._validate(value, options, maybeCb) : new Promise((resolve, reject) => schema._validate(value, options, (err, value2) => {
      if (err)
        reject(err);
      else
        resolve(value2);
    }));
  }
  validateSync(value, options) {
    let schema = this.resolve(_extends18({}, options, {
      value
    }));
    let result;
    schema._validate(value, _extends18({}, options, {
      sync: true
    }), (err, value2) => {
      if (err)
        throw err;
      result = value2;
    });
    return result;
  }
  isValid(value, options) {
    return this.validate(value, options).then(() => true, (err) => {
      if (ValidationError.isError(err))
        return false;
      throw err;
    });
  }
  isValidSync(value, options) {
    try {
      this.validateSync(value, options);
      return true;
    } catch (err) {
      if (ValidationError.isError(err))
        return false;
      throw err;
    }
  }
  _getDefault() {
    let defaultValue = this.spec.default;
    if (defaultValue == null) {
      return defaultValue;
    }
    return typeof defaultValue === "function" ? defaultValue.call(this) : clone3(defaultValue);
  }
  getDefault(options) {
    let schema = this.resolve(options || {});
    return schema._getDefault();
  }
  default(def) {
    if (arguments.length === 0) {
      return this._getDefault();
    }
    let next = this.clone({
      default: def
    });
    return next;
  }
  strict(isStrict = true) {
    let next = this.clone();
    next.spec.strict = isStrict;
    return next;
  }
  _isPresent(value) {
    return value != null;
  }
  defined(message = mixed.defined) {
    return this.test({
      message,
      name: "defined",
      exclusive: true,
      test(value) {
        return value !== void 0;
      }
    });
  }
  required(message = mixed.required) {
    return this.clone({
      presence: "required"
    }).withMutation((s20) => s20.test({
      message,
      name: "required",
      exclusive: true,
      test(value) {
        return this.schema._isPresent(value);
      }
    }));
  }
  notRequired() {
    let next = this.clone({
      presence: "optional"
    });
    next.tests = next.tests.filter((test) => test.OPTIONS.name !== "required");
    return next;
  }
  nullable(isNullable = true) {
    let next = this.clone({
      nullable: isNullable !== false
    });
    return next;
  }
  transform(fn2) {
    let next = this.clone();
    next.transforms.push(fn2);
    return next;
  }
  /**
   * Adds a test function to the schema's queue of tests.
   * tests can be exclusive or non-exclusive.
   *
   * - exclusive tests, will replace any existing tests of the same name.
   * - non-exclusive: can be stacked
   *
   * If a non-exclusive test is added to a schema with an exclusive test of the same name
   * the exclusive test is removed and further tests of the same name will be stacked.
   *
   * If an exclusive test is added to a schema with non-exclusive tests of the same name
   * the previous tests are removed and further tests of the same name will replace each other.
   */
  test(...args) {
    let opts;
    if (args.length === 1) {
      if (typeof args[0] === "function") {
        opts = {
          test: args[0]
        };
      } else {
        opts = args[0];
      }
    } else if (args.length === 2) {
      opts = {
        name: args[0],
        test: args[1]
      };
    } else {
      opts = {
        name: args[0],
        message: args[1],
        test: args[2]
      };
    }
    if (opts.message === void 0)
      opts.message = mixed.default;
    if (typeof opts.test !== "function")
      throw new TypeError("`test` is a required parameters");
    let next = this.clone();
    let validate3 = createValidation(opts);
    let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;
    if (opts.exclusive) {
      if (!opts.name)
        throw new TypeError("Exclusive tests must provide a unique `name` identifying the test");
    }
    if (opts.name)
      next.exclusiveTests[opts.name] = !!opts.exclusive;
    next.tests = next.tests.filter((fn2) => {
      if (fn2.OPTIONS.name === opts.name) {
        if (isExclusive)
          return false;
        if (fn2.OPTIONS.test === validate3.OPTIONS.test)
          return false;
      }
      return true;
    });
    next.tests.push(validate3);
    return next;
  }
  when(keys6, options) {
    if (!Array.isArray(keys6) && typeof keys6 !== "string") {
      options = keys6;
      keys6 = ".";
    }
    let next = this.clone();
    let deps = toArray3(keys6).map((key) => new Reference2(key));
    deps.forEach((dep) => {
      if (dep.isSibling)
        next.deps.push(dep.key);
    });
    next.conditions.push(new Condition_default(deps, options));
    return next;
  }
  typeError(message) {
    let next = this.clone();
    next._typeError = createValidation({
      message,
      name: "typeError",
      test(value) {
        if (value !== void 0 && !this.schema.isType(value))
          return this.createError({
            params: {
              type: this.schema._type
            }
          });
        return true;
      }
    });
    return next;
  }
  oneOf(enums, message = mixed.oneOf) {
    let next = this.clone();
    enums.forEach((val) => {
      next._whitelist.add(val);
      next._blacklist.delete(val);
    });
    next._whitelistError = createValidation({
      message,
      name: "oneOf",
      test(value) {
        if (value === void 0)
          return true;
        let valids = this.schema._whitelist;
        let resolved = valids.resolveAll(this.resolve);
        return resolved.includes(value) ? true : this.createError({
          params: {
            values: valids.toArray().join(", "),
            resolved
          }
        });
      }
    });
    return next;
  }
  notOneOf(enums, message = mixed.notOneOf) {
    let next = this.clone();
    enums.forEach((val) => {
      next._blacklist.add(val);
      next._whitelist.delete(val);
    });
    next._blacklistError = createValidation({
      message,
      name: "notOneOf",
      test(value) {
        let invalids = this.schema._blacklist;
        let resolved = invalids.resolveAll(this.resolve);
        if (resolved.includes(value))
          return this.createError({
            params: {
              values: invalids.toArray().join(", "),
              resolved
            }
          });
        return true;
      }
    });
    return next;
  }
  strip(strip = true) {
    let next = this.clone();
    next.spec.strip = strip;
    return next;
  }
  describe() {
    const next = this.clone();
    const {
      label,
      meta
    } = next.spec;
    const description = {
      meta,
      label,
      type: next.type,
      oneOf: next._whitelist.describe(),
      notOneOf: next._blacklist.describe(),
      tests: next.tests.map((fn2) => ({
        name: fn2.OPTIONS.name,
        params: fn2.OPTIONS.params
      })).filter((n12, idx, list) => list.findIndex((c16) => c16.name === n12.name) === idx)
    };
    return description;
  }
};
BaseSchema.prototype.__isYupSchema__ = true;
for (const method of ["validate", "validateSync"])
  BaseSchema.prototype[`${method}At`] = function(path, value, options = {}) {
    const {
      parent: parent2,
      parentPath,
      schema
    } = getIn3(this, path, value, options.context);
    return schema[method](parent2 && parent2[parentPath], _extends18({}, options, {
      parent: parent2,
      path
    }));
  };
for (const alias of ["equals", "is"])
  BaseSchema.prototype[alias] = BaseSchema.prototype.oneOf;
for (const alias of ["not", "nope"])
  BaseSchema.prototype[alias] = BaseSchema.prototype.notOneOf;
BaseSchema.prototype.optional = BaseSchema.prototype.notRequired;

// node_modules/yup/es/mixed.js
var Mixed = BaseSchema;
var mixed_default = Mixed;
function create6() {
  return new Mixed();
}
create6.prototype = Mixed.prototype;

// node_modules/yup/es/util/isAbsent.js
var isAbsent = (value) => value == null;
var isAbsent_default = isAbsent;

// node_modules/yup/es/boolean.js
function create7() {
  return new BooleanSchema();
}
var BooleanSchema = class extends BaseSchema {
  constructor() {
    super({
      type: "boolean"
    });
    this.withMutation(() => {
      this.transform(function(value) {
        if (!this.isType(value)) {
          if (/^(true|1)$/i.test(String(value)))
            return true;
          if (/^(false|0)$/i.test(String(value)))
            return false;
        }
        return value;
      });
    });
  }
  _typeCheck(v6) {
    if (v6 instanceof Boolean)
      v6 = v6.valueOf();
    return typeof v6 === "boolean";
  }
  isTrue(message = boolean.isValue) {
    return this.test({
      message,
      name: "is-value",
      exclusive: true,
      params: {
        value: "true"
      },
      test(value) {
        return isAbsent_default(value) || value === true;
      }
    });
  }
  isFalse(message = boolean.isValue) {
    return this.test({
      message,
      name: "is-value",
      exclusive: true,
      params: {
        value: "false"
      },
      test(value) {
        return isAbsent_default(value) || value === false;
      }
    });
  }
};
create7.prototype = BooleanSchema.prototype;

// node_modules/yup/es/string.js
var rEmail = /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i;
var rUrl = /^((https?|ftp):)?\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i;
var rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
var isTrimmed = (value) => isAbsent_default(value) || value === value.trim();
var objStringTag = {}.toString();
function create8() {
  return new StringSchema();
}
var StringSchema = class extends BaseSchema {
  constructor() {
    super({
      type: "string"
    });
    this.withMutation(() => {
      this.transform(function(value) {
        if (this.isType(value))
          return value;
        if (Array.isArray(value))
          return value;
        const strValue = value != null && value.toString ? value.toString() : value;
        if (strValue === objStringTag)
          return value;
        return strValue;
      });
    });
  }
  _typeCheck(value) {
    if (value instanceof String)
      value = value.valueOf();
    return typeof value === "string";
  }
  _isPresent(value) {
    return super._isPresent(value) && !!value.length;
  }
  length(length, message = string.length) {
    return this.test({
      message,
      name: "length",
      exclusive: true,
      params: {
        length
      },
      test(value) {
        return isAbsent_default(value) || value.length === this.resolve(length);
      }
    });
  }
  min(min4, message = string.min) {
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        min: min4
      },
      test(value) {
        return isAbsent_default(value) || value.length >= this.resolve(min4);
      }
    });
  }
  max(max4, message = string.max) {
    return this.test({
      name: "max",
      exclusive: true,
      message,
      params: {
        max: max4
      },
      test(value) {
        return isAbsent_default(value) || value.length <= this.resolve(max4);
      }
    });
  }
  matches(regex, options) {
    let excludeEmptyString = false;
    let message;
    let name2;
    if (options) {
      if (typeof options === "object") {
        ({
          excludeEmptyString = false,
          message,
          name: name2
        } = options);
      } else {
        message = options;
      }
    }
    return this.test({
      name: name2 || "matches",
      message: message || string.matches,
      params: {
        regex
      },
      test: (value) => isAbsent_default(value) || value === "" && excludeEmptyString || value.search(regex) !== -1
    });
  }
  email(message = string.email) {
    return this.matches(rEmail, {
      name: "email",
      message,
      excludeEmptyString: true
    });
  }
  url(message = string.url) {
    return this.matches(rUrl, {
      name: "url",
      message,
      excludeEmptyString: true
    });
  }
  uuid(message = string.uuid) {
    return this.matches(rUUID, {
      name: "uuid",
      message,
      excludeEmptyString: false
    });
  }
  //-- transforms --
  ensure() {
    return this.default("").transform((val) => val === null ? "" : val);
  }
  trim(message = string.trim) {
    return this.transform((val) => val != null ? val.trim() : val).test({
      message,
      name: "trim",
      test: isTrimmed
    });
  }
  lowercase(message = string.lowercase) {
    return this.transform((value) => !isAbsent_default(value) ? value.toLowerCase() : value).test({
      message,
      name: "string_case",
      exclusive: true,
      test: (value) => isAbsent_default(value) || value === value.toLowerCase()
    });
  }
  uppercase(message = string.uppercase) {
    return this.transform((value) => !isAbsent_default(value) ? value.toUpperCase() : value).test({
      message,
      name: "string_case",
      exclusive: true,
      test: (value) => isAbsent_default(value) || value === value.toUpperCase()
    });
  }
};
create8.prototype = StringSchema.prototype;

// node_modules/yup/es/number.js
var isNaN2 = (value) => value != +value;
function create9() {
  return new NumberSchema();
}
var NumberSchema = class extends BaseSchema {
  constructor() {
    super({
      type: "number"
    });
    this.withMutation(() => {
      this.transform(function(value) {
        let parsed = value;
        if (typeof parsed === "string") {
          parsed = parsed.replace(/\s/g, "");
          if (parsed === "")
            return NaN;
          parsed = +parsed;
        }
        if (this.isType(parsed))
          return parsed;
        return parseFloat(parsed);
      });
    });
  }
  _typeCheck(value) {
    if (value instanceof Number)
      value = value.valueOf();
    return typeof value === "number" && !isNaN2(value);
  }
  min(min4, message = number.min) {
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        min: min4
      },
      test(value) {
        return isAbsent_default(value) || value >= this.resolve(min4);
      }
    });
  }
  max(max4, message = number.max) {
    return this.test({
      message,
      name: "max",
      exclusive: true,
      params: {
        max: max4
      },
      test(value) {
        return isAbsent_default(value) || value <= this.resolve(max4);
      }
    });
  }
  lessThan(less, message = number.lessThan) {
    return this.test({
      message,
      name: "max",
      exclusive: true,
      params: {
        less
      },
      test(value) {
        return isAbsent_default(value) || value < this.resolve(less);
      }
    });
  }
  moreThan(more, message = number.moreThan) {
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        more
      },
      test(value) {
        return isAbsent_default(value) || value > this.resolve(more);
      }
    });
  }
  positive(msg = number.positive) {
    return this.moreThan(0, msg);
  }
  negative(msg = number.negative) {
    return this.lessThan(0, msg);
  }
  integer(message = number.integer) {
    return this.test({
      name: "integer",
      message,
      test: (val) => isAbsent_default(val) || Number.isInteger(val)
    });
  }
  truncate() {
    return this.transform((value) => !isAbsent_default(value) ? value | 0 : value);
  }
  round(method) {
    var _method;
    let avail = ["ceil", "floor", "round", "trunc"];
    method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || "round";
    if (method === "trunc")
      return this.truncate();
    if (avail.indexOf(method.toLowerCase()) === -1)
      throw new TypeError("Only valid options for round() are: " + avail.join(", "));
    return this.transform((value) => !isAbsent_default(value) ? Math[method](value) : value);
  }
};
create9.prototype = NumberSchema.prototype;

// node_modules/yup/es/util/isodate.js
var isoReg = /^(\d{4}|[+\-]\d{6})(?:-?(\d{2})(?:-?(\d{2}))?)?(?:[ T]?(\d{2}):?(\d{2})(?::?(\d{2})(?:[,\.](\d{1,}))?)?(?:(Z)|([+\-])(\d{2})(?::?(\d{2}))?)?)?$/;
function parseIsoDate(date2) {
  var numericKeys = [1, 4, 5, 6, 7, 10, 11], minutesOffset = 0, timestamp, struct;
  if (struct = isoReg.exec(date2)) {
    for (var i15 = 0, k3; k3 = numericKeys[i15]; ++i15)
      struct[k3] = +struct[k3] || 0;
    struct[2] = (+struct[2] || 1) - 1;
    struct[3] = +struct[3] || 1;
    struct[7] = struct[7] ? String(struct[7]).substr(0, 3) : 0;
    if ((struct[8] === void 0 || struct[8] === "") && (struct[9] === void 0 || struct[9] === ""))
      timestamp = +new Date(struct[1], struct[2], struct[3], struct[4], struct[5], struct[6], struct[7]);
    else {
      if (struct[8] !== "Z" && struct[9] !== void 0) {
        minutesOffset = struct[10] * 60 + struct[11];
        if (struct[9] === "+")
          minutesOffset = 0 - minutesOffset;
      }
      timestamp = Date.UTC(struct[1], struct[2], struct[3], struct[4], struct[5] + minutesOffset, struct[6], struct[7]);
    }
  } else
    timestamp = Date.parse ? Date.parse(date2) : NaN;
  return timestamp;
}

// node_modules/yup/es/date.js
var invalidDate2 = new Date("");
var isDate3 = (obj) => Object.prototype.toString.call(obj) === "[object Date]";
function create10() {
  return new DateSchema();
}
var DateSchema = class extends BaseSchema {
  constructor() {
    super({
      type: "date"
    });
    this.withMutation(() => {
      this.transform(function(value) {
        if (this.isType(value))
          return value;
        value = parseIsoDate(value);
        return !isNaN(value) ? new Date(value) : invalidDate2;
      });
    });
  }
  _typeCheck(v6) {
    return isDate3(v6) && !isNaN(v6.getTime());
  }
  prepareParam(ref2, name2) {
    let param;
    if (!Reference2.isRef(ref2)) {
      let cast = this.cast(ref2);
      if (!this._typeCheck(cast))
        throw new TypeError(`\`${name2}\` must be a Date or a value that can be \`cast()\` to a Date`);
      param = cast;
    } else {
      param = ref2;
    }
    return param;
  }
  min(min4, message = date.min) {
    let limit = this.prepareParam(min4, "min");
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        min: min4
      },
      test(value) {
        return isAbsent_default(value) || value >= this.resolve(limit);
      }
    });
  }
  max(max4, message = date.max) {
    let limit = this.prepareParam(max4, "max");
    return this.test({
      message,
      name: "max",
      exclusive: true,
      params: {
        max: max4
      },
      test(value) {
        return isAbsent_default(value) || value <= this.resolve(limit);
      }
    });
  }
};
DateSchema.INVALID_DATE = invalidDate2;
create10.prototype = DateSchema.prototype;
create10.INVALID_DATE = invalidDate2;

// node_modules/yup/es/object.js
var import_has3 = __toESM(require_has());
var import_snakeCase = __toESM(require_snakeCase());
var import_camelCase = __toESM(require_camelCase());
var import_mapKeys = __toESM(require_mapKeys());
var import_mapValues2 = __toESM(require_mapValues());
var import_property_expr4 = __toESM(require_property_expr());

// node_modules/yup/es/util/sortFields.js
var import_has2 = __toESM(require_has());
var import_toposort = __toESM(require_toposort());
var import_property_expr3 = __toESM(require_property_expr());
function sortFields(fields, excludedEdges = []) {
  let edges = [];
  let nodes = /* @__PURE__ */ new Set();
  let excludes = new Set(excludedEdges.map(([a13, b6]) => `${a13}-${b6}`));
  function addNode(depPath, key) {
    let node = (0, import_property_expr3.split)(depPath)[0];
    nodes.add(node);
    if (!excludes.has(`${key}-${node}`))
      edges.push([key, node]);
  }
  for (const key in fields)
    if ((0, import_has2.default)(fields, key)) {
      let value = fields[key];
      nodes.add(key);
      if (Reference2.isRef(value) && value.isSibling)
        addNode(value.path, key);
      else if (isSchema_default(value) && "deps" in value)
        value.deps.forEach((path) => addNode(path, key));
    }
  return import_toposort.default.array(Array.from(nodes), edges).reverse();
}

// node_modules/yup/es/util/sortByKeyOrder.js
function findIndex2(arr, err) {
  let idx = Infinity;
  arr.some((key, ii) => {
    var _err$path;
    if (((_err$path = err.path) == null ? void 0 : _err$path.indexOf(key)) !== -1) {
      idx = ii;
      return true;
    }
  });
  return idx;
}
function sortByKeyOrder(keys6) {
  return (a13, b6) => {
    return findIndex2(keys6, a13) - findIndex2(keys6, b6);
  };
}

// node_modules/yup/es/object.js
function _extends19() {
  _extends19 = Object.assign || function(target) {
    for (var i15 = 1; i15 < arguments.length; i15++) {
      var source = arguments[i15];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends19.apply(this, arguments);
}
var isObject9 = (obj) => Object.prototype.toString.call(obj) === "[object Object]";
function unknown2(ctx, value) {
  let known = Object.keys(ctx.fields);
  return Object.keys(value).filter((key) => known.indexOf(key) === -1);
}
var defaultSort = sortByKeyOrder([]);
var ObjectSchema = class extends BaseSchema {
  constructor(spec) {
    super({
      type: "object"
    });
    this.fields = /* @__PURE__ */ Object.create(null);
    this._sortErrors = defaultSort;
    this._nodes = [];
    this._excludedEdges = [];
    this.withMutation(() => {
      this.transform(function coerce2(value) {
        if (typeof value === "string") {
          try {
            value = JSON.parse(value);
          } catch (err) {
            value = null;
          }
        }
        if (this.isType(value))
          return value;
        return null;
      });
      if (spec) {
        this.shape(spec);
      }
    });
  }
  _typeCheck(value) {
    return isObject9(value) || typeof value === "function";
  }
  _cast(_value, options = {}) {
    var _options$stripUnknown;
    let value = super._cast(_value, options);
    if (value === void 0)
      return this.getDefault();
    if (!this._typeCheck(value))
      return value;
    let fields = this.fields;
    let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;
    let props = this._nodes.concat(Object.keys(value).filter((v6) => this._nodes.indexOf(v6) === -1));
    let intermediateValue = {};
    let innerOptions = _extends19({}, options, {
      parent: intermediateValue,
      __validating: options.__validating || false
    });
    let isChanged = false;
    for (const prop of props) {
      let field = fields[prop];
      let exists = (0, import_has3.default)(value, prop);
      if (field) {
        let fieldValue;
        let inputValue = value[prop];
        innerOptions.path = (options.path ? `${options.path}.` : "") + prop;
        field = field.resolve({
          value: inputValue,
          context: options.context,
          parent: intermediateValue
        });
        let fieldSpec = "spec" in field ? field.spec : void 0;
        let strict = fieldSpec == null ? void 0 : fieldSpec.strict;
        if (fieldSpec == null ? void 0 : fieldSpec.strip) {
          isChanged = isChanged || prop in value;
          continue;
        }
        fieldValue = !options.__validating || !strict ? (
          // TODO: use _cast, this is double resolving
          field.cast(value[prop], innerOptions)
        ) : value[prop];
        if (fieldValue !== void 0) {
          intermediateValue[prop] = fieldValue;
        }
      } else if (exists && !strip) {
        intermediateValue[prop] = value[prop];
      }
      if (intermediateValue[prop] !== value[prop]) {
        isChanged = true;
      }
    }
    return isChanged ? intermediateValue : value;
  }
  _validate(_value, opts = {}, callback) {
    let errors = [];
    let {
      sync,
      from: from2 = [],
      originalValue = _value,
      abortEarly = this.spec.abortEarly,
      recursive = this.spec.recursive
    } = opts;
    from2 = [{
      schema: this,
      value: originalValue
    }, ...from2];
    opts.__validating = true;
    opts.originalValue = originalValue;
    opts.from = from2;
    super._validate(_value, opts, (err, value) => {
      if (err) {
        if (!ValidationError.isError(err) || abortEarly) {
          return void callback(err, value);
        }
        errors.push(err);
      }
      if (!recursive || !isObject9(value)) {
        callback(errors[0] || null, value);
        return;
      }
      originalValue = originalValue || value;
      let tests = this._nodes.map((key) => (_7, cb) => {
        let path = key.indexOf(".") === -1 ? (opts.path ? `${opts.path}.` : "") + key : `${opts.path || ""}["${key}"]`;
        let field = this.fields[key];
        if (field && "validate" in field) {
          field.validate(value[key], _extends19({}, opts, {
            // @ts-ignore
            path,
            from: from2,
            // inner fields are always strict:
            // 1. this isn't strict so the casting will also have cast inner values
            // 2. this is strict in which case the nested values weren't cast either
            strict: true,
            parent: value,
            originalValue: originalValue[key]
          }), cb);
          return;
        }
        cb(null);
      });
      runTests({
        sync,
        tests,
        value,
        errors,
        endEarly: abortEarly,
        sort: this._sortErrors,
        path: opts.path
      }, callback);
    });
  }
  clone(spec) {
    const next = super.clone(spec);
    next.fields = _extends19({}, this.fields);
    next._nodes = this._nodes;
    next._excludedEdges = this._excludedEdges;
    next._sortErrors = this._sortErrors;
    return next;
  }
  concat(schema) {
    let next = super.concat(schema);
    let nextFields = next.fields;
    for (let [field, schemaOrRef] of Object.entries(this.fields)) {
      const target = nextFields[field];
      if (target === void 0) {
        nextFields[field] = schemaOrRef;
      } else if (target instanceof BaseSchema && schemaOrRef instanceof BaseSchema) {
        nextFields[field] = schemaOrRef.concat(target);
      }
    }
    return next.withMutation(() => next.shape(nextFields, this._excludedEdges));
  }
  getDefaultFromShape() {
    let dft = {};
    this._nodes.forEach((key) => {
      const field = this.fields[key];
      dft[key] = "default" in field ? field.getDefault() : void 0;
    });
    return dft;
  }
  _getDefault() {
    if ("default" in this.spec) {
      return super._getDefault();
    }
    if (!this._nodes.length) {
      return void 0;
    }
    return this.getDefaultFromShape();
  }
  shape(additions, excludes = []) {
    let next = this.clone();
    let fields = Object.assign(next.fields, additions);
    next.fields = fields;
    next._sortErrors = sortByKeyOrder(Object.keys(fields));
    if (excludes.length) {
      if (!Array.isArray(excludes[0]))
        excludes = [excludes];
      next._excludedEdges = [...next._excludedEdges, ...excludes];
    }
    next._nodes = sortFields(fields, next._excludedEdges);
    return next;
  }
  pick(keys6) {
    const picked = {};
    for (const key of keys6) {
      if (this.fields[key])
        picked[key] = this.fields[key];
    }
    return this.clone().withMutation((next) => {
      next.fields = {};
      return next.shape(picked);
    });
  }
  omit(keys6) {
    const next = this.clone();
    const fields = next.fields;
    next.fields = {};
    for (const key of keys6) {
      delete fields[key];
    }
    return next.withMutation(() => next.shape(fields));
  }
  from(from2, to4, alias) {
    let fromGetter = (0, import_property_expr4.getter)(from2, true);
    return this.transform((obj) => {
      if (obj == null)
        return obj;
      let newObj = obj;
      if ((0, import_has3.default)(obj, from2)) {
        newObj = _extends19({}, obj);
        if (!alias)
          delete newObj[from2];
        newObj[to4] = fromGetter(obj);
      }
      return newObj;
    });
  }
  noUnknown(noAllow = true, message = object.noUnknown) {
    if (typeof noAllow === "string") {
      message = noAllow;
      noAllow = true;
    }
    let next = this.test({
      name: "noUnknown",
      exclusive: true,
      message,
      test(value) {
        if (value == null)
          return true;
        const unknownKeys = unknown2(this.schema, value);
        return !noAllow || unknownKeys.length === 0 || this.createError({
          params: {
            unknown: unknownKeys.join(", ")
          }
        });
      }
    });
    next.spec.noUnknown = noAllow;
    return next;
  }
  unknown(allow = true, message = object.noUnknown) {
    return this.noUnknown(!allow, message);
  }
  transformKeys(fn2) {
    return this.transform((obj) => obj && (0, import_mapKeys.default)(obj, (_7, key) => fn2(key)));
  }
  camelCase() {
    return this.transformKeys(import_camelCase.default);
  }
  snakeCase() {
    return this.transformKeys(import_snakeCase.default);
  }
  constantCase() {
    return this.transformKeys((key) => (0, import_snakeCase.default)(key).toUpperCase());
  }
  describe() {
    let base = super.describe();
    base.fields = (0, import_mapValues2.default)(this.fields, (value) => value.describe());
    return base;
  }
};
function create11(spec) {
  return new ObjectSchema(spec);
}
create11.prototype = ObjectSchema.prototype;

// node_modules/yup/es/array.js
function _extends20() {
  _extends20 = Object.assign || function(target) {
    for (var i15 = 1; i15 < arguments.length; i15++) {
      var source = arguments[i15];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends20.apply(this, arguments);
}
function create12(type) {
  return new ArraySchema(type);
}
var ArraySchema = class extends BaseSchema {
  constructor(type) {
    super({
      type: "array"
    });
    this.innerType = void 0;
    this.innerType = type;
    this.withMutation(() => {
      this.transform(function(values3) {
        if (typeof values3 === "string")
          try {
            values3 = JSON.parse(values3);
          } catch (err) {
            values3 = null;
          }
        return this.isType(values3) ? values3 : null;
      });
    });
  }
  _typeCheck(v6) {
    return Array.isArray(v6);
  }
  get _subType() {
    return this.innerType;
  }
  _cast(_value, _opts) {
    const value = super._cast(_value, _opts);
    if (!this._typeCheck(value) || !this.innerType)
      return value;
    let isChanged = false;
    const castArray5 = value.map((v6, idx) => {
      const castElement = this.innerType.cast(v6, _extends20({}, _opts, {
        path: `${_opts.path || ""}[${idx}]`
      }));
      if (castElement !== v6) {
        isChanged = true;
      }
      return castElement;
    });
    return isChanged ? castArray5 : value;
  }
  _validate(_value, options = {}, callback) {
    var _options$abortEarly, _options$recursive;
    let errors = [];
    let sync = options.sync;
    let path = options.path;
    let innerType = this.innerType;
    let endEarly = (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly;
    let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;
    let originalValue = options.originalValue != null ? options.originalValue : _value;
    super._validate(_value, options, (err, value) => {
      if (err) {
        if (!ValidationError.isError(err) || endEarly) {
          return void callback(err, value);
        }
        errors.push(err);
      }
      if (!recursive || !innerType || !this._typeCheck(value)) {
        callback(errors[0] || null, value);
        return;
      }
      originalValue = originalValue || value;
      let tests = new Array(value.length);
      for (let idx = 0; idx < value.length; idx++) {
        let item = value[idx];
        let path2 = `${options.path || ""}[${idx}]`;
        let innerOptions = _extends20({}, options, {
          path: path2,
          strict: true,
          parent: value,
          index: idx,
          originalValue: originalValue[idx]
        });
        tests[idx] = (_7, cb) => innerType.validate(item, innerOptions, cb);
      }
      runTests({
        sync,
        path,
        value,
        errors,
        endEarly,
        tests
      }, callback);
    });
  }
  clone(spec) {
    const next = super.clone(spec);
    next.innerType = this.innerType;
    return next;
  }
  concat(schema) {
    let next = super.concat(schema);
    next.innerType = this.innerType;
    if (schema.innerType)
      next.innerType = next.innerType ? (
        // @ts-expect-error Lazy doesn't have concat()
        next.innerType.concat(schema.innerType)
      ) : schema.innerType;
    return next;
  }
  of(schema) {
    let next = this.clone();
    if (!isSchema_default(schema))
      throw new TypeError("`array.of()` sub-schema must be a valid yup schema not: " + printValue(schema));
    next.innerType = schema;
    return next;
  }
  length(length, message = array.length) {
    return this.test({
      message,
      name: "length",
      exclusive: true,
      params: {
        length
      },
      test(value) {
        return isAbsent_default(value) || value.length === this.resolve(length);
      }
    });
  }
  min(min4, message) {
    message = message || array.min;
    return this.test({
      message,
      name: "min",
      exclusive: true,
      params: {
        min: min4
      },
      // FIXME(ts): Array<typeof T>
      test(value) {
        return isAbsent_default(value) || value.length >= this.resolve(min4);
      }
    });
  }
  max(max4, message) {
    message = message || array.max;
    return this.test({
      message,
      name: "max",
      exclusive: true,
      params: {
        max: max4
      },
      test(value) {
        return isAbsent_default(value) || value.length <= this.resolve(max4);
      }
    });
  }
  ensure() {
    return this.default(() => []).transform((val, original) => {
      if (this._typeCheck(val))
        return val;
      return original == null ? [] : [].concat(original);
    });
  }
  compact(rejector) {
    let reject = !rejector ? (v6) => !!v6 : (v6, i15, a13) => !rejector(v6, i15, a13);
    return this.transform((values3) => values3 != null ? values3.filter(reject) : values3);
  }
  describe() {
    let base = super.describe();
    if (this.innerType)
      base.innerType = this.innerType.describe();
    return base;
  }
  nullable(isNullable = true) {
    return super.nullable(isNullable);
  }
  defined() {
    return super.defined();
  }
  required(msg) {
    return super.required(msg);
  }
};
create12.prototype = ArraySchema.prototype;

// node_modules/yup/es/Lazy.js
function create13(builder) {
  return new Lazy(builder);
}
var Lazy = class {
  constructor(builder) {
    this.type = "lazy";
    this.__isYupSchema__ = true;
    this.__inputType = void 0;
    this.__outputType = void 0;
    this._resolve = (value, options = {}) => {
      let schema = this.builder(value, options);
      if (!isSchema_default(schema))
        throw new TypeError("lazy() functions must return a valid schema");
      return schema.resolve(options);
    };
    this.builder = builder;
  }
  resolve(options) {
    return this._resolve(options.value, options);
  }
  cast(value, options) {
    return this._resolve(value, options).cast(value, options);
  }
  validate(value, options, maybeCb) {
    return this._resolve(value, options).validate(value, options, maybeCb);
  }
  validateSync(value, options) {
    return this._resolve(value, options).validateSync(value, options);
  }
  validateAt(path, value, options) {
    return this._resolve(value, options).validateAt(path, value, options);
  }
  validateSyncAt(path, value, options) {
    return this._resolve(value, options).validateSyncAt(path, value, options);
  }
  describe() {
    return null;
  }
  isValid(value, options) {
    return this._resolve(value, options).isValid(value, options);
  }
  isValidSync(value, options) {
    return this._resolve(value, options).isValidSync(value, options);
  }
};

// node_modules/yup/es/setLocale.js
function setLocale(custom2) {
  Object.keys(custom2).forEach((type) => {
    Object.keys(custom2[type]).forEach((method) => {
      locale_default[type][method] = custom2[type][method];
    });
  });
}

// node_modules/yup/es/index.js
function addMethod(schemaType, name2, fn2) {
  if (!schemaType || !isSchema_default(schemaType.prototype))
    throw new TypeError("You must provide a yup schema constructor function");
  if (typeof name2 !== "string")
    throw new TypeError("A Method name must be provided");
  if (typeof fn2 !== "function")
    throw new TypeError("Method function must be provided");
  schemaType.prototype[name2] = fn2;
}

// node_modules/@tinacms/schema-tools/dist/index.es.js
var import_url_pattern = __toESM(require_url_pattern());
function addNamespaceToSchema(maybeNode, namespace = []) {
  if (typeof maybeNode === "string") {
    return maybeNode;
  }
  if (typeof maybeNode === "boolean") {
    return maybeNode;
  }
  if (typeof maybeNode === "function") {
    return maybeNode;
  }
  const newNode = { ...maybeNode };
  const keys6 = Object.keys(maybeNode);
  Object.values(maybeNode).map((m10, index2) => {
    const key = keys6[index2];
    if (Array.isArray(m10)) {
      newNode[key] = m10.map((element) => {
        if (!element) {
          return;
        }
        if (!element.hasOwnProperty("name")) {
          return element;
        }
        const value = element.name || element.value;
        return addNamespaceToSchema(element, [...namespace, value]);
      });
    } else {
      if (!m10) {
        return;
      }
      if (!m10.hasOwnProperty("name")) {
        newNode[key] = m10;
      } else {
        newNode[key] = addNamespaceToSchema(m10, [...namespace, m10.name]);
      }
    }
  });
  return { ...newNode, namespace };
}
function assertShape(value, yupSchema, errorMessage) {
  const shape = yupSchema(es_exports);
  try {
    shape.validateSync(value);
  } catch (e9) {
    const message = errorMessage || `Failed to assertShape - ${e9.message}`;
    throw new Error(message);
  }
}
var lastItem = (arr) => {
  if (typeof arr === "undefined") {
    throw new Error("Can not call lastItem when arr is undefined");
  }
  return arr[arr.length - 1];
};
var capitalize2 = (s20) => {
  if (typeof s20 !== "string")
    return "";
  return s20.charAt(0).toUpperCase() + s20.slice(1);
};
var generateNamespacedFieldName = (names2, suffix2 = "") => {
  return (suffix2 ? [...names2, suffix2] : names2).map(capitalize2).join("");
};
var NAMER = {
  dataFilterTypeNameOn: (namespace) => {
    return generateNamespacedFieldName(namespace, "_FilterOn");
  },
  dataFilterTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "Filter");
  },
  dataMutationTypeNameOn: (namespace) => {
    return generateNamespacedFieldName(namespace, "_MutationOn");
  },
  dataMutationTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "Mutation");
  },
  updateName: (namespace) => {
    return "update" + generateNamespacedFieldName(namespace, "Document");
  },
  createName: (namespace) => {
    return "create" + generateNamespacedFieldName(namespace, "Document");
  },
  queryName: (namespace) => {
    return "get" + generateNamespacedFieldName(namespace, "Document");
  },
  generateQueryListName: (namespace) => {
    return "get" + generateNamespacedFieldName(namespace, "List");
  },
  fragmentName: (namespace) => {
    return generateNamespacedFieldName(namespace, "") + "Parts";
  },
  collectionTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "Collection");
  },
  documentTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "Document");
  },
  dataTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "");
  },
  referenceConnectionType: (namespace) => {
    return generateNamespacedFieldName(namespace, "Connection");
  },
  referenceConnectionEdgesTypeName: (namespace) => {
    return generateNamespacedFieldName(namespace, "ConnectionEdges");
  }
};
function findDuplicates(array2 = []) {
  const duplicates = [
    ...new Set(array2.filter((item, index2) => array2.indexOf(item) !== index2))
  ].map((x7) => `"${x7}"`);
  if (duplicates.length) {
    return duplicates.join(", ");
  } else
    return void 0;
}
var parseURL = (url) => {
  if (url.startsWith("/")) {
    return {
      branch: null,
      isLocalClient: false,
      clientId: null,
      host: null
    };
  }
  if (url.includes("localhost")) {
    return {
      branch: null,
      isLocalClient: true,
      clientId: null,
      host: "localhost"
    };
  }
  const params = new URL(url);
  const isTinaCloud = params.host.includes("tinajs.dev") || params.host.includes("tina.io") || params.host.includes("tinajs.io");
  if (!isTinaCloud) {
    return {
      branch: null,
      isLocalClient: true,
      clientId: null,
      host: params.host
    };
  }
  const pattern = new import_url_pattern.default("/:v/content/:clientId/github/*", {
    escapeChar: " ",
    segmentValueCharset: "a-zA-Z0-9-_~ %."
  });
  const result = pattern.match(params.pathname);
  const branch = result == null ? void 0 : result._;
  const clientId = result == null ? void 0 : result.clientId;
  if (!branch || !clientId) {
    throw new Error(`Invalid URL format provided. Expected: https://content.tinajs.io/<Version>/content/<ClientID>/github/<Branch> but but received ${url}`);
  }
  return {
    host: params.host,
    branch,
    clientId,
    isLocalClient: false
  };
};
var normalizePath = (filepath) => filepath.replace(/\\/g, "/");
var TinaSchema = class {
  constructor(config2) {
    this.config = config2;
    this.getIsTitleFieldName = (collection) => {
      var _a;
      const col = this.getCollection(collection);
      const field = (_a = col == null ? void 0 : col.fields) == null ? void 0 : _a.find((x7) => x7.type === "string" && x7.isTitle);
      return field == null ? void 0 : field.name;
    };
    this.getCollectionsByName = (collectionNames) => {
      return this.schema.collections.filter((collection) => collectionNames.includes(collection.name));
    };
    this.getCollection = (collectionName) => {
      const collection = this.schema.collections.find((collection2) => collection2.name === collectionName);
      if (!collection) {
        throw new Error(`Expected to find collection named ${collectionName}`);
      }
      const extraFields = {};
      const templateInfo = this.getTemplatesForCollectable(collection);
      switch (templateInfo.type) {
        case "object":
          extraFields["fields"] = templateInfo.template.fields;
          break;
        case "union":
          extraFields["templates"] = templateInfo.templates;
          break;
      }
      return {
        slug: collection.name,
        ...extraFields,
        ...collection,
        format: collection.format || "md"
      };
    };
    this.getCollections = () => {
      return this.schema.collections.map((collection) => this.getCollection(collection.name)) || [];
    };
    this.getCollectionByFullPath = (filepath) => {
      const fileExtension = filepath.split(".").pop();
      const possibleCollections = this.getCollections().filter((collection) => {
        var _a, _b;
        if (fileExtension !== (collection.format || "md")) {
          return false;
        }
        if (((_a = collection == null ? void 0 : collection.match) == null ? void 0 : _a.include) || ((_b = collection == null ? void 0 : collection.match) == null ? void 0 : _b.exclude)) {
          const matches = this.getMatches({ collection });
          const match5 = (0, import_micromatch.default)([filepath], matches).length > 0;
          if (!match5) {
            return false;
          }
        }
        return filepath.replace(/\\/g, "/").startsWith(collection.path.replace(/\/?$/, "/"));
      });
      if (possibleCollections.length === 0) {
        throw new Error(`Unable to find collection for file at ${filepath}`);
      }
      if (possibleCollections.length === 1) {
        return possibleCollections[0];
      }
      if (possibleCollections.length > 1) {
        const longestMatch = possibleCollections.reduce((acc, collection) => {
          if (collection.path.length > acc.path.length) {
            return collection;
          }
          return acc;
        });
        return longestMatch;
      }
    };
    this.getCollectionAndTemplateByFullPath = (filepath, templateName) => {
      let template;
      const collection = this.getCollectionByFullPath(filepath);
      const templates = this.getTemplatesForCollectable(collection);
      if (templates.type === "union") {
        if (templateName) {
          template = templates.templates.find((template2) => lastItem(template2.namespace) === templateName);
          if (!template) {
            throw new Error(`Unable to determine template for item at ${filepath}`);
          }
        } else {
          throw new Error(`Unable to determine template for item at ${filepath}, no template name provided for collection with multiple templates`);
        }
      }
      if (templates.type === "object") {
        template = templates.template;
      }
      if (!template) {
        throw new Error(`Something went wrong while trying to determine template for ${filepath}`);
      }
      return { collection, template };
    };
    this.getTemplateForData = ({
      data,
      collection
    }) => {
      const templateInfo = this.getTemplatesForCollectable(collection);
      switch (templateInfo.type) {
        case "object":
          return templateInfo.template;
        case "union":
          assertShape(data, (yup2) => yup2.object({ _template: yup2.string().required() }));
          const template = templateInfo.templates.find((template2) => template2.namespace[template2.namespace.length - 1] === data._template);
          if (!template) {
            throw new Error(`Expected to find template named '${data._template}' for collection '${lastItem(collection.namespace)}'`);
          }
          return template;
      }
    };
    this.transformPayload = (collectionName, payload) => {
      const collection = this.getCollection(collectionName);
      if (collection.templates) {
        const template = collection.templates.find((template2) => {
          if (typeof template2 === "string") {
            throw new Error("Global templates not supported");
          }
          return payload["_template"] === template2.name;
        });
        if (!template) {
          console.error(payload);
          throw new Error(`Unable to find template for payload`);
        }
        if (typeof template === "string") {
          throw new Error("Global templates not supported");
        }
        return {
          [collectionName]: {
            [template.name]: this.transformCollectablePayload(payload, template)
          }
        };
      } else {
        return {
          [collectionName]: this.transformCollectablePayload(payload, collection)
        };
      }
    };
    this.transformCollectablePayload = (payload, collection) => {
      const accumulator = {};
      Object.entries(payload).forEach(([key, value]) => {
        if (typeof collection.fields === "string") {
          throw new Error("Global templates not supported");
        }
        const field = collection.fields.find((field2) => {
          if (typeof field2 === "string") {
            throw new Error("Global templates not supported");
          }
          return field2.name === key;
        });
        if (field) {
          accumulator[key] = this.transformField(field, value);
        }
      });
      return accumulator;
    };
    this.transformField = (field, value) => {
      if (field.type === "object")
        if (field.templates) {
          if (field.list) {
            assertShape(value, (yup2) => yup2.array(yup2.object({ _template: yup2.string().required() })));
            return value.map((item) => {
              const { _template, ...rest } = item;
              const template = field.templates.find((template2) => {
                if (typeof template2 === "string") {
                  return false;
                }
                return template2.name === _template;
              });
              if (typeof template === "string") {
                throw new Error("Global templates not supported");
              }
              return {
                [_template]: this.transformCollectablePayload(rest, template)
              };
            });
          } else {
            assertShape(value, (yup2) => yup2.object({ _template: yup2.string().required() }));
            const { _template, ...rest } = value;
            return { [_template]: this.transformCollectablePayload(rest, field) };
          }
        } else {
          if (field.list) {
            assertShape(value, (yup2) => yup2.array(yup2.object()));
            return value.map((item) => {
              return this.transformCollectablePayload(item, field);
            });
          } else {
            assertShape(value, (yup2) => yup2.object());
            return this.transformCollectablePayload(value, field);
          }
        }
      else {
        return value;
      }
    };
    this.isMarkdownCollection = (collectionName) => {
      const collection = this.getCollection(collectionName);
      const format3 = collection.format;
      if (!format3) {
        return true;
      }
      if (["markdown", "md"].includes(format3)) {
        return true;
      }
      return false;
    };
    this.getTemplatesForCollectable = (collection) => {
      let extraFields = [];
      if (collection == null ? void 0 : collection.fields) {
        const template = collection;
        if (typeof template.fields === "string" || typeof template.fields === "undefined") {
          throw new Error("Exptected template to have fields but none were found");
        }
        return {
          namespace: collection.namespace,
          type: "object",
          template: {
            ...template,
            fields: [...template.fields, ...extraFields]
          }
        };
      } else {
        if (collection == null ? void 0 : collection.templates) {
          return {
            namespace: collection.namespace,
            type: "union",
            templates: collection.templates.map((templateOrTemplateString) => {
              const template = templateOrTemplateString;
              return {
                ...template,
                fields: [...template.fields, ...extraFields]
              };
            })
          };
        } else {
          throw new Error(`Expected either fields or templates array to be defined on collection ${collection.namespace.join("_")}`);
        }
      }
    };
    this.walkFields = (cb) => {
      const walk = (collectionOrObject, collection, path) => {
        if (collectionOrObject.templates) {
          collectionOrObject.templates.forEach((template) => {
            template.fields.forEach((field) => {
              cb({ field, collection, path: [...path, template.name] });
            });
          });
        }
        if (collectionOrObject.fields) {
          collectionOrObject.fields.forEach((field) => {
            cb({ field, collection, path: [...path, field.name] });
            if (field.type === "rich-text" || field.type === "object") {
              walk(field, collection, [...path, field.name]);
            }
          });
        }
      };
      const collections = this.getCollections();
      collections.forEach((collection) => walk(collection, collection, []));
    };
    this.schema = config2;
    this.walkFields(({ field, collection, path }) => {
      var _a;
      if (field.type === "rich-text") {
        if (field.parser) {
          return;
        }
        if (collection.format === "mdx") {
          field.parser = { type: "mdx" };
        } else {
          (_a = field.templates) == null ? void 0 : _a.forEach((template) => {
            if (!template.match) {
              console.warn(`WARNING: Found rich-text template at ${collection.name}.${path.join(".")} with no matches property.
Visit https://tina.io/docs/reference/types/rich-text/#custom-shortcode-syntax to learn more
                `);
            }
          });
          field.parser = { type: "markdown" };
        }
      }
    });
  }
  getMatches({
    collection: collectionOrString
  }) {
    var _a, _b;
    const collection = typeof collectionOrString === "string" ? this.getCollection(collectionOrString) : collectionOrString;
    const normalPath = normalizePath(collection.path);
    const format3 = collection.format || "md";
    const matches = [];
    if ((_a = collection == null ? void 0 : collection.match) == null ? void 0 : _a.include) {
      const match5 = `${normalPath}/${collection.match.include}.${format3}`;
      matches.push(match5);
    }
    if ((_b = collection == null ? void 0 : collection.match) == null ? void 0 : _b.exclude) {
      const exclude = `!(${normalPath}/${collection.match.exclude}.${format3})`;
      matches.push(exclude);
    }
    return matches;
  }
  matchFiles({
    collection,
    files
  }) {
    const matches = this.getMatches({ collection });
    const matchedFiles = (0, import_micromatch.default)(files, matches);
    return matchedFiles;
  }
};
var resolveField = (field, schema) => {
  var _a;
  const extraFields = field.ui || {};
  switch (field.type) {
    case "number":
      return {
        component: "number",
        ...field,
        ...extraFields
      };
    case "datetime":
      return {
        component: "date",
        ...field,
        ...extraFields
      };
    case "boolean":
      return {
        component: "toggle",
        ...field,
        ...extraFields
      };
    case "image":
      if (field.list) {
        return {
          component: "list",
          field: {
            component: "image"
          },
          ...field,
          ...extraFields
        };
      }
      return {
        component: "image",
        clearable: true,
        ...field,
        ...extraFields
      };
    case "string":
      if (field.options) {
        if (field.list) {
          return {
            component: "checkbox-group",
            ...field,
            ...extraFields,
            options: field.options
          };
        }
        if (field.options[0] && typeof field.options[0] === "object" && field.options[0].icon) {
          return {
            component: "button-toggle",
            ...field,
            ...extraFields,
            options: field.options
          };
        }
        return {
          component: "select",
          ...field,
          ...extraFields,
          options: field.ui && field.ui.component !== "select" ? field.options : [{ label: `Choose an option`, value: "" }, ...field.options]
        };
      }
      if (field.list) {
        return {
          component: "list",
          field: {
            component: "text"
          },
          ...field,
          ...extraFields
        };
      }
      return {
        component: "text",
        ...field,
        ...extraFields
      };
    case "object":
      const templateInfo = schema.getTemplatesForCollectable(field);
      if (templateInfo.type === "object") {
        return {
          ...field,
          component: field.list ? "group-list" : "group",
          fields: templateInfo.template.fields.map((field2) => resolveField(field2, schema)),
          ...extraFields
        };
      } else if (templateInfo.type === "union") {
        const templates2 = {};
        const typeMap2 = {};
        templateInfo.templates.forEach((template) => {
          const extraFields2 = template.ui || {};
          const templateName = lastItem(template.namespace);
          typeMap2[templateName] = NAMER.dataTypeName(template.namespace);
          templates2[lastItem(template.namespace)] = {
            label: template.label || templateName,
            key: templateName,
            namespace: [...field.namespace, templateName],
            fields: template.fields.map((field2) => resolveField(field2, schema)),
            ...extraFields2
          };
          return true;
        });
        return {
          ...field,
          typeMap: typeMap2,
          namespace: field.namespace,
          component: field.list ? "blocks" : "not-implemented",
          templates: templates2,
          ...extraFields
        };
      } else {
        throw new Error(`Unknown object for resolveField function`);
      }
    case "rich-text":
      const templates = {};
      (_a = field.templates) == null ? void 0 : _a.forEach((template) => {
        if (typeof template === "string") {
          throw new Error(`Global templates not yet supported for rich-text`);
        } else {
          const extraFields2 = template.ui || {};
          const templateName = lastItem(template.namespace);
          NAMER.dataTypeName(template.namespace);
          templates[lastItem(template.namespace)] = {
            label: template.label || templateName,
            key: templateName,
            inline: template.inline,
            name: templateName,
            match: template.match,
            fields: template.fields.map((field2) => resolveField(field2, schema)),
            ...extraFields2
          };
          return true;
        }
      });
      return {
        ...field,
        templates: Object.values(templates),
        component: "rich-text",
        ...extraFields
      };
    case "reference":
      return {
        ...field,
        component: "reference",
        ...extraFields
      };
    default:
      throw new Error(`Unknown field type ${field.type}`);
  }
};
var resolveForm = ({
  collection,
  basename,
  template,
  schema
}) => {
  return {
    id: basename,
    label: collection.label,
    name: basename,
    fields: template.fields.map((field) => {
      return resolveField(field, schema);
    })
  };
};
var parseZodError = ({ zodError }) => {
  var _a, _b, _c, _d;
  const errors = zodError.flatten((issue) => {
    const moreInfo = [];
    if (issue.code === "invalid_union") {
      issue.unionErrors.map((unionError) => {
        moreInfo.push(parseZodError({ zodError: unionError }));
      });
    }
    const errorMessage = `Error ${issue == null ? void 0 : issue.message} at path ${issue.path.join(".")}`;
    const errorMessages = [errorMessage, ...moreInfo];
    return {
      errors: errorMessages
    };
  });
  const formErrors = errors.formErrors.flatMap((x7) => x7.errors);
  const parsedErrors = [
    ...((_b = (_a = errors.fieldErrors) == null ? void 0 : _a.collections) == null ? void 0 : _b.flatMap((x7) => x7.errors)) || [],
    ...((_d = (_c = errors.fieldErrors) == null ? void 0 : _c.config) == null ? void 0 : _d.flatMap((x7) => x7.errors)) || [],
    ...formErrors
  ];
  return parsedErrors;
};
var name = z.string({
  required_error: "Name is required but not provided",
  invalid_type_error: "Name must be a string"
}).superRefine((val, ctx) => {
  if (val.match(/^[a-zA-Z0-9_]*$/) === null) {
    ctx.addIssue({
      code: "custom",
      message: `name, "${val}" must be alphanumeric and can only contain underscores. (No spaces, dashes, special characters, etc.)
If you only want to display this value in the CMS UI, you can use the label property to customize it.

If you need to use this value in your content you can use the \`nameOverride\` property to customize the value. For example:
\`\`\`
{
  "name": ${val.replace(/[^a-zA-Z0-9]/g, "_")},
  "nameOverride": ${val},
  // ...
}
\`\`\``
    });
  }
});
var TypeName = [
  "string",
  "boolean",
  "number",
  "datetime",
  "image",
  "object",
  "reference",
  "rich-text"
];
var typeTypeError = `type must be one of ${TypeName.join(", ")}`;
var typeRequiredError = `type is required and must be one of ${TypeName.join(", ")}`;
var Option = z.union([
  z.string(),
  z.object({ label: z.string(), value: z.string() }),
  z.object({ icon: z.any(), value: z.string() })
], {
  errorMap: () => {
    return {
      message: "Invalid option array. Must be a string[] or {label: string, value: string}[] or {icon: React.ComponentType<any>, value: string}[]"
    };
  }
});
var TinaField2 = z.object({
  name,
  label: z.string().or(z.boolean()).optional(),
  description: z.string().optional(),
  required: z.boolean().optional()
});
var FieldWithList = TinaField2.extend({ list: z.boolean().optional() });
var TinaScalerBase = FieldWithList.extend({
  options: z.array(Option).optional()
});
var StringField = TinaScalerBase.extend({
  type: z.literal("string", {
    invalid_type_error: typeTypeError,
    required_error: typeRequiredError
  }),
  isTitle: z.boolean().optional()
});
var BooleanField = TinaScalerBase.extend({
  type: z.literal("boolean", {
    invalid_type_error: typeTypeError,
    required_error: typeRequiredError
  })
});
var NumberField2 = TinaScalerBase.extend({
  type: z.literal("number", {
    invalid_type_error: typeTypeError,
    required_error: typeRequiredError
  })
});
var ImageField2 = TinaScalerBase.extend({
  type: z.literal("image", {
    invalid_type_error: typeTypeError,
    required_error: typeRequiredError
  })
});
var DateTimeField = TinaScalerBase.extend({
  type: z.literal("datetime", {
    invalid_type_error: typeTypeError,
    required_error: typeRequiredError
  }),
  dateFormat: z.string().optional(),
  timeFormat: z.string().optional()
});
var ReferenceField2 = FieldWithList.extend({
  type: z.literal("reference", {
    invalid_type_error: typeTypeError,
    required_error: typeRequiredError
  })
});
var TinaFieldZod = z.lazy(() => {
  const TemplateTemp = z.object({
    label: z.string().optional(),
    name,
    fields: z.array(TinaFieldZod),
    match: z.object({
      start: z.string(),
      end: z.string(),
      name: z.string().optional()
    }).optional()
  }).superRefine((val, ctx) => {
    const dups = findDuplicates(val == null ? void 0 : val.fields.map((x7) => x7.name));
    if (dups) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: `Fields must have a unique name, duplicate field names: ${dups}`
      });
    }
  });
  const ObjectField = FieldWithList.extend({
    type: z.literal("object", {
      invalid_type_error: typeTypeError,
      required_error: typeRequiredError
    }),
    fields: z.array(TinaFieldZod).min(1).optional().superRefine((val, ctx) => {
      const dups = findDuplicates(val == null ? void 0 : val.map((x7) => x7.name));
      if (dups) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Fields must have a unique name, duplicate field names: ${dups}`
        });
      }
    }),
    templates: z.array(TemplateTemp).min(1).optional().superRefine((val, ctx) => {
      const dups = findDuplicates(val == null ? void 0 : val.map((x7) => x7.name));
      if (dups) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Templates must have a unique name, duplicate template names: ${dups}`
        });
      }
    })
  });
  const RichTextField = FieldWithList.extend({
    type: z.literal("rich-text", {
      invalid_type_error: typeTypeError,
      required_error: typeRequiredError
    }),
    templates: z.array(TemplateTemp).optional().superRefine((val, ctx) => {
      const dups = findDuplicates(val == null ? void 0 : val.map((x7) => x7.name));
      if (dups) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message: `Templates must have a unique name, duplicate template names: ${dups}`
        });
      }
    })
  });
  return z.discriminatedUnion("type", [
    StringField,
    BooleanField,
    NumberField2,
    ImageField2,
    DateTimeField,
    ReferenceField2,
    ObjectField,
    RichTextField
  ], {
    errorMap: (issue, ctx) => {
      var _a;
      if (issue.code === "invalid_union_discriminator") {
        return {
          message: `Invalid \`type\` property. In the schema is 'type: ${(_a = ctx.data) == null ? void 0 : _a.type}' and expected one of ${TypeName.join(", ")}`
        };
      }
      return {
        message: issue.message
      };
    }
  }).superRefine((val, ctx) => {
    if (val.type === "string") {
      if (val.isTitle) {
        if (val.list) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: `Can not have \`list: true\` when using \`isTitle\`. Error in value 
${JSON.stringify(val, null, 2)}
`
          });
        }
        if (!val.required) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message: `Must have { required: true } when using \`isTitle\` Error in value 
${JSON.stringify(val, null, 2)}
`
          });
        }
      }
    }
    if (val.type === "object") {
      const message = "Must provide one of templates or fields in your collection";
      let isValid4 = Boolean(val == null ? void 0 : val.templates) || Boolean(val == null ? void 0 : val.fields);
      if (!isValid4) {
        ctx.addIssue({
          code: z.ZodIssueCode.custom,
          message
        });
        return false;
      } else {
        isValid4 = !((val == null ? void 0 : val.templates) && (val == null ? void 0 : val.fields));
        if (!isValid4) {
          ctx.addIssue({
            code: z.ZodIssueCode.custom,
            message
          });
        }
        return isValid4;
      }
    }
    return true;
  });
});
var tinaConfigKey = z.object({
  publicFolder: z.string(),
  mediaRoot: z.string()
}).strict().optional();
var tinaConfigZod = z.object({
  client: z.object({ referenceDepth: z.number().optional() }).optional(),
  media: z.object({
    tina: tinaConfigKey,
    loadCustomStore: z.function().optional()
  }).optional()
});
var FORMATS = [
  "json",
  "md",
  "markdown",
  "mdx",
  "toml",
  "yaml",
  "yml"
];
var Template = z.object({
  label: z.string({
    invalid_type_error: "label must be a string",
    required_error: "label was not provided but is required"
  }),
  name,
  fields: z.array(TinaFieldZod)
}).superRefine((val, ctx) => {
  var _a;
  const dups = findDuplicates((_a = val.fields) == null ? void 0 : _a.map((x7) => x7.name));
  if (dups) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: `Fields must have a unique name, duplicate field names: ${dups}`
    });
  }
});
var CollectionBaseSchema = z.object({
  label: z.string().optional(),
  name: name.superRefine((val, ctx) => {
    if (val === "relativePath") {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: `name cannot be 'relativePath'. 'relativePath' is a reserved field name.`
      });
    }
  }),
  path: z.string().transform((val) => val.replace(/^\/|\/$/g, "")),
  format: z.enum(FORMATS).optional()
});
var TinaCloudCollection = CollectionBaseSchema.extend({
  fields: z.array(TinaFieldZod).min(1).optional().superRefine((val, ctx) => {
    const dups = findDuplicates(val == null ? void 0 : val.map((x7) => x7.name));
    if (dups) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: `Fields must have a unique name, duplicate field names: ${dups}`
      });
    }
  }).refine((val) => {
    const arr = (val == null ? void 0 : val.filter((x7) => x7.type === "string" && x7.isTitle)) || [];
    return arr.length < 2;
  }, {
    message: "Fields can only have one use of `isTitle`"
  }),
  templates: z.array(Template).min(1).optional().superRefine((val, ctx) => {
    const dups = findDuplicates(val == null ? void 0 : val.map((x7) => x7.name));
    if (dups) {
      ctx.addIssue({
        code: z.ZodIssueCode.custom,
        message: `Templates must have a unique name, duplicate template names: ${dups}`
      });
    }
  })
}).refine((val) => {
  let isValid4 = Boolean(val == null ? void 0 : val.templates) || Boolean(val == null ? void 0 : val.fields);
  if (!isValid4) {
    return false;
  } else {
    isValid4 = !((val == null ? void 0 : val.templates) && (val == null ? void 0 : val.fields));
    return isValid4;
  }
}, { message: "Must provide one of templates or fields in your collection" });
var TinaCloudSchemaZod = z.object({
  collections: z.array(TinaCloudCollection),
  config: tinaConfigZod.optional()
}).superRefine((val, ctx) => {
  var _a, _b;
  const dups = findDuplicates((_a = val.collections) == null ? void 0 : _a.map((x7) => x7.name));
  if (dups) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: `${dups} are duplicate names in your collections. Collection names must be unique.`,
      fatal: true
    });
  }
  const media = (_b = val == null ? void 0 : val.config) == null ? void 0 : _b.media;
  if (media && media.tina && media.loadCustomStore) {
    ctx.addIssue({
      code: z.ZodIssueCode.custom,
      message: "can not have both loadCustomStore and tina. Must use one or the other",
      fatal: true,
      path: ["config", "media"]
    });
  }
});
var TinaSchemaValidationError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "TinaSchemaValidationError";
  }
};
var validateSchema = ({ schema }) => {
  try {
    TinaCloudSchemaZod.parse(schema);
  } catch (e9) {
    if (e9 instanceof ZodError) {
      const errors = parseZodError({ zodError: e9 });
      throw new TinaSchemaValidationError(errors.join(", \n"));
    } else {
      throw new Error(e9);
    }
  }
};

// node_modules/tinacms/dist/index.es.js
var import_react120 = __toESM(require_react());

// node_modules/@graphql-inspector/core/esm/utils/is-deprecated.js
function isDeprecated(fieldOrEnumValue) {
  var _a, _b;
  if ("isDeprecated" in fieldOrEnumValue) {
    return !!fieldOrEnumValue["isDeprecated"];
  }
  if (fieldOrEnumValue.deprecationReason != null) {
    return true;
  }
  if ((_b = (_a = fieldOrEnumValue.astNode) === null || _a === void 0 ? void 0 : _a.directives) === null || _b === void 0 ? void 0 : _b.some((directive) => directive.name.value === "deprecated")) {
    return true;
  }
  return false;
}

// node_modules/@graphql-inspector/core/esm/utils/graphql.js
function safeChangeForField(oldType, newType) {
  if (!isWrappingType(oldType) && !isWrappingType(newType)) {
    return oldType.toString() === newType.toString();
  }
  if (isNonNullType(newType)) {
    const ofType = isNonNullType(oldType) ? oldType.ofType : oldType;
    return safeChangeForField(ofType, newType.ofType);
  }
  if (isListType(oldType)) {
    return isListType(newType) && safeChangeForField(oldType.ofType, newType.ofType) || isNonNullType(newType) && safeChangeForField(oldType, newType.ofType);
  }
  return false;
}
function safeChangeForInputValue(oldType, newType) {
  if (!isWrappingType(oldType) && !isWrappingType(newType)) {
    return oldType.toString() === newType.toString();
  }
  if (isListType(oldType) && isListType(newType)) {
    return safeChangeForInputValue(oldType.ofType, newType.ofType);
  }
  if (isNonNullType(oldType)) {
    const ofType = isNonNullType(newType) ? newType.ofType : newType;
    return safeChangeForInputValue(oldType.ofType, ofType);
  }
  return false;
}
function getKind(type) {
  const node = type.astNode;
  return (node === null || node === void 0 ? void 0 : node.kind) || "";
}
function isPrimitive(type) {
  return ["String", "Int", "Float", "Boolean", "ID"].includes(typeof type === "string" ? type : type.name);
}

// node_modules/@graphql-inspector/core/esm/diff/changes/change.js
var ChangeType;
(function(ChangeType2) {
  ChangeType2["FieldArgumentDescriptionChanged"] = "FIELD_ARGUMENT_DESCRIPTION_CHANGED";
  ChangeType2["FieldArgumentDefaultChanged"] = "FIELD_ARGUMENT_DEFAULT_CHANGED";
  ChangeType2["FieldArgumentTypeChanged"] = "FIELD_ARGUMENT_TYPE_CHANGED";
  ChangeType2["DirectiveRemoved"] = "DIRECTIVE_REMOVED";
  ChangeType2["DirectiveAdded"] = "DIRECTIVE_ADDED";
  ChangeType2["DirectiveDescriptionChanged"] = "DIRECTIVE_DESCRIPTION_CHANGED";
  ChangeType2["DirectiveLocationAdded"] = "DIRECTIVE_LOCATION_ADDED";
  ChangeType2["DirectiveLocationRemoved"] = "DIRECTIVE_LOCATION_REMOVED";
  ChangeType2["DirectiveArgumentAdded"] = "DIRECTIVE_ARGUMENT_ADDED";
  ChangeType2["DirectiveArgumentRemoved"] = "DIRECTIVE_ARGUMENT_REMOVED";
  ChangeType2["DirectiveArgumentDescriptionChanged"] = "DIRECTIVE_ARGUMENT_DESCRIPTION_CHANGED";
  ChangeType2["DirectiveArgumentDefaultValueChanged"] = "DIRECTIVE_ARGUMENT_DEFAULT_VALUE_CHANGED";
  ChangeType2["DirectiveArgumentTypeChanged"] = "DIRECTIVE_ARGUMENT_TYPE_CHANGED";
  ChangeType2["EnumValueRemoved"] = "ENUM_VALUE_REMOVED";
  ChangeType2["EnumValueAdded"] = "ENUM_VALUE_ADDED";
  ChangeType2["EnumValueDescriptionChanged"] = "ENUM_VALUE_DESCRIPTION_CHANGED";
  ChangeType2["EnumValueDeprecationReasonChanged"] = "ENUM_VALUE_DEPRECATION_REASON_CHANGED";
  ChangeType2["EnumValueDeprecationReasonAdded"] = "ENUM_VALUE_DEPRECATION_REASON_ADDED";
  ChangeType2["EnumValueDeprecationReasonRemoved"] = "ENUM_VALUE_DEPRECATION_REASON_REMOVED";
  ChangeType2["FieldRemoved"] = "FIELD_REMOVED";
  ChangeType2["FieldAdded"] = "FIELD_ADDED";
  ChangeType2["FieldDescriptionChanged"] = "FIELD_DESCRIPTION_CHANGED";
  ChangeType2["FieldDescriptionAdded"] = "FIELD_DESCRIPTION_ADDED";
  ChangeType2["FieldDescriptionRemoved"] = "FIELD_DESCRIPTION_REMOVED";
  ChangeType2["FieldDeprecationAdded"] = "FIELD_DEPRECATION_ADDED";
  ChangeType2["FieldDeprecationRemoved"] = "FIELD_DEPRECATION_REMOVED";
  ChangeType2["FieldDeprecationReasonChanged"] = "FIELD_DEPRECATION_REASON_CHANGED";
  ChangeType2["FieldDeprecationReasonAdded"] = "FIELD_DEPRECATION_REASON_ADDED";
  ChangeType2["FieldDeprecationReasonRemoved"] = "FIELD_DEPRECATION_REASON_REMOVED";
  ChangeType2["FieldTypeChanged"] = "FIELD_TYPE_CHANGED";
  ChangeType2["FieldArgumentAdded"] = "FIELD_ARGUMENT_ADDED";
  ChangeType2["FieldArgumentRemoved"] = "FIELD_ARGUMENT_REMOVED";
  ChangeType2["InputFieldRemoved"] = "INPUT_FIELD_REMOVED";
  ChangeType2["InputFieldAdded"] = "INPUT_FIELD_ADDED";
  ChangeType2["InputFieldDescriptionAdded"] = "INPUT_FIELD_DESCRIPTION_ADDED";
  ChangeType2["InputFieldDescriptionRemoved"] = "INPUT_FIELD_DESCRIPTION_REMOVED";
  ChangeType2["InputFieldDescriptionChanged"] = "INPUT_FIELD_DESCRIPTION_CHANGED";
  ChangeType2["InputFieldDefaultValueChanged"] = "INPUT_FIELD_DEFAULT_VALUE_CHANGED";
  ChangeType2["InputFieldTypeChanged"] = "INPUT_FIELD_TYPE_CHANGED";
  ChangeType2["ObjectTypeInterfaceAdded"] = "OBJECT_TYPE_INTERFACE_ADDED";
  ChangeType2["ObjectTypeInterfaceRemoved"] = "OBJECT_TYPE_INTERFACE_REMOVED";
  ChangeType2["SchemaQueryTypeChanged"] = "SCHEMA_QUERY_TYPE_CHANGED";
  ChangeType2["SchemaMutationTypeChanged"] = "SCHEMA_MUTATION_TYPE_CHANGED";
  ChangeType2["SchemaSubscriptionTypeChanged"] = "SCHEMA_SUBSCRIPTION_TYPE_CHANGED";
  ChangeType2["TypeRemoved"] = "TYPE_REMOVED";
  ChangeType2["TypeAdded"] = "TYPE_ADDED";
  ChangeType2["TypeKindChanged"] = "TYPE_KIND_CHANGED";
  ChangeType2["TypeDescriptionChanged"] = "TYPE_DESCRIPTION_CHANGED";
  ChangeType2["TypeDescriptionRemoved"] = "TYPE_DESCRIPTION_REMOVED";
  ChangeType2["TypeDescriptionAdded"] = "TYPE_DESCRIPTION_ADDED";
  ChangeType2["UnionMemberRemoved"] = "UNION_MEMBER_REMOVED";
  ChangeType2["UnionMemberAdded"] = "UNION_MEMBER_ADDED";
})(ChangeType || (ChangeType = {}));
var CriticalityLevel;
(function(CriticalityLevel2) {
  CriticalityLevel2["Breaking"] = "BREAKING";
  CriticalityLevel2["NonBreaking"] = "NON_BREAKING";
  CriticalityLevel2["Dangerous"] = "DANGEROUS";
})(CriticalityLevel || (CriticalityLevel = {}));

// node_modules/@graphql-inspector/core/esm/diff/rules/ignore-description-changes.js
var descriptionChangeTypes = [
  ChangeType.FieldArgumentDescriptionChanged,
  ChangeType.DirectiveDescriptionChanged,
  ChangeType.DirectiveArgumentDescriptionChanged,
  ChangeType.EnumValueDescriptionChanged,
  ChangeType.FieldDescriptionChanged,
  ChangeType.FieldDescriptionAdded,
  ChangeType.FieldDescriptionRemoved,
  ChangeType.InputFieldDescriptionAdded,
  ChangeType.InputFieldDescriptionRemoved,
  ChangeType.InputFieldDescriptionChanged,
  ChangeType.TypeDescriptionChanged
];

// node_modules/@graphql-inspector/core/esm/utils/compare.js
function keyMap(list, keyFn) {
  return list.reduce((map5, item) => {
    map5[keyFn(item)] = item;
    return map5;
  }, /* @__PURE__ */ Object.create(null));
}
function isEqual6(a13, b6) {
  if (Array.isArray(a13) && Array.isArray(b6)) {
    if (a13.length !== b6.length)
      return false;
    for (let index2 = 0; index2 < a13.length; index2++) {
      if (!isEqual6(a13[index2], b6[index2])) {
        return false;
      }
    }
    return true;
  }
  if (a13 && b6 && typeof a13 === "object" && typeof b6 === "object") {
    const aRecord = a13;
    const bRecord = b6;
    const aKeys = Object.keys(aRecord);
    const bKeys = Object.keys(bRecord);
    if (aKeys.length !== bKeys.length)
      return false;
    for (const key of aKeys) {
      if (!isEqual6(aRecord[key], bRecord[key])) {
        return false;
      }
    }
    return true;
  }
  return a13 === b6 || !a13 && !b6;
}
function isNotEqual(a13, b6) {
  return !isEqual6(a13, b6);
}
function isVoid2(a13) {
  return typeof a13 === "undefined" || a13 === null;
}
function diffArrays(a13, b6) {
  return a13.filter((c16) => !b6.some((d17) => isEqual6(d17, c16)));
}
function compareLists(oldList, newList, callbacks) {
  const oldMap = keyMap(oldList, ({ name: name2 }) => name2);
  const newMap = keyMap(newList, ({ name: name2 }) => name2);
  const added = [];
  const removed = [];
  const mutual = [];
  for (const oldItem of oldList) {
    const newItem = newMap[oldItem.name];
    if (newItem === void 0) {
      removed.push(oldItem);
    } else {
      mutual.push({
        newVersion: newItem,
        oldVersion: oldItem
      });
    }
  }
  for (const newItem of newList) {
    if (oldMap[newItem.name] === void 0) {
      added.push(newItem);
    }
  }
  if (callbacks) {
    if (callbacks.onAdded) {
      for (const item of added) {
        callbacks.onAdded(item);
      }
    }
    if (callbacks.onRemoved) {
      for (const item of removed) {
        callbacks.onRemoved(item);
      }
    }
    if (callbacks.onMutual) {
      for (const item of mutual) {
        callbacks.onMutual(item);
      }
    }
  }
  return {
    added,
    removed,
    mutual
  };
}

// node_modules/@graphql-inspector/core/esm/utils/string.js
var import_object_inspect = __toESM(require_object_inspect(), 1);
function safeString(obj) {
  if (typeof obj === "string") {
    return JSON.stringify(obj);
  }
  return (0, import_object_inspect.default)(obj).replace(/\[Object: null prototype\] /g, "").replace(/(^')|('$)/g, "");
}

// node_modules/@graphql-inspector/core/esm/diff/changes/directive.js
function buildDirectiveRemovedMessage(args) {
  return `Directive '${args.removedDirectiveName}' was removed`;
}
var directiveRemovedCriticalityBreakingReason = `A directive could be in use of a client application. Removing it could break the client application.`;
function directiveRemovedFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.Breaking,
      reason: directiveRemovedCriticalityBreakingReason
    },
    type: ChangeType.DirectiveRemoved,
    message: buildDirectiveRemovedMessage(args.meta),
    path: `@${args.meta.removedDirectiveName}`,
    meta: args.meta
  };
}
function directiveRemoved(directive) {
  return directiveRemovedFromMeta({
    type: ChangeType.DirectiveRemoved,
    meta: {
      removedDirectiveName: directive.name
    }
  });
}
function buildDirectiveAddedMessage(args) {
  return `Directive '${args.addedDirectiveName}' was added`;
}
function directiveAddedFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    type: ChangeType.DirectiveAdded,
    message: buildDirectiveAddedMessage(args.meta),
    path: `@${args.meta.addedDirectiveName}`,
    meta: args.meta
  };
}
function directiveAdded(directive) {
  return directiveAddedFromMeta({
    type: ChangeType.DirectiveAdded,
    meta: {
      addedDirectiveName: directive.name
    }
  });
}
function buildDirectiveDescriptionChangedMessage(args) {
  var _a, _b;
  return `Directive '${args.directiveName}' description changed from '${(_a = args.oldDirectiveDescription) !== null && _a !== void 0 ? _a : "undefined"}' to '${(_b = args.newDirectiveDescription) !== null && _b !== void 0 ? _b : "undefined"}'`;
}
function directiveDescriptionChangedFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    type: ChangeType.DirectiveDescriptionChanged,
    message: buildDirectiveDescriptionChangedMessage(args.meta),
    path: `@${args.meta.directiveName}`,
    meta: args.meta
  };
}
function directiveDescriptionChanged(oldDirective, newDirective) {
  var _a, _b;
  return directiveDescriptionChangedFromMeta({
    type: ChangeType.DirectiveDescriptionChanged,
    meta: {
      directiveName: oldDirective.name,
      oldDirectiveDescription: (_a = oldDirective.description) !== null && _a !== void 0 ? _a : null,
      newDirectiveDescription: (_b = newDirective.description) !== null && _b !== void 0 ? _b : null
    }
  });
}
function buildDirectiveLocationAddedMessage(args) {
  return `Location '${args.addedDirectiveLocation}' was added to directive '${args.directiveName}'`;
}
function directiveLocationAddedFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    type: ChangeType.DirectiveLocationAdded,
    message: buildDirectiveLocationAddedMessage(args.meta),
    path: `@${args.meta.directiveName}`,
    meta: args.meta
  };
}
function directiveLocationAdded(directive, location) {
  return directiveLocationAddedFromMeta({
    type: ChangeType.DirectiveLocationAdded,
    meta: {
      directiveName: directive.name,
      addedDirectiveLocation: location.toString()
    }
  });
}
function buildDirectiveLocationRemovedMessage(args) {
  return `Location '${args.removedDirectiveLocation}' was removed from directive '${args.directiveName}'`;
}
var directiveLocationRemovedBreakingReason = `A directive could be in use of a client application. Removing it could break the client application.`;
function directiveLocationRemovedFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.Breaking,
      reason: directiveLocationRemovedBreakingReason
    },
    type: ChangeType.DirectiveLocationRemoved,
    message: buildDirectiveLocationRemovedMessage(args.meta),
    path: `@${args.meta.directiveName}`,
    meta: args.meta
  };
}
function directiveLocationRemoved(directive, location) {
  return directiveLocationRemovedFromMeta({
    type: ChangeType.DirectiveLocationRemoved,
    meta: {
      directiveName: directive.name,
      removedDirectiveLocation: location.toString()
    }
  });
}
var directiveArgumentAddedBreakingReason = `A directive could be in use of a client application. Adding a non-nullable argument will break those clients.`;
var directiveArgumentNonBreakingReason = `A directive could be in use of a client application. Adding a non-nullable argument will break those clients.`;
function directiveArgumentAddedFromMeta(args) {
  return {
    criticality: args.meta.addedDirectiveArgumentTypeIsNonNull ? {
      level: CriticalityLevel.Breaking,
      reason: directiveArgumentAddedBreakingReason
    } : {
      level: CriticalityLevel.NonBreaking,
      reason: directiveArgumentNonBreakingReason
    },
    type: ChangeType.DirectiveArgumentAdded,
    message: `Argument '${args.meta.addedDirectiveArgumentName}' was added to directive '${args.meta.directiveName}'`,
    path: `@${args.meta.directiveName}`,
    meta: args.meta
  };
}
function directiveArgumentAdded(directive, arg) {
  return directiveArgumentAddedFromMeta({
    type: ChangeType.DirectiveArgumentAdded,
    meta: {
      directiveName: directive.name,
      addedDirectiveArgumentName: arg.name,
      addedDirectiveArgumentTypeIsNonNull: isNonNullType(arg.type)
    }
  });
}
function buildDirectiveArgumentRemovedMessage(args) {
  return `Argument '${args.removedDirectiveArgumentName}' was removed from directive '${args.directiveName}'`;
}
var directiveArgumentRemovedBreakingReason = `A directive argument could be in use of a client application. Removing the argument can break client applications.`;
function directiveArgumentRemovedFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.Breaking,
      reason: directiveArgumentRemovedBreakingReason
    },
    type: ChangeType.DirectiveArgumentRemoved,
    message: buildDirectiveArgumentRemovedMessage(args.meta),
    path: `@${args.meta.directiveName}.${args.meta.removedDirectiveArgumentName}`,
    meta: args.meta
  };
}
function directiveArgumentRemoved(directive, arg) {
  return directiveArgumentRemovedFromMeta({
    type: ChangeType.DirectiveArgumentRemoved,
    meta: {
      directiveName: directive.name,
      removedDirectiveArgumentName: arg.name
    }
  });
}
function buildDirectiveArgumentDescriptionChangedMessage(args) {
  return `Description for argument '${args.directiveArgumentName}' on directive '${args.directiveName}' changed from '${args.oldDirectiveArgumentDescription}' to '${args.newDirectiveArgumentDescription}'`;
}
function directiveArgumentDescriptionChangedFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    type: ChangeType.DirectiveArgumentDescriptionChanged,
    message: buildDirectiveArgumentDescriptionChangedMessage(args.meta),
    path: `@${args.meta.directiveName}.${args.meta.directiveArgumentName}`,
    meta: args.meta
  };
}
function directiveArgumentDescriptionChanged(directive, oldArg, newArg) {
  var _a, _b;
  return directiveArgumentDescriptionChangedFromMeta({
    type: ChangeType.DirectiveArgumentDescriptionChanged,
    meta: {
      directiveName: directive.name,
      directiveArgumentName: oldArg.name,
      oldDirectiveArgumentDescription: (_a = oldArg.description) !== null && _a !== void 0 ? _a : null,
      newDirectiveArgumentDescription: (_b = newArg.description) !== null && _b !== void 0 ? _b : null
    }
  });
}
function buildDirectiveArgumentDefaultValueChanged(args) {
  return args.oldDirectiveArgumentDefaultValue === void 0 ? `Default value '${args.newDirectiveArgumentDefaultValue}' was added to argument '${args.directiveArgumentName}' on directive '${args.directiveName}'` : `Default value for argument '${args.directiveArgumentName}' on directive '${args.directiveName}' changed from '${args.oldDirectiveArgumentDefaultValue}' to '${args.newDirectiveArgumentDefaultValue}'`;
}
var directiveArgumentDefaultValueChangedDangerousReason = "Changing the default value for an argument may change the runtime behaviour of a field if it was never provided.";
function directiveArgumentDefaultValueChangedFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.Dangerous,
      reason: directiveArgumentDefaultValueChangedDangerousReason
    },
    type: ChangeType.DirectiveArgumentDefaultValueChanged,
    message: buildDirectiveArgumentDefaultValueChanged(args.meta),
    path: `@${args.meta.directiveName}.${args.meta.directiveArgumentName}`,
    meta: args.meta
  };
}
function directiveArgumentDefaultValueChanged(directive, oldArg, newArg) {
  const meta = {
    directiveName: directive.name,
    directiveArgumentName: oldArg.name
  };
  if (oldArg.defaultValue !== void 0) {
    meta.oldDirectiveArgumentDefaultValue = safeString(oldArg.defaultValue);
  }
  if (newArg.defaultValue !== void 0) {
    meta.newDirectiveArgumentDefaultValue = safeString(newArg.defaultValue);
  }
  return directiveArgumentDefaultValueChangedFromMeta({
    type: ChangeType.DirectiveArgumentDefaultValueChanged,
    meta
  });
}
function buildDirectiveArgumentTypeChangedMessage(args) {
  return `Type for argument '${args.meta.directiveArgumentName}' on directive '${args.meta.directiveName}' changed from '${args.meta.oldDirectiveArgumentType}' to '${args.meta.newDirectiveArgumentType}'`;
}
var directiveArgumentTypeChangedNonBreakingReason = "Changing an input field from non-null to null is considered non-breaking.";
function directiveArgumentTypeChangedFromMeta(args) {
  return {
    criticality: args.meta.isSafeDirectiveArgumentTypeChange ? {
      level: CriticalityLevel.NonBreaking,
      reason: directiveArgumentTypeChangedNonBreakingReason
    } : {
      level: CriticalityLevel.Breaking
    },
    type: ChangeType.DirectiveArgumentTypeChanged,
    message: buildDirectiveArgumentTypeChangedMessage(args),
    path: `@${args.meta.directiveName}.${args.meta.directiveArgumentName}`,
    meta: args.meta
  };
}
function directiveArgumentTypeChanged(directive, oldArg, newArg) {
  return directiveArgumentTypeChangedFromMeta({
    type: ChangeType.DirectiveArgumentTypeChanged,
    meta: {
      directiveName: directive.name,
      directiveArgumentName: oldArg.name,
      oldDirectiveArgumentType: oldArg.type.toString(),
      newDirectiveArgumentType: newArg.type.toString(),
      isSafeDirectiveArgumentTypeChange: safeChangeForInputValue(oldArg.type, newArg.type)
    }
  });
}

// node_modules/@graphql-inspector/core/esm/diff/changes/schema.js
function buildSchemaQueryTypeChangedMessage(args) {
  return `Schema query root has changed from '${args.oldQueryTypeName}' to '${args.newQueryTypeName}'`;
}
function schemaQueryTypeChangedFromMeta(args) {
  return {
    type: ChangeType.SchemaQueryTypeChanged,
    criticality: {
      level: CriticalityLevel.Breaking
    },
    message: buildSchemaQueryTypeChangedMessage(args.meta),
    meta: args.meta
  };
}
function schemaQueryTypeChanged(oldSchema, newSchema) {
  const oldName = (oldSchema.getQueryType() || {}).name || "unknown";
  const newName = (newSchema.getQueryType() || {}).name || "unknown";
  return schemaQueryTypeChangedFromMeta({
    type: ChangeType.SchemaQueryTypeChanged,
    meta: {
      oldQueryTypeName: oldName,
      newQueryTypeName: newName
    }
  });
}
function buildSchemaMutationTypeChangedMessage(args) {
  return `Schema mutation root has changed from '${args.oldMutationTypeName}' to '${args.newMutationTypeName}'`;
}
function schemaMutationTypeChangedFromMeta(args) {
  return {
    type: ChangeType.SchemaMutationTypeChanged,
    criticality: {
      level: CriticalityLevel.Breaking
    },
    message: buildSchemaMutationTypeChangedMessage(args.meta),
    meta: args.meta
  };
}
function schemaMutationTypeChanged(oldSchema, newSchema) {
  const oldName = (oldSchema.getMutationType() || {}).name || "unknown";
  const newName = (newSchema.getMutationType() || {}).name || "unknown";
  return schemaMutationTypeChangedFromMeta({
    type: ChangeType.SchemaMutationTypeChanged,
    meta: {
      newMutationTypeName: newName,
      oldMutationTypeName: oldName
    }
  });
}
function buildSchemaSubscriptionTypeChangedMessage(args) {
  return `Schema subscription root has changed from '${args.oldSubscriptionTypeName}' to '${args.newSubscriptionTypeName}'`;
}
function schemaSubscriptionTypeChangedFromMeta(args) {
  return {
    type: ChangeType.SchemaSubscriptionTypeChanged,
    criticality: {
      level: CriticalityLevel.Breaking
    },
    message: buildSchemaSubscriptionTypeChangedMessage(args.meta),
    meta: args.meta
  };
}
function schemaSubscriptionTypeChanged(oldSchema, newSchema) {
  const oldName = (oldSchema.getSubscriptionType() || {}).name || "unknown";
  const newName = (newSchema.getSubscriptionType() || {}).name || "unknown";
  return schemaSubscriptionTypeChangedFromMeta({
    type: ChangeType.SchemaSubscriptionTypeChanged,
    meta: {
      newSubscriptionTypeName: newName,
      oldSubscriptionTypeName: oldName
    }
  });
}

// node_modules/@graphql-inspector/core/esm/diff/changes/type.js
function buildTypeRemovedMessage(type) {
  return `Type '${type.removedTypeName}' was removed`;
}
function typeRemovedFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.Breaking
    },
    type: ChangeType.TypeRemoved,
    message: buildTypeRemovedMessage(args.meta),
    meta: args.meta,
    path: args.meta.removedTypeName
  };
}
function typeRemoved(type) {
  return typeRemovedFromMeta({
    type: ChangeType.TypeRemoved,
    meta: {
      removedTypeName: type.name
    }
  });
}
function buildTypeAddedMessage(type) {
  return `Type '${type.addedTypeName}' was added`;
}
function typeAddedFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    type: ChangeType.TypeAdded,
    message: buildTypeAddedMessage(args.meta),
    meta: args.meta,
    path: args.meta.addedTypeName
  };
}
function typeAdded(type) {
  return typeAddedFromMeta({
    type: ChangeType.TypeAdded,
    meta: {
      addedTypeName: type.name
    }
  });
}
function buildTypeKindChangedMessage(args) {
  return `'${args.meta.typeName}' kind changed from '${args.meta.oldTypeKind}' to '${args.meta.newTypeKind}'`;
}
function typeKindChangedFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.Breaking,
      reason: `Changing the kind of a type is a breaking change because it can cause existing queries to error. For example, turning an object type to a scalar type would break queries that define a selection set for this type.`
    },
    type: ChangeType.TypeKindChanged,
    message: buildTypeKindChangedMessage(args),
    path: args.meta.typeName,
    meta: args.meta
  };
}
function typeKindChanged(oldType, newType) {
  return typeKindChangedFromMeta({
    type: ChangeType.TypeKindChanged,
    meta: {
      typeName: oldType.name,
      newTypeKind: String(getKind(newType)),
      oldTypeKind: String(getKind(oldType))
    }
  });
}
function buildTypeDescriptionChangedMessage(args) {
  return `Description '${args.oldTypeDescription}' on type '${args.typeName}' has changed to '${args.newTypeDescription}'`;
}
function typeDescriptionChangedFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    type: ChangeType.TypeDescriptionChanged,
    message: buildTypeDescriptionChangedMessage(args.meta),
    path: args.meta.typeName,
    meta: args.meta
  };
}
function typeDescriptionChanged(oldType, newType) {
  var _a, _b;
  return typeDescriptionChangedFromMeta({
    type: ChangeType.TypeDescriptionChanged,
    meta: {
      typeName: oldType.name,
      newTypeDescription: (_a = newType.description) !== null && _a !== void 0 ? _a : "",
      oldTypeDescription: (_b = oldType.description) !== null && _b !== void 0 ? _b : ""
    }
  });
}
function buildTypeDescriptionRemoved(args) {
  return `Description '${args.removedTypeDescription}' was removed from object type '${args.typeName}'`;
}
function typeDescriptionRemovedFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    type: ChangeType.TypeDescriptionRemoved,
    message: buildTypeDescriptionRemoved(args.meta),
    path: args.meta.typeName,
    meta: args.meta
  };
}
function typeDescriptionRemoved(type) {
  var _a;
  return typeDescriptionRemovedFromMeta({
    type: ChangeType.TypeDescriptionRemoved,
    meta: {
      typeName: type.name,
      removedTypeDescription: (_a = type.description) !== null && _a !== void 0 ? _a : ""
    }
  });
}
function buildTypeDescriptionAddedMessage(args) {
  return `Object type '${args.typeName}' has description '${args.addedTypeDescription}'`;
}
function typeDescriptionAddedFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    type: ChangeType.TypeDescriptionAdded,
    message: buildTypeDescriptionAddedMessage(args.meta),
    path: args.meta.typeName,
    meta: args.meta
  };
}
function typeDescriptionAdded(type) {
  var _a;
  return typeDescriptionAddedFromMeta({
    type: ChangeType.TypeDescriptionAdded,
    meta: {
      typeName: type.name,
      addedTypeDescription: (_a = type.description) !== null && _a !== void 0 ? _a : ""
    }
  });
}

// node_modules/@graphql-inspector/core/esm/diff/directive.js
function changesInDirective(oldDirective, newDirective, addChange) {
  if (isNotEqual(oldDirective.description, newDirective.description)) {
    addChange(directiveDescriptionChanged(oldDirective, newDirective));
  }
  const locations = {
    added: diffArrays(newDirective.locations, oldDirective.locations),
    removed: diffArrays(oldDirective.locations, newDirective.locations)
  };
  for (const location of locations.added)
    addChange(directiveLocationAdded(newDirective, location));
  for (const location of locations.removed)
    addChange(directiveLocationRemoved(oldDirective, location));
  compareLists(oldDirective.args, newDirective.args, {
    onAdded(arg) {
      addChange(directiveArgumentAdded(newDirective, arg));
    },
    onRemoved(arg) {
      addChange(directiveArgumentRemoved(oldDirective, arg));
    },
    onMutual(arg) {
      changesInDirectiveArgument(oldDirective, arg.oldVersion, arg.newVersion, addChange);
    }
  });
}
function changesInDirectiveArgument(directive, oldArg, newArg, addChange) {
  if (isNotEqual(oldArg.description, newArg.description)) {
    addChange(directiveArgumentDescriptionChanged(directive, oldArg, newArg));
  }
  if (isNotEqual(oldArg.defaultValue, newArg.defaultValue)) {
    addChange(directiveArgumentDefaultValueChanged(directive, oldArg, newArg));
  }
  if (isNotEqual(oldArg.type.toString(), newArg.type.toString())) {
    addChange(directiveArgumentTypeChanged(directive, oldArg, newArg));
  }
}

// node_modules/@graphql-inspector/core/esm/diff/changes/enum.js
function buildEnumValueRemovedMessage(args) {
  return `Enum value '${args.removedEnumValueName}' ${args.isEnumValueDeprecated ? "(deprecated) " : ""}was removed from enum '${args.enumName}'`;
}
var enumValueRemovedCriticalityBreakingReason = `Removing an enum value will cause existing queries that use this enum value to error.`;
function enumValueRemovedFromMeta(args) {
  return {
    type: ChangeType.EnumValueRemoved,
    criticality: {
      level: CriticalityLevel.Breaking,
      reason: enumValueRemovedCriticalityBreakingReason
    },
    message: buildEnumValueRemovedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.enumName, args.meta.removedEnumValueName].join(".")
  };
}
function enumValueRemoved(oldEnum, value) {
  return enumValueRemovedFromMeta({
    type: ChangeType.EnumValueRemoved,
    meta: {
      enumName: oldEnum.name,
      removedEnumValueName: value.name,
      isEnumValueDeprecated: isDeprecated(value)
    }
  });
}
function buildEnumValueAddedMessage(args) {
  return `Enum value '${args.meta.addedEnumValueName}' was added to enum '${args.meta.enumName}'`;
}
var enumValueAddedCriticalityDangerousReason = `Adding an enum value may break existing clients that were not programming defensively against an added case when querying an enum.`;
function enumValueAddedFromMeta(args) {
  return {
    type: ChangeType.EnumValueAdded,
    criticality: {
      level: CriticalityLevel.Dangerous,
      reason: enumValueAddedCriticalityDangerousReason
    },
    message: buildEnumValueAddedMessage(args),
    meta: args.meta,
    path: [args.meta.enumName, args.meta.addedEnumValueName].join(".")
  };
}
function enumValueAdded(newEnum, value) {
  return enumValueAddedFromMeta({
    type: ChangeType.EnumValueAdded,
    meta: {
      enumName: newEnum.name,
      addedEnumValueName: value.name
    }
  });
}
function buildEnumValueDescriptionChangedMessage(args) {
  var _a, _b, _c;
  return args.oldEnumValueDescription === null ? `Description '${(_a = args.newEnumValueDescription) !== null && _a !== void 0 ? _a : "undefined"}' was added to enum value '${args.enumName}.${args.enumValueName}'` : `Description for enum value '${args.enumName}.${args.enumValueName}' changed from '${(_b = args.oldEnumValueDescription) !== null && _b !== void 0 ? _b : "undefined"}' to '${(_c = args.newEnumValueDescription) !== null && _c !== void 0 ? _c : "undefined"}'`;
}
function enumValueDescriptionChangedFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    type: ChangeType.EnumValueDescriptionChanged,
    message: buildEnumValueDescriptionChangedMessage(args.meta),
    path: [args.meta.enumName, args.meta.enumValueName].join("."),
    meta: args.meta
  };
}
function enumValueDescriptionChanged(newEnum, oldValue, newValue) {
  var _a, _b;
  return enumValueDescriptionChangedFromMeta({
    type: ChangeType.EnumValueDescriptionChanged,
    meta: {
      enumName: newEnum.name,
      enumValueName: oldValue.name,
      oldEnumValueDescription: (_a = oldValue.description) !== null && _a !== void 0 ? _a : null,
      newEnumValueDescription: (_b = newValue.description) !== null && _b !== void 0 ? _b : null
    }
  });
}
function buildEnumValueDeprecationChangedMessage(args) {
  return `Enum value '${args.enumName}.${args.enumValueName}' deprecation reason changed from '${args.oldEnumValueDeprecationReason}' to '${args.newEnumValueDeprecationReason}'`;
}
function enumValueDeprecationReasonChangedFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    type: ChangeType.EnumValueDeprecationReasonChanged,
    message: buildEnumValueDeprecationChangedMessage(args.meta),
    path: [args.meta.enumName, args.meta.enumValueName].join("."),
    meta: args.meta
  };
}
function enumValueDeprecationReasonChanged(newEnum, oldValue, newValue) {
  var _a, _b;
  return enumValueDeprecationReasonChangedFromMeta({
    type: ChangeType.EnumValueDeprecationReasonChanged,
    meta: {
      enumName: newEnum.name,
      enumValueName: oldValue.name,
      oldEnumValueDeprecationReason: (_a = oldValue.deprecationReason) !== null && _a !== void 0 ? _a : "",
      newEnumValueDeprecationReason: (_b = newValue.deprecationReason) !== null && _b !== void 0 ? _b : ""
    }
  });
}
function buildEnumValueDeprecationReasonAddedMessage(args) {
  return `Enum value '${args.enumName}.${args.enumValueName}' was deprecated with reason '${args.addedValueDeprecationReason}'`;
}
function enumValueDeprecationReasonAddedFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    type: ChangeType.EnumValueDeprecationReasonAdded,
    message: buildEnumValueDeprecationReasonAddedMessage(args.meta),
    path: [args.meta.enumName, args.meta.enumValueName].join("."),
    meta: args.meta
  };
}
function enumValueDeprecationReasonAdded(newEnum, oldValue, newValue) {
  var _a;
  return enumValueDeprecationReasonAddedFromMeta({
    type: ChangeType.EnumValueDeprecationReasonAdded,
    meta: {
      enumName: newEnum.name,
      enumValueName: oldValue.name,
      addedValueDeprecationReason: (_a = newValue.deprecationReason) !== null && _a !== void 0 ? _a : ""
    }
  });
}
function buildEnumValueDeprecationReasonRemovedMessage(args) {
  return `Deprecation reason was removed from enum value '${args.enumName}.${args.enumValueName}'`;
}
function enumValueDeprecationReasonRemovedFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    type: ChangeType.EnumValueDeprecationReasonRemoved,
    message: buildEnumValueDeprecationReasonRemovedMessage(args.meta),
    path: [args.meta.enumName, args.meta.enumValueName].join("."),
    meta: args.meta
  };
}
function enumValueDeprecationReasonRemoved(newEnum, oldValue, _newValue) {
  var _a;
  return enumValueDeprecationReasonRemovedFromMeta({
    type: ChangeType.EnumValueDeprecationReasonRemoved,
    meta: {
      enumName: newEnum.name,
      enumValueName: oldValue.name,
      removedEnumValueDeprecationReason: (_a = oldValue.deprecationReason) !== null && _a !== void 0 ? _a : ""
    }
  });
}

// node_modules/@graphql-inspector/core/esm/diff/enum.js
function changesInEnum(oldEnum, newEnum, addChange) {
  compareLists(oldEnum.getValues(), newEnum.getValues(), {
    onAdded(value) {
      addChange(enumValueAdded(newEnum, value));
    },
    onRemoved(value) {
      addChange(enumValueRemoved(oldEnum, value));
    },
    onMutual(value) {
      const oldValue = value.oldVersion;
      const newValue = value.newVersion;
      if (isNotEqual(oldValue.description, newValue.description)) {
        addChange(enumValueDescriptionChanged(newEnum, oldValue, newValue));
      }
      if (isNotEqual(oldValue.deprecationReason, newValue.deprecationReason)) {
        if (isVoid2(oldValue.deprecationReason)) {
          addChange(enumValueDeprecationReasonAdded(newEnum, oldValue, newValue));
        } else if (isVoid2(newValue.deprecationReason)) {
          addChange(enumValueDeprecationReasonRemoved(newEnum, oldValue, newValue));
        } else {
          addChange(enumValueDeprecationReasonChanged(newEnum, oldValue, newValue));
        }
      }
    }
  });
}

// node_modules/@graphql-inspector/core/esm/diff/changes/input.js
function buildInputFieldRemovedMessage(args) {
  return `Input field '${args.removedFieldName}' ${args.isInputFieldDeprecated ? "(deprecated) " : ""}was removed from input object type '${args.inputName}'`;
}
function inputFieldRemovedFromMeta(args) {
  return {
    type: ChangeType.InputFieldRemoved,
    criticality: {
      level: CriticalityLevel.Breaking,
      reason: "Removing an input field will cause existing queries that use this input field to error."
    },
    message: buildInputFieldRemovedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.inputName, args.meta.removedFieldName].join(".")
  };
}
function inputFieldRemoved(input, field) {
  return inputFieldRemovedFromMeta({
    type: ChangeType.InputFieldRemoved,
    meta: {
      inputName: input.name,
      removedFieldName: field.name,
      isInputFieldDeprecated: isDeprecated(field)
    }
  });
}
function buildInputFieldAddedMessage(args) {
  return `Input field '${args.addedInputFieldName}' of type '${args.addedInputFieldType}' was added to input object type '${args.inputName}'`;
}
function inputFieldAddedFromMeta(args) {
  return {
    type: ChangeType.InputFieldAdded,
    criticality: args.meta.isAddedInputFieldTypeNullable ? {
      level: CriticalityLevel.Dangerous
    } : {
      level: CriticalityLevel.Breaking,
      reason: "Adding a required input field to an existing input object type is a breaking change because it will cause existing uses of this input object type to error."
    },
    message: buildInputFieldAddedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.inputName, args.meta.addedInputFieldName].join(".")
  };
}
function inputFieldAdded(input, field) {
  return inputFieldAddedFromMeta({
    type: ChangeType.InputFieldAdded,
    meta: {
      inputName: input.name,
      addedInputFieldName: field.name,
      isAddedInputFieldTypeNullable: !isNonNullType(field.type),
      addedInputFieldType: field.type.toString()
    }
  });
}
function buildInputFieldDescriptionAddedMessage(args) {
  return `Input field '${args.inputName}.${args.inputFieldName}' has description '${args.addedInputFieldDescription}'`;
}
function inputFieldDescriptionAddedFromMeta(args) {
  return {
    type: ChangeType.InputFieldDescriptionAdded,
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    message: buildInputFieldDescriptionAddedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.inputName, args.meta.inputFieldName].join(".")
  };
}
function inputFieldDescriptionAdded(type, field) {
  var _a;
  return inputFieldDescriptionAddedFromMeta({
    type: ChangeType.InputFieldDescriptionAdded,
    meta: {
      inputName: type.name,
      inputFieldName: field.name,
      addedInputFieldDescription: (_a = field.description) !== null && _a !== void 0 ? _a : ""
    }
  });
}
function buildInputFieldDescriptionRemovedMessage(args) {
  return `Description '${args.removedDescription}' was removed from input field '${args.inputName}.${args.inputFieldName}'`;
}
function inputFieldDescriptionRemovedFromMeta(args) {
  return {
    type: ChangeType.InputFieldDescriptionRemoved,
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    message: buildInputFieldDescriptionRemovedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.inputName, args.meta.inputFieldName].join(".")
  };
}
function inputFieldDescriptionRemoved(type, field) {
  var _a;
  return inputFieldDescriptionRemovedFromMeta({
    type: ChangeType.InputFieldDescriptionRemoved,
    meta: {
      inputName: type.name,
      inputFieldName: field.name,
      removedDescription: (_a = field.description) !== null && _a !== void 0 ? _a : ""
    }
  });
}
function buildInputFieldDescriptionChangedMessage(args) {
  return `Input field '${args.inputName}.${args.inputFieldName}' description changed from '${args.oldInputFieldDescription}' to '${args.newInputFieldDescription}'`;
}
function inputFieldDescriptionChangedFromMeta(args) {
  return {
    type: ChangeType.InputFieldDescriptionChanged,
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    message: buildInputFieldDescriptionChangedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.inputName, args.meta.inputFieldName].join(".")
  };
}
function inputFieldDescriptionChanged(input, oldField, newField) {
  var _a, _b;
  return inputFieldDescriptionChangedFromMeta({
    type: ChangeType.InputFieldDescriptionChanged,
    meta: {
      inputName: input.name,
      inputFieldName: oldField.name,
      oldInputFieldDescription: (_a = oldField.description) !== null && _a !== void 0 ? _a : "",
      newInputFieldDescription: (_b = newField.description) !== null && _b !== void 0 ? _b : ""
    }
  });
}
function buildInputFieldDefaultValueChangedMessage(args) {
  return `Input field '${args.inputName}.${args.inputFieldName}' default value changed from '${args.oldDefaultValue}' to '${args.newDefaultValue}'`;
}
function inputFieldDefaultValueChangedFromMeta(args) {
  return {
    type: ChangeType.InputFieldDefaultValueChanged,
    criticality: {
      level: CriticalityLevel.Dangerous,
      reason: "Changing the default value for an argument may change the runtime behavior of a field if it was never provided."
    },
    message: buildInputFieldDefaultValueChangedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.inputName, args.meta.inputFieldName].join(".")
  };
}
function inputFieldDefaultValueChanged(input, oldField, newField) {
  const meta = {
    inputName: input.name,
    inputFieldName: oldField.name
  };
  if (oldField.defaultValue !== void 0) {
    meta.oldDefaultValue = safeString(oldField.defaultValue);
  }
  if (newField.defaultValue !== void 0) {
    meta.newDefaultValue = safeString(newField.defaultValue);
  }
  return inputFieldDefaultValueChangedFromMeta({
    type: ChangeType.InputFieldDefaultValueChanged,
    meta
  });
}
function buildInputFieldTypeChangedMessage(args) {
  return `Input field '${args.inputName}.${args.inputFieldName}' changed type from '${args.oldInputFieldType}' to '${args.newInputFieldType}'`;
}
function inputFieldTypeChangedFromMeta(args) {
  return {
    type: ChangeType.InputFieldTypeChanged,
    criticality: args.meta.isInputFieldTypeChangeSafe ? {
      level: CriticalityLevel.NonBreaking,
      reason: "Changing an input field from non-null to null is considered non-breaking."
    } : {
      level: CriticalityLevel.Breaking,
      reason: "Changing the type of an input field can cause existing queries that use this field to error."
    },
    message: buildInputFieldTypeChangedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.inputName, args.meta.inputFieldName].join(".")
  };
}
function inputFieldTypeChanged(input, oldField, newField) {
  return inputFieldTypeChangedFromMeta({
    type: ChangeType.InputFieldTypeChanged,
    meta: {
      inputName: input.name,
      inputFieldName: oldField.name,
      oldInputFieldType: oldField.type.toString(),
      newInputFieldType: newField.type.toString(),
      isInputFieldTypeChangeSafe: safeChangeForInputValue(oldField.type, newField.type)
    }
  });
}

// node_modules/@graphql-inspector/core/esm/diff/input.js
function changesInInputObject(oldInput, newInput, addChange) {
  const oldFields = oldInput.getFields();
  const newFields = newInput.getFields();
  compareLists(Object.values(oldFields), Object.values(newFields), {
    onAdded(field) {
      addChange(inputFieldAdded(newInput, field));
    },
    onRemoved(field) {
      addChange(inputFieldRemoved(oldInput, field));
    },
    onMutual(field) {
      changesInInputField(oldInput, field.oldVersion, field.newVersion, addChange);
    }
  });
}
function changesInInputField(input, oldField, newField, addChange) {
  if (isNotEqual(oldField.description, newField.description)) {
    if (isVoid2(oldField.description)) {
      addChange(inputFieldDescriptionAdded(input, newField));
    } else if (isVoid2(newField.description)) {
      addChange(inputFieldDescriptionRemoved(input, oldField));
    } else {
      addChange(inputFieldDescriptionChanged(input, oldField, newField));
    }
  }
  if (isNotEqual(oldField.defaultValue, newField.defaultValue)) {
    if (Array.isArray(oldField.defaultValue) && Array.isArray(newField.defaultValue)) {
      if (diffArrays(oldField.defaultValue, newField.defaultValue).length > 0) {
        addChange(inputFieldDefaultValueChanged(input, oldField, newField));
      }
    } else if (JSON.stringify(oldField.defaultValue) !== JSON.stringify(newField.defaultValue)) {
      addChange(inputFieldDefaultValueChanged(input, oldField, newField));
    }
  }
  if (isNotEqual(oldField.type.toString(), newField.type.toString())) {
    addChange(inputFieldTypeChanged(input, oldField, newField));
  }
}

// node_modules/@graphql-inspector/core/esm/diff/changes/field.js
function buildFieldRemovedMessage(args) {
  return `Field '${args.removedFieldName}' ${args.isRemovedFieldDeprecated ? "(deprecated) " : ""}was removed from ${args.typeType} '${args.typeName}'`;
}
function fieldRemovedFromMeta(args) {
  return {
    type: ChangeType.FieldRemoved,
    criticality: {
      level: CriticalityLevel.Breaking,
      reason: args.meta.isRemovedFieldDeprecated ? `Removing a deprecated field is a breaking change. Before removing it, you may want to look at the field's usage to see the impact of removing the field.` : `Removing a field is a breaking change. It is preferable to deprecate the field before removing it.`
    },
    message: buildFieldRemovedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.typeName, args.meta.removedFieldName].join(".")
  };
}
function fieldRemoved(type, field) {
  const entity = isInterfaceType(type) ? "interface" : "object type";
  return fieldRemovedFromMeta({
    type: ChangeType.FieldRemoved,
    meta: {
      typeName: type.name,
      removedFieldName: field.name,
      isRemovedFieldDeprecated: field.deprecationReason != null,
      typeType: entity
    }
  });
}
function buildFieldAddedMessage(args) {
  return `Field '${args.addedFieldName}' was added to ${args.typeType} '${args.typeName}'`;
}
function fieldAddedFromMeta(args) {
  return {
    type: ChangeType.FieldAdded,
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    message: buildFieldAddedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.typeName, args.meta.addedFieldName].join(".")
  };
}
function fieldAdded(type, field) {
  const entity = isInterfaceType(type) ? "interface" : "object type";
  return fieldAddedFromMeta({
    type: ChangeType.FieldAdded,
    meta: {
      typeName: type.name,
      addedFieldName: field.name,
      typeType: entity
    }
  });
}
function buildFieldDescriptionChangedMessage(args) {
  return `Field '${args.typeName}.${args.fieldName}' description changed from '${args.oldDescription}' to '${args.newDescription}'`;
}
function fieldDescriptionChangedFromMeta(args) {
  return {
    type: ChangeType.FieldDescriptionChanged,
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    message: buildFieldDescriptionChangedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.typeName, args.meta.fieldName].join(".")
  };
}
function fieldDescriptionChanged(type, oldField, newField) {
  var _a, _b;
  return fieldDescriptionChangedFromMeta({
    type: ChangeType.FieldDescriptionChanged,
    meta: {
      fieldName: oldField.name,
      typeName: type.name,
      oldDescription: (_a = oldField.description) !== null && _a !== void 0 ? _a : "",
      newDescription: (_b = newField.description) !== null && _b !== void 0 ? _b : ""
    }
  });
}
function buildFieldDescriptionAddedMessage(args) {
  return `Field '${args.typeName}.${args.fieldName}' has description '${args.addedDescription}'`;
}
function fieldDescriptionAddedFromMeta(args) {
  return {
    type: ChangeType.FieldDescriptionAdded,
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    message: buildFieldDescriptionAddedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.typeName, args.meta.fieldName].join(".")
  };
}
function fieldDescriptionAdded(type, field) {
  var _a;
  return fieldDescriptionAddedFromMeta({
    type: ChangeType.FieldDescriptionAdded,
    meta: {
      typeName: type.name,
      fieldName: field.name,
      addedDescription: (_a = field.description) !== null && _a !== void 0 ? _a : ""
    }
  });
}
function buildFieldDescriptionRemovedMessage(args) {
  return `Description was removed from field '${args.typeName}.${args.fieldName}'`;
}
function fieldDescriptionRemovedFromMeta(args) {
  return {
    type: ChangeType.FieldDescriptionRemoved,
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    message: buildFieldDescriptionRemovedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.typeName, args.meta.fieldName].join(".")
  };
}
function fieldDescriptionRemoved(type, field) {
  return fieldDescriptionRemovedFromMeta({
    type: ChangeType.FieldDescriptionRemoved,
    meta: {
      typeName: type.name,
      fieldName: field.name
    }
  });
}
function buildFieldDeprecatedAddedMessage(args) {
  return `Field '${args.typeName}.${args.fieldName}' is deprecated`;
}
function fieldDeprecationAddedFromMeta(args) {
  return {
    type: ChangeType.FieldDeprecationAdded,
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    message: buildFieldDeprecatedAddedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.typeName, args.meta.fieldName].join(".")
  };
}
function fieldDeprecationAdded(type, field) {
  return fieldDeprecationAddedFromMeta({
    type: ChangeType.FieldDeprecationAdded,
    meta: {
      typeName: type.name,
      fieldName: field.name
    }
  });
}
function fieldDeprecationRemovedFromMeta(args) {
  return {
    type: ChangeType.FieldDeprecationRemoved,
    criticality: {
      level: CriticalityLevel.Dangerous
    },
    message: `Field '${args.meta.typeName}.${args.meta.fieldName}' is no longer deprecated`,
    meta: args.meta,
    path: [args.meta.typeName, args.meta.fieldName].join(".")
  };
}
function fieldDeprecationRemoved(type, field) {
  return fieldDeprecationRemovedFromMeta({
    type: ChangeType.FieldDeprecationRemoved,
    meta: {
      fieldName: field.name,
      typeName: type.name
    }
  });
}
function buildFieldDeprecationReasonChangedMessage(args) {
  return `Deprecation reason on field '${args.typeName}.${args.fieldName}' has changed from '${args.oldDeprecationReason}' to '${args.newDeprecationReason}'`;
}
function fieldDeprecationReasonChangedFromMeta(args) {
  return {
    type: ChangeType.FieldDeprecationReasonChanged,
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    message: buildFieldDeprecationReasonChangedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.typeName, args.meta.fieldName].join(".")
  };
}
function fieldDeprecationReasonChanged(type, oldField, newField) {
  var _a, _b;
  return fieldDeprecationReasonChangedFromMeta({
    type: ChangeType.FieldDeprecationReasonChanged,
    meta: {
      fieldName: newField.name,
      typeName: type.name,
      newDeprecationReason: (_a = newField.deprecationReason) !== null && _a !== void 0 ? _a : "",
      oldDeprecationReason: (_b = oldField.deprecationReason) !== null && _b !== void 0 ? _b : ""
    }
  });
}
function buildFieldDeprecationReasonAddedMessage(args) {
  return `Field '${args.typeName}.${args.fieldName}' has deprecation reason '${args.addedDeprecationReason}'`;
}
function fieldDeprecationReasonAddedFromMeta(args) {
  return {
    type: ChangeType.FieldDeprecationReasonAdded,
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    message: buildFieldDeprecationReasonAddedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.typeName, args.meta.fieldName].join(".")
  };
}
function fieldDeprecationReasonAdded(type, field) {
  var _a;
  return fieldDeprecationReasonAddedFromMeta({
    type: ChangeType.FieldDeprecationReasonAdded,
    meta: {
      typeName: type.name,
      fieldName: field.name,
      addedDeprecationReason: (_a = field.deprecationReason) !== null && _a !== void 0 ? _a : ""
    }
  });
}
function fieldDeprecationReasonRemovedFromMeta(args) {
  return {
    type: ChangeType.FieldDeprecationReasonRemoved,
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    message: `Deprecation reason was removed from field '${args.meta.typeName}.${args.meta.fieldName}'`,
    meta: args.meta,
    path: [args.meta.typeName, args.meta.fieldName].join(".")
  };
}
function fieldDeprecationReasonRemoved(type, field) {
  return fieldDeprecationReasonRemovedFromMeta({
    type: ChangeType.FieldDeprecationReasonRemoved,
    meta: {
      typeName: type.name,
      fieldName: field.name
    }
  });
}
function buildFieldTypeChangedMessage(args) {
  return `Field '${args.meta.typeName}.${args.meta.fieldName}' changed type from '${args.meta.oldFieldType}' to '${args.meta.newFieldType}'`;
}
function fieldTypeChangedFromMeta(args) {
  return {
    type: ChangeType.FieldTypeChanged,
    criticality: {
      level: args.meta.isSafeFieldTypeChange ? CriticalityLevel.NonBreaking : CriticalityLevel.Breaking
    },
    message: buildFieldTypeChangedMessage(args),
    meta: args.meta,
    path: [args.meta.typeName, args.meta.fieldName].join(".")
  };
}
function fieldTypeChanged(type, oldField, newField) {
  return fieldTypeChangedFromMeta({
    type: ChangeType.FieldTypeChanged,
    meta: {
      typeName: type.name,
      fieldName: oldField.name,
      oldFieldType: oldField.type.toString(),
      newFieldType: newField.type.toString(),
      isSafeFieldTypeChange: safeChangeForField(oldField.type, newField.type)
    }
  });
}
function buildFieldArgumentAddedMessage(args) {
  return `Argument '${args.addedArgumentName}: ${args.addedArgumentType}'${args.hasDefaultValue ? " (with default value) " : " "}added to field '${args.typeName}.${args.fieldName}'`;
}
function fieldArgumentAddedFromMeta(args) {
  return {
    type: ChangeType.FieldArgumentAdded,
    criticality: {
      level: args.meta.isAddedFieldArgumentBreaking ? CriticalityLevel.Breaking : CriticalityLevel.Dangerous
    },
    message: buildFieldArgumentAddedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.typeName, args.meta.fieldName, args.meta.addedArgumentName].join(".")
  };
}
function fieldArgumentAdded(type, field, arg) {
  const isBreaking = isNonNullType(arg.type) && typeof arg.defaultValue === "undefined";
  return fieldArgumentAddedFromMeta({
    type: ChangeType.FieldArgumentAdded,
    meta: {
      typeName: type.name,
      fieldName: field.name,
      addedArgumentName: arg.name,
      addedArgumentType: arg.type.toString(),
      hasDefaultValue: arg.defaultValue != null,
      isAddedFieldArgumentBreaking: isBreaking
    }
  });
}
function buildFieldArgumentRemovedMessage(args) {
  return `Argument '${args.meta.removedFieldArgumentName}: ${args.meta.removedFieldType}' was removed from field '${args.meta.typeName}.${args.meta.fieldName}'`;
}
function fieldArgumentRemovedFromMeta(args) {
  return {
    type: ChangeType.FieldArgumentRemoved,
    criticality: {
      level: CriticalityLevel.Breaking
    },
    message: buildFieldArgumentRemovedMessage(args),
    meta: args.meta,
    path: [args.meta.typeName, args.meta.fieldName, args.meta.removedFieldArgumentName].join(".")
  };
}
function fieldArgumentRemoved(type, field, arg) {
  return fieldArgumentRemovedFromMeta({
    type: ChangeType.FieldArgumentRemoved,
    meta: {
      typeName: type.name,
      fieldName: field.name,
      removedFieldArgumentName: arg.name,
      removedFieldType: arg.type.toString()
    }
  });
}

// node_modules/@graphql-inspector/core/esm/diff/changes/argument.js
function buildFieldArgumentDescriptionChangedMessage(args) {
  return `Description for argument '${args.argumentName}' on field '${args.typeName}.${args.fieldName}' changed from '${args.oldDescription}' to '${args.newDescription}'`;
}
function fieldArgumentDescriptionChangedFromMeta(args) {
  return {
    type: ChangeType.FieldArgumentDescriptionChanged,
    criticality: {
      level: CriticalityLevel.NonBreaking
    },
    message: buildFieldArgumentDescriptionChangedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.typeName, args.meta.fieldName, args.meta.argumentName].join(".")
  };
}
function fieldArgumentDescriptionChanged(type, field, oldArg, newArg) {
  var _a, _b;
  return fieldArgumentDescriptionChangedFromMeta({
    type: ChangeType.FieldArgumentDescriptionChanged,
    meta: {
      typeName: type.name,
      fieldName: field.name,
      argumentName: oldArg.name,
      oldDescription: (_a = oldArg.description) !== null && _a !== void 0 ? _a : null,
      newDescription: (_b = newArg.description) !== null && _b !== void 0 ? _b : null
    }
  });
}
function buildFieldArgumentDefaultChangedMessage(args) {
  return args.oldDefaultValue === void 0 ? `Default value '${args.newDefaultValue}' was added to argument '${args.argumentName}' on field '${args.typeName}.${args.fieldName}'` : `Default value for argument '${args.argumentName}' on field '${args.typeName}.${args.fieldName}' changed from '${args.oldDefaultValue}' to '${args.newDefaultValue}'`;
}
var fieldArgumentDefaultChangedCriticalityDangerousReason = "Changing the default value for an argument may change the runtime behaviour of a field if it was never provided.";
function fieldArgumentDefaultChangedFromMeta(args) {
  return {
    type: ChangeType.FieldArgumentDefaultChanged,
    criticality: {
      level: CriticalityLevel.Dangerous,
      reason: fieldArgumentDefaultChangedCriticalityDangerousReason
    },
    message: buildFieldArgumentDefaultChangedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.typeName, args.meta.fieldName, args.meta.argumentName].join(".")
  };
}
function fieldArgumentDefaultChanged(type, field, oldArg, newArg) {
  const meta = {
    typeName: type.name,
    fieldName: field.name,
    argumentName: newArg.name
  };
  if (oldArg.defaultValue !== void 0) {
    meta.oldDefaultValue = safeString(oldArg.defaultValue);
  }
  if (newArg.defaultValue !== void 0) {
    meta.newDefaultValue = safeString(newArg.defaultValue);
  }
  return fieldArgumentDefaultChangedFromMeta({
    type: ChangeType.FieldArgumentDefaultChanged,
    meta
  });
}
function buildFieldArgumentTypeChangedMessage(args) {
  return `Type for argument '${args.argumentName}' on field '${args.typeName}.${args.fieldName}' changed from '${args.oldArgumentType}' to '${args.newArgumentType}'`;
}
var fieldArgumentTypeChangedCriticalityNonBreakingReason = `Changing an input field from non-null to null is considered non-breaking.`;
var fieldArgumentTypeChangedCriticalityBreakingReason = `Changing the type of a field's argument can cause existing queries that use this argument to error.`;
function fieldArgumentTypeChangedFromMeta(args) {
  return {
    type: ChangeType.FieldArgumentTypeChanged,
    criticality: args.meta.isSafeArgumentTypeChange ? {
      level: CriticalityLevel.NonBreaking,
      reason: fieldArgumentTypeChangedCriticalityNonBreakingReason
    } : {
      level: CriticalityLevel.Breaking,
      reason: fieldArgumentTypeChangedCriticalityBreakingReason
    },
    message: buildFieldArgumentTypeChangedMessage(args.meta),
    meta: args.meta,
    path: [args.meta.typeName, args.meta.fieldName, args.meta.argumentName].join(".")
  };
}
function fieldArgumentTypeChanged(type, field, oldArg, newArg) {
  return fieldArgumentTypeChangedFromMeta({
    type: ChangeType.FieldArgumentTypeChanged,
    meta: {
      typeName: type.name,
      fieldName: field.name,
      argumentName: newArg.name,
      oldArgumentType: oldArg.type.toString(),
      newArgumentType: newArg.type.toString(),
      isSafeArgumentTypeChange: safeChangeForInputValue(oldArg.type, newArg.type)
    }
  });
}

// node_modules/@graphql-inspector/core/esm/diff/argument.js
function changesInArgument(type, field, oldArg, newArg, addChange) {
  if (isNotEqual(oldArg.description, newArg.description)) {
    addChange(fieldArgumentDescriptionChanged(type, field, oldArg, newArg));
  }
  if (isNotEqual(oldArg.defaultValue, newArg.defaultValue)) {
    if (Array.isArray(oldArg.defaultValue) && Array.isArray(newArg.defaultValue)) {
      const diff3 = diffArrays(oldArg.defaultValue, newArg.defaultValue);
      if (diff3.length > 0) {
        addChange(fieldArgumentDefaultChanged(type, field, oldArg, newArg));
      }
    } else if (JSON.stringify(oldArg.defaultValue) !== JSON.stringify(newArg.defaultValue)) {
      addChange(fieldArgumentDefaultChanged(type, field, oldArg, newArg));
    }
  }
  if (isNotEqual(oldArg.type.toString(), newArg.type.toString())) {
    addChange(fieldArgumentTypeChanged(type, field, oldArg, newArg));
  }
}

// node_modules/@graphql-inspector/core/esm/diff/field.js
function changesInField(type, oldField, newField, addChange) {
  if (isNotEqual(oldField.description, newField.description)) {
    if (isVoid2(oldField.description)) {
      addChange(fieldDescriptionAdded(type, newField));
    } else if (isVoid2(newField.description)) {
      addChange(fieldDescriptionRemoved(type, oldField));
    } else {
      addChange(fieldDescriptionChanged(type, oldField, newField));
    }
  }
  if (isNotEqual(isDeprecated(oldField), isDeprecated(newField))) {
    if (isDeprecated(newField)) {
      addChange(fieldDeprecationAdded(type, newField));
    } else {
      addChange(fieldDeprecationRemoved(type, oldField));
    }
  }
  if (isNotEqual(oldField.deprecationReason, newField.deprecationReason)) {
    if (isVoid2(oldField.deprecationReason)) {
      addChange(fieldDeprecationReasonAdded(type, newField));
    } else if (isVoid2(newField.deprecationReason)) {
      addChange(fieldDeprecationReasonRemoved(type, oldField));
    } else {
      addChange(fieldDeprecationReasonChanged(type, oldField, newField));
    }
  }
  if (isNotEqual(oldField.type.toString(), newField.type.toString())) {
    addChange(fieldTypeChanged(type, oldField, newField));
  }
  compareLists(oldField.args, newField.args, {
    onAdded(arg) {
      addChange(fieldArgumentAdded(type, newField, arg));
    },
    onRemoved(arg) {
      addChange(fieldArgumentRemoved(type, oldField, arg));
    },
    onMutual(arg) {
      changesInArgument(type, oldField, arg.oldVersion, arg.newVersion, addChange);
    }
  });
}

// node_modules/@graphql-inspector/core/esm/diff/interface.js
function changesInInterface(oldInterface, newInterface, addChange) {
  compareLists(Object.values(oldInterface.getFields()), Object.values(newInterface.getFields()), {
    onAdded(field) {
      addChange(fieldAdded(newInterface, field));
    },
    onRemoved(field) {
      addChange(fieldRemoved(oldInterface, field));
    },
    onMutual(field) {
      changesInField(oldInterface, field.oldVersion, field.newVersion, addChange);
    }
  });
}

// node_modules/@graphql-inspector/core/esm/diff/changes/object.js
function buildObjectTypeInterfaceAddedMessage(args) {
  return `'${args.objectTypeName}' object implements '${args.addedInterfaceName}' interface`;
}
function objectTypeInterfaceAddedFromMeta(args) {
  return {
    type: ChangeType.ObjectTypeInterfaceAdded,
    criticality: {
      level: CriticalityLevel.Dangerous,
      reason: "Adding an interface to an object type may break existing clients that were not programming defensively against a new possible type."
    },
    message: buildObjectTypeInterfaceAddedMessage(args.meta),
    meta: args.meta,
    path: args.meta.objectTypeName
  };
}
function objectTypeInterfaceAdded(iface, type) {
  return objectTypeInterfaceAddedFromMeta({
    type: ChangeType.ObjectTypeInterfaceAdded,
    meta: {
      objectTypeName: type.name,
      addedInterfaceName: iface.name
    }
  });
}
function buildObjectTypeInterfaceRemovedMessage(args) {
  return `'${args.objectTypeName}' object type no longer implements '${args.removedInterfaceName}' interface`;
}
function objectTypeInterfaceRemovedFromMeta(args) {
  return {
    type: ChangeType.ObjectTypeInterfaceRemoved,
    criticality: {
      level: CriticalityLevel.Breaking,
      reason: "Removing an interface from an object type can cause existing queries that use this in a fragment spread to error."
    },
    message: buildObjectTypeInterfaceRemovedMessage(args.meta),
    meta: args.meta,
    path: args.meta.objectTypeName
  };
}
function objectTypeInterfaceRemoved(iface, type) {
  return objectTypeInterfaceRemovedFromMeta({
    type: ChangeType.ObjectTypeInterfaceRemoved,
    meta: {
      objectTypeName: type.name,
      removedInterfaceName: iface.name
    }
  });
}

// node_modules/@graphql-inspector/core/esm/diff/object.js
function changesInObject(oldType, newType, addChange) {
  const oldInterfaces = oldType.getInterfaces();
  const newInterfaces = newType.getInterfaces();
  const oldFields = oldType.getFields();
  const newFields = newType.getFields();
  compareLists(oldInterfaces, newInterfaces, {
    onAdded(i15) {
      addChange(objectTypeInterfaceAdded(i15, newType));
    },
    onRemoved(i15) {
      addChange(objectTypeInterfaceRemoved(i15, oldType));
    }
  });
  compareLists(Object.values(oldFields), Object.values(newFields), {
    onAdded(f16) {
      addChange(fieldAdded(newType, f16));
    },
    onRemoved(f16) {
      addChange(fieldRemoved(oldType, f16));
    },
    onMutual(f16) {
      changesInField(oldType, f16.oldVersion, f16.newVersion, addChange);
    }
  });
}

// node_modules/@graphql-inspector/core/esm/diff/changes/union.js
function buildUnionMemberRemovedMessage(args) {
  return `Member '${args.removedUnionMemberTypeName}' was removed from Union type '${args.unionName}'`;
}
function unionMemberRemovedFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.Breaking,
      reason: "Removing a union member from a union can cause existing queries that use this union member in a fragment spread to error."
    },
    type: ChangeType.UnionMemberRemoved,
    message: buildUnionMemberRemovedMessage(args.meta),
    meta: args.meta,
    path: args.meta.unionName
  };
}
function unionMemberRemoved(union, type) {
  return unionMemberRemovedFromMeta({
    type: ChangeType.UnionMemberRemoved,
    meta: {
      unionName: union.name,
      removedUnionMemberTypeName: type.name
    }
  });
}
function buildUnionMemberAddedMessage(args) {
  return `Member '${args.addedUnionMemberTypeName}' was added to Union type '${args.unionName}'`;
}
function buildUnionMemberAddedMessageFromMeta(args) {
  return {
    criticality: {
      level: CriticalityLevel.Dangerous,
      reason: "Adding a possible type to Unions may break existing clients that were not programming defensively against a new possible type."
    },
    type: ChangeType.UnionMemberAdded,
    message: buildUnionMemberAddedMessage(args.meta),
    meta: args.meta,
    path: args.meta.unionName
  };
}
function unionMemberAdded(union, type) {
  return buildUnionMemberAddedMessageFromMeta({
    type: ChangeType.UnionMemberAdded,
    meta: {
      unionName: union.name,
      addedUnionMemberTypeName: type.name
    }
  });
}

// node_modules/@graphql-inspector/core/esm/diff/union.js
function changesInUnion(oldUnion, newUnion, addChange) {
  const oldTypes = oldUnion.getTypes();
  const newTypes = newUnion.getTypes();
  compareLists(oldTypes, newTypes, {
    onAdded(t20) {
      addChange(unionMemberAdded(newUnion, t20));
    },
    onRemoved(t20) {
      addChange(unionMemberRemoved(oldUnion, t20));
    }
  });
}

// node_modules/@graphql-inspector/core/esm/diff/schema.js
function diffSchema(oldSchema, newSchema) {
  const changes = [];
  function addChange(change) {
    changes.push(change);
  }
  changesInSchema(oldSchema, newSchema, addChange);
  compareLists(Object.values(oldSchema.getTypeMap()).filter((t20) => !isPrimitive(t20)), Object.values(newSchema.getTypeMap()).filter((t20) => !isPrimitive(t20)), {
    onAdded(type) {
      addChange(typeAdded(type));
    },
    onRemoved(type) {
      addChange(typeRemoved(type));
    },
    onMutual(type) {
      changesInType(type.oldVersion, type.newVersion, addChange);
    }
  });
  compareLists(oldSchema.getDirectives(), newSchema.getDirectives(), {
    onAdded(directive) {
      addChange(directiveAdded(directive));
    },
    onRemoved(directive) {
      addChange(directiveRemoved(directive));
    },
    onMutual(directive) {
      changesInDirective(directive.oldVersion, directive.newVersion, addChange);
    }
  });
  return changes;
}
function changesInSchema(oldSchema, newSchema, addChange) {
  var _a, _b, _c, _d, _e4, _f;
  const defaultNames = {
    query: "Query",
    mutation: "Mutation",
    subscription: "Subscription"
  };
  const oldRoot = {
    query: (_a = (oldSchema.getQueryType() || {}).name) !== null && _a !== void 0 ? _a : defaultNames.query,
    mutation: (_b = (oldSchema.getMutationType() || {}).name) !== null && _b !== void 0 ? _b : defaultNames.mutation,
    subscription: (_c = (oldSchema.getSubscriptionType() || {}).name) !== null && _c !== void 0 ? _c : defaultNames.subscription
  };
  const newRoot = {
    query: (_d = (newSchema.getQueryType() || {}).name) !== null && _d !== void 0 ? _d : defaultNames.query,
    mutation: (_e4 = (newSchema.getMutationType() || {}).name) !== null && _e4 !== void 0 ? _e4 : defaultNames.mutation,
    subscription: (_f = (newSchema.getSubscriptionType() || {}).name) !== null && _f !== void 0 ? _f : defaultNames.subscription
  };
  if (isNotEqual(oldRoot.query, newRoot.query)) {
    addChange(schemaQueryTypeChanged(oldSchema, newSchema));
  }
  if (isNotEqual(oldRoot.mutation, newRoot.mutation)) {
    addChange(schemaMutationTypeChanged(oldSchema, newSchema));
  }
  if (isNotEqual(oldRoot.subscription, newRoot.subscription)) {
    addChange(schemaSubscriptionTypeChanged(oldSchema, newSchema));
  }
}
function changesInType(oldType, newType, addChange) {
  if (isEnumType(oldType) && isEnumType(newType)) {
    changesInEnum(oldType, newType, addChange);
  } else if (isUnionType(oldType) && isUnionType(newType)) {
    changesInUnion(oldType, newType, addChange);
  } else if (isInputObjectType(oldType) && isInputObjectType(newType)) {
    changesInInputObject(oldType, newType, addChange);
  } else if (isObjectType(oldType) && isObjectType(newType)) {
    changesInObject(oldType, newType, addChange);
  } else if (isInterfaceType(oldType) && isInterfaceType(newType)) {
    changesInInterface(oldType, newType, addChange);
  } else if (isScalarType(oldType) && isScalarType(newType)) {
  } else {
    addChange(typeKindChanged(oldType, newType));
  }
  if (isNotEqual(oldType.description, newType.description)) {
    if (isVoid2(oldType.description)) {
      addChange(typeDescriptionAdded(newType));
    } else if (isVoid2(newType.description)) {
      addChange(typeDescriptionRemoved(oldType));
    } else {
      addChange(typeDescriptionChanged(oldType, newType));
    }
  }
}

// node_modules/@graphql-inspector/core/esm/diff/index.js
function diff2(oldSchema, newSchema, rules = [], config2) {
  const changes = diffSchema(oldSchema, newSchema);
  return rules.reduce((prev, rule) => __awaiter(this, void 0, void 0, function* () {
    const prevChanges = yield prev;
    return rule({
      changes: prevChanges,
      oldSchema,
      newSchema,
      config: config2
    });
  }), Promise.resolve(changes));
}

// node_modules/@graphql-inspector/core/esm/validate/index.js
var import_dependency_graph = __toESM(require_dep_graph(), 1);

// node_modules/@graphql-inspector/core/esm/validate/token-count.js
var import_parser = __toESM(require_parser(), 1);

// node_modules/react-router-dom/dist/index.js
var React70 = __toESM(require_react());

// node_modules/@remix-run/router/dist/router.js
function _extends21() {
  _extends21 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i15 = 1; i15 < arguments.length; i15++) {
      var source = arguments[i15];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends21.apply(this, arguments);
}
var Action;
(function(Action2) {
  Action2["Pop"] = "POP";
  Action2["Push"] = "PUSH";
  Action2["Replace"] = "REPLACE";
})(Action || (Action = {}));
var PopStateEventType = "popstate";
function createHashHistory(options) {
  if (options === void 0) {
    options = {};
  }
  function createHashLocation(window2, globalHistory) {
    let {
      pathname = "/",
      search = "",
      hash: hash2 = ""
    } = parsePath2(window2.location.hash.substr(1));
    return createLocation(
      "",
      {
        pathname,
        search,
        hash: hash2
      },
      // state defaults to `null` because `window.history.state` does
      globalHistory.state && globalHistory.state.usr || null,
      globalHistory.state && globalHistory.state.key || "default"
    );
  }
  function createHashHref(window2, to4) {
    let base = window2.document.querySelector("base");
    let href = "";
    if (base && base.getAttribute("href")) {
      let url = window2.location.href;
      let hashIndex = url.indexOf("#");
      href = hashIndex === -1 ? url : url.slice(0, hashIndex);
    }
    return href + "#" + (typeof to4 === "string" ? to4 : createPath(to4));
  }
  function validateHashLocation(location, to4) {
    warning3(location.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(to4) + ")");
  }
  return getUrlBasedHistory(createHashLocation, createHashHref, validateHashLocation, options);
}
function invariant3(value, message) {
  if (value === false || value === null || typeof value === "undefined") {
    throw new Error(message);
  }
}
function warning3(cond, message) {
  if (!cond) {
    if (typeof console !== "undefined")
      console.warn(message);
    try {
      throw new Error(message);
    } catch (e9) {
    }
  }
}
function createKey() {
  return Math.random().toString(36).substr(2, 8);
}
function getHistoryState(location, index2) {
  return {
    usr: location.state,
    key: location.key,
    idx: index2
  };
}
function createLocation(current, to4, state, key) {
  if (state === void 0) {
    state = null;
  }
  let location = _extends21({
    pathname: typeof current === "string" ? current : current.pathname,
    search: "",
    hash: ""
  }, typeof to4 === "string" ? parsePath2(to4) : to4, {
    state,
    // TODO: This could be cleaned up.  push/replace should probably just take
    // full Locations now and avoid the need to run through this flow at all
    // But that's a pretty big refactor to the current test suite so going to
    // keep as is for the time being and just let any incoming keys take precedence
    key: to4 && to4.key || key || createKey()
  });
  return location;
}
function createPath(_ref) {
  let {
    pathname = "/",
    search = "",
    hash: hash2 = ""
  } = _ref;
  if (search && search !== "?")
    pathname += search.charAt(0) === "?" ? search : "?" + search;
  if (hash2 && hash2 !== "#")
    pathname += hash2.charAt(0) === "#" ? hash2 : "#" + hash2;
  return pathname;
}
function parsePath2(path) {
  let parsedPath = {};
  if (path) {
    let hashIndex = path.indexOf("#");
    if (hashIndex >= 0) {
      parsedPath.hash = path.substr(hashIndex);
      path = path.substr(0, hashIndex);
    }
    let searchIndex = path.indexOf("?");
    if (searchIndex >= 0) {
      parsedPath.search = path.substr(searchIndex);
      path = path.substr(0, searchIndex);
    }
    if (path) {
      parsedPath.pathname = path;
    }
  }
  return parsedPath;
}
function getUrlBasedHistory(getLocation, createHref, validateLocation, options) {
  if (options === void 0) {
    options = {};
  }
  let {
    window: window2 = document.defaultView,
    v5Compat = false
  } = options;
  let globalHistory = window2.history;
  let action = Action.Pop;
  let listener = null;
  let index2 = getIndex();
  if (index2 == null) {
    index2 = 0;
    globalHistory.replaceState(_extends21({}, globalHistory.state, {
      idx: index2
    }), "");
  }
  function getIndex() {
    let state = globalHistory.state || {
      idx: null
    };
    return state.idx;
  }
  function handlePop() {
    action = Action.Pop;
    let nextIndex = getIndex();
    let delta = nextIndex == null ? null : nextIndex - index2;
    index2 = nextIndex;
    if (listener) {
      listener({
        action,
        location: history.location,
        delta
      });
    }
  }
  function push3(to4, state) {
    action = Action.Push;
    let location = createLocation(history.location, to4, state);
    if (validateLocation)
      validateLocation(location, to4);
    index2 = getIndex() + 1;
    let historyState = getHistoryState(location, index2);
    let url = history.createHref(location);
    try {
      globalHistory.pushState(historyState, "", url);
    } catch (error2) {
      window2.location.assign(url);
    }
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 1
      });
    }
  }
  function replace(to4, state) {
    action = Action.Replace;
    let location = createLocation(history.location, to4, state);
    if (validateLocation)
      validateLocation(location, to4);
    index2 = getIndex();
    let historyState = getHistoryState(location, index2);
    let url = history.createHref(location);
    globalHistory.replaceState(historyState, "", url);
    if (v5Compat && listener) {
      listener({
        action,
        location: history.location,
        delta: 0
      });
    }
  }
  function createURL(to4) {
    let base = window2.location.origin !== "null" ? window2.location.origin : window2.location.href;
    let href = typeof to4 === "string" ? to4 : createPath(to4);
    invariant3(base, "No window.location.(origin|href) available to create URL for href: " + href);
    return new URL(href, base);
  }
  let history = {
    get action() {
      return action;
    },
    get location() {
      return getLocation(window2, globalHistory);
    },
    listen(fn2) {
      if (listener) {
        throw new Error("A history only accepts one active listener");
      }
      window2.addEventListener(PopStateEventType, handlePop);
      listener = fn2;
      return () => {
        window2.removeEventListener(PopStateEventType, handlePop);
        listener = null;
      };
    },
    createHref(to4) {
      return createHref(window2, to4);
    },
    createURL,
    encodeLocation(to4) {
      let url = createURL(to4);
      return {
        pathname: url.pathname,
        search: url.search,
        hash: url.hash
      };
    },
    push: push3,
    replace,
    go(n12) {
      return globalHistory.go(n12);
    }
  };
  return history;
}
var ResultType;
(function(ResultType2) {
  ResultType2["data"] = "data";
  ResultType2["deferred"] = "deferred";
  ResultType2["redirect"] = "redirect";
  ResultType2["error"] = "error";
})(ResultType || (ResultType = {}));
function matchRoutes(routes, locationArg, basename) {
  if (basename === void 0) {
    basename = "/";
  }
  let location = typeof locationArg === "string" ? parsePath2(locationArg) : locationArg;
  let pathname = stripBasename(location.pathname || "/", basename);
  if (pathname == null) {
    return null;
  }
  let branches = flattenRoutes(routes);
  rankRouteBranches(branches);
  let matches = null;
  for (let i15 = 0; matches == null && i15 < branches.length; ++i15) {
    matches = matchRouteBranch(
      branches[i15],
      // Incoming pathnames are generally encoded from either window.location
      // or from router.navigate, but we want to match against the unencoded
      // paths in the route definitions.  Memory router locations won't be
      // encoded here but there also shouldn't be anything to decode so this
      // should be a safe operation.  This avoids needing matchRoutes to be
      // history-aware.
      safelyDecodeURI(pathname)
    );
  }
  return matches;
}
function flattenRoutes(routes, branches, parentsMeta, parentPath) {
  if (branches === void 0) {
    branches = [];
  }
  if (parentsMeta === void 0) {
    parentsMeta = [];
  }
  if (parentPath === void 0) {
    parentPath = "";
  }
  let flattenRoute = (route, index2, relativePath) => {
    let meta = {
      relativePath: relativePath === void 0 ? route.path || "" : relativePath,
      caseSensitive: route.caseSensitive === true,
      childrenIndex: index2,
      route
    };
    if (meta.relativePath.startsWith("/")) {
      invariant3(meta.relativePath.startsWith(parentPath), 'Absolute route path "' + meta.relativePath + '" nested under path ' + ('"' + parentPath + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes.");
      meta.relativePath = meta.relativePath.slice(parentPath.length);
    }
    let path = joinPaths([parentPath, meta.relativePath]);
    let routesMeta = parentsMeta.concat(meta);
    if (route.children && route.children.length > 0) {
      invariant3(
        // Our types know better, but runtime JS may not!
        // @ts-expect-error
        route.index !== true,
        "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + path + '".')
      );
      flattenRoutes(route.children, branches, routesMeta, path);
    }
    if (route.path == null && !route.index) {
      return;
    }
    branches.push({
      path,
      score: computeScore(path, route.index),
      routesMeta
    });
  };
  routes.forEach((route, index2) => {
    var _route$path;
    if (route.path === "" || !((_route$path = route.path) != null && _route$path.includes("?"))) {
      flattenRoute(route, index2);
    } else {
      for (let exploded of explodeOptionalSegments(route.path)) {
        flattenRoute(route, index2, exploded);
      }
    }
  });
  return branches;
}
function explodeOptionalSegments(path) {
  let segments = path.split("/");
  if (segments.length === 0)
    return [];
  let [first, ...rest] = segments;
  let isOptional = first.endsWith("?");
  let required2 = first.replace(/\?$/, "");
  if (rest.length === 0) {
    return isOptional ? [required2, ""] : [required2];
  }
  let restExploded = explodeOptionalSegments(rest.join("/"));
  let result = [];
  result.push(...restExploded.map((subpath) => subpath === "" ? required2 : [required2, subpath].join("/")));
  if (isOptional) {
    result.push(...restExploded);
  }
  return result.map((exploded) => path.startsWith("/") && exploded === "" ? "/" : exploded);
}
function rankRouteBranches(branches) {
  branches.sort((a13, b6) => a13.score !== b6.score ? b6.score - a13.score : compareIndexes(a13.routesMeta.map((meta) => meta.childrenIndex), b6.routesMeta.map((meta) => meta.childrenIndex)));
}
var paramRe = /^:\w+$/;
var dynamicSegmentValue = 3;
var indexRouteValue = 2;
var emptySegmentValue = 1;
var staticSegmentValue = 10;
var splatPenalty = -2;
var isSplat = (s20) => s20 === "*";
function computeScore(path, index2) {
  let segments = path.split("/");
  let initialScore = segments.length;
  if (segments.some(isSplat)) {
    initialScore += splatPenalty;
  }
  if (index2) {
    initialScore += indexRouteValue;
  }
  return segments.filter((s20) => !isSplat(s20)).reduce((score, segment) => score + (paramRe.test(segment) ? dynamicSegmentValue : segment === "" ? emptySegmentValue : staticSegmentValue), initialScore);
}
function compareIndexes(a13, b6) {
  let siblings = a13.length === b6.length && a13.slice(0, -1).every((n12, i15) => n12 === b6[i15]);
  return siblings ? (
    // If two routes are siblings, we should try to match the earlier sibling
    // first. This allows people to have fine-grained control over the matching
    // behavior by simply putting routes with identical paths in the order they
    // want them tried.
    a13[a13.length - 1] - b6[b6.length - 1]
  ) : (
    // Otherwise, it doesn't really make sense to rank non-siblings by index,
    // so they sort equally.
    0
  );
}
function matchRouteBranch(branch, pathname) {
  let {
    routesMeta
  } = branch;
  let matchedParams = {};
  let matchedPathname = "/";
  let matches = [];
  for (let i15 = 0; i15 < routesMeta.length; ++i15) {
    let meta = routesMeta[i15];
    let end2 = i15 === routesMeta.length - 1;
    let remainingPathname = matchedPathname === "/" ? pathname : pathname.slice(matchedPathname.length) || "/";
    let match5 = matchPath2({
      path: meta.relativePath,
      caseSensitive: meta.caseSensitive,
      end: end2
    }, remainingPathname);
    if (!match5)
      return null;
    Object.assign(matchedParams, match5.params);
    let route = meta.route;
    matches.push({
      // TODO: Can this as be avoided?
      params: matchedParams,
      pathname: joinPaths([matchedPathname, match5.pathname]),
      pathnameBase: normalizePathname(joinPaths([matchedPathname, match5.pathnameBase])),
      route
    });
    if (match5.pathnameBase !== "/") {
      matchedPathname = joinPaths([matchedPathname, match5.pathnameBase]);
    }
  }
  return matches;
}
function matchPath2(pattern, pathname) {
  if (typeof pattern === "string") {
    pattern = {
      path: pattern,
      caseSensitive: false,
      end: true
    };
  }
  let [matcher, paramNames] = compilePath(pattern.path, pattern.caseSensitive, pattern.end);
  let match5 = pathname.match(matcher);
  if (!match5)
    return null;
  let matchedPathname = match5[0];
  let pathnameBase = matchedPathname.replace(/(.)\/+$/, "$1");
  let captureGroups = match5.slice(1);
  let params = paramNames.reduce((memo2, paramName, index2) => {
    if (paramName === "*") {
      let splatValue = captureGroups[index2] || "";
      pathnameBase = matchedPathname.slice(0, matchedPathname.length - splatValue.length).replace(/(.)\/+$/, "$1");
    }
    memo2[paramName] = safelyDecodeURIComponent(captureGroups[index2] || "", paramName);
    return memo2;
  }, {});
  return {
    params,
    pathname: matchedPathname,
    pathnameBase,
    pattern
  };
}
function compilePath(path, caseSensitive, end2) {
  if (caseSensitive === void 0) {
    caseSensitive = false;
  }
  if (end2 === void 0) {
    end2 = true;
  }
  warning3(path === "*" || !path.endsWith("*") || path.endsWith("/*"), 'Route path "' + path + '" will be treated as if it were ' + ('"' + path.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + path.replace(/\*$/, "/*") + '".'));
  let paramNames = [];
  let regexpSource = "^" + path.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^$?{}|()[\]]/g, "\\$&").replace(/\/:(\w+)/g, (_7, paramName) => {
    paramNames.push(paramName);
    return "/([^\\/]+)";
  });
  if (path.endsWith("*")) {
    paramNames.push("*");
    regexpSource += path === "*" || path === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$";
  } else if (end2) {
    regexpSource += "\\/*$";
  } else if (path !== "" && path !== "/") {
    regexpSource += "(?:(?=\\/|$))";
  } else
    ;
  let matcher = new RegExp(regexpSource, caseSensitive ? void 0 : "i");
  return [matcher, paramNames];
}
function safelyDecodeURI(value) {
  try {
    return decodeURI(value);
  } catch (error2) {
    warning3(false, 'The URL path "' + value + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + error2 + ")."));
    return value;
  }
}
function safelyDecodeURIComponent(value, paramName) {
  try {
    return decodeURIComponent(value);
  } catch (error2) {
    warning3(false, 'The value for the URL param "' + paramName + '" will not be decoded because' + (' the string "' + value + '" is a malformed URL segment. This is probably') + (" due to a bad percent encoding (" + error2 + ")."));
    return value;
  }
}
function stripBasename(pathname, basename) {
  if (basename === "/")
    return pathname;
  if (!pathname.toLowerCase().startsWith(basename.toLowerCase())) {
    return null;
  }
  let startIndex = basename.endsWith("/") ? basename.length - 1 : basename.length;
  let nextChar = pathname.charAt(startIndex);
  if (nextChar && nextChar !== "/") {
    return null;
  }
  return pathname.slice(startIndex) || "/";
}
function resolvePath(to4, fromPathname) {
  if (fromPathname === void 0) {
    fromPathname = "/";
  }
  let {
    pathname: toPathname,
    search = "",
    hash: hash2 = ""
  } = typeof to4 === "string" ? parsePath2(to4) : to4;
  let pathname = toPathname ? toPathname.startsWith("/") ? toPathname : resolvePathname(toPathname, fromPathname) : fromPathname;
  return {
    pathname,
    search: normalizeSearch(search),
    hash: normalizeHash(hash2)
  };
}
function resolvePathname(relativePath, fromPathname) {
  let segments = fromPathname.replace(/\/+$/, "").split("/");
  let relativeSegments = relativePath.split("/");
  relativeSegments.forEach((segment) => {
    if (segment === "..") {
      if (segments.length > 1)
        segments.pop();
    } else if (segment !== ".") {
      segments.push(segment);
    }
  });
  return segments.length > 1 ? segments.join("/") : "/";
}
function getInvalidPathError(char, field, dest, path) {
  return "Cannot include a '" + char + "' character in a manually specified " + ("`to." + field + "` field [" + JSON.stringify(path) + "].  Please separate it out to the ") + ("`to." + dest + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.';
}
function getPathContributingMatches(matches) {
  return matches.filter((match5, index2) => index2 === 0 || match5.route.path && match5.route.path.length > 0);
}
function resolveTo(toArg, routePathnames, locationPathname, isPathRelative) {
  if (isPathRelative === void 0) {
    isPathRelative = false;
  }
  let to4;
  if (typeof toArg === "string") {
    to4 = parsePath2(toArg);
  } else {
    to4 = _extends21({}, toArg);
    invariant3(!to4.pathname || !to4.pathname.includes("?"), getInvalidPathError("?", "pathname", "search", to4));
    invariant3(!to4.pathname || !to4.pathname.includes("#"), getInvalidPathError("#", "pathname", "hash", to4));
    invariant3(!to4.search || !to4.search.includes("#"), getInvalidPathError("#", "search", "hash", to4));
  }
  let isEmptyPath = toArg === "" || to4.pathname === "";
  let toPathname = isEmptyPath ? "/" : to4.pathname;
  let from2;
  if (isPathRelative || toPathname == null) {
    from2 = locationPathname;
  } else {
    let routePathnameIndex = routePathnames.length - 1;
    if (toPathname.startsWith("..")) {
      let toSegments = toPathname.split("/");
      while (toSegments[0] === "..") {
        toSegments.shift();
        routePathnameIndex -= 1;
      }
      to4.pathname = toSegments.join("/");
    }
    from2 = routePathnameIndex >= 0 ? routePathnames[routePathnameIndex] : "/";
  }
  let path = resolvePath(to4, from2);
  let hasExplicitTrailingSlash = toPathname && toPathname !== "/" && toPathname.endsWith("/");
  let hasCurrentTrailingSlash = (isEmptyPath || toPathname === ".") && locationPathname.endsWith("/");
  if (!path.pathname.endsWith("/") && (hasExplicitTrailingSlash || hasCurrentTrailingSlash)) {
    path.pathname += "/";
  }
  return path;
}
var joinPaths = (paths) => paths.join("/").replace(/\/\/+/g, "/");
var normalizePathname = (pathname) => pathname.replace(/\/+$/, "").replace(/^\/*/, "/");
var normalizeSearch = (search) => !search || search === "?" ? "" : search.startsWith("?") ? search : "?" + search;
var normalizeHash = (hash2) => !hash2 || hash2 === "#" ? "" : hash2.startsWith("#") ? hash2 : "#" + hash2;
function isRouteErrorResponse(error2) {
  return error2 != null && typeof error2.status === "number" && typeof error2.statusText === "string" && typeof error2.internal === "boolean" && "data" in error2;
}
var validMutationMethodsArr = ["post", "put", "patch", "delete"];
var validMutationMethods = new Set(validMutationMethodsArr);
var validRequestMethodsArr = ["get", ...validMutationMethodsArr];
var validRequestMethods = new Set(validRequestMethodsArr);
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var UNSAFE_DEFERRED_SYMBOL = Symbol("deferred");

// node_modules/react-router/dist/index.js
var React69 = __toESM(require_react());
function isPolyfill(x7, y9) {
  return x7 === y9 && (x7 !== 0 || 1 / x7 === 1 / y9) || x7 !== x7 && y9 !== y9;
}
var is2 = typeof Object.is === "function" ? Object.is : isPolyfill;
var {
  useState: useState12,
  useEffect: useEffect21,
  useLayoutEffect: useLayoutEffect10,
  useDebugValue: useDebugValue5
} = React69;
var didWarnOld18Alpha = false;
var didWarnUncachedGetSnapshot = false;
function useSyncExternalStore$2(subscribe, getSnapshot, getServerSnapshot) {
  if (true) {
    if (!didWarnOld18Alpha) {
      if ("startTransition" in React69) {
        didWarnOld18Alpha = true;
        console.error("You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release.");
      }
    }
  }
  const value = getSnapshot();
  if (true) {
    if (!didWarnUncachedGetSnapshot) {
      const cachedValue = getSnapshot();
      if (!is2(value, cachedValue)) {
        console.error("The result of getSnapshot should be cached to avoid an infinite loop");
        didWarnUncachedGetSnapshot = true;
      }
    }
  }
  const [{
    inst
  }, forceUpdate] = useState12({
    inst: {
      value,
      getSnapshot
    }
  });
  useLayoutEffect10(() => {
    inst.value = value;
    inst.getSnapshot = getSnapshot;
    if (checkIfSnapshotChanged(inst)) {
      forceUpdate({
        inst
      });
    }
  }, [subscribe, value, getSnapshot]);
  useEffect21(() => {
    if (checkIfSnapshotChanged(inst)) {
      forceUpdate({
        inst
      });
    }
    const handleStoreChange = () => {
      if (checkIfSnapshotChanged(inst)) {
        forceUpdate({
          inst
        });
      }
    };
    return subscribe(handleStoreChange);
  }, [subscribe]);
  useDebugValue5(value);
  return value;
}
function checkIfSnapshotChanged(inst) {
  const latestGetSnapshot = inst.getSnapshot;
  const prevValue = inst.value;
  try {
    const nextValue = latestGetSnapshot();
    return !is2(prevValue, nextValue);
  } catch (error2) {
    return true;
  }
}
function useSyncExternalStore$1(subscribe, getSnapshot, getServerSnapshot) {
  return getSnapshot();
}
var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
var isServerEnvironment = !canUseDOM;
var shim = isServerEnvironment ? useSyncExternalStore$1 : useSyncExternalStore$2;
var useSyncExternalStore = "useSyncExternalStore" in React69 ? ((module2) => module2.useSyncExternalStore)(React69) : shim;
var DataRouterContext = React69.createContext(null);
if (true) {
  DataRouterContext.displayName = "DataRouter";
}
var DataRouterStateContext = React69.createContext(null);
if (true) {
  DataRouterStateContext.displayName = "DataRouterState";
}
var AwaitContext = React69.createContext(null);
if (true) {
  AwaitContext.displayName = "Await";
}
var NavigationContext = React69.createContext(null);
if (true) {
  NavigationContext.displayName = "Navigation";
}
var LocationContext = React69.createContext(null);
if (true) {
  LocationContext.displayName = "Location";
}
var RouteContext = React69.createContext({
  outlet: null,
  matches: []
});
if (true) {
  RouteContext.displayName = "Route";
}
var RouteErrorContext = React69.createContext(null);
if (true) {
  RouteErrorContext.displayName = "RouteError";
}
function _extends22() {
  _extends22 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i15 = 1; i15 < arguments.length; i15++) {
      var source = arguments[i15];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends22.apply(this, arguments);
}
function useHref(to4, _temp) {
  let {
    relative
  } = _temp === void 0 ? {} : _temp;
  !useInRouterContext() ? true ? invariant3(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useHref() may be used only in the context of a <Router> component."
  ) : invariant3(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = React69.useContext(NavigationContext);
  let {
    hash: hash2,
    pathname,
    search
  } = useResolvedPath(to4, {
    relative
  });
  let joinedPathname = pathname;
  if (basename !== "/") {
    joinedPathname = pathname === "/" ? basename : joinPaths([basename, pathname]);
  }
  return navigator2.createHref({
    pathname: joinedPathname,
    search,
    hash: hash2
  });
}
function useInRouterContext() {
  return React69.useContext(LocationContext) != null;
}
function useLocation() {
  !useInRouterContext() ? true ? invariant3(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useLocation() may be used only in the context of a <Router> component."
  ) : invariant3(false) : void 0;
  return React69.useContext(LocationContext).location;
}
function useNavigate() {
  !useInRouterContext() ? true ? invariant3(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useNavigate() may be used only in the context of a <Router> component."
  ) : invariant3(false) : void 0;
  let {
    basename,
    navigator: navigator2
  } = React69.useContext(NavigationContext);
  let {
    matches
  } = React69.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match5) => match5.pathnameBase));
  let activeRef = React69.useRef(false);
  React69.useEffect(() => {
    activeRef.current = true;
  });
  let navigate = React69.useCallback(function(to4, options) {
    if (options === void 0) {
      options = {};
    }
    true ? warning3(activeRef.current, "You should call navigate() in a React.useEffect(), not when your component is first rendered.") : void 0;
    if (!activeRef.current)
      return;
    if (typeof to4 === "number") {
      navigator2.go(to4);
      return;
    }
    let path = resolveTo(to4, JSON.parse(routePathnamesJson), locationPathname, options.relative === "path");
    if (basename !== "/") {
      path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
    }
    (!!options.replace ? navigator2.replace : navigator2.push)(path, options.state, options);
  }, [basename, navigator2, routePathnamesJson, locationPathname]);
  return navigate;
}
var OutletContext = React69.createContext(null);
function useParams() {
  let {
    matches
  } = React69.useContext(RouteContext);
  let routeMatch = matches[matches.length - 1];
  return routeMatch ? routeMatch.params : {};
}
function useResolvedPath(to4, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    matches
  } = React69.useContext(RouteContext);
  let {
    pathname: locationPathname
  } = useLocation();
  let routePathnamesJson = JSON.stringify(getPathContributingMatches(matches).map((match5) => match5.pathnameBase));
  return React69.useMemo(() => resolveTo(to4, JSON.parse(routePathnamesJson), locationPathname, relative === "path"), [to4, routePathnamesJson, locationPathname, relative]);
}
function useRoutes(routes, locationArg) {
  !useInRouterContext() ? true ? invariant3(
    false,
    // TODO: This error is probably because they somehow have 2 versions of the
    // router loaded. We can help them understand how to avoid that.
    "useRoutes() may be used only in the context of a <Router> component."
  ) : invariant3(false) : void 0;
  let {
    navigator: navigator2
  } = React69.useContext(NavigationContext);
  let dataRouterStateContext = React69.useContext(DataRouterStateContext);
  let {
    matches: parentMatches
  } = React69.useContext(RouteContext);
  let routeMatch = parentMatches[parentMatches.length - 1];
  let parentParams = routeMatch ? routeMatch.params : {};
  let parentPathname = routeMatch ? routeMatch.pathname : "/";
  let parentPathnameBase = routeMatch ? routeMatch.pathnameBase : "/";
  let parentRoute = routeMatch && routeMatch.route;
  if (true) {
    let parentPath = parentRoute && parentRoute.path || "";
    warningOnce(parentPathname, !parentRoute || parentPath.endsWith("*"), "You rendered descendant <Routes> (or called `useRoutes()`) at " + ('"' + parentPathname + '" (under <Route path="' + parentPath + '">) but the ') + `parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

` + ('Please change the parent <Route path="' + parentPath + '"> to <Route ') + ('path="' + (parentPath === "/" ? "*" : parentPath + "/*") + '">.'));
  }
  let locationFromContext = useLocation();
  let location;
  if (locationArg) {
    var _parsedLocationArg$pa;
    let parsedLocationArg = typeof locationArg === "string" ? parsePath2(locationArg) : locationArg;
    !(parentPathnameBase === "/" || ((_parsedLocationArg$pa = parsedLocationArg.pathname) == null ? void 0 : _parsedLocationArg$pa.startsWith(parentPathnameBase))) ? true ? invariant3(false, "When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, the location pathname must begin with the portion of the URL pathname that was " + ('matched by all parent routes. The current pathname base is "' + parentPathnameBase + '" ') + ('but pathname "' + parsedLocationArg.pathname + '" was given in the `location` prop.')) : invariant3(false) : void 0;
    location = parsedLocationArg;
  } else {
    location = locationFromContext;
  }
  let pathname = location.pathname || "/";
  let remainingPathname = parentPathnameBase === "/" ? pathname : pathname.slice(parentPathnameBase.length) || "/";
  let matches = matchRoutes(routes, {
    pathname: remainingPathname
  });
  if (true) {
    true ? warning3(parentRoute || matches != null, 'No routes matched location "' + location.pathname + location.search + location.hash + '" ') : void 0;
    true ? warning3(matches == null || matches[matches.length - 1].route.element !== void 0 || matches[matches.length - 1].route.Component !== void 0, 'Matched leaf route at location "' + location.pathname + location.search + location.hash + '" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.') : void 0;
  }
  let renderedMatches = _renderMatches(matches && matches.map((match5) => Object.assign({}, match5, {
    params: Object.assign({}, parentParams, match5.params),
    pathname: joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match5.pathname).pathname : match5.pathname
    ]),
    pathnameBase: match5.pathnameBase === "/" ? parentPathnameBase : joinPaths([
      parentPathnameBase,
      // Re-encode pathnames that were decoded inside matchRoutes
      navigator2.encodeLocation ? navigator2.encodeLocation(match5.pathnameBase).pathname : match5.pathnameBase
    ])
  })), parentMatches, dataRouterStateContext || void 0);
  if (locationArg && renderedMatches) {
    return React69.createElement(LocationContext.Provider, {
      value: {
        location: _extends22({
          pathname: "/",
          search: "",
          hash: "",
          state: null,
          key: "default"
        }, location),
        navigationType: Action.Pop
      }
    }, renderedMatches);
  }
  return renderedMatches;
}
function DefaultErrorComponent() {
  let error2 = useRouteError();
  let message = isRouteErrorResponse(error2) ? error2.status + " " + error2.statusText : error2 instanceof Error ? error2.message : JSON.stringify(error2);
  let stack = error2 instanceof Error ? error2.stack : null;
  let lightgrey = "rgba(200,200,200, 0.5)";
  let preStyles = {
    padding: "0.5rem",
    backgroundColor: lightgrey
  };
  let codeStyles = {
    padding: "2px 4px",
    backgroundColor: lightgrey
  };
  let devInfo = null;
  if (true) {
    devInfo = React69.createElement(React69.Fragment, null, React69.createElement("p", null, "💿 Hey developer 👋"), React69.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", React69.createElement("code", {
      style: codeStyles
    }, "ErrorBoundary"), " prop on ", React69.createElement("code", {
      style: codeStyles
    }, "<Route>")));
  }
  return React69.createElement(React69.Fragment, null, React69.createElement("h2", null, "Unexpected Application Error!"), React69.createElement("h3", {
    style: {
      fontStyle: "italic"
    }
  }, message), stack ? React69.createElement("pre", {
    style: preStyles
  }, stack) : null, devInfo);
}
var RenderErrorBoundary = class extends React69.Component {
  constructor(props) {
    super(props);
    this.state = {
      location: props.location,
      error: props.error
    };
  }
  static getDerivedStateFromError(error2) {
    return {
      error: error2
    };
  }
  static getDerivedStateFromProps(props, state) {
    if (state.location !== props.location) {
      return {
        error: props.error,
        location: props.location
      };
    }
    return {
      error: props.error || state.error,
      location: state.location
    };
  }
  componentDidCatch(error2, errorInfo) {
    console.error("React Router caught the following error during render", error2, errorInfo);
  }
  render() {
    return this.state.error ? React69.createElement(RouteContext.Provider, {
      value: this.props.routeContext
    }, React69.createElement(RouteErrorContext.Provider, {
      value: this.state.error,
      children: this.props.component
    })) : this.props.children;
  }
};
function RenderedRoute(_ref) {
  let {
    routeContext,
    match: match5,
    children
  } = _ref;
  let dataRouterContext = React69.useContext(DataRouterContext);
  if (dataRouterContext && dataRouterContext.static && dataRouterContext.staticContext && (match5.route.errorElement || match5.route.ErrorBoundary)) {
    dataRouterContext.staticContext._deepestRenderedBoundaryId = match5.route.id;
  }
  return React69.createElement(RouteContext.Provider, {
    value: routeContext
  }, children);
}
function _renderMatches(matches, parentMatches, dataRouterState) {
  if (parentMatches === void 0) {
    parentMatches = [];
  }
  if (matches == null) {
    if (dataRouterState != null && dataRouterState.errors) {
      matches = dataRouterState.matches;
    } else {
      return null;
    }
  }
  let renderedMatches = matches;
  let errors = dataRouterState == null ? void 0 : dataRouterState.errors;
  if (errors != null) {
    let errorIndex = renderedMatches.findIndex((m10) => m10.route.id && (errors == null ? void 0 : errors[m10.route.id]));
    !(errorIndex >= 0) ? true ? invariant3(false, "Could not find a matching route for the current errors: " + errors) : invariant3(false) : void 0;
    renderedMatches = renderedMatches.slice(0, Math.min(renderedMatches.length, errorIndex + 1));
  }
  return renderedMatches.reduceRight((outlet, match5, index2) => {
    let error2 = match5.route.id ? errors == null ? void 0 : errors[match5.route.id] : null;
    let errorElement = null;
    if (dataRouterState) {
      if (match5.route.ErrorBoundary) {
        errorElement = React69.createElement(match5.route.ErrorBoundary, null);
      } else if (match5.route.errorElement) {
        errorElement = match5.route.errorElement;
      } else {
        errorElement = React69.createElement(DefaultErrorComponent, null);
      }
    }
    let matches2 = parentMatches.concat(renderedMatches.slice(0, index2 + 1));
    let getChildren2 = () => {
      let children = outlet;
      if (error2) {
        children = errorElement;
      } else if (match5.route.Component) {
        children = React69.createElement(match5.route.Component, null);
      } else if (match5.route.element) {
        children = match5.route.element;
      }
      return React69.createElement(RenderedRoute, {
        match: match5,
        routeContext: {
          outlet,
          matches: matches2
        },
        children
      });
    };
    return dataRouterState && (match5.route.ErrorBoundary || match5.route.errorElement || index2 === 0) ? React69.createElement(RenderErrorBoundary, {
      location: dataRouterState.location,
      component: errorElement,
      error: error2,
      children: getChildren2(),
      routeContext: {
        outlet: null,
        matches: matches2
      }
    }) : getChildren2();
  }, null);
}
var DataRouterHook;
(function(DataRouterHook3) {
  DataRouterHook3["UseBlocker"] = "useBlocker";
  DataRouterHook3["UseRevalidator"] = "useRevalidator";
})(DataRouterHook || (DataRouterHook = {}));
var DataRouterStateHook;
(function(DataRouterStateHook3) {
  DataRouterStateHook3["UseBlocker"] = "useBlocker";
  DataRouterStateHook3["UseLoaderData"] = "useLoaderData";
  DataRouterStateHook3["UseActionData"] = "useActionData";
  DataRouterStateHook3["UseRouteError"] = "useRouteError";
  DataRouterStateHook3["UseNavigation"] = "useNavigation";
  DataRouterStateHook3["UseRouteLoaderData"] = "useRouteLoaderData";
  DataRouterStateHook3["UseMatches"] = "useMatches";
  DataRouterStateHook3["UseRevalidator"] = "useRevalidator";
})(DataRouterStateHook || (DataRouterStateHook = {}));
function getDataRouterConsoleError(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function useDataRouterState(hookName) {
  let state = React69.useContext(DataRouterStateContext);
  !state ? true ? invariant3(false, getDataRouterConsoleError(hookName)) : invariant3(false) : void 0;
  return state;
}
function useRouteContext(hookName) {
  let route = React69.useContext(RouteContext);
  !route ? true ? invariant3(false, getDataRouterConsoleError(hookName)) : invariant3(false) : void 0;
  return route;
}
function useCurrentRouteId(hookName) {
  let route = useRouteContext(hookName);
  let thisRoute = route.matches[route.matches.length - 1];
  !thisRoute.route.id ? true ? invariant3(false, hookName + ' can only be used on routes that contain a unique "id"') : invariant3(false) : void 0;
  return thisRoute.route.id;
}
function useNavigation() {
  let state = useDataRouterState(DataRouterStateHook.UseNavigation);
  return state.navigation;
}
function useMatches() {
  let {
    matches,
    loaderData
  } = useDataRouterState(DataRouterStateHook.UseMatches);
  return React69.useMemo(() => matches.map((match5) => {
    let {
      pathname,
      params
    } = match5;
    return {
      id: match5.route.id,
      pathname,
      params,
      data: loaderData[match5.route.id],
      handle: match5.route.handle
    };
  }), [matches, loaderData]);
}
function useRouteError() {
  var _state$errors;
  let error2 = React69.useContext(RouteErrorContext);
  let state = useDataRouterState(DataRouterStateHook.UseRouteError);
  let routeId = useCurrentRouteId(DataRouterStateHook.UseRouteError);
  if (error2) {
    return error2;
  }
  return (_state$errors = state.errors) == null ? void 0 : _state$errors[routeId];
}
var alreadyWarned = {};
function warningOnce(key, cond, message) {
  if (!cond && !alreadyWarned[key]) {
    alreadyWarned[key] = true;
    true ? warning3(false, message) : void 0;
  }
}
function Route(_props) {
  true ? invariant3(false, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") : invariant3(false);
}
function Router(_ref4) {
  let {
    basename: basenameProp = "/",
    children = null,
    location: locationProp,
    navigationType = Action.Pop,
    navigator: navigator2,
    static: staticProp = false
  } = _ref4;
  !!useInRouterContext() ? true ? invariant3(false, "You cannot render a <Router> inside another <Router>. You should never have more than one in your app.") : invariant3(false) : void 0;
  let basename = basenameProp.replace(/^\/*/, "/");
  let navigationContext = React69.useMemo(() => ({
    basename,
    navigator: navigator2,
    static: staticProp
  }), [basename, navigator2, staticProp]);
  if (typeof locationProp === "string") {
    locationProp = parsePath2(locationProp);
  }
  let {
    pathname = "/",
    search = "",
    hash: hash2 = "",
    state = null,
    key = "default"
  } = locationProp;
  let locationContext = React69.useMemo(() => {
    let trailingPathname = stripBasename(pathname, basename);
    if (trailingPathname == null) {
      return null;
    }
    return {
      location: {
        pathname: trailingPathname,
        search,
        hash: hash2,
        state,
        key
      },
      navigationType
    };
  }, [basename, pathname, search, hash2, state, key, navigationType]);
  true ? warning3(locationContext != null, '<Router basename="' + basename + '"> is not able to match the URL ' + ('"' + pathname + search + hash2 + '" because it does not start with the ') + "basename, so the <Router> won't render anything.") : void 0;
  if (locationContext == null) {
    return null;
  }
  return React69.createElement(NavigationContext.Provider, {
    value: navigationContext
  }, React69.createElement(LocationContext.Provider, {
    children,
    value: locationContext
  }));
}
function Routes(_ref5) {
  let {
    children,
    location
  } = _ref5;
  let dataRouterContext = React69.useContext(DataRouterContext);
  let routes = dataRouterContext && !children ? dataRouterContext.router.routes : createRoutesFromChildren(children);
  return useRoutes(routes, location);
}
var AwaitRenderStatus;
(function(AwaitRenderStatus2) {
  AwaitRenderStatus2[AwaitRenderStatus2["pending"] = 0] = "pending";
  AwaitRenderStatus2[AwaitRenderStatus2["success"] = 1] = "success";
  AwaitRenderStatus2[AwaitRenderStatus2["error"] = 2] = "error";
})(AwaitRenderStatus || (AwaitRenderStatus = {}));
var neverSettledPromise = new Promise(() => {
});
function createRoutesFromChildren(children, parentPath) {
  if (parentPath === void 0) {
    parentPath = [];
  }
  let routes = [];
  React69.Children.forEach(children, (element, index2) => {
    if (!React69.isValidElement(element)) {
      return;
    }
    let treePath = [...parentPath, index2];
    if (element.type === React69.Fragment) {
      routes.push.apply(routes, createRoutesFromChildren(element.props.children, treePath));
      return;
    }
    !(element.type === Route) ? true ? invariant3(false, "[" + (typeof element.type === "string" ? element.type : element.type.name) + "] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>") : invariant3(false) : void 0;
    !(!element.props.index || !element.props.children) ? true ? invariant3(false, "An index route cannot have child routes.") : invariant3(false) : void 0;
    let route = {
      id: element.props.id || treePath.join("-"),
      caseSensitive: element.props.caseSensitive,
      element: element.props.element,
      Component: element.props.Component,
      index: element.props.index,
      path: element.props.path,
      loader: element.props.loader,
      action: element.props.action,
      errorElement: element.props.errorElement,
      ErrorBoundary: element.props.ErrorBoundary,
      hasErrorBoundary: element.props.ErrorBoundary != null || element.props.errorElement != null,
      shouldRevalidate: element.props.shouldRevalidate,
      handle: element.props.handle,
      lazy: element.props.lazy
    };
    if (element.props.children) {
      route.children = createRoutesFromChildren(element.props.children, treePath);
    }
    routes.push(route);
  });
  return routes;
}

// node_modules/react-router-dom/dist/index.js
function _extends23() {
  _extends23 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i15 = 1; i15 < arguments.length; i15++) {
      var source = arguments[i15];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends23.apply(this, arguments);
}
function _objectWithoutPropertiesLoose7(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i15;
  for (i15 = 0; i15 < sourceKeys.length; i15++) {
    key = sourceKeys[i15];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var defaultMethod = "get";
var defaultEncType = "application/x-www-form-urlencoded";
function isHtmlElement3(object2) {
  return object2 != null && typeof object2.tagName === "string";
}
function isButtonElement(object2) {
  return isHtmlElement3(object2) && object2.tagName.toLowerCase() === "button";
}
function isFormElement(object2) {
  return isHtmlElement3(object2) && object2.tagName.toLowerCase() === "form";
}
function isInputElement(object2) {
  return isHtmlElement3(object2) && object2.tagName.toLowerCase() === "input";
}
function isModifiedEvent(event) {
  return !!(event.metaKey || event.altKey || event.ctrlKey || event.shiftKey);
}
function shouldProcessLinkClick(event, target) {
  return event.button === 0 && // Ignore everything but left clicks
  (!target || target === "_self") && // Let browser handle "target=_blank" etc.
  !isModifiedEvent(event);
}
function createSearchParams(init) {
  if (init === void 0) {
    init = "";
  }
  return new URLSearchParams(typeof init === "string" || Array.isArray(init) || init instanceof URLSearchParams ? init : Object.keys(init).reduce((memo2, key) => {
    let value = init[key];
    return memo2.concat(Array.isArray(value) ? value.map((v6) => [key, v6]) : [[key, value]]);
  }, []));
}
function getSearchParamsForLocation(locationSearch, defaultSearchParams) {
  let searchParams = createSearchParams(locationSearch);
  if (defaultSearchParams) {
    for (let key of defaultSearchParams.keys()) {
      if (!searchParams.has(key)) {
        defaultSearchParams.getAll(key).forEach((value) => {
          searchParams.append(key, value);
        });
      }
    }
  }
  return searchParams;
}
function getFormSubmissionInfo(target, defaultAction, options) {
  let method;
  let action;
  let encType;
  let formData;
  if (isFormElement(target)) {
    let submissionTrigger = options.submissionTrigger;
    method = options.method || target.getAttribute("method") || defaultMethod;
    action = options.action || target.getAttribute("action") || defaultAction;
    encType = options.encType || target.getAttribute("enctype") || defaultEncType;
    formData = new FormData(target);
    if (submissionTrigger && submissionTrigger.name) {
      formData.append(submissionTrigger.name, submissionTrigger.value);
    }
  } else if (isButtonElement(target) || isInputElement(target) && (target.type === "submit" || target.type === "image")) {
    let form = target.form;
    if (form == null) {
      throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>');
    }
    method = options.method || target.getAttribute("formmethod") || form.getAttribute("method") || defaultMethod;
    action = options.action || target.getAttribute("formaction") || form.getAttribute("action") || defaultAction;
    encType = options.encType || target.getAttribute("formenctype") || form.getAttribute("enctype") || defaultEncType;
    formData = new FormData(form);
    if (target.name) {
      formData.append(target.name, target.value);
    }
  } else if (isHtmlElement3(target)) {
    throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">');
  } else {
    method = options.method || defaultMethod;
    action = options.action || defaultAction;
    encType = options.encType || defaultEncType;
    if (target instanceof FormData) {
      formData = target;
    } else {
      formData = new FormData();
      if (target instanceof URLSearchParams) {
        for (let [name2, value] of target) {
          formData.append(name2, value);
        }
      } else if (target != null) {
        for (let name2 of Object.keys(target)) {
          formData.append(name2, target[name2]);
        }
      }
    }
  }
  let {
    protocol,
    host
  } = window.location;
  let url = new URL(action, protocol + "//" + host);
  return {
    url,
    method: method.toLowerCase(),
    encType,
    formData
  };
}
var _excluded10 = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset"];
var _excluded25 = ["aria-current", "caseSensitive", "className", "end", "style", "to", "children"];
var _excluded33 = ["reloadDocument", "replace", "method", "action", "onSubmit", "fetcherKey", "routeId", "relative", "preventScrollReset"];
function HashRouter(_ref2) {
  let {
    basename,
    children,
    window: window2
  } = _ref2;
  let historyRef = React70.useRef();
  if (historyRef.current == null) {
    historyRef.current = createHashHistory({
      window: window2,
      v5Compat: true
    });
  }
  let history = historyRef.current;
  let [state, setState] = React70.useState({
    action: history.action,
    location: history.location
  });
  React70.useLayoutEffect(() => history.listen(setState), [history]);
  return React70.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
function HistoryRouter(_ref3) {
  let {
    basename,
    children,
    history
  } = _ref3;
  const [state, setState] = React70.useState({
    action: history.action,
    location: history.location
  });
  React70.useLayoutEffect(() => history.listen(setState), [history]);
  return React70.createElement(Router, {
    basename,
    children,
    location: state.location,
    navigationType: state.action,
    navigator: history
  });
}
if (true) {
  HistoryRouter.displayName = "unstable_HistoryRouter";
}
var isBrowser2 = typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined";
var ABSOLUTE_URL_REGEX = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i;
var Link = React70.forwardRef(function LinkWithRef(_ref4, ref2) {
  let {
    onClick,
    relative,
    reloadDocument,
    replace,
    state,
    target,
    to: to4,
    preventScrollReset
  } = _ref4, rest = _objectWithoutPropertiesLoose7(_ref4, _excluded10);
  let {
    basename
  } = React70.useContext(NavigationContext);
  let absoluteHref;
  let isExternal = false;
  if (typeof to4 === "string" && ABSOLUTE_URL_REGEX.test(to4)) {
    absoluteHref = to4;
    if (isBrowser2) {
      let currentUrl = new URL(window.location.href);
      let targetUrl = to4.startsWith("//") ? new URL(currentUrl.protocol + to4) : new URL(to4);
      let path = stripBasename(targetUrl.pathname, basename);
      if (targetUrl.origin === currentUrl.origin && path != null) {
        to4 = path + targetUrl.search + targetUrl.hash;
      } else {
        isExternal = true;
      }
    }
  }
  let href = useHref(to4, {
    relative
  });
  let internalOnClick = useLinkClickHandler(to4, {
    replace,
    state,
    target,
    preventScrollReset,
    relative
  });
  function handleClick(event) {
    if (onClick)
      onClick(event);
    if (!event.defaultPrevented) {
      internalOnClick(event);
    }
  }
  return (
    // eslint-disable-next-line jsx-a11y/anchor-has-content
    React70.createElement("a", _extends23({}, rest, {
      href: absoluteHref || href,
      onClick: isExternal || reloadDocument ? onClick : handleClick,
      ref: ref2,
      target
    }))
  );
});
if (true) {
  Link.displayName = "Link";
}
var NavLink = React70.forwardRef(function NavLinkWithRef(_ref5, ref2) {
  let {
    "aria-current": ariaCurrentProp = "page",
    caseSensitive = false,
    className: classNameProp = "",
    end: end2 = false,
    style: styleProp,
    to: to4,
    children
  } = _ref5, rest = _objectWithoutPropertiesLoose7(_ref5, _excluded25);
  let path = useResolvedPath(to4, {
    relative: rest.relative
  });
  let location = useLocation();
  let routerState = React70.useContext(DataRouterStateContext);
  let {
    navigator: navigator2
  } = React70.useContext(NavigationContext);
  let toPathname = navigator2.encodeLocation ? navigator2.encodeLocation(path).pathname : path.pathname;
  let locationPathname = location.pathname;
  let nextLocationPathname = routerState && routerState.navigation && routerState.navigation.location ? routerState.navigation.location.pathname : null;
  if (!caseSensitive) {
    locationPathname = locationPathname.toLowerCase();
    nextLocationPathname = nextLocationPathname ? nextLocationPathname.toLowerCase() : null;
    toPathname = toPathname.toLowerCase();
  }
  let isActive = locationPathname === toPathname || !end2 && locationPathname.startsWith(toPathname) && locationPathname.charAt(toPathname.length) === "/";
  let isPending = nextLocationPathname != null && (nextLocationPathname === toPathname || !end2 && nextLocationPathname.startsWith(toPathname) && nextLocationPathname.charAt(toPathname.length) === "/");
  let ariaCurrent = isActive ? ariaCurrentProp : void 0;
  let className;
  if (typeof classNameProp === "function") {
    className = classNameProp({
      isActive,
      isPending
    });
  } else {
    className = [classNameProp, isActive ? "active" : null, isPending ? "pending" : null].filter(Boolean).join(" ");
  }
  let style2 = typeof styleProp === "function" ? styleProp({
    isActive,
    isPending
  }) : styleProp;
  return React70.createElement(Link, _extends23({}, rest, {
    "aria-current": ariaCurrent,
    className,
    ref: ref2,
    style: style2,
    to: to4
  }), typeof children === "function" ? children({
    isActive,
    isPending
  }) : children);
});
if (true) {
  NavLink.displayName = "NavLink";
}
var Form2 = React70.forwardRef((props, ref2) => {
  return React70.createElement(FormImpl, _extends23({}, props, {
    ref: ref2
  }));
});
if (true) {
  Form2.displayName = "Form";
}
var FormImpl = React70.forwardRef((_ref6, forwardedRef) => {
  let {
    reloadDocument,
    replace,
    method = defaultMethod,
    action,
    onSubmit,
    fetcherKey,
    routeId,
    relative,
    preventScrollReset
  } = _ref6, props = _objectWithoutPropertiesLoose7(_ref6, _excluded33);
  let submit = useSubmitImpl(fetcherKey, routeId);
  let formMethod = method.toLowerCase() === "get" ? "get" : "post";
  let formAction = useFormAction(action, {
    relative
  });
  let submitHandler = (event) => {
    onSubmit && onSubmit(event);
    if (event.defaultPrevented)
      return;
    event.preventDefault();
    let submitter = event.nativeEvent.submitter;
    let submitMethod = (submitter == null ? void 0 : submitter.getAttribute("formmethod")) || method;
    submit(submitter || event.currentTarget, {
      method: submitMethod,
      replace,
      relative,
      preventScrollReset
    });
  };
  return React70.createElement("form", _extends23({
    ref: forwardedRef,
    method: formMethod,
    action: formAction,
    onSubmit: reloadDocument ? onSubmit : submitHandler
  }, props));
});
if (true) {
  FormImpl.displayName = "FormImpl";
}
function ScrollRestoration(_ref7) {
  let {
    getKey,
    storageKey
  } = _ref7;
  useScrollRestoration({
    getKey,
    storageKey
  });
  return null;
}
if (true) {
  ScrollRestoration.displayName = "ScrollRestoration";
}
var DataRouterHook2;
(function(DataRouterHook3) {
  DataRouterHook3["UseScrollRestoration"] = "useScrollRestoration";
  DataRouterHook3["UseSubmitImpl"] = "useSubmitImpl";
  DataRouterHook3["UseFetcher"] = "useFetcher";
})(DataRouterHook2 || (DataRouterHook2 = {}));
var DataRouterStateHook2;
(function(DataRouterStateHook3) {
  DataRouterStateHook3["UseFetchers"] = "useFetchers";
  DataRouterStateHook3["UseScrollRestoration"] = "useScrollRestoration";
})(DataRouterStateHook2 || (DataRouterStateHook2 = {}));
function getDataRouterConsoleError2(hookName) {
  return hookName + " must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.";
}
function useDataRouterContext(hookName) {
  let ctx = React70.useContext(DataRouterContext);
  !ctx ? true ? invariant3(false, getDataRouterConsoleError2(hookName)) : invariant3(false) : void 0;
  return ctx;
}
function useDataRouterState2(hookName) {
  let state = React70.useContext(DataRouterStateContext);
  !state ? true ? invariant3(false, getDataRouterConsoleError2(hookName)) : invariant3(false) : void 0;
  return state;
}
function useLinkClickHandler(to4, _temp) {
  let {
    target,
    replace: replaceProp,
    state,
    preventScrollReset,
    relative
  } = _temp === void 0 ? {} : _temp;
  let navigate = useNavigate();
  let location = useLocation();
  let path = useResolvedPath(to4, {
    relative
  });
  return React70.useCallback((event) => {
    if (shouldProcessLinkClick(event, target)) {
      event.preventDefault();
      let replace = replaceProp !== void 0 ? replaceProp : createPath(location) === createPath(path);
      navigate(to4, {
        replace,
        state,
        preventScrollReset,
        relative
      });
    }
  }, [location, navigate, path, replaceProp, state, target, to4, preventScrollReset, relative]);
}
function useSearchParams(defaultInit) {
  true ? warning3(typeof URLSearchParams !== "undefined", "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params\n\nIf you're unsure how to load polyfills, we recommend you check out https://polyfill.io/v3/ which provides some recommendations about how to load polyfills only for users that need them, instead of for every user.") : void 0;
  let defaultSearchParamsRef = React70.useRef(createSearchParams(defaultInit));
  let hasSetSearchParamsRef = React70.useRef(false);
  let location = useLocation();
  let searchParams = React70.useMemo(() => (
    // Only merge in the defaults if we haven't yet called setSearchParams.
    // Once we call that we want those to take precedence, otherwise you can't
    // remove a param with setSearchParams({}) if it has an initial value
    getSearchParamsForLocation(location.search, hasSetSearchParamsRef.current ? null : defaultSearchParamsRef.current)
  ), [location.search]);
  let navigate = useNavigate();
  let setSearchParams = React70.useCallback((nextInit, navigateOptions) => {
    const newSearchParams = createSearchParams(typeof nextInit === "function" ? nextInit(searchParams) : nextInit);
    hasSetSearchParamsRef.current = true;
    navigate("?" + newSearchParams, navigateOptions);
  }, [navigate, searchParams]);
  return [searchParams, setSearchParams];
}
function useSubmitImpl(fetcherKey, routeId) {
  let {
    router
  } = useDataRouterContext(DataRouterHook2.UseSubmitImpl);
  let defaultAction = useFormAction();
  return React70.useCallback(function(target, options) {
    if (options === void 0) {
      options = {};
    }
    if (typeof document === "undefined") {
      throw new Error("You are calling submit during the server render. Try calling submit within a `useEffect` or callback instead.");
    }
    let {
      method,
      encType,
      formData,
      url
    } = getFormSubmissionInfo(target, defaultAction, options);
    let href = url.pathname + url.search;
    let opts = {
      replace: options.replace,
      preventScrollReset: options.preventScrollReset,
      formData,
      formMethod: method,
      formEncType: encType
    };
    if (fetcherKey) {
      !(routeId != null) ? true ? invariant3(false, "No routeId available for useFetcher()") : invariant3(false) : void 0;
      router.fetch(fetcherKey, routeId, href, opts);
    } else {
      router.navigate(href, opts);
    }
  }, [defaultAction, router, fetcherKey, routeId]);
}
function useFormAction(action, _temp2) {
  let {
    relative
  } = _temp2 === void 0 ? {} : _temp2;
  let {
    basename
  } = React70.useContext(NavigationContext);
  let routeContext = React70.useContext(RouteContext);
  !routeContext ? true ? invariant3(false, "useFormAction must be used inside a RouteContext") : invariant3(false) : void 0;
  let [match5] = routeContext.matches.slice(-1);
  let path = _extends23({}, useResolvedPath(action ? action : ".", {
    relative
  }));
  let location = useLocation();
  if (action == null) {
    path.search = location.search;
    path.hash = location.hash;
    if (match5.route.index) {
      let params = new URLSearchParams(path.search);
      params.delete("index");
      path.search = params.toString() ? "?" + params.toString() : "";
    }
  }
  if ((!action || action === ".") && match5.route.index) {
    path.search = path.search ? path.search.replace(/^\?/, "?index&") : "?index";
  }
  if (basename !== "/") {
    path.pathname = path.pathname === "/" ? basename : joinPaths([basename, path.pathname]);
  }
  return createPath(path);
}
var SCROLL_RESTORATION_STORAGE_KEY = "react-router-scroll-positions";
var savedScrollPositions = {};
function useScrollRestoration(_temp3) {
  let {
    getKey,
    storageKey
  } = _temp3 === void 0 ? {} : _temp3;
  let {
    router
  } = useDataRouterContext(DataRouterHook2.UseScrollRestoration);
  let {
    restoreScrollPosition,
    preventScrollReset
  } = useDataRouterState2(DataRouterStateHook2.UseScrollRestoration);
  let location = useLocation();
  let matches = useMatches();
  let navigation = useNavigation();
  React70.useEffect(() => {
    window.history.scrollRestoration = "manual";
    return () => {
      window.history.scrollRestoration = "auto";
    };
  }, []);
  usePageHide(React70.useCallback(() => {
    if (navigation.state === "idle") {
      let key = (getKey ? getKey(location, matches) : null) || location.key;
      savedScrollPositions[key] = window.scrollY;
    }
    sessionStorage.setItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY, JSON.stringify(savedScrollPositions));
    window.history.scrollRestoration = "auto";
  }, [storageKey, getKey, navigation.state, location, matches]));
  if (typeof document !== "undefined") {
    React70.useLayoutEffect(() => {
      try {
        let sessionPositions = sessionStorage.getItem(storageKey || SCROLL_RESTORATION_STORAGE_KEY);
        if (sessionPositions) {
          savedScrollPositions = JSON.parse(sessionPositions);
        }
      } catch (e9) {
      }
    }, [storageKey]);
    React70.useLayoutEffect(() => {
      let disableScrollRestoration = router == null ? void 0 : router.enableScrollRestoration(savedScrollPositions, () => window.scrollY, getKey);
      return () => disableScrollRestoration && disableScrollRestoration();
    }, [router, getKey]);
    React70.useLayoutEffect(() => {
      if (restoreScrollPosition === false) {
        return;
      }
      if (typeof restoreScrollPosition === "number") {
        window.scrollTo(0, restoreScrollPosition);
        return;
      }
      if (location.hash) {
        let el = document.getElementById(location.hash.slice(1));
        if (el) {
          el.scrollIntoView();
          return;
        }
      }
      if (preventScrollReset === true) {
        return;
      }
      window.scrollTo(0, 0);
    }, [location, restoreScrollPosition, preventScrollReset]);
  }
}
function usePageHide(callback, options) {
  let {
    capture
  } = options || {};
  React70.useEffect(() => {
    let opts = capture != null ? {
      capture
    } : void 0;
    window.addEventListener("pagehide", callback, opts);
    return () => {
      window.removeEventListener("pagehide", callback, opts);
    };
  }, [callback, capture]);
}

// node_modules/tinacms/dist/index.es.js
function popupWindow(url, title, window2, w7, h11) {
  const y9 = window2.top.outerHeight / 2 + window2.top.screenY - h11 / 2;
  const x7 = window2.top.outerWidth / 2 + window2.top.screenX - w7 / 2;
  return window2.open(url, title, "toolbar=no, location=no, directories=no, status=no, menubar=no, scrollbars=yes, resizable=yes, copyhistory=no, width=" + w7 + ", height=" + h11 + ", top=" + y9 + ", left=" + x7);
}
var TINA_LOGIN_EVENT = "tinaCloudLogin";
var AUTH_TOKEN_KEY = "tinacms-auth";
var authenticate = (clientId, frontendUrl) => {
  return new Promise((resolve) => {
    let authTab;
    window.addEventListener("message", function(e9) {
      if (e9.data.source === TINA_LOGIN_EVENT) {
        if (authTab) {
          authTab.close();
        }
        resolve({
          id_token: e9.data.id_token,
          access_token: e9.data.access_token,
          refresh_token: e9.data.refresh_token
        });
      }
    });
    const origin2 = `${window.location.protocol}//${window.location.host}`;
    authTab = popupWindow(`${frontendUrl}/signin?clientId=${clientId}&origin=${origin2}`, "_blank", window, 1e3, 700);
  });
};
var captureBranchName = /^refs\/heads\/(.*)/;
var parseRefForBranchName = (ref2) => {
  const matches = ref2.match(captureBranchName);
  return matches[1];
};
var ListBranchResponse = z.object({
  name: z.string()
}).array();
var IndexStatusResponse = z.object({
  status: z.union([
    z.literal("complete"),
    z.literal("unknown"),
    z.literal("failed"),
    z.literal("inprogress")
  ]).optional(),
  timestamp: z.number().optional()
});
function asyncPoll(fn2, pollInterval = 5 * 1e3, pollTimeout = 30 * 1e3) {
  const endTime = new Date().getTime() + pollTimeout;
  let stop = false;
  const cancel = () => {
    stop = true;
  };
  const checkCondition = (resolve, reject) => {
    Promise.resolve(fn2()).then((result) => {
      const now3 = new Date().getTime();
      if (stop) {
        reject(new Error("AsyncPoller: cancelled"));
      } else if (result.done) {
        resolve(result.data);
      } else if (now3 < endTime) {
        setTimeout(checkCondition, pollInterval, resolve, reject);
      } else {
        reject(new Error("AsyncPoller: reached timeout"));
      }
    }).catch((err) => {
      reject(err);
    });
  };
  return [new Promise(checkCondition), cancel];
}
var Client = class {
  constructor({ tokenStorage = "MEMORY", ...options }) {
    var _a, _b, _c, _d, _e4, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P;
    this.events = new EventBus();
    this.addPendingContent = async (props) => {
      const mutation = `#graphql
mutation addPendingDocumentMutation(
  $relativePath: String!
  $collection: String!
  $template: String
) {
  addPendingDocument(
    relativePath: $relativePath
    template: $template
    collection: $collection
  ) {
    ... on Document {
      _sys {
        relativePath
        path
        breadcrumbs
        collection {
          slug
        }
      }
    }
  }
}`;
      const result = await this.request(mutation, {
        variables: props
      });
      return result;
    };
    this.getSchema = async () => {
      if (!this.gqlSchema) {
        const data = await this.request(getIntrospectionQuery(), {
          variables: {}
        });
        this.gqlSchema = buildClientSchema(data);
      }
      return this.gqlSchema;
    };
    this.getOptimizedQuery = async (documentNode) => {
      const data = await this.request(`query GetOptimizedQuery($queryString: String!) {
        getOptimizedQuery(queryString: $queryString)
      }`, {
        variables: { queryString: print(documentNode) }
      });
      return parse(data.getOptimizedQuery);
    };
    this.tinaGraphQLVersion = options.tinaGraphQLVersion;
    this.onLogin = (_d = (_c = (_b = (_a = options.schema) == null ? void 0 : _a.config) == null ? void 0 : _b.admin) == null ? void 0 : _c.auth) == null ? void 0 : _d.onLogin;
    this.onLogout = (_h = (_g = (_f = (_e4 = options.schema) == null ? void 0 : _e4.config) == null ? void 0 : _f.admin) == null ? void 0 : _g.auth) == null ? void 0 : _h.onLogout;
    if ((_l = (_k = (_j = (_i = options.schema) == null ? void 0 : _i.config) == null ? void 0 : _j.admin) == null ? void 0 : _k.auth) == null ? void 0 : _l.logout) {
      this.onLogout = (_p = (_o = (_n = (_m = options.schema) == null ? void 0 : _m.config) == null ? void 0 : _n.admin) == null ? void 0 : _o.auth) == null ? void 0 : _p.logout;
    }
    if ((_t = (_s = (_r = (_q = options.schema) == null ? void 0 : _q.config) == null ? void 0 : _r.admin) == null ? void 0 : _s.auth) == null ? void 0 : _t.getUser) {
      this.getUser = (_x = (_w = (_v = (_u = options.schema) == null ? void 0 : _u.config) == null ? void 0 : _v.admin) == null ? void 0 : _w.auth) == null ? void 0 : _x.getUser;
    }
    if ((_B = (_A = (_z = (_y = options.schema) == null ? void 0 : _y.config) == null ? void 0 : _z.admin) == null ? void 0 : _A.auth) == null ? void 0 : _B.authenticate) {
      this.authenticate = (_F = (_E = (_D = (_C = options.schema) == null ? void 0 : _C.config) == null ? void 0 : _D.admin) == null ? void 0 : _E.auth) == null ? void 0 : _F.authenticate;
    }
    if (options.schema) {
      const enrichedSchema = new TinaSchema({
        version: { fullVersion: "", major: "", minor: "", patch: "" },
        meta: { flags: [] },
        ...addNamespaceToSchema({ ...options.schema }, [])
      });
      this.schema = enrichedSchema;
    }
    this.options = options;
    if ((_H = (_G = options.schema) == null ? void 0 : _G.config) == null ? void 0 : _H.contentApiUrlOverride) {
      this.options.customContentApiUrl = options.schema.config.contentApiUrlOverride;
    }
    this.setBranch(options.branch);
    this.events.subscribe("branch:change", ({ branchName }) => {
      this.setBranch(branchName);
    });
    this.clientId = options.clientId;
    switch (tokenStorage) {
      case "LOCAL_STORAGE":
        this.getToken = async function() {
          const tokens2 = localStorage.getItem(AUTH_TOKEN_KEY) || null;
          if (tokens2) {
            return await this.getRefreshedToken(tokens2);
          } else {
            return {
              access_token: null,
              id_token: null,
              refresh_token: null
            };
          }
        };
        this.setToken = function(token2) {
          localStorage.setItem(AUTH_TOKEN_KEY, JSON.stringify(token2, null, 2));
        };
        break;
      case "MEMORY":
        this.getToken = async () => {
          if (this.token) {
            return await this.getRefreshedToken(this.token);
          } else {
            return {
              access_token: null,
              id_token: null,
              refresh_token: null
            };
          }
        };
        this.setToken = (token2) => {
          this.token = JSON.stringify(token2, null, 2);
        };
        break;
      case "CUSTOM":
        if (!options.getTokenFn) {
          throw new Error("When CUSTOM token storage is selected, a getTokenFn must be provided");
        }
        this.getToken = options.getTokenFn;
        break;
    }
    if ((_L = (_K = (_J = (_I = options.schema) == null ? void 0 : _I.config) == null ? void 0 : _J.admin) == null ? void 0 : _K.auth) == null ? void 0 : _L.getToken) {
      this.getToken = (_P = (_O = (_N = (_M = options.schema) == null ? void 0 : _M.config) == null ? void 0 : _N.admin) == null ? void 0 : _O.auth) == null ? void 0 : _P.getToken;
    }
  }
  get isLocalMode() {
    return false;
  }
  setBranch(branchName) {
    var _a, _b, _c, _d;
    const encodedBranch = encodeURIComponent(branchName);
    this.branch = encodedBranch;
    this.assetsApiUrl = ((_a = this.options.tinaioConfig) == null ? void 0 : _a.assetsApiUrlOverride) || "https://assets.tinajs.io";
    this.frontendUrl = ((_b = this.options.tinaioConfig) == null ? void 0 : _b.frontendUrlOverride) || "https://app.tina.io";
    this.identityApiUrl = ((_c = this.options.tinaioConfig) == null ? void 0 : _c.identityApiUrlOverride) || "https://identity.tinajs.io";
    this.contentApiBase = ((_d = this.options.tinaioConfig) == null ? void 0 : _d.contentApiUrlOverride) || `https://content.tinajs.io`;
    this.contentApiUrl = this.options.customContentApiUrl || `${this.contentApiBase}/${this.tinaGraphQLVersion}/content/${this.options.clientId}/github/${encodedBranch}`;
  }
  async request(query, { variables }) {
    const res = await fetch(this.contentApiUrl, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: "Bearer " + (await this.getToken()).id_token
      },
      body: JSON.stringify({
        query: typeof query === "function" ? print(query(lib_default)) : query,
        variables
      })
    });
    if (res.status !== 200) {
      let errorMessage = `Unable to complete request, ${res.statusText}`;
      const resBody = await res.json();
      if (resBody.message) {
        errorMessage = `${errorMessage}, Response: ${resBody.message}`;
      }
      errorMessage = `${errorMessage}, Please check that the following information is correct: 
	clientId: ${this.options.clientId}
	branch: ${this.branch}.`;
      if (this.branch !== "main") {
        errorMessage = `${errorMessage}
	Note: This error can occur if the branch does not exist on GitHub or on Tina Cloud`;
      }
      throw new Error(errorMessage);
    }
    const json2 = await res.json();
    if (json2.errors) {
      throw new Error(`Unable to fetch, errors: 
	${json2.errors.map((error2) => error2.message).join("\n")}`);
    }
    return json2.data;
  }
  async syncTinaMedia() {
    const res = await this.fetchWithToken(`${this.contentApiBase}/assets/${this.clientId}/sync/${this.branch}`, { method: "POST" });
    const jsonRes = await res.json();
    return jsonRes;
  }
  async checkSyncStatus({
    assetsSyncing
  }) {
    const res = await this.fetchWithToken(`${this.assetsApiUrl}/v1/${this.clientId}/syncStatus`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify({ assetsSyncing })
    });
    const jsonRes = await res.json();
    return jsonRes;
  }
  async fetchEvents(limit, cursor) {
    if (this.isLocalMode) {
      return {
        events: []
      };
    } else {
      return (await this.fetchWithToken(`${this.contentApiBase}/events/${this.clientId}/${this.branch}?limit=${limit || 1}${cursor ? `&cursor=${cursor}` : ""}`, { method: "GET" })).json();
    }
  }
  parseJwt(token2) {
    const base64Url = token2.split(".")[1];
    const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
    const jsonPayload = decodeURIComponent(atob(base64).split("").map(function(c16) {
      return "%" + ("00" + c16.charCodeAt(0).toString(16)).slice(-2);
    }).join(""));
    return JSON.parse(jsonPayload);
  }
  async getRefreshedToken(tokens2) {
    const { access_token, id_token, refresh_token } = JSON.parse(tokens2);
    const { exp, iss, client_id } = this.parseJwt(access_token);
    if (Date.now() / 1e3 >= exp - 120) {
      const refreshResponse = await fetch(iss, {
        method: "POST",
        headers: {
          "Content-Type": "application/x-amz-json-1.1",
          "x-amz-target": "AWSCognitoIdentityProviderService.InitiateAuth"
        },
        body: JSON.stringify({
          ClientId: client_id,
          AuthFlow: "REFRESH_TOKEN_AUTH",
          AuthParameters: {
            REFRESH_TOKEN: refresh_token,
            DEVICE_KEY: null
          }
        })
      });
      if (refreshResponse.status !== 200) {
        throw new Error("Unable to refresh auth tokens");
      }
      const responseJson = await refreshResponse.json();
      const newToken = {
        access_token: responseJson.AuthenticationResult.AccessToken,
        id_token: responseJson.AuthenticationResult.IdToken,
        refresh_token
      };
      this.setToken(newToken);
      return Promise.resolve(newToken);
    }
    return Promise.resolve({ access_token, id_token, refresh_token });
  }
  async isAuthorized() {
    return this.isAuthenticated();
  }
  async isAuthenticated() {
    return !!await this.getUser();
  }
  async logout() {
    this.setToken(null);
  }
  async authenticate() {
    const token2 = await authenticate(this.clientId, this.frontendUrl);
    this.setToken(token2);
    return token2;
  }
  async fetchWithToken(input, init) {
    const headers2 = (init == null ? void 0 : init.headers) || {};
    return await fetch(input, {
      ...init,
      headers: new Headers({
        Authorization: "Bearer " + (await this.getToken()).id_token,
        ...headers2
      })
    });
  }
  async getUser() {
    if (!this.clientId) {
      return null;
    }
    const url = `${this.identityApiUrl}/v2/apps/${this.clientId}/currentUser`;
    try {
      const res = await this.fetchWithToken(url, {
        method: "GET"
      });
      const val = await res.json();
      if (!res.status.toString().startsWith("2")) {
        console.error(val.error);
        return null;
      }
      return val;
    } catch (e9) {
      console.error(e9);
      return null;
    }
  }
  async getBillingState() {
    if (!this.clientId) {
      return null;
    }
    const url = `${this.identityApiUrl}/v2/apps/${this.clientId}/billing/state`;
    try {
      const res = await this.fetchWithToken(url, {
        method: "GET"
      });
      const val = await res.json();
      if (!res.status.toString().startsWith("2")) {
        console.error(val.error);
        return null;
      }
      return {
        clientId: val.clientId || this.clientId,
        delinquencyDate: val.delinquencyDate,
        billingState: val.billingState
      };
    } catch (e9) {
      console.error(e9);
      return null;
    }
  }
  waitForIndexStatus({ ref: ref2 }) {
    try {
      const [prom, cancel] = asyncPoll(async () => {
        try {
          const result = await this.getIndexStatus({ ref: ref2 });
          if (!(result.status === "inprogress" || result.status === "unknown")) {
            return Promise.resolve({
              done: true,
              data: result
            });
          } else {
            return Promise.resolve({
              done: false
            });
          }
        } catch (err) {
          return Promise.reject(err);
        }
      }, 5e3, 9e5);
      return [prom, cancel];
    } catch (error2) {
      if (error2.message === "AsyncPoller: reached timeout") {
        console.warn(error2);
        return {
          status: "timeout"
        };
      }
      throw error2;
    }
  }
  async getIndexStatus({ ref: ref2 }) {
    const url = `${this.contentApiBase}/db/${this.clientId}/status/${ref2}`;
    const res = await this.fetchWithToken(url);
    const result = await res.json();
    const parsedResult = IndexStatusResponse.parse(result);
    return parsedResult;
  }
  async listBranches() {
    try {
      const url = `${this.contentApiBase}/github/${this.clientId}/list_branches`;
      const res = await this.fetchWithToken(url, {
        method: "GET"
      });
      const branches = await res.json();
      const parsedBranches = ListBranchResponse.parse(branches);
      const indexStatusPromises = parsedBranches.map(async (branch) => {
        const indexStatus2 = await this.getIndexStatus({ ref: branch.name });
        return {
          ...branch,
          indexStatus: indexStatus2
        };
      });
      const indexStatus = await Promise.all(indexStatusPromises);
      return indexStatus;
    } catch (error2) {
      console.error("There was an error listing branches.", error2);
      throw error2;
    }
  }
  async createBranch({ baseBranch, branchName }) {
    const url = `${this.contentApiBase}/github/${this.clientId}/create_branch`;
    try {
      const res = await this.fetchWithToken(url, {
        method: "POST",
        body: JSON.stringify({
          baseBranch,
          branchName
        }),
        headers: {
          "Content-Type": "application/json"
        }
      });
      return await res.json().then((r15) => parseRefForBranchName(r15.data.ref));
    } catch (error2) {
      console.error("There was an error creating a new branch.", error2);
      return null;
    }
  }
};
var DEFAULT_LOCAL_TINA_GQL_SERVER_URL = "http://localhost:4001/graphql";
var LOCAL_CLIENT_KEY = "tina.local.isLogedIn";
var LocalClient = class extends Client {
  constructor(props) {
    const clientProps = {
      ...props,
      clientId: "",
      branch: "",
      tinaGraphQLVersion: "",
      customContentApiUrl: props && props.customContentApiUrl ? props.customContentApiUrl : DEFAULT_LOCAL_TINA_GQL_SERVER_URL
    };
    super(clientProps);
  }
  get isLocalMode() {
    return true;
  }
  async logout() {
    localStorage.removeItem(LOCAL_CLIENT_KEY);
  }
  async authenticate() {
    localStorage.setItem(LOCAL_CLIENT_KEY, "true");
    return { access_token: "LOCAL", id_token: "LOCAL", refresh_token: "LOCAL" };
  }
  async getUser() {
    return localStorage.getItem(LOCAL_CLIENT_KEY) === "true";
  }
};
function ModalBuilder(modalProps) {
  return import_react120.default.createElement(Modal, null, import_react120.default.createElement(ModalPopup, null, import_react120.default.createElement(ModalHeader, null, modalProps.title), import_react120.default.createElement(ModalBody, {
    padded: true
  }, import_react120.default.createElement("p", null, modalProps.message), modalProps.error && import_react120.default.createElement(ErrorLabel, null, modalProps.error)), import_react120.default.createElement(ModalActions, null, modalProps.actions.map((action) => import_react120.default.createElement(AsyncButton, {
    key: action.name,
    ...action
  })))));
}
var ErrorLabel = ({ style: style2 = {}, ...props }) => import_react120.default.createElement("p", {
  style: { ...style2, color: "var(--tina-color-error)" },
  ...props
});
var AsyncButton = ({ name: name2, primary, action }) => {
  const [submitting, setSubmitting] = (0, import_react120.useState)(false);
  const onClick = (0, import_react120.useCallback)(async () => {
    setSubmitting(true);
    try {
      await action();
      setSubmitting(false);
    } catch (e9) {
      setSubmitting(false);
      throw e9;
    }
  }, [action, setSubmitting]);
  return import_react120.default.createElement(Button, {
    "data-test": name2.replace(/\s/g, "-").toLowerCase(),
    variant: primary ? "primary" : "secondary",
    onClick,
    busy: submitting,
    disabled: submitting
  }, submitting && import_react120.default.createElement(LoadingDots, null), !submitting && name2);
};
var TINA_AUTH_CONFIG = "tina_auth_config";
var useTinaAuthRedirect = () => {
  (0, import_react120.useEffect)(() => {
    const urlParams = new URLSearchParams(window.location.search);
    const config2 = {
      code: urlParams.get("code") || "",
      scope: urlParams.get("scope") || "email",
      state: urlParams.get("state")
    };
    if (!config2.code) {
      return;
    }
    localStorage[TINA_AUTH_CONFIG] = JSON.stringify(config2);
  }, []);
};
var createClient = ({
  clientId,
  isLocalClient = true,
  branch,
  tinaioConfig,
  schema,
  apiUrl,
  tinaGraphQLVersion
}) => {
  return isLocalClient ? new LocalClient({ customContentApiUrl: apiUrl, schema }) : new Client({
    clientId: clientId || "",
    branch: branch || "main",
    tokenStorage: "LOCAL_STORAGE",
    tinaioConfig,
    schema,
    tinaGraphQLVersion
  });
};
function assertShape2(value, yupSchema, errorMessage) {
  const shape = yupSchema(es_exports);
  try {
    shape.validateSync(value);
  } catch (e9) {
    const message = errorMessage || `Failed to assertShape - ${e9.message}`;
    throw new Error(message);
  }
}
function safeAssertShape(value, yupSchema) {
  try {
    assertShape2(value, yupSchema);
    return true;
  } catch (e9) {
    return false;
  }
}
var TinaAdminApi = class {
  constructor(cms) {
    this.api = cms.api.tina;
    this.schema = cms.api.tina.schema;
  }
  async isAuthenticated() {
    return await this.api.isAuthenticated();
  }
  async checkGraphqlSchema({ localSchema }) {
    const schemaFromCloud = await this.api.getSchema();
    const schema1 = schemaFromCloud;
    const schema2 = buildSchema(print(localSchema));
    const diffOutput = await diff2(schema1, schema2);
    if (diffOutput.length > 0) {
      return false;
    } else {
      return true;
    }
  }
  fetchCollections() {
    return this.schema.getCollections();
  }
  async renameDocument({ collection, relativePath, newRelativePath }) {
    await this.api.request(`#graphql
              mutation RenameDocument($collection: String!, $relativePath: String! $newRelativePath: String!) {
                updateDocument(collection: $collection, relativePath: $relativePath, params: {relativePath: $newRelativePath}){
    __typename
  }
              }
            `, { variables: { collection, relativePath, newRelativePath } });
  }
  async deleteDocument({
    collection,
    relativePath
  }) {
    await this.api.request(`#graphql
      mutation DeleteDocument($collection: String!, $relativePath: String!  ){
  deleteDocument(collection: $collection, relativePath: $relativePath){
    __typename
  }
}`, { variables: { collection, relativePath } });
  }
  async fetchCollection(collectionName, includeDocuments, after, sortKey, order, filterArgs) {
    let filter = null;
    const filterField = filterArgs == null ? void 0 : filterArgs.filterField;
    if (filterField) {
      filter = {
        [collectionName]: {
          [filterField]: {}
        }
      };
    }
    if (filterField && (filterArgs == null ? void 0 : filterArgs.startsWith)) {
      filter[collectionName][filterField] = {
        ...filter[collectionName][filterField] || {},
        startsWith: filterArgs.startsWith
      };
    }
    if (filterField && (filterArgs == null ? void 0 : filterArgs.before)) {
      filter[collectionName][filterField] = {
        ...filter[collectionName][filterField] || {},
        before: filterArgs.before
      };
    }
    if (filterField && (filterArgs == null ? void 0 : filterArgs.after)) {
      filter[collectionName][filterField] = {
        ...filter[collectionName][filterField] || {},
        after: filterArgs.after
      };
    }
    if (filterField && (filterArgs == null ? void 0 : filterArgs.booleanEquals) !== null && (filterArgs == null ? void 0 : filterArgs.booleanEquals) !== void 0) {
      filter[collectionName][filterField] = {
        ...filter[collectionName][filterField] || {},
        eq: filterArgs.booleanEquals
      };
    }
    if (includeDocuments === true) {
      const sort = sortKey || this.schema.getIsTitleFieldName(collectionName);
      const response = order === "asc" ? await this.api.request(`#graphql
      query($collection: String!, $includeDocuments: Boolean!, $sort: String,  $limit: Float, $after: String, $filter: DocumentFilter){
        collection(collection: $collection){
          name
          label
          format
          templates
          documents(sort: $sort, after: $after, first: $limit, filter: $filter) @include(if: $includeDocuments) {
            totalCount
            pageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            edges {
              node {
                ... on Document {
                  _sys {
                    title
                    template
                    breadcrumbs
                    path
                    basename
                    relativePath
                    filename
                    extension
                  }
                }
              }
            }
          }
        }
      }`, {
        variables: {
          collection: collectionName,
          includeDocuments,
          sort,
          limit: 50,
          after,
          filter
        }
      }) : await this.api.request(`#graphql
      query($collection: String!, $includeDocuments: Boolean!, $sort: String,  $limit: Float, $after: String, $filter: DocumentFilter){
        collection(collection: $collection){
          name
          label
          format
          templates
          documents(sort: $sort, before: $after, last: $limit, filter: $filter) @include(if: $includeDocuments) {
            totalCount
            pageInfo {
              hasPreviousPage
              hasNextPage
              startCursor
              endCursor
            }
            edges {
              node {
                ... on Document {
                  _sys {
                    title
                    template
                    breadcrumbs
                    path
                    basename
                    relativePath
                    filename
                    extension
                  }
                }
              }
            }
          }
        }
      }`, {
        variables: {
          collection: collectionName,
          includeDocuments,
          sort,
          limit: 50,
          after,
          filter
        }
      });
      return response.collection;
    } else {
      try {
        const collection = this.schema.getCollection(collectionName);
        return collection;
      } catch (e9) {
        console.error(`[TinaAdminAPI] Unable to fetchCollection(): ${e9.message}`);
        return void 0;
      }
    }
  }
  async fetchDocument(collectionName, relativePath) {
    const response = await this.api.request(`#graphql
      query($collection: String!, $relativePath: String!) {
        document(collection:$collection, relativePath:$relativePath) {
          ... on Document {
            _values
          }
        }
      }`, { variables: { collection: collectionName, relativePath } });
    return response;
  }
  async createDocument(collectionName, relativePath, params) {
    const response = await this.api.request(`#graphql
      mutation($collection: String!, $relativePath: String!, $params: DocumentMutation!) {
        createDocument(
          collection: $collection,
          relativePath: $relativePath,
          params: $params
        ){__typename}
      }`, {
      variables: {
        collection: collectionName,
        relativePath,
        params
      }
    });
    return response;
  }
  async updateDocument(collectionName, relativePath, params) {
    const response = await this.api.request(`#graphql
      mutation($collection: String!, $relativePath: String!, $params: DocumentUpdateMutation!) {
        updateDocument(
          collection: $collection,
          relativePath: $relativePath,
          params: $params
        ){__typename}
      }`, {
      variables: {
        collection: collectionName,
        relativePath,
        params
      }
    });
    return response;
  }
};
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
var AuthWallInner = ({
  children,
  cms,
  loginScreen,
  getModalActions
}) => {
  var _a, _b, _c, _d, _e4;
  const client = cms.api.tina;
  const isTinaCloud = !client.isLocalMode && !((_e4 = (_d = (_c = (_b = (_a = client.schema) == null ? void 0 : _a.config) == null ? void 0 : _b.config) == null ? void 0 : _c.admin) == null ? void 0 : _d.auth) == null ? void 0 : _e4.customAuth);
  const [activeModal, setActiveModal] = (0, import_react120.useState)(null);
  const [showChildren, setShowChildren] = (0, import_react120.useState)(false);
  import_react120.default.useEffect(() => {
    client.isAuthenticated().then((isAuthenticated) => {
      if (isAuthenticated) {
        setShowChildren(true);
        cms.enable();
      } else {
        sleep(500).then(() => {
          setActiveModal("authenticate");
        });
      }
    });
  }, []);
  const onAuthSuccess = async () => {
    if (await client.isAuthenticated()) {
      setShowChildren(true);
      setActiveModal(null);
    } else {
      throw new Error("No access to repo");
    }
  };
  const otherModalActions = getModalActions ? getModalActions({
    closeModal: () => {
      setActiveModal(null);
    }
  }) : [];
  return import_react120.default.createElement(import_react120.default.Fragment, null, activeModal === "authenticate" && import_react120.default.createElement(ModalBuilder, {
    title: isTinaCloud ? "Tina Cloud Authorization" : "Enter into edit mode",
    message: isTinaCloud ? "To save edits, Tina Cloud authorization is required. On save, changes will get commited using your account." : "To save edits, enter into edit mode. On save, changes will saved to the local filesystem.",
    close,
    actions: [
      ...otherModalActions,
      {
        action: async () => {
          setEditing(false);
          window.location.reload();
        },
        name: "Close",
        primary: false
      },
      {
        name: isTinaCloud ? "Continue to Tina Cloud" : "Enter Edit Mode",
        action: async () => {
          const token2 = await client.authenticate();
          if (typeof (client == null ? void 0 : client.onLogin) === "function") {
            await (client == null ? void 0 : client.onLogin({ token: token2 }));
          }
          onAuthSuccess();
        },
        primary: true
      }
    ]
  }), showChildren ? children : loginScreen ? loginScreen : null);
};
var TinaCloudProvider = (props) => {
  const baseBranch = props.branch || "main";
  const [currentBranch, setCurrentBranch] = useLocalStorage("tinacms-current-branch", baseBranch);
  useTinaAuthRedirect();
  const cms = import_react120.default.useMemo(() => props.cms || new TinaCMS({
    enabled: true,
    sidebar: true,
    isLocalClient: props.isLocalClient,
    clientId: props.clientId
  }), [props.cms]);
  if (!cms.api.tina) {
    cms.registerApi("tina", createClient({ ...props, branch: currentBranch }));
  } else {
    cms.api.tina.setBranch(currentBranch);
  }
  if (!cms.api.admin) {
    cms.registerApi("admin", new TinaAdminApi(cms));
  }
  const setupMedia = async () => {
    var _a, _b, _c, _d, _e4, _f, _g;
    const hasTinaMedia = Boolean((_b = (_a = props.schema.config) == null ? void 0 : _a.media) == null ? void 0 : _b.tina);
    if (hasTinaMedia) {
      cms.media.store = new TinaMediaStore(cms);
    } else if (((_d = (_c = props.schema.config) == null ? void 0 : _c.media) == null ? void 0 : _d.loadCustomStore) || props.mediaStore) {
      const mediaStoreFromProps = ((_f = (_e4 = props.schema.config) == null ? void 0 : _e4.media) == null ? void 0 : _f.loadCustomStore) || props.mediaStore;
      if ((_g = mediaStoreFromProps.prototype) == null ? void 0 : _g.persist) {
        cms.media.store = new mediaStoreFromProps(cms.api.tina);
      } else {
        const MediaClass = await mediaStoreFromProps();
        cms.media.store = new MediaClass(cms.api.tina);
      }
    } else {
      cms.media.store = new DummyMediaStore();
    }
  };
  const handleListBranches = async () => {
    const { owner, repo } = props;
    const branches = await cms.api.tina.listBranches({ owner, repo });
    if (!Array.isArray(branches)) {
      return [];
    }
    return branches;
  };
  const handleCreateBranch = async (data) => {
    const newBranch = await cms.api.tina.createBranch(data);
    return newBranch;
  };
  setupMedia();
  const [branchingEnabled, setBranchingEnabled] = import_react120.default.useState(() => cms.flags.get("branch-switcher"));
  import_react120.default.useEffect(() => {
    cms.events.subscribe("flag:set", ({ key, value }) => {
      if (key === "branch-switcher") {
        setBranchingEnabled(value);
      }
    });
  }, [cms.events]);
  import_react120.default.useEffect(() => {
    let branchSwitcher;
    if (branchingEnabled) {
      branchSwitcher = new BranchSwitcherPlugin({
        listBranches: handleListBranches,
        createBranch: handleCreateBranch,
        chooseBranch: setCurrentBranch
      });
      cms.plugins.add(branchSwitcher);
    }
    return () => {
      if (branchingEnabled && branchSwitcher) {
        cms.plugins.remove(branchSwitcher);
      }
    };
  }, [branchingEnabled, props.branch]);
  import_react120.default.useEffect(() => {
    if (props.cmsCallback) {
      props.cmsCallback(cms);
    }
  }, []);
  return import_react120.default.createElement(BranchDataProvider, {
    currentBranch,
    setCurrentBranch: (b6) => {
      setCurrentBranch(b6);
    }
  }, import_react120.default.createElement(TinaProvider, {
    cms
  }, import_react120.default.createElement(AuthWallInner, {
    ...props,
    cms
  })));
};
var TinaCloudAuthWall = TinaCloudProvider;
var styles4 = `.tina-tailwind {
  line-height: 1.5;
  -webkit-text-size-adjust: 100%;
  -moz-tab-size: 4;
  tab-size: 4;
}

  .tina-tailwind *,
  .tina-tailwind ::before,
  .tina-tailwind ::after {
    box-sizing: border-box;
    border-width: 0;
    border-style: solid;
    border-color: transparent;
  }

  .tina-tailwind ::before,
  .tina-tailwind ::after {
    --tw-content: '';
  }

  .tina-tailwind hr {
    height: 0; /* 1 */
    color: inherit; /* 2 */
    border-top-width: 1px; /* 3 */
  }

  .tina-tailwind abbr:where([title]) {
    text-decoration: underline dotted;
  }

  .tina-tailwind h1,
  .tina-tailwind h2,
  .tina-tailwind h3,
  .tina-tailwind h4,
  .tina-tailwind h5,
  .tina-tailwind h6 {
    font-size: inherit;
    font-weight: inherit;
  }

  .tina-tailwind a {
    color: inherit;
    text-decoration: inherit;
  }

  .tina-tailwind b,
  .tina-tailwind strong {
    font-weight: bolder;
  }

  .tina-tailwind code,
  .tina-tailwind kbd,
  .tina-tailwind samp,
  .tina-tailwind pre {
    font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; /* 1 */
    font-size: 1em; /* 2 */
  }

  .tina-tailwind small {
    font-size: 80%;
  }

  .tina-tailwind sub,
  .tina-tailwind sup {
    font-size: 75%;
    line-height: 0;
    position: relative;
    vertical-align: baseline;
  }

  .tina-tailwind sub {
    bottom: -0.25em;
  }

  .tina-tailwind sup {
    top: -0.5em;
  }

  .tina-tailwind table {
    text-indent: 0; /* 1 */
    border-color: inherit; /* 2 */
    border-collapse: collapse; /* 3 */
  }

  .tina-tailwind button,
  .tina-tailwind input,
  .tina-tailwind optgroup,
  .tina-tailwind select,
  .tina-tailwind textarea {
    font-family: inherit; /* 1 */
    font-size: 100%; /* 1 */
    line-height: inherit; /* 1 */
    color: inherit; /* 1 */
    margin: 0; /* 2 */
    padding: 0; /* 3 */
  }

  .tina-tailwind button,
  .tina-tailwind select {
    text-transform: none;
  }

  .tina-tailwind button,
  .tina-tailwind [type='button'],
  .tina-tailwind [type='reset'],
  .tina-tailwind [type='submit'] {
    -webkit-appearance: button; /* 1 */
    background-color: transparent; /* 2 */
    background-image: none; /* 2 */
  }

  .tina-tailwind :-moz-focusring {
    outline: auto;
  }

  .tina-tailwind :-moz-ui-invalid {
    box-shadow: none;
  }

  .tina-tailwind progress {
    vertical-align: baseline;
  }

  .tina-tailwind ::-webkit-inner-spin-button,
  .tina-tailwind ::-webkit-outer-spin-button {
    height: auto;
  }

  .tina-tailwind [type='search'] {
    -webkit-appearance: textfield; /* 1 */
    outline-offset: -2px; /* 2 */
  }

  .tina-tailwind ::-webkit-search-decoration {
    -webkit-appearance: none;
  }

  .tina-tailwind ::-webkit-file-upload-button {
    -webkit-appearance: button; /* 1 */
    font: inherit; /* 2 */
  }

  .tina-tailwind summary {
    display: list-item;
  }

  .tina-tailwind blockquote,
  .tina-tailwind dl,
  .tina-tailwind dd,
  .tina-tailwind h1,
  .tina-tailwind h2,
  .tina-tailwind h3,
  .tina-tailwind h4,
  .tina-tailwind h5,
  .tina-tailwind h6,
  .tina-tailwind hr,
  .tina-tailwind figure,
  .tina-tailwind p,
  .tina-tailwind pre {
    margin: 0;
  }

  .tina-tailwind fieldset {
    margin: 0;
    padding: 0;
  }

  .tina-tailwind legend {
    padding: 0;
  }

  .tina-tailwind ol,
  .tina-tailwind ul,
  .tina-tailwind menu {
    list-style: none;
    margin: 0;
    padding: 0;
  }

  .tina-tailwind li:before {
    display: none;
  }

  .tina-tailwind textarea {
    resize: vertical;
  }

  .tina-tailwind input::placeholder,
  .tina-tailwind textarea::placeholder {
    opacity: 1; /* 1 */
    color: #918c9e; /* 2 */
  }

  .tina-tailwind button,
  .tina-tailwind [role='button'] {
    cursor: pointer;
  }

  .tina-tailwind :disabled {
    cursor: default;
  }

  .tina-tailwind img,
  .tina-tailwind svg,
  .tina-tailwind video,
  .tina-tailwind canvas,
  .tina-tailwind audio,
  .tina-tailwind iframe,
  .tina-tailwind embed,
  .tina-tailwind object {
    display: block; /* 1 */
    vertical-align: middle; /* 2 */
  }

  .tina-tailwind img,
  .tina-tailwind video {
    max-width: 100%;
    height: auto;
  }

  .tina-tailwind [hidden] {
    display: none;
  }
*, ::before, ::after {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(0 132 255 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
}
::backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(0 132 255 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
}
.tina-tailwind .pointer-events-none {
  pointer-events: none;
}
.tina-tailwind .pointer-events-auto {
  pointer-events: auto;
}
.tina-tailwind .static {
  position: static;
}
.tina-tailwind .fixed {
  position: fixed;
}
.tina-tailwind .absolute {
  position: absolute;
}
.tina-tailwind .relative {
  position: relative;
}
.tina-tailwind .inset-0 {
  top: 0px;
  right: 0px;
  bottom: 0px;
  left: 0px;
}
.tina-tailwind .left-0 {
  left: 0px;
}
.tina-tailwind .left-2 {
  left: 8px;
}
.tina-tailwind .right-0 {
  right: 0px;
}
.tina-tailwind .top-0 {
  top: 0px;
}
.tina-tailwind .top-1\\/2 {
  top: 50%;
}
.tina-tailwind .top-10 {
  top: 40px;
}
.tina-tailwind .top-4 {
  top: 16px;
}
.tina-tailwind .top-8 {
  top: 32px;
}
.tina-tailwind .z-50 {
  z-index: 50;
}
.tina-tailwind .z-menu {
  z-index: 9800;
}
.tina-tailwind .z-overlay {
  z-index: 10600;
}
.tina-tailwind .mx-auto {
  margin-left: auto;
  margin-right: auto;
}
.tina-tailwind .-ml-px {
  margin-left: -1px;
}
.tina-tailwind .-mt-0 {
  margin-top: -0px;
}
.tina-tailwind .-mt-0\\.5 {
  margin-top: -2px;
}
.tina-tailwind .mb-1 {
  margin-bottom: 4px;
}
.tina-tailwind .mb-2 {
  margin-bottom: 8px;
}
.tina-tailwind .mb-4 {
  margin-bottom: 16px;
}
.tina-tailwind .mb-6 {
  margin-bottom: 24px;
}
.tina-tailwind .mb-8 {
  margin-bottom: 32px;
}
.tina-tailwind .ml-1 {
  margin-left: 4px;
}
.tina-tailwind .ml-1\\.5 {
  margin-left: 6px;
}
.tina-tailwind .mr-1 {
  margin-right: 4px;
}
.tina-tailwind .mr-1\\.5 {
  margin-right: 6px;
}
.tina-tailwind .mr-2 {
  margin-right: 8px;
}
.tina-tailwind .mt-2 {
  margin-top: 8px;
}
.tina-tailwind .block {
  display: block;
}
.tina-tailwind .inline-block {
  display: inline-block;
}
.tina-tailwind .flex {
  display: flex;
}
.tina-tailwind .inline-flex {
  display: inline-flex;
}
.tina-tailwind .table {
  display: table;
}
.tina-tailwind .grid {
  display: grid;
}
.tina-tailwind .h-10 {
  height: 40px;
}
.tina-tailwind .h-12 {
  height: 48px;
}
.tina-tailwind .h-5 {
  height: 20px;
}
.tina-tailwind .h-6 {
  height: 24px;
}
.tina-tailwind .h-7 {
  height: 28px;
}
.tina-tailwind .h-auto {
  height: auto;
}
.tina-tailwind .h-full {
  height: 100%;
}
.tina-tailwind .h-screen {
  height: 100vh;
}
.tina-tailwind .w-0 {
  width: 0px;
}
.tina-tailwind .w-10 {
  width: 40px;
}
.tina-tailwind .w-12 {
  width: 48px;
}
.tina-tailwind .w-5 {
  width: 20px;
}
.tina-tailwind .w-56 {
  width: 224px;
}
.tina-tailwind .w-6 {
  width: 24px;
}
.tina-tailwind .w-7 {
  width: 28px;
}
.tina-tailwind .w-\\[15\\%\\] {
  width: 15%;
}
.tina-tailwind .w-auto {
  width: auto;
}
.tina-tailwind .w-full {
  width: 100%;
}
.tina-tailwind .max-w-0 {
  max-width: 0rem;
}
.tina-tailwind .max-w-form {
  max-width: 900px;
}
.tina-tailwind .max-w-full {
  max-width: 100%;
}
.tina-tailwind .max-w-lg {
  max-width: 32rem;
}
.tina-tailwind .max-w-screen-xl {
  max-width: 1280px;
}
.tina-tailwind .flex-1 {
  flex: 1 1 0%;
}
.tina-tailwind .flex-shrink-0 {
  flex-shrink: 0;
}
.tina-tailwind .flex-grow-0 {
  flex-grow: 0;
}
.tina-tailwind .table-auto {
  table-layout: auto;
}
.tina-tailwind .origin-top-right {
  transform-origin: top right;
}
.tina-tailwind .-translate-x-full {
  --tw-translate-x: -100%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tina-tailwind .-translate-y-1\\/2 {
  --tw-translate-y: -50%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tina-tailwind .translate-x-0 {
  --tw-translate-x: 0px;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tina-tailwind .translate-x-full {
  --tw-translate-x: 100%;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tina-tailwind .scale-100 {
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tina-tailwind .scale-95 {
  --tw-scale-x: .95;
  --tw-scale-y: .95;
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tina-tailwind .transform {
  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));
}
.tina-tailwind .cursor-pointer {
  cursor: pointer;
}
.tina-tailwind .grid-flow-col {
  grid-auto-flow: column;
}
.tina-tailwind .flex-col {
  flex-direction: column;
}
.tina-tailwind .flex-wrap {
  flex-wrap: wrap;
}
.tina-tailwind .items-start {
  align-items: flex-start;
}
.tina-tailwind .items-end {
  align-items: flex-end;
}
.tina-tailwind .items-center {
  align-items: center;
}
.tina-tailwind .items-stretch {
  align-items: stretch;
}
.tina-tailwind .justify-end {
  justify-content: flex-end;
}
.tina-tailwind .justify-center {
  justify-content: center;
}
.tina-tailwind .justify-between {
  justify-content: space-between;
}
.tina-tailwind .gap-0 {
  gap: 0px;
}
.tina-tailwind .gap-0\\.5 {
  gap: 2px;
}
.tina-tailwind .gap-2 {
  gap: 8px;
}
.tina-tailwind .gap-3 {
  gap: 12px;
}
.tina-tailwind .gap-4 {
  gap: 16px;
}
.tina-tailwind .divide-y > :not([hidden]) ~ :not([hidden]) {
  --tw-divide-y-reverse: 0;
  border-top-width: calc(1px * calc(1 - var(--tw-divide-y-reverse)));
  border-bottom-width: calc(1px * var(--tw-divide-y-reverse));
}
.tina-tailwind .divide-gray-150 > :not([hidden]) ~ :not([hidden]) {
  --tw-divide-opacity: 1;
  border-color: rgb(230 227 239 / var(--tw-divide-opacity));
}
.tina-tailwind .self-end {
  align-self: flex-end;
}
.tina-tailwind .justify-self-end {
  justify-self: end;
}
.tina-tailwind .overflow-hidden {
  overflow: hidden;
}
.tina-tailwind .overflow-y-auto {
  overflow-y: auto;
}
.tina-tailwind .truncate {
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.tina-tailwind .whitespace-normal {
  white-space: normal;
}
.tina-tailwind .whitespace-nowrap {
  white-space: nowrap;
}
.tina-tailwind .rounded {
  border-radius: 4px;
}
.tina-tailwind .rounded-full {
  border-radius: 9999px;
}
.tina-tailwind .rounded-lg {
  border-radius: 8px;
}
.tina-tailwind .rounded-md {
  border-radius: 6px;
}
.tina-tailwind .rounded-r-md {
  border-top-right-radius: 6px;
  border-bottom-right-radius: 6px;
}
.tina-tailwind .border {
  border-width: 1px;
}
.tina-tailwind .border-b {
  border-bottom-width: 1px;
}
.tina-tailwind .border-gray-100 {
  --tw-border-opacity: 1;
  border-color: rgb(237 236 243 / var(--tw-border-opacity));
}
.tina-tailwind .border-gray-150 {
  --tw-border-opacity: 1;
  border-color: rgb(230 227 239 / var(--tw-border-opacity));
}
.tina-tailwind .border-gray-200 {
  --tw-border-opacity: 1;
  border-color: rgb(225 221 236 / var(--tw-border-opacity));
}
.tina-tailwind .bg-blue-500 {
  --tw-bg-opacity: 1;
  background-color: rgb(0 132 255 / var(--tw-bg-opacity));
}
.tina-tailwind .bg-gray-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(237 236 243 / var(--tw-bg-opacity));
}
.tina-tailwind .bg-gray-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(246 246 249 / var(--tw-bg-opacity));
}
.tina-tailwind .bg-white {
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity));
}
.tina-tailwind .bg-gradient-to-b {
  background-image: linear-gradient(to bottom, var(--tw-gradient-stops));
}
.tina-tailwind .bg-gradient-to-br {
  background-image: linear-gradient(to bottom right, var(--tw-gradient-stops));
}
.tina-tailwind .from-blue-900 {
  --tw-gradient-from: #1D2C6C;
  --tw-gradient-to: rgb(29 44 108 / 0);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}
.tina-tailwind .from-gray-50\\/50 {
  --tw-gradient-from: rgb(246 246 249 / .5);
  --tw-gradient-to: rgb(246 246 249 / 0);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}
.tina-tailwind .from-gray-800 {
  --tw-gradient-from: #363145;
  --tw-gradient-to: rgb(54 49 69 / 0);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}
.tina-tailwind .via-gray-900 {
  --tw-gradient-to: rgb(37 35 54 / 0);
  --tw-gradient-stops: var(--tw-gradient-from), #252336, var(--tw-gradient-to);
}
.tina-tailwind .to-black {
  --tw-gradient-to: #000;
}
.tina-tailwind .to-gray-50 {
  --tw-gradient-to: #F6F6F9;
}
.tina-tailwind .to-gray-900 {
  --tw-gradient-to: #252336;
}
.tina-tailwind .fill-current {
  fill: currentColor;
}
.tina-tailwind .px-12 {
  padding-left: 48px;
  padding-right: 48px;
}
.tina-tailwind .px-20 {
  padding-left: 80px;
  padding-right: 80px;
}
.tina-tailwind .px-3 {
  padding-left: 12px;
  padding-right: 12px;
}
.tina-tailwind .px-4 {
  padding-left: 16px;
  padding-right: 16px;
}
.tina-tailwind .px-5 {
  padding-left: 20px;
  padding-right: 20px;
}
.tina-tailwind .px-6 {
  padding-left: 24px;
  padding-right: 24px;
}
.tina-tailwind .py-1 {
  padding-top: 4px;
  padding-bottom: 4px;
}
.tina-tailwind .py-10 {
  padding-top: 40px;
  padding-bottom: 40px;
}
.tina-tailwind .py-2 {
  padding-top: 8px;
  padding-bottom: 8px;
}
.tina-tailwind .py-3 {
  padding-top: 12px;
  padding-bottom: 12px;
}
.tina-tailwind .py-4 {
  padding-top: 16px;
  padding-bottom: 16px;
}
.tina-tailwind .py-5 {
  padding-top: 20px;
  padding-bottom: 20px;
}
.tina-tailwind .py-6 {
  padding-top: 24px;
  padding-bottom: 24px;
}
.tina-tailwind .py-8 {
  padding-top: 32px;
  padding-bottom: 32px;
}
.tina-tailwind .pl-18 {
  padding-left: 72px;
}
.tina-tailwind .pl-3 {
  padding-left: 12px;
}
.tina-tailwind .pl-5 {
  padding-left: 20px;
}
.tina-tailwind .pl-8 {
  padding-left: 32px;
}
.tina-tailwind .pr-3 {
  padding-right: 12px;
}
.tina-tailwind .pt-12 {
  padding-top: 48px;
}
.tina-tailwind .pt-4 {
  padding-top: 16px;
}
.tina-tailwind .text-left {
  text-align: left;
}
.tina-tailwind .text-center {
  text-align: center;
}
.tina-tailwind .font-sans {
  font-family: Inter, ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
}
.tina-tailwind .text-2xl {
  font-size: 24px;
  line-height: 1.33;
}
.tina-tailwind .text-4xl {
  font-size: 36px;
  line-height: 1.1;
}
.tina-tailwind .text-base {
  font-size: 16px;
  line-height: 1.5;
}
.tina-tailwind .text-md {
  font-size: 16px;
  line-height: 1.5;
}
.tina-tailwind .text-sm {
  font-size: 14px;
  line-height: 1.43;
}
.tina-tailwind .text-xl {
  font-size: 20px;
  line-height: 1.4;
}
.tina-tailwind .text-xs {
  font-size: 13px;
  line-height: 1.33;
}
.tina-tailwind .font-medium {
  font-weight: 500;
}
.tina-tailwind .font-semibold {
  font-weight: 600;
}
.tina-tailwind .uppercase {
  text-transform: uppercase;
}
.tina-tailwind .italic {
  font-style: italic;
}
.tina-tailwind .leading-5 {
  line-height: 20px;
}
.tina-tailwind .leading-normal {
  line-height: 1.5;
}
.tina-tailwind .leading-tight {
  line-height: 1.25;
}
.tina-tailwind .tracking-wide {
  letter-spacing: 0.025em;
}
.tina-tailwind .text-blue-500 {
  --tw-text-opacity: 1;
  color: rgb(0 132 255 / var(--tw-text-opacity));
}
.tina-tailwind .text-blue-600 {
  --tw-text-opacity: 1;
  color: rgb(5 116 228 / var(--tw-text-opacity));
}
.tina-tailwind .text-current {
  color: currentColor;
}
.tina-tailwind .text-gray-300 {
  --tw-text-opacity: 1;
  color: rgb(178 173 190 / var(--tw-text-opacity));
}
.tina-tailwind .text-gray-400 {
  --tw-text-opacity: 1;
  color: rgb(145 140 158 / var(--tw-text-opacity));
}
.tina-tailwind .text-gray-500 {
  --tw-text-opacity: 1;
  color: rgb(113 108 127 / var(--tw-text-opacity));
}
.tina-tailwind .text-gray-600 {
  --tw-text-opacity: 1;
  color: rgb(86 81 101 / var(--tw-text-opacity));
}
.tina-tailwind .text-gray-700 {
  --tw-text-opacity: 1;
  color: rgb(67 62 82 / var(--tw-text-opacity));
}
.tina-tailwind .text-gray-900 {
  --tw-text-opacity: 1;
  color: rgb(37 35 54 / var(--tw-text-opacity));
}
.tina-tailwind .text-red-400 {
  --tw-text-opacity: 1;
  color: rgb(248 113 113 / var(--tw-text-opacity));
}
.tina-tailwind .text-red-500 {
  --tw-text-opacity: 1;
  color: rgb(239 68 68 / var(--tw-text-opacity));
}
.tina-tailwind .text-white {
  --tw-text-opacity: 1;
  color: rgb(255 255 255 / var(--tw-text-opacity));
}
.tina-tailwind .underline {
  text-decoration-line: underline;
}
.tina-tailwind .opacity-0 {
  opacity: 0;
}
.tina-tailwind .opacity-100 {
  opacity: 1;
}
.tina-tailwind .opacity-20 {
  opacity: .2;
}
.tina-tailwind .opacity-50 {
  opacity: .5;
}
.tina-tailwind .opacity-70 {
  opacity: .7;
}
.tina-tailwind .opacity-80 {
  opacity: .8;
}
.tina-tailwind .opacity-90 {
  opacity: .9;
}
.tina-tailwind .shadow {
  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tina-tailwind .shadow-2xl {
  --tw-shadow: 0 25px 50px -12px rgb(0 0 0 / 0.25);
  --tw-shadow-colored: 0 25px 50px -12px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tina-tailwind .shadow-inner {
  --tw-shadow: inset 0 2px 4px 0 rgb(0 0 0 / 0.05);
  --tw-shadow-colored: inset 0 2px 4px 0 var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tina-tailwind .shadow-lg {
  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tina-tailwind .ring-1 {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.tina-tailwind .ring-black {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(0 0 0 / var(--tw-ring-opacity));
}
.tina-tailwind .ring-opacity-5 {
  --tw-ring-opacity: .05;
}
.tina-tailwind .filter {
  filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow);
}
.tina-tailwind .transition {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tina-tailwind .transition-all {
  transition-property: all;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tina-tailwind .transition-colors {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tina-tailwind .transition-opacity {
  transition-property: opacity;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}
.tina-tailwind .duration-100 {
  transition-duration: 100ms;
}
.tina-tailwind .duration-150 {
  transition-duration: 150ms;
}
.tina-tailwind .duration-200 {
  transition-duration: 200ms;
}
.tina-tailwind .duration-300 {
  transition-duration: 300ms;
}
.tina-tailwind .duration-75 {
  transition-duration: 75ms;
}
.tina-tailwind .ease-in {
  transition-timing-function: cubic-bezier(0.4, 0, 1, 1);
}
.tina-tailwind .ease-out {
  transition-timing-function: cubic-bezier(0, 0, 0.2, 1);
}
.tina-tailwind .icon-parent svg {
      fill: currentColor;
    }
.tina-tailwind {
  font-family: Inter, ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
  font-size: 16px;
  line-height: 1.5;
  --tw-text-opacity: 1;
  color: rgb(86 81 101 / var(--tw-text-opacity));
}
.tina-tailwind .hover\\:bg-blue-600:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(5 116 228 / var(--tw-bg-opacity));
}
.tina-tailwind .hover\\:text-blue-400:hover {
  --tw-text-opacity: 1;
  color: rgb(34 150 254 / var(--tw-text-opacity));
}
.tina-tailwind .hover\\:text-blue-600:hover {
  --tw-text-opacity: 1;
  color: rgb(5 116 228 / var(--tw-text-opacity));
}
.tina-tailwind .hover\\:opacity-100:hover {
  opacity: 1;
}
.tina-tailwind .hover\\:opacity-60:hover {
  opacity: .6;
}
.tina-tailwind .focus\\:border-blue-500:focus {
  --tw-border-opacity: 1;
  border-color: rgb(0 132 255 / var(--tw-border-opacity));
}
.tina-tailwind .focus\\:text-blue-400:focus {
  --tw-text-opacity: 1;
  color: rgb(34 150 254 / var(--tw-text-opacity));
}
.tina-tailwind .focus\\:text-gray-900:focus {
  --tw-text-opacity: 1;
  color: rgb(37 35 54 / var(--tw-text-opacity));
}
.tina-tailwind .focus\\:underline:focus {
  text-decoration-line: underline;
}
.tina-tailwind .focus\\:shadow-outline:focus {
  --tw-shadow: 0 0 0 3px rgba(66, 153, 225, 0.5);
  --tw-shadow-colored: 0 0 0 3px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}
.tina-tailwind .focus\\:outline-none:focus {
  outline: 2px solid transparent;
  outline-offset: 2px;
}
.tina-tailwind .focus\\:ring-2:focus {
  --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
  --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
  box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000);
}
.tina-tailwind .focus\\:ring-blue-500:focus {
  --tw-ring-opacity: 1;
  --tw-ring-color: rgb(0 132 255 / var(--tw-ring-opacity));
}
.tina-tailwind .group:hover .group-hover\\:border-gray-200 {
  --tw-border-opacity: 1;
  border-color: rgb(225 221 236 / var(--tw-border-opacity));
}
.tina-tailwind .group:hover .group-hover\\:bg-white {
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity));
}
.tina-tailwind .group:hover .group-hover\\:text-gray-600 {
  --tw-text-opacity: 1;
  color: rgb(86 81 101 / var(--tw-text-opacity));
}
.tina-tailwind .group:hover .group-hover\\:opacity-0 {
  opacity: 0;
}
.tina-tailwind .group:hover .group-hover\\:opacity-80 {
  opacity: .8;
}
.tina-tailwind .group:active .group-active\\:opacity-0 {
  opacity: 0;
}
.tina-tailwind .group:active .group-active\\:opacity-80 {
  opacity: .8;
}
`;
var ContentCreatorPlugin = class {
  constructor(options) {
    this.__type = "content-creator";
    this.fields = options.fields;
    this.name = options.label;
    this.onNewDocument = options.onNewDocument;
    this.collections = options.collections;
    this.onChange = options.onChange;
    this.initialValues = options.initialValues;
  }
  async onSubmit({ collection, template, relativePath }, cms) {
    try {
      const selectedCollection = this.collections.find((collectionItem) => collectionItem.slug === collection);
      const collectionFormat = selectedCollection.format;
      const extensionLength = -1 * (collectionFormat.length + 1);
      let relativePathWithExt = relativePath;
      if (relativePath.slice(extensionLength).toLocaleLowerCase() === `.${collectionFormat}`) {
        relativePathWithExt = `${relativePath.slice(0, -3)}.${collectionFormat}`;
      } else {
        relativePathWithExt = `${relativePath}.${collectionFormat}`;
      }
      const payload = {
        relativePath: relativePathWithExt,
        collection,
        template
      };
      try {
        const res = await cms.api.tina.addPendingContent(payload);
        if (res.errors) {
          res.errors.map((e9) => {
            cms.alerts.error(e9.message);
          });
        } else {
          cms.alerts.info("Document created!");
          if (typeof this.onNewDocument === "function") {
            this.onNewDocument(res.addPendingDocument._sys);
          }
        }
      } catch (e9) {
        cms.alerts.error(e9.message);
      }
    } catch (e9) {
      cms.alerts.error(e9.message);
    }
  }
};
var useDocumentCreatorPlugin = (args) => {
  const cms = useCMS();
  const [values3, setValues] = import_react120.default.useState({});
  const [plugin, setPlugin] = import_react120.default.useState(null);
  import_react120.default.useEffect(() => {
    const run = async () => {
      var _a;
      const res = await cms.api.tina.request((gql22) => gql22`
          {
            collections {
              label
              slug
              format
              templates
            }
          }
        `, { variables: {} });
      const allCollectionOptions = [];
      res.collections.forEach((collection) => {
        const value = collection.slug;
        const label = `${collection.label}`;
        allCollectionOptions.push({ value, label });
      });
      let collectionOptions;
      if (args && args.filterCollections && typeof args.filterCollections === "function") {
        const filtered = args.filterCollections(allCollectionOptions);
        collectionOptions = [
          { value: "", label: "Choose Collection" },
          ...filtered
        ];
      } else {
        collectionOptions = [
          { value: "", label: "Choose Collection" },
          ...allCollectionOptions
        ];
      }
      const templateOptions = [
        { value: "", label: "Choose Template" }
      ];
      if (values3.collection) {
        const filteredCollection = res.collections.find((c16) => c16.slug === values3.collection);
        (_a = filteredCollection == null ? void 0 : filteredCollection.templates) == null ? void 0 : _a.forEach((template) => {
          templateOptions.push({ value: template.name, label: template.label });
        });
      }
      setPlugin(new ContentCreatorPlugin({
        label: "Add Document",
        onNewDocument: args && args.onNewDocument,
        collections: res.collections,
        onChange: async ({ values: values22 }) => {
          setValues(values22);
        },
        initialValues: values3,
        fields: [
          {
            component: "select",
            name: "collection",
            label: "Collection",
            description: "Select the collection.",
            options: collectionOptions,
            validate: async (value, allValues, meta) => {
              if (!value) {
                return true;
              }
            }
          },
          {
            component: "select",
            name: "template",
            label: "Template",
            description: "Select the template.",
            options: templateOptions,
            validate: async (value, allValues, meta) => {
              if (!value && templateOptions.length > 1) {
                if (meta.dirty) {
                  return "Required";
                }
                return true;
              }
            }
          },
          {
            component: "text",
            name: "relativePath",
            label: "Name",
            description: `A unique name for the content. Example: "newPost" or "blog_022021`,
            placeholder: "newPost",
            validate: (value, allValues, meta) => {
              if (!value) {
                if (meta.dirty) {
                  return "Required";
                }
                return true;
              }
              const isValid4 = /^[_a-zA-Z0-9][\-_a-zA-Z0-9]*$/.test(value);
              if (value && !isValid4) {
                return "Must begin with a-z, A-Z, 0-9, or _ and contain only a-z, A-Z, 0-9, - or _";
              }
            }
          }
        ]
      }));
    };
    run();
  }, [cms]);
  import_react120.default.useEffect(() => {
    if (plugin) {
      cms.plugins.add(plugin);
    }
    return () => {
      if (plugin) {
        cms.plugins.remove(plugin);
      }
    };
  }, [plugin]);
};
var errorButtonStyles = {
  background: "#eb6337",
  padding: "12px 18px",
  cursor: "pointer",
  borderRadius: "50px",
  textTransform: "uppercase",
  letterSpacing: "2px",
  fontWeight: "bold",
  border: "none",
  color: "white",
  margin: "1rem 0"
};
var ErrorBoundary2 = class extends import_react120.default.Component {
  constructor(props) {
    super(props);
    this.state = {
      hasError: props.hasError,
      message: "",
      pageRefresh: false
    };
  }
  static getDerivedStateFromError(error2) {
    return { hasError: true, message: error2.message };
  }
  render() {
    const branchData = window.localStorage && window.localStorage.getItem("tinacms-current-branch");
    const hasBranchData = branchData && branchData.length > 0;
    if (this.state.hasError && !this.state.pageRefresh) {
      return import_react120.default.createElement("div", {
        style: {
          background: "#efefef",
          height: "100vh",
          display: "flex",
          alignItems: "center",
          justifyContent: "center"
        }
      }, import_react120.default.createElement("style", null, "            body {              margin: 0;            }          "), import_react120.default.createElement("div", {
        style: {
          background: "#fff",
          maxWidth: "400px",
          padding: "20px",
          fontFamily: "'Inter', sans-serif",
          borderRadius: "5px",
          boxShadow: "0 6px 24px rgb(0 37 91 / 5%), 0 2px 4px rgb(0 37 91 / 3%)"
        }
      }, import_react120.default.createElement("h3", {
        style: { color: "#eb6337" }
      }, "TinaCMS Render Error"), import_react120.default.createElement("p", null, "Tina caught an error while updating the page:"), import_react120.default.createElement("pre", {
        style: { marginTop: "1rem", overflowX: "auto" }
      }, this.state.message), import_react120.default.createElement("br", null), import_react120.default.createElement("p", null, `If you've just updated the form, undo your most recent changes and click "refresh". If after a few refreshes, you're still encountering this error. There is a bigger issue with the site. Please reach out to your site admin.`), import_react120.default.createElement("p", null, "See our", " ", import_react120.default.createElement("a", {
        className: "text-gray-600",
        style: { textDecoration: "underline" },
        href: "https://tina.io/docs/errors/faq/",
        target: "_blank"
      }, " ", "Error FAQ", " "), " ", "for more information."), import_react120.default.createElement("button", {
        style: errorButtonStyles,
        onClick: () => {
          this.setState({ pageRefresh: true });
          setTimeout(() => this.setState({ hasError: false, pageRefresh: false }), 3e3);
        }
      }, "Refresh"), hasBranchData && import_react120.default.createElement(import_react120.default.Fragment, null, import_react120.default.createElement("p", null, `If you're using the branch switcher, you may currently be on a "stale" branch that has been deleted or whose content is not compatible with the latest version of the site's layout. Click the button below to switch back to the default branch for this deployment.`), import_react120.default.createElement("p", null, "See our", " ", import_react120.default.createElement("a", {
        className: "text-gray-600",
        style: { textDecoration: "underline" },
        href: "https://tina.io/docs/errors/faq/",
        target: "_blank"
      }, " ", "Error FAQ", " "), " ", "for more information."), import_react120.default.createElement("button", {
        style: errorButtonStyles,
        onClick: () => {
          window.localStorage.removeItem("tinacms-current-branch");
          window.location.reload();
        }
      }, "Switch to default branch"))));
    }
    if (this.state.pageRefresh) {
      return import_react120.default.createElement(Loader, null, "Let's try that again.");
    }
    return this.props.children;
  }
};
var TinaCMSProvider2 = ({
  query,
  documentCreatorCallback,
  formifyCallback,
  schema,
  ...props
}) => {
  var _a, _b, _c, _d, _e4;
  if (props == null ? void 0 : props.apiURL) {
    console.warn("The apiURL prop is deprecated. Please see https://tina.io/blog/tina-v-0.68.14 for information on how to upgrade to the new API");
  }
  const apiURL = ((_a = props == null ? void 0 : props.client) == null ? void 0 : _a.apiUrl) || (props == null ? void 0 : props.apiURL);
  const isLocalOverride = (_d = (_c = (_b = schema == null ? void 0 : schema.config) == null ? void 0 : _b.admin) == null ? void 0 : _c.auth) == null ? void 0 : _d.useLocalAuth;
  const { branch, clientId, isLocalClient } = apiURL ? parseURL(apiURL) : {
    branch: props.branch,
    clientId: props.clientId,
    isLocalClient: props == null ? void 0 : props.isLocalClient
  };
  if (typeof isLocalClient === "undefined" || !isLocalClient && (!branch || !clientId) && !schema.config.contentApiUrlOverride) {
    throw new Error("Invalid setup. See https://tina.io/docs/tina-cloud/connecting-site/ for more information.");
  }
  if (!schema) {
    throw new Error("`schema` is required to be passed as a property to `TinaProvider`.  You can learn more about this change here: https://github.com/tinacms/tinacms/pull/2823");
  }
  return import_react120.default.createElement(import_react120.default.Fragment, null, import_react120.default.createElement(TinaCloudProvider, {
    branch,
    clientId: clientId || ((_e4 = schema == null ? void 0 : schema.config) == null ? void 0 : _e4.clientId),
    tinaioConfig: props.tinaioConfig,
    isLocalClient: isLocalOverride || isLocalClient,
    cmsCallback: props.cmsCallback,
    mediaStore: props.mediaStore,
    apiUrl: apiURL,
    schema: { ...schema, config: { ...schema.config, ...props } },
    tinaGraphQLVersion: props.tinaGraphQLVersion
  }, import_react120.default.createElement("style", null, styles4), import_react120.default.createElement(ErrorBoundary2, null, props.children)));
};
var Loader = (props) => {
  return import_react120.default.createElement(import_react120.default.Fragment, null, import_react120.default.createElement("div", {
    style: {
      position: "fixed",
      background: "rgba(0, 0, 0, 0.5)",
      inset: 0,
      zIndex: 200,
      opacity: "0.8",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      padding: "40px"
    }
  }, import_react120.default.createElement("div", {
    style: {
      background: "#f6f6f9",
      boxShadow: "0px 2px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.1)",
      borderRadius: "5px",
      padding: "40px 32px",
      width: "460px",
      maxWidth: "90%",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      flexDirection: "column"
    }
  }, import_react120.default.createElement("svg", {
    style: {
      width: "64px",
      color: "#2296fe",
      marginTop: "-8px",
      marginBottom: "16px"
    },
    version: "1.1",
    id: "L5",
    xmlns: "http://www.w3.org/2000/svg",
    xmlnsXlink: "http://www.w3.org/1999/xlink",
    x: "0px",
    y: "0px",
    viewBox: "0 0 100 64",
    enableBackground: "new 0 0 0 0",
    xmlSpace: "preserve"
  }, import_react120.default.createElement("circle", {
    fill: "currentColor",
    stroke: "none",
    cx: 6,
    cy: 32,
    r: 6
  }, import_react120.default.createElement("animateTransform", {
    attributeName: "transform",
    dur: "1s",
    type: "translate",
    values: "0 15 ; 0 -15; 0 15",
    calcMode: "spline",
    keySplines: "0.8 0 0.4 1; 0.4 0 0.2 1",
    repeatCount: "indefinite",
    begin: "0.1"
  })), import_react120.default.createElement("circle", {
    fill: "currentColor",
    stroke: "none",
    cx: 30,
    cy: 32,
    r: 6
  }, import_react120.default.createElement("animateTransform", {
    attributeName: "transform",
    dur: "1s",
    type: "translate",
    values: "0 15 ; 0 -10; 0 15",
    calcMode: "spline",
    keySplines: "0.8 0 0.4 1; 0.4 0 0.2 1",
    repeatCount: "indefinite",
    begin: "0.2"
  })), import_react120.default.createElement("circle", {
    fill: "currentColor",
    stroke: "none",
    cx: 54,
    cy: 32,
    r: 6
  }, import_react120.default.createElement("animateTransform", {
    attributeName: "transform",
    dur: "1s",
    type: "translate",
    values: "0 15 ; 0 -5; 0 15",
    calcMode: "spline",
    keySplines: "0.8 0 0.4 1; 0.4 0 0.2 1",
    repeatCount: "indefinite",
    begin: "0.3"
  }))), import_react120.default.createElement("p", {
    style: {
      fontSize: "18px",
      color: "#252336",
      textAlign: "center",
      lineHeight: "1.3",
      fontFamily: "'Inter', sans-serif",
      fontWeight: "normal"
    }
  }, "Please wait, Tina is loading data..."))), props.children);
};
var getStaticPropsForTina = async ({
  query,
  variables
}) => {
  try {
    const data = await staticRequest({ query, variables });
    return JSON.parse(JSON.stringify({
      data,
      query,
      variables
    }));
  } catch (e9) {
    return JSON.parse(JSON.stringify({
      data: {},
      query,
      variables
    }));
  }
};
function is_server() {
  return !(typeof window != "undefined" && window.document);
}
var staticRequest = async ({
  query,
  variables
}) => {
  const client = new LocalClient();
  if (!is_server()) {
    console.warn(`Whoops! Looks like you are using \`staticRequest\` in the browser to fetch data.

The local server is not available outside of \`getStaticProps\` or \`getStaticPaths\` functions.
This function should only be called on the server at build time.

This will work when developing locally but NOT when deployed to production.
`);
  }
  return client.request(query, { variables });
};
function gql2(strings, ...args) {
  let str = "";
  strings.forEach((string2, i15) => {
    str += string2 + (args[i15] || "");
  });
  return str;
}
var Layout = ({ children }) => {
  return import_react120.default.createElement(import_react120.default.Fragment, null, import_react120.default.createElement("style", null, styles4), import_react120.default.createElement("div", {
    className: "tina-tailwind",
    style: {
      position: "fixed",
      top: 0,
      left: 0,
      width: "100%",
      height: "100%",
      overflow: "auto",
      background: "#F6F6F9",
      fontFamily: "'Inter', sans-serif",
      zIndex: 9999
    }
  }, children));
};
var DefaultContext2 = {
  color: void 0,
  size: void 0,
  className: void 0,
  style: void 0,
  attr: void 0
};
var IconContext2 = import_react120.default.createContext && import_react120.default.createContext(DefaultContext2);
var __assign6 = globalThis && globalThis.__assign || function() {
  __assign6 = Object.assign || function(t20) {
    for (var s20, i15 = 1, n12 = arguments.length; i15 < n12; i15++) {
      s20 = arguments[i15];
      for (var p12 in s20)
        if (Object.prototype.hasOwnProperty.call(s20, p12))
          t20[p12] = s20[p12];
    }
    return t20;
  };
  return __assign6.apply(this, arguments);
};
var __rest2 = globalThis && globalThis.__rest || function(s20, e9) {
  var t20 = {};
  for (var p12 in s20)
    if (Object.prototype.hasOwnProperty.call(s20, p12) && e9.indexOf(p12) < 0)
      t20[p12] = s20[p12];
  if (s20 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i15 = 0, p12 = Object.getOwnPropertySymbols(s20); i15 < p12.length; i15++) {
      if (e9.indexOf(p12[i15]) < 0 && Object.prototype.propertyIsEnumerable.call(s20, p12[i15]))
        t20[p12[i15]] = s20[p12[i15]];
    }
  return t20;
};
function Tree2Element2(tree) {
  return tree && tree.map(function(node, i15) {
    return import_react120.default.createElement(node.tag, __assign6({
      key: i15
    }, node.attr), Tree2Element2(node.child));
  });
}
function GenIcon2(data) {
  return function(props) {
    return import_react120.default.createElement(IconBase2, __assign6({
      attr: __assign6({}, data.attr)
    }, props), Tree2Element2(data.child));
  };
}
function IconBase2(props) {
  var elem = function(conf) {
    var attr = props.attr, size2 = props.size, title = props.title, svgProps = __rest2(props, ["attr", "size", "title"]);
    var computedSize = size2 || conf.size || "1em";
    var className;
    if (conf.className)
      className = conf.className;
    if (props.className)
      className = (className ? className + " " : "") + props.className;
    return import_react120.default.createElement("svg", __assign6({
      stroke: "currentColor",
      fill: "currentColor",
      strokeWidth: "0"
    }, conf.attr, attr, svgProps, {
      className,
      style: __assign6(__assign6({
        color: props.color || conf.color
      }, conf.style), props.style),
      height: computedSize,
      width: computedSize,
      xmlns: "http://www.w3.org/2000/svg"
    }), title && import_react120.default.createElement("title", null, title), props.children);
  };
  return IconContext2 !== void 0 ? import_react120.default.createElement(IconContext2.Consumer, null, function(conf) {
    return elem(conf);
  }) : elem(DefaultContext2);
}
function ImFilesEmpty2(props) {
  return GenIcon2({ "tag": "svg", "attr": { "version": "1.1", "viewBox": "0 0 16 16" }, "child": [{ "tag": "path", "attr": { "d": "M14.341 5.579c-0.347-0.473-0.831-1.027-1.362-1.558s-1.085-1.015-1.558-1.362c-0.806-0.591-1.197-0.659-1.421-0.659h-5.75c-0.689 0-1.25 0.561-1.25 1.25v11.5c0 0.689 0.561 1.25 1.25 1.25h9.5c0.689 0 1.25-0.561 1.25-1.25v-7.75c0-0.224-0.068-0.615-0.659-1.421zM12.271 4.729c0.48 0.48 0.856 0.912 1.134 1.271h-2.406v-2.405c0.359 0.278 0.792 0.654 1.271 1.134v0zM14 14.75c0 0.136-0.114 0.25-0.25 0.25h-9.5c-0.136 0-0.25-0.114-0.25-0.25v-11.5c0-0.135 0.114-0.25 0.25-0.25 0 0 5.749-0 5.75 0v3.5c0 0.276 0.224 0.5 0.5 0.5h3.5v7.75z" } }, { "tag": "path", "attr": { "d": "M9.421 0.659c-0.806-0.591-1.197-0.659-1.421-0.659h-5.75c-0.689 0-1.25 0.561-1.25 1.25v11.5c0 0.604 0.43 1.109 1 1.225v-12.725c0-0.135 0.115-0.25 0.25-0.25h7.607c-0.151-0.124-0.297-0.238-0.437-0.341z" } }] })(props);
}
var useGetCollections = (cms) => {
  const api = new TinaAdminApi(cms);
  return { collections: api.fetchCollections() };
};
function IoMdClose2(props) {
  return GenIcon2({ "tag": "svg", "attr": { "viewBox": "0 0 512 512" }, "child": [{ "tag": "path", "attr": { "d": "M405 136.798L375.202 107 256 226.202 136.798 107 107 136.798 226.202 256 107 375.202 136.798 405 256 285.798 375.202 405 405 375.202 285.798 256z" } }] })(props);
}
function BiEdit2(props) {
  return GenIcon2({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "m7 17.013 4.413-.015 9.632-9.54c.378-.378.586-.88.586-1.414s-.208-1.036-.586-1.414l-1.586-1.586c-.756-.756-2.075-.752-2.825-.003L7 12.583v4.43zM18.045 4.458l1.589 1.583-1.597 1.582-1.586-1.585 1.594-1.58zM9 13.417l6.03-5.973 1.586 1.586-6.029 5.971L9 15.006v-1.589z" } }, { "tag": "path", "attr": { "d": "M5 21h14c1.103 0 2-.897 2-2v-8.668l-2 2V19H8.158c-.026 0-.053.01-.079.01-.033 0-.066-.009-.1-.01H5V5h6.847l2-2H5c-1.103 0-2 .897-2 2v14c0 1.103.897 2 2 2z" } }] })(props);
}
function BiError2(props) {
  return GenIcon2({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M11.001 10h2v5h-2zM11 16h2v2h-2z" } }, { "tag": "path", "attr": { "d": "M13.768 4.2C13.42 3.545 12.742 3.138 12 3.138s-1.42.407-1.768 1.063L2.894 18.064a1.986 1.986 0 0 0 .054 1.968A1.984 1.984 0 0 0 4.661 21h14.678c.708 0 1.349-.362 1.714-.968a1.989 1.989 0 0 0 .054-1.968L13.768 4.2zM4.661 19 12 5.137 19.344 19H4.661z" } }] })(props);
}
function BiLogIn(props) {
  return GenIcon2({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "m13 16 5-4-5-4v3H4v2h9z" } }, { "tag": "path", "attr": { "d": "M20 3h-9c-1.103 0-2 .897-2 2v4h2V5h9v14h-9v-4H9v4c0 1.103.897 2 2 2h9c1.103 0 2-.897 2-2V5c0-1.103-.897-2-2-2z" } }] })(props);
}
function BiLogOut(props) {
  return GenIcon2({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M16 13v-2H7V8l-5 4 5 4v-3z" } }, { "tag": "path", "attr": { "d": "M20 3h-9c-1.103 0-2 .897-2 2v4h2V5h9v14h-9v-4H9v4c0 1.103.897 2 2 2h9c1.103 0 2-.897 2-2V5c0-1.103-.897-2-2-2z" } }] })(props);
}
function BiMenu2(props) {
  return GenIcon2({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M4 6h16v2H4zm0 5h16v2H4zm0 5h16v2H4z" } }] })(props);
}
function BiPlus2(props) {
  return GenIcon2({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M19 11h-6V5h-2v6H5v2h6v6h2v-6h6z" } }] })(props);
}
function BiRename(props) {
  return GenIcon2({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M20.005 5.995h-1v2h1v8h-1v2h1c1.103 0 2-.897 2-2v-8c0-1.102-.898-2-2-2zm-14 4H15v4H6.005z" } }, { "tag": "path", "attr": { "d": "M17.005 17.995V4H20V2h-8v2h3.005v1.995h-11c-1.103 0-2 .897-2 2v8c0 1.103.897 2 2 2h11V20H12v2h8v-2h-2.995v-2.005zm-13-2v-8h11v8h-11z" } }] })(props);
}
function BiSearch2(props) {
  return GenIcon2({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M10 18a7.952 7.952 0 0 0 4.897-1.688l4.396 4.396 1.414-1.414-4.396-4.396A7.952 7.952 0 0 0 18 10c0-4.411-3.589-8-8-8s-8 3.589-8 8 3.589 8 8 8zm0-14c3.309 0 6 2.691 6 6s-2.691 6-6 6-6-2.691-6-6 2.691-6 6-6z" } }] })(props);
}
function BiSync(props) {
  return GenIcon2({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "m13 7.101.01.001a4.978 4.978 0 0 1 2.526 1.362 5.005 5.005 0 0 1 1.363 2.528 5.061 5.061 0 0 1-.001 2.016 4.976 4.976 0 0 1-1.363 2.527l1.414 1.414a7.014 7.014 0 0 0 1.908-3.54 6.98 6.98 0 0 0 0-2.819 6.957 6.957 0 0 0-1.907-3.539 6.97 6.97 0 0 0-2.223-1.5 6.921 6.921 0 0 0-1.315-.408c-.137-.028-.275-.043-.412-.063V2L9 6l4 4V7.101zm-7.45 7.623c.174.412.392.812.646 1.19.249.37.537.718.854 1.034a7.036 7.036 0 0 0 2.224 1.501c.425.18.868.317 1.315.408.167.034.338.056.508.078v2.944l4-4-4-4v3.03c-.035-.006-.072-.003-.107-.011a4.978 4.978 0 0 1-2.526-1.362 4.994 4.994 0 0 1 .001-7.071L7.051 7.05a7.01 7.01 0 0 0-1.5 2.224A6.974 6.974 0 0 0 5 12a6.997 6.997 0 0 0 .55 2.724z" } }] })(props);
}
function BiTrash(props) {
  return GenIcon2({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "M5 20a2 2 0 0 0 2 2h10a2 2 0 0 0 2-2V8h2V6h-4V4a2 2 0 0 0-2-2H9a2 2 0 0 0-2 2v2H3v2h2zM9 4h6v2H9zM8 8h9v12H7V8z" } }, { "tag": "path", "attr": { "d": "M9 10h2v8H9zm4 0h2v8h-2z" } }] })(props);
}
function BiX2(props) {
  return GenIcon2({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "d": "m16.192 6.344-4.243 4.242-4.242-4.242-1.414 1.414L10.535 12l-4.242 4.242 1.414 1.414 4.242-4.242 4.243 4.242 1.414-1.414L13.364 12l4.242-4.242z" } }] })(props);
}
var slugify = (text) => {
  return text.toString().toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "_").replace(/^-+|-+$/g, "");
};
var Sidebar2 = ({ cms }) => {
  var _a, _b;
  const collectionsInfo = useGetCollections(cms);
  const screens = cms.plugins.getType("screen").all();
  const cloudConfigs = cms.plugins.getType("cloud-config").all();
  const [menuIsOpen, setMenuIsOpen] = import_react120.default.useState(false);
  const isLocalMode = (_b = (_a = cms.api) == null ? void 0 : _a.tina) == null ? void 0 : _b.isLocalMode;
  const navBreakpoint2 = 1e3;
  const windowWidth = useWindowWidth();
  const renderDesktopNav = windowWidth > navBreakpoint2;
  return import_react120.default.createElement(import_react120.default.Fragment, null, renderDesktopNav && import_react120.default.createElement(Nav, {
    isLocalMode,
    sidebarWidth: 360,
    showCollections: true,
    collectionsInfo,
    screens,
    cloudConfigs,
    contentCreators: [],
    RenderNavSite: ({ view }) => import_react120.default.createElement(SidebarLink, {
      label: view.name,
      to: `/screens/${slugify(view.name)}`,
      Icon: view.Icon ? view.Icon : ImFilesEmpty2
    }),
    RenderNavCloud: ({ config: config2 }) => import_react120.default.createElement(SidebarCloudLink2, {
      config: config2
    }),
    RenderNavCollection: ({ collection }) => import_react120.default.createElement(SidebarLink, {
      label: collection.label ? collection.label : collection.name,
      to: `/collections/${collection.name}`,
      Icon: ImFilesEmpty2
    })
  }), !renderDesktopNav && import_react120.default.createElement(tt2, {
    show: menuIsOpen
  }, import_react120.default.createElement(tt2.Child, {
    as: import_react120.default.Fragment,
    enter: "transform transition-all ease-out duration-300",
    enterFrom: "opacity-0 -translate-x-full",
    enterTo: "opacity-100 translate-x-0",
    leave: "transform transition-all ease-in duration-200",
    leaveFrom: "opacity-100 translate-x-0",
    leaveTo: "opacity-0 -translate-x-full"
  }, import_react120.default.createElement("div", {
    className: "fixed left-0 top-0 z-overlay h-full transform"
  }, import_react120.default.createElement(Nav, {
    isLocalMode,
    className: "rounded-r-md",
    sidebarWidth: 360,
    showCollections: true,
    collectionsInfo,
    screens,
    cloudConfigs,
    contentCreators: [],
    RenderNavSite: ({ view }) => import_react120.default.createElement(SidebarLink, {
      label: view.name,
      to: `/screens/${slugify(view.name)}`,
      Icon: view.Icon ? view.Icon : ImFilesEmpty2,
      onClick: () => {
        setMenuIsOpen(false);
      }
    }),
    RenderNavCloud: ({ config: config2 }) => import_react120.default.createElement(SidebarCloudLink2, {
      config: config2
    }),
    RenderNavCollection: ({ collection }) => import_react120.default.createElement(SidebarLink, {
      label: collection.label ? collection.label : collection.name,
      to: `/collections/${collection.name}`,
      Icon: ImFilesEmpty2,
      onClick: () => {
        setMenuIsOpen(false);
      }
    })
  }, import_react120.default.createElement("div", {
    className: "absolute top-8 right-0 transform translate-x-full overflow-hidden"
  }, import_react120.default.createElement(Button, {
    rounded: "right",
    variant: "secondary",
    onClick: () => {
      setMenuIsOpen(false);
    },
    className: `transition-opacity duration-150 ease-out`
  }, import_react120.default.createElement(IoMdClose2, {
    className: "h-6 w-auto"
  })))))), import_react120.default.createElement(tt2.Child, {
    as: import_react120.default.Fragment,
    enter: "ease-out duration-300",
    enterFrom: "opacity-0",
    enterTo: "opacity-80",
    entered: "opacity-80",
    leave: "ease-in duration-200",
    leaveFrom: "opacity-80",
    leaveTo: "opacity-0"
  }, import_react120.default.createElement("div", {
    onClick: () => {
      setMenuIsOpen(false);
    },
    className: "fixed z-menu inset-0 bg-gradient-to-br from-gray-800 via-gray-900 to-black"
  }))), !renderDesktopNav && import_react120.default.createElement(Button, {
    rounded: "right",
    variant: "secondary",
    onClick: () => {
      setMenuIsOpen(true);
    },
    className: `pointer-events-auto -ml-px absolute left-0 z-50 ${isLocalMode ? `top-10` : `top-4`}`
  }, import_react120.default.createElement(BiMenu2, {
    className: "h-7 w-auto"
  })));
};
var SidebarLink = (props) => {
  const { to: to4, label, Icon } = props;
  return import_react120.default.createElement(NavLink, {
    className: ({ isActive }) => {
      return `text-base tracking-wide ${isActive ? "text-blue-600" : "text-gray-500"} hover:text-blue-600 flex items-center opacity-90 hover:opacity-100`;
    },
    onClick: props.onClick ? props.onClick : () => {
    },
    to: to4
  }, import_react120.default.createElement(Icon, {
    className: "mr-2 h-6 opacity-80 w-auto"
  }), " ", label);
};
var SidebarCloudLink2 = ({ config: config2 }) => {
  if (config2.text) {
    return import_react120.default.createElement("span", {
      className: "text-base tracking-wide text-gray-500 flex items-center opacity-90"
    }, config2.text, " ", import_react120.default.createElement("a", {
      target: "_blank",
      className: "ml-1 text-blue-600 hover:opacity-60",
      href: config2.link.href
    }, config2.link.text));
  }
  return import_react120.default.createElement("span", {
    className: "text-base tracking-wide text-gray-500 hover:text-blue-600 flex items-center opacity-90 hover:opacity-100"
  }, import_react120.default.createElement(config2.Icon, {
    className: "mr-2 h-6 opacity-80 w-auto"
  }), import_react120.default.createElement("a", {
    target: "_blank",
    href: config2.link.href
  }, config2.link.text));
};
var GetCMS = ({ children }) => {
  try {
    const cms = useCMS();
    return import_react120.default.createElement(import_react120.default.Fragment, null, children(cms));
  } catch (e9) {
    return null;
  }
};
function MdOutlineArrowBack(props) {
  return GenIcon2({ "tag": "svg", "attr": { "viewBox": "0 0 24 24" }, "child": [{ "tag": "path", "attr": { "fill": "none", "d": "M0 0h24v24H0V0z" } }, { "tag": "path", "attr": { "d": "M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z" } }] })(props);
}
var AuthTemplate = ({
  message,
  children
}) => {
  return import_react120.default.createElement("div", {
    className: "h-screen w-full bg-gradient-to-b from-blue-900 to-gray-900 flex items-center justify-center px-4 py-6"
  }, import_react120.default.createElement("div", {
    className: "bg-white rounded-lg overflow-hidden shadow-lg w-full max-w-lg"
  }, import_react120.default.createElement("div", {
    className: "px-5 py-4 border-b border-gray-150"
  }, import_react120.default.createElement("h2", {
    className: "text-2xl font-sans tracking-wide text-gray-700 flex items-center gap-0.5"
  }, import_react120.default.createElement("svg", {
    viewBox: "0 0 32 32",
    fill: "#EC4815",
    xmlns: "http://www.w3.org/2000/svg",
    className: "w-10 h-auto"
  }, import_react120.default.createElement("path", {
    d: "M18.6466 14.5553C19.9018 13.5141 20.458 7.36086 21.0014 5.14903C21.5447 2.9372 23.7919 3.04938 23.7919 3.04938C23.7919 3.04938 23.2085 4.06764 23.4464 4.82751C23.6844 5.58738 25.3145 6.26662 25.3145 6.26662L24.9629 7.19622C24.9629 7.19622 24.2288 7.10204 23.7919 7.9785C23.355 8.85496 24.3392 17.4442 24.3392 17.4442C24.3392 17.4442 21.4469 22.7275 21.4469 24.9206C21.4469 27.1136 22.4819 28.9515 22.4819 28.9515H21.0296C21.0296 28.9515 18.899 26.4086 18.462 25.1378C18.0251 23.8669 18.1998 22.596 18.1998 22.596C18.1998 22.596 15.8839 22.4646 13.8303 22.596C11.7767 22.7275 10.4072 24.498 10.16 25.4884C9.91287 26.4787 9.81048 28.9515 9.81048 28.9515H8.66211C7.96315 26.7882 7.40803 26.0129 7.70918 24.9206C8.54334 21.8949 8.37949 20.1788 8.18635 19.4145C7.99321 18.6501 6.68552 17.983 6.68552 17.983C7.32609 16.6741 7.97996 16.0452 10.7926 15.9796C13.6052 15.914 17.3915 15.5965 18.6466 14.5553Z"
  }), import_react120.default.createElement("path", {
    d: "M11.1268 24.7939C11.1268 24.7939 11.4236 27.5481 13.0001 28.9516H14.3511C13.0001 27.4166 12.8527 23.4155 12.8527 23.4155C12.1656 23.6399 11.3045 24.3846 11.1268 24.7939Z"
  })), import_react120.default.createElement("span", null, "Tina"))), message && import_react120.default.createElement("div", {
    className: "px-5 pt-4"
  }, import_react120.default.createElement("p", {
    className: "text-base font-sans leading-normal"
  }, message)), import_react120.default.createElement("div", {
    className: "px-5 py-4 flex gap-4 w-full justify-between"
  }, children)));
};
var LoginPage = () => {
  const { setEdit } = useEditState();
  const login = () => setEdit(true);
  return import_react120.default.createElement(AuthTemplate, null, import_react120.default.createElement("div", {
    className: "flex w-full flex-1 gap-4 items-center justify-end"
  }, import_react120.default.createElement(Button, {
    onClick: () => {
      window.location.href = "/";
    },
    variant: "white",
    size: "custom",
    className: "text-base h-12 px-6 flex-shrink-0 flex-grow-0"
  }, import_react120.default.createElement(MdOutlineArrowBack, {
    className: "w-6 h-auto mr-1.5 opacity-80"
  }), " Back To Site"), import_react120.default.createElement(Button, {
    onClick: () => login(),
    variant: "primary",
    size: "custom",
    className: "text-base h-12 px-6 flex-1",
    type: "submit"
  }, import_react120.default.createElement(BiLogIn, {
    className: "w-6 h-auto mr-2 opacity-80"
  }), " Edit With Tina")));
};
var LogoutRedirect = () => {
  const cms = useCMS();
  const { setEdit } = useEditState();
  const [searchParams] = useSearchParams();
  const slug = searchParams.get("slug") || "/";
  const logout2 = async () => {
    var _a, _b, _c, _d, _e4, _f;
    if ((_b = (_a = cms == null ? void 0 : cms.api) == null ? void 0 : _a.tina) == null ? void 0 : _b.logout) {
      await cms.api.tina.logout();
      if ((_d = (_c = cms == null ? void 0 : cms.api) == null ? void 0 : _c.tina) == null ? void 0 : _d.onLogout) {
        await ((_f = (_e4 = cms == null ? void 0 : cms.api) == null ? void 0 : _e4.tina) == null ? void 0 : _f.onLogout());
      }
    }
    setEdit(false);
  };
  (0, import_react120.useEffect)(() => {
    logout2().then(() => {
      window.location.href = slug;
    });
  }, []);
  return import_react120.default.createElement("div", null, "Redirecting to ", slug, " ...");
};
var logout = () => {
  setEditing(false);
  window.location.href = "/";
};
var LogoutPage = () => {
  return import_react120.default.createElement(AuthTemplate, null, import_react120.default.createElement("div", {
    className: "flex w-full flex-1 gap-4 items-center justify-end"
  }, import_react120.default.createElement(Button, {
    onClick: () => {
      window.location.href = "/";
    },
    variant: "white",
    size: "custom",
    className: "text-base h-12 px-6 flex-shrink-0 flex-grow-0"
  }, import_react120.default.createElement(MdOutlineArrowBack, {
    className: "w-6 h-auto mr-1.5 opacity-80"
  }), " Back To Site"), import_react120.default.createElement(Button, {
    onClick: () => logout(),
    type: "submit",
    variant: "primary",
    size: "custom",
    className: "text-base h-12 px-6 flex-1"
  }, import_react120.default.createElement(BiLogOut, {
    className: "w-6 h-auto mr-1.5 opacity-80"
  }), " Log Out of Tina")));
};
var PageWrapper = ({
  children
}) => {
  var _a, _b;
  const cms = useCMS();
  const isLocalMode = (_b = (_a = cms.api) == null ? void 0 : _a.tina) == null ? void 0 : _b.isLocalMode;
  const [branchingEnabled, setBranchingEnabled] = import_react120.default.useState(() => cms.flags.get("branch-switcher"));
  import_react120.default.useEffect(() => {
    cms.events.subscribe("flag:set", ({ key, value }) => {
      if (key === "branch-switcher") {
        setBranchingEnabled(value);
      }
    });
  }, [cms.events]);
  return import_react120.default.createElement("div", {
    className: "relative left-0 w-full h-full bg-gradient-to-b from-gray-50/50 to-gray-50 shadow-2xl overflow-y-auto transition-opacity duration-300 ease-out flex flex-col opacity-100"
  }, branchingEnabled && !isLocalMode && import_react120.default.createElement(BranchBanner, null), children);
};
var PageHeader = ({
  isLocalMode,
  children
}) => {
  return import_react120.default.createElement(import_react120.default.Fragment, null, isLocalMode && import_react120.default.createElement(LocalWarning, null), !isLocalMode && import_react120.default.createElement(BillingWarning, null), import_react120.default.createElement("div", {
    className: "pt-12 px-12"
  }, import_react120.default.createElement("div", {
    className: "w-full mx-auto max-w-screen-xl"
  }, import_react120.default.createElement("div", {
    className: "w-full flex justify-between items-end"
  }, children))));
};
var PageBody = ({
  children
}) => import_react120.default.createElement("div", {
  className: "py-8 px-12"
}, children);
var PageBodyNarrow = ({
  children
}) => import_react120.default.createElement("div", {
  className: "py-10 px-12"
}, import_react120.default.createElement("div", {
  className: "w-full mx-auto max-w-screen-xl"
}, children));
var DashboardPage = () => {
  return import_react120.default.createElement(GetCMS, null, (cms) => {
    var _a, _b;
    return import_react120.default.createElement(PageWrapper, null, import_react120.default.createElement(import_react120.default.Fragment, null, import_react120.default.createElement(PageHeader, {
      isLocalMode: (_b = (_a = cms.api) == null ? void 0 : _a.tina) == null ? void 0 : _b.isLocalMode
    }, import_react120.default.createElement("h3", {
      className: "text-2xl font-sans text-gray-700"
    }, "Welcome to Tina!")), import_react120.default.createElement(PageBodyNarrow, null, "This is your dashboard for editing or creating content. Select a collection on the left to begin.")));
  });
};
var LoadingPage = () => import_react120.default.createElement(import_react120.default.Fragment, null, import_react120.default.createElement("div", {
  style: {
    position: "absolute",
    top: 0,
    left: 0,
    width: "100%",
    height: "100%",
    zIndex: 200,
    opacity: "0.8",
    display: "flex",
    alignItems: "start",
    justifyContent: "center",
    padding: "120px 40px 40px 40px"
  }
}, import_react120.default.createElement("div", {
  style: {
    background: "#FFF",
    border: "1px solid #EDECF3",
    boxShadow: "0px 2px 3px rgba(0, 0, 0, 0.05), 0 4px 12px rgba(0, 0, 0, 0.1)",
    borderRadius: "8px",
    padding: "32px 24px",
    width: "460px",
    maxWidth: "90%",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    flexDirection: "column"
  }
}, import_react120.default.createElement("svg", {
  style: {
    width: "64px",
    color: "#2296fe",
    marginTop: "-8px",
    marginBottom: "16px"
  },
  version: "1.1",
  id: "L5",
  xmlns: "http://www.w3.org/2000/svg",
  xmlnsXlink: "http://www.w3.org/1999/xlink",
  x: "0px",
  y: "0px",
  viewBox: "0 0 100 64",
  enableBackground: "new 0 0 0 0",
  xmlSpace: "preserve"
}, import_react120.default.createElement("circle", {
  fill: "currentColor",
  stroke: "none",
  cx: 6,
  cy: 32,
  r: 6
}, import_react120.default.createElement("animateTransform", {
  attributeName: "transform",
  dur: "1s",
  type: "translate",
  values: "0 15 ; 0 -15; 0 15",
  calcMode: "spline",
  keySplines: "0.8 0 0.4 1; 0.4 0 0.2 1",
  repeatCount: "indefinite",
  begin: "0.1"
})), import_react120.default.createElement("circle", {
  fill: "currentColor",
  stroke: "none",
  cx: 30,
  cy: 32,
  r: 6
}, import_react120.default.createElement("animateTransform", {
  attributeName: "transform",
  dur: "1s",
  type: "translate",
  values: "0 15 ; 0 -10; 0 15",
  calcMode: "spline",
  keySplines: "0.8 0 0.4 1; 0.4 0 0.2 1",
  repeatCount: "indefinite",
  begin: "0.2"
})), import_react120.default.createElement("circle", {
  fill: "currentColor",
  stroke: "none",
  cx: 54,
  cy: 32,
  r: 6
}, import_react120.default.createElement("animateTransform", {
  attributeName: "transform",
  dur: "1s",
  type: "translate",
  values: "0 15 ; 0 -5; 0 15",
  calcMode: "spline",
  keySplines: "0.8 0 0.4 1; 0.4 0 0.2 1",
  repeatCount: "indefinite",
  begin: "0.3"
}))), import_react120.default.createElement("p", {
  style: {
    fontSize: "16px",
    color: "#716c7f",
    textAlign: "center",
    lineHeight: "1.3",
    fontFamily: "'Inter', sans-serif",
    fontWeight: "normal"
  }
}, "Please wait, Tina is loading data..."))));
var FullscreenError = ({
  title = "Error",
  errorMessage = "It looks like something went wrong."
}) => {
  return import_react120.default.createElement("div", {
    className: "flex flex-col justify-center items-center h-screen bg-gray-100"
  }, import_react120.default.createElement("div", {
    className: "text-red-500 text-4xl mb-6 flex items-center"
  }, import_react120.default.createElement(BiError2, {
    className: "w-12 h-auto fill-current text-red-400 opacity-70 mr-1"
  }), " ", title), import_react120.default.createElement("p", {
    className: "text-gray-700 text-xl mb-8"
  }, errorMessage), import_react120.default.createElement(Button, {
    variant: "danger",
    onClick: () => window.location.reload()
  }, import_react120.default.createElement(BiSync, {
    className: "w-7 h-auto fill-current opacity-70 mr-1"
  }), " Reload"));
};
var useGetCollection = (cms, collectionName, includeDocuments = true, after = "", sortKey, filterArgs) => {
  const api = new TinaAdminApi(cms);
  const schema = cms.api.tina.schema;
  const collectionExtra = schema.getCollection(collectionName);
  const [collection, setCollection] = (0, import_react120.useState)(void 0);
  const [loading, setLoading] = (0, import_react120.useState)(true);
  const [error2, setError] = (0, import_react120.useState)(void 0);
  const [resetState, setResetSate] = (0, import_react120.useState)(0);
  (0, import_react120.useEffect)(() => {
    const fetchCollection = async () => {
      var _a;
      if (await api.isAuthenticated()) {
        const { name: name2, order } = JSON.parse(sortKey || "{}");
        const validSortKey = ((_a = collectionExtra.fields) == null ? void 0 : _a.map((x7) => x7.name).includes(name2)) ? name2 : void 0;
        try {
          const collection2 = await api.fetchCollection(collectionName, includeDocuments, after, validSortKey, order, filterArgs);
          setCollection(collection2);
        } catch (error22) {
          cms.alerts.error(`[${error22.name}] GetCollection failed: ${error22.message}`);
          console.error(error22);
          setCollection(void 0);
          setError(error22);
        }
        setLoading(false);
      }
    };
    setLoading(true);
    fetchCollection();
  }, [cms, collectionName, resetState, after, sortKey]);
  const reFetchCollection = () => setResetSate((x7) => x7 + 1);
  return { collection, loading, error: error2, reFetchCollection, collectionExtra };
};
var GetCollection = ({
  cms,
  collectionName,
  includeDocuments = true,
  startCursor,
  sortKey,
  children,
  filterArgs
}) => {
  const navigate = useNavigate();
  const { collection, loading, error: error2, reFetchCollection, collectionExtra } = useGetCollection(cms, collectionName, includeDocuments, startCursor || "", sortKey, filterArgs) || {};
  (0, import_react120.useEffect)(() => {
    var _a, _b, _c, _d, _e4, _f, _g, _h;
    if (loading)
      return;
    const collectionDefinition = cms.api.tina.schema.getCollection(collection.name);
    const allowCreate = (_c = (_b = (_a = collectionDefinition == null ? void 0 : collectionDefinition.ui) == null ? void 0 : _a.allowedActions) == null ? void 0 : _b.create) != null ? _c : true;
    const allowDelete = (_f = (_e4 = (_d = collectionDefinition == null ? void 0 : collectionDefinition.ui) == null ? void 0 : _d.allowedActions) == null ? void 0 : _e4.delete) != null ? _f : true;
    if (!allowCreate && !allowDelete && ((_h = (_g = collection.documents) == null ? void 0 : _g.edges) == null ? void 0 : _h.length) === 1) {
      const doc = collection.documents.edges[0].node;
      handleNavigate(navigate, cms, collection, collectionDefinition, doc);
    }
  }, [(collection == null ? void 0 : collection.name) || "", loading]);
  if (error2) {
    return import_react120.default.createElement(FullscreenError, null);
  }
  if (loading) {
    return import_react120.default.createElement(LoadingPage, null);
  }
  return import_react120.default.createElement(import_react120.default.Fragment, null, children(collection, loading, reFetchCollection, collectionExtra));
};
var LOCAL_STORAGE_KEY = "tinacms.admin.collection.list.page";
var isSSR2 = typeof window === "undefined";
var TemplateMenu = ({ templates }) => {
  return import_react120.default.createElement(ot2, {
    as: "div",
    className: "relative inline-block text-left"
  }, () => import_react120.default.createElement("div", null, import_react120.default.createElement("div", null, import_react120.default.createElement(ot2.Button, {
    className: "icon-parent inline-flex items-center font-medium focus:outline-none focus:ring-2 focus:shadow-outline text-center rounded-full justify-center transition-all duration-150 ease-out  shadow text-white bg-blue-500 hover:bg-blue-600 focus:ring-blue-500 text-sm h-10 px-6"
  }, "Create New ", import_react120.default.createElement(BiPlus2, {
    className: "w-5 h-full ml-1 opacity-70"
  }))), import_react120.default.createElement(tt2, {
    as: import_react120.Fragment,
    enter: "transition ease-out duration-100",
    enterFrom: "transform opacity-0 scale-95",
    enterTo: "transform opacity-100 scale-100",
    leave: "transition ease-in duration-75",
    leaveFrom: "transform opacity-100 scale-100",
    leaveTo: "transform opacity-0 scale-95"
  }, import_react120.default.createElement(ot2.Items, {
    className: "origin-top-right absolute right-0 mt-2 z-menu w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 focus:outline-none"
  }, import_react120.default.createElement("div", {
    className: "py-1"
  }, templates.map((template) => import_react120.default.createElement(ot2.Item, {
    key: `${template.label}-${template.name}`
  }, ({ active }) => import_react120.default.createElement(Link, {
    to: `${template.name}/new`,
    className: `w-full text-md px-4 py-2 tracking-wide flex items-center transition ease-out duration-100 ${active ? "text-blue-600 opacity-100 bg-gray-50" : "opacity-80 text-gray-600"}`
  }, template.label))))))));
};
var handleNavigate = (navigate, cms, collection, collectionDefinition, document2) => {
  var _a, _b;
  const plugins2 = cms.plugins.all("tina-admin");
  const routeMapping = plugins2.find(({ name: name2 }) => name2 === "route-mapping");
  const tinaPreview = cms.flags.get("tina-preview") || false;
  let routeOverride = ((_a = collectionDefinition.ui) == null ? void 0 : _a.router) ? (_b = collectionDefinition.ui) == null ? void 0 : _b.router({
    document: document2,
    collection: collectionDefinition
  }) : routeMapping ? routeMapping.mapper(collection, document2) : void 0;
  if (routeOverride) {
    if (routeOverride.startsWith("/")) {
      routeOverride = routeOverride.slice(1);
    }
    tinaPreview ? navigate(`/~/${routeOverride}`) : window.location.href = routeOverride;
    return null;
  } else {
    navigate(document2._sys.breadcrumbs.join("/"));
  }
};
var CollectionListPage = () => {
  const navigate = useNavigate();
  const { collectionName } = useParams();
  const [deleteModalOpen, setDeleteModalOpen] = import_react120.default.useState(false);
  const [renameModalOpen, setRenameModalOpen] = import_react120.default.useState(false);
  const [vars, setVars] = import_react120.default.useState({
    collection: collectionName,
    relativePath: "",
    newRelativePath: "",
    filterField: "",
    startsWith: "",
    endsWith: "",
    before: "",
    after: "",
    booleanEquals: null
  });
  const [endCursor, setEndCursor] = (0, import_react120.useState)("");
  const [prevCursors, setPrevCursors] = (0, import_react120.useState)([]);
  const [sortKey, setSortKey] = (0, import_react120.useState)(isSSR2 ? "" : window.localStorage.getItem(`${LOCAL_STORAGE_KEY}.${collectionName}`) || JSON.stringify({
    order: "asc",
    name: ""
  }));
  const { order = "asc" } = JSON.parse(sortKey || "{}");
  const [sortOrder, setSortOrder] = (0, import_react120.useState)(order);
  const loc = useLocation();
  (0, import_react120.useEffect)(() => {
    setSortKey(window.localStorage.getItem(`${LOCAL_STORAGE_KEY}.${collectionName}`) || JSON.stringify({
      order: "asc",
      name: ""
    }));
    setEndCursor("");
    setPrevCursors([]);
  }, [loc]);
  (0, import_react120.useEffect)(() => {
    setVars((old) => ({
      ...old,
      collection: collectionName,
      relativePath: "",
      newRelativePath: "",
      filterField: "",
      startsWith: "",
      endsWith: "",
      before: "",
      after: "",
      booleanEquals: null
    }));
  }, [collectionName]);
  return import_react120.default.createElement(GetCMS, null, (cms) => {
    return import_react120.default.createElement(PageWrapper, null, import_react120.default.createElement(GetCollection, {
      cms,
      collectionName,
      includeDocuments: true,
      startCursor: endCursor,
      sortKey,
      filterArgs: collectionName === vars.collection ? vars : {
        collection: collectionName,
        relativePath: "",
        newRelativePath: "",
        filterField: "",
        startsWith: "",
        endsWith: "",
        before: "",
        after: "",
        booleanEquals: null
      }
    }, (collection, _loading, reFetchCollection, collectionExtra) => {
      var _a, _b, _c, _d, _e4, _f, _g, _h, _i, _j, _k;
      collection.documents.totalCount;
      const documents = collection.documents.edges;
      const admin = cms.api.admin;
      const pageInfo = collection.documents.pageInfo;
      const fields = (_a = collectionExtra.fields) == null ? void 0 : _a.filter((x7) => ["string", "number", "datetime", "boolean"].includes(x7.type));
      const filterFields = (_b = collectionExtra.fields) == null ? void 0 : _b.filter((x7) => {
        return ["string", "datetime", "boolean"].includes(x7.type) && !x7.list;
      });
      const filterField = filterFields == null ? void 0 : filterFields.find((x7) => x7.name === vars.filterField);
      const showStartsWith = (filterField == null ? void 0 : filterField.type) === "string" && !filterField.list;
      const showDateFilter = (filterField == null ? void 0 : filterField.type) === "datetime";
      const showBooleanToggle = (filterField == null ? void 0 : filterField.type) === "boolean" && !filterField.list;
      const collectionDefinition = cms.api.tina.schema.getCollection(collection.name);
      const allowCreate = (_e4 = (_d = (_c = collectionDefinition == null ? void 0 : collectionDefinition.ui) == null ? void 0 : _c.allowedActions) == null ? void 0 : _d.create) != null ? _e4 : true;
      const allowDelete = (_h = (_g = (_f = collectionDefinition == null ? void 0 : collectionDefinition.ui) == null ? void 0 : _f.allowedActions) == null ? void 0 : _g.delete) != null ? _h : true;
      return import_react120.default.createElement(import_react120.default.Fragment, null, deleteModalOpen && import_react120.default.createElement(DeleteModal2, {
        filename: vars.relativePath,
        deleteFunc: async () => {
          try {
            await admin.deleteDocument(vars);
            cms.alerts.info("Document was successfully deleted");
            reFetchCollection();
          } catch (error2) {
            cms.alerts.warn("Document was not deleted, ask a developer for help or check the console for an error message");
            console.error(error2);
            throw error2;
          }
        },
        close: () => setDeleteModalOpen(false)
      }), renameModalOpen && import_react120.default.createElement(RenameModal, {
        filename: vars.relativePath,
        newRelativePath: vars.newRelativePath,
        setNewRelativePath: (newRelativePath) => {
          setVars((vars2) => {
            return { ...vars2, newRelativePath };
          });
        },
        renameFunc: async () => {
          const newRelativePath = `${vars.newRelativePath}.${collection.format}`;
          try {
            await admin.renameDocument({
              collection: vars.collection,
              relativePath: vars.relativePath,
              newRelativePath
            });
            cms.alerts.info("Document was successfully renamed");
            reFetchCollection();
          } catch (error2) {
            cms.alerts.warn("Document was not renamed, ask a developer for help or check the console for an error message");
            console.error(error2);
            throw error2;
          }
        },
        close: () => setRenameModalOpen(false)
      }), import_react120.default.createElement(PageHeader, {
        isLocalMode: (_j = (_i = cms == null ? void 0 : cms.api) == null ? void 0 : _i.tina) == null ? void 0 : _j.isLocalMode
      }, import_react120.default.createElement("div", {
        className: "w-full grid grid-flow-col items-end gap-4"
      }, import_react120.default.createElement("div", {
        className: "flex flex-col gap-4"
      }, import_react120.default.createElement("h3", {
        className: "font-sans text-2xl text-gray-700"
      }, collection.label ? collection.label : collection.name), (fields == null ? void 0 : fields.length) > 0 && import_react120.default.createElement("div", {
        className: "flex gap-4 items-end flex-wrap"
      }, import_react120.default.createElement("div", {
        className: "flex flex-col gap-2 items-start"
      }, import_react120.default.createElement("label", {
        htmlFor: "sort",
        className: "block font-sans text-xs font-semibold text-gray-500 whitespace-normal"
      }, "Sort by"), import_react120.default.createElement(Select, {
        name: "sort",
        options: [
          {
            label: "Default",
            value: JSON.stringify({
              order: "asc",
              name: ""
            })
          },
          ...fields.map((x7) => [
            {
              label: (x7.label || x7.name) + (x7.type === "datetime" ? " (Oldest First)" : " (Ascending)"),
              value: JSON.stringify({
                name: x7.name,
                order: "asc"
              })
            },
            {
              label: (x7.label || x7.name) + (x7.type === "datetime" ? " (Newest First)" : " (Descending)"),
              value: JSON.stringify({
                name: x7.name,
                order: "desc"
              })
            }
          ]).flat()
        ],
        input: {
          id: "sort",
          name: "sort",
          value: sortKey,
          onChange: (e9) => {
            const val = JSON.parse(e9.target.value);
            setEndCursor("");
            setPrevCursors([]);
            window == null ? void 0 : window.localStorage.setItem(`${LOCAL_STORAGE_KEY}.${collectionName}`, e9.target.value);
            setSortKey(e9.target.value);
            setSortOrder(val.order);
          }
        }
      })), import_react120.default.createElement("form", {
        className: "flex flex-wrap gap-4 items-end"
      }, import_react120.default.createElement("div", {
        className: "flex flex-shrink-0 flex-col gap-2 items-start"
      }, import_react120.default.createElement("label", {
        htmlFor: "filter",
        className: "block font-sans text-xs font-semibold text-gray-500 whitespace-normal"
      }, "Filter by"), import_react120.default.createElement(Select, {
        name: "filter",
        options: [
          {
            label: "None",
            value: ""
          },
          ...filterFields.map((x7) => ({
            label: typeof x7.label === "string" && x7.label || x7.name,
            value: x7.name
          }))
        ],
        input: {
          id: "filter",
          name: "filter",
          value: vars.filterField,
          onChange: (e9) => {
            const val = e9.target.value;
            setEndCursor("");
            setPrevCursors([]);
            setVars((old) => ({
              ...old,
              filterField: val
            }));
            if (!val) {
              reFetchCollection();
            }
          }
        }
      })), showStartsWith && import_react120.default.createElement(import_react120.default.Fragment, null, import_react120.default.createElement("div", {
        className: "flex flex-shrink-0 flex-col gap-2 items-start"
      }, import_react120.default.createElement("label", {
        htmlFor: "startsWith",
        className: "block font-sans text-xs font-semibold text-gray-500 whitespace-normal"
      }, "Starts with"), import_react120.default.createElement(Input, {
        name: "startsWith",
        id: "startsWith",
        value: vars.startsWith,
        onChange: (e9) => {
          const val = e9.target.value;
          setVars((old) => ({
            ...old,
            startsWith: val,
            after: "",
            before: "",
            booleanEquals: null
          }));
        }
      }))), showDateFilter && import_react120.default.createElement("div", {
        className: "flex flex-shrink-0 gap-4"
      }, import_react120.default.createElement("div", {
        className: "flex flex-col gap-2 items-start"
      }, import_react120.default.createElement("label", {
        htmlFor: "dateAfter",
        className: "block font-sans text-xs font-semibold text-gray-500 whitespace-normal"
      }, "After"), import_react120.default.createElement(ReactDateTimeWithStyles, {
        inputProps: {
          className: textFieldClasses
        },
        value: vars.after,
        onChange: (e9) => {
          setVars((old) => ({
            ...old,
            after: typeof e9.format === "function" ? e9.format() : "",
            booleanEquals: null,
            startsWith: ""
          }));
        }
      })), import_react120.default.createElement("div", {
        className: "flex flex-col gap-2 items-start"
      }, import_react120.default.createElement("label", {
        htmlFor: "dateBefore",
        className: "block font-sans text-xs font-semibold text-gray-500 whitespace-normal"
      }, "Before"), import_react120.default.createElement(ReactDateTimeWithStyles, {
        inputProps: {
          className: textFieldClasses
        },
        value: vars.before,
        onChange: (e9) => {
          setVars((old) => ({
            ...old,
            before: typeof e9.format === "function" ? e9.format() : "",
            booleanEquals: null,
            startsWith: ""
          }));
        }
      }))), showBooleanToggle && import_react120.default.createElement(import_react120.default.Fragment, null, import_react120.default.createElement("div", {
        className: "flex flex-col gap-2 items-start"
      }, import_react120.default.createElement("label", {
        htmlFor: "toggle",
        className: "block font-sans text-xs font-semibold text-gray-500 whitespace-normal"
      }, filterField.label || filterField.name), import_react120.default.createElement(Toggle, {
        field: filterField,
        input: {
          name: "toggle",
          value: (_k = vars.booleanEquals) != null ? _k : false,
          onChange: () => {
            setVars((old) => ({
              ...old,
              booleanEquals: !old.booleanEquals,
              after: "",
              before: "",
              startsWith: ""
            }));
          }
        },
        name: "toggle"
      }))), (showStartsWith || showDateFilter || showBooleanToggle) && import_react120.default.createElement("div", {
        className: "flex gap-3"
      }, import_react120.default.createElement(Button, {
        onClick: () => {
          setEndCursor("");
          setPrevCursors([]);
          reFetchCollection();
        },
        variant: "primary",
        type: "submit"
      }, "Search", " ", import_react120.default.createElement(BiSearch2, {
        className: "w-5 h-full ml-1.5 opacity-70"
      })), (vars.startsWith || vars.after || vars.before || vars.booleanEquals) && import_react120.default.createElement(Button, {
        onClick: () => {
          setVars((old) => ({
            ...old,
            startsWith: "",
            after: "",
            before: "",
            booleanEquals: null
          }));
          setEndCursor("");
          setPrevCursors([]);
          reFetchCollection();
        },
        variant: "white"
      }, "Clear", " ", import_react120.default.createElement(BiX2, {
        className: "w-5 h-full ml-1 opacity-70"
      })))))), import_react120.default.createElement("div", {
        className: "flex self-end	justify-self-end"
      }, !collection.templates && allowCreate && import_react120.default.createElement(Link, {
        to: `new`,
        className: "icon-parent inline-flex items-center font-medium focus:outline-none focus:ring-2 focus:shadow-outline text-center rounded-full justify-center transition-all duration-150 ease-out whitespace-nowrap shadow text-white bg-blue-500 hover:bg-blue-600 focus:ring-blue-500 text-sm h-10 px-6"
      }, "Create New", " ", import_react120.default.createElement(BiPlus2, {
        className: "w-5 h-full ml-1 opacity-70"
      })), collection.templates && allowCreate && import_react120.default.createElement(TemplateMenu, {
        templates: collection.templates
      })))), import_react120.default.createElement(PageBody, null, import_react120.default.createElement("div", {
        className: "w-full mx-auto max-w-screen-xl"
      }, documents.length > 0 ? import_react120.default.createElement("table", {
        className: "table-auto shadow bg-white border-b border-gray-200 w-full max-w-full rounded-lg"
      }, import_react120.default.createElement("tbody", {
        className: "divide-y divide-gray-150"
      }, documents.map((document2) => {
        var _a2;
        const hasTitle = Boolean(document2.node._sys.title);
        const subfolders = document2.node._sys.breadcrumbs.slice(0, -1).join("/");
        return import_react120.default.createElement("tr", {
          key: `document-${document2.node._sys.relativePath}`,
          className: ""
        }, import_react120.default.createElement("td", {
          className: "pl-5 pr-3 py-2 truncate max-w-0"
        }, import_react120.default.createElement("a", {
          className: "text-blue-600 hover:text-blue-400 flex items-center gap-3 cursor-pointer truncate",
          onClick: () => {
            handleNavigate(navigate, cms, collection, collectionDefinition, document2.node);
          }
        }, import_react120.default.createElement(BiEdit2, {
          className: "inline-block h-6 w-auto flex-shrink-0 opacity-70"
        }), import_react120.default.createElement("span", {
          className: "truncate block"
        }, import_react120.default.createElement("span", {
          className: "block text-xs text-gray-400 mb-1 uppercase"
        }, hasTitle ? "Title" : "Filename"), import_react120.default.createElement("span", {
          className: "h-5 leading-5 block truncate"
        }, !hasTitle && subfolders && import_react120.default.createElement("span", {
          className: "text-xs text-gray-400"
        }, `${subfolders}/`), import_react120.default.createElement("span", null, hasTitle ? (_a2 = document2.node._sys) == null ? void 0 : _a2.title : document2.node._sys.filename))))), hasTitle && import_react120.default.createElement("td", {
          className: "px-3 py-4 truncate max-w-0 "
        }, import_react120.default.createElement("span", {
          className: "block text-xs text-gray-400 mb-1 uppercase"
        }, "Filename"), import_react120.default.createElement("span", {
          className: "h-5 leading-5 block text-sm font-medium text-gray-900 truncate"
        }, subfolders && import_react120.default.createElement("span", {
          className: "text-xs text-gray-400"
        }, `${subfolders}/`), import_react120.default.createElement("span", null, document2.node._sys.filename))), import_react120.default.createElement("td", {
          className: "px-3 py-4 truncate w-[15%]"
        }, import_react120.default.createElement("span", {
          className: "block text-xs text-gray-400 mb-1 uppercase"
        }, "Extension"), import_react120.default.createElement("span", {
          className: "h-5 leading-5 block text-sm font-medium text-gray-900"
        }, document2.node._sys.extension)), import_react120.default.createElement("td", {
          className: "px-3 py-4 truncate w-[15%]"
        }, import_react120.default.createElement("span", {
          className: "block text-xs text-gray-400 mb-1 uppercase"
        }, "Template"), import_react120.default.createElement("span", {
          className: "h-5 leading-5 block text-sm font-medium text-gray-900"
        }, document2.node._sys.template)), import_react120.default.createElement("td", {
          className: "w-0"
        }, import_react120.default.createElement(OverflowMenu$1, {
          toolbarItems: [
            {
              name: "edit",
              label: "Edit in Admin",
              Icon: import_react120.default.createElement(BiEdit2, {
                size: "1.3rem"
              }),
              onMouseDown: () => {
                navigate(`${document2.node._sys.breadcrumbs.join("/")}`, { replace: true });
              }
            },
            allowDelete && {
              name: "delete",
              label: "Delete",
              Icon: import_react120.default.createElement(BiTrash, {
                size: "1.3rem",
                className: "text-red-500"
              }),
              onMouseDown: () => {
                setVars((old) => ({
                  ...old,
                  collection: collectionName,
                  relativePath: document2.node._sys.breadcrumbs.join("/") + document2.node._sys.extension,
                  newRelativePath: ""
                }));
                setDeleteModalOpen(true);
              }
            },
            allowDelete && {
              name: "rename",
              label: "Rename",
              Icon: import_react120.default.createElement(BiRename, {
                size: "1.3rem",
                className: "text-red-500"
              }),
              onMouseDown: () => {
                setVars((old) => ({
                  ...old,
                  collection: collectionName,
                  relativePath: document2.node._sys.breadcrumbs.join("/") + document2.node._sys.extension,
                  newRelativePath: ""
                }));
                setRenameModalOpen(true);
              }
            }
          ].filter(Boolean)
        })));
      }))) : import_react120.default.createElement(NoDocumentsPlaceholder, null), import_react120.default.createElement("div", {
        className: "pt-4"
      }, import_react120.default.createElement(CursorPaginator, {
        variant: "white",
        hasNext: sortOrder === "asc" ? pageInfo == null ? void 0 : pageInfo.hasNextPage : pageInfo.hasPreviousPage,
        navigateNext: () => {
          const newState = [...prevCursors, endCursor];
          setPrevCursors(newState);
          setEndCursor(pageInfo == null ? void 0 : pageInfo.endCursor);
        },
        hasPrev: prevCursors.length > 0,
        navigatePrev: () => {
          const prev = prevCursors[prevCursors.length - 1];
          if (typeof prev === "string") {
            const newState = prevCursors.slice(0, -1);
            setPrevCursors(newState);
            setEndCursor(prev);
          }
        }
      })))));
    }));
  });
};
var NoDocumentsPlaceholder = () => {
  return import_react120.default.createElement("div", {
    className: "text-center px-5 py-3 flex flex-col items-center justify-center shadow border border-gray-100 bg-gray-50 border-b border-gray-200 w-full max-w-full rounded-lg"
  }, import_react120.default.createElement("p", {
    className: "text-base italic font-medium text-gray-300"
  }, "No documents found."));
};
var DeleteModal2 = ({ close: close2, deleteFunc, filename }) => {
  return import_react120.default.createElement(Modal, null, import_react120.default.createElement(PopupModal, null, import_react120.default.createElement(ModalHeader, {
    close: close2
  }, "Delete ", filename), import_react120.default.createElement(ModalBody, {
    padded: true
  }, import_react120.default.createElement("p", null, `Are you sure you want to delete ${filename}?`)), import_react120.default.createElement(ModalActions, null, import_react120.default.createElement(Button, {
    style: { flexGrow: 2 },
    onClick: close2
  }, "Cancel"), import_react120.default.createElement(Button, {
    style: { flexGrow: 3 },
    variant: "danger",
    onClick: async () => {
      await deleteFunc();
      close2();
    }
  }, "Delete"))));
};
var RenameModal = ({
  close: close2,
  renameFunc,
  filename,
  newRelativePath,
  setNewRelativePath
}) => {
  return import_react120.default.createElement(Modal, null, import_react120.default.createElement(PopupModal, null, import_react120.default.createElement(ModalHeader, {
    close: close2
  }, "Rename ", filename), import_react120.default.createElement(ModalBody, {
    padded: true
  }, import_react120.default.createElement(import_react120.default.Fragment, null, import_react120.default.createElement("p", {
    className: "mb-4"
  }, "Are you sure you want to rename ", import_react120.default.createElement("strong", null, filename), "? TinaCMS uses the filename as the ID; renaming this file could result in unresolved references."), import_react120.default.createElement(BaseTextField, {
    placeholder: "Enter a new name for the document's file",
    value: newRelativePath,
    onChange: (event) => setNewRelativePath(event.target.value)
  }))), import_react120.default.createElement(ModalActions, null, import_react120.default.createElement(Button, {
    style: { flexGrow: 2 },
    onClick: close2
  }, "Cancel"), import_react120.default.createElement(Button, {
    style: { flexGrow: 3 },
    variant: "primary",
    onClick: async () => {
      await renameFunc();
      close2();
    }
  }, "Rename"))));
};
function HiChevronRight(props) {
  return GenIcon2({ "tag": "svg", "attr": { "viewBox": "0 0 20 20", "fill": "currentColor" }, "child": [{ "tag": "path", "attr": { "fillRule": "evenodd", "d": "M7.293 14.707a1 1 0 010-1.414L10.586 10 7.293 6.707a1 1 0 011.414-1.414l4 4a1 1 0 010 1.414l-4 4a1 1 0 01-1.414 0z", "clipRule": "evenodd" } }] })(props);
}
function FaLock(props) {
  return GenIcon2({ "tag": "svg", "attr": { "viewBox": "0 0 448 512" }, "child": [{ "tag": "path", "attr": { "d": "M400 224h-24v-72C376 68.2 307.8 0 224 0S72 68.2 72 152v72H48c-26.5 0-48 21.5-48 48v192c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V272c0-26.5-21.5-48-48-48zm-104 0H152v-72c0-39.7 32.3-72 72-72s72 32.3 72 72v72z" } }] })(props);
}
function FaUnlock(props) {
  return GenIcon2({ "tag": "svg", "attr": { "viewBox": "0 0 448 512" }, "child": [{ "tag": "path", "attr": { "d": "M400 256H152V152.9c0-39.6 31.7-72.5 71.3-72.9 40-.4 72.7 32.1 72.7 72v16c0 13.3 10.7 24 24 24h32c13.3 0 24-10.7 24-24v-16C376 68 307.5-.3 223.5 0 139.5.3 72 69.5 72 153.5V256H48c-26.5 0-48 21.5-48 48v160c0 26.5 21.5 48 48 48h352c26.5 0 48-21.5 48-48V304c0-26.5-21.5-48-48-48z" } }] })(props);
}
var createDocument = async (cms, collection, template, mutationInfo, values3) => {
  const api = new TinaAdminApi(cms);
  const { filename, ...leftover } = values3;
  const relativePath = `${filename}.${collection.format}`;
  const params = api.schema.transformPayload(collection.name, {
    _collection: collection.name,
    ...template && { _template: template.name },
    ...leftover
  });
  if (await api.isAuthenticated()) {
    await api.createDocument(collection.name, relativePath, params);
  } else {
    const authMessage = `CreateDocument failed: User is no longer authenticated; please login and try again.`;
    cms.alerts.error(authMessage);
    console.error(authMessage);
    return false;
  }
};
var CollectionCreatePage = () => {
  const { collectionName, templateName } = useParams();
  return import_react120.default.createElement(GetCMS, null, (cms) => import_react120.default.createElement(GetCollection, {
    cms,
    collectionName,
    includeDocuments: false
  }, (collection) => {
    const mutationInfo = {
      includeCollection: true,
      includeTemplate: !!collection.templates
    };
    return import_react120.default.createElement(RenderForm$1, {
      cms,
      collection,
      templateName,
      mutationInfo
    });
  }));
};
var FilenameInput = (props) => {
  const [filenameTouched, setFilenameTouched] = import_react120.default.useState(false);
  return import_react120.default.createElement("div", {
    className: "group relative block cursor-pointer",
    onClick: () => {
      setFilenameTouched(true);
    }
  }, import_react120.default.createElement("input", {
    type: "text",
    className: `shadow-inner focus:shadow-outline focus:border-blue-500 focus:outline-none block text-base pr-3 truncate py-2 w-full border transition-all ease-out duration-150 focus:text-gray-900 rounded-md ${props.readonly || !filenameTouched ? "bg-gray-50 text-gray-300  border-gray-150 pointer-events-none pl-8 group-hover:bg-white group-hover:text-gray-600  group-hover:border-gray-200" : "bg-white text-gray-600  border-gray-200 pl-3"}`,
    ...props,
    disabled: props.readonly || !filenameTouched
  }), import_react120.default.createElement(FaLock, {
    className: `text-gray-400 absolute top-1/2 left-2 -translate-y-1/2 pointer-events-none h-5 w-auto transition-opacity duration-150 ease-out ${!filenameTouched && !props.readonly ? "opacity-20 group-hover:opacity-0 group-active:opacity-0" : "opacity-0"}`
  }), import_react120.default.createElement(FaUnlock, {
    className: `text-blue-500 absolute top-1/2 left-2 -translate-y-1/2 pointer-events-none h-5 w-auto transition-opacity duration-150 ease-out ${!filenameTouched && !props.readonly ? "opacity-0 group-hover:opacity-80 group-active:opacity-80" : "opacity-0"}`
  }));
};
var RenderForm$1 = ({ cms, collection, templateName, mutationInfo }) => {
  var _a, _b, _c, _d, _e4, _f;
  const navigate = useNavigate();
  const [formIsPristine, setFormIsPristine] = (0, import_react120.useState)(true);
  const schema = cms.api.tina.schema;
  const schemaCollection = schema.getCollection(collection.name);
  const template = schema.getTemplateForData({
    collection: schemaCollection,
    data: { _template: templateName }
  });
  const formInfo = resolveForm({
    collection: schemaCollection,
    basename: schemaCollection.name,
    schema,
    template
  });
  let slugFunction = (_b = (_a = schemaCollection.ui) == null ? void 0 : _a.filename) == null ? void 0 : _b.slugify;
  if (!slugFunction) {
    const titleField = (_c = template == null ? void 0 : template.fields.find((x7) => x7.required && x7.type === "string" && x7.isTitle)) == null ? void 0 : _c.name;
    if (titleField) {
      slugFunction = (values3) => {
        var _a2;
        return (_a2 = values3[titleField]) == null ? void 0 : _a2.replace(/ /g, "-").replace(/[^a-zA-Z0-9-]/g, "");
      };
    }
  }
  const defaultItem = ((_d = template.ui) == null ? void 0 : _d.defaultItem) || (template == null ? void 0 : template.defaultItem);
  const form = (0, import_react120.useMemo)(() => {
    var _a2, _b2;
    return new Form({
      initialValues: typeof defaultItem === "function" ? defaultItem() : defaultItem,
      extraSubscribeValues: { active: true, submitting: true, touched: true },
      onChange: (values3) => {
        var _a3;
        if (slugFunction && (values3 == null ? void 0 : values3.active) !== "filename" && !(values3 == null ? void 0 : values3.submitting) && !((_a3 = values3.touched) == null ? void 0 : _a3.filename)) {
          const value = slugFunction(values3 == null ? void 0 : values3.values);
          form.finalForm.change("filename", value);
        }
      },
      id: "create-form",
      label: "form",
      fields: [
        ...formInfo.fields,
        {
          name: "filename",
          label: "Filename",
          component: slugFunction ? wrapFieldsWithMeta(({ field, input, meta }) => {
            var _a3, _b3;
            return import_react120.default.createElement(FilenameInput, {
              readonly: (_b3 = (_a3 = schemaCollection == null ? void 0 : schemaCollection.ui) == null ? void 0 : _a3.filename) == null ? void 0 : _b3.readonly,
              ...input
            });
          }) : "text",
          disabled: (_b2 = (_a2 = schemaCollection == null ? void 0 : schemaCollection.ui) == null ? void 0 : _a2.filename) == null ? void 0 : _b2.readonly,
          description: import_react120.default.createElement("span", null, "A unique filename for the content.", import_react120.default.createElement("br", null), "Examples: ", import_react120.default.createElement("code", null, "My_Document"), ", ", import_react120.default.createElement("code", null, "My_Document.en"), ",", " ", import_react120.default.createElement("code", null, "sub-folder/My_Document")),
          placeholder: `My_Document`,
          validate: (value, allValues, meta) => {
            var _a3, _b3;
            if (!value) {
              if (meta.dirty) {
                return "Required";
              }
              return true;
            }
            const isValid4 = /^[_a-zA-Z0-9][\.\-_\/a-zA-Z0-9]*$/.test(value);
            if (value && !isValid4) {
              return "Must begin with a-z, A-Z, 0-9, or _ and contain only a-z, A-Z, 0-9, -, _, ., or /.";
            }
            if (((_a3 = schemaCollection.match) == null ? void 0 : _a3.exclude) || ((_b3 = schemaCollection.match) == null ? void 0 : _b3.include)) {
              const filePath = `${normalizePath(schemaCollection.path)}/${value}.${schemaCollection.format || "md"}`;
              const match5 = schema.matchFiles({
                files: [filePath],
                collection: schemaCollection
              });
              if (match5.length === 0) {
                return `The filename "${value}" is not allowed for this collection.`;
              }
            }
          }
        }
      ],
      onSubmit: async (values3) => {
        try {
          await createDocument(cms, collection, template, mutationInfo, values3);
          cms.alerts.success("Document created!");
          navigate(`/collections/${collection.name}`);
        } catch (error2) {
          console.error(error2);
          const defaultErrorText = "There was a problem saving your document.";
          if (error2.message.includes("already exists")) {
            cms.alerts.error(`${defaultErrorText} The "Filename" is alredy used for another document, please modify it.`);
          } else {
            cms.alerts.error(defaultErrorText);
          }
          throw new Error(`[${error2.name}] CreateDocument failed: ${error2.message}`);
        }
      }
    });
  }, [cms, collection, mutationInfo]);
  const navBreakpoint2 = 1e3;
  const windowWidth = useWindowWidth();
  const renderNavToggle = windowWidth < navBreakpoint2 + 1;
  const headerPadding = renderNavToggle ? "px-20" : "px-6";
  return import_react120.default.createElement(PageWrapper, null, import_react120.default.createElement(import_react120.default.Fragment, null, ((_f = (_e4 = cms == null ? void 0 : cms.api) == null ? void 0 : _e4.tina) == null ? void 0 : _f.isLocalMode) ? import_react120.default.createElement(LocalWarning, null) : import_react120.default.createElement(BillingWarning, null), import_react120.default.createElement("div", {
    className: `py-4 border-b border-gray-200 bg-white ${headerPadding}`
  }, import_react120.default.createElement("div", {
    className: "max-w-form mx-auto"
  }, import_react120.default.createElement("div", {
    className: "mb-2"
  }, import_react120.default.createElement("span", {
    className: "block text-sm leading-tight uppercase text-gray-400 mb-1"
  }, import_react120.default.createElement(Link, {
    to: `/collections/${collection.name}`,
    className: "inline-block text-current hover:text-blue-400 focus:underline focus:outline-none focus:text-blue-400 font-medium transition-colors duration-150 ease-out"
  }, collection.label ? collection.label : collection.name), import_react120.default.createElement(HiChevronRight, {
    className: "inline-block -mt-0.5 opacity-50"
  })), import_react120.default.createElement("span", {
    className: "text-xl text-gray-700 font-medium leading-tight"
  }, "Create New")), import_react120.default.createElement(FormStatus, {
    pristine: formIsPristine
  }))), import_react120.default.createElement(FormBuilder, {
    form,
    onPristineChange: setFormIsPristine
  })));
};
var useGetDocument = (cms, collectionName, relativePath) => {
  const api = new TinaAdminApi(cms);
  const [document2, setDocument] = (0, import_react120.useState)(void 0);
  const [loading, setLoading] = (0, import_react120.useState)(true);
  const [error2, setError] = (0, import_react120.useState)(void 0);
  (0, import_react120.useEffect)(() => {
    const fetchDocument = async () => {
      if (api.isAuthenticated()) {
        try {
          const response = await api.fetchDocument(collectionName, relativePath);
          setDocument(response.document);
        } catch (error22) {
          cms.alerts.error(`[${error22.name}] GetDocument failed: ${error22.message}`);
          console.error(error22);
          setDocument(void 0);
          setError(error22);
        }
        setLoading(false);
      }
    };
    setLoading(true);
    fetchDocument();
  }, [cms, collectionName, relativePath]);
  return { document: document2, loading, error: error2 };
};
var GetDocument = ({
  cms,
  collectionName,
  relativePath,
  children
}) => {
  const { document: document2, loading, error: error2 } = useGetDocument(cms, collectionName, relativePath);
  if (error2) {
    return import_react120.default.createElement(FullscreenError, null);
  }
  if (loading) {
    return import_react120.default.createElement(LoadingPage, null);
  }
  return import_react120.default.createElement(import_react120.default.Fragment, null, children(document2, loading));
};
var updateDocument = async (cms, relativePath, collection, mutationInfo, values3) => {
  const api = new TinaAdminApi(cms);
  const params = api.schema.transformPayload(collection.name, values3);
  if (await api.isAuthenticated()) {
    await api.updateDocument(collection.name, relativePath, params);
  } else {
    const authMessage = `UpdateDocument failed: User is no longer authenticated; please login and try again.`;
    cms.alerts.error(authMessage);
    console.error(authMessage);
    return false;
  }
};
var CollectionUpdatePage = () => {
  const { collectionName, ...rest } = useParams();
  const { "*": filename } = rest;
  return import_react120.default.createElement(GetCMS, null, (cms) => import_react120.default.createElement(GetCollection, {
    cms,
    collectionName,
    includeDocuments: false
  }, (collection) => {
    const relativePath = `${filename}.${collection.format}`;
    const mutationInfo = {
      includeCollection: true,
      includeTemplate: !!collection.templates
    };
    return import_react120.default.createElement(PageWrapper, null, import_react120.default.createElement(GetDocument, {
      cms,
      collectionName: collection.name,
      relativePath
    }, (document2) => import_react120.default.createElement(RenderForm, {
      cms,
      document: document2,
      filename,
      relativePath,
      collection,
      mutationInfo
    })));
  }));
};
var RenderForm = ({
  cms,
  document: document2,
  filename,
  relativePath,
  collection,
  mutationInfo
}) => {
  var _a, _b;
  const [formIsPristine, setFormIsPristine] = (0, import_react120.useState)(true);
  const schema = cms.api.tina.schema;
  const schemaCollection = schema.getCollection(collection.name);
  const template = schema.getTemplateForData({
    collection: schemaCollection,
    data: document2._values
  });
  const formInfo = resolveForm({
    collection: schemaCollection,
    basename: schemaCollection.name,
    schema,
    template
  });
  const form = (0, import_react120.useMemo)(() => {
    return new Form({
      id: "update-form",
      label: "form",
      fields: formInfo.fields,
      initialValues: document2._values,
      onSubmit: async (values3) => {
        try {
          await updateDocument(cms, relativePath, collection, mutationInfo, values3);
          cms.alerts.success("Document updated!");
        } catch (error2) {
          console.error(error2);
          throw new Error(`[${error2.name}] UpdateDocument failed: ${error2.message}`);
        }
      }
    });
  }, [cms, document2, relativePath, collection, mutationInfo]);
  const navBreakpoint2 = 1e3;
  const windowWidth = useWindowWidth();
  const renderNavToggle = windowWidth < navBreakpoint2 + 1;
  const headerPadding = renderNavToggle ? "px-20" : "px-6";
  return import_react120.default.createElement(import_react120.default.Fragment, null, ((_b = (_a = cms == null ? void 0 : cms.api) == null ? void 0 : _a.tina) == null ? void 0 : _b.isLocalMode) ? import_react120.default.createElement(LocalWarning, null) : import_react120.default.createElement(BillingWarning, null), import_react120.default.createElement("div", {
    className: `py-4 border-b border-gray-200 bg-white ${headerPadding}`
  }, import_react120.default.createElement("div", {
    className: "max-w-form mx-auto"
  }, import_react120.default.createElement("div", {
    className: "mb-2"
  }, import_react120.default.createElement("span", {
    className: "block text-sm leading-tight uppercase text-gray-400 mb-1"
  }, import_react120.default.createElement(Link, {
    to: `/collections/${collection.name}`,
    className: "inline-block text-current hover:text-blue-400 focus:underline focus:outline-none focus:text-blue-400 font-medium transition-colors duration-150 ease-out"
  }, collection.label ? collection.label : collection.name), import_react120.default.createElement(HiChevronRight, {
    className: "inline-block -mt-0.5 opacity-50"
  })), import_react120.default.createElement("span", {
    className: "text-xl text-gray-700 font-medium leading-tight"
  }, "Edit ", `${filename}.${collection.format}`)), import_react120.default.createElement(FormStatus, {
    pristine: formIsPristine
  }))), import_react120.default.createElement(FormBuilder, {
    form,
    onPristineChange: setFormIsPristine
  }));
};
var ScreenPage = () => {
  const { screenName } = useParams();
  const navBreakpoint2 = 1e3;
  const windowWidth = useWindowWidth();
  const renderNavToggle = windowWidth < navBreakpoint2 + 1;
  return import_react120.default.createElement(GetCMS, null, (cms) => {
    var _a, _b;
    const screens = cms.plugins.getType("screen").all();
    const selectedScreen = screens.find(({ name: name2 }) => slugify(name2) === screenName);
    return import_react120.default.createElement("div", {
      className: "relative w-full h-full flex flex-col items-stretch justify-between"
    }, ((_b = (_a = cms == null ? void 0 : cms.api) == null ? void 0 : _a.tina) == null ? void 0 : _b.isLocalMode) ? import_react120.default.createElement(LocalWarning, null) : import_react120.default.createElement(BillingWarning, null), renderNavToggle && import_react120.default.createElement("div", {
      className: `py-5 border-b border-gray-200 bg-white pl-18`
    }, selectedScreen.name), import_react120.default.createElement("div", {
      className: "flex-1 overflow-y-auto relative flex flex-col items-stretch justify-between"
    }, import_react120.default.createElement(selectedScreen.Component, {
      close: () => {
      }
    })));
  });
};
var Redirect = () => {
  import_react120.default.useEffect(() => {
    if (window) {
      window.location.assign("/");
    }
  }, []);
  return null;
};
var MaybeRedirectToPreview = ({
  redirect: redirect2,
  children
}) => {
  const navigate = useNavigate();
  import_react120.default.useEffect(() => {
    if (redirect2) {
      navigate("/~");
    }
  }, [redirect2]);
  return children;
};
var SetPreviewFlag = ({
  preview,
  cms
}) => {
  import_react120.default.useEffect(() => {
    if (preview) {
      cms.flags.set("tina-iframe", true);
    }
  }, [preview]);
  return null;
};
var PreviewInner = ({ preview, config: config2 }) => {
  const params = useParams();
  const navigate = useNavigate();
  const [url, setURL] = import_react120.default.useState(`/${params["*"]}`);
  const [reportedURL, setReportedURL] = (0, import_react120.useState)(null);
  const ref2 = import_react120.default.useRef(null);
  const paramURL = `/${params["*"]}`;
  import_react120.default.useEffect(() => {
    if (reportedURL !== paramURL && paramURL) {
      setURL(paramURL);
    }
  }, [paramURL]);
  import_react120.default.useEffect(() => {
    if ((reportedURL !== url || reportedURL !== paramURL) && reportedURL) {
      navigate(`/~${reportedURL}`);
    }
  }, [reportedURL]);
  import_react120.default.useEffect(() => {
    setInterval(() => {
      var _a;
      if (ref2.current) {
        const url2 = new URL(((_a = ref2.current.contentWindow) == null ? void 0 : _a.location.href) || "");
        if (url2.origin === "null") {
          return;
        }
        const href = url2.href.replace(url2.origin, "");
        setReportedURL(href);
      }
    }, 100);
  }, [ref2.current]);
  const Preview = preview;
  return import_react120.default.createElement(Preview, {
    url,
    iframeRef: ref2,
    ...config2
  });
};
var CheckSchema = ({
  schemaJson,
  children
}) => {
  const cms = useCMS();
  const api = new TinaAdminApi(cms);
  const url = api.api.contentApiUrl;
  (0, import_react120.useEffect)(() => {
    if (schemaJson && cms) {
      api.checkGraphqlSchema({
        localSchema: schemaJson
      }).then((x7) => {
        if (x7 === false) {
          cms.alerts.error("GraphQL Schema Mismatch. Editing may not work. If you just switched branches, try going back to the previous branch");
        }
      });
    }
  }, [cms, JSON.stringify(schemaJson || {}), url]);
  return children;
};
var TinaAdmin = ({
  preview,
  Playground,
  config: config2,
  schemaJson
}) => {
  const isSSR22 = typeof window === "undefined";
  const { edit } = useEditState();
  if (isSSR22) {
    return null;
  }
  if (!edit) {
    return import_react120.default.createElement(Layout, null, import_react120.default.createElement(LoginPage, null));
  }
  return import_react120.default.createElement(GetCMS, null, (cms) => {
    var _a, _b, _c;
    const isTinaAdminEnabled = cms.flags.get("tina-admin") === false ? false : true;
    if (isTinaAdminEnabled) {
      const tinaClient = (_a = cms.api) == null ? void 0 : _a.tina;
      const collectionWithRouter = (_c = (_b = tinaClient == null ? void 0 : tinaClient.schema) == null ? void 0 : _b.config) == null ? void 0 : _c.collections.find((x7) => {
        var _a2;
        return typeof ((_a2 = x7 == null ? void 0 : x7.ui) == null ? void 0 : _a2.router) === "function";
      });
      const hasRouter = Boolean(collectionWithRouter);
      return import_react120.default.createElement(CheckSchema, {
        schemaJson
      }, import_react120.default.createElement(HashRouter, null, import_react120.default.createElement(SetPreviewFlag, {
        preview,
        cms
      }), import_react120.default.createElement(Routes, null, preview && import_react120.default.createElement(Route, {
        path: "/~/*",
        element: import_react120.default.createElement(PreviewInner, {
          config: config2,
          preview
        })
      }), import_react120.default.createElement(Route, {
        path: "graphql",
        element: import_react120.default.createElement(PlainLayout, null, import_react120.default.createElement(Playground, null))
      }), import_react120.default.createElement(Route, {
        path: "collections/:collectionName/new",
        element: import_react120.default.createElement(DefaultWrapper, {
          cms
        }, import_react120.default.createElement(CollectionCreatePage, null))
      }), import_react120.default.createElement(Route, {
        path: "collections/:collectionName/:templateName/new",
        element: import_react120.default.createElement(DefaultWrapper, {
          cms
        }, import_react120.default.createElement(CollectionCreatePage, null))
      }), import_react120.default.createElement(Route, {
        path: "collections/:collectionName/*",
        element: import_react120.default.createElement(DefaultWrapper, {
          cms
        }, import_react120.default.createElement(CollectionUpdatePage, null))
      }), import_react120.default.createElement(Route, {
        path: "collections/:collectionName",
        element: import_react120.default.createElement(DefaultWrapper, {
          cms
        }, import_react120.default.createElement(CollectionListPage, null))
      }), import_react120.default.createElement(Route, {
        path: "screens/:screenName",
        element: import_react120.default.createElement(DefaultWrapper, {
          cms
        }, import_react120.default.createElement(ScreenPage, null))
      }), import_react120.default.createElement(Route, {
        path: "logout",
        element: import_react120.default.createElement(DefaultWrapper, {
          cms
        }, import_react120.default.createElement(LogoutRedirect, null))
      }), import_react120.default.createElement(Route, {
        path: "/",
        element: import_react120.default.createElement(MaybeRedirectToPreview, {
          redirect: !!preview && hasRouter
        }, import_react120.default.createElement(DefaultWrapper, {
          cms
        }, import_react120.default.createElement(DashboardPage, null)))
      }))));
    } else {
      return import_react120.default.createElement(Layout, null, import_react120.default.createElement(HashRouter, null, import_react120.default.createElement(Routes, null, import_react120.default.createElement(Route, {
        path: "logout",
        element: import_react120.default.createElement(LogoutPage, null)
      }), import_react120.default.createElement(Route, {
        path: "/",
        element: import_react120.default.createElement(Redirect, null)
      }))));
    }
  });
};
var DefaultWrapper = ({
  cms,
  children
}) => {
  return import_react120.default.createElement(Layout, null, import_react120.default.createElement("div", {
    className: "flex items-stretch h-screen overflow-hidden"
  }, import_react120.default.createElement(Sidebar2, {
    cms
  }), import_react120.default.createElement("div", {
    className: "flex-1 relative"
  }, children)));
};
var PlainLayout = ({ children }) => {
  return import_react120.default.createElement("div", {
    style: {
      position: "fixed",
      top: 0,
      left: 0,
      width: "100%",
      height: "100%",
      overflow: "auto",
      background: "#F6F6F9",
      fontFamily: "'Inter', sans-serif",
      zIndex: 9999
    }
  }, children);
};
var RouteMappingPlugin = class {
  constructor(mapper) {
    this.__type = "tina-admin";
    this.name = "route-mapping";
    this.mapper = mapper;
  }
};
var defineSchema = (config2) => {
  validateSchema({ schema: config2 });
  return config2;
};
var defineLegacyConfig = (config2) => {
  validateSchema({ schema: config2.schema });
  return config2;
};
var defineStaticConfig = (config2) => {
  if (!config2.schema) {
    throw new Error("Static config must have a schema");
  }
  validateSchema({ schema: config2.schema });
  return config2;
};
var defineConfig = defineStaticConfig;
export {
  ActionButton,
  AddIcon,
  AlertIcon,
  Alerts$1 as Alerts,
  AlignCenter,
  AlignLeft,
  AlignRight,
  AuthWallInner,
  BaseTextField,
  BillingWarning,
  BlocksField,
  BlocksFieldPlugin,
  BoldIcon$1 as BoldIcon,
  BranchBanner,
  BranchDataProvider,
  BranchSwitcher,
  BranchSwitcherPlugin,
  Button,
  ButtonToggle,
  ButtonToggleField,
  ButtonToggleFieldPlugin,
  CMSContext,
  CheckboxGroup,
  CheckboxGroupField,
  CheckboxGroupFieldPlugin,
  ChevronDownIcon$2 as ChevronDownIcon,
  ChevronLeftIcon,
  ChevronRightIcon,
  ChevronUpIcon,
  Circle3 as Circle,
  CircleCheck,
  Client,
  CloseIcon,
  CodeIcon$1 as CodeIcon,
  ColorField,
  ColorFieldPlugin,
  ColorPicker,
  CursorPaginator,
  DEFAULT_LOCAL_TINA_GQL_SERVER_URL,
  DEFAULT_MEDIA_UPLOAD_TYPES,
  DateField,
  DateFieldPlugin,
  DeleteImageButton,
  Dismissible,
  DragHandle,
  DragIcon,
  DummyMediaStore,
  DuplicateIcon,
  ERROR_MISSING_CMS,
  EditIcon,
  EllipsisVerticalIcon,
  ErrorIcon,
  EventBus,
  ExitIcon,
  FieldDescription,
  FieldError,
  FieldLabel,
  FieldMeta,
  FieldWrapper,
  FieldsBuilder,
  FieldsGroup,
  File2 as File,
  Folder,
  FontLoader,
  Form,
  FormActionMenu,
  FormBuilder,
  FormLegacy,
  FormMetaPlugin,
  FormPortalProvider,
  FormStatus,
  FormWrapper$1 as FormWrapper,
  FullscreenFormBuilder,
  FullscreenModal,
  GlobalFormPlugin,
  Group$1 as Group,
  GroupField,
  GroupFieldPlugin,
  GroupLabel,
  GroupListField,
  GroupListFieldPlugin,
  GroupPanel,
  HamburgerIcon,
  HeadingIcon$1 as HeadingIcon,
  HiddenField,
  HiddenFieldPlugin,
  IconButton,
  ImageField,
  ImageFieldPlugin,
  ImageUpload,
  InfoIcon,
  Input,
  ItalicIcon$1 as ItalicIcon,
  ItemClickTarget,
  ItemDeleteButton,
  ItemHeader,
  LeftArrowIcon,
  LinkIcon$1 as LinkIcon,
  ListField,
  ListFieldPlugin,
  LoadingDots,
  LocalClient,
  LocalWarning,
  LockIcon,
  MarkdownIcon,
  MdxFieldPlugin,
  MdxFieldPluginExtendible,
  MediaIcon,
  MediaListError,
  MediaManager$1 as MediaManager,
  Modal,
  ModalActions,
  ModalBody,
  ModalFullscreen,
  ModalHeader,
  ModalOverlay,
  ModalPopup,
  ModalProvider,
  NAMER,
  Nav,
  NumberField,
  NumberFieldPlugin,
  NumberInput,
  OrderedListIcon$1 as OrderedListIcon,
  OverflowMenu$1 as OverflowMenu,
  PanelBody,
  PanelHeader,
  PopupModal,
  PullRequestIcon,
  QuoteIcon$1 as QuoteIcon,
  RadioGroup,
  RadioGroupField,
  RadioGroupFieldPlugin,
  ReactDateTimeWithStyles,
  RedoIcon,
  Reference,
  ReferenceField,
  ReferenceFieldPlugin,
  ReorderIcon,
  ReorderRowIcon,
  ResetForm,
  ResetIcon,
  RightArrowIcon,
  RouteMappingPlugin,
  Select,
  SelectField,
  SelectFieldPlugin,
  SettingsIcon,
  StrikethroughIcon,
  SyncStatus,
  TableIcon,
  TagsField,
  TagsFieldPlugin,
  TextArea,
  TextField,
  TextFieldPlugin,
  TextareaField,
  TextareaFieldPlugin,
  Tina,
  TinaAdmin,
  TinaAdminApi,
  TinaCMS,
  TinaCMSProvider,
  TinaCMSProvider2,
  TinaCloudAuthWall,
  TinaCloudProvider,
  TinaField,
  TinaForm,
  TinaIcon,
  TinaMediaStore,
  TinaProvider,
  TinaUI,
  Toggle,
  ToggleField,
  ToggleFieldPlugin,
  TrashIcon,
  UnderlineIcon,
  UndoIcon,
  UnorderedListIcon$1 as UnorderedListIcon,
  UploadIcon,
  WarningIcon,
  assertShape2 as assertShape,
  asyncPoll,
  classNames,
  createClient,
  TinaCMSProvider2 as default,
  defineConfig,
  defineLegacyConfig,
  defineSchema,
  defineStaticConfig,
  formatBranchName,
  getFilteredBranchList,
  getStaticPropsForTina,
  gql2 as gql,
  resolveForm,
  safeAssertShape,
  selectFieldClasses,
  staticRequest,
  textFieldClasses,
  useBranchData,
  useCMS,
  useCMSEvent,
  useDismissible,
  useDocumentCreatorPlugin,
  useForm2 as useForm,
  useFormPortal,
  useFormScreenPlugin,
  useGlobalForm,
  useLocalForm,
  useLocalStorage,
  useModalContainer,
  usePlugin,
  usePlugins,
  useScreenPlugin,
  useSubscribable,
  useTinaAuthRedirect,
  useWatchFormValues,
  withPlugin,
  withPlugins,
  withTina,
  wrapFieldWithError,
  wrapFieldsWithMeta
};
/*! Bundled license information:

prismjs/prism.js:
  (**
   * Prism: Lightweight, robust, elegant syntax highlighting
   *
   * @license MIT <https://opensource.org/licenses/MIT>
   * @author Lea Verou <https://lea.verou.me>
   * @namespace
   * @public
   *)

react-is/cjs/react-is.development.js:
  (** @license React v17.0.2
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

papaparse/papaparse.min.js:
  (* @license
  Papa Parse
  v5.4.1
  https://github.com/mholt/PapaParse
  License: MIT
  *)

react-dom/cjs/react-dom-server.browser.development.js:
  (** @license React v17.0.2
   * react-dom-server.browser.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

escape-html/index.js:
  (*!
   * escape-html
   * Copyright(c) 2012-2013 TJ Holowaychuk
   * Copyright(c) 2015 Andreas Lubbe
   * Copyright(c) 2015 Tiancheng "Timothy" Gu
   * MIT Licensed
   *)

is-buffer/index.js:
  (*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

is-number/index.js:
  (*!
   * is-number <https://github.com/jonschlinkert/is-number>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

to-regex-range/index.js:
  (*!
   * to-regex-range <https://github.com/micromatch/to-regex-range>
   *
   * Copyright (c) 2015-present, Jon Schlinkert.
   * Released under the MIT License.
   *)

fill-range/index.js:
  (*!
   * fill-range <https://github.com/jonschlinkert/fill-range>
   *
   * Copyright (c) 2014-present, Jon Schlinkert.
   * Licensed under the MIT License.
   *)

is-plain-object/dist/is-plain-object.mjs:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

@udecode/plate-core/dist/index.es.js:
  (*!
   * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
   *
   * Copyright (c) 2014-2017, Jon Schlinkert.
   * Released under the MIT License.
   *)

moment/dist/moment.js:
  (*! moment.js *)
  (*! version : 2.29.4 *)
  (*! authors : Tim Wood, Iskren Chernev, Moment.js contributors *)
  (*! license : MIT *)
  (*! momentjs.com *)

@remix-run/router/dist/router.js:
  (**
   * @remix-run/router v1.5.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router/dist/index.js:
  (**
   * React Router v6.10.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)

react-router-dom/dist/index.js:
  (**
   * React Router DOM v6.10.0
   *
   * Copyright (c) Remix Software Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE.md file in the root directory of this source tree.
   *
   * @license MIT
   *)
*/
//# sourceMappingURL=tinacms.js.map
