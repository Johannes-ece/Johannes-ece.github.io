var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value3) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value3 }) : obj[key] = value3;
var __spreadValues = (a2, b2) => {
  for (var prop2 in b2 || (b2 = {}))
    if (__hasOwnProp.call(b2, prop2))
      __defNormalProp(a2, prop2, b2[prop2]);
  if (__getOwnPropSymbols)
    for (var prop2 of __getOwnPropSymbols(b2)) {
      if (__propIsEnum.call(b2, prop2))
        __defNormalProp(a2, prop2, b2[prop2]);
    }
  return a2;
};
var __spreadProps = (a2, b2) => __defProps(a2, __getOwnPropDescs(b2));
var __name = (target2, value3) => __defProp(target2, "name", { value: value3, configurable: true });
var __objRest = (source, exclude) => {
  var target2 = {};
  for (var prop2 in source)
    if (__hasOwnProp.call(source, prop2) && exclude.indexOf(prop2) < 0)
      target2[prop2] = source[prop2];
  if (source != null && __getOwnPropSymbols)
    for (var prop2 of __getOwnPropSymbols(source)) {
      if (exclude.indexOf(prop2) < 0 && __propIsEnum.call(source, prop2))
        target2[prop2] = source[prop2];
    }
  return target2;
};
import * as React from "react";
import React__default, { createContext as createContext$1, useContext, useRef, useState, useEffect, forwardRef, useLayoutEffect, useCallback, createElement, PureComponent, useId as useId$1, useMemo, Fragment as Fragment$1, memo, useReducer, Children, cloneElement } from "react";
import { parse as parse$2, TypeInfo, visit as visit$1, print as print$1, getNamedType, isLeafType as isLeafType$1, Kind as Kind$1, visitWithTypeInfo, isCompositeType, isScalarType as isScalarType$1, isObjectType as isObjectType$1, isInterfaceType as isInterfaceType$1, isUnionType as isUnionType$1, isEnumType as isEnumType$1, isInputObjectType as isInputObjectType$1, isOutputType, isInputType, TypeNameMetaFieldDef as TypeNameMetaFieldDef$1, SchemaMetaFieldDef as SchemaMetaFieldDef$1, TypeMetaFieldDef as TypeMetaFieldDef$1, GraphQLEnumType as GraphQLEnumType$1, GraphQLBoolean as GraphQLBoolean$1, isAbstractType as isAbstractType$1, assertAbstractType, doTypesOverlap, DirectiveLocation as DirectiveLocation$1, BREAK as BREAK$1, isListType as isListType$1, isNonNullType as isNonNullType$1, GraphQLInterfaceType as GraphQLInterfaceType$1, GraphQLObjectType as GraphQLObjectType$1, GraphQLInputObjectType as GraphQLInputObjectType$1, getNullableType, GraphQLList as GraphQLList$1, typeFromAST, GraphQLFloat as GraphQLFloat$1, astFromValue as astFromValue$1, isSchema, buildClientSchema, validateSchema, getIntrospectionQuery, isNamedType, isType as isType$1 } from "graphql";
import ReactDOM, { createPortal } from "react-dom";
var root = /* @__PURE__ */ (() => '.graphiql-container *{box-sizing:border-box}.graphiql-container,.CodeMirror-info,.CodeMirror-lint-tooltip,reach-portal{--color-primary: 320, 95%, 43%;--color-secondary: 242, 51%, 61%;--color-tertiary: 188, 100%, 36%;--color-info: 208, 100%, 46%;--color-success: 158, 60%, 42%;--color-warning: 36, 100%, 41%;--color-error: 13, 93%, 58%;--color-neutral: 219, 28%, 32%;--color-base: 219, 28%, 100%;--alpha-secondary: .76;--alpha-tertiary: .5;--alpha-background-heavy: .15;--alpha-background-medium: .1;--alpha-background-light: .07;--font-family: "Roboto", sans-serif;--font-family-mono: "Fira Code", monospace;--font-size-hint:.75rem;--font-size-inline-code:.8125rem;--font-size-body:.9375rem;--font-size-h4:1.125rem;--font-size-h3:1.375rem;--font-size-h2:1.8125rem;--font-weight-regular: 400;--font-weight-medium: 500;--line-height: 1.5;--px-2: 2px;--px-4: 4px;--px-6: 6px;--px-8: 8px;--px-10: 10px;--px-12: 12px;--px-16: 16px;--px-20: 20px;--px-24: 24px;--border-radius-2: 2px;--border-radius-4: 4px;--border-radius-8: 8px;--border-radius-12: 12px;--popover-box-shadow: 0px 6px 20px rgba(59, 76, 106, .13), 0px 1.34018px 4.46726px rgba(59, 76, 106, .0774939), 0px .399006px 1.33002px rgba(59, 76, 106, .0525061);--popover-border: none;--sidebar-width: 60px;--toolbar-width: 40px;--session-header-height: 51px}@media (prefers-color-scheme: dark){body:not(.graphiql-light) .graphiql-container,body:not(.graphiql-light) .CodeMirror-info,body:not(.graphiql-light) .CodeMirror-lint-tooltip,body:not(.graphiql-light) reach-portal{--color-primary: 338, 100%, 67%;--color-secondary: 243, 100%, 77%;--color-tertiary: 188, 100%, 44%;--color-info: 208, 100%, 72%;--color-success: 158, 100%, 42%;--color-warning: 30, 100%, 80%;--color-error: 13, 100%, 58%;--color-neutral: 219, 29%, 78%;--color-base: 219, 29%, 18%;--popover-box-shadow: none;--popover-border: 1px solid hsl(var(--color-neutral))}}body.graphiql-dark .graphiql-container,body.graphiql-dark .CodeMirror-info,body.graphiql-dark .CodeMirror-lint-tooltip,body.graphiql-dark reach-portal{--color-primary: 338, 100%, 67%;--color-secondary: 243, 100%, 77%;--color-tertiary: 188, 100%, 44%;--color-info: 208, 100%, 72%;--color-success: 158, 100%, 42%;--color-warning: 30, 100%, 80%;--color-error: 13, 100%, 58%;--color-neutral: 219, 29%, 78%;--color-base: 219, 29%, 18%;--popover-box-shadow: none;--popover-border: 1px solid hsl(var(--color-neutral))}:is(.graphiql-container,.CodeMirror-info,.CodeMirror-lint-tooltip,reach-portal),:is(.graphiql-container,.CodeMirror-info,.CodeMirror-lint-tooltip,reach-portal):is(button){color:hsla(var(--color-neutral),1);font-family:var(--font-family);font-size:var(--font-size-body);font-weight:var(----font-weight-regular);line-height:var(--line-height)}:is(.graphiql-container,.CodeMirror-info,.CodeMirror-lint-tooltip,reach-portal) input{color:hsla(var(--color-neutral),1);font-family:var(--font-family);font-size:var(--font-size-caption)}:is(.graphiql-container,.CodeMirror-info,.CodeMirror-lint-tooltip,reach-portal) input::placeholder{color:hsla(var(--color-neutral),var(--alpha-secondary))}:is(.graphiql-container,.CodeMirror-info,.CodeMirror-lint-tooltip,reach-portal) a{color:hsl(var(--color-primary))}:is(.graphiql-container,.CodeMirror-info,.CodeMirror-lint-tooltip,reach-portal) a:focus{outline:hsl(var(--color-primary)) auto 1px}\n')();
function r$2(e2) {
  var t2, f2, n2 = "";
  if (typeof e2 == "string" || typeof e2 == "number")
    n2 += e2;
  else if (typeof e2 == "object")
    if (Array.isArray(e2))
      for (t2 = 0; t2 < e2.length; t2++)
        e2[t2] && (f2 = r$2(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
    else
      for (t2 in e2)
        e2[t2] && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
__name(r$2, "r$2");
function clsx() {
  for (var e2, t2, f2 = 0, n2 = ""; f2 < arguments.length; )
    (e2 = arguments[f2++]) && (t2 = r$2(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
__name(clsx, "clsx");
function isPromise(value3) {
  return typeof value3 === "object" && value3 !== null && typeof value3.then === "function";
}
__name(isPromise, "isPromise");
function observableToPromise(observable) {
  return new Promise((resolve, reject) => {
    const subscription = observable.subscribe({
      next: (v2) => {
        resolve(v2);
        subscription.unsubscribe();
      },
      error: reject,
      complete: () => {
        reject(new Error("no value resolved"));
      }
    });
  });
}
__name(observableToPromise, "observableToPromise");
function isObservable(value3) {
  return typeof value3 === "object" && value3 !== null && "subscribe" in value3 && typeof value3.subscribe === "function";
}
__name(isObservable, "isObservable");
function isAsyncIterable(input) {
  return typeof input === "object" && input !== null && (input[Symbol.toStringTag] === "AsyncGenerator" || Symbol.asyncIterator in input);
}
__name(isAsyncIterable, "isAsyncIterable");
function asyncIterableToPromise(input) {
  return new Promise((resolve, reject) => {
    var _a;
    const iteratorReturn = (_a = ("return" in input ? input : input[Symbol.asyncIterator]()).return) === null || _a === void 0 ? void 0 : _a.bind(input);
    const iteratorNext = ("next" in input ? input : input[Symbol.asyncIterator]()).next.bind(input);
    iteratorNext().then((result) => {
      resolve(result.value);
      iteratorReturn === null || iteratorReturn === void 0 ? void 0 : iteratorReturn();
    }).catch((err) => {
      reject(err);
    });
  });
}
__name(asyncIterableToPromise, "asyncIterableToPromise");
function fetcherReturnToPromise(fetcherResult) {
  return Promise.resolve(fetcherResult).then((result) => {
    if (isAsyncIterable(result)) {
      return asyncIterableToPromise(result);
    }
    if (isObservable(result)) {
      return observableToPromise(result);
    }
    return result;
  });
}
__name(fetcherReturnToPromise, "fetcherReturnToPromise");
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value3) {
    return value3 instanceof P ? value3 : new P(function(resolve) {
      resolve(value3);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value3) {
      try {
        step(generator.next(value3));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value3) {
      try {
        step(generator["throw"](value3));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __await = globalThis && globalThis.__await || function(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
};
globalThis && globalThis.__asyncValues || function(o2) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o2[Symbol.asyncIterator], i;
  return m2 ? m2.call(o2) : (o2 = typeof __values === "function" ? __values(o2) : o2[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n2) {
    i[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n2](v2), settle(resolve, reject, v2.done, v2.value);
      });
    };
  }
  __name(verb, "verb");
  function settle(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject);
  }
  __name(settle, "settle");
};
globalThis && globalThis.__asyncGenerator || function(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator)
    throw new TypeError("Symbol.asyncIterator is not defined.");
  var g2 = generator.apply(thisArg, _arguments || []), i, q2 = [];
  return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function verb(n2) {
    if (g2[n2])
      i[n2] = function(v2) {
        return new Promise(function(a2, b2) {
          q2.push([n2, v2, a2, b2]) > 1 || resume(n2, v2);
        });
      };
  }
  __name(verb, "verb");
  function resume(n2, v2) {
    try {
      step(g2[n2](v2));
    } catch (e2) {
      settle(q2[0][3], e2);
    }
  }
  __name(resume, "resume");
  function step(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle(q2[0][2], r2);
  }
  __name(step, "step");
  function fulfill(value3) {
    resume("next", value3);
  }
  __name(fulfill, "fulfill");
  function reject(value3) {
    resume("throw", value3);
  }
  __name(reject, "reject");
  function settle(f2, v2) {
    if (f2(v2), q2.shift(), q2.length)
      resume(q2[0][0], q2[0][1]);
  }
  __name(settle, "settle");
};
function stringify(obj) {
  return JSON.stringify(obj, null, 2);
}
__name(stringify, "stringify");
function formatSingleError(error2) {
  return Object.assign(Object.assign({}, error2), { message: error2.message, stack: error2.stack });
}
__name(formatSingleError, "formatSingleError");
function handleSingleError(error2) {
  if (error2 instanceof Error) {
    return formatSingleError(error2);
  }
  return error2;
}
__name(handleSingleError, "handleSingleError");
function formatError(error2) {
  if (Array.isArray(error2)) {
    return stringify({
      errors: error2.map((e2) => handleSingleError(e2))
    });
  }
  return stringify({ errors: [handleSingleError(error2)] });
}
__name(formatError, "formatError");
function formatResult(result) {
  return stringify(result);
}
__name(formatResult, "formatResult");
function fillLeafs(schema, docString, getDefaultFieldNames) {
  const insertions = [];
  if (!schema || !docString) {
    return { insertions, result: docString };
  }
  let ast2;
  try {
    ast2 = parse$2(docString);
  } catch (_a) {
    return { insertions, result: docString };
  }
  const fieldNameFn = getDefaultFieldNames || defaultGetDefaultFieldNames;
  const typeInfo = new TypeInfo(schema);
  visit$1(ast2, {
    leave(node) {
      typeInfo.leave(node);
    },
    enter(node) {
      typeInfo.enter(node);
      if (node.kind === "Field" && !node.selectionSet) {
        const fieldType = typeInfo.getType();
        const selectionSet = buildSelectionSet(isFieldType(fieldType), fieldNameFn);
        if (selectionSet && node.loc) {
          const indent2 = getIndentation(docString, node.loc.start);
          insertions.push({
            index: node.loc.end,
            string: " " + print$1(selectionSet).replaceAll("\n", "\n" + indent2)
          });
        }
      }
    }
  });
  return {
    insertions,
    result: withInsertions(docString, insertions)
  };
}
__name(fillLeafs, "fillLeafs");
function defaultGetDefaultFieldNames(type2) {
  if (!("getFields" in type2)) {
    return [];
  }
  const fields = type2.getFields();
  if (fields.id) {
    return ["id"];
  }
  if (fields.edges) {
    return ["edges"];
  }
  if (fields.node) {
    return ["node"];
  }
  const leafFieldNames = [];
  Object.keys(fields).forEach((fieldName) => {
    if (isLeafType$1(fields[fieldName].type)) {
      leafFieldNames.push(fieldName);
    }
  });
  return leafFieldNames;
}
__name(defaultGetDefaultFieldNames, "defaultGetDefaultFieldNames");
function buildSelectionSet(type2, getDefaultFieldNames) {
  const namedType = getNamedType(type2);
  if (!type2 || isLeafType$1(type2)) {
    return;
  }
  const fieldNames = getDefaultFieldNames(namedType);
  if (!Array.isArray(fieldNames) || fieldNames.length === 0 || !("getFields" in namedType)) {
    return;
  }
  return {
    kind: Kind$1.SELECTION_SET,
    selections: fieldNames.map((fieldName) => {
      const fieldDef = namedType.getFields()[fieldName];
      const fieldType = fieldDef ? fieldDef.type : null;
      return {
        kind: Kind$1.FIELD,
        name: {
          kind: Kind$1.NAME,
          value: fieldName
        },
        selectionSet: buildSelectionSet(fieldType, getDefaultFieldNames)
      };
    })
  };
}
__name(buildSelectionSet, "buildSelectionSet");
function withInsertions(initial, insertions) {
  if (insertions.length === 0) {
    return initial;
  }
  let edited = "";
  let prevIndex = 0;
  insertions.forEach(({ index, string }) => {
    edited += initial.slice(prevIndex, index) + string;
    prevIndex = index;
  });
  edited += initial.slice(prevIndex);
  return edited;
}
__name(withInsertions, "withInsertions");
function getIndentation(str, index) {
  let indentStart = index;
  let indentEnd = index;
  while (indentStart) {
    const c2 = str.charCodeAt(indentStart - 1);
    if (c2 === 10 || c2 === 13 || c2 === 8232 || c2 === 8233) {
      break;
    }
    indentStart--;
    if (c2 !== 9 && c2 !== 11 && c2 !== 12 && c2 !== 32 && c2 !== 160) {
      indentEnd = indentStart;
    }
  }
  return str.slice(indentStart, indentEnd);
}
__name(getIndentation, "getIndentation");
function isFieldType(fieldType) {
  if (fieldType) {
    return fieldType;
  }
}
__name(isFieldType, "isFieldType");
function uniqueBy(array, iteratee) {
  var _a;
  const FilteredMap = /* @__PURE__ */ new Map();
  const result = [];
  for (const item of array) {
    if (item.kind === "Field") {
      const uniqueValue = iteratee(item);
      const existing = FilteredMap.get(uniqueValue);
      if ((_a = item.directives) === null || _a === void 0 ? void 0 : _a.length) {
        const itemClone = Object.assign({}, item);
        result.push(itemClone);
      } else if ((existing === null || existing === void 0 ? void 0 : existing.selectionSet) && item.selectionSet) {
        existing.selectionSet.selections = [
          ...existing.selectionSet.selections,
          ...item.selectionSet.selections
        ];
      } else if (!existing) {
        const itemClone = Object.assign({}, item);
        FilteredMap.set(uniqueValue, itemClone);
        result.push(itemClone);
      }
    } else {
      result.push(item);
    }
  }
  return result;
}
__name(uniqueBy, "uniqueBy");
function inlineRelevantFragmentSpreads(fragmentDefinitions, selections, selectionSetType) {
  var _a;
  const selectionSetTypeName = selectionSetType ? getNamedType(selectionSetType).name : null;
  const outputSelections = [];
  const seenSpreads = [];
  for (let selection of selections) {
    if (selection.kind === "FragmentSpread") {
      const fragmentName = selection.name.value;
      if (!selection.directives || selection.directives.length === 0) {
        if (seenSpreads.includes(fragmentName)) {
          continue;
        } else {
          seenSpreads.push(fragmentName);
        }
      }
      const fragmentDefinition = fragmentDefinitions[selection.name.value];
      if (fragmentDefinition) {
        const { typeCondition, directives, selectionSet } = fragmentDefinition;
        selection = {
          kind: Kind$1.INLINE_FRAGMENT,
          typeCondition,
          directives,
          selectionSet
        };
      }
    }
    if (selection.kind === Kind$1.INLINE_FRAGMENT && (!selection.directives || ((_a = selection.directives) === null || _a === void 0 ? void 0 : _a.length) === 0)) {
      const fragmentTypeName = selection.typeCondition ? selection.typeCondition.name.value : null;
      if (!fragmentTypeName || fragmentTypeName === selectionSetTypeName) {
        outputSelections.push(...inlineRelevantFragmentSpreads(fragmentDefinitions, selection.selectionSet.selections, selectionSetType));
        continue;
      }
    }
    outputSelections.push(selection);
  }
  return outputSelections;
}
__name(inlineRelevantFragmentSpreads, "inlineRelevantFragmentSpreads");
function mergeAst(documentAST, schema) {
  const typeInfo = schema ? new TypeInfo(schema) : null;
  const fragmentDefinitions = /* @__PURE__ */ Object.create(null);
  for (const definition of documentAST.definitions) {
    if (definition.kind === Kind$1.FRAGMENT_DEFINITION) {
      fragmentDefinitions[definition.name.value] = definition;
    }
  }
  const visitors = {
    SelectionSet(node) {
      const selectionSetType = typeInfo ? typeInfo.getParentType() : null;
      let { selections } = node;
      selections = inlineRelevantFragmentSpreads(fragmentDefinitions, selections, selectionSetType);
      selections = uniqueBy(selections, (selection) => selection.alias ? selection.alias.value : selection.name.value);
      return Object.assign(Object.assign({}, node), { selections });
    },
    FragmentDefinition() {
      return null;
    }
  };
  return visit$1(documentAST, typeInfo ? visitWithTypeInfo(typeInfo, visitors) : visitors);
}
__name(mergeAst, "mergeAst");
function getSelectedOperationName(prevOperations, prevSelectedOperationName, operations) {
  if (!operations || operations.length < 1) {
    return;
  }
  const names = operations.map((op) => {
    var _a;
    return (_a = op.name) === null || _a === void 0 ? void 0 : _a.value;
  });
  if (prevSelectedOperationName && names.includes(prevSelectedOperationName)) {
    return prevSelectedOperationName;
  }
  if (prevSelectedOperationName && prevOperations) {
    const prevNames = prevOperations.map((op) => {
      var _a;
      return (_a = op.name) === null || _a === void 0 ? void 0 : _a.value;
    });
    const prevIndex = prevNames.indexOf(prevSelectedOperationName);
    if (prevIndex !== -1 && prevIndex < names.length) {
      return names[prevIndex];
    }
  }
  return names[0];
}
__name(getSelectedOperationName, "getSelectedOperationName");
function isQuotaError(storage, e2) {
  return e2 instanceof DOMException && (e2.code === 22 || e2.code === 1014 || e2.name === "QuotaExceededError" || e2.name === "NS_ERROR_DOM_QUOTA_REACHED") && storage.length !== 0;
}
__name(isQuotaError, "isQuotaError");
class StorageAPI {
  constructor(storage) {
    if (storage) {
      this.storage = storage;
    } else if (storage === null) {
      this.storage = null;
    } else if (typeof window === "undefined") {
      this.storage = null;
    } else {
      this.storage = {
        getItem: window.localStorage.getItem.bind(window.localStorage),
        setItem: window.localStorage.setItem.bind(window.localStorage),
        removeItem: window.localStorage.removeItem.bind(window.localStorage),
        get length() {
          let keys = 0;
          for (const key in window.localStorage) {
            if (key.indexOf(`${STORAGE_NAMESPACE}:`) === 0) {
              keys += 1;
            }
          }
          return keys;
        },
        clear: () => {
          for (const key in window.localStorage) {
            if (key.indexOf(`${STORAGE_NAMESPACE}:`) === 0) {
              window.localStorage.removeItem(key);
            }
          }
        }
      };
    }
  }
  get(name2) {
    if (!this.storage) {
      return null;
    }
    const key = `${STORAGE_NAMESPACE}:${name2}`;
    const value3 = this.storage.getItem(key);
    if (value3 === "null" || value3 === "undefined") {
      this.storage.removeItem(key);
      return null;
    }
    return value3 || null;
  }
  set(name2, value3) {
    let quotaError = false;
    let error2 = null;
    if (this.storage) {
      const key = `${STORAGE_NAMESPACE}:${name2}`;
      if (value3) {
        try {
          this.storage.setItem(key, value3);
        } catch (e2) {
          error2 = e2 instanceof Error ? e2 : new Error(`${e2}`);
          quotaError = isQuotaError(this.storage, e2);
        }
      } else {
        this.storage.removeItem(key);
      }
    }
    return { isQuotaError: quotaError, error: error2 };
  }
  clear() {
    if (this.storage) {
      this.storage.clear();
    }
  }
}
__name(StorageAPI, "StorageAPI");
const STORAGE_NAMESPACE = "graphiql";
class QueryStore {
  constructor(key, storage, maxSize = null) {
    this.key = key;
    this.storage = storage;
    this.maxSize = maxSize;
    this.items = this.fetchAll();
  }
  get length() {
    return this.items.length;
  }
  contains(item) {
    return this.items.some((x2) => x2.query === item.query && x2.variables === item.variables && x2.headers === item.headers && x2.operationName === item.operationName);
  }
  edit(item) {
    const itemIndex = this.items.findIndex((x2) => x2.query === item.query && x2.variables === item.variables && x2.headers === item.headers && x2.operationName === item.operationName);
    if (itemIndex !== -1) {
      this.items.splice(itemIndex, 1, item);
      this.save();
    }
  }
  delete(item) {
    const itemIndex = this.items.findIndex((x2) => x2.query === item.query && x2.variables === item.variables && x2.headers === item.headers && x2.operationName === item.operationName);
    if (itemIndex !== -1) {
      this.items.splice(itemIndex, 1);
      this.save();
    }
  }
  fetchRecent() {
    return this.items.at(-1);
  }
  fetchAll() {
    const raw = this.storage.get(this.key);
    if (raw) {
      return JSON.parse(raw)[this.key];
    }
    return [];
  }
  push(item) {
    const items = [...this.items, item];
    if (this.maxSize && items.length > this.maxSize) {
      items.shift();
    }
    for (let attempts = 0; attempts < 5; attempts++) {
      const response = this.storage.set(this.key, JSON.stringify({ [this.key]: items }));
      if (!(response === null || response === void 0 ? void 0 : response.error)) {
        this.items = items;
      } else if (response.isQuotaError && this.maxSize) {
        items.shift();
      } else {
        return;
      }
    }
  }
  save() {
    this.storage.set(this.key, JSON.stringify({ [this.key]: this.items }));
  }
}
__name(QueryStore, "QueryStore");
const MAX_QUERY_SIZE = 1e5;
class HistoryStore {
  constructor(storage, maxHistoryLength) {
    this.storage = storage;
    this.maxHistoryLength = maxHistoryLength;
    this.updateHistory = (query, variables, headers, operationName) => {
      if (this.shouldSaveQuery(query, variables, headers, this.history.fetchRecent())) {
        this.history.push({
          query,
          variables,
          headers,
          operationName
        });
        const historyQueries = this.history.items;
        const favoriteQueries = this.favorite.items;
        this.queries = historyQueries.concat(favoriteQueries);
      }
    };
    this.history = new QueryStore("queries", this.storage, this.maxHistoryLength);
    this.favorite = new QueryStore("favorites", this.storage, null);
    this.queries = [...this.history.fetchAll(), ...this.favorite.fetchAll()];
  }
  shouldSaveQuery(query, variables, headers, lastQuerySaved) {
    if (!query) {
      return false;
    }
    try {
      parse$2(query);
    } catch (_a) {
      return false;
    }
    if (query.length > MAX_QUERY_SIZE) {
      return false;
    }
    if (!lastQuerySaved) {
      return true;
    }
    if (JSON.stringify(query) === JSON.stringify(lastQuerySaved.query)) {
      if (JSON.stringify(variables) === JSON.stringify(lastQuerySaved.variables)) {
        if (JSON.stringify(headers) === JSON.stringify(lastQuerySaved.headers)) {
          return false;
        }
        if (headers && !lastQuerySaved.headers) {
          return false;
        }
      }
      if (variables && !lastQuerySaved.variables) {
        return false;
      }
    }
    return true;
  }
  toggleFavorite(query, variables, headers, operationName, label, favorite) {
    const item = {
      query,
      variables,
      headers,
      operationName,
      label
    };
    if (!this.favorite.contains(item)) {
      item.favorite = true;
      this.favorite.push(item);
    } else if (favorite) {
      item.favorite = false;
      this.favorite.delete(item);
    }
    this.queries = [...this.history.items, ...this.favorite.items];
  }
  editLabel(query, variables, headers, operationName, label, favorite) {
    const item = {
      query,
      variables,
      headers,
      operationName,
      label
    };
    if (favorite) {
      this.favorite.edit(Object.assign(Object.assign({}, item), { favorite }));
    } else {
      this.history.edit(item);
    }
    this.queries = [...this.history.items, ...this.favorite.items];
  }
}
__name(HistoryStore, "HistoryStore");
var __defProp$G = Object.defineProperty;
var __name$G = /* @__PURE__ */ __name((target2, value3) => __defProp$G(target2, "name", { value: value3, configurable: true }), "__name$G");
function createNullableContext(name2) {
  const context = createContext$1(null);
  context.displayName = name2;
  return context;
}
__name(createNullableContext, "createNullableContext");
__name$G(createNullableContext, "createNullableContext");
function createContextHook(context) {
  function useGivenContext(options) {
    var _a;
    const value3 = useContext(context);
    if (value3 === null && (options == null ? void 0 : options.nonNull)) {
      throw new Error(`Tried to use \`${((_a = options.caller) == null ? void 0 : _a.name) || useGivenContext.caller.name}\` without the necessary context. Make sure to render the \`${context.displayName}Provider\` component higher up the tree.`);
    }
    return value3;
  }
  __name(useGivenContext, "useGivenContext");
  __name$G(useGivenContext, "useGivenContext");
  Object.defineProperty(useGivenContext, "name", {
    value: `use${context.displayName}`
  });
  return useGivenContext;
}
__name(createContextHook, "createContextHook");
__name$G(createContextHook, "createContextHook");
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
__name(getDefaultExportFromCjs, "getDefaultExportFromCjs");
function getAugmentedNamespace(n2) {
  if (n2.__esModule)
    return n2;
  var a2 = Object.defineProperty({}, "__esModule", { value: true });
  Object.keys(n2).forEach(function(k2) {
    var d2 = Object.getOwnPropertyDescriptor(n2, k2);
    Object.defineProperty(a2, k2, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n2[k2];
      }
    });
  });
  return a2;
}
__name(getAugmentedNamespace, "getAugmentedNamespace");
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;
function toObject(val) {
  if (val === null || val === void 0) {
    throw new TypeError("Object.assign cannot be called with null or undefined");
  }
  return Object(val);
}
__name(toObject, "toObject");
function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    }
    var test1 = new String("abc");
    test1[5] = "de";
    if (Object.getOwnPropertyNames(test1)[0] === "5") {
      return false;
    }
    var test2 = {};
    for (var i = 0; i < 10; i++) {
      test2["_" + String.fromCharCode(i)] = i;
    }
    var order2 = Object.getOwnPropertyNames(test2).map(function(n2) {
      return test2[n2];
    });
    if (order2.join("") !== "0123456789") {
      return false;
    }
    var test3 = {};
    "abcdefghijklmnopqrst".split("").forEach(function(letter) {
      test3[letter] = letter;
    });
    if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
      return false;
    }
    return true;
  } catch (err) {
    return false;
  }
}
__name(shouldUseNative, "shouldUseNative");
shouldUseNative() ? Object.assign : function(target2, source) {
  var from;
  var to = toObject(target2);
  var symbols;
  for (var s2 = 1; s2 < arguments.length; s2++) {
    from = Object(arguments[s2]);
    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }
    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);
      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }
  return to;
};
/** @license React v17.0.2
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$2 = React__default, g$1 = 60103;
reactJsxRuntime_production_min.Fragment = 60107;
if (typeof Symbol === "function" && Symbol.for) {
  var h$1 = Symbol.for;
  g$1 = h$1("react.element");
  reactJsxRuntime_production_min.Fragment = h$1("react.fragment");
}
var m$1 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, n$2 = Object.prototype.hasOwnProperty, p$2 = { key: true, ref: true, __self: true, __source: true };
function q$1(c2, a2, k2) {
  var b2, d2 = {}, e2 = null, l2 = null;
  k2 !== void 0 && (e2 = "" + k2);
  a2.key !== void 0 && (e2 = "" + a2.key);
  a2.ref !== void 0 && (l2 = a2.ref);
  for (b2 in a2)
    n$2.call(a2, b2) && !p$2.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps)
    for (b2 in a2 = c2.defaultProps, a2)
      d2[b2] === void 0 && (d2[b2] = a2[b2]);
  return { $$typeof: g$1, type: c2, key: e2, ref: l2, props: d2, _owner: m$1.current };
}
__name(q$1, "q$1");
reactJsxRuntime_production_min.jsx = q$1;
reactJsxRuntime_production_min.jsxs = q$1;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
const jsx = jsxRuntime.exports.jsx;
const jsxs = jsxRuntime.exports.jsxs;
const Fragment = jsxRuntime.exports.Fragment;
var __defProp$F = Object.defineProperty;
var __name$F = /* @__PURE__ */ __name((target2, value3) => __defProp$F(target2, "name", { value: value3, configurable: true }), "__name$F");
const StorageContext = createNullableContext("StorageContext");
function StorageContextProvider(props2) {
  const isInitialRender = useRef(true);
  const [storage, setStorage] = useState(new StorageAPI(props2.storage));
  useEffect(() => {
    if (isInitialRender.current) {
      isInitialRender.current = false;
    } else {
      setStorage(new StorageAPI(props2.storage));
    }
  }, [props2.storage]);
  return /* @__PURE__ */ jsx(StorageContext.Provider, {
    value: storage,
    children: props2.children
  });
}
__name(StorageContextProvider, "StorageContextProvider");
__name$F(StorageContextProvider, "StorageContextProvider");
const useStorageContext = createContextHook(StorageContext);
const MAX_ARRAY_LENGTH = 10;
const MAX_RECURSIVE_DEPTH = 2;
function inspect(value3) {
  return formatValue(value3, []);
}
__name(inspect, "inspect");
function formatValue(value3, seenValues) {
  switch (typeof value3) {
    case "string":
      return JSON.stringify(value3);
    case "function":
      return value3.name ? `[function ${value3.name}]` : "[function]";
    case "object":
      return formatObjectValue(value3, seenValues);
    default:
      return String(value3);
  }
}
__name(formatValue, "formatValue");
function formatObjectValue(value3, previouslySeenValues) {
  if (value3 === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value3)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value3];
  if (isJSONable(value3)) {
    const jsonValue = value3.toJSON();
    if (jsonValue !== value3) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value3)) {
    return formatArray(value3, seenValues);
  }
  return formatObject(value3, seenValues);
}
__name(formatObjectValue, "formatObjectValue");
function isJSONable(value3) {
  return typeof value3.toJSON === "function";
}
__name(isJSONable, "isJSONable");
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(([key, value3]) => key + ": " + formatValue(value3, seenValues));
  return "{ " + properties.join(", ") + " }";
}
__name(formatObject, "formatObject");
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i = 0; i < len; ++i) {
    items.push(formatValue(array[i], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
__name(formatArray, "formatArray");
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name2 = object.constructor.name;
    if (typeof name2 === "string" && name2 !== "") {
      return name2;
    }
  }
  return tag;
}
__name(getObjectTag, "getObjectTag");
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message != null ? message : "Unexpected invariant triggered.");
  }
}
__name(invariant, "invariant");
let DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));
function isWhiteSpace$2(code3) {
  return code3 === 9 || code3 === 32;
}
__name(isWhiteSpace$2, "isWhiteSpace$2");
function isDigit$1(code3) {
  return code3 >= 48 && code3 <= 57;
}
__name(isDigit$1, "isDigit$1");
function isLetter$1(code3) {
  return code3 >= 97 && code3 <= 122 || code3 >= 65 && code3 <= 90;
}
__name(isLetter$1, "isLetter$1");
function isNameStart(code3) {
  return isLetter$1(code3) || code3 === 95;
}
__name(isNameStart, "isNameStart");
function isNameContinue(code3) {
  return isLetter$1(code3) || isDigit$1(code3) || code3 === 95;
}
__name(isNameContinue, "isNameContinue");
function printBlockString(value3, options) {
  const escapedValue = value3.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace$2(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value3.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value3.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && (!isSingleLine || value3.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace$2(value3.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}
__name(printBlockString, "printBlockString");
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
__name(printString, "printString");
const escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
__name(escapedReplacer, "escapedReplacer");
const escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}
__name(devAssert, "devAssert");
const QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
const kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
__name(isNode, "isNode");
let OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));
let Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));
const BREAK = Object.freeze({});
function visit(root2, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root2);
  let keys = [root2];
  let index = -1;
  let edits = [];
  let node = root2;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties({}, Object.getOwnPropertyDescriptors(node));
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root2;
}
__name(visit, "visit");
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}
__name(getEnterLeaveForKind, "getEnterLeaveForKind");
function print(ast2) {
  return visit(ast2, printDocASTReducer);
}
__name(print, "print");
const MAX_LINE_LENGTH = 80;
const printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join([
        node.operation,
        join([node.name, varDefs]),
        join(node.directives, " ")
      ], " ");
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type: type2, defaultValue: defaultValue2, directives }) => variable + ": " + type2 + wrap(" = ", defaultValue2) + wrap(" ", join(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block$2(selections)
  },
  Field: {
    leave({ alias, name: name2, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name2;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name: name2, value: value3 }) => name2 + ": " + value3
  },
  FragmentSpread: {
    leave: ({ name: name2, directives }) => "..." + name2 + wrap(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join([
      "...",
      wrap("on ", typeCondition),
      join(directives, " "),
      selectionSet
    ], " ")
  },
  FragmentDefinition: {
    leave: ({ name: name2, typeCondition, variableDefinitions, directives, selectionSet }) => `fragment ${name2}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
  },
  IntValue: {
    leave: ({ value: value3 }) => value3
  },
  FloatValue: {
    leave: ({ value: value3 }) => value3
  },
  StringValue: {
    leave: ({ value: value3, block: isBlockString }) => isBlockString ? printBlockString(value3) : printString(value3)
  },
  BooleanValue: {
    leave: ({ value: value3 }) => value3 ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value: value3 }) => value3
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name: name2, value: value3 }) => name2 + ": " + value3
  },
  Directive: {
    leave: ({ name: name2, arguments: args }) => "@" + name2 + wrap("(", join(args, ", "), ")")
  },
  NamedType: {
    leave: ({ name: name2 }) => name2
  },
  ListType: {
    leave: ({ type: type2 }) => "[" + type2 + "]"
  },
  NonNullType: {
    leave: ({ type: type2 }) => type2 + "!"
  },
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block$2(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type: type2 }) => operation + ": " + type2
  },
  ScalarTypeDefinition: {
    leave: ({ description, name: name2, directives }) => wrap("", description, "\n") + join(["scalar", name2, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name: name2, interfaces, directives, fields }) => wrap("", description, "\n") + join([
      "type",
      name2,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block$2(fields)
    ], " ")
  },
  FieldDefinition: {
    leave: ({ description, name: name2, arguments: args, type: type2, directives }) => wrap("", description, "\n") + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type2 + wrap(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name: name2, type: type2, defaultValue: defaultValue2, directives }) => wrap("", description, "\n") + join([name2 + ": " + type2, wrap("= ", defaultValue2), join(directives, " ")], " ")
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name: name2, interfaces, directives, fields }) => wrap("", description, "\n") + join([
      "interface",
      name2,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block$2(fields)
    ], " ")
  },
  UnionTypeDefinition: {
    leave: ({ description, name: name2, directives, types }) => wrap("", description, "\n") + join(["union", name2, join(directives, " "), wrap("= ", join(types, " | "))], " ")
  },
  EnumTypeDefinition: {
    leave: ({ description, name: name2, directives, values }) => wrap("", description, "\n") + join(["enum", name2, join(directives, " "), block$2(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name: name2, directives }) => wrap("", description, "\n") + join([name2, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name: name2, directives, fields }) => wrap("", description, "\n") + join(["input", name2, join(directives, " "), block$2(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name: name2, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name2 + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(["extend schema", join(directives, " "), block$2(operationTypes)], " ")
  },
  ScalarTypeExtension: {
    leave: ({ name: name2, directives }) => join(["extend scalar", name2, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name: name2, interfaces, directives, fields }) => join([
      "extend type",
      name2,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block$2(fields)
    ], " ")
  },
  InterfaceTypeExtension: {
    leave: ({ name: name2, interfaces, directives, fields }) => join([
      "extend interface",
      name2,
      wrap("implements ", join(interfaces, " & ")),
      join(directives, " "),
      block$2(fields)
    ], " ")
  },
  UnionTypeExtension: {
    leave: ({ name: name2, directives, types }) => join([
      "extend union",
      name2,
      join(directives, " "),
      wrap("= ", join(types, " | "))
    ], " ")
  },
  EnumTypeExtension: {
    leave: ({ name: name2, directives, values }) => join(["extend enum", name2, join(directives, " "), block$2(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name: name2, directives, fields }) => join(["extend input", name2, join(directives, " "), block$2(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x2) => x2).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
__name(join, "join");
function block$2(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
__name(block$2, "block$2");
function wrap(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
__name(wrap, "wrap");
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
__name(indent, "indent");
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}
__name(hasMultilineItems, "hasMultilineItems");
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}
__name(isIterableObject, "isIterableObject");
function isObjectLike(value3) {
  return typeof value3 == "object" && value3 !== null;
}
__name(isObjectLike, "isObjectLike");
const MAX_SUGGESTIONS = 5;
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x2) => `"${x2}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}
__name(didYouMean, "didYouMean");
function identityFunc(x2) {
  return x2;
}
__name(identityFunc, "identityFunc");
const instanceOf = /* @__PURE__ */ __name(function instanceOf2(value3, constructor) {
  return value3 instanceof constructor;
}, "instanceOf");
function keyMap(list3, keyFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list3) {
    result[keyFn(item)] = item;
  }
  return result;
}
__name(keyMap, "keyMap");
function keyValMap(list3, keyFn, valFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list3) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}
__name(keyValMap, "keyValMap");
function mapValue(map2, fn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map2)) {
    result[key] = fn(map2[key], key);
  }
  return result;
}
__name(mapValue, "mapValue");
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit(aChar) && isDigit(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
__name(naturalCompare, "naturalCompare");
const DIGIT_0 = 48;
const DIGIT_9 = 57;
function isDigit(code3) {
  return !isNaN(code3) && DIGIT_0 <= code3 && code3 <= DIGIT_9;
}
__name(isDigit, "isDigit");
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance2 = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance2.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a2, b2) => {
    const distanceDiff = optionsByDistance[a2] - optionsByDistance[b2];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a2, b2);
  });
}
__name(suggestionList, "suggestionList");
class LexicalDistance {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a2 = stringToArray(optionLowerCase);
    let b2 = this._inputArray;
    if (a2.length < b2.length) {
      const tmp = a2;
      a2 = b2;
      b2 = tmp;
    }
    const aLength = a2.length;
    const bLength = b2.length;
    if (aLength - bLength > threshold) {
      return void 0;
    }
    const rows = this._rows;
    for (let j = 0; j <= bLength; j++) {
      rows[0][j] = j;
    }
    for (let i = 1; i <= aLength; i++) {
      const upRow = rows[(i - 1) % 3];
      const currentRow = rows[i % 3];
      let smallestCell = currentRow[0] = i;
      for (let j = 1; j <= bLength; j++) {
        const cost = a2[i - 1] === b2[j - 1] ? 0 : 1;
        let currentCell = Math.min(upRow[j] + 1, currentRow[j - 1] + 1, upRow[j - 1] + cost);
        if (i > 1 && j > 1 && a2[i - 1] === b2[j - 2] && a2[i - 2] === b2[j - 1]) {
          const doubleDiagonalCell = rows[(i - 2) % 3][j - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j] = currentCell;
      }
      if (smallestCell > threshold) {
        return void 0;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : void 0;
  }
}
__name(LexicalDistance, "LexicalDistance");
function stringToArray(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i = 0; i < strLength; ++i) {
    array[i] = str.charCodeAt(i);
  }
  return array;
}
__name(stringToArray, "stringToArray");
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map2 = /* @__PURE__ */ Object.create(null);
  for (const [key, value3] of Object.entries(obj)) {
    map2[key] = value3;
  }
  return map2;
}
__name(toObjMap, "toObjMap");
const LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match2 of source.body.matchAll(LineRegExp)) {
    typeof match2.index === "number" || invariant(false);
    if (match2.index >= position) {
      break;
    }
    lastLineStart = match2.index + match2[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}
__name(getLocation, "getLocation");
function printLocation(location) {
  return printSourceLocation(location.source, getLocation(location.source, location.start));
}
__name(printLocation, "printLocation");
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i = 0; i < locationLine.length; i += 80) {
      subLines.push(locationLine.slice(i, i + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
__name(printSourceLocation, "printSourceLocation");
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}
__name(printPrefixedLines, "printPrefixedLines");
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
__name(toNormalizedOptions, "toNormalizedOptions");
class GraphQLError extends Error {
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref2;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== void 0 ? path : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0);
    const nodeLocations = undefinedIfEmpty((_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null));
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(originalError === null || originalError === void 0 ? void 0 : originalError.extensions) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref2 = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref2 !== void 0 ? _ref2 : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location of this.locations) {
        output += "\n\n" + printSourceLocation(this.source, location);
      }
    }
    return output;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
}
__name(GraphQLError, "GraphQLError");
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}
__name(undefinedIfEmpty, "undefinedIfEmpty");
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map((node) => valueFromASTUntyped(node, variables));
    case Kind.OBJECT:
      return keyValMap(valueNode.fields, (field) => field.name.value, (field) => valueFromASTUntyped(field.value, variables));
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}
__name(valueFromASTUntyped, "valueFromASTUntyped");
function assertName(name2) {
  name2 != null || devAssert(false, "Must provide name.");
  typeof name2 === "string" || devAssert(false, "Expected name to be a string.");
  if (name2.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i = 1; i < name2.length; ++i) {
    if (!isNameContinue(name2.charCodeAt(i))) {
      throw new GraphQLError(`Names must only contain [_a-zA-Z0-9] but "${name2}" does not.`);
    }
  }
  if (!isNameStart(name2.charCodeAt(0))) {
    throw new GraphQLError(`Names must start with [_a-zA-Z] but "${name2}" does not.`);
  }
  return name2;
}
__name(assertName, "assertName");
function assertEnumValueName(name2) {
  if (name2 === "true" || name2 === "false" || name2 === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name2}`);
  }
  return assertName(name2);
}
__name(assertEnumValueName, "assertEnumValueName");
function isType(type2) {
  return isScalarType(type2) || isObjectType(type2) || isInterfaceType(type2) || isUnionType(type2) || isEnumType(type2) || isInputObjectType(type2) || isListType(type2) || isNonNullType(type2);
}
__name(isType, "isType");
function isScalarType(type2) {
  return instanceOf(type2, GraphQLScalarType);
}
__name(isScalarType, "isScalarType");
function isObjectType(type2) {
  return instanceOf(type2, GraphQLObjectType);
}
__name(isObjectType, "isObjectType");
function isInterfaceType(type2) {
  return instanceOf(type2, GraphQLInterfaceType);
}
__name(isInterfaceType, "isInterfaceType");
function isUnionType(type2) {
  return instanceOf(type2, GraphQLUnionType);
}
__name(isUnionType, "isUnionType");
function isEnumType(type2) {
  return instanceOf(type2, GraphQLEnumType);
}
__name(isEnumType, "isEnumType");
function isInputObjectType(type2) {
  return instanceOf(type2, GraphQLInputObjectType);
}
__name(isInputObjectType, "isInputObjectType");
function isListType(type2) {
  return instanceOf(type2, GraphQLList);
}
__name(isListType, "isListType");
function isNonNullType(type2) {
  return instanceOf(type2, GraphQLNonNull);
}
__name(isNonNullType, "isNonNullType");
function isLeafType(type2) {
  return isScalarType(type2) || isEnumType(type2);
}
__name(isLeafType, "isLeafType");
function isAbstractType(type2) {
  return isInterfaceType(type2) || isUnionType(type2);
}
__name(isAbstractType, "isAbstractType");
class GraphQLList {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
}
__name(GraphQLList, "GraphQLList");
class GraphQLNonNull {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL nullable type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
}
__name(GraphQLNonNull, "GraphQLNonNull");
function isNullableType(type2) {
  return isType(type2) && !isNonNullType(type2);
}
__name(isNullableType, "isNullableType");
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
__name(resolveReadonlyArrayThunk, "resolveReadonlyArrayThunk");
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
__name(resolveObjMapThunk, "resolveObjMapThunk");
class GraphQLScalarType {
  constructor(config2) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue = (_config$parseValue = config2.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.specifiedByURL = config2.specifiedByURL;
    this.serialize = (_config$serialize = config2.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
    this.parseValue = parseValue;
    this.parseLiteral = (_config$parseLiteral = config2.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue(valueFromASTUntyped(node, variables));
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config2.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    config2.specifiedByURL == null || typeof config2.specifiedByURL === "string" || devAssert(false, `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config2.specifiedByURL)}.`);
    config2.serialize == null || typeof config2.serialize === "function" || devAssert(false, `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`);
    if (config2.parseLiteral) {
      typeof config2.parseValue === "function" && typeof config2.parseLiteral === "function" || devAssert(false, `${this.name} must provide both "parseValue" and "parseLiteral" functions.`);
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
__name(GraphQLScalarType, "GraphQLScalarType");
class GraphQLObjectType {
  constructor(config2) {
    var _config$extensionASTN2;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.isTypeOf = config2.isTypeOf;
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config2.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config2);
    this._interfaces = () => defineInterfaces(config2);
    config2.isTypeOf == null || typeof config2.isTypeOf === "function" || devAssert(false, `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config2.isTypeOf)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
__name(GraphQLObjectType, "GraphQLObjectType");
function defineInterfaces(config2) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk((_config$interfaces = config2.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []);
  Array.isArray(interfaces) || devAssert(false, `${config2.name} interfaces must be an Array or a function which returns an Array.`);
  return interfaces;
}
__name(defineInterfaces, "defineInterfaces");
function defineFieldMap(config2) {
  const fieldMap = resolveObjMapThunk(config2.fields);
  isPlainObj(fieldMap) || devAssert(false, `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`);
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(false, `${config2.name}.${fieldName} field config must be an object.`);
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(false, `${config2.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`);
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(false, `${config2.name}.${fieldName} args must be an object with argument names as keys.`);
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
__name(defineFieldMap, "defineFieldMap");
function defineArguments(config2) {
  return Object.entries(config2).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
__name(defineArguments, "defineArguments");
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
__name(isPlainObj, "isPlainObj");
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
}
__name(fieldsToFieldsConfig, "fieldsToFieldsConfig");
function argsToArgsConfig(args) {
  return keyValMap(args, (arg) => arg.name, (arg) => ({
    description: arg.description,
    type: arg.type,
    defaultValue: arg.defaultValue,
    deprecationReason: arg.deprecationReason,
    extensions: arg.extensions,
    astNode: arg.astNode
  }));
}
__name(argsToArgsConfig, "argsToArgsConfig");
class GraphQLInterfaceType {
  constructor(config2) {
    var _config$extensionASTN3;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.resolveType = config2.resolveType;
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config2.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(void 0, config2);
    this._interfaces = defineInterfaces.bind(void 0, config2);
    config2.resolveType == null || typeof config2.resolveType === "function" || devAssert(false, `${this.name} must provide "resolveType" as a function, but got: ${inspect(config2.resolveType)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
__name(GraphQLInterfaceType, "GraphQLInterfaceType");
class GraphQLUnionType {
  constructor(config2) {
    var _config$extensionASTN4;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.resolveType = config2.resolveType;
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config2.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(void 0, config2);
    config2.resolveType == null || typeof config2.resolveType === "function" || devAssert(false, `${this.name} must provide "resolveType" as a function, but got: ${inspect(config2.resolveType)}.`);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
__name(GraphQLUnionType, "GraphQLUnionType");
function defineTypes(config2) {
  const types = resolveReadonlyArrayThunk(config2.types);
  Array.isArray(types) || devAssert(false, `Must provide Array of types or a function which returns such an array for Union ${config2.name}.`);
  return types;
}
__name(defineTypes, "defineTypes");
class GraphQLEnumType {
  constructor(config2) {
    var _config$extensionASTN5;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config2.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
    this._values = defineEnumValues(this.name, config2.values);
    this._valueLookup = new Map(this._values.map((enumValue) => [enumValue.value, enumValue]));
    this._nameLookup = keyMap(this._values, (value3) => value3.name);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    return this._values;
  }
  getValue(name2) {
    return this._nameLookup[name2];
  }
  serialize(outputValue) {
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === void 0) {
      throw new GraphQLError(`Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`);
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(`Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr));
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(`Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue));
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print(valueNode);
      throw new GraphQLError(`Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr), {
        nodes: valueNode
      });
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print(valueNode);
      throw new GraphQLError(`Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr), {
        nodes: valueNode
      });
    }
    return enumValue.value;
  }
  toConfig() {
    const values = keyValMap(this.getValues(), (value3) => value3.name, (value3) => ({
      description: value3.description,
      value: value3.value,
      deprecationReason: value3.deprecationReason,
      extensions: value3.extensions,
      astNode: value3.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
__name(GraphQLEnumType, "GraphQLEnumType");
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value3) => value3.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
__name(didYouMeanEnumValue, "didYouMeanEnumValue");
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(false, `${typeName} values must be an object with value names as keys.`);
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(false, `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`);
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
__name(defineEnumValues, "defineEnumValues");
class GraphQLInputObjectType {
  constructor(config2) {
    var _config$extensionASTN6;
    this.name = assertName(config2.name);
    this.description = config2.description;
    this.extensions = toObjMap(config2.extensions);
    this.astNode = config2.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config2.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
    this._fields = defineInputFieldMap.bind(void 0, config2);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
}
__name(GraphQLInputObjectType, "GraphQLInputObjectType");
function defineInputFieldMap(config2) {
  const fieldMap = resolveObjMapThunk(config2.fields);
  isPlainObj(fieldMap) || devAssert(false, `${config2.name} fields must be an object with field names as keys or a function which returns such an object.`);
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(false, `${config2.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`);
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
__name(defineInputFieldMap, "defineInputFieldMap");
const GRAPHQL_MAX_INT = 2147483647;
const GRAPHQL_MIN_INT = -2147483648;
const GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num2 = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num2 = Number(coercedValue);
    }
    if (typeof num2 !== "number" || !Number.isInteger(num2)) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(coercedValue)}`);
    }
    if (num2 > GRAPHQL_MAX_INT || num2 < GRAPHQL_MIN_INT) {
      throw new GraphQLError("Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue));
    }
    return num2;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${inspect(inputValue)}`);
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${inputValue}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(`Int cannot represent non-integer value: ${print(valueNode)}`, {
        nodes: valueNode
      });
    }
    const num2 = parseInt(valueNode.value, 10);
    if (num2 > GRAPHQL_MAX_INT || num2 < GRAPHQL_MIN_INT) {
      throw new GraphQLError(`Int cannot represent non 32-bit signed integer value: ${valueNode.value}`, {
        nodes: valueNode
      });
    }
    return num2;
  }
});
const GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num2 = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num2 = Number(coercedValue);
    }
    if (typeof num2 !== "number" || !Number.isFinite(num2)) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(coercedValue)}`);
    }
    return num2;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${inspect(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(`Float cannot represent non numeric value: ${print(valueNode)}`, valueNode);
    }
    return parseFloat(valueNode.value);
  }
});
const GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(`String cannot represent value: ${inspect(outputValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(`String cannot represent a non string value: ${inspect(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(`String cannot represent a non string value: ${print(valueNode)}`, {
        nodes: valueNode
      });
    }
    return valueNode.value;
  }
});
const GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${inspect(inputValue)}`);
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(`Boolean cannot represent a non boolean value: ${print(valueNode)}`, {
        nodes: valueNode
      });
    }
    return valueNode.value;
  }
});
const GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(outputValue)}`);
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError("ID cannot represent a non-string and non-integer value: " + print(valueNode), {
        nodes: valueNode
      });
    }
    return valueNode.value;
  }
});
Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}
__name(serializeObject, "serializeObject");
function astFromValue(value3, type2) {
  if (isNonNullType(type2)) {
    const astValue = astFromValue(value3, type2.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value3 === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value3 === void 0) {
    return null;
  }
  if (isListType(type2)) {
    const itemType = type2.ofType;
    if (isIterableObject(value3)) {
      const valuesNodes = [];
      for (const item of value3) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value3, itemType);
  }
  if (isInputObjectType(type2)) {
    if (!isObjectLike(value3)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type2.getFields())) {
      const fieldValue = astFromValue(value3[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type2)) {
    const serialized = type2.serialize(value3);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type2)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type2 === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type2));
}
__name(astFromValue, "astFromValue");
const integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;
const __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Directive))),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
const __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive2) => directive2.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive2) => directive2.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive2) => directive2.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__DirectiveLocation))),
      resolve: (directive2) => directive2.locations
    },
    args: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
const __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
const __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type2) {
        if (isScalarType(type2)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type2)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type2)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type2)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type2)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type2)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type2)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type2)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type2)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type2) => "name" in type2 ? type2.name : void 0
    },
    description: {
      type: GraphQLString,
      resolve: (type2) => "description" in type2 ? type2.description : void 0
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isObjectType(type2) || isInterfaceType(type2)) {
          const fields = Object.values(type2.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type2) {
        if (isObjectType(type2) || isInterfaceType(type2)) {
          return type2.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type2, _args, _context, { schema }) {
        if (isAbstractType(type2)) {
          return schema.getPossibleTypes(type2);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isEnumType(type2)) {
          const values = type2.getValues();
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type2, { includeDeprecated }) {
        if (isInputObjectType(type2)) {
          const values = Object.values(type2.getFields());
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type2) => "ofType" in type2 ? type2.ofType : void 0
    }
  })
});
const __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__InputValue))),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
const __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type: type2, defaultValue: defaultValue2 } = inputValue;
        const valueAST = astFromValue(defaultValue2, type2);
        return valueAST ? print(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
const __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
let TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
const __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
const SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
const TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: void 0,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: void 0,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    }
  ],
  resolve: (_source, { name: name2 }, _context, { schema }) => schema.getType(name2),
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
const TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);
function getDefinitionState(tokenState) {
  let definitionState;
  forEachState(tokenState, (state2) => {
    switch (state2.kind) {
      case "Query":
      case "ShortQuery":
      case "Mutation":
      case "Subscription":
      case "FragmentDefinition":
        definitionState = state2;
        break;
    }
  });
  return definitionState;
}
__name(getDefinitionState, "getDefinitionState");
function getFieldDef(schema, type2, fieldName) {
  if (fieldName === SchemaMetaFieldDef.name && schema.getQueryType() === type2) {
    return SchemaMetaFieldDef;
  }
  if (fieldName === TypeMetaFieldDef.name && schema.getQueryType() === type2) {
    return TypeMetaFieldDef;
  }
  if (fieldName === TypeNameMetaFieldDef.name && isCompositeType(type2)) {
    return TypeNameMetaFieldDef;
  }
  if ("getFields" in type2) {
    return type2.getFields()[fieldName];
  }
  return null;
}
__name(getFieldDef, "getFieldDef");
function forEachState(stack, fn) {
  const reverseStateStack = [];
  let state2 = stack;
  while (state2 === null || state2 === void 0 ? void 0 : state2.kind) {
    reverseStateStack.push(state2);
    state2 = state2.prevState;
  }
  for (let i = reverseStateStack.length - 1; i >= 0; i--) {
    fn(reverseStateStack[i]);
  }
}
__name(forEachState, "forEachState");
function objectValues(object) {
  const keys = Object.keys(object);
  const len = keys.length;
  const values = new Array(len);
  for (let i = 0; i < len; ++i) {
    values[i] = object[keys[i]];
  }
  return values;
}
__name(objectValues, "objectValues");
function hintList(token2, list3) {
  return filterAndSortList(list3, normalizeText(token2.string));
}
__name(hintList, "hintList");
function filterAndSortList(list3, text3) {
  if (!text3) {
    return filterNonEmpty(list3, (entry) => !entry.isDeprecated);
  }
  const byProximity = list3.map((entry) => ({
    proximity: getProximity(normalizeText(entry.label), text3),
    entry
  }));
  return filterNonEmpty(filterNonEmpty(byProximity, (pair) => pair.proximity <= 2), (pair) => !pair.entry.isDeprecated).sort((a2, b2) => (a2.entry.isDeprecated ? 1 : 0) - (b2.entry.isDeprecated ? 1 : 0) || a2.proximity - b2.proximity || a2.entry.label.length - b2.entry.label.length).map((pair) => pair.entry);
}
__name(filterAndSortList, "filterAndSortList");
function filterNonEmpty(array, predicate) {
  const filtered = array.filter(predicate);
  return filtered.length === 0 ? array : filtered;
}
__name(filterNonEmpty, "filterNonEmpty");
function normalizeText(text3) {
  return text3.toLowerCase().replaceAll(/\W/g, "");
}
__name(normalizeText, "normalizeText");
function getProximity(suggestion, text3) {
  let proximity = lexicalDistance(text3, suggestion);
  if (suggestion.length > text3.length) {
    proximity -= suggestion.length - text3.length - 1;
    proximity += suggestion.indexOf(text3) === 0 ? 0 : 0.5;
  }
  return proximity;
}
__name(getProximity, "getProximity");
function lexicalDistance(a2, b2) {
  let i;
  let j;
  const d2 = [];
  const aLength = a2.length;
  const bLength = b2.length;
  for (i = 0; i <= aLength; i++) {
    d2[i] = [i];
  }
  for (j = 1; j <= bLength; j++) {
    d2[0][j] = j;
  }
  for (i = 1; i <= aLength; i++) {
    for (j = 1; j <= bLength; j++) {
      const cost = a2[i - 1] === b2[j - 1] ? 0 : 1;
      d2[i][j] = Math.min(d2[i - 1][j] + 1, d2[i][j - 1] + 1, d2[i - 1][j - 1] + cost);
      if (i > 1 && j > 1 && a2[i - 1] === b2[j - 2] && a2[i - 2] === b2[j - 1]) {
        d2[i][j] = Math.min(d2[i][j], d2[i - 2][j - 2] + cost);
      }
    }
  }
  return d2[aLength][bLength];
}
__name(lexicalDistance, "lexicalDistance");
var DocumentUri;
(function(DocumentUri2) {
  function is(value3) {
    return typeof value3 === "string";
  }
  __name(is, "is");
  DocumentUri2.is = is;
})(DocumentUri || (DocumentUri = {}));
var URI;
(function(URI2) {
  function is(value3) {
    return typeof value3 === "string";
  }
  __name(is, "is");
  URI2.is = is;
})(URI || (URI = {}));
var integer;
(function(integer2) {
  integer2.MIN_VALUE = -2147483648;
  integer2.MAX_VALUE = 2147483647;
  function is(value3) {
    return typeof value3 === "number" && integer2.MIN_VALUE <= value3 && value3 <= integer2.MAX_VALUE;
  }
  __name(is, "is");
  integer2.is = is;
})(integer || (integer = {}));
var uinteger;
(function(uinteger2) {
  uinteger2.MIN_VALUE = 0;
  uinteger2.MAX_VALUE = 2147483647;
  function is(value3) {
    return typeof value3 === "number" && uinteger2.MIN_VALUE <= value3 && value3 <= uinteger2.MAX_VALUE;
  }
  __name(is, "is");
  uinteger2.is = is;
})(uinteger || (uinteger = {}));
var Position;
(function(Position2) {
  function create(line, character) {
    if (line === Number.MAX_VALUE) {
      line = uinteger.MAX_VALUE;
    }
    if (character === Number.MAX_VALUE) {
      character = uinteger.MAX_VALUE;
    }
    return { line, character };
  }
  __name(create, "create");
  Position2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
  }
  __name(is, "is");
  Position2.is = is;
})(Position || (Position = {}));
var Range;
(function(Range2) {
  function create(one, two, three, four) {
    if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
      return { start: Position.create(one, two), end: Position.create(three, four) };
    } else if (Position.is(one) && Position.is(two)) {
      return { start: one, end: two };
    } else {
      throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
    }
  }
  __name(create, "create");
  Range2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
  }
  __name(is, "is");
  Range2.is = is;
})(Range || (Range = {}));
var Location;
(function(Location2) {
  function create(uri, range2) {
    return { uri, range: range2 };
  }
  __name(create, "create");
  Location2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.defined(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
  }
  __name(is, "is");
  Location2.is = is;
})(Location || (Location = {}));
var LocationLink;
(function(LocationLink2) {
  function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
    return { targetUri, targetRange, targetSelectionRange, originSelectionRange };
  }
  __name(create, "create");
  LocationLink2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.defined(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
  }
  __name(is, "is");
  LocationLink2.is = is;
})(LocationLink || (LocationLink = {}));
var Color;
(function(Color2) {
  function create(red, green, blue, alpha2) {
    return {
      red,
      green,
      blue,
      alpha: alpha2
    };
  }
  __name(create, "create");
  Color2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
  }
  __name(is, "is");
  Color2.is = is;
})(Color || (Color = {}));
var ColorInformation;
(function(ColorInformation2) {
  function create(range2, color) {
    return {
      range: range2,
      color
    };
  }
  __name(create, "create");
  ColorInformation2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
  }
  __name(is, "is");
  ColorInformation2.is = is;
})(ColorInformation || (ColorInformation = {}));
var ColorPresentation;
(function(ColorPresentation2) {
  function create(label, textEdit, additionalTextEdits) {
    return {
      label,
      textEdit,
      additionalTextEdits
    };
  }
  __name(create, "create");
  ColorPresentation2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
  }
  __name(is, "is");
  ColorPresentation2.is = is;
})(ColorPresentation || (ColorPresentation = {}));
var FoldingRangeKind;
(function(FoldingRangeKind2) {
  FoldingRangeKind2.Comment = "comment";
  FoldingRangeKind2.Imports = "imports";
  FoldingRangeKind2.Region = "region";
})(FoldingRangeKind || (FoldingRangeKind = {}));
var FoldingRange;
(function(FoldingRange2) {
  function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
    var result = {
      startLine,
      endLine
    };
    if (Is.defined(startCharacter)) {
      result.startCharacter = startCharacter;
    }
    if (Is.defined(endCharacter)) {
      result.endCharacter = endCharacter;
    }
    if (Is.defined(kind)) {
      result.kind = kind;
    }
    if (Is.defined(collapsedText)) {
      result.collapsedText = collapsedText;
    }
    return result;
  }
  __name(create, "create");
  FoldingRange2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
  }
  __name(is, "is");
  FoldingRange2.is = is;
})(FoldingRange || (FoldingRange = {}));
var DiagnosticRelatedInformation;
(function(DiagnosticRelatedInformation2) {
  function create(location, message) {
    return {
      location,
      message
    };
  }
  __name(create, "create");
  DiagnosticRelatedInformation2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
  }
  __name(is, "is");
  DiagnosticRelatedInformation2.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
var DiagnosticSeverity;
(function(DiagnosticSeverity2) {
  DiagnosticSeverity2.Error = 1;
  DiagnosticSeverity2.Warning = 2;
  DiagnosticSeverity2.Information = 3;
  DiagnosticSeverity2.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
var DiagnosticTag;
(function(DiagnosticTag2) {
  DiagnosticTag2.Unnecessary = 1;
  DiagnosticTag2.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
var CodeDescription;
(function(CodeDescription2) {
  function is(value3) {
    var candidate = value3;
    return Is.objectLiteral(candidate) && Is.string(candidate.href);
  }
  __name(is, "is");
  CodeDescription2.is = is;
})(CodeDescription || (CodeDescription = {}));
var Diagnostic;
(function(Diagnostic2) {
  function create(range2, message, severity, code3, source, relatedInformation) {
    var result = { range: range2, message };
    if (Is.defined(severity)) {
      result.severity = severity;
    }
    if (Is.defined(code3)) {
      result.code = code3;
    }
    if (Is.defined(source)) {
      result.source = source;
    }
    if (Is.defined(relatedInformation)) {
      result.relatedInformation = relatedInformation;
    }
    return result;
  }
  __name(create, "create");
  Diagnostic2.create = create;
  function is(value3) {
    var _a;
    var candidate = value3;
    return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
  }
  __name(is, "is");
  Diagnostic2.is = is;
})(Diagnostic || (Diagnostic = {}));
var Command;
(function(Command2) {
  function create(title, command) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i];
    }
    var result = { title, command };
    if (Is.defined(args) && args.length > 0) {
      result.arguments = args;
    }
    return result;
  }
  __name(create, "create");
  Command2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
  }
  __name(is, "is");
  Command2.is = is;
})(Command || (Command = {}));
var TextEdit;
(function(TextEdit2) {
  function replace2(range2, newText) {
    return { range: range2, newText };
  }
  __name(replace2, "replace");
  TextEdit2.replace = replace2;
  function insert(position, newText) {
    return { range: { start: position, end: position }, newText };
  }
  __name(insert, "insert");
  TextEdit2.insert = insert;
  function del(range2) {
    return { range: range2, newText: "" };
  }
  __name(del, "del");
  TextEdit2.del = del;
  function is(value3) {
    var candidate = value3;
    return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
  }
  __name(is, "is");
  TextEdit2.is = is;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function(ChangeAnnotation2) {
  function create(label, needsConfirmation, description) {
    var result = { label };
    if (needsConfirmation !== void 0) {
      result.needsConfirmation = needsConfirmation;
    }
    if (description !== void 0) {
      result.description = description;
    }
    return result;
  }
  __name(create, "create");
  ChangeAnnotation2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
  }
  __name(is, "is");
  ChangeAnnotation2.is = is;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function(ChangeAnnotationIdentifier2) {
  function is(value3) {
    var candidate = value3;
    return Is.string(candidate);
  }
  __name(is, "is");
  ChangeAnnotationIdentifier2.is = is;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function(AnnotatedTextEdit2) {
  function replace2(range2, newText, annotation) {
    return { range: range2, newText, annotationId: annotation };
  }
  __name(replace2, "replace");
  AnnotatedTextEdit2.replace = replace2;
  function insert(position, newText, annotation) {
    return { range: { start: position, end: position }, newText, annotationId: annotation };
  }
  __name(insert, "insert");
  AnnotatedTextEdit2.insert = insert;
  function del(range2, annotation) {
    return { range: range2, newText: "", annotationId: annotation };
  }
  __name(del, "del");
  AnnotatedTextEdit2.del = del;
  function is(value3) {
    var candidate = value3;
    return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  __name(is, "is");
  AnnotatedTextEdit2.is = is;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
var TextDocumentEdit;
(function(TextDocumentEdit2) {
  function create(textDocument, edits) {
    return { textDocument, edits };
  }
  __name(create, "create");
  TextDocumentEdit2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
  }
  __name(is, "is");
  TextDocumentEdit2.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function(CreateFile2) {
  function create(uri, options, annotation) {
    var result = {
      kind: "create",
      uri
    };
    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
      result.options = options;
    }
    if (annotation !== void 0) {
      result.annotationId = annotation;
    }
    return result;
  }
  __name(create, "create");
  CreateFile2.create = create;
  function is(value3) {
    var candidate = value3;
    return candidate && candidate.kind === "create" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  __name(is, "is");
  CreateFile2.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function(RenameFile2) {
  function create(oldUri, newUri, options, annotation) {
    var result = {
      kind: "rename",
      oldUri,
      newUri
    };
    if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
      result.options = options;
    }
    if (annotation !== void 0) {
      result.annotationId = annotation;
    }
    return result;
  }
  __name(create, "create");
  RenameFile2.create = create;
  function is(value3) {
    var candidate = value3;
    return candidate && candidate.kind === "rename" && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === void 0 || (candidate.options.overwrite === void 0 || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  __name(is, "is");
  RenameFile2.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function(DeleteFile2) {
  function create(uri, options, annotation) {
    var result = {
      kind: "delete",
      uri
    };
    if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
      result.options = options;
    }
    if (annotation !== void 0) {
      result.annotationId = annotation;
    }
    return result;
  }
  __name(create, "create");
  DeleteFile2.create = create;
  function is(value3) {
    var candidate = value3;
    return candidate && candidate.kind === "delete" && Is.string(candidate.uri) && (candidate.options === void 0 || (candidate.options.recursive === void 0 || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === void 0 || ChangeAnnotationIdentifier.is(candidate.annotationId));
  }
  __name(is, "is");
  DeleteFile2.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function(WorkspaceEdit2) {
  function is(value3) {
    var candidate = value3;
    return candidate && (candidate.changes !== void 0 || candidate.documentChanges !== void 0) && (candidate.documentChanges === void 0 || candidate.documentChanges.every(function(change) {
      if (Is.string(change.kind)) {
        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
      } else {
        return TextDocumentEdit.is(change);
      }
    }));
  }
  __name(is, "is");
  WorkspaceEdit2.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = function() {
  function TextEditChangeImpl2(edits, changeAnnotations) {
    this.edits = edits;
    this.changeAnnotations = changeAnnotations;
  }
  __name(TextEditChangeImpl2, "TextEditChangeImpl");
  TextEditChangeImpl2.prototype.insert = function(position, newText, annotation) {
    var edit;
    var id2;
    if (annotation === void 0) {
      edit = TextEdit.insert(position, newText);
    } else if (ChangeAnnotationIdentifier.is(annotation)) {
      id2 = annotation;
      edit = AnnotatedTextEdit.insert(position, newText, annotation);
    } else {
      this.assertChangeAnnotations(this.changeAnnotations);
      id2 = this.changeAnnotations.manage(annotation);
      edit = AnnotatedTextEdit.insert(position, newText, id2);
    }
    this.edits.push(edit);
    if (id2 !== void 0) {
      return id2;
    }
  };
  TextEditChangeImpl2.prototype.replace = function(range2, newText, annotation) {
    var edit;
    var id2;
    if (annotation === void 0) {
      edit = TextEdit.replace(range2, newText);
    } else if (ChangeAnnotationIdentifier.is(annotation)) {
      id2 = annotation;
      edit = AnnotatedTextEdit.replace(range2, newText, annotation);
    } else {
      this.assertChangeAnnotations(this.changeAnnotations);
      id2 = this.changeAnnotations.manage(annotation);
      edit = AnnotatedTextEdit.replace(range2, newText, id2);
    }
    this.edits.push(edit);
    if (id2 !== void 0) {
      return id2;
    }
  };
  TextEditChangeImpl2.prototype.delete = function(range2, annotation) {
    var edit;
    var id2;
    if (annotation === void 0) {
      edit = TextEdit.del(range2);
    } else if (ChangeAnnotationIdentifier.is(annotation)) {
      id2 = annotation;
      edit = AnnotatedTextEdit.del(range2, annotation);
    } else {
      this.assertChangeAnnotations(this.changeAnnotations);
      id2 = this.changeAnnotations.manage(annotation);
      edit = AnnotatedTextEdit.del(range2, id2);
    }
    this.edits.push(edit);
    if (id2 !== void 0) {
      return id2;
    }
  };
  TextEditChangeImpl2.prototype.add = function(edit) {
    this.edits.push(edit);
  };
  TextEditChangeImpl2.prototype.all = function() {
    return this.edits;
  };
  TextEditChangeImpl2.prototype.clear = function() {
    this.edits.splice(0, this.edits.length);
  };
  TextEditChangeImpl2.prototype.assertChangeAnnotations = function(value3) {
    if (value3 === void 0) {
      throw new Error("Text edit change is not configured to manage change annotations.");
    }
  };
  return TextEditChangeImpl2;
}();
var ChangeAnnotations = function() {
  function ChangeAnnotations2(annotations) {
    this._annotations = annotations === void 0 ? /* @__PURE__ */ Object.create(null) : annotations;
    this._counter = 0;
    this._size = 0;
  }
  __name(ChangeAnnotations2, "ChangeAnnotations");
  ChangeAnnotations2.prototype.all = function() {
    return this._annotations;
  };
  Object.defineProperty(ChangeAnnotations2.prototype, "size", {
    get: function() {
      return this._size;
    },
    enumerable: false,
    configurable: true
  });
  ChangeAnnotations2.prototype.manage = function(idOrAnnotation, annotation) {
    var id2;
    if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
      id2 = idOrAnnotation;
    } else {
      id2 = this.nextId();
      annotation = idOrAnnotation;
    }
    if (this._annotations[id2] !== void 0) {
      throw new Error("Id ".concat(id2, " is already in use."));
    }
    if (annotation === void 0) {
      throw new Error("No annotation provided for id ".concat(id2));
    }
    this._annotations[id2] = annotation;
    this._size++;
    return id2;
  };
  ChangeAnnotations2.prototype.nextId = function() {
    this._counter++;
    return this._counter.toString();
  };
  return ChangeAnnotations2;
}();
(function() {
  function WorkspaceChange(workspaceEdit) {
    var _this = this;
    this._textEditChanges = /* @__PURE__ */ Object.create(null);
    if (workspaceEdit !== void 0) {
      this._workspaceEdit = workspaceEdit;
      if (workspaceEdit.documentChanges) {
        this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
        workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        workspaceEdit.documentChanges.forEach(function(change) {
          if (TextDocumentEdit.is(change)) {
            var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
            _this._textEditChanges[change.textDocument.uri] = textEditChange;
          }
        });
      } else if (workspaceEdit.changes) {
        Object.keys(workspaceEdit.changes).forEach(function(key) {
          var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
          _this._textEditChanges[key] = textEditChange;
        });
      }
    } else {
      this._workspaceEdit = {};
    }
  }
  __name(WorkspaceChange, "WorkspaceChange");
  Object.defineProperty(WorkspaceChange.prototype, "edit", {
    get: function() {
      this.initDocumentChanges();
      if (this._changeAnnotations !== void 0) {
        if (this._changeAnnotations.size === 0) {
          this._workspaceEdit.changeAnnotations = void 0;
        } else {
          this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
      }
      return this._workspaceEdit;
    },
    enumerable: false,
    configurable: true
  });
  WorkspaceChange.prototype.getTextEditChange = function(key) {
    if (OptionalVersionedTextDocumentIdentifier.is(key)) {
      this.initDocumentChanges();
      if (this._workspaceEdit.documentChanges === void 0) {
        throw new Error("Workspace edit is not configured for document changes.");
      }
      var textDocument = { uri: key.uri, version: key.version };
      var result = this._textEditChanges[textDocument.uri];
      if (!result) {
        var edits = [];
        var textDocumentEdit = {
          textDocument,
          edits
        };
        this._workspaceEdit.documentChanges.push(textDocumentEdit);
        result = new TextEditChangeImpl(edits, this._changeAnnotations);
        this._textEditChanges[textDocument.uri] = result;
      }
      return result;
    } else {
      this.initChanges();
      if (this._workspaceEdit.changes === void 0) {
        throw new Error("Workspace edit is not configured for normal text edit changes.");
      }
      var result = this._textEditChanges[key];
      if (!result) {
        var edits = [];
        this._workspaceEdit.changes[key] = edits;
        result = new TextEditChangeImpl(edits);
        this._textEditChanges[key] = result;
      }
      return result;
    }
  };
  WorkspaceChange.prototype.initDocumentChanges = function() {
    if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
      this._changeAnnotations = new ChangeAnnotations();
      this._workspaceEdit.documentChanges = [];
      this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
    }
  };
  WorkspaceChange.prototype.initChanges = function() {
    if (this._workspaceEdit.documentChanges === void 0 && this._workspaceEdit.changes === void 0) {
      this._workspaceEdit.changes = /* @__PURE__ */ Object.create(null);
    }
  };
  WorkspaceChange.prototype.createFile = function(uri, optionsOrAnnotation, options) {
    this.initDocumentChanges();
    if (this._workspaceEdit.documentChanges === void 0) {
      throw new Error("Workspace edit is not configured for document changes.");
    }
    var annotation;
    if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
      annotation = optionsOrAnnotation;
    } else {
      options = optionsOrAnnotation;
    }
    var operation;
    var id2;
    if (annotation === void 0) {
      operation = CreateFile.create(uri, options);
    } else {
      id2 = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
      operation = CreateFile.create(uri, options, id2);
    }
    this._workspaceEdit.documentChanges.push(operation);
    if (id2 !== void 0) {
      return id2;
    }
  };
  WorkspaceChange.prototype.renameFile = function(oldUri, newUri, optionsOrAnnotation, options) {
    this.initDocumentChanges();
    if (this._workspaceEdit.documentChanges === void 0) {
      throw new Error("Workspace edit is not configured for document changes.");
    }
    var annotation;
    if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
      annotation = optionsOrAnnotation;
    } else {
      options = optionsOrAnnotation;
    }
    var operation;
    var id2;
    if (annotation === void 0) {
      operation = RenameFile.create(oldUri, newUri, options);
    } else {
      id2 = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
      operation = RenameFile.create(oldUri, newUri, options, id2);
    }
    this._workspaceEdit.documentChanges.push(operation);
    if (id2 !== void 0) {
      return id2;
    }
  };
  WorkspaceChange.prototype.deleteFile = function(uri, optionsOrAnnotation, options) {
    this.initDocumentChanges();
    if (this._workspaceEdit.documentChanges === void 0) {
      throw new Error("Workspace edit is not configured for document changes.");
    }
    var annotation;
    if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
      annotation = optionsOrAnnotation;
    } else {
      options = optionsOrAnnotation;
    }
    var operation;
    var id2;
    if (annotation === void 0) {
      operation = DeleteFile.create(uri, options);
    } else {
      id2 = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
      operation = DeleteFile.create(uri, options, id2);
    }
    this._workspaceEdit.documentChanges.push(operation);
    if (id2 !== void 0) {
      return id2;
    }
  };
  return WorkspaceChange;
})();
var TextDocumentIdentifier;
(function(TextDocumentIdentifier2) {
  function create(uri) {
    return { uri };
  }
  __name(create, "create");
  TextDocumentIdentifier2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.defined(candidate) && Is.string(candidate.uri);
  }
  __name(is, "is");
  TextDocumentIdentifier2.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
var VersionedTextDocumentIdentifier;
(function(VersionedTextDocumentIdentifier2) {
  function create(uri, version) {
    return { uri, version };
  }
  __name(create, "create");
  VersionedTextDocumentIdentifier2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
  }
  __name(is, "is");
  VersionedTextDocumentIdentifier2.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
var OptionalVersionedTextDocumentIdentifier;
(function(OptionalVersionedTextDocumentIdentifier2) {
  function create(uri, version) {
    return { uri, version };
  }
  __name(create, "create");
  OptionalVersionedTextDocumentIdentifier2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
  }
  __name(is, "is");
  OptionalVersionedTextDocumentIdentifier2.is = is;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
var TextDocumentItem;
(function(TextDocumentItem2) {
  function create(uri, languageId, version, text3) {
    return { uri, languageId, version, text: text3 };
  }
  __name(create, "create");
  TextDocumentItem2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
  }
  __name(is, "is");
  TextDocumentItem2.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
var MarkupKind;
(function(MarkupKind2) {
  MarkupKind2.PlainText = "plaintext";
  MarkupKind2.Markdown = "markdown";
  function is(value3) {
    var candidate = value3;
    return candidate === MarkupKind2.PlainText || candidate === MarkupKind2.Markdown;
  }
  __name(is, "is");
  MarkupKind2.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function(MarkupContent2) {
  function is(value3) {
    var candidate = value3;
    return Is.objectLiteral(value3) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
  }
  __name(is, "is");
  MarkupContent2.is = is;
})(MarkupContent || (MarkupContent = {}));
var CompletionItemKind$1;
(function(CompletionItemKind2) {
  CompletionItemKind2.Text = 1;
  CompletionItemKind2.Method = 2;
  CompletionItemKind2.Function = 3;
  CompletionItemKind2.Constructor = 4;
  CompletionItemKind2.Field = 5;
  CompletionItemKind2.Variable = 6;
  CompletionItemKind2.Class = 7;
  CompletionItemKind2.Interface = 8;
  CompletionItemKind2.Module = 9;
  CompletionItemKind2.Property = 10;
  CompletionItemKind2.Unit = 11;
  CompletionItemKind2.Value = 12;
  CompletionItemKind2.Enum = 13;
  CompletionItemKind2.Keyword = 14;
  CompletionItemKind2.Snippet = 15;
  CompletionItemKind2.Color = 16;
  CompletionItemKind2.File = 17;
  CompletionItemKind2.Reference = 18;
  CompletionItemKind2.Folder = 19;
  CompletionItemKind2.EnumMember = 20;
  CompletionItemKind2.Constant = 21;
  CompletionItemKind2.Struct = 22;
  CompletionItemKind2.Event = 23;
  CompletionItemKind2.Operator = 24;
  CompletionItemKind2.TypeParameter = 25;
})(CompletionItemKind$1 || (CompletionItemKind$1 = {}));
var InsertTextFormat;
(function(InsertTextFormat2) {
  InsertTextFormat2.PlainText = 1;
  InsertTextFormat2.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
var CompletionItemTag;
(function(CompletionItemTag2) {
  CompletionItemTag2.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
var InsertReplaceEdit;
(function(InsertReplaceEdit2) {
  function create(newText, insert, replace2) {
    return { newText, insert, replace: replace2 };
  }
  __name(create, "create");
  InsertReplaceEdit2.create = create;
  function is(value3) {
    var candidate = value3;
    return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
  }
  __name(is, "is");
  InsertReplaceEdit2.is = is;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
var InsertTextMode;
(function(InsertTextMode2) {
  InsertTextMode2.asIs = 1;
  InsertTextMode2.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
var CompletionItemLabelDetails;
(function(CompletionItemLabelDetails2) {
  function is(value3) {
    var candidate = value3;
    return candidate && (Is.string(candidate.detail) || candidate.detail === void 0) && (Is.string(candidate.description) || candidate.description === void 0);
  }
  __name(is, "is");
  CompletionItemLabelDetails2.is = is;
})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
var CompletionItem;
(function(CompletionItem2) {
  function create(label) {
    return { label };
  }
  __name(create, "create");
  CompletionItem2.create = create;
})(CompletionItem || (CompletionItem = {}));
var CompletionList;
(function(CompletionList2) {
  function create(items, isIncomplete) {
    return { items: items ? items : [], isIncomplete: !!isIncomplete };
  }
  __name(create, "create");
  CompletionList2.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function(MarkedString2) {
  function fromPlainText(plainText) {
    return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
  }
  __name(fromPlainText, "fromPlainText");
  MarkedString2.fromPlainText = fromPlainText;
  function is(value3) {
    var candidate = value3;
    return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
  }
  __name(is, "is");
  MarkedString2.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function(Hover2) {
  function is(value3) {
    var candidate = value3;
    return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value3.range === void 0 || Range.is(value3.range));
  }
  __name(is, "is");
  Hover2.is = is;
})(Hover || (Hover = {}));
var ParameterInformation;
(function(ParameterInformation2) {
  function create(label, documentation) {
    return documentation ? { label, documentation } : { label };
  }
  __name(create, "create");
  ParameterInformation2.create = create;
})(ParameterInformation || (ParameterInformation = {}));
var SignatureInformation;
(function(SignatureInformation2) {
  function create(label, documentation) {
    var parameters = [];
    for (var _i = 2; _i < arguments.length; _i++) {
      parameters[_i - 2] = arguments[_i];
    }
    var result = { label };
    if (Is.defined(documentation)) {
      result.documentation = documentation;
    }
    if (Is.defined(parameters)) {
      result.parameters = parameters;
    } else {
      result.parameters = [];
    }
    return result;
  }
  __name(create, "create");
  SignatureInformation2.create = create;
})(SignatureInformation || (SignatureInformation = {}));
var DocumentHighlightKind;
(function(DocumentHighlightKind2) {
  DocumentHighlightKind2.Text = 1;
  DocumentHighlightKind2.Read = 2;
  DocumentHighlightKind2.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
var DocumentHighlight;
(function(DocumentHighlight2) {
  function create(range2, kind) {
    var result = { range: range2 };
    if (Is.number(kind)) {
      result.kind = kind;
    }
    return result;
  }
  __name(create, "create");
  DocumentHighlight2.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
var SymbolKind;
(function(SymbolKind2) {
  SymbolKind2.File = 1;
  SymbolKind2.Module = 2;
  SymbolKind2.Namespace = 3;
  SymbolKind2.Package = 4;
  SymbolKind2.Class = 5;
  SymbolKind2.Method = 6;
  SymbolKind2.Property = 7;
  SymbolKind2.Field = 8;
  SymbolKind2.Constructor = 9;
  SymbolKind2.Enum = 10;
  SymbolKind2.Interface = 11;
  SymbolKind2.Function = 12;
  SymbolKind2.Variable = 13;
  SymbolKind2.Constant = 14;
  SymbolKind2.String = 15;
  SymbolKind2.Number = 16;
  SymbolKind2.Boolean = 17;
  SymbolKind2.Array = 18;
  SymbolKind2.Object = 19;
  SymbolKind2.Key = 20;
  SymbolKind2.Null = 21;
  SymbolKind2.EnumMember = 22;
  SymbolKind2.Struct = 23;
  SymbolKind2.Event = 24;
  SymbolKind2.Operator = 25;
  SymbolKind2.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
var SymbolTag;
(function(SymbolTag2) {
  SymbolTag2.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function(SymbolInformation2) {
  function create(name2, kind, range2, uri, containerName) {
    var result = {
      name: name2,
      kind,
      location: { uri, range: range2 }
    };
    if (containerName) {
      result.containerName = containerName;
    }
    return result;
  }
  __name(create, "create");
  SymbolInformation2.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var WorkspaceSymbol;
(function(WorkspaceSymbol2) {
  function create(name2, kind, uri, range2) {
    return range2 !== void 0 ? { name: name2, kind, location: { uri, range: range2 } } : { name: name2, kind, location: { uri } };
  }
  __name(create, "create");
  WorkspaceSymbol2.create = create;
})(WorkspaceSymbol || (WorkspaceSymbol = {}));
var DocumentSymbol;
(function(DocumentSymbol2) {
  function create(name2, detail, kind, range2, selectionRange, children) {
    var result = {
      name: name2,
      detail,
      kind,
      range: range2,
      selectionRange
    };
    if (children !== void 0) {
      result.children = children;
    }
    return result;
  }
  __name(create, "create");
  DocumentSymbol2.create = create;
  function is(value3) {
    var candidate = value3;
    return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === void 0 || Is.string(candidate.detail)) && (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) && (candidate.children === void 0 || Array.isArray(candidate.children)) && (candidate.tags === void 0 || Array.isArray(candidate.tags));
  }
  __name(is, "is");
  DocumentSymbol2.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
var CodeActionKind;
(function(CodeActionKind2) {
  CodeActionKind2.Empty = "";
  CodeActionKind2.QuickFix = "quickfix";
  CodeActionKind2.Refactor = "refactor";
  CodeActionKind2.RefactorExtract = "refactor.extract";
  CodeActionKind2.RefactorInline = "refactor.inline";
  CodeActionKind2.RefactorRewrite = "refactor.rewrite";
  CodeActionKind2.Source = "source";
  CodeActionKind2.SourceOrganizeImports = "source.organizeImports";
  CodeActionKind2.SourceFixAll = "source.fixAll";
})(CodeActionKind || (CodeActionKind = {}));
var CodeActionTriggerKind;
(function(CodeActionTriggerKind2) {
  CodeActionTriggerKind2.Invoked = 1;
  CodeActionTriggerKind2.Automatic = 2;
})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
var CodeActionContext;
(function(CodeActionContext2) {
  function create(diagnostics, only, triggerKind) {
    var result = { diagnostics };
    if (only !== void 0 && only !== null) {
      result.only = only;
    }
    if (triggerKind !== void 0 && triggerKind !== null) {
      result.triggerKind = triggerKind;
    }
    return result;
  }
  __name(create, "create");
  CodeActionContext2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === void 0 || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
  }
  __name(is, "is");
  CodeActionContext2.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function(CodeAction2) {
  function create(title, kindOrCommandOrEdit, kind) {
    var result = { title };
    var checkKind = true;
    if (typeof kindOrCommandOrEdit === "string") {
      checkKind = false;
      result.kind = kindOrCommandOrEdit;
    } else if (Command.is(kindOrCommandOrEdit)) {
      result.command = kindOrCommandOrEdit;
    } else {
      result.edit = kindOrCommandOrEdit;
    }
    if (checkKind && kind !== void 0) {
      result.kind = kind;
    }
    return result;
  }
  __name(create, "create");
  CodeAction2.create = create;
  function is(value3) {
    var candidate = value3;
    return candidate && Is.string(candidate.title) && (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === void 0 || Is.string(candidate.kind)) && (candidate.edit !== void 0 || candidate.command !== void 0) && (candidate.command === void 0 || Command.is(candidate.command)) && (candidate.isPreferred === void 0 || Is.boolean(candidate.isPreferred)) && (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
  }
  __name(is, "is");
  CodeAction2.is = is;
})(CodeAction || (CodeAction = {}));
var CodeLens;
(function(CodeLens2) {
  function create(range2, data) {
    var result = { range: range2 };
    if (Is.defined(data)) {
      result.data = data;
    }
    return result;
  }
  __name(create, "create");
  CodeLens2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
  }
  __name(is, "is");
  CodeLens2.is = is;
})(CodeLens || (CodeLens = {}));
var FormattingOptions;
(function(FormattingOptions2) {
  function create(tabSize, insertSpaces) {
    return { tabSize, insertSpaces };
  }
  __name(create, "create");
  FormattingOptions2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
  }
  __name(is, "is");
  FormattingOptions2.is = is;
})(FormattingOptions || (FormattingOptions = {}));
var DocumentLink;
(function(DocumentLink2) {
  function create(range2, target2, data) {
    return { range: range2, target: target2, data };
  }
  __name(create, "create");
  DocumentLink2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
  }
  __name(is, "is");
  DocumentLink2.is = is;
})(DocumentLink || (DocumentLink = {}));
var SelectionRange;
(function(SelectionRange2) {
  function create(range2, parent) {
    return { range: range2, parent };
  }
  __name(create, "create");
  SelectionRange2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === void 0 || SelectionRange2.is(candidate.parent));
  }
  __name(is, "is");
  SelectionRange2.is = is;
})(SelectionRange || (SelectionRange = {}));
var SemanticTokenTypes;
(function(SemanticTokenTypes2) {
  SemanticTokenTypes2["namespace"] = "namespace";
  SemanticTokenTypes2["type"] = "type";
  SemanticTokenTypes2["class"] = "class";
  SemanticTokenTypes2["enum"] = "enum";
  SemanticTokenTypes2["interface"] = "interface";
  SemanticTokenTypes2["struct"] = "struct";
  SemanticTokenTypes2["typeParameter"] = "typeParameter";
  SemanticTokenTypes2["parameter"] = "parameter";
  SemanticTokenTypes2["variable"] = "variable";
  SemanticTokenTypes2["property"] = "property";
  SemanticTokenTypes2["enumMember"] = "enumMember";
  SemanticTokenTypes2["event"] = "event";
  SemanticTokenTypes2["function"] = "function";
  SemanticTokenTypes2["method"] = "method";
  SemanticTokenTypes2["macro"] = "macro";
  SemanticTokenTypes2["keyword"] = "keyword";
  SemanticTokenTypes2["modifier"] = "modifier";
  SemanticTokenTypes2["comment"] = "comment";
  SemanticTokenTypes2["string"] = "string";
  SemanticTokenTypes2["number"] = "number";
  SemanticTokenTypes2["regexp"] = "regexp";
  SemanticTokenTypes2["operator"] = "operator";
  SemanticTokenTypes2["decorator"] = "decorator";
})(SemanticTokenTypes || (SemanticTokenTypes = {}));
var SemanticTokenModifiers;
(function(SemanticTokenModifiers2) {
  SemanticTokenModifiers2["declaration"] = "declaration";
  SemanticTokenModifiers2["definition"] = "definition";
  SemanticTokenModifiers2["readonly"] = "readonly";
  SemanticTokenModifiers2["static"] = "static";
  SemanticTokenModifiers2["deprecated"] = "deprecated";
  SemanticTokenModifiers2["abstract"] = "abstract";
  SemanticTokenModifiers2["async"] = "async";
  SemanticTokenModifiers2["modification"] = "modification";
  SemanticTokenModifiers2["documentation"] = "documentation";
  SemanticTokenModifiers2["defaultLibrary"] = "defaultLibrary";
})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
var SemanticTokens;
(function(SemanticTokens2) {
  function is(value3) {
    var candidate = value3;
    return Is.objectLiteral(candidate) && (candidate.resultId === void 0 || typeof candidate.resultId === "string") && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === "number");
  }
  __name(is, "is");
  SemanticTokens2.is = is;
})(SemanticTokens || (SemanticTokens = {}));
var InlineValueText;
(function(InlineValueText2) {
  function create(range2, text3) {
    return { range: range2, text: text3 };
  }
  __name(create, "create");
  InlineValueText2.create = create;
  function is(value3) {
    var candidate = value3;
    return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
  }
  __name(is, "is");
  InlineValueText2.is = is;
})(InlineValueText || (InlineValueText = {}));
var InlineValueVariableLookup;
(function(InlineValueVariableLookup2) {
  function create(range2, variableName, caseSensitiveLookup) {
    return { range: range2, variableName, caseSensitiveLookup };
  }
  __name(create, "create");
  InlineValueVariableLookup2.create = create;
  function is(value3) {
    var candidate = value3;
    return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === void 0);
  }
  __name(is, "is");
  InlineValueVariableLookup2.is = is;
})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
var InlineValueEvaluatableExpression;
(function(InlineValueEvaluatableExpression2) {
  function create(range2, expression) {
    return { range: range2, expression };
  }
  __name(create, "create");
  InlineValueEvaluatableExpression2.create = create;
  function is(value3) {
    var candidate = value3;
    return candidate !== void 0 && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === void 0);
  }
  __name(is, "is");
  InlineValueEvaluatableExpression2.is = is;
})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
var InlineValueContext;
(function(InlineValueContext2) {
  function create(frameId, stoppedLocation) {
    return { frameId, stoppedLocation };
  }
  __name(create, "create");
  InlineValueContext2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.defined(candidate) && Range.is(value3.stoppedLocation);
  }
  __name(is, "is");
  InlineValueContext2.is = is;
})(InlineValueContext || (InlineValueContext = {}));
var InlayHintKind;
(function(InlayHintKind2) {
  InlayHintKind2.Type = 1;
  InlayHintKind2.Parameter = 2;
  function is(value3) {
    return value3 === 1 || value3 === 2;
  }
  __name(is, "is");
  InlayHintKind2.is = is;
})(InlayHintKind || (InlayHintKind = {}));
var InlayHintLabelPart;
(function(InlayHintLabelPart2) {
  function create(value3) {
    return { value: value3 };
  }
  __name(create, "create");
  InlayHintLabelPart2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.objectLiteral(candidate) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === void 0 || Location.is(candidate.location)) && (candidate.command === void 0 || Command.is(candidate.command));
  }
  __name(is, "is");
  InlayHintLabelPart2.is = is;
})(InlayHintLabelPart || (InlayHintLabelPart = {}));
var InlayHint;
(function(InlayHint2) {
  function create(position, label, kind) {
    var result = { position, label };
    if (kind !== void 0) {
      result.kind = kind;
    }
    return result;
  }
  __name(create, "create");
  InlayHint2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === void 0 || InlayHintKind.is(candidate.kind)) && candidate.textEdits === void 0 || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === void 0 || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === void 0 || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === void 0 || Is.boolean(candidate.paddingRight));
  }
  __name(is, "is");
  InlayHint2.is = is;
})(InlayHint || (InlayHint = {}));
var WorkspaceFolder;
(function(WorkspaceFolder2) {
  function is(value3) {
    var candidate = value3;
    return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
  }
  __name(is, "is");
  WorkspaceFolder2.is = is;
})(WorkspaceFolder || (WorkspaceFolder = {}));
var TextDocument;
(function(TextDocument2) {
  function create(uri, languageId, version, content) {
    return new FullTextDocument(uri, languageId, version, content);
  }
  __name(create, "create");
  TextDocument2.create = create;
  function is(value3) {
    var candidate = value3;
    return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
  }
  __name(is, "is");
  TextDocument2.is = is;
  function applyEdits(document2, edits) {
    var text3 = document2.getText();
    var sortedEdits = mergeSort(edits, function(a2, b2) {
      var diff = a2.range.start.line - b2.range.start.line;
      if (diff === 0) {
        return a2.range.start.character - b2.range.start.character;
      }
      return diff;
    });
    var lastModifiedOffset = text3.length;
    for (var i = sortedEdits.length - 1; i >= 0; i--) {
      var e2 = sortedEdits[i];
      var startOffset = document2.offsetAt(e2.range.start);
      var endOffset = document2.offsetAt(e2.range.end);
      if (endOffset <= lastModifiedOffset) {
        text3 = text3.substring(0, startOffset) + e2.newText + text3.substring(endOffset, text3.length);
      } else {
        throw new Error("Overlapping edit");
      }
      lastModifiedOffset = startOffset;
    }
    return text3;
  }
  __name(applyEdits, "applyEdits");
  TextDocument2.applyEdits = applyEdits;
  function mergeSort(data, compare) {
    if (data.length <= 1) {
      return data;
    }
    var p2 = data.length / 2 | 0;
    var left = data.slice(0, p2);
    var right = data.slice(p2);
    mergeSort(left, compare);
    mergeSort(right, compare);
    var leftIdx = 0;
    var rightIdx = 0;
    var i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
      var ret = compare(left[leftIdx], right[rightIdx]);
      if (ret <= 0) {
        data[i++] = left[leftIdx++];
      } else {
        data[i++] = right[rightIdx++];
      }
    }
    while (leftIdx < left.length) {
      data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
      data[i++] = right[rightIdx++];
    }
    return data;
  }
  __name(mergeSort, "mergeSort");
})(TextDocument || (TextDocument = {}));
var FullTextDocument = function() {
  function FullTextDocument2(uri, languageId, version, content) {
    this._uri = uri;
    this._languageId = languageId;
    this._version = version;
    this._content = content;
    this._lineOffsets = void 0;
  }
  __name(FullTextDocument2, "FullTextDocument");
  Object.defineProperty(FullTextDocument2.prototype, "uri", {
    get: function() {
      return this._uri;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FullTextDocument2.prototype, "languageId", {
    get: function() {
      return this._languageId;
    },
    enumerable: false,
    configurable: true
  });
  Object.defineProperty(FullTextDocument2.prototype, "version", {
    get: function() {
      return this._version;
    },
    enumerable: false,
    configurable: true
  });
  FullTextDocument2.prototype.getText = function(range2) {
    if (range2) {
      var start = this.offsetAt(range2.start);
      var end = this.offsetAt(range2.end);
      return this._content.substring(start, end);
    }
    return this._content;
  };
  FullTextDocument2.prototype.update = function(event, version) {
    this._content = event.text;
    this._version = version;
    this._lineOffsets = void 0;
  };
  FullTextDocument2.prototype.getLineOffsets = function() {
    if (this._lineOffsets === void 0) {
      var lineOffsets = [];
      var text3 = this._content;
      var isLineStart = true;
      for (var i = 0; i < text3.length; i++) {
        if (isLineStart) {
          lineOffsets.push(i);
          isLineStart = false;
        }
        var ch = text3.charAt(i);
        isLineStart = ch === "\r" || ch === "\n";
        if (ch === "\r" && i + 1 < text3.length && text3.charAt(i + 1) === "\n") {
          i++;
        }
      }
      if (isLineStart && text3.length > 0) {
        lineOffsets.push(text3.length);
      }
      this._lineOffsets = lineOffsets;
    }
    return this._lineOffsets;
  };
  FullTextDocument2.prototype.positionAt = function(offset) {
    offset = Math.max(Math.min(offset, this._content.length), 0);
    var lineOffsets = this.getLineOffsets();
    var low = 0, high = lineOffsets.length;
    if (high === 0) {
      return Position.create(0, offset);
    }
    while (low < high) {
      var mid2 = Math.floor((low + high) / 2);
      if (lineOffsets[mid2] > offset) {
        high = mid2;
      } else {
        low = mid2 + 1;
      }
    }
    var line = low - 1;
    return Position.create(line, offset - lineOffsets[line]);
  };
  FullTextDocument2.prototype.offsetAt = function(position) {
    var lineOffsets = this.getLineOffsets();
    if (position.line >= lineOffsets.length) {
      return this._content.length;
    } else if (position.line < 0) {
      return 0;
    }
    var lineOffset = lineOffsets[position.line];
    var nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
    return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
  };
  Object.defineProperty(FullTextDocument2.prototype, "lineCount", {
    get: function() {
      return this.getLineOffsets().length;
    },
    enumerable: false,
    configurable: true
  });
  return FullTextDocument2;
}();
var Is;
(function(Is2) {
  var toString = Object.prototype.toString;
  function defined(value3) {
    return typeof value3 !== "undefined";
  }
  __name(defined, "defined");
  Is2.defined = defined;
  function undefined$1(value3) {
    return typeof value3 === "undefined";
  }
  __name(undefined$1, "undefined$1");
  Is2.undefined = undefined$1;
  function boolean(value3) {
    return value3 === true || value3 === false;
  }
  __name(boolean, "boolean");
  Is2.boolean = boolean;
  function string(value3) {
    return toString.call(value3) === "[object String]";
  }
  __name(string, "string");
  Is2.string = string;
  function number(value3) {
    return toString.call(value3) === "[object Number]";
  }
  __name(number, "number");
  Is2.number = number;
  function numberRange(value3, min, max) {
    return toString.call(value3) === "[object Number]" && min <= value3 && value3 <= max;
  }
  __name(numberRange, "numberRange");
  Is2.numberRange = numberRange;
  function integer2(value3) {
    return toString.call(value3) === "[object Number]" && -2147483648 <= value3 && value3 <= 2147483647;
  }
  __name(integer2, "integer");
  Is2.integer = integer2;
  function uinteger2(value3) {
    return toString.call(value3) === "[object Number]" && 0 <= value3 && value3 <= 2147483647;
  }
  __name(uinteger2, "uinteger");
  Is2.uinteger = uinteger2;
  function func(value3) {
    return toString.call(value3) === "[object Function]";
  }
  __name(func, "func");
  Is2.func = func;
  function objectLiteral(value3) {
    return value3 !== null && typeof value3 === "object";
  }
  __name(objectLiteral, "objectLiteral");
  Is2.objectLiteral = objectLiteral;
  function typedArray(value3, check2) {
    return Array.isArray(value3) && value3.every(check2);
  }
  __name(typedArray, "typedArray");
  Is2.typedArray = typedArray;
})(Is || (Is = {}));
var CompletionItemKind;
(function(CompletionItemKind2) {
  CompletionItemKind2.Text = 1;
  CompletionItemKind2.Method = 2;
  CompletionItemKind2.Function = 3;
  CompletionItemKind2.Constructor = 4;
  CompletionItemKind2.Field = 5;
  CompletionItemKind2.Variable = 6;
  CompletionItemKind2.Class = 7;
  CompletionItemKind2.Interface = 8;
  CompletionItemKind2.Module = 9;
  CompletionItemKind2.Property = 10;
  CompletionItemKind2.Unit = 11;
  CompletionItemKind2.Value = 12;
  CompletionItemKind2.Enum = 13;
  CompletionItemKind2.Keyword = 14;
  CompletionItemKind2.Snippet = 15;
  CompletionItemKind2.Color = 16;
  CompletionItemKind2.File = 17;
  CompletionItemKind2.Reference = 18;
  CompletionItemKind2.Folder = 19;
  CompletionItemKind2.EnumMember = 20;
  CompletionItemKind2.Constant = 21;
  CompletionItemKind2.Struct = 22;
  CompletionItemKind2.Event = 23;
  CompletionItemKind2.Operator = 24;
  CompletionItemKind2.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
class CharacterStream {
  constructor(sourceText) {
    this.getStartOfToken = () => this._start;
    this.getCurrentPosition = () => this._pos;
    this.eol = () => this._sourceText.length === this._pos;
    this.sol = () => this._pos === 0;
    this.peek = () => {
      return this._sourceText.charAt(this._pos) || null;
    };
    this.next = () => {
      const char = this._sourceText.charAt(this._pos);
      this._pos++;
      return char;
    };
    this.eat = (pattern) => {
      const isMatched = this._testNextCharacter(pattern);
      if (isMatched) {
        this._start = this._pos;
        this._pos++;
        return this._sourceText.charAt(this._pos - 1);
      }
      return void 0;
    };
    this.eatWhile = (match2) => {
      let isMatched = this._testNextCharacter(match2);
      let didEat = false;
      if (isMatched) {
        didEat = isMatched;
        this._start = this._pos;
      }
      while (isMatched) {
        this._pos++;
        isMatched = this._testNextCharacter(match2);
        didEat = true;
      }
      return didEat;
    };
    this.eatSpace = () => this.eatWhile(/[\s\u00a0]/);
    this.skipToEnd = () => {
      this._pos = this._sourceText.length;
    };
    this.skipTo = (position) => {
      this._pos = position;
    };
    this.match = (pattern, consume = true, caseFold = false) => {
      let token2 = null;
      let match2 = null;
      if (typeof pattern === "string") {
        const regex2 = new RegExp(pattern, caseFold ? "i" : "g");
        match2 = regex2.test(this._sourceText.slice(this._pos, this._pos + pattern.length));
        token2 = pattern;
      } else if (pattern instanceof RegExp) {
        match2 = this._sourceText.slice(this._pos).match(pattern);
        token2 = match2 === null || match2 === void 0 ? void 0 : match2[0];
      }
      if (match2 != null && (typeof pattern === "string" || match2 instanceof Array && this._sourceText.startsWith(match2[0], this._pos))) {
        if (consume) {
          this._start = this._pos;
          if (token2 && token2.length) {
            this._pos += token2.length;
          }
        }
        return match2;
      }
      return false;
    };
    this.backUp = (num2) => {
      this._pos -= num2;
    };
    this.column = () => this._pos;
    this.indentation = () => {
      const match2 = this._sourceText.match(/\s*/);
      let indent2 = 0;
      if (match2 && match2.length !== 0) {
        const whiteSpaces = match2[0];
        let pos = 0;
        while (whiteSpaces.length > pos) {
          if (whiteSpaces.charCodeAt(pos) === 9) {
            indent2 += 2;
          } else {
            indent2++;
          }
          pos++;
        }
      }
      return indent2;
    };
    this.current = () => this._sourceText.slice(this._start, this._pos);
    this._start = 0;
    this._pos = 0;
    this._sourceText = sourceText;
  }
  _testNextCharacter(pattern) {
    const character = this._sourceText.charAt(this._pos);
    let isMatched = false;
    if (typeof pattern === "string") {
      isMatched = character === pattern;
    } else {
      isMatched = pattern instanceof RegExp ? pattern.test(character) : pattern(character);
    }
    return isMatched;
  }
}
__name(CharacterStream, "CharacterStream");
function opt(ofRule) {
  return { ofRule };
}
__name(opt, "opt");
function list$1(ofRule, separator) {
  return { ofRule, isList: true, separator };
}
__name(list$1, "list$1");
function butNot(rule, exclusions) {
  const ruleMatch = rule.match;
  rule.match = (token2) => {
    let check2 = false;
    if (ruleMatch) {
      check2 = ruleMatch(token2);
    }
    return check2 && exclusions.every((exclusion) => exclusion.match && !exclusion.match(token2));
  };
  return rule;
}
__name(butNot, "butNot");
function t$2(kind, style2) {
  return { style: style2, match: (token2) => token2.kind === kind };
}
__name(t$2, "t$2");
function p$1(value3, style2) {
  return {
    style: style2 || "punctuation",
    match: (token2) => token2.kind === "Punctuation" && token2.value === value3
  };
}
__name(p$1, "p$1");
const isIgnored = /* @__PURE__ */ __name((ch) => ch === " " || ch === "	" || ch === "," || ch === "\n" || ch === "\r" || ch === "\uFEFF" || ch === "\xA0", "isIgnored");
const LexRules = {
  Name: /^[_A-Za-z][_0-9A-Za-z]*/,
  Punctuation: /^(?:!|\$|\(|\)|\.\.\.|:|=|&|@|\[|]|\{|\||\})/,
  Number: /^-?(?:0|(?:[1-9][0-9]*))(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?/,
  String: /^(?:"""(?:\\"""|[^"]|"[^"]|""[^"])*(?:""")?|"(?:[^"\\]|\\(?:"|\/|\\|b|f|n|r|t|u[0-9a-fA-F]{4}))*"?)/,
  Comment: /^#.*/
};
const ParseRules = {
  Document: [list$1("Definition")],
  Definition(token2) {
    switch (token2.value) {
      case "{":
        return "ShortQuery";
      case "query":
        return "Query";
      case "mutation":
        return "Mutation";
      case "subscription":
        return "Subscription";
      case "fragment":
        return Kind$1.FRAGMENT_DEFINITION;
      case "schema":
        return "SchemaDef";
      case "scalar":
        return "ScalarDef";
      case "type":
        return "ObjectTypeDef";
      case "interface":
        return "InterfaceDef";
      case "union":
        return "UnionDef";
      case "enum":
        return "EnumDef";
      case "input":
        return "InputDef";
      case "extend":
        return "ExtendDef";
      case "directive":
        return "DirectiveDef";
    }
  },
  ShortQuery: ["SelectionSet"],
  Query: [
    word("query"),
    opt(name("def")),
    opt("VariableDefinitions"),
    list$1("Directive"),
    "SelectionSet"
  ],
  Mutation: [
    word("mutation"),
    opt(name("def")),
    opt("VariableDefinitions"),
    list$1("Directive"),
    "SelectionSet"
  ],
  Subscription: [
    word("subscription"),
    opt(name("def")),
    opt("VariableDefinitions"),
    list$1("Directive"),
    "SelectionSet"
  ],
  VariableDefinitions: [p$1("("), list$1("VariableDefinition"), p$1(")")],
  VariableDefinition: ["Variable", p$1(":"), "Type", opt("DefaultValue")],
  Variable: [p$1("$", "variable"), name("variable")],
  DefaultValue: [p$1("="), "Value"],
  SelectionSet: [p$1("{"), list$1("Selection"), p$1("}")],
  Selection(token2, stream) {
    return token2.value === "..." ? stream.match(/[\s\u00a0,]*(on\b|@|{)/, false) ? "InlineFragment" : "FragmentSpread" : stream.match(/[\s\u00a0,]*:/, false) ? "AliasedField" : "Field";
  },
  AliasedField: [
    name("property"),
    p$1(":"),
    name("qualifier"),
    opt("Arguments"),
    list$1("Directive"),
    opt("SelectionSet")
  ],
  Field: [
    name("property"),
    opt("Arguments"),
    list$1("Directive"),
    opt("SelectionSet")
  ],
  Arguments: [p$1("("), list$1("Argument"), p$1(")")],
  Argument: [name("attribute"), p$1(":"), "Value"],
  FragmentSpread: [p$1("..."), name("def"), list$1("Directive")],
  InlineFragment: [
    p$1("..."),
    opt("TypeCondition"),
    list$1("Directive"),
    "SelectionSet"
  ],
  FragmentDefinition: [
    word("fragment"),
    opt(butNot(name("def"), [word("on")])),
    "TypeCondition",
    list$1("Directive"),
    "SelectionSet"
  ],
  TypeCondition: [word("on"), "NamedType"],
  Value(token2) {
    switch (token2.kind) {
      case "Number":
        return "NumberValue";
      case "String":
        return "StringValue";
      case "Punctuation":
        switch (token2.value) {
          case "[":
            return "ListValue";
          case "{":
            return "ObjectValue";
          case "$":
            return "Variable";
          case "&":
            return "NamedType";
        }
        return null;
      case "Name":
        switch (token2.value) {
          case "true":
          case "false":
            return "BooleanValue";
        }
        if (token2.value === "null") {
          return "NullValue";
        }
        return "EnumValue";
    }
  },
  NumberValue: [t$2("Number", "number")],
  StringValue: [
    {
      style: "string",
      match: (token2) => token2.kind === "String",
      update(state2, token2) {
        if (token2.value.startsWith('"""')) {
          state2.inBlockstring = !token2.value.slice(3).endsWith('"""');
        }
      }
    }
  ],
  BooleanValue: [t$2("Name", "builtin")],
  NullValue: [t$2("Name", "keyword")],
  EnumValue: [name("string-2")],
  ListValue: [p$1("["), list$1("Value"), p$1("]")],
  ObjectValue: [p$1("{"), list$1("ObjectField"), p$1("}")],
  ObjectField: [name("attribute"), p$1(":"), "Value"],
  Type(token2) {
    return token2.value === "[" ? "ListType" : "NonNullType";
  },
  ListType: [p$1("["), "Type", p$1("]"), opt(p$1("!"))],
  NonNullType: ["NamedType", opt(p$1("!"))],
  NamedType: [type("atom")],
  Directive: [p$1("@", "meta"), name("meta"), opt("Arguments")],
  DirectiveDef: [
    word("directive"),
    p$1("@", "meta"),
    name("meta"),
    opt("ArgumentsDef"),
    word("on"),
    list$1("DirectiveLocation", p$1("|"))
  ],
  InterfaceDef: [
    word("interface"),
    name("atom"),
    opt("Implements"),
    list$1("Directive"),
    p$1("{"),
    list$1("FieldDef"),
    p$1("}")
  ],
  Implements: [word("implements"), list$1("NamedType", p$1("&"))],
  DirectiveLocation: [name("string-2")],
  SchemaDef: [
    word("schema"),
    list$1("Directive"),
    p$1("{"),
    list$1("OperationTypeDef"),
    p$1("}")
  ],
  OperationTypeDef: [name("keyword"), p$1(":"), name("atom")],
  ScalarDef: [word("scalar"), name("atom"), list$1("Directive")],
  ObjectTypeDef: [
    word("type"),
    name("atom"),
    opt("Implements"),
    list$1("Directive"),
    p$1("{"),
    list$1("FieldDef"),
    p$1("}")
  ],
  FieldDef: [
    name("property"),
    opt("ArgumentsDef"),
    p$1(":"),
    "Type",
    list$1("Directive")
  ],
  ArgumentsDef: [p$1("("), list$1("InputValueDef"), p$1(")")],
  InputValueDef: [
    name("attribute"),
    p$1(":"),
    "Type",
    opt("DefaultValue"),
    list$1("Directive")
  ],
  UnionDef: [
    word("union"),
    name("atom"),
    list$1("Directive"),
    p$1("="),
    list$1("UnionMember", p$1("|"))
  ],
  UnionMember: ["NamedType"],
  EnumDef: [
    word("enum"),
    name("atom"),
    list$1("Directive"),
    p$1("{"),
    list$1("EnumValueDef"),
    p$1("}")
  ],
  EnumValueDef: [name("string-2"), list$1("Directive")],
  InputDef: [
    word("input"),
    name("atom"),
    list$1("Directive"),
    p$1("{"),
    list$1("InputValueDef"),
    p$1("}")
  ],
  ExtendDef: [word("extend"), "ExtensionDefinition"],
  ExtensionDefinition(token2) {
    switch (token2.value) {
      case "schema":
        return Kind$1.SCHEMA_EXTENSION;
      case "scalar":
        return Kind$1.SCALAR_TYPE_EXTENSION;
      case "type":
        return Kind$1.OBJECT_TYPE_EXTENSION;
      case "interface":
        return Kind$1.INTERFACE_TYPE_EXTENSION;
      case "union":
        return Kind$1.UNION_TYPE_EXTENSION;
      case "enum":
        return Kind$1.ENUM_TYPE_EXTENSION;
      case "input":
        return Kind$1.INPUT_OBJECT_TYPE_EXTENSION;
    }
  },
  [Kind$1.SCHEMA_EXTENSION]: ["SchemaDef"],
  [Kind$1.SCALAR_TYPE_EXTENSION]: ["ScalarDef"],
  [Kind$1.OBJECT_TYPE_EXTENSION]: ["ObjectTypeDef"],
  [Kind$1.INTERFACE_TYPE_EXTENSION]: ["InterfaceDef"],
  [Kind$1.UNION_TYPE_EXTENSION]: ["UnionDef"],
  [Kind$1.ENUM_TYPE_EXTENSION]: ["EnumDef"],
  [Kind$1.INPUT_OBJECT_TYPE_EXTENSION]: ["InputDef"]
};
function word(value3) {
  return {
    style: "keyword",
    match: (token2) => token2.kind === "Name" && token2.value === value3
  };
}
__name(word, "word");
function name(style2) {
  return {
    style: style2,
    match: (token2) => token2.kind === "Name",
    update(state2, token2) {
      state2.name = token2.value;
    }
  };
}
__name(name, "name");
function type(style2) {
  return {
    style: style2,
    match: (token2) => token2.kind === "Name",
    update(state2, token2) {
      var _a;
      if ((_a = state2.prevState) === null || _a === void 0 ? void 0 : _a.prevState) {
        state2.name = token2.value;
        state2.prevState.prevState.type = token2.value;
      }
    }
  };
}
__name(type, "type");
function onlineParser(options = {
  eatWhitespace: (stream) => stream.eatWhile(isIgnored),
  lexRules: LexRules,
  parseRules: ParseRules,
  editorConfig: {}
}) {
  return {
    startState() {
      const initialState2 = {
        level: 0,
        step: 0,
        name: null,
        kind: null,
        type: null,
        rule: null,
        needsSeparator: false,
        prevState: null
      };
      pushRule(options.parseRules, initialState2, Kind$1.DOCUMENT);
      return initialState2;
    },
    token(stream, state2) {
      return getToken(stream, state2, options);
    }
  };
}
__name(onlineParser, "onlineParser");
function getToken(stream, state2, options) {
  var _a;
  if (state2.inBlockstring) {
    if (stream.match(/.*"""/)) {
      state2.inBlockstring = false;
      return "string";
    }
    stream.skipToEnd();
    return "string";
  }
  const { lexRules, parseRules, eatWhitespace, editorConfig } = options;
  if (state2.rule && state2.rule.length === 0) {
    popRule(state2);
  } else if (state2.needsAdvance) {
    state2.needsAdvance = false;
    advanceRule(state2, true);
  }
  if (stream.sol()) {
    const tabSize = (editorConfig === null || editorConfig === void 0 ? void 0 : editorConfig.tabSize) || 2;
    state2.indentLevel = Math.floor(stream.indentation() / tabSize);
  }
  if (eatWhitespace(stream)) {
    return "ws";
  }
  const token2 = lex(lexRules, stream);
  if (!token2) {
    const matchedSomething = stream.match(/\S+/);
    if (!matchedSomething) {
      stream.match(/\s/);
    }
    pushRule(SpecialParseRules, state2, "Invalid");
    return "invalidchar";
  }
  if (token2.kind === "Comment") {
    pushRule(SpecialParseRules, state2, "Comment");
    return "comment";
  }
  const backupState = assign$2({}, state2);
  if (token2.kind === "Punctuation") {
    if (/^[{([]/.test(token2.value)) {
      if (state2.indentLevel !== void 0) {
        state2.levels = (state2.levels || []).concat(state2.indentLevel + 1);
      }
    } else if (/^[})\]]/.test(token2.value)) {
      const levels = state2.levels = (state2.levels || []).slice(0, -1);
      if (state2.indentLevel && levels.length > 0 && levels.at(-1) < state2.indentLevel) {
        state2.indentLevel = levels.at(-1);
      }
    }
  }
  while (state2.rule) {
    let expected = typeof state2.rule === "function" ? state2.step === 0 ? state2.rule(token2, stream) : null : state2.rule[state2.step];
    if (state2.needsSeparator) {
      expected = expected === null || expected === void 0 ? void 0 : expected.separator;
    }
    if (expected) {
      if (expected.ofRule) {
        expected = expected.ofRule;
      }
      if (typeof expected === "string") {
        pushRule(parseRules, state2, expected);
        continue;
      }
      if ((_a = expected.match) === null || _a === void 0 ? void 0 : _a.call(expected, token2)) {
        if (expected.update) {
          expected.update(state2, token2);
        }
        if (token2.kind === "Punctuation") {
          advanceRule(state2, true);
        } else {
          state2.needsAdvance = true;
        }
        return expected.style;
      }
    }
    unsuccessful(state2);
  }
  assign$2(state2, backupState);
  pushRule(SpecialParseRules, state2, "Invalid");
  return "invalidchar";
}
__name(getToken, "getToken");
function assign$2(to, from) {
  const keys = Object.keys(from);
  for (let i = 0; i < keys.length; i++) {
    to[keys[i]] = from[keys[i]];
  }
  return to;
}
__name(assign$2, "assign$2");
const SpecialParseRules = {
  Invalid: [],
  Comment: []
};
function pushRule(rules, state2, ruleKind) {
  if (!rules[ruleKind]) {
    throw new TypeError("Unknown rule: " + ruleKind);
  }
  state2.prevState = Object.assign({}, state2);
  state2.kind = ruleKind;
  state2.name = null;
  state2.type = null;
  state2.rule = rules[ruleKind];
  state2.step = 0;
  state2.needsSeparator = false;
}
__name(pushRule, "pushRule");
function popRule(state2) {
  if (!state2.prevState) {
    return;
  }
  state2.kind = state2.prevState.kind;
  state2.name = state2.prevState.name;
  state2.type = state2.prevState.type;
  state2.rule = state2.prevState.rule;
  state2.step = state2.prevState.step;
  state2.needsSeparator = state2.prevState.needsSeparator;
  state2.prevState = state2.prevState.prevState;
}
__name(popRule, "popRule");
function advanceRule(state2, successful) {
  var _a;
  if (isList(state2) && state2.rule) {
    const step = state2.rule[state2.step];
    if (step.separator) {
      const { separator } = step;
      state2.needsSeparator = !state2.needsSeparator;
      if (!state2.needsSeparator && separator.ofRule) {
        return;
      }
    }
    if (successful) {
      return;
    }
  }
  state2.needsSeparator = false;
  state2.step++;
  while (state2.rule && !(Array.isArray(state2.rule) && state2.step < state2.rule.length)) {
    popRule(state2);
    if (state2.rule) {
      if (isList(state2)) {
        if ((_a = state2.rule) === null || _a === void 0 ? void 0 : _a[state2.step].separator) {
          state2.needsSeparator = !state2.needsSeparator;
        }
      } else {
        state2.needsSeparator = false;
        state2.step++;
      }
    }
  }
}
__name(advanceRule, "advanceRule");
function isList(state2) {
  const step = Array.isArray(state2.rule) && typeof state2.rule[state2.step] !== "string" && state2.rule[state2.step];
  return step && step.isList;
}
__name(isList, "isList");
function unsuccessful(state2) {
  while (state2.rule && !(Array.isArray(state2.rule) && state2.rule[state2.step].ofRule)) {
    popRule(state2);
  }
  if (state2.rule) {
    advanceRule(state2, false);
  }
}
__name(unsuccessful, "unsuccessful");
function lex(lexRules, stream) {
  const kinds = Object.keys(lexRules);
  for (let i = 0; i < kinds.length; i++) {
    const match2 = stream.match(lexRules[kinds[i]]);
    if (match2 && match2 instanceof Array) {
      return { kind: kinds[i], value: match2[0] };
    }
  }
}
__name(lex, "lex");
const AdditionalRuleKinds = {
  ALIASED_FIELD: "AliasedField",
  ARGUMENTS: "Arguments",
  SHORT_QUERY: "ShortQuery",
  QUERY: "Query",
  MUTATION: "Mutation",
  SUBSCRIPTION: "Subscription",
  TYPE_CONDITION: "TypeCondition",
  INVALID: "Invalid",
  COMMENT: "Comment",
  SCHEMA_DEF: "SchemaDef",
  SCALAR_DEF: "ScalarDef",
  OBJECT_TYPE_DEF: "ObjectTypeDef",
  OBJECT_VALUE: "ObjectValue",
  LIST_VALUE: "ListValue",
  INTERFACE_DEF: "InterfaceDef",
  UNION_DEF: "UnionDef",
  ENUM_DEF: "EnumDef",
  ENUM_VALUE: "EnumValue",
  FIELD_DEF: "FieldDef",
  INPUT_DEF: "InputDef",
  INPUT_VALUE_DEF: "InputValueDef",
  ARGUMENTS_DEF: "ArgumentsDef",
  EXTEND_DEF: "ExtendDef",
  EXTENSION_DEFINITION: "ExtensionDefinition",
  DIRECTIVE_DEF: "DirectiveDef",
  IMPLEMENTS: "Implements",
  VARIABLE_DEFINITIONS: "VariableDefinitions",
  TYPE: "Type"
};
const RuleKinds = Object.assign(Object.assign({}, Kind$1), AdditionalRuleKinds);
const SuggestionCommand = {
  command: "editor.action.triggerSuggest",
  title: "Suggestions"
};
const collectFragmentDefs = /* @__PURE__ */ __name((op) => {
  const externalFragments = [];
  if (op) {
    try {
      visit$1(parse$2(op), {
        FragmentDefinition(def) {
          externalFragments.push(def);
        }
      });
    } catch (_a) {
      return [];
    }
  }
  return externalFragments;
}, "collectFragmentDefs");
const typeSystemKinds = [
  Kind$1.SCHEMA_DEFINITION,
  Kind$1.OPERATION_TYPE_DEFINITION,
  Kind$1.SCALAR_TYPE_DEFINITION,
  Kind$1.OBJECT_TYPE_DEFINITION,
  Kind$1.INTERFACE_TYPE_DEFINITION,
  Kind$1.UNION_TYPE_DEFINITION,
  Kind$1.ENUM_TYPE_DEFINITION,
  Kind$1.INPUT_OBJECT_TYPE_DEFINITION,
  Kind$1.DIRECTIVE_DEFINITION,
  Kind$1.SCHEMA_EXTENSION,
  Kind$1.SCALAR_TYPE_EXTENSION,
  Kind$1.OBJECT_TYPE_EXTENSION,
  Kind$1.INTERFACE_TYPE_EXTENSION,
  Kind$1.UNION_TYPE_EXTENSION,
  Kind$1.ENUM_TYPE_EXTENSION,
  Kind$1.INPUT_OBJECT_TYPE_EXTENSION
];
const hasTypeSystemDefinitions = /* @__PURE__ */ __name((sdl) => {
  let hasTypeSystemDef = false;
  if (sdl) {
    try {
      visit$1(parse$2(sdl), {
        enter(node) {
          if (node.kind === "Document") {
            return;
          }
          if (typeSystemKinds.includes(node.kind)) {
            hasTypeSystemDef = true;
            return BREAK$1;
          }
          return false;
        }
      });
    } catch (_a) {
      return hasTypeSystemDef;
    }
  }
  return hasTypeSystemDef;
}, "hasTypeSystemDefinitions");
function getAutocompleteSuggestions(schema, queryText, cursor, contextToken, fragmentDefs, options) {
  var _a;
  const opts = Object.assign(Object.assign({}, options), { schema });
  const token2 = contextToken || getTokenAtPosition(queryText, cursor);
  const state2 = token2.state.kind === "Invalid" ? token2.state.prevState : token2.state;
  const mode = (options === null || options === void 0 ? void 0 : options.mode) || getDocumentMode(queryText, options === null || options === void 0 ? void 0 : options.uri);
  if (!state2) {
    return [];
  }
  const { kind, step, prevState } = state2;
  const typeInfo = getTypeInfo(schema, token2.state);
  if (kind === RuleKinds.DOCUMENT) {
    if (mode === GraphQLDocumentMode.TYPE_SYSTEM) {
      return getSuggestionsForTypeSystemDefinitions(token2);
    }
    return getSuggestionsForExecutableDefinitions(token2);
  }
  if (kind === RuleKinds.EXTEND_DEF) {
    return getSuggestionsForExtensionDefinitions(token2);
  }
  if (((_a = prevState === null || prevState === void 0 ? void 0 : prevState.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.EXTENSION_DEFINITION && state2.name) {
    return hintList(token2, []);
  }
  if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === Kind$1.SCALAR_TYPE_EXTENSION) {
    return hintList(token2, Object.values(schema.getTypeMap()).filter(isScalarType$1).map((type2) => ({
      label: type2.name,
      kind: CompletionItemKind.Function
    })));
  }
  if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === Kind$1.OBJECT_TYPE_EXTENSION) {
    return hintList(token2, Object.values(schema.getTypeMap()).filter((type2) => isObjectType$1(type2) && !type2.name.startsWith("__")).map((type2) => ({
      label: type2.name,
      kind: CompletionItemKind.Function
    })));
  }
  if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === Kind$1.INTERFACE_TYPE_EXTENSION) {
    return hintList(token2, Object.values(schema.getTypeMap()).filter(isInterfaceType$1).map((type2) => ({
      label: type2.name,
      kind: CompletionItemKind.Function
    })));
  }
  if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === Kind$1.UNION_TYPE_EXTENSION) {
    return hintList(token2, Object.values(schema.getTypeMap()).filter(isUnionType$1).map((type2) => ({
      label: type2.name,
      kind: CompletionItemKind.Function
    })));
  }
  if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === Kind$1.ENUM_TYPE_EXTENSION) {
    return hintList(token2, Object.values(schema.getTypeMap()).filter((type2) => isEnumType$1(type2) && !type2.name.startsWith("__")).map((type2) => ({
      label: type2.name,
      kind: CompletionItemKind.Function
    })));
  }
  if ((prevState === null || prevState === void 0 ? void 0 : prevState.kind) === Kind$1.INPUT_OBJECT_TYPE_EXTENSION) {
    return hintList(token2, Object.values(schema.getTypeMap()).filter(isInputObjectType$1).map((type2) => ({
      label: type2.name,
      kind: CompletionItemKind.Function
    })));
  }
  if (kind === RuleKinds.IMPLEMENTS || kind === RuleKinds.NAMED_TYPE && (prevState === null || prevState === void 0 ? void 0 : prevState.kind) === RuleKinds.IMPLEMENTS) {
    return getSuggestionsForImplements(token2, state2, schema, queryText, typeInfo);
  }
  if (kind === RuleKinds.SELECTION_SET || kind === RuleKinds.FIELD || kind === RuleKinds.ALIASED_FIELD) {
    return getSuggestionsForFieldNames(token2, typeInfo, opts);
  }
  if (kind === RuleKinds.ARGUMENTS || kind === RuleKinds.ARGUMENT && step === 0) {
    const { argDefs } = typeInfo;
    if (argDefs) {
      return hintList(token2, argDefs.map((argDef) => {
        var _a2;
        return {
          label: argDef.name,
          insertText: argDef.name + ": ",
          command: SuggestionCommand,
          detail: String(argDef.type),
          documentation: (_a2 = argDef.description) !== null && _a2 !== void 0 ? _a2 : void 0,
          kind: CompletionItemKind.Variable,
          type: argDef.type
        };
      }));
    }
  }
  if ((kind === RuleKinds.OBJECT_VALUE || kind === RuleKinds.OBJECT_FIELD && step === 0) && typeInfo.objectFieldDefs) {
    const objectFields = objectValues(typeInfo.objectFieldDefs);
    const completionKind = kind === RuleKinds.OBJECT_VALUE ? CompletionItemKind.Value : CompletionItemKind.Field;
    return hintList(token2, objectFields.map((field) => {
      var _a2;
      return {
        label: field.name,
        detail: String(field.type),
        documentation: (_a2 = field.description) !== null && _a2 !== void 0 ? _a2 : void 0,
        kind: completionKind,
        type: field.type
      };
    }));
  }
  if (kind === RuleKinds.ENUM_VALUE || kind === RuleKinds.LIST_VALUE && step === 1 || kind === RuleKinds.OBJECT_FIELD && step === 2 || kind === RuleKinds.ARGUMENT && step === 2) {
    return getSuggestionsForInputValues(token2, typeInfo, queryText, schema);
  }
  if (kind === RuleKinds.VARIABLE && step === 1) {
    const namedInputType = getNamedType(typeInfo.inputType);
    const variableDefinitions = getVariableCompletions(queryText, schema, token2);
    return hintList(token2, variableDefinitions.filter((v2) => v2.detail === (namedInputType === null || namedInputType === void 0 ? void 0 : namedInputType.name)));
  }
  if (kind === RuleKinds.TYPE_CONDITION && step === 1 || kind === RuleKinds.NAMED_TYPE && prevState != null && prevState.kind === RuleKinds.TYPE_CONDITION) {
    return getSuggestionsForFragmentTypeConditions(token2, typeInfo, schema);
  }
  if (kind === RuleKinds.FRAGMENT_SPREAD && step === 1) {
    return getSuggestionsForFragmentSpread(token2, typeInfo, schema, queryText, Array.isArray(fragmentDefs) ? fragmentDefs : collectFragmentDefs(fragmentDefs));
  }
  const unwrappedState = unwrapType(state2);
  if (mode === GraphQLDocumentMode.TYPE_SYSTEM && !unwrappedState.needsAdvance && kind === RuleKinds.NAMED_TYPE || kind === RuleKinds.LIST_TYPE) {
    if (unwrappedState.kind === RuleKinds.FIELD_DEF) {
      return hintList(token2, Object.values(schema.getTypeMap()).filter((type2) => isOutputType(type2) && !type2.name.startsWith("__")).map((type2) => ({
        label: type2.name,
        kind: CompletionItemKind.Function
      })));
    }
    if (unwrappedState.kind === RuleKinds.INPUT_VALUE_DEF) {
      return hintList(token2, Object.values(schema.getTypeMap()).filter((type2) => isInputType(type2) && !type2.name.startsWith("__")).map((type2) => ({
        label: type2.name,
        kind: CompletionItemKind.Function
      })));
    }
  }
  if (kind === RuleKinds.VARIABLE_DEFINITION && step === 2 || kind === RuleKinds.LIST_TYPE && step === 1 || kind === RuleKinds.NAMED_TYPE && prevState && (prevState.kind === RuleKinds.VARIABLE_DEFINITION || prevState.kind === RuleKinds.LIST_TYPE || prevState.kind === RuleKinds.NON_NULL_TYPE)) {
    return getSuggestionsForVariableDefinition(token2, schema);
  }
  if (kind === RuleKinds.DIRECTIVE) {
    return getSuggestionsForDirective(token2, state2, schema);
  }
  return [];
}
__name(getAutocompleteSuggestions, "getAutocompleteSuggestions");
const insertSuffix = ` {
  $1
}`;
const getInsertText = /* @__PURE__ */ __name((field) => {
  const { type: type2 } = field;
  if (isCompositeType(type2)) {
    return insertSuffix;
  }
  if (isListType$1(type2) && isCompositeType(type2.ofType)) {
    return insertSuffix;
  }
  if (isNonNullType$1(type2)) {
    if (isCompositeType(type2.ofType)) {
      return insertSuffix;
    }
    if (isListType$1(type2.ofType) && isCompositeType(type2.ofType.ofType)) {
      return insertSuffix;
    }
  }
  return null;
}, "getInsertText");
function getSuggestionsForTypeSystemDefinitions(token2) {
  return hintList(token2, [
    { label: "extend", kind: CompletionItemKind.Function },
    { label: "type", kind: CompletionItemKind.Function },
    { label: "interface", kind: CompletionItemKind.Function },
    { label: "union", kind: CompletionItemKind.Function },
    { label: "input", kind: CompletionItemKind.Function },
    { label: "scalar", kind: CompletionItemKind.Function },
    { label: "schema", kind: CompletionItemKind.Function }
  ]);
}
__name(getSuggestionsForTypeSystemDefinitions, "getSuggestionsForTypeSystemDefinitions");
function getSuggestionsForExecutableDefinitions(token2) {
  return hintList(token2, [
    { label: "query", kind: CompletionItemKind.Function },
    { label: "mutation", kind: CompletionItemKind.Function },
    { label: "subscription", kind: CompletionItemKind.Function },
    { label: "fragment", kind: CompletionItemKind.Function },
    { label: "{", kind: CompletionItemKind.Constructor }
  ]);
}
__name(getSuggestionsForExecutableDefinitions, "getSuggestionsForExecutableDefinitions");
function getSuggestionsForExtensionDefinitions(token2) {
  return hintList(token2, [
    { label: "type", kind: CompletionItemKind.Function },
    { label: "interface", kind: CompletionItemKind.Function },
    { label: "union", kind: CompletionItemKind.Function },
    { label: "input", kind: CompletionItemKind.Function },
    { label: "scalar", kind: CompletionItemKind.Function },
    { label: "schema", kind: CompletionItemKind.Function }
  ]);
}
__name(getSuggestionsForExtensionDefinitions, "getSuggestionsForExtensionDefinitions");
function getSuggestionsForFieldNames(token2, typeInfo, options) {
  var _a;
  if (typeInfo.parentType) {
    const { parentType } = typeInfo;
    let fields = [];
    if ("getFields" in parentType) {
      fields = objectValues(parentType.getFields());
    }
    if (isCompositeType(parentType)) {
      fields.push(TypeNameMetaFieldDef$1);
    }
    if (parentType === ((_a = options === null || options === void 0 ? void 0 : options.schema) === null || _a === void 0 ? void 0 : _a.getQueryType())) {
      fields.push(SchemaMetaFieldDef$1, TypeMetaFieldDef$1);
    }
    return hintList(token2, fields.map((field, index) => {
      var _a2;
      const suggestion = {
        sortText: String(index) + field.name,
        label: field.name,
        detail: String(field.type),
        documentation: (_a2 = field.description) !== null && _a2 !== void 0 ? _a2 : void 0,
        deprecated: Boolean(field.deprecationReason),
        isDeprecated: Boolean(field.deprecationReason),
        deprecationReason: field.deprecationReason,
        kind: CompletionItemKind.Field,
        type: field.type
      };
      if (options === null || options === void 0 ? void 0 : options.fillLeafsOnComplete) {
        const insertText = getInsertText(field);
        if (insertText) {
          suggestion.insertText = field.name + insertText;
          suggestion.insertTextFormat = InsertTextFormat.Snippet;
          suggestion.command = SuggestionCommand;
        }
      }
      return suggestion;
    }));
  }
  return [];
}
__name(getSuggestionsForFieldNames, "getSuggestionsForFieldNames");
function getSuggestionsForInputValues(token2, typeInfo, queryText, schema) {
  const namedInputType = getNamedType(typeInfo.inputType);
  const queryVariables = getVariableCompletions(queryText, schema, token2).filter((v2) => v2.detail === namedInputType.name);
  if (namedInputType instanceof GraphQLEnumType$1) {
    const values = namedInputType.getValues();
    return hintList(token2, values.map((value3) => {
      var _a;
      return {
        label: value3.name,
        detail: String(namedInputType),
        documentation: (_a = value3.description) !== null && _a !== void 0 ? _a : void 0,
        deprecated: Boolean(value3.deprecationReason),
        isDeprecated: Boolean(value3.deprecationReason),
        deprecationReason: value3.deprecationReason,
        kind: CompletionItemKind.EnumMember,
        type: namedInputType
      };
    }).concat(queryVariables));
  }
  if (namedInputType === GraphQLBoolean$1) {
    return hintList(token2, queryVariables.concat([
      {
        label: "true",
        detail: String(GraphQLBoolean$1),
        documentation: "Not false.",
        kind: CompletionItemKind.Variable,
        type: GraphQLBoolean$1
      },
      {
        label: "false",
        detail: String(GraphQLBoolean$1),
        documentation: "Not true.",
        kind: CompletionItemKind.Variable,
        type: GraphQLBoolean$1
      }
    ]));
  }
  return queryVariables;
}
__name(getSuggestionsForInputValues, "getSuggestionsForInputValues");
function getSuggestionsForImplements(token2, tokenState, schema, documentText, typeInfo) {
  if (tokenState.needsSeparator) {
    return [];
  }
  const typeMap = schema.getTypeMap();
  const schemaInterfaces = objectValues(typeMap).filter(isInterfaceType$1);
  const schemaInterfaceNames = schemaInterfaces.map(({ name: name2 }) => name2);
  const inlineInterfaces = /* @__PURE__ */ new Set();
  runOnlineParser(documentText, (_, state2) => {
    var _a, _b, _c, _d, _e;
    if (state2.name) {
      if (state2.kind === RuleKinds.INTERFACE_DEF && !schemaInterfaceNames.includes(state2.name)) {
        inlineInterfaces.add(state2.name);
      }
      if (state2.kind === RuleKinds.NAMED_TYPE && ((_a = state2.prevState) === null || _a === void 0 ? void 0 : _a.kind) === RuleKinds.IMPLEMENTS) {
        if (typeInfo.interfaceDef) {
          const existingType = (_b = typeInfo.interfaceDef) === null || _b === void 0 ? void 0 : _b.getInterfaces().find(({ name: name2 }) => name2 === state2.name);
          if (existingType) {
            return;
          }
          const type2 = schema.getType(state2.name);
          const interfaceConfig = (_c = typeInfo.interfaceDef) === null || _c === void 0 ? void 0 : _c.toConfig();
          typeInfo.interfaceDef = new GraphQLInterfaceType$1(Object.assign(Object.assign({}, interfaceConfig), { interfaces: [
            ...interfaceConfig.interfaces,
            type2 || new GraphQLInterfaceType$1({ name: state2.name, fields: {} })
          ] }));
        } else if (typeInfo.objectTypeDef) {
          const existingType = (_d = typeInfo.objectTypeDef) === null || _d === void 0 ? void 0 : _d.getInterfaces().find(({ name: name2 }) => name2 === state2.name);
          if (existingType) {
            return;
          }
          const type2 = schema.getType(state2.name);
          const objectTypeConfig = (_e = typeInfo.objectTypeDef) === null || _e === void 0 ? void 0 : _e.toConfig();
          typeInfo.objectTypeDef = new GraphQLObjectType$1(Object.assign(Object.assign({}, objectTypeConfig), { interfaces: [
            ...objectTypeConfig.interfaces,
            type2 || new GraphQLInterfaceType$1({ name: state2.name, fields: {} })
          ] }));
        }
      }
    }
  });
  const currentTypeToExtend = typeInfo.interfaceDef || typeInfo.objectTypeDef;
  const siblingInterfaces = (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.getInterfaces()) || [];
  const siblingInterfaceNames = siblingInterfaces.map(({ name: name2 }) => name2);
  const possibleInterfaces = schemaInterfaces.concat([...inlineInterfaces].map((name2) => ({ name: name2 }))).filter(({ name: name2 }) => name2 !== (currentTypeToExtend === null || currentTypeToExtend === void 0 ? void 0 : currentTypeToExtend.name) && !siblingInterfaceNames.includes(name2));
  return hintList(token2, possibleInterfaces.map((type2) => {
    const result = {
      label: type2.name,
      kind: CompletionItemKind.Interface,
      type: type2
    };
    if (type2 === null || type2 === void 0 ? void 0 : type2.description) {
      result.documentation = type2.description;
    }
    return result;
  }));
}
__name(getSuggestionsForImplements, "getSuggestionsForImplements");
function getSuggestionsForFragmentTypeConditions(token2, typeInfo, schema, _kind) {
  let possibleTypes;
  if (typeInfo.parentType) {
    if (isAbstractType$1(typeInfo.parentType)) {
      const abstractType = assertAbstractType(typeInfo.parentType);
      const possibleObjTypes = schema.getPossibleTypes(abstractType);
      const possibleIfaceMap = /* @__PURE__ */ Object.create(null);
      possibleObjTypes.forEach((type2) => {
        type2.getInterfaces().forEach((iface) => {
          possibleIfaceMap[iface.name] = iface;
        });
      });
      possibleTypes = possibleObjTypes.concat(objectValues(possibleIfaceMap));
    } else {
      possibleTypes = [typeInfo.parentType];
    }
  } else {
    const typeMap = schema.getTypeMap();
    possibleTypes = objectValues(typeMap).filter((type2) => isCompositeType(type2) && !type2.name.startsWith("__"));
  }
  return hintList(token2, possibleTypes.map((type2) => {
    const namedType = getNamedType(type2);
    return {
      label: String(type2),
      documentation: (namedType === null || namedType === void 0 ? void 0 : namedType.description) || "",
      kind: CompletionItemKind.Field
    };
  }));
}
__name(getSuggestionsForFragmentTypeConditions, "getSuggestionsForFragmentTypeConditions");
function getSuggestionsForFragmentSpread(token2, typeInfo, schema, queryText, fragmentDefs) {
  if (!queryText) {
    return [];
  }
  const typeMap = schema.getTypeMap();
  const defState = getDefinitionState(token2.state);
  const fragments = getFragmentDefinitions(queryText);
  if (fragmentDefs && fragmentDefs.length > 0) {
    fragments.push(...fragmentDefs);
  }
  const relevantFrags = fragments.filter((frag) => typeMap[frag.typeCondition.name.value] && !(defState && defState.kind === RuleKinds.FRAGMENT_DEFINITION && defState.name === frag.name.value) && isCompositeType(typeInfo.parentType) && isCompositeType(typeMap[frag.typeCondition.name.value]) && doTypesOverlap(schema, typeInfo.parentType, typeMap[frag.typeCondition.name.value]));
  return hintList(token2, relevantFrags.map((frag) => ({
    label: frag.name.value,
    detail: String(typeMap[frag.typeCondition.name.value]),
    documentation: `fragment ${frag.name.value} on ${frag.typeCondition.name.value}`,
    kind: CompletionItemKind.Field,
    type: typeMap[frag.typeCondition.name.value]
  })));
}
__name(getSuggestionsForFragmentSpread, "getSuggestionsForFragmentSpread");
const getParentDefinition = /* @__PURE__ */ __name((state2, kind) => {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
  if (((_a = state2.prevState) === null || _a === void 0 ? void 0 : _a.kind) === kind) {
    return state2.prevState;
  }
  if (((_c = (_b = state2.prevState) === null || _b === void 0 ? void 0 : _b.prevState) === null || _c === void 0 ? void 0 : _c.kind) === kind) {
    return state2.prevState.prevState;
  }
  if (((_f = (_e = (_d = state2.prevState) === null || _d === void 0 ? void 0 : _d.prevState) === null || _e === void 0 ? void 0 : _e.prevState) === null || _f === void 0 ? void 0 : _f.kind) === kind) {
    return state2.prevState.prevState.prevState;
  }
  if (((_k = (_j = (_h = (_g = state2.prevState) === null || _g === void 0 ? void 0 : _g.prevState) === null || _h === void 0 ? void 0 : _h.prevState) === null || _j === void 0 ? void 0 : _j.prevState) === null || _k === void 0 ? void 0 : _k.kind) === kind) {
    return state2.prevState.prevState.prevState.prevState;
  }
}, "getParentDefinition");
function getVariableCompletions(queryText, schema, token2) {
  let variableName = null;
  let variableType;
  const definitions = /* @__PURE__ */ Object.create({});
  runOnlineParser(queryText, (_, state2) => {
    if ((state2 === null || state2 === void 0 ? void 0 : state2.kind) === RuleKinds.VARIABLE && state2.name) {
      variableName = state2.name;
    }
    if ((state2 === null || state2 === void 0 ? void 0 : state2.kind) === RuleKinds.NAMED_TYPE && variableName) {
      const parentDefinition = getParentDefinition(state2, RuleKinds.TYPE);
      if (parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type) {
        variableType = schema.getType(parentDefinition === null || parentDefinition === void 0 ? void 0 : parentDefinition.type);
      }
    }
    if (variableName && variableType && !definitions[variableName]) {
      definitions[variableName] = {
        detail: variableType.toString(),
        insertText: token2.string === "$" ? variableName : "$" + variableName,
        label: variableName,
        type: variableType,
        kind: CompletionItemKind.Variable
      };
      variableName = null;
      variableType = null;
    }
  });
  return objectValues(definitions);
}
__name(getVariableCompletions, "getVariableCompletions");
function getFragmentDefinitions(queryText) {
  const fragmentDefs = [];
  runOnlineParser(queryText, (_, state2) => {
    if (state2.kind === RuleKinds.FRAGMENT_DEFINITION && state2.name && state2.type) {
      fragmentDefs.push({
        kind: RuleKinds.FRAGMENT_DEFINITION,
        name: {
          kind: Kind$1.NAME,
          value: state2.name
        },
        selectionSet: {
          kind: RuleKinds.SELECTION_SET,
          selections: []
        },
        typeCondition: {
          kind: RuleKinds.NAMED_TYPE,
          name: {
            kind: Kind$1.NAME,
            value: state2.type
          }
        }
      });
    }
  });
  return fragmentDefs;
}
__name(getFragmentDefinitions, "getFragmentDefinitions");
function getSuggestionsForVariableDefinition(token2, schema, _kind) {
  const inputTypeMap = schema.getTypeMap();
  const inputTypes = objectValues(inputTypeMap).filter(isInputType);
  return hintList(token2, inputTypes.map((type2) => ({
    label: type2.name,
    documentation: type2.description,
    kind: CompletionItemKind.Variable
  })));
}
__name(getSuggestionsForVariableDefinition, "getSuggestionsForVariableDefinition");
function getSuggestionsForDirective(token2, state2, schema, _kind) {
  var _a;
  if ((_a = state2.prevState) === null || _a === void 0 ? void 0 : _a.kind) {
    const directives = schema.getDirectives().filter((directive2) => canUseDirective(state2.prevState, directive2));
    return hintList(token2, directives.map((directive2) => ({
      label: directive2.name,
      documentation: directive2.description || "",
      kind: CompletionItemKind.Function
    })));
  }
  return [];
}
__name(getSuggestionsForDirective, "getSuggestionsForDirective");
function getTokenAtPosition(queryText, cursor) {
  let styleAtCursor = null;
  let stateAtCursor = null;
  let stringAtCursor = null;
  const token2 = runOnlineParser(queryText, (stream, state2, style2, index) => {
    if (index === cursor.line && stream.getCurrentPosition() >= cursor.character) {
      styleAtCursor = style2;
      stateAtCursor = Object.assign({}, state2);
      stringAtCursor = stream.current();
      return "BREAK";
    }
  });
  return {
    start: token2.start,
    end: token2.end,
    string: stringAtCursor || token2.string,
    state: stateAtCursor || token2.state,
    style: styleAtCursor || token2.style
  };
}
__name(getTokenAtPosition, "getTokenAtPosition");
function runOnlineParser(queryText, callback) {
  const lines = queryText.split("\n");
  const parser = onlineParser();
  let state2 = parser.startState();
  let style2 = "";
  let stream = new CharacterStream("");
  for (let i = 0; i < lines.length; i++) {
    stream = new CharacterStream(lines[i]);
    while (!stream.eol()) {
      style2 = parser.token(stream, state2);
      const code3 = callback(stream, state2, style2, i);
      if (code3 === "BREAK") {
        break;
      }
    }
    callback(stream, state2, style2, i);
    if (!state2.kind) {
      state2 = parser.startState();
    }
  }
  return {
    start: stream.getStartOfToken(),
    end: stream.getCurrentPosition(),
    string: stream.current(),
    state: state2,
    style: style2
  };
}
__name(runOnlineParser, "runOnlineParser");
function canUseDirective(state2, directive2) {
  if (!(state2 === null || state2 === void 0 ? void 0 : state2.kind)) {
    return false;
  }
  const { kind, prevState } = state2;
  const { locations } = directive2;
  switch (kind) {
    case RuleKinds.QUERY:
      return locations.includes(DirectiveLocation$1.QUERY);
    case RuleKinds.MUTATION:
      return locations.includes(DirectiveLocation$1.MUTATION);
    case RuleKinds.SUBSCRIPTION:
      return locations.includes(DirectiveLocation$1.SUBSCRIPTION);
    case RuleKinds.FIELD:
    case RuleKinds.ALIASED_FIELD:
      return locations.includes(DirectiveLocation$1.FIELD);
    case RuleKinds.FRAGMENT_DEFINITION:
      return locations.includes(DirectiveLocation$1.FRAGMENT_DEFINITION);
    case RuleKinds.FRAGMENT_SPREAD:
      return locations.includes(DirectiveLocation$1.FRAGMENT_SPREAD);
    case RuleKinds.INLINE_FRAGMENT:
      return locations.includes(DirectiveLocation$1.INLINE_FRAGMENT);
    case RuleKinds.SCHEMA_DEF:
      return locations.includes(DirectiveLocation$1.SCHEMA);
    case RuleKinds.SCALAR_DEF:
      return locations.includes(DirectiveLocation$1.SCALAR);
    case RuleKinds.OBJECT_TYPE_DEF:
      return locations.includes(DirectiveLocation$1.OBJECT);
    case RuleKinds.FIELD_DEF:
      return locations.includes(DirectiveLocation$1.FIELD_DEFINITION);
    case RuleKinds.INTERFACE_DEF:
      return locations.includes(DirectiveLocation$1.INTERFACE);
    case RuleKinds.UNION_DEF:
      return locations.includes(DirectiveLocation$1.UNION);
    case RuleKinds.ENUM_DEF:
      return locations.includes(DirectiveLocation$1.ENUM);
    case RuleKinds.ENUM_VALUE:
      return locations.includes(DirectiveLocation$1.ENUM_VALUE);
    case RuleKinds.INPUT_DEF:
      return locations.includes(DirectiveLocation$1.INPUT_OBJECT);
    case RuleKinds.INPUT_VALUE_DEF:
      const prevStateKind = prevState === null || prevState === void 0 ? void 0 : prevState.kind;
      switch (prevStateKind) {
        case RuleKinds.ARGUMENTS_DEF:
          return locations.includes(DirectiveLocation$1.ARGUMENT_DEFINITION);
        case RuleKinds.INPUT_DEF:
          return locations.includes(DirectiveLocation$1.INPUT_FIELD_DEFINITION);
      }
  }
  return false;
}
__name(canUseDirective, "canUseDirective");
function getTypeInfo(schema, tokenState) {
  let argDef;
  let argDefs;
  let directiveDef;
  let enumValue;
  let fieldDef;
  let inputType;
  let objectTypeDef;
  let objectFieldDefs;
  let parentType;
  let type2;
  let interfaceDef;
  forEachState(tokenState, (state2) => {
    var _a;
    switch (state2.kind) {
      case RuleKinds.QUERY:
      case "ShortQuery":
        type2 = schema.getQueryType();
        break;
      case RuleKinds.MUTATION:
        type2 = schema.getMutationType();
        break;
      case RuleKinds.SUBSCRIPTION:
        type2 = schema.getSubscriptionType();
        break;
      case RuleKinds.INLINE_FRAGMENT:
      case RuleKinds.FRAGMENT_DEFINITION:
        if (state2.type) {
          type2 = schema.getType(state2.type);
        }
        break;
      case RuleKinds.FIELD:
      case RuleKinds.ALIASED_FIELD: {
        if (!type2 || !state2.name) {
          fieldDef = null;
        } else {
          fieldDef = parentType ? getFieldDef(schema, parentType, state2.name) : null;
          type2 = fieldDef ? fieldDef.type : null;
        }
        break;
      }
      case RuleKinds.SELECTION_SET:
        parentType = getNamedType(type2);
        break;
      case RuleKinds.DIRECTIVE:
        directiveDef = state2.name ? schema.getDirective(state2.name) : null;
        break;
      case RuleKinds.INTERFACE_DEF:
        if (state2.name) {
          objectTypeDef = null;
          interfaceDef = new GraphQLInterfaceType$1({
            name: state2.name,
            interfaces: [],
            fields: {}
          });
        }
        break;
      case RuleKinds.OBJECT_TYPE_DEF:
        if (state2.name) {
          interfaceDef = null;
          objectTypeDef = new GraphQLObjectType$1({
            name: state2.name,
            interfaces: [],
            fields: {}
          });
        }
        break;
      case RuleKinds.ARGUMENTS: {
        if (state2.prevState) {
          switch (state2.prevState.kind) {
            case RuleKinds.FIELD:
              argDefs = fieldDef && fieldDef.args;
              break;
            case RuleKinds.DIRECTIVE:
              argDefs = directiveDef && directiveDef.args;
              break;
            case RuleKinds.ALIASED_FIELD: {
              const name2 = (_a = state2.prevState) === null || _a === void 0 ? void 0 : _a.name;
              if (!name2) {
                argDefs = null;
                break;
              }
              const field = parentType ? getFieldDef(schema, parentType, name2) : null;
              if (!field) {
                argDefs = null;
                break;
              }
              argDefs = field.args;
              break;
            }
            default:
              argDefs = null;
              break;
          }
        } else {
          argDefs = null;
        }
        break;
      }
      case RuleKinds.ARGUMENT:
        if (argDefs) {
          for (let i = 0; i < argDefs.length; i++) {
            if (argDefs[i].name === state2.name) {
              argDef = argDefs[i];
              break;
            }
          }
        }
        inputType = argDef === null || argDef === void 0 ? void 0 : argDef.type;
        break;
      case RuleKinds.ENUM_VALUE:
        const enumType = getNamedType(inputType);
        enumValue = enumType instanceof GraphQLEnumType$1 ? enumType.getValues().find((val) => val.value === state2.name) : null;
        break;
      case RuleKinds.LIST_VALUE:
        const nullableType = getNullableType(inputType);
        inputType = nullableType instanceof GraphQLList$1 ? nullableType.ofType : null;
        break;
      case RuleKinds.OBJECT_VALUE:
        const objectType = getNamedType(inputType);
        objectFieldDefs = objectType instanceof GraphQLInputObjectType$1 ? objectType.getFields() : null;
        break;
      case RuleKinds.OBJECT_FIELD:
        const objectField = state2.name && objectFieldDefs ? objectFieldDefs[state2.name] : null;
        inputType = objectField === null || objectField === void 0 ? void 0 : objectField.type;
        break;
      case RuleKinds.NAMED_TYPE:
        if (state2.name) {
          type2 = schema.getType(state2.name);
        }
        break;
    }
  });
  return {
    argDef,
    argDefs,
    directiveDef,
    enumValue,
    fieldDef,
    inputType,
    objectFieldDefs,
    parentType,
    type: type2,
    interfaceDef,
    objectTypeDef
  };
}
__name(getTypeInfo, "getTypeInfo");
var GraphQLDocumentMode;
(function(GraphQLDocumentMode2) {
  GraphQLDocumentMode2["TYPE_SYSTEM"] = "TYPE_SYSTEM";
  GraphQLDocumentMode2["EXECUTABLE"] = "EXECUTABLE";
})(GraphQLDocumentMode || (GraphQLDocumentMode = {}));
function getDocumentMode(documentText, uri) {
  if (uri === null || uri === void 0 ? void 0 : uri.endsWith(".graphqls")) {
    return GraphQLDocumentMode.TYPE_SYSTEM;
  }
  return hasTypeSystemDefinitions(documentText) ? GraphQLDocumentMode.TYPE_SYSTEM : GraphQLDocumentMode.EXECUTABLE;
}
__name(getDocumentMode, "getDocumentMode");
function unwrapType(state2) {
  if (state2.prevState && state2.kind && [
    RuleKinds.NAMED_TYPE,
    RuleKinds.LIST_TYPE,
    RuleKinds.TYPE,
    RuleKinds.NON_NULL_TYPE
  ].includes(state2.kind)) {
    return unwrapType(state2.prevState);
  }
  return state2;
}
__name(unwrapType, "unwrapType");
var nullthrows$2 = { exports: {} };
function nullthrows(x2, message) {
  if (x2 != null) {
    return x2;
  }
  var error2 = new Error(message !== void 0 ? message : "Got unexpected " + x2);
  error2.framesToPop = 1;
  throw error2;
}
__name(nullthrows, "nullthrows");
nullthrows$2.exports = nullthrows;
nullthrows$2.exports.default = nullthrows;
Object.defineProperty(nullthrows$2.exports, "__esModule", { value: true });
var nullthrows$1 = /* @__PURE__ */ getDefaultExportFromCjs(nullthrows$2.exports);
const getFragmentDependenciesForAST = /* @__PURE__ */ __name((parsedOperation, fragmentDefinitions) => {
  if (!fragmentDefinitions) {
    return [];
  }
  const existingFrags = /* @__PURE__ */ new Map();
  const referencedFragNames = /* @__PURE__ */ new Set();
  visit$1(parsedOperation, {
    FragmentDefinition(node) {
      existingFrags.set(node.name.value, true);
    },
    FragmentSpread(node) {
      if (!referencedFragNames.has(node.name.value)) {
        referencedFragNames.add(node.name.value);
      }
    }
  });
  const asts = /* @__PURE__ */ new Set();
  referencedFragNames.forEach((name2) => {
    if (!existingFrags.has(name2) && fragmentDefinitions.has(name2)) {
      asts.add(nullthrows$1(fragmentDefinitions.get(name2)));
    }
  });
  const referencedFragments = [];
  asts.forEach((ast2) => {
    visit$1(ast2, {
      FragmentSpread(node) {
        if (!referencedFragNames.has(node.name.value) && fragmentDefinitions.get(node.name.value)) {
          asts.add(nullthrows$1(fragmentDefinitions.get(node.name.value)));
          referencedFragNames.add(node.name.value);
        }
      }
    });
    if (!existingFrags.has(ast2.name.value)) {
      referencedFragments.push(ast2);
    }
  });
  return referencedFragments;
}, "getFragmentDependenciesForAST");
function collectVariables(schema, documentAST) {
  const variableToType = /* @__PURE__ */ Object.create(null);
  documentAST.definitions.forEach((definition) => {
    if (definition.kind === "OperationDefinition") {
      const { variableDefinitions } = definition;
      if (variableDefinitions) {
        variableDefinitions.forEach(({ variable, type: type2 }) => {
          const inputType = typeFromAST(schema, type2);
          if (inputType) {
            variableToType[variable.name.value] = inputType;
          } else if (type2.kind === Kind$1.NAMED_TYPE && type2.name.value === "Float") {
            variableToType[variable.name.value] = GraphQLFloat$1;
          }
        });
      }
    }
  });
  return variableToType;
}
__name(collectVariables, "collectVariables");
function getOperationASTFacts(documentAST, schema) {
  const variableToType = schema ? collectVariables(schema, documentAST) : void 0;
  const operations = [];
  visit$1(documentAST, {
    OperationDefinition(node) {
      operations.push(node);
    }
  });
  return { variableToType, operations };
}
__name(getOperationASTFacts, "getOperationASTFacts");
function getOperationFacts(schema, documentString) {
  if (!documentString) {
    return;
  }
  try {
    const documentAST = parse$2(documentString);
    return Object.assign(Object.assign({}, getOperationASTFacts(documentAST, schema)), { documentAST });
  } catch (_a) {
    return;
  }
}
__name(getOperationFacts, "getOperationFacts");
globalThis && globalThis.__awaiter || function(thisArg, _arguments, P, generator) {
  function adopt(value3) {
    return value3 instanceof P ? value3 : new P(function(resolve) {
      resolve(value3);
    });
  }
  __name(adopt, "adopt");
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value3) {
      try {
        step(generator.next(value3));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(fulfilled, "fulfilled");
    function rejected(value3) {
      try {
        step(generator["throw"](value3));
      } catch (e2) {
        reject(e2);
      }
    }
    __name(rejected, "rejected");
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    __name(step, "step");
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
/*!
 * is-primitive <https://github.com/jonschlinkert/is-primitive>
 *
 * Copyright (c) 2014-present, Jon Schlinkert.
 * Released under the MIT License.
 */
var isPrimitive$1 = /* @__PURE__ */ __name(function isPrimitive(val) {
  if (typeof val === "object") {
    return val === null;
  }
  return typeof val !== "function";
}, "isPrimitive");
/*!
 * isobject <https://github.com/jonschlinkert/isobject>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isobject = /* @__PURE__ */ __name(function isObject(val) {
  return val != null && typeof val === "object" && Array.isArray(val) === false;
}, "isObject");
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
var isObject$2 = isobject;
function isObjectObject(o2) {
  return isObject$2(o2) === true && Object.prototype.toString.call(o2) === "[object Object]";
}
__name(isObjectObject, "isObjectObject");
var isPlainObject$1 = /* @__PURE__ */ __name(function isPlainObject(o2) {
  var ctor, prot;
  if (isObjectObject(o2) === false)
    return false;
  ctor = o2.constructor;
  if (typeof ctor !== "function")
    return false;
  prot = ctor.prototype;
  if (isObjectObject(prot) === false)
    return false;
  if (prot.hasOwnProperty("isPrototypeOf") === false) {
    return false;
  }
  return true;
}, "isPlainObject");
/*!
 * set-value <https://github.com/jonschlinkert/set-value>
 *
 * Copyright (c) Jon Schlinkert (https://github.com/jonschlinkert).
 * Released under the MIT License.
 */
const { deleteProperty } = Reflect;
const isPrimitive2 = isPrimitive$1;
const isPlainObject2 = isPlainObject$1;
const isObject$1 = /* @__PURE__ */ __name((value3) => {
  return typeof value3 === "object" && value3 !== null || typeof value3 === "function";
}, "isObject$1");
const isUnsafeKey = /* @__PURE__ */ __name((key) => {
  return key === "__proto__" || key === "constructor" || key === "prototype";
}, "isUnsafeKey");
const validateKey = /* @__PURE__ */ __name((key) => {
  if (!isPrimitive2(key)) {
    throw new TypeError("Object keys must be strings or symbols");
  }
  if (isUnsafeKey(key)) {
    throw new Error(`Cannot set unsafe key: "${key}"`);
  }
}, "validateKey");
const toStringKey = /* @__PURE__ */ __name((input) => {
  return Array.isArray(input) ? input.flat().map(String).join(",") : input;
}, "toStringKey");
const createMemoKey = /* @__PURE__ */ __name((input, options) => {
  if (typeof input !== "string" || !options)
    return input;
  let key = input + ";";
  if (options.arrays !== void 0)
    key += `arrays=${options.arrays};`;
  if (options.separator !== void 0)
    key += `separator=${options.separator};`;
  if (options.split !== void 0)
    key += `split=${options.split};`;
  if (options.merge !== void 0)
    key += `merge=${options.merge};`;
  if (options.preservePaths !== void 0)
    key += `preservePaths=${options.preservePaths};`;
  return key;
}, "createMemoKey");
const memoize = /* @__PURE__ */ __name((input, options, fn) => {
  const key = toStringKey(options ? createMemoKey(input, options) : input);
  validateKey(key);
  const value3 = setValue.cache.get(key) || fn();
  setValue.cache.set(key, value3);
  return value3;
}, "memoize");
const splitString = /* @__PURE__ */ __name((input, options = {}) => {
  const sep = options.separator || ".";
  const preserve = sep === "/" ? false : options.preservePaths;
  if (typeof input === "string" && preserve !== false && /\//.test(input)) {
    return [input];
  }
  const parts = [];
  let part2 = "";
  const push = /* @__PURE__ */ __name((part3) => {
    let number;
    if (part3.trim() !== "" && Number.isInteger(number = Number(part3))) {
      parts.push(number);
    } else {
      parts.push(part3);
    }
  }, "push");
  for (let i = 0; i < input.length; i++) {
    const value3 = input[i];
    if (value3 === "\\") {
      part2 += input[++i];
      continue;
    }
    if (value3 === sep) {
      push(part2);
      part2 = "";
      continue;
    }
    part2 += value3;
  }
  if (part2) {
    push(part2);
  }
  return parts;
}, "splitString");
const split = /* @__PURE__ */ __name((input, options) => {
  if (options && typeof options.split === "function")
    return options.split(input);
  if (typeof input === "symbol")
    return [input];
  if (Array.isArray(input))
    return input;
  return memoize(input, options, () => splitString(input, options));
}, "split");
const assignProp = /* @__PURE__ */ __name((obj, prop2, value3, options) => {
  validateKey(prop2);
  if (value3 === void 0) {
    deleteProperty(obj, prop2);
  } else if (options && options.merge) {
    const merge = options.merge === "function" ? options.merge : Object.assign;
    if (merge && isPlainObject2(obj[prop2]) && isPlainObject2(value3)) {
      obj[prop2] = merge(obj[prop2], value3);
    } else {
      obj[prop2] = value3;
    }
  } else {
    obj[prop2] = value3;
  }
  return obj;
}, "assignProp");
const setValue = /* @__PURE__ */ __name((target2, path, value3, options) => {
  if (!path || !isObject$1(target2))
    return target2;
  const keys = split(path, options);
  let obj = target2;
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    const next = keys[i + 1];
    validateKey(key);
    if (next === void 0) {
      assignProp(obj, key, value3, options);
      break;
    }
    if (typeof next === "number" && !Array.isArray(obj[key])) {
      obj = obj[key] = [];
      continue;
    }
    if (!isObject$1(obj[key])) {
      obj[key] = {};
    }
    obj = obj[key];
  }
  return target2;
}, "setValue");
setValue.split = split;
setValue.cache = /* @__PURE__ */ new Map();
setValue.clear = () => {
  setValue.cache = /* @__PURE__ */ new Map();
};
var setValue_1 = setValue;
function SvgArgument(_a) {
  var _b = _a, {
    title,
    titleId
  } = _b, props2 = __objRest(_b, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M5.0484 1.40838C6.12624 0.33054 7.87376 0.330541 8.9516 1.40838L12.5916 5.0484C13.6695 6.12624 13.6695 7.87376 12.5916 8.9516L8.9516 12.5916C7.87376 13.6695 6.12624 13.6695 5.0484 12.5916L1.40838 8.9516C0.33054 7.87376 0.330541 6.12624 1.40838 5.0484L5.0484 1.40838Z",
    stroke: "currentColor",
    strokeWidth: 1.2
  }), /* @__PURE__ */ React.createElement("rect", {
    x: 6,
    y: 6,
    width: 2,
    height: 2,
    rx: 1,
    fill: "currentColor"
  }));
}
__name(SvgArgument, "SvgArgument");
function SvgChevronDown(_c) {
  var _d = _c, {
    title,
    titleId
  } = _d, props2 = __objRest(_d, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 14 9",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M1 1L7 7L13 1",
    stroke: "currentColor",
    strokeWidth: 1.5
  }));
}
__name(SvgChevronDown, "SvgChevronDown");
function SvgChevronLeft(_e) {
  var _f = _e, {
    title,
    titleId
  } = _f, props2 = __objRest(_f, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 7 10",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M6 1.04819L2 5.04819L6 9.04819",
    stroke: "currentColor",
    strokeWidth: 1.75
  }));
}
__name(SvgChevronLeft, "SvgChevronLeft");
function SvgChevronUp(_g) {
  var _h = _g, {
    title,
    titleId
  } = _h, props2 = __objRest(_h, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 14 9",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M13 8L7 2L1 8",
    stroke: "currentColor",
    strokeWidth: 1.5
  }));
}
__name(SvgChevronUp, "SvgChevronUp");
function SvgClose(_i) {
  var _j = _i, {
    title,
    titleId
  } = _j, props2 = __objRest(_j, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M1 1L12.9998 12.9997",
    stroke: "currentColor",
    strokeWidth: 1.5
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M13 1L1.00079 13.0003",
    stroke: "currentColor",
    strokeWidth: 1.5
  }));
}
__name(SvgClose, "SvgClose");
function SvgCopy(_k) {
  var _l = _k, {
    title,
    titleId
  } = _l, props2 = __objRest(_l, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "-2 -2 22 22",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M11.25 14.2105V15.235C11.25 16.3479 10.3479 17.25 9.23501 17.25H2.76499C1.65214 17.25 0.75 16.3479 0.75 15.235L0.75 8.76499C0.75 7.65214 1.65214 6.75 2.76499 6.75L3.78947 6.75",
    stroke: "currentColor",
    strokeWidth: 1.5
  }), /* @__PURE__ */ React.createElement("rect", {
    x: 6.75,
    y: 0.75,
    width: 10.5,
    height: 10.5,
    rx: 2.2069,
    stroke: "currentColor",
    strokeWidth: 1.5
  }));
}
__name(SvgCopy, "SvgCopy");
function SvgDeprecatedArgument(_m) {
  var _n = _m, {
    title,
    titleId
  } = _n, props2 = __objRest(_n, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M5.0484 1.40838C6.12624 0.33054 7.87376 0.330541 8.9516 1.40838L12.5916 5.0484C13.6695 6.12624 13.6695 7.87376 12.5916 8.9516L8.9516 12.5916C7.87376 13.6695 6.12624 13.6695 5.0484 12.5916L1.40838 8.9516C0.33054 7.87376 0.330541 6.12624 1.40838 5.0484L5.0484 1.40838Z",
    stroke: "currentColor",
    strokeWidth: 1.2
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M5 9L9 5",
    stroke: "currentColor",
    strokeWidth: 1.2
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M5 5L9 9",
    stroke: "currentColor",
    strokeWidth: 1.2
  }));
}
__name(SvgDeprecatedArgument, "SvgDeprecatedArgument");
function SvgDeprecatedEnumValue(_o) {
  var _p = _o, {
    title,
    titleId
  } = _p, props2 = __objRest(_p, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 12 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M4 8L8 4",
    stroke: "currentColor",
    strokeWidth: 1.2
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M4 4L8 8",
    stroke: "currentColor",
    strokeWidth: 1.2
  }), /* @__PURE__ */ React.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M8.5 1.2H9C9.99411 1.2 10.8 2.00589 10.8 3V9C10.8 9.99411 9.99411 10.8 9 10.8H8.5V12H9C10.6569 12 12 10.6569 12 9V3C12 1.34315 10.6569 0 9 0H8.5V1.2ZM3.5 1.2V0H3C1.34315 0 0 1.34315 0 3V9C0 10.6569 1.34315 12 3 12H3.5V10.8H3C2.00589 10.8 1.2 9.99411 1.2 9V3C1.2 2.00589 2.00589 1.2 3 1.2H3.5Z",
    fill: "currentColor"
  }));
}
__name(SvgDeprecatedEnumValue, "SvgDeprecatedEnumValue");
function SvgDeprecatedField(_q) {
  var _r = _q, {
    title,
    titleId
  } = _r, props2 = __objRest(_r, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 12 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("rect", {
    x: 0.6,
    y: 0.6,
    width: 10.8,
    height: 10.8,
    rx: 3.4,
    stroke: "currentColor",
    strokeWidth: 1.2
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M4 8L8 4",
    stroke: "currentColor",
    strokeWidth: 1.2
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M4 4L8 8",
    stroke: "currentColor",
    strokeWidth: 1.2
  }));
}
__name(SvgDeprecatedField, "SvgDeprecatedField");
function SvgDirective(_s) {
  var _t = _s, {
    title,
    titleId
  } = _t, props2 = __objRest(_t, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0.5 12 12",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("rect", {
    x: 7,
    y: 5.5,
    width: 2,
    height: 2,
    rx: 1,
    transform: "rotate(90 7 5.5)",
    fill: "currentColor"
  }), /* @__PURE__ */ React.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M10.8 9L10.8 9.5C10.8 10.4941 9.99411 11.3 9 11.3L3 11.3C2.00589 11.3 1.2 10.4941 1.2 9.5L1.2 9L-3.71547e-07 9L-3.93402e-07 9.5C-4.65826e-07 11.1569 1.34314 12.5 3 12.5L9 12.5C10.6569 12.5 12 11.1569 12 9.5L12 9L10.8 9ZM10.8 4L12 4L12 3.5C12 1.84315 10.6569 0.5 9 0.5L3 0.5C1.34315 0.5 -5.87117e-08 1.84315 -1.31135e-07 3.5L-1.5299e-07 4L1.2 4L1.2 3.5C1.2 2.50589 2.00589 1.7 3 1.7L9 1.7C9.99411 1.7 10.8 2.50589 10.8 3.5L10.8 4Z",
    fill: "currentColor"
  }));
}
__name(SvgDirective, "SvgDirective");
function SvgDocsFilled(_u) {
  var _v = _u, {
    title,
    titleId
  } = _v, props2 = __objRest(_v, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 20 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M0.75 3C0.75 1.75736 1.75736 0.75 3 0.75H17.25C17.8023 0.75 18.25 1.19772 18.25 1.75V5.25",
    stroke: "currentColor",
    strokeWidth: 1.5
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M0.75 3C0.75 4.24264 1.75736 5.25 3 5.25H18.25C18.8023 5.25 19.25 5.69771 19.25 6.25V22.25C19.25 22.8023 18.8023 23.25 18.25 23.25H3C1.75736 23.25 0.75 22.2426 0.75 21V3Z",
    stroke: "currentColor",
    strokeWidth: 1.5
  }), /* @__PURE__ */ React.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M3 5.25C1.75736 5.25 0.75 4.24264 0.75 3V21C0.75 22.2426 1.75736 23.25 3 23.25H18.25C18.8023 23.25 19.25 22.8023 19.25 22.25V6.25C19.25 5.69771 18.8023 5.25 18.25 5.25H3ZM13 11L6 11V12.5L13 12.5V11Z",
    fill: "currentColor"
  }));
}
__name(SvgDocsFilled, "SvgDocsFilled");
function SvgDocs(_w) {
  var _x = _w, {
    title,
    titleId
  } = _x, props2 = __objRest(_x, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 20 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M0.75 3C0.75 4.24264 1.75736 5.25 3 5.25H17.25M0.75 3C0.75 1.75736 1.75736 0.75 3 0.75H16.25C16.8023 0.75 17.25 1.19772 17.25 1.75V5.25M0.75 3V21C0.75 22.2426 1.75736 23.25 3 23.25H18.25C18.8023 23.25 19.25 22.8023 19.25 22.25V6.25C19.25 5.69771 18.8023 5.25 18.25 5.25H17.25",
    stroke: "currentColor",
    strokeWidth: 1.5
  }), /* @__PURE__ */ React.createElement("line", {
    x1: 13,
    y1: 11.75,
    x2: 6,
    y2: 11.75,
    stroke: "currentColor",
    strokeWidth: 1.5
  }));
}
__name(SvgDocs, "SvgDocs");
function SvgEnumValue(_y) {
  var _z = _y, {
    title,
    titleId
  } = _z, props2 = __objRest(_z, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 12 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("rect", {
    x: 5,
    y: 5,
    width: 2,
    height: 2,
    rx: 1,
    fill: "currentColor"
  }), /* @__PURE__ */ React.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M8.5 1.2H9C9.99411 1.2 10.8 2.00589 10.8 3V9C10.8 9.99411 9.99411 10.8 9 10.8H8.5V12H9C10.6569 12 12 10.6569 12 9V3C12 1.34315 10.6569 0 9 0H8.5V1.2ZM3.5 1.2V0H3C1.34315 0 0 1.34315 0 3V9C0 10.6569 1.34315 12 3 12H3.5V10.8H3C2.00589 10.8 1.2 9.99411 1.2 9V3C1.2 2.00589 2.00589 1.2 3 1.2H3.5Z",
    fill: "currentColor"
  }));
}
__name(SvgEnumValue, "SvgEnumValue");
function SvgField(_A) {
  var _B = _A, {
    title,
    titleId
  } = _B, props2 = __objRest(_B, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 12 13",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("rect", {
    x: 0.6,
    y: 1.1,
    width: 10.8,
    height: 10.8,
    rx: 2.4,
    stroke: "currentColor",
    strokeWidth: 1.2
  }), /* @__PURE__ */ React.createElement("rect", {
    x: 5,
    y: 5.5,
    width: 2,
    height: 2,
    rx: 1,
    fill: "currentColor"
  }));
}
__name(SvgField, "SvgField");
function SvgHistory(_C) {
  var _D = _C, {
    title,
    titleId
  } = _D, props2 = __objRest(_D, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 24 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M1.59375 9.52344L4.87259 12.9944L8.07872 9.41249",
    stroke: "currentColor",
    strokeWidth: 1.5,
    strokeLinecap: "square"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M13.75 5.25V10.75H18.75",
    stroke: "currentColor",
    strokeWidth: 1.5,
    strokeLinecap: "square"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M4.95427 11.9332C4.55457 10.0629 4.74441 8.11477 5.49765 6.35686C6.25089 4.59894 7.5305 3.11772 9.16034 2.11709C10.7902 1.11647 12.6901 0.645626 14.5986 0.769388C16.5071 0.893151 18.3303 1.60543 19.8172 2.80818C21.3042 4.01093 22.3818 5.64501 22.9017 7.48548C23.4216 9.32595 23.3582 11.2823 22.7203 13.0853C22.0824 14.8883 20.9013 16.4492 19.3396 17.5532C17.778 18.6572 15.9125 19.25 14 19.25",
    stroke: "currentColor",
    strokeWidth: 1.5
  }));
}
__name(SvgHistory, "SvgHistory");
function SvgImplements(_E) {
  var _F = _E, {
    title,
    titleId
  } = _F, props2 = __objRest(_F, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 12 12",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("circle", {
    cx: 6,
    cy: 6,
    r: 5.4,
    stroke: "currentColor",
    strokeWidth: 1.2,
    strokeDasharray: "4.241025 4.241025",
    transform: "rotate(22.5)",
    "transform-origin": "center"
  }), /* @__PURE__ */ React.createElement("circle", {
    cx: 6,
    cy: 6,
    r: 1,
    fill: "currentColor"
  }));
}
__name(SvgImplements, "SvgImplements");
function SvgKeyboardShortcut(_G) {
  var _H = _G, {
    title,
    titleId
  } = _H, props2 = __objRest(_H, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 19 18",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M1.5 14.5653C1.5 15.211 1.75652 15.8303 2.21314 16.2869C2.66975 16.7435 3.28905 17 3.9348 17C4.58054 17 5.19984 16.7435 5.65646 16.2869C6.11307 15.8303 6.36959 15.211 6.36959 14.5653V12.1305H3.9348C3.28905 12.1305 2.66975 12.387 2.21314 12.8437C1.75652 13.3003 1.5 13.9195 1.5 14.5653Z",
    stroke: "currentColor",
    strokeWidth: 1.125,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M3.9348 1.00063C3.28905 1.00063 2.66975 1.25715 2.21314 1.71375C1.75652 2.17035 1.5 2.78964 1.5 3.43537C1.5 4.0811 1.75652 4.70038 2.21314 5.15698C2.66975 5.61358 3.28905 5.8701 3.9348 5.8701H6.36959V3.43537C6.36959 2.78964 6.11307 2.17035 5.65646 1.71375C5.19984 1.25715 4.58054 1.00063 3.9348 1.00063Z",
    stroke: "currentColor",
    strokeWidth: 1.125,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M15.0652 12.1305H12.6304V14.5653C12.6304 15.0468 12.7732 15.5175 13.0407 15.9179C13.3083 16.3183 13.6885 16.6304 14.1334 16.8147C14.5783 16.9989 15.0679 17.0472 15.5402 16.9532C16.0125 16.8593 16.4464 16.6274 16.7869 16.2869C17.1274 15.9464 17.3593 15.5126 17.4532 15.0403C17.5472 14.568 17.4989 14.0784 17.3147 13.6335C17.1304 13.1886 16.8183 12.8084 16.4179 12.5409C16.0175 12.2733 15.5468 12.1305 15.0652 12.1305Z",
    stroke: "currentColor",
    strokeWidth: 1.125,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M12.6318 5.86775H6.36955V12.1285H12.6318V5.86775Z",
    stroke: "currentColor",
    strokeWidth: 1.125,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M17.5 3.43473C17.5 2.789 17.2435 2.16972 16.7869 1.71312C16.3303 1.25652 15.711 1 15.0652 1C14.4195 1 13.8002 1.25652 13.3435 1.71312C12.8869 2.16972 12.6304 2.789 12.6304 3.43473V5.86946H15.0652C15.711 5.86946 16.3303 5.61295 16.7869 5.15635C17.2435 4.69975 17.5 4.08046 17.5 3.43473Z",
    stroke: "currentColor",
    strokeWidth: 1.125,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
}
__name(SvgKeyboardShortcut, "SvgKeyboardShortcut");
function SvgMagnifyingGlass(_I) {
  var _J = _I, {
    title,
    titleId
  } = _J, props2 = __objRest(_J, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 13 13",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("circle", {
    cx: 5,
    cy: 5,
    r: 4.35,
    stroke: "currentColor",
    strokeWidth: 1.3
  }), /* @__PURE__ */ React.createElement("line", {
    x1: 8.45962,
    y1: 8.54038,
    x2: 11.7525,
    y2: 11.8333,
    stroke: "currentColor",
    strokeWidth: 1.3
  }));
}
__name(SvgMagnifyingGlass, "SvgMagnifyingGlass");
function SvgMerge(_K) {
  var _L = _K, {
    title,
    titleId
  } = _L, props2 = __objRest(_L, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "-2 -2 22 22",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M17.2492 6V2.9569C17.2492 1.73806 16.2611 0.75 15.0423 0.75L2.9569 0.75C1.73806 0.75 0.75 1.73806 0.75 2.9569L0.75 6",
    stroke: "currentColor",
    strokeWidth: 1.5
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M0.749873 12V15.0431C0.749873 16.2619 1.73794 17.25 2.95677 17.25H15.0421C16.261 17.25 17.249 16.2619 17.249 15.0431V12",
    stroke: "currentColor",
    strokeWidth: 1.5
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M6 4.5L9 7.5L12 4.5",
    stroke: "currentColor",
    strokeWidth: 1.5
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M12 13.5L9 10.5L6 13.5",
    stroke: "currentColor",
    strokeWidth: 1.5
  }));
}
__name(SvgMerge, "SvgMerge");
function SvgPen(_M) {
  var _N = _M, {
    title,
    titleId
  } = _N, props2 = __objRest(_N, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M0.75 13.25L0.0554307 12.967C-0.0593528 13.2488 0.00743073 13.5719 0.224488 13.7851C0.441545 13.9983 0.765869 14.0592 1.04549 13.9393L0.75 13.25ZM12.8214 1.83253L12.2911 2.36286L12.2911 2.36286L12.8214 1.83253ZM12.8214 3.90194L13.3517 4.43227L12.8214 3.90194ZM10.0981 1.17859L9.56773 0.648259L10.0981 1.17859ZM12.1675 1.17859L12.6978 0.648258L12.6978 0.648257L12.1675 1.17859ZM2.58049 8.75697L3.27506 9.03994L2.58049 8.75697ZM2.70066 8.57599L3.23099 9.10632L2.70066 8.57599ZM5.2479 11.4195L4.95355 10.7297L5.2479 11.4195ZM5.42036 11.303L4.89003 10.7727L5.42036 11.303ZM4.95355 10.7297C4.08882 11.0987 3.41842 11.362 2.73535 11.6308C2.05146 11.9 1.35588 12.1743 0.454511 12.5607L1.04549 13.9393C1.92476 13.5624 2.60256 13.2951 3.28469 13.0266C3.96762 12.7578 4.65585 12.4876 5.54225 12.1093L4.95355 10.7297ZM1.44457 13.533L3.27506 9.03994L1.88592 8.474L0.0554307 12.967L1.44457 13.533ZM3.23099 9.10632L10.6284 1.70892L9.56773 0.648259L2.17033 8.04566L3.23099 9.10632ZM11.6371 1.70892L12.2911 2.36286L13.3517 1.3022L12.6978 0.648258L11.6371 1.70892ZM12.2911 3.37161L4.89003 10.7727L5.95069 11.8333L13.3517 4.43227L12.2911 3.37161ZM12.2911 2.36286C12.5696 2.64142 12.5696 3.09305 12.2911 3.37161L13.3517 4.43227C14.2161 3.56792 14.2161 2.16654 13.3517 1.3022L12.2911 2.36286ZM10.6284 1.70892C10.9069 1.43036 11.3586 1.43036 11.6371 1.70892L12.6978 0.648257C11.8335 -0.216088 10.4321 -0.216084 9.56773 0.648259L10.6284 1.70892ZM3.27506 9.03994C3.26494 9.06479 3.24996 9.08735 3.23099 9.10632L2.17033 8.04566C2.04793 8.16806 1.95123 8.31369 1.88592 8.474L3.27506 9.03994ZM5.54225 12.1093C5.69431 12.0444 5.83339 11.9506 5.95069 11.8333L4.89003 10.7727C4.90863 10.7541 4.92988 10.7398 4.95355 10.7297L5.54225 12.1093Z",
    fill: "currentColor"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M11.5 4.5L9.5 2.5",
    stroke: "currentColor",
    strokeWidth: 1.4026,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M5.5 10.5L3.5 8.5",
    stroke: "currentColor",
    strokeWidth: 1.4026,
    strokeLinecap: "round",
    strokeLinejoin: "round"
  }));
}
__name(SvgPen, "SvgPen");
function SvgPlay(_O) {
  var _P = _O, {
    title,
    titleId
  } = _P, props2 = __objRest(_P, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 16 18",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M1.32226e-07 1.6609C7.22332e-08 0.907329 0.801887 0.424528 1.46789 0.777117L15.3306 8.11621C16.0401 8.49182 16.0401 9.50818 15.3306 9.88379L1.46789 17.2229C0.801886 17.5755 1.36076e-06 17.0927 1.30077e-06 16.3391L1.32226e-07 1.6609Z",
    fill: "currentColor"
  }));
}
__name(SvgPlay, "SvgPlay");
function SvgPlus(_Q) {
  var _R = _Q, {
    title,
    titleId
  } = _R, props2 = __objRest(_R, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 10 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M4.25 9.25V13.5H5.75V9.25L10 9.25V7.75L5.75 7.75V3.5H4.25V7.75L0 7.75V9.25L4.25 9.25Z",
    fill: "currentColor"
  }));
}
__name(SvgPlus, "SvgPlus");
function SvgPrettify(_S) {
  var _T = _S, {
    title,
    titleId
  } = _T, props2 = __objRest(_T, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    width: 25,
    height: 25,
    viewBox: "0 0 25 25",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M10.2852 24.0745L13.7139 18.0742",
    stroke: "currentColor",
    strokeWidth: 1.5625
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M14.5742 24.0749L17.1457 19.7891",
    stroke: "currentColor",
    strokeWidth: 1.5625
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M19.4868 24.0735L20.7229 21.7523C21.3259 20.6143 21.5457 19.3122 21.3496 18.0394C21.1535 16.7666 20.5519 15.591 19.6342 14.6874L23.7984 6.87853C24.0123 6.47728 24.0581 6.00748 23.9256 5.57249C23.7932 5.1375 23.4933 4.77294 23.0921 4.55901C22.6908 4.34509 22.221 4.29932 21.7861 4.43178C21.3511 4.56424 20.9865 4.86408 20.7726 5.26533L16.6084 13.0742C15.3474 12.8142 14.0362 12.9683 12.8699 13.5135C11.7035 14.0586 10.7443 14.9658 10.135 16.1L6 24.0735",
    stroke: "currentColor",
    strokeWidth: 1.5625
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M4 15L5 13L7 12L5 11L4 9L3 11L1 12L3 13L4 15Z",
    stroke: "currentColor",
    strokeWidth: 1.5625,
    strokeLinejoin: "round"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M11.5 8L12.6662 5.6662L15 4.5L12.6662 3.3338L11.5 1L10.3338 3.3338L8 4.5L10.3338 5.6662L11.5 8Z",
    stroke: "currentColor",
    strokeWidth: 1.5625,
    strokeLinejoin: "round"
  }));
}
__name(SvgPrettify, "SvgPrettify");
function SvgReload(_U) {
  var _V = _U, {
    title,
    titleId
  } = _V, props2 = __objRest(_V, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M4.75 9.25H1.25V12.75",
    stroke: "currentColor",
    strokeWidth: 1,
    strokeLinecap: "square"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M11.25 6.75H14.75V3.25",
    stroke: "currentColor",
    strokeWidth: 1,
    strokeLinecap: "square"
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M14.1036 6.65539C13.8 5.27698 13.0387 4.04193 11.9437 3.15131C10.8487 2.26069 9.48447 1.76694 8.0731 1.75043C6.66173 1.73392 5.28633 2.19563 4.17079 3.0604C3.05526 3.92516 2.26529 5.14206 1.92947 6.513",
    stroke: "currentColor",
    strokeWidth: 1
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M1.89635 9.34461C2.20001 10.723 2.96131 11.9581 4.05631 12.8487C5.15131 13.7393 6.51553 14.2331 7.9269 14.2496C9.33827 14.2661 10.7137 13.8044 11.8292 12.9396C12.9447 12.0748 13.7347 10.8579 14.0705 9.487",
    stroke: "currentColor",
    strokeWidth: 1
  }));
}
__name(SvgReload, "SvgReload");
function SvgRootType(_W) {
  var _X = _W, {
    title,
    titleId
  } = _X, props2 = __objRest(_X, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 13 13",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("rect", {
    x: 0.6,
    y: 0.6,
    width: 11.8,
    height: 11.8,
    rx: 5.9,
    stroke: "currentColor",
    strokeWidth: 1.2
  }), /* @__PURE__ */ React.createElement("path", {
    d: "M4.25 7.5C4.25 6 5.75 5 6.5 6.5C7.25 8 8.75 7 8.75 5.5",
    stroke: "currentColor",
    strokeWidth: 1.2
  }));
}
__name(SvgRootType, "SvgRootType");
function SvgSettings(_Y) {
  var _Z = _Y, {
    title,
    titleId
  } = _Z, props2 = __objRest(_Z, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 21 20",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    fillRule: "evenodd",
    clipRule: "evenodd",
    d: "M9.29186 1.92702C9.06924 1.82745 8.87014 1.68202 8.70757 1.50024L7.86631 0.574931C7.62496 0.309957 7.30773 0.12592 6.95791 0.0479385C6.60809 -0.0300431 6.24274 0.00182978 5.91171 0.139208C5.58068 0.276585 5.3001 0.512774 5.10828 0.815537C4.91645 1.1183 4.82272 1.47288 4.83989 1.83089L4.90388 3.08019C4.91612 3.32348 4.87721 3.56662 4.78968 3.79394C4.70215 4.02126 4.56794 4.2277 4.39571 4.39994C4.22347 4.57219 4.01704 4.7064 3.78974 4.79394C3.56243 4.88147 3.3193 4.92038 3.07603 4.90814L1.8308 4.84414C1.47162 4.82563 1.11553 4.91881 0.811445 5.11086C0.507359 5.30292 0.270203 5.58443 0.132561 5.91671C-0.00508149 6.249 -0.0364554 6.61576 0.0427496 6.9666C0.121955 7.31744 0.307852 7.63514 0.5749 7.87606L1.50016 8.71204C1.68193 8.87461 1.82735 9.07373 1.92692 9.29636C2.02648 9.51898 2.07794 9.76012 2.07794 10.004C2.07794 10.2479 2.02648 10.489 1.92692 10.7116C1.82735 10.9343 1.68193 11.1334 1.50016 11.296L0.5749 12.1319C0.309856 12.3729 0.125575 12.6898 0.0471809 13.0393C-0.0312128 13.3888 9.64098e-05 13.754 0.13684 14.0851C0.273583 14.4162 0.509106 14.6971 0.811296 14.8894C1.11349 15.0817 1.46764 15.1762 1.82546 15.1599L3.0707 15.0959C3.31397 15.0836 3.5571 15.1225 3.7844 15.2101C4.01171 15.2976 4.21814 15.4318 4.39037 15.6041C4.56261 15.7763 4.69682 15.9827 4.78435 16.2101C4.87188 16.4374 4.91078 16.6805 4.89855 16.9238L4.83455 18.1691C4.81605 18.5283 4.90921 18.8844 5.10126 19.1885C5.2933 19.4926 5.5748 19.7298 5.90707 19.8674C6.23934 20.0051 6.60608 20.0365 6.9569 19.9572C7.30772 19.878 7.6254 19.6921 7.86631 19.4251L8.7129 18.4998C8.87547 18.318 9.07458 18.1725 9.29719 18.073C9.51981 17.9734 9.76093 17.9219 10.0048 17.9219C10.2487 17.9219 10.4898 17.9734 10.7124 18.073C10.935 18.1725 11.1341 18.318 11.2967 18.4998L12.1326 19.4251C12.3735 19.6921 12.6912 19.878 13.042 19.9572C13.3929 20.0365 13.7596 20.0051 14.0919 19.8674C14.4241 19.7298 14.7056 19.4926 14.8977 19.1885C15.0897 18.8844 15.1829 18.5283 15.1644 18.1691L15.1004 16.9238C15.0882 16.6805 15.1271 16.4374 15.2146 16.2101C15.3021 15.9827 15.4363 15.7763 15.6086 15.6041C15.7808 15.4318 15.9872 15.2976 16.2145 15.2101C16.4418 15.1225 16.685 15.0836 16.9282 15.0959L18.1735 15.1599C18.5326 15.1784 18.8887 15.0852 19.1928 14.8931C19.4969 14.7011 19.7341 14.4196 19.8717 14.0873C20.0093 13.755 20.0407 13.3882 19.9615 13.0374C19.8823 12.6866 19.6964 12.3689 19.4294 12.1279L18.5041 11.292C18.3223 11.1294 18.1769 10.9303 18.0774 10.7076C17.9778 10.485 17.9263 10.2439 17.9263 10C17.9263 9.75612 17.9778 9.51499 18.0774 9.29236C18.1769 9.06973 18.3223 8.87062 18.5041 8.70804L19.4294 7.87206C19.6964 7.63114 19.8823 7.31344 19.9615 6.9626C20.0407 6.61176 20.0093 6.245 19.8717 5.91271C19.7341 5.58043 19.4969 5.29892 19.1928 5.10686C18.8887 4.91481 18.5326 4.82163 18.1735 4.84014L16.9282 4.90414C16.685 4.91638 16.4418 4.87747 16.2145 4.78994C15.9872 4.7024 15.7808 4.56818 15.6086 4.39594C15.4363 4.2237 15.3021 4.01726 15.2146 3.78994C15.1271 3.56262 15.0882 3.31948 15.1004 3.07619L15.1644 1.83089C15.1829 1.4717 15.0897 1.11559 14.8977 0.811487C14.7056 0.507385 14.4241 0.270217 14.0919 0.132568C13.7596 -0.00508182 13.3929 -0.0364573 13.042 0.0427519C12.6912 0.121961 12.3735 0.307869 12.1326 0.574931L11.2914 1.50024C11.1288 1.68202 10.9297 1.82745 10.7071 1.92702C10.4845 2.02659 10.2433 2.07805 9.99947 2.07805C9.7556 2.07805 9.51448 2.02659 9.29186 1.92702ZM14.3745 10C14.3745 12.4162 12.4159 14.375 9.99977 14.375C7.58365 14.375 5.625 12.4162 5.625 10C5.625 7.58375 7.58365 5.625 9.99977 5.625C12.4159 5.625 14.3745 7.58375 14.3745 10Z",
    fill: "currentColor"
  }));
}
__name(SvgSettings, "SvgSettings");
function SvgStarFilled(__) {
  var _$ = __, {
    title,
    titleId
  } = _$, props2 = __objRest(_$, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M6.5782 1.07092C6.71096 0.643026 7.28904 0.643027 7.4218 1.07092L8.59318 4.84622C8.65255 5.03758 8.82284 5.16714 9.01498 5.16714L12.8056 5.16714C13.2353 5.16714 13.4139 5.74287 13.0663 6.00732L9.99962 8.34058C9.84418 8.45885 9.77913 8.66848 9.83851 8.85984L11.0099 12.6351C11.1426 13.063 10.675 13.4189 10.3274 13.1544L7.26069 10.8211C7.10524 10.7029 6.89476 10.7029 6.73931 10.8211L3.6726 13.1544C3.32502 13.4189 2.85735 13.063 2.99012 12.6351L4.16149 8.85984C4.22087 8.66848 4.15582 8.45885 4.00038 8.34058L0.933671 6.00732C0.586087 5.74287 0.764722 5.16714 1.19436 5.16714L4.98502 5.16714C5.17716 5.16714 5.34745 5.03758 5.40682 4.84622L6.5782 1.07092Z",
    fill: "currentColor",
    stroke: "currentColor"
  }));
}
__name(SvgStarFilled, "SvgStarFilled");
function SvgStar(_aa) {
  var _ba = _aa, {
    title,
    titleId
  } = _ba, props2 = __objRest(_ba, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 14 14",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("path", {
    d: "M6.5782 1.07092C6.71096 0.643026 7.28904 0.643027 7.4218 1.07092L8.59318 4.84622C8.65255 5.03758 8.82284 5.16714 9.01498 5.16714L12.8056 5.16714C13.2353 5.16714 13.4139 5.74287 13.0663 6.00732L9.99962 8.34058C9.84418 8.45885 9.77913 8.66848 9.83851 8.85984L11.0099 12.6351C11.1426 13.063 10.675 13.4189 10.3274 13.1544L7.26069 10.8211C7.10524 10.7029 6.89476 10.7029 6.73931 10.8211L3.6726 13.1544C3.32502 13.4189 2.85735 13.063 2.99012 12.6351L4.16149 8.85984C4.22087 8.66848 4.15582 8.45885 4.00038 8.34058L0.933671 6.00732C0.586087 5.74287 0.764722 5.16714 1.19436 5.16714L4.98502 5.16714C5.17716 5.16714 5.34745 5.03758 5.40682 4.84622L6.5782 1.07092Z",
    stroke: "currentColor",
    strokeWidth: 1.5
  }));
}
__name(SvgStar, "SvgStar");
function SvgStop(_ca) {
  var _da = _ca, {
    title,
    titleId
  } = _da, props2 = __objRest(_da, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 16 16",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("rect", {
    width: 16,
    height: 16,
    rx: 2,
    fill: "currentColor"
  }));
}
__name(SvgStop, "SvgStop");
function SvgType(_ea) {
  var _fa = _ea, {
    title,
    titleId
  } = _fa, props2 = __objRest(_fa, [
    "title",
    "titleId"
  ]);
  return /* @__PURE__ */ React.createElement("svg", Object.assign({
    height: "1em",
    viewBox: "0 0 13 13",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    "aria-labelledby": titleId
  }, props2), title ? /* @__PURE__ */ React.createElement("title", {
    id: titleId
  }, title) : null, /* @__PURE__ */ React.createElement("rect", {
    x: 0.6,
    y: 0.6,
    width: 11.8,
    height: 11.8,
    rx: 5.9,
    stroke: "currentColor",
    strokeWidth: 1.2
  }), /* @__PURE__ */ React.createElement("rect", {
    x: 5.5,
    y: 5.5,
    width: 2,
    height: 2,
    rx: 1,
    fill: "currentColor"
  }));
}
__name(SvgType, "SvgType");
var __defProp$E = Object.defineProperty;
var __name$E = /* @__PURE__ */ __name((target2, value3) => __defProp$E(target2, "name", { value: value3, configurable: true }), "__name$E");
const ArgumentIcon = generateIcon(SvgArgument, "argument icon");
const ChevronDownIcon = generateIcon(SvgChevronDown, "chevron down icon");
const ChevronLeftIcon = generateIcon(SvgChevronLeft, "chevron left icon");
const ChevronUpIcon = generateIcon(SvgChevronUp, "chevron up icon");
const CloseIcon = generateIcon(SvgClose, "close icon");
const CopyIcon = generateIcon(SvgCopy, "copy icon");
const DeprecatedArgumentIcon = generateIcon(SvgDeprecatedArgument, "deprecated argument icon");
const DeprecatedEnumValueIcon = generateIcon(SvgDeprecatedEnumValue, "deprecated enum value icon");
const DeprecatedFieldIcon = generateIcon(SvgDeprecatedField, "deprecated field icon");
const DirectiveIcon = generateIcon(SvgDirective, "directive icon");
const DocsFilledIcon = generateIcon(SvgDocsFilled, "filled docs icon");
const DocsIcon = generateIcon(SvgDocs, "docs icon");
const EnumValueIcon = generateIcon(SvgEnumValue, "enum value icon");
const FieldIcon = generateIcon(SvgField, "field icon");
const HistoryIcon = generateIcon(SvgHistory, "history icon");
const ImplementsIcon = generateIcon(SvgImplements, "implements icon");
const KeyboardShortcutIcon = generateIcon(SvgKeyboardShortcut, "keyboard shortcut icon");
const MagnifyingGlassIcon = generateIcon(SvgMagnifyingGlass, "magnifying glass icon");
const MergeIcon = generateIcon(SvgMerge, "merge icon");
const PenIcon = generateIcon(SvgPen, "pen icon");
const PlayIcon = generateIcon(SvgPlay, "play icon");
const PlusIcon = generateIcon(SvgPlus, "plus icon");
const PrettifyIcon = generateIcon(SvgPrettify, "prettify icon");
const ReloadIcon = generateIcon(SvgReload, "reload icon");
const RootTypeIcon = generateIcon(SvgRootType, "root type icon");
const SettingsIcon = generateIcon(SvgSettings, "settings icon");
const StarFilledIcon = generateIcon(SvgStarFilled, "filled star icon");
const StarIcon = generateIcon(SvgStar, "star icon");
const StopIcon = generateIcon(SvgStop, "stop icon");
const TypeIcon = generateIcon(SvgType, "type icon");
function generateIcon(RawComponent, title) {
  const WithTitle = /* @__PURE__ */ __name$E(/* @__PURE__ */ __name(function IconComponent(props2) {
    return /* @__PURE__ */ jsx(RawComponent, __spreadProps(__spreadValues({}, props2), {
      title
    }));
  }, "IconComponent"), "IconComponent");
  Object.defineProperty(WithTitle, "name", {
    value: RawComponent.name
  });
  return WithTitle;
}
__name(generateIcon, "generateIcon");
__name$E(generateIcon, "generateIcon");
var button$1 = /* @__PURE__ */ (() => ".graphiql-un-styled,button.graphiql-un-styled{all:unset;border-radius:var(--border-radius-4);cursor:pointer}:is(.graphiql-un-styled,button.graphiql-un-styled):hover{background-color:hsla(var(--color-neutral),var(--alpha-background-light))}:is(.graphiql-un-styled,button.graphiql-un-styled):active{background-color:hsla(var(--color-neutral),var(--alpha-background-medium))}:is(.graphiql-un-styled,button.graphiql-un-styled):focus{outline:hsla(var(--color-neutral),var(--alpha-background-heavy)) auto 1px}.graphiql-button,button.graphiql-button{background-color:hsla(var(--color-neutral),var(--alpha-background-light));border:none;border-radius:var(--border-radius-4);color:hsla(var(--color-neutral),1);cursor:pointer;font-size:var(--font-size-body);padding:var(--px-8) var(--px-12)}:is(.graphiql-button,button.graphiql-button):hover,:is(.graphiql-button,button.graphiql-button):active{background-color:hsla(var(--color-neutral),var(--alpha-background-medium))}:is(.graphiql-button,button.graphiql-button):focus{outline:hsla(var(--color-neutral),var(--alpha-background-heavy)) auto 1px}.graphiql-button-success:is(.graphiql-button,button.graphiql-button){background-color:hsla(var(--color-success),var(--alpha-background-heavy))}.graphiql-button-error:is(.graphiql-button,button.graphiql-button){background-color:hsla(var(--color-error),var(--alpha-background-heavy))}\n")();
const UnStyledButton = forwardRef((props2, ref) => /* @__PURE__ */ jsx("button", __spreadProps(__spreadValues({}, props2), {
  ref,
  className: clsx("graphiql-un-styled", props2.className)
})));
UnStyledButton.displayName = "UnStyledButton";
const Button = forwardRef((props2, ref) => /* @__PURE__ */ jsx("button", __spreadProps(__spreadValues({}, props2), {
  ref,
  className: clsx("graphiql-button", {
    success: "graphiql-button-success",
    error: "graphiql-button-error"
  }[props2.state], props2.className)
})));
Button.displayName = "Button";
var buttonGroup = /* @__PURE__ */ (() => ".graphiql-button-group{background-color:hsla(var(--color-neutral),var(--alpha-background-light));border-radius:calc(var(--border-radius-4) + var(--px-4));display:flex;padding:var(--px-4)}.graphiql-button-group>button.graphiql-button{background-color:transparent}.graphiql-button-group>button.graphiql-button:hover{background-color:hsla(var(--color-neutral),var(--alpha-background-light))}.graphiql-button-group>button.graphiql-button.active{background-color:hsl(var(--color-base));cursor:default}.graphiql-button-group>*+*{margin-left:var(--px-8)}\n")();
const ButtonGroup = forwardRef((props2, ref) => /* @__PURE__ */ jsx("div", __spreadProps(__spreadValues({}, props2), {
  ref,
  className: clsx("graphiql-button-group", props2.className)
})));
ButtonGroup.displayName = "ButtonGroup";
function canUseDOM() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}
__name(canUseDOM, "canUseDOM");
var useIsomorphicLayoutEffect = /* @__PURE__ */ canUseDOM() ? useLayoutEffect : useEffect;
function useForceUpdate() {
  var _useState = useState(/* @__PURE__ */ Object.create(null)), dispatch = _useState[1];
  return useCallback(function() {
    dispatch(/* @__PURE__ */ Object.create(null));
  }, []);
}
__name(useForceUpdate, "useForceUpdate");
function _objectWithoutPropertiesLoose$b(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
__name(_objectWithoutPropertiesLoose$b, "_objectWithoutPropertiesLoose$b");
var _excluded$a = ["unstable_skipInitialRender"];
var PortalImpl = /* @__PURE__ */ __name(function PortalImpl2(_ref2) {
  var children = _ref2.children, _ref$type = _ref2.type, type2 = _ref$type === void 0 ? "reach-portal" : _ref$type, containerRef = _ref2.containerRef;
  var mountNode = useRef(null);
  var portalNode = useRef(null);
  var forceUpdate = useForceUpdate();
  useIsomorphicLayoutEffect(function() {
    if (!mountNode.current)
      return;
    var ownerDocument = mountNode.current.ownerDocument;
    var body = (containerRef == null ? void 0 : containerRef.current) || ownerDocument.body;
    portalNode.current = ownerDocument == null ? void 0 : ownerDocument.createElement(type2);
    body.appendChild(portalNode.current);
    forceUpdate();
    return function() {
      if (portalNode.current && body) {
        body.removeChild(portalNode.current);
      }
    };
  }, [type2, forceUpdate, containerRef]);
  return portalNode.current ? /* @__PURE__ */ createPortal(children, portalNode.current) : /* @__PURE__ */ createElement("span", {
    ref: mountNode
  });
}, "PortalImpl");
var Portal = /* @__PURE__ */ __name(function Portal2(_ref2) {
  var unstable_skipInitialRender = _ref2.unstable_skipInitialRender, props2 = _objectWithoutPropertiesLoose$b(_ref2, _excluded$a);
  var _React$useState = useState(false), hydrated = _React$useState[0], setHydrated = _React$useState[1];
  useEffect(function() {
    if (unstable_skipInitialRender) {
      setHydrated(true);
    }
  }, [unstable_skipInitialRender]);
  if (unstable_skipInitialRender && !hydrated) {
    return null;
  }
  return /* @__PURE__ */ createElement(PortalImpl, props2);
}, "Portal");
function getOwnerDocument(element) {
  return canUseDOM() ? element ? element.ownerDocument : document : null;
}
__name(getOwnerDocument, "getOwnerDocument");
function isBoolean(value3) {
  return typeof value3 === "boolean";
}
__name(isBoolean, "isBoolean");
function isFunction$1(value3) {
  return !!(value3 && {}.toString.call(value3) == "[object Function]");
}
__name(isFunction$1, "isFunction$1");
function isString$1(value3) {
  return typeof value3 === "string";
}
__name(isString$1, "isString$1");
function noop() {
}
__name(noop, "noop");
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
__name(_arrayLikeToArray, "_arrayLikeToArray");
function _unsupportedIterableToArray(o2, minLen) {
  if (!o2)
    return;
  if (typeof o2 === "string")
    return _arrayLikeToArray(o2, minLen);
  var n2 = Object.prototype.toString.call(o2).slice(8, -1);
  if (n2 === "Object" && o2.constructor)
    n2 = o2.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o2);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o2, minLen);
}
__name(_unsupportedIterableToArray, "_unsupportedIterableToArray");
function _createForOfIteratorHelperLoose(o2, allowArrayLike) {
  var it2;
  if (typeof Symbol === "undefined" || o2[Symbol.iterator] == null) {
    if (Array.isArray(o2) || (it2 = _unsupportedIterableToArray(o2)) || allowArrayLike && o2 && typeof o2.length === "number") {
      if (it2)
        o2 = it2;
      var i = 0;
      return function() {
        if (i >= o2.length)
          return {
            done: true
          };
        return {
          done: false,
          value: o2[i++]
        };
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  it2 = o2[Symbol.iterator]();
  return it2.next.bind(it2);
}
__name(_createForOfIteratorHelperLoose, "_createForOfIteratorHelperLoose");
function assignRef$1(ref, value3) {
  if (ref == null)
    return;
  if (isFunction$1(ref)) {
    ref(value3);
  } else {
    try {
      ref.current = value3;
    } catch (error2) {
      throw new Error('Cannot assign value "' + value3 + '" to ref "' + ref + '"');
    }
  }
}
__name(assignRef$1, "assignRef$1");
function useComposedRefs() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }
  return useCallback(function(node) {
    for (var _iterator = _createForOfIteratorHelperLoose(refs), _step; !(_step = _iterator()).done; ) {
      var ref = _step.value;
      assignRef$1(ref, node);
    }
  }, refs);
}
__name(useComposedRefs, "useComposedRefs");
function composeEventHandlers(theirHandler, ourHandler) {
  return function(event) {
    theirHandler && theirHandler(event);
    if (!event.defaultPrevented) {
      return ourHandler(event);
    }
  };
}
__name(composeEventHandlers, "composeEventHandlers");
function _objectWithoutPropertiesLoose$a(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
__name(_objectWithoutPropertiesLoose$a, "_objectWithoutPropertiesLoose$a");
function _extends$a() {
  _extends$a = Object.assign ? Object.assign.bind() : function(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends$a.apply(this, arguments);
}
__name(_extends$a, "_extends$a");
var ReactPropTypesSecret$3 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1$1 = ReactPropTypesSecret$3;
var ReactPropTypesSecret$2 = ReactPropTypesSecret_1$1;
function emptyFunction$1() {
}
__name(emptyFunction$1, "emptyFunction$1");
function emptyFunctionWithReset$1() {
}
__name(emptyFunctionWithReset$1, "emptyFunctionWithReset$1");
emptyFunctionWithReset$1.resetWarningCache = emptyFunction$1;
var factoryWithThrowingShims$1 = /* @__PURE__ */ __name(function() {
  function shim(props2, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret$2) {
      return;
    }
    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
    err.name = "Invariant Violation";
    throw err;
  }
  __name(shim, "shim");
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  __name(getShim, "getShim");
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset$1,
    resetWarningCache: emptyFunction$1
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
}, "factoryWithThrowingShims$1");
{
  factoryWithThrowingShims$1();
}
var FOCUS_GROUP = "data-focus-lock";
var FOCUS_DISABLED = "data-focus-lock-disabled";
var FOCUS_ALLOW = "data-no-focus-lock";
var FOCUS_AUTO = "data-autofocus-inside";
var FOCUS_NO_AUTOFOCUS = "data-no-autofocus";
function assignRef(ref, value3) {
  if (typeof ref === "function") {
    ref(value3);
  } else if (ref) {
    ref.current = value3;
  }
  return ref;
}
__name(assignRef, "assignRef");
function useCallbackRef(initialValue, callback) {
  var ref = useState(function() {
    return {
      value: initialValue,
      callback,
      facade: {
        get current() {
          return ref.value;
        },
        set current(value3) {
          var last = ref.value;
          if (last !== value3) {
            ref.value = value3;
            ref.callback(value3, last);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
__name(useCallbackRef, "useCallbackRef");
function useMergeRefs(refs, defaultValue2) {
  return useCallbackRef(defaultValue2 || null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
}
__name(useMergeRefs, "useMergeRefs");
var hiddenGuard = {
  width: "1px",
  height: "0px",
  padding: 0,
  overflow: "hidden",
  position: "fixed",
  top: "1px",
  left: "1px"
};
var __assign = /* @__PURE__ */ __name(function() {
  __assign = Object.assign || /* @__PURE__ */ __name(function __assign2(t2) {
    for (var s2, i = 1, n2 = arguments.length; i < n2; i++) {
      s2 = arguments[i];
      for (var p2 in s2)
        if (Object.prototype.hasOwnProperty.call(s2, p2))
          t2[p2] = s2[p2];
    }
    return t2;
  }, "__assign");
  return __assign.apply(this, arguments);
}, "__assign");
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e2.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
}
__name(__rest, "__rest");
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l2 = from.length, ar; i < l2; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
__name(__spreadArray, "__spreadArray");
function ItoI(a2) {
  return a2;
}
__name(ItoI, "ItoI");
function innerCreateMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
      }
      buffer = {
        push: function(x2) {
          return cb(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb);
        pendingQueue = buffer;
      }
      var executeQueue = /* @__PURE__ */ __name(function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb);
      }, "executeQueue");
      var cycle = /* @__PURE__ */ __name(function() {
        return Promise.resolve().then(executeQueue);
      }, "cycle");
      cycle();
      buffer = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
__name(innerCreateMedium, "innerCreateMedium");
function createMedium(defaults, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  return innerCreateMedium(defaults, middleware);
}
__name(createMedium, "createMedium");
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
__name(createSidecarMedium, "createSidecarMedium");
var SideCar$1 = /* @__PURE__ */ __name(function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return React.createElement(Target, __assign({}, rest));
}, "SideCar$1");
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
__name(exportSidecar, "exportSidecar");
var mediumFocus = createMedium({}, function(_ref2) {
  var target2 = _ref2.target, currentTarget = _ref2.currentTarget;
  return {
    target: target2,
    currentTarget
  };
});
var mediumBlur = createMedium();
var mediumEffect = createMedium();
var mediumSidecar = createSidecarMedium({
  async: true
});
var emptyArray = [];
var FocusLock$1 = /* @__PURE__ */ React.forwardRef(/* @__PURE__ */ __name(function FocusLockUI(props2, parentRef) {
  var _extends2;
  var _React$useState = React.useState(), realObserved = _React$useState[0], setObserved = _React$useState[1];
  var observed = React.useRef();
  var isActive = React.useRef(false);
  var originalFocusedElement = React.useRef(null);
  var children = props2.children, disabled = props2.disabled, noFocusGuards = props2.noFocusGuards, persistentFocus = props2.persistentFocus, crossFrame = props2.crossFrame, autoFocus = props2.autoFocus;
  props2.allowTextSelection;
  var group = props2.group, className = props2.className, whiteList = props2.whiteList, hasPositiveIndices = props2.hasPositiveIndices, _props$shards = props2.shards, shards = _props$shards === void 0 ? emptyArray : _props$shards, _props$as = props2.as, Container = _props$as === void 0 ? "div" : _props$as, _props$lockProps = props2.lockProps, containerProps = _props$lockProps === void 0 ? {} : _props$lockProps, SideCar2 = props2.sideCar, shouldReturnFocus = props2.returnFocus, focusOptions = props2.focusOptions, onActivationCallback = props2.onActivation, onDeactivationCallback = props2.onDeactivation;
  var _React$useState2 = React.useState({}), id2 = _React$useState2[0];
  var onActivation = React.useCallback(function() {
    originalFocusedElement.current = originalFocusedElement.current || document && document.activeElement;
    if (observed.current && onActivationCallback) {
      onActivationCallback(observed.current);
    }
    isActive.current = true;
  }, [onActivationCallback]);
  var onDeactivation = React.useCallback(function() {
    isActive.current = false;
    if (onDeactivationCallback) {
      onDeactivationCallback(observed.current);
    }
  }, [onDeactivationCallback]);
  useEffect(function() {
    if (!disabled) {
      originalFocusedElement.current = null;
    }
  }, []);
  var returnFocus = React.useCallback(function(allowDefer) {
    var returnFocusTo = originalFocusedElement.current;
    if (returnFocusTo && returnFocusTo.focus) {
      var howToReturnFocus = typeof shouldReturnFocus === "function" ? shouldReturnFocus(returnFocusTo) : shouldReturnFocus;
      if (howToReturnFocus) {
        var returnFocusOptions = typeof howToReturnFocus === "object" ? howToReturnFocus : void 0;
        originalFocusedElement.current = null;
        if (allowDefer) {
          Promise.resolve().then(function() {
            return returnFocusTo.focus(returnFocusOptions);
          });
        } else {
          returnFocusTo.focus(returnFocusOptions);
        }
      }
    }
  }, [shouldReturnFocus]);
  var onFocus3 = React.useCallback(function(event) {
    if (isActive.current) {
      mediumFocus.useMedium(event);
    }
  }, []);
  var onBlur3 = mediumBlur.useMedium;
  var setObserveNode = React.useCallback(function(newObserved) {
    if (observed.current !== newObserved) {
      observed.current = newObserved;
      setObserved(newObserved);
    }
  }, []);
  var lockProps = _extends$a((_extends2 = {}, _extends2[FOCUS_DISABLED] = disabled && "disabled", _extends2[FOCUS_GROUP] = group, _extends2), containerProps);
  var hasLeadingGuards = noFocusGuards !== true;
  var hasTailingGuards = hasLeadingGuards && noFocusGuards !== "tail";
  var mergedRef = useMergeRefs([parentRef, setObserveNode]);
  return /* @__PURE__ */ React.createElement(React.Fragment, null, hasLeadingGuards && [
    /* @__PURE__ */ React.createElement("div", {
      key: "guard-first",
      "data-focus-guard": true,
      tabIndex: disabled ? -1 : 0,
      style: hiddenGuard
    }),
    hasPositiveIndices ? /* @__PURE__ */ React.createElement("div", {
      key: "guard-nearest",
      "data-focus-guard": true,
      tabIndex: disabled ? -1 : 1,
      style: hiddenGuard
    }) : null
  ], !disabled && /* @__PURE__ */ React.createElement(SideCar2, {
    id: id2,
    sideCar: mediumSidecar,
    observed: realObserved,
    disabled,
    persistentFocus,
    crossFrame,
    autoFocus,
    whiteList,
    shards,
    onActivation,
    onDeactivation,
    returnFocus,
    focusOptions
  }), /* @__PURE__ */ React.createElement(Container, _extends$a({
    ref: mergedRef
  }, lockProps, {
    className,
    onBlur: onBlur3,
    onFocus: onFocus3
  }), children), hasTailingGuards && /* @__PURE__ */ React.createElement("div", {
    "data-focus-guard": true,
    tabIndex: disabled ? -1 : 0,
    style: hiddenGuard
  }));
}, "FocusLockUI"));
FocusLock$1.propTypes = {};
FocusLock$1.defaultProps = {
  children: void 0,
  disabled: false,
  returnFocus: false,
  focusOptions: void 0,
  noFocusGuards: false,
  autoFocus: true,
  persistentFocus: false,
  crossFrame: true,
  hasPositiveIndices: void 0,
  allowTextSelection: void 0,
  group: void 0,
  className: void 0,
  whiteList: void 0,
  shards: void 0,
  as: "div",
  lockProps: {},
  onActivation: void 0,
  onDeactivation: void 0
};
var FocusLockUI2 = FocusLock$1;
function _setPrototypeOf(o2, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : /* @__PURE__ */ __name(function _setPrototypeOf2(o3, p3) {
    o3.__proto__ = p3;
    return o3;
  }, "_setPrototypeOf");
  return _setPrototypeOf(o2, p2);
}
__name(_setPrototypeOf, "_setPrototypeOf");
function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  _setPrototypeOf(subClass, superClass);
}
__name(_inheritsLoose, "_inheritsLoose");
function _defineProperty(obj, key, value3) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value3,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value3;
  }
  return obj;
}
__name(_defineProperty, "_defineProperty");
function withSideEffect(reducePropsToState2, handleStateChangeOnClient2) {
  function getDisplayName(WrappedComponent) {
    return WrappedComponent.displayName || WrappedComponent.name || "Component";
  }
  __name(getDisplayName, "getDisplayName");
  return /* @__PURE__ */ __name(function wrap2(WrappedComponent) {
    var mountedInstances = [];
    var state2;
    function emitChange() {
      state2 = reducePropsToState2(mountedInstances.map(function(instance) {
        return instance.props;
      }));
      handleStateChangeOnClient2(state2);
    }
    __name(emitChange, "emitChange");
    var SideEffect = /* @__PURE__ */ function(_PureComponent) {
      _inheritsLoose(SideEffect2, _PureComponent);
      function SideEffect2() {
        return _PureComponent.apply(this, arguments) || this;
      }
      __name(SideEffect2, "SideEffect");
      SideEffect2.peek = /* @__PURE__ */ __name(function peek() {
        return state2;
      }, "peek");
      var _proto = SideEffect2.prototype;
      _proto.componentDidMount = /* @__PURE__ */ __name(function componentDidMount() {
        mountedInstances.push(this);
        emitChange();
      }, "componentDidMount");
      _proto.componentDidUpdate = /* @__PURE__ */ __name(function componentDidUpdate() {
        emitChange();
      }, "componentDidUpdate");
      _proto.componentWillUnmount = /* @__PURE__ */ __name(function componentWillUnmount() {
        var index = mountedInstances.indexOf(this);
        mountedInstances.splice(index, 1);
        emitChange();
      }, "componentWillUnmount");
      _proto.render = /* @__PURE__ */ __name(function render() {
        return /* @__PURE__ */ jsx(WrappedComponent, __spreadValues({}, this.props));
      }, "render");
      return SideEffect2;
    }(PureComponent);
    _defineProperty(SideEffect, "displayName", "SideEffect(" + getDisplayName(WrappedComponent) + ")");
    return SideEffect;
  }, "wrap");
}
__name(withSideEffect, "withSideEffect");
var toArray = /* @__PURE__ */ __name(function(a2) {
  var ret = Array(a2.length);
  for (var i = 0; i < a2.length; ++i) {
    ret[i] = a2[i];
  }
  return ret;
}, "toArray");
var asArray = /* @__PURE__ */ __name(function(a2) {
  return Array.isArray(a2) ? a2 : [a2];
}, "asArray");
var isElementHidden = /* @__PURE__ */ __name(function(node) {
  if (node.nodeType !== Node.ELEMENT_NODE) {
    return false;
  }
  var computedStyle = window.getComputedStyle(node, null);
  if (!computedStyle || !computedStyle.getPropertyValue) {
    return false;
  }
  return computedStyle.getPropertyValue("display") === "none" || computedStyle.getPropertyValue("visibility") === "hidden";
}, "isElementHidden");
var getParentNode = /* @__PURE__ */ __name(function(node) {
  return node.parentNode && node.parentNode.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? node.parentNode.host : node.parentNode;
}, "getParentNode");
var isTopNode = /* @__PURE__ */ __name(function(node) {
  return node === document || node && node.nodeType === Node.DOCUMENT_NODE;
}, "isTopNode");
var isVisibleUncached = /* @__PURE__ */ __name(function(node, checkParent) {
  return !node || isTopNode(node) || !isElementHidden(node) && checkParent(getParentNode(node));
}, "isVisibleUncached");
var isVisibleCached = /* @__PURE__ */ __name(function(visibilityCache, node) {
  var cached = visibilityCache.get(node);
  if (cached !== void 0) {
    return cached;
  }
  var result = isVisibleUncached(node, isVisibleCached.bind(void 0, visibilityCache));
  visibilityCache.set(node, result);
  return result;
}, "isVisibleCached");
var isAutoFocusAllowedUncached = /* @__PURE__ */ __name(function(node, checkParent) {
  return node && !isTopNode(node) ? isAutoFocusAllowed(node) ? checkParent(getParentNode(node)) : false : true;
}, "isAutoFocusAllowedUncached");
var isAutoFocusAllowedCached = /* @__PURE__ */ __name(function(cache, node) {
  var cached = cache.get(node);
  if (cached !== void 0) {
    return cached;
  }
  var result = isAutoFocusAllowedUncached(node, isAutoFocusAllowedCached.bind(void 0, cache));
  cache.set(node, result);
  return result;
}, "isAutoFocusAllowedCached");
var getDataset = /* @__PURE__ */ __name(function(node) {
  return node.dataset;
}, "getDataset");
var isHTMLButtonElement = /* @__PURE__ */ __name(function(node) {
  return node.tagName === "BUTTON";
}, "isHTMLButtonElement");
var isHTMLInputElement = /* @__PURE__ */ __name(function(node) {
  return node.tagName === "INPUT";
}, "isHTMLInputElement");
var isRadioElement = /* @__PURE__ */ __name(function(node) {
  return isHTMLInputElement(node) && node.type === "radio";
}, "isRadioElement");
var notHiddenInput = /* @__PURE__ */ __name(function(node) {
  return !((isHTMLInputElement(node) || isHTMLButtonElement(node)) && (node.type === "hidden" || node.disabled));
}, "notHiddenInput");
var isAutoFocusAllowed = /* @__PURE__ */ __name(function(node) {
  var attribute2 = node.getAttribute(FOCUS_NO_AUTOFOCUS);
  return ![true, "true", ""].includes(attribute2);
}, "isAutoFocusAllowed");
var isGuard = /* @__PURE__ */ __name(function(node) {
  var _a;
  return Boolean(node && ((_a = getDataset(node)) === null || _a === void 0 ? void 0 : _a.focusGuard));
}, "isGuard");
var isNotAGuard = /* @__PURE__ */ __name(function(node) {
  return !isGuard(node);
}, "isNotAGuard");
var isDefined = /* @__PURE__ */ __name(function(x2) {
  return Boolean(x2);
}, "isDefined");
var tabSort = /* @__PURE__ */ __name(function(a2, b2) {
  var tabDiff = a2.tabIndex - b2.tabIndex;
  var indexDiff = a2.index - b2.index;
  if (tabDiff) {
    if (!a2.tabIndex) {
      return 1;
    }
    if (!b2.tabIndex) {
      return -1;
    }
  }
  return tabDiff || indexDiff;
}, "tabSort");
var orderByTabIndex = /* @__PURE__ */ __name(function(nodes, filterNegative, keepGuards) {
  return toArray(nodes).map(function(node, index) {
    return {
      node,
      index,
      tabIndex: keepGuards && node.tabIndex === -1 ? (node.dataset || {}).focusGuard ? 0 : -1 : node.tabIndex
    };
  }).filter(function(data) {
    return !filterNegative || data.tabIndex >= 0;
  }).sort(tabSort);
}, "orderByTabIndex");
var tabbables = [
  "button:enabled",
  "select:enabled",
  "textarea:enabled",
  "input:enabled",
  "a[href]",
  "area[href]",
  "summary",
  "iframe",
  "object",
  "embed",
  "audio[controls]",
  "video[controls]",
  "[tabindex]",
  "[contenteditable]",
  "[autofocus]"
];
var queryTabbables = tabbables.join(",");
var queryGuardTabbables = "".concat(queryTabbables, ", [data-focus-guard]");
var getFocusablesWithShadowDom = /* @__PURE__ */ __name(function(parent, withGuards) {
  var _a;
  return toArray(((_a = parent.shadowRoot) === null || _a === void 0 ? void 0 : _a.children) || parent.children).reduce(function(acc, child) {
    return acc.concat(child.matches(withGuards ? queryGuardTabbables : queryTabbables) ? [child] : [], getFocusablesWithShadowDom(child));
  }, []);
}, "getFocusablesWithShadowDom");
var getFocusables = /* @__PURE__ */ __name(function(parents, withGuards) {
  return parents.reduce(function(acc, parent) {
    return acc.concat(getFocusablesWithShadowDom(parent, withGuards), parent.parentNode ? toArray(parent.parentNode.querySelectorAll(queryTabbables)).filter(function(node) {
      return node === parent;
    }) : []);
  }, []);
}, "getFocusables");
var getParentAutofocusables = /* @__PURE__ */ __name(function(parent) {
  var parentFocus = parent.querySelectorAll("[".concat(FOCUS_AUTO, "]"));
  return toArray(parentFocus).map(function(node) {
    return getFocusables([node]);
  }).reduce(function(acc, nodes) {
    return acc.concat(nodes);
  }, []);
}, "getParentAutofocusables");
var filterFocusable = /* @__PURE__ */ __name(function(nodes, visibilityCache) {
  return toArray(nodes).filter(function(node) {
    return isVisibleCached(visibilityCache, node);
  }).filter(function(node) {
    return notHiddenInput(node);
  });
}, "filterFocusable");
var filterAutoFocusable = /* @__PURE__ */ __name(function(nodes, cache) {
  if (cache === void 0) {
    cache = /* @__PURE__ */ new Map();
  }
  return toArray(nodes).filter(function(node) {
    return isAutoFocusAllowedCached(cache, node);
  });
}, "filterAutoFocusable");
var getTabbableNodes = /* @__PURE__ */ __name(function(topNodes, visibilityCache, withGuards) {
  return orderByTabIndex(filterFocusable(getFocusables(topNodes, withGuards), visibilityCache), true, withGuards);
}, "getTabbableNodes");
var getAllTabbableNodes = /* @__PURE__ */ __name(function(topNodes, visibilityCache) {
  return orderByTabIndex(filterFocusable(getFocusables(topNodes), visibilityCache), false);
}, "getAllTabbableNodes");
var parentAutofocusables = /* @__PURE__ */ __name(function(topNode, visibilityCache) {
  return filterFocusable(getParentAutofocusables(topNode), visibilityCache);
}, "parentAutofocusables");
var contains = /* @__PURE__ */ __name(function(scope, element) {
  return (scope.shadowRoot ? contains(scope.shadowRoot, element) : Object.getPrototypeOf(scope).contains.call(scope, element)) || toArray(scope.children).some(function(child) {
    return contains(child, element);
  });
}, "contains");
var filterNested = /* @__PURE__ */ __name(function(nodes) {
  var contained = /* @__PURE__ */ new Set();
  var l2 = nodes.length;
  for (var i = 0; i < l2; i += 1) {
    for (var j = i + 1; j < l2; j += 1) {
      var position = nodes[i].compareDocumentPosition(nodes[j]);
      if ((position & Node.DOCUMENT_POSITION_CONTAINED_BY) > 0) {
        contained.add(j);
      }
      if ((position & Node.DOCUMENT_POSITION_CONTAINS) > 0) {
        contained.add(i);
      }
    }
  }
  return nodes.filter(function(_, index) {
    return !contained.has(index);
  });
}, "filterNested");
var getTopParent = /* @__PURE__ */ __name(function(node) {
  return node.parentNode ? getTopParent(node.parentNode) : node;
}, "getTopParent");
var getAllAffectedNodes = /* @__PURE__ */ __name(function(node) {
  var nodes = asArray(node);
  return nodes.filter(Boolean).reduce(function(acc, currentNode) {
    var group = currentNode.getAttribute(FOCUS_GROUP);
    acc.push.apply(acc, group ? filterNested(toArray(getTopParent(currentNode).querySelectorAll("[".concat(FOCUS_GROUP, '="').concat(group, '"]:not([').concat(FOCUS_DISABLED, '="disabled"])')))) : [currentNode]);
    return acc;
  }, []);
}, "getAllAffectedNodes");
var getNestedShadowActiveElement = /* @__PURE__ */ __name(function(shadowRoot) {
  return shadowRoot.activeElement ? shadowRoot.activeElement.shadowRoot ? getNestedShadowActiveElement(shadowRoot.activeElement.shadowRoot) : shadowRoot.activeElement : void 0;
}, "getNestedShadowActiveElement");
var getActiveElement = /* @__PURE__ */ __name(function() {
  return document.activeElement ? document.activeElement.shadowRoot ? getNestedShadowActiveElement(document.activeElement.shadowRoot) : document.activeElement : void 0;
}, "getActiveElement");
var focusInFrame = /* @__PURE__ */ __name(function(frame) {
  return frame === document.activeElement;
}, "focusInFrame");
var focusInsideIframe = /* @__PURE__ */ __name(function(topNode) {
  return Boolean(toArray(topNode.querySelectorAll("iframe")).some(function(node) {
    return focusInFrame(node);
  }));
}, "focusInsideIframe");
var focusInside = /* @__PURE__ */ __name(function(topNode) {
  var activeElement = document && getActiveElement();
  if (!activeElement || activeElement.dataset && activeElement.dataset.focusGuard) {
    return false;
  }
  return getAllAffectedNodes(topNode).some(function(node) {
    return contains(node, activeElement) || focusInsideIframe(node);
  });
}, "focusInside");
var focusIsHidden = /* @__PURE__ */ __name(function() {
  var activeElement = document && getActiveElement();
  if (!activeElement) {
    return false;
  }
  return toArray(document.querySelectorAll("[".concat(FOCUS_ALLOW, "]"))).some(function(node) {
    return contains(node, activeElement);
  });
}, "focusIsHidden");
var findSelectedRadio = /* @__PURE__ */ __name(function(node, nodes) {
  return nodes.filter(isRadioElement).filter(function(el2) {
    return el2.name === node.name;
  }).filter(function(el2) {
    return el2.checked;
  })[0] || node;
}, "findSelectedRadio");
var correctNode = /* @__PURE__ */ __name(function(node, nodes) {
  if (isRadioElement(node) && node.name) {
    return findSelectedRadio(node, nodes);
  }
  return node;
}, "correctNode");
var correctNodes = /* @__PURE__ */ __name(function(nodes) {
  var resultSet = /* @__PURE__ */ new Set();
  nodes.forEach(function(node) {
    return resultSet.add(correctNode(node, nodes));
  });
  return nodes.filter(function(node) {
    return resultSet.has(node);
  });
}, "correctNodes");
var pickFirstFocus = /* @__PURE__ */ __name(function(nodes) {
  if (nodes[0] && nodes.length > 1) {
    return correctNode(nodes[0], nodes);
  }
  return nodes[0];
}, "pickFirstFocus");
var pickFocusable = /* @__PURE__ */ __name(function(nodes, index) {
  if (nodes.length > 1) {
    return nodes.indexOf(correctNode(nodes[index], nodes));
  }
  return index;
}, "pickFocusable");
var NEW_FOCUS = "NEW_FOCUS";
var newFocus = /* @__PURE__ */ __name(function(innerNodes, outerNodes, activeElement, lastNode) {
  var cnt = innerNodes.length;
  var firstFocus = innerNodes[0];
  var lastFocus = innerNodes[cnt - 1];
  var isOnGuard = isGuard(activeElement);
  if (activeElement && innerNodes.indexOf(activeElement) >= 0) {
    return void 0;
  }
  var activeIndex = activeElement !== void 0 ? outerNodes.indexOf(activeElement) : -1;
  var lastIndex = lastNode ? outerNodes.indexOf(lastNode) : activeIndex;
  var lastNodeInside = lastNode ? innerNodes.indexOf(lastNode) : -1;
  var indexDiff = activeIndex - lastIndex;
  var firstNodeIndex = outerNodes.indexOf(firstFocus);
  var lastNodeIndex = outerNodes.indexOf(lastFocus);
  var correctedNodes = correctNodes(outerNodes);
  var correctedIndex = activeElement !== void 0 ? correctedNodes.indexOf(activeElement) : -1;
  var correctedIndexDiff = correctedIndex - (lastNode ? correctedNodes.indexOf(lastNode) : activeIndex);
  var returnFirstNode = pickFocusable(innerNodes, 0);
  var returnLastNode = pickFocusable(innerNodes, cnt - 1);
  if (activeIndex === -1 || lastNodeInside === -1) {
    return NEW_FOCUS;
  }
  if (!indexDiff && lastNodeInside >= 0) {
    return lastNodeInside;
  }
  if (activeIndex <= firstNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnLastNode;
  }
  if (activeIndex >= lastNodeIndex && isOnGuard && Math.abs(indexDiff) > 1) {
    return returnFirstNode;
  }
  if (indexDiff && Math.abs(correctedIndexDiff) > 1) {
    return lastNodeInside;
  }
  if (activeIndex <= firstNodeIndex) {
    return returnLastNode;
  }
  if (activeIndex > lastNodeIndex) {
    return returnFirstNode;
  }
  if (indexDiff) {
    if (Math.abs(indexDiff) > 1) {
      return lastNodeInside;
    }
    return (cnt + lastNodeInside + indexDiff) % cnt;
  }
  return void 0;
}, "newFocus");
var getParents = /* @__PURE__ */ __name(function(node, parents) {
  if (parents === void 0) {
    parents = [];
  }
  parents.push(node);
  if (node.parentNode) {
    getParents(node.parentNode.host || node.parentNode, parents);
  }
  return parents;
}, "getParents");
var getCommonParent = /* @__PURE__ */ __name(function(nodeA, nodeB) {
  var parentsA = getParents(nodeA);
  var parentsB = getParents(nodeB);
  for (var i = 0; i < parentsA.length; i += 1) {
    var currentParent = parentsA[i];
    if (parentsB.indexOf(currentParent) >= 0) {
      return currentParent;
    }
  }
  return false;
}, "getCommonParent");
var getTopCommonParent = /* @__PURE__ */ __name(function(baseActiveElement, leftEntry, rightEntries) {
  var activeElements = asArray(baseActiveElement);
  var leftEntries = asArray(leftEntry);
  var activeElement = activeElements[0];
  var topCommon = false;
  leftEntries.filter(Boolean).forEach(function(entry) {
    topCommon = getCommonParent(topCommon || entry, entry) || topCommon;
    rightEntries.filter(Boolean).forEach(function(subEntry) {
      var common = getCommonParent(activeElement, subEntry);
      if (common) {
        if (!topCommon || contains(common, topCommon)) {
          topCommon = common;
        } else {
          topCommon = getCommonParent(common, topCommon);
        }
      }
    });
  });
  return topCommon;
}, "getTopCommonParent");
var allParentAutofocusables = /* @__PURE__ */ __name(function(entries, visibilityCache) {
  return entries.reduce(function(acc, node) {
    return acc.concat(parentAutofocusables(node, visibilityCache));
  }, []);
}, "allParentAutofocusables");
var findAutoFocused = /* @__PURE__ */ __name(function(autoFocusables) {
  return function(node) {
    var _a;
    return node.autofocus || !!((_a = getDataset(node)) === null || _a === void 0 ? void 0 : _a.autofocus) || autoFocusables.indexOf(node) >= 0;
  };
}, "findAutoFocused");
var reorderNodes = /* @__PURE__ */ __name(function(srcNodes, dstNodes) {
  var remap = /* @__PURE__ */ new Map();
  dstNodes.forEach(function(entity3) {
    return remap.set(entity3.node, entity3);
  });
  return srcNodes.map(function(node) {
    return remap.get(node);
  }).filter(isDefined);
}, "reorderNodes");
var getFocusMerge = /* @__PURE__ */ __name(function(topNode, lastNode) {
  var activeElement = document && getActiveElement();
  var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);
  var commonParent = getTopCommonParent(activeElement || topNode, topNode, entries);
  var visibilityCache = /* @__PURE__ */ new Map();
  var anyFocusable = getAllTabbableNodes(entries, visibilityCache);
  var innerElements = getTabbableNodes(entries, visibilityCache).filter(function(_a) {
    var node = _a.node;
    return isNotAGuard(node);
  });
  if (!innerElements[0]) {
    innerElements = anyFocusable;
    if (!innerElements[0]) {
      return void 0;
    }
  }
  var outerNodes = getAllTabbableNodes([commonParent], visibilityCache).map(function(_a) {
    var node = _a.node;
    return node;
  });
  var orderedInnerElements = reorderNodes(outerNodes, innerElements);
  var innerNodes = orderedInnerElements.map(function(_a) {
    var node = _a.node;
    return node;
  });
  var newId = newFocus(innerNodes, outerNodes, activeElement, lastNode);
  if (newId === NEW_FOCUS) {
    var autoFocusable = filterAutoFocusable(anyFocusable.map(function(_a) {
      var node = _a.node;
      return node;
    })).filter(findAutoFocused(allParentAutofocusables(entries, visibilityCache)));
    return {
      node: autoFocusable && autoFocusable.length ? pickFirstFocus(autoFocusable) : pickFirstFocus(filterAutoFocusable(innerNodes))
    };
  }
  if (newId === void 0) {
    return newId;
  }
  return orderedInnerElements[newId];
}, "getFocusMerge");
var getFocusabledIn = /* @__PURE__ */ __name(function(topNode) {
  var entries = getAllAffectedNodes(topNode).filter(isNotAGuard);
  var commonParent = getTopCommonParent(topNode, topNode, entries);
  var visibilityCache = /* @__PURE__ */ new Map();
  var outerNodes = getTabbableNodes([commonParent], visibilityCache, true);
  var innerElements = getTabbableNodes(entries, visibilityCache).filter(function(_a) {
    var node = _a.node;
    return isNotAGuard(node);
  }).map(function(_a) {
    var node = _a.node;
    return node;
  });
  return outerNodes.map(function(_a) {
    var node = _a.node, index = _a.index;
    return {
      node,
      index,
      lockItem: innerElements.indexOf(node) >= 0,
      guard: isGuard(node)
    };
  });
}, "getFocusabledIn");
var focusOn = /* @__PURE__ */ __name(function(target2, focusOptions) {
  if ("focus" in target2) {
    target2.focus(focusOptions);
  }
  if ("contentWindow" in target2 && target2.contentWindow) {
    target2.contentWindow.focus();
  }
}, "focusOn");
var guardCount = 0;
var lockDisabled = false;
var setFocus = /* @__PURE__ */ __name(function(topNode, lastNode, options) {
  if (options === void 0) {
    options = {};
  }
  var focusable = getFocusMerge(topNode, lastNode);
  if (lockDisabled) {
    return;
  }
  if (focusable) {
    if (guardCount > 2) {
      console.error("FocusLock: focus-fighting detected. Only one focus management system could be active. See https://github.com/theKashey/focus-lock/#focus-fighting");
      lockDisabled = true;
      setTimeout(function() {
        lockDisabled = false;
      }, 1);
      return;
    }
    guardCount++;
    focusOn(focusable.node, options.focusOptions);
    guardCount--;
  }
}, "setFocus");
var moveFocusInside = setFocus;
function deferAction(action) {
  var _window = window, setImmediate = _window.setImmediate;
  if (typeof setImmediate !== "undefined") {
    setImmediate(action);
  } else {
    setTimeout(action, 1);
  }
}
__name(deferAction, "deferAction");
var focusOnBody = /* @__PURE__ */ __name(function focusOnBody2() {
  return document && document.activeElement === document.body;
}, "focusOnBody");
var isFreeFocus = /* @__PURE__ */ __name(function isFreeFocus2() {
  return focusOnBody() || focusIsHidden();
}, "isFreeFocus");
var lastActiveTrap = null;
var lastActiveFocus = null;
var lastPortaledElement = null;
var focusWasOutsideWindow = false;
var defaultWhitelist = /* @__PURE__ */ __name(function defaultWhitelist2() {
  return true;
}, "defaultWhitelist");
var focusWhitelisted = /* @__PURE__ */ __name(function focusWhitelisted2(activeElement) {
  return (lastActiveTrap.whiteList || defaultWhitelist)(activeElement);
}, "focusWhitelisted");
var recordPortal = /* @__PURE__ */ __name(function recordPortal2(observerNode, portaledElement) {
  lastPortaledElement = {
    observerNode,
    portaledElement
  };
}, "recordPortal");
var focusIsPortaledPair = /* @__PURE__ */ __name(function focusIsPortaledPair2(element) {
  return lastPortaledElement && lastPortaledElement.portaledElement === element;
}, "focusIsPortaledPair");
function autoGuard(startIndex, end, step, allNodes) {
  var lastGuard = null;
  var i = startIndex;
  do {
    var item = allNodes[i];
    if (item.guard) {
      if (item.node.dataset.focusAutoGuard) {
        lastGuard = item;
      }
    } else if (item.lockItem) {
      if (i !== startIndex) {
        return;
      }
      lastGuard = null;
    } else {
      break;
    }
  } while ((i += step) !== end);
  if (lastGuard) {
    lastGuard.node.tabIndex = 0;
  }
}
__name(autoGuard, "autoGuard");
var extractRef$1 = /* @__PURE__ */ __name(function extractRef(ref) {
  return ref && "current" in ref ? ref.current : ref;
}, "extractRef");
var focusWasOutside = /* @__PURE__ */ __name(function focusWasOutside2(crossFrameOption) {
  if (crossFrameOption) {
    return Boolean(focusWasOutsideWindow);
  }
  return focusWasOutsideWindow === "meanwhile";
}, "focusWasOutside");
var checkInHost = /* @__PURE__ */ __name(function checkInHost2(check2, el2, boundary) {
  return el2 && (el2.host === check2 && (!el2.activeElement || boundary.contains(el2.activeElement)) || el2.parentNode && checkInHost2(check2, el2.parentNode, boundary));
}, "checkInHost");
var withinHost = /* @__PURE__ */ __name(function withinHost2(activeElement, workingArea) {
  return workingArea.some(function(area) {
    return checkInHost(activeElement, area, area);
  });
}, "withinHost");
var activateTrap = /* @__PURE__ */ __name(function activateTrap2() {
  var result = false;
  if (lastActiveTrap) {
    var _lastActiveTrap = lastActiveTrap, observed = _lastActiveTrap.observed, persistentFocus = _lastActiveTrap.persistentFocus, autoFocus = _lastActiveTrap.autoFocus, shards = _lastActiveTrap.shards, crossFrame = _lastActiveTrap.crossFrame, focusOptions = _lastActiveTrap.focusOptions;
    var workingNode = observed || lastPortaledElement && lastPortaledElement.portaledElement;
    var activeElement = document && document.activeElement;
    if (workingNode) {
      var workingArea = [workingNode].concat(shards.map(extractRef$1).filter(Boolean));
      if (!activeElement || focusWhitelisted(activeElement)) {
        if (persistentFocus || focusWasOutside(crossFrame) || !isFreeFocus() || !lastActiveFocus && autoFocus) {
          if (workingNode && !(focusInside(workingArea) || activeElement && withinHost(activeElement, workingArea) || focusIsPortaledPair(activeElement))) {
            if (document && !lastActiveFocus && activeElement && !autoFocus) {
              if (activeElement.blur) {
                activeElement.blur();
              }
              document.body.focus();
            } else {
              result = moveFocusInside(workingArea, lastActiveFocus, {
                focusOptions
              });
              lastPortaledElement = {};
            }
          }
          focusWasOutsideWindow = false;
          lastActiveFocus = document && document.activeElement;
        }
      }
      if (document) {
        var newActiveElement = document && document.activeElement;
        var allNodes = getFocusabledIn(workingArea);
        var focusedIndex = allNodes.map(function(_ref2) {
          var node = _ref2.node;
          return node;
        }).indexOf(newActiveElement);
        if (focusedIndex > -1) {
          allNodes.filter(function(_ref2) {
            var guard = _ref2.guard, node = _ref2.node;
            return guard && node.dataset.focusAutoGuard;
          }).forEach(function(_ref3) {
            var node = _ref3.node;
            return node.removeAttribute("tabIndex");
          });
          autoGuard(focusedIndex, allNodes.length, 1, allNodes);
          autoGuard(focusedIndex, -1, -1, allNodes);
        }
      }
    }
  }
  return result;
}, "activateTrap");
var onTrap = /* @__PURE__ */ __name(function onTrap2(event) {
  if (activateTrap() && event) {
    event.stopPropagation();
    event.preventDefault();
  }
}, "onTrap");
var onBlur = /* @__PURE__ */ __name(function onBlur2() {
  return deferAction(activateTrap);
}, "onBlur");
var onFocus = /* @__PURE__ */ __name(function onFocus2(event) {
  var source = event.target;
  var currentNode = event.currentTarget;
  if (!currentNode.contains(source)) {
    recordPortal(currentNode, source);
  }
}, "onFocus");
var FocusWatcher = /* @__PURE__ */ __name(function FocusWatcher2() {
  return null;
}, "FocusWatcher");
var onWindowBlur = /* @__PURE__ */ __name(function onWindowBlur2() {
  focusWasOutsideWindow = "just";
  setTimeout(function() {
    focusWasOutsideWindow = "meanwhile";
  }, 0);
}, "onWindowBlur");
var attachHandler = /* @__PURE__ */ __name(function attachHandler2() {
  document.addEventListener("focusin", onTrap);
  document.addEventListener("focusout", onBlur);
  window.addEventListener("blur", onWindowBlur);
}, "attachHandler");
var detachHandler = /* @__PURE__ */ __name(function detachHandler2() {
  document.removeEventListener("focusin", onTrap);
  document.removeEventListener("focusout", onBlur);
  window.removeEventListener("blur", onWindowBlur);
}, "detachHandler");
function reducePropsToState(propsList) {
  return propsList.filter(function(_ref5) {
    var disabled = _ref5.disabled;
    return !disabled;
  });
}
__name(reducePropsToState, "reducePropsToState");
function handleStateChangeOnClient(traps) {
  var trap = traps.slice(-1)[0];
  if (trap && !lastActiveTrap) {
    attachHandler();
  }
  var lastTrap = lastActiveTrap;
  var sameTrap = lastTrap && trap && trap.id === lastTrap.id;
  lastActiveTrap = trap;
  if (lastTrap && !sameTrap) {
    lastTrap.onDeactivation();
    if (!traps.filter(function(_ref6) {
      var id2 = _ref6.id;
      return id2 === lastTrap.id;
    }).length) {
      lastTrap.returnFocus(!trap);
    }
  }
  if (trap) {
    lastActiveFocus = null;
    if (!sameTrap || lastTrap.observed !== trap.observed) {
      trap.onActivation();
    }
    activateTrap();
    deferAction(activateTrap);
  } else {
    detachHandler();
    lastActiveFocus = null;
  }
}
__name(handleStateChangeOnClient, "handleStateChangeOnClient");
mediumFocus.assignSyncMedium(onFocus);
mediumBlur.assignMedium(onBlur);
mediumEffect.assignMedium(function(cb) {
  return cb({
    moveFocusInside,
    focusInside
  });
});
var FocusTrap = withSideEffect(reducePropsToState, handleStateChangeOnClient)(FocusWatcher);
var FocusLockCombination = /* @__PURE__ */ React.forwardRef(/* @__PURE__ */ __name(function FocusLockUICombination(props2, ref) {
  return /* @__PURE__ */ React.createElement(FocusLockUI2, _extends$a({
    sideCar: FocusTrap,
    ref
  }, props2));
}, "FocusLockUICombination"));
var _ref = FocusLockUI2.propTypes || {};
_ref.sideCar;
_objectWithoutPropertiesLoose$a(_ref, ["sideCar"]);
FocusLockCombination.propTypes = {};
var FocusLock = FocusLockCombination;
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
var effectCar = createSidecarMedium();
var nothing = /* @__PURE__ */ __name(function() {
  return;
}, "nothing");
var RemoveScroll$1 = React.forwardRef(function(props2, parentRef) {
  var ref = React.useRef(null);
  var _a = React.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props2.forwardProps, children = props2.children, className = props2.className, removeScrollBar = props2.removeScrollBar, enabled = props2.enabled, shards = props2.shards, sideCar = props2.sideCar, noIsolation = props2.noIsolation, inert = props2.inert, allowPinchZoom = props2.allowPinchZoom, _b = props2.as, Container = _b === void 0 ? "div" : _b, rest = __rest(props2, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return React.createElement(React.Fragment, null, enabled && React.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref }), forwardProps ? React.cloneElement(React.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : React.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children));
});
RemoveScroll$1.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll$1.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = /* @__PURE__ */ __name(function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
}, "getNonce");
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
__name(makeStyleTag, "makeStyleTag");
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
__name(injectStyles, "injectStyles");
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
__name(insertStyleTag, "insertStyleTag");
var stylesheetSingleton = /* @__PURE__ */ __name(function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style2) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style2);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
}, "stylesheetSingleton");
var styleHookSingleton = /* @__PURE__ */ __name(function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    React.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
}, "styleHookSingleton");
var styleSingleton = /* @__PURE__ */ __name(function() {
  var useStyle = styleHookSingleton();
  var Sheet = /* @__PURE__ */ __name(function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  }, "Sheet");
  return Sheet;
}, "styleSingleton");
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse$1 = /* @__PURE__ */ __name(function(x2) {
  return parseInt(x2 || "", 10) || 0;
}, "parse$1");
var getOffset = /* @__PURE__ */ __name(function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top2 = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse$1(left), parse$1(top2), parse$1(right)];
}, "getOffset");
var getGapWidth = /* @__PURE__ */ __name(function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
}, "getGapWidth");
var Style = styleSingleton();
var getStyles$2 = /* @__PURE__ */ __name(function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top2 = _a.top, right = _a.right, gap2 = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap2, "px ").concat(important, ";\n  }\n  body {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top2, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap2, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap2, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap2, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap2, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body {\n    ").concat(removedBarSizeVariable, ": ").concat(gap2, "px;\n  }\n");
}, "getStyles$2");
var RemoveScrollBar = /* @__PURE__ */ __name(function(props2) {
  var noRelative = props2.noRelative, noImportant = props2.noImportant, _a = props2.gapMode, gapMode = _a === void 0 ? "margin" : _a;
  var gap2 = React.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return React.createElement(Style, { styles: getStyles$2(gap2, !noRelative, gapMode, !noImportant ? "!important" : "") });
}, "RemoveScrollBar");
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = /* @__PURE__ */ __name(function(node) {
  return node.tagName === "TEXTAREA";
}, "alwaysContainsScroll");
var elementCanBeScrolled = /* @__PURE__ */ __name(function(node, overflow) {
  var styles = window.getComputedStyle(node);
  return styles[overflow] !== "hidden" && !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible");
}, "elementCanBeScrolled");
var elementCouldBeVScrolled = /* @__PURE__ */ __name(function(node) {
  return elementCanBeScrolled(node, "overflowY");
}, "elementCouldBeVScrolled");
var elementCouldBeHScrolled = /* @__PURE__ */ __name(function(node) {
  return elementCanBeScrolled(node, "overflowX");
}, "elementCouldBeHScrolled");
var locationCouldBeScrolled = /* @__PURE__ */ __name(function(axis, node) {
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), s2 = _a[1], d2 = _a[2];
      if (s2 > d2) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== document.body);
  return false;
}, "locationCouldBeScrolled");
var getVScrollVariables = /* @__PURE__ */ __name(function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
}, "getVScrollVariables");
var getHScrollVariables = /* @__PURE__ */ __name(function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
}, "getHScrollVariables");
var elementCouldBeScrolled = /* @__PURE__ */ __name(function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
}, "elementCouldBeScrolled");
var getScrollVariables = /* @__PURE__ */ __name(function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
}, "getScrollVariables");
var getDirectionFactor = /* @__PURE__ */ __name(function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
}, "getDirectionFactor");
var handleScroll = /* @__PURE__ */ __name(function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta2 = directionFactor * sourceDelta;
  var target2 = event.target;
  var targetInLock = endTarget.contains(target2);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta2 > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target2), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target2)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    target2 = target2.parentNode;
  } while (!targetInLock && target2 !== document.body || targetInLock && (endTarget.contains(target2) || endTarget === target2));
  if (isDeltaPositive && (noOverscroll && availableScroll === 0 || !noOverscroll && delta2 > availableScroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (noOverscroll && availableScrollTop === 0 || !noOverscroll && -delta2 > availableScrollTop)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
}, "handleScroll");
var getTouchXY = /* @__PURE__ */ __name(function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
}, "getTouchXY");
var getDeltaXY = /* @__PURE__ */ __name(function(event) {
  return [event.deltaX, event.deltaY];
}, "getDeltaXY");
var extractRef2 = /* @__PURE__ */ __name(function(ref) {
  return ref && "current" in ref ? ref.current : ref;
}, "extractRef");
var deltaCompare = /* @__PURE__ */ __name(function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
}, "deltaCompare");
var generateStyle = /* @__PURE__ */ __name(function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
}, "generateStyle");
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props2) {
  var shouldPreventQueue = React.useRef([]);
  var touchStartRef = React.useRef([0, 0]);
  var activeAxis = React.useRef();
  var id2 = React.useState(idCounter++)[0];
  var Style2 = React.useState(function() {
    return styleSingleton();
  })[0];
  var lastProps = React.useRef(props2);
  React.useEffect(function() {
    lastProps.current = props2;
  }, [props2]);
  React.useEffect(function() {
    if (props2.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray([props2.lockRef.current], (props2.shards || []).map(extractRef2), true).filter(Boolean);
      allow_1.forEach(function(el2) {
        return el2.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el2) {
          return el2.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props2.inert, props2.lockRef.current, props2.shards]);
  var shouldCancelEvent = React.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target2 = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target2.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target2);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target2);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = React.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta2 = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && e2.target === event.target && deltaCompare(e2.delta, delta2);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef2).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = React.useCallback(function(name2, delta2, target2, should) {
    var event = { name: name2, delta: delta2, target: target2, should };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = React.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = React.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props2.lockRef.current));
  }, []);
  var scrollTouchMove = React.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props2.lockRef.current));
  }, []);
  React.useEffect(function() {
    lockStack.push(Style2);
    props2.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props2.removeScrollBar, inert = props2.inert;
  return React.createElement(React.Fragment, null, inert ? React.createElement(Style2, { styles: generateStyle(id2) }) : null, removeScrollBar ? React.createElement(RemoveScrollBar, { gapMode: "margin" }) : null);
}
__name(RemoveScrollSideCar, "RemoveScrollSideCar");
var SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = React.forwardRef(function(props2, ref) {
  return React.createElement(RemoveScroll$1, __assign({}, props2, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll$1.classNames;
var RemoveScroll = ReactRemoveScroll;
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
__name(emptyFunction, "emptyFunction");
function emptyFunctionWithReset() {
}
__name(emptyFunctionWithReset, "emptyFunctionWithReset");
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = /* @__PURE__ */ __name(function() {
  function shim(props2, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
    err.name = "Invariant Violation";
    throw err;
  }
  __name(shim, "shim");
  shim.isRequired = shim;
  function getShim() {
    return shim;
  }
  __name(getShim, "getShim");
  var ReactPropTypes = {
    array: shim,
    bigint: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,
    any: shim,
    arrayOf: getShim,
    element: shim,
    elementType: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
}, "factoryWithThrowingShims");
{
  propTypes.exports = factoryWithThrowingShims();
}
var PropTypes = propTypes.exports;
function _extends$9() {
  _extends$9 = Object.assign || function(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends$9.apply(this, arguments);
}
__name(_extends$9, "_extends$9");
function _objectWithoutPropertiesLoose$9(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
__name(_objectWithoutPropertiesLoose$9, "_objectWithoutPropertiesLoose$9");
var _excluded$9 = ["as", "isOpen"], _excluded2$5 = ["allowPinchZoom", "as", "dangerouslyBypassFocusLock", "dangerouslyBypassScrollLock", "initialFocusRef", "onClick", "onDismiss", "onKeyDown", "onMouseDown", "unstable_lockFocusAcrossFrames"], _excluded3$5 = ["as", "onClick", "onKeyDown"], _excluded4$4 = ["allowPinchZoom", "initialFocusRef", "isOpen", "onDismiss"];
({
  allowPinchZoom: PropTypes.bool,
  dangerouslyBypassFocusLock: PropTypes.bool,
  dangerouslyBypassScrollLock: PropTypes.bool,
  initialFocusRef: /* @__PURE__ */ __name(function initialFocusRef() {
    return null;
  }, "initialFocusRef"),
  onDismiss: PropTypes.func
});
var DialogOverlay = /* @__PURE__ */ forwardRef(/* @__PURE__ */ __name(function DialogOverlay2(_ref2, forwardedRef) {
  var _ref$as = _ref2.as, Comp = _ref$as === void 0 ? "div" : _ref$as, _ref$isOpen = _ref2.isOpen, isOpen = _ref$isOpen === void 0 ? true : _ref$isOpen, props2 = _objectWithoutPropertiesLoose$9(_ref2, _excluded$9);
  useEffect(function() {
    if (isOpen) {
      window.__REACH_DISABLE_TOOLTIPS = true;
    } else {
      window.requestAnimationFrame(function() {
        window.__REACH_DISABLE_TOOLTIPS = false;
      });
    }
  }, [isOpen]);
  return isOpen ? /* @__PURE__ */ createElement(Portal, {
    "data-reach-dialog-wrapper": ""
  }, /* @__PURE__ */ createElement(DialogInner, _extends$9({
    ref: forwardedRef,
    as: Comp
  }, props2))) : null;
}, "DialogOverlay"));
var DialogInner = /* @__PURE__ */ forwardRef(/* @__PURE__ */ __name(function DialogInner2(_ref2, forwardedRef) {
  var allowPinchZoom = _ref2.allowPinchZoom, _ref2$as = _ref2.as, Comp = _ref2$as === void 0 ? "div" : _ref2$as, _ref2$dangerouslyBypa = _ref2.dangerouslyBypassFocusLock, dangerouslyBypassFocusLock = _ref2$dangerouslyBypa === void 0 ? false : _ref2$dangerouslyBypa, _ref2$dangerouslyBypa2 = _ref2.dangerouslyBypassScrollLock, dangerouslyBypassScrollLock = _ref2$dangerouslyBypa2 === void 0 ? false : _ref2$dangerouslyBypa2, initialFocusRef2 = _ref2.initialFocusRef, onClick = _ref2.onClick, _ref2$onDismiss = _ref2.onDismiss, onDismiss = _ref2$onDismiss === void 0 ? noop : _ref2$onDismiss, onKeyDown = _ref2.onKeyDown, onMouseDown = _ref2.onMouseDown, unstable_lockFocusAcrossFrames = _ref2.unstable_lockFocusAcrossFrames, props2 = _objectWithoutPropertiesLoose$9(_ref2, _excluded2$5);
  var mouseDownTarget = useRef(null);
  var overlayNode = useRef(null);
  var ref = useComposedRefs(overlayNode, forwardedRef);
  var activateFocusLock = useCallback(function() {
    if (initialFocusRef2 && initialFocusRef2.current) {
      initialFocusRef2.current.focus();
    }
  }, [initialFocusRef2]);
  function handleClick(event) {
    if (mouseDownTarget.current === event.target) {
      event.stopPropagation();
      onDismiss(event);
    }
  }
  __name(handleClick, "handleClick");
  function handleKeyDown(event) {
    if (event.key === "Escape") {
      event.stopPropagation();
      onDismiss(event);
    }
  }
  __name(handleKeyDown, "handleKeyDown");
  function handleMouseDown(event) {
    mouseDownTarget.current = event.target;
  }
  __name(handleMouseDown, "handleMouseDown");
  useEffect(function() {
    return overlayNode.current ? createAriaHider(overlayNode.current) : void 0;
  }, []);
  return /* @__PURE__ */ createElement(FocusLock, {
    autoFocus: true,
    returnFocus: true,
    onActivation: activateFocusLock,
    disabled: dangerouslyBypassFocusLock,
    crossFrame: unstable_lockFocusAcrossFrames != null ? unstable_lockFocusAcrossFrames : true
  }, /* @__PURE__ */ createElement(RemoveScroll, {
    allowPinchZoom,
    enabled: !dangerouslyBypassScrollLock
  }, /* @__PURE__ */ createElement(Comp, _extends$9({}, props2, {
    ref,
    "data-reach-dialog-overlay": "",
    onClick: composeEventHandlers(onClick, handleClick),
    onKeyDown: composeEventHandlers(onKeyDown, handleKeyDown),
    onMouseDown: composeEventHandlers(onMouseDown, handleMouseDown)
  }))));
}, "DialogInner"));
var DialogContent = /* @__PURE__ */ forwardRef(/* @__PURE__ */ __name(function DialogContent2(_ref3, forwardedRef) {
  var _ref3$as = _ref3.as, Comp = _ref3$as === void 0 ? "div" : _ref3$as, onClick = _ref3.onClick;
  _ref3.onKeyDown;
  var props2 = _objectWithoutPropertiesLoose$9(_ref3, _excluded3$5);
  return /* @__PURE__ */ createElement(Comp, _extends$9({
    "aria-modal": "true",
    role: "dialog",
    tabIndex: -1
  }, props2, {
    ref: forwardedRef,
    "data-reach-dialog-content": "",
    onClick: composeEventHandlers(onClick, function(event) {
      event.stopPropagation();
    })
  }));
}, "DialogContent"));
var Dialog$1 = /* @__PURE__ */ forwardRef(/* @__PURE__ */ __name(function Dialog(_ref4, forwardedRef) {
  var _ref4$allowPinchZoom = _ref4.allowPinchZoom, allowPinchZoom = _ref4$allowPinchZoom === void 0 ? false : _ref4$allowPinchZoom, initialFocusRef2 = _ref4.initialFocusRef, isOpen = _ref4.isOpen, _ref4$onDismiss = _ref4.onDismiss, onDismiss = _ref4$onDismiss === void 0 ? noop : _ref4$onDismiss, props2 = _objectWithoutPropertiesLoose$9(_ref4, _excluded4$4);
  return /* @__PURE__ */ createElement(DialogOverlay, {
    allowPinchZoom,
    initialFocusRef: initialFocusRef2,
    isOpen,
    onDismiss
  }, /* @__PURE__ */ createElement(DialogContent, _extends$9({
    ref: forwardedRef
  }, props2)));
}, "Dialog"));
function createAriaHider(dialogNode) {
  var originalValues = [];
  var rootNodes = [];
  var ownerDocument = getOwnerDocument(dialogNode);
  if (!dialogNode) {
    return noop;
  }
  Array.prototype.forEach.call(ownerDocument.querySelectorAll("body > *"), function(node) {
    var _dialogNode$parentNod, _dialogNode$parentNod2;
    var portalNode = (_dialogNode$parentNod = dialogNode.parentNode) == null ? void 0 : (_dialogNode$parentNod2 = _dialogNode$parentNod.parentNode) == null ? void 0 : _dialogNode$parentNod2.parentNode;
    if (node === portalNode) {
      return;
    }
    var attr = node.getAttribute("aria-hidden");
    var alreadyHidden = attr !== null && attr !== "false";
    if (alreadyHidden) {
      return;
    }
    originalValues.push(attr);
    rootNodes.push(node);
    node.setAttribute("aria-hidden", "true");
  });
  return function() {
    rootNodes.forEach(function(node, index) {
      var originalValue = originalValues[index];
      if (originalValue === null) {
        node.removeAttribute("aria-hidden");
      } else {
        node.setAttribute("aria-hidden", originalValue);
      }
    });
  };
}
__name(createAriaHider, "createAriaHider");
function _extends$8() {
  _extends$8 = Object.assign || function(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends$8.apply(this, arguments);
}
__name(_extends$8, "_extends$8");
function _objectWithoutPropertiesLoose$8(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
__name(_objectWithoutPropertiesLoose$8, "_objectWithoutPropertiesLoose$8");
var _excluded$8 = ["as", "style"];
var VisuallyHidden = /* @__PURE__ */ forwardRef(/* @__PURE__ */ __name(function VisuallyHidden2(_ref2, ref) {
  var _ref$as = _ref2.as, Comp = _ref$as === void 0 ? "span" : _ref$as, _ref$style = _ref2.style, style2 = _ref$style === void 0 ? {} : _ref$style, props2 = _objectWithoutPropertiesLoose$8(_ref2, _excluded$8);
  return /* @__PURE__ */ createElement(Comp, _extends$8({
    ref,
    style: _extends$8({
      border: 0,
      clip: "rect(0 0 0 0)",
      height: "1px",
      margin: "-1px",
      overflow: "hidden",
      padding: 0,
      position: "absolute",
      width: "1px",
      whiteSpace: "nowrap",
      wordWrap: "normal"
    }, style2)
  }, props2));
}, "VisuallyHidden"));
var __defProp$D = Object.defineProperty;
var __name$D = /* @__PURE__ */ __name((target2, value3) => __defProp$D(target2, "name", { value: value3, configurable: true }), "__name$D");
const createComponentGroup = /* @__PURE__ */ __name$D((root2, children) => Object.entries(children).reduce((r2, [key, value3]) => {
  r2[key] = value3;
  return r2;
}, root2), "createComponentGroup");
var dialog = /* @__PURE__ */ (() => ":root{--reach-dialog: 1}[data-reach-dialog-overlay]{background:hsla(0,0%,0%,.33);position:fixed;top:0;right:0;bottom:0;left:0;overflow:auto}[data-reach-dialog-content]{width:50vw;margin:10vh auto;background:white;padding:2rem;outline:none}[data-reach-dialog-overlay]{align-items:center;background-color:hsla(var(--color-neutral),var(--alpha-background-heavy));display:flex;justify-content:center;z-index:10}[data-reach-dialog-content]{background-color:hsl(var(--color-base));border:var(--popover-border);border-radius:var(--border-radius-12);box-shadow:var(--popover-box-shadow);margin:0;max-height:80vh;max-width:80vw;overflow:auto;padding:0;width:unset}.graphiql-dialog-close>svg{color:hsla(var(--color-neutral),var(--alpha-secondary));display:block;height:var(--px-12);padding:var(--px-12);width:var(--px-12)}\n")();
const DialogRoot = forwardRef((props2, ref) => /* @__PURE__ */ jsx(Dialog$1, __spreadProps(__spreadValues({}, props2), {
  ref
})));
DialogRoot.displayName = "Dialog";
const DialogClose = forwardRef((props2, ref) => /* @__PURE__ */ jsxs(UnStyledButton, __spreadProps(__spreadValues({}, props2), {
  ref,
  type: "button",
  className: clsx("graphiql-dialog-close", props2.className),
  children: [/* @__PURE__ */ jsx(VisuallyHidden, {
    children: "Close dialog"
  }), /* @__PURE__ */ jsx(CloseIcon, {})]
})));
DialogClose.displayName = "Dialog.Close";
const Dialog2 = createComponentGroup(DialogRoot, {
  Close: DialogClose
});
var serverHandoffComplete = false;
var id = 0;
function genId() {
  return ++id;
}
__name(genId, "genId");
function useId(providedId) {
  var _ref2;
  if (typeof useId$1 === "function") {
    var _id = useId$1(providedId);
    return providedId != null ? providedId : _id;
  }
  var initialId = providedId != null ? providedId : serverHandoffComplete ? genId() : null;
  var _React$useState = useState(initialId), id2 = _React$useState[0], setId = _React$useState[1];
  useIsomorphicLayoutEffect(function() {
    if (id2 === null) {
      setId(genId());
    }
  }, []);
  useEffect(function() {
    if (serverHandoffComplete === false) {
      serverHandoffComplete = true;
    }
  }, []);
  return (_ref2 = providedId != null ? providedId : id2) != null ? _ref2 : void 0;
}
__name(useId, "useId");
var props = ["bottom", "height", "left", "right", "top", "width"];
var rectChanged = /* @__PURE__ */ __name(function rectChanged2(a2, b2) {
  if (a2 === void 0) {
    a2 = {};
  }
  if (b2 === void 0) {
    b2 = {};
  }
  return props.some(function(prop2) {
    return a2[prop2] !== b2[prop2];
  });
}, "rectChanged");
var observedNodes = /* @__PURE__ */ new Map();
var rafId;
var run = /* @__PURE__ */ __name(function run2() {
  var changedStates = [];
  observedNodes.forEach(function(state2, node) {
    var newRect = node.getBoundingClientRect();
    if (rectChanged(newRect, state2.rect)) {
      state2.rect = newRect;
      changedStates.push(state2);
    }
  });
  changedStates.forEach(function(state2) {
    state2.callbacks.forEach(function(cb) {
      return cb(state2.rect);
    });
  });
  rafId = window.requestAnimationFrame(run2);
}, "run");
function observeRect(node, cb) {
  return {
    observe: /* @__PURE__ */ __name(function observe() {
      var wasEmpty = observedNodes.size === 0;
      if (observedNodes.has(node)) {
        observedNodes.get(node).callbacks.push(cb);
      } else {
        observedNodes.set(node, {
          rect: void 0,
          hasRectChanged: false,
          callbacks: [cb]
        });
      }
      if (wasEmpty)
        run();
    }, "observe"),
    unobserve: /* @__PURE__ */ __name(function unobserve() {
      var state2 = observedNodes.get(node);
      if (state2) {
        var index = state2.callbacks.indexOf(cb);
        if (index >= 0)
          state2.callbacks.splice(index, 1);
        if (!state2.callbacks.length)
          observedNodes["delete"](node);
        if (!observedNodes.size)
          cancelAnimationFrame(rafId);
      }
    }, "unobserve")
  };
}
__name(observeRect, "observeRect");
function useRect(nodeRef, observeOrOptions, deprecated_onChange) {
  var observe;
  var onChange;
  if (isBoolean(observeOrOptions)) {
    observe = observeOrOptions;
  } else {
    var _observeOrOptions$obs;
    observe = (_observeOrOptions$obs = observeOrOptions == null ? void 0 : observeOrOptions.observe) != null ? _observeOrOptions$obs : true;
    onChange = observeOrOptions == null ? void 0 : observeOrOptions.onChange;
  }
  if (isFunction$1(deprecated_onChange)) {
    onChange = deprecated_onChange;
  }
  var _React$useState = useState(nodeRef.current), element = _React$useState[0], setElement = _React$useState[1];
  var initialRectIsSet = useRef(false);
  var initialRefIsSet = useRef(false);
  var _React$useState2 = useState(null), rect2 = _React$useState2[0], setRect = _React$useState2[1];
  var onChangeRef = useRef(onChange);
  useIsomorphicLayoutEffect(function() {
    onChangeRef.current = onChange;
    if (nodeRef.current !== element) {
      setElement(nodeRef.current);
    }
  });
  useIsomorphicLayoutEffect(function() {
    if (element && !initialRectIsSet.current) {
      initialRectIsSet.current = true;
      setRect(element.getBoundingClientRect());
    }
  }, [element]);
  useIsomorphicLayoutEffect(function() {
    if (!observe) {
      return;
    }
    var elem = element;
    if (!initialRefIsSet.current) {
      initialRefIsSet.current = true;
      elem = nodeRef.current;
    }
    if (!elem) {
      return;
    }
    var observer = observeRect(elem, function(rect3) {
      onChangeRef.current == null ? void 0 : onChangeRef.current(rect3);
      setRect(rect3);
    });
    observer.observe();
    return function() {
      observer.unobserve();
    };
  }, [observe, element, nodeRef]);
  return rect2;
}
__name(useRect, "useRect");
var candidateSelectors = [
  "input",
  "select",
  "textarea",
  "a[href]",
  "button",
  "[tabindex]",
  "audio[controls]",
  "video[controls]",
  '[contenteditable]:not([contenteditable="false"])'
];
var candidateSelector = candidateSelectors.join(",");
var matches = typeof Element === "undefined" ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
function tabbable(el2, options) {
  options = options || {};
  var regularTabbables = [];
  var orderedTabbables = [];
  var candidates = el2.querySelectorAll(candidateSelector);
  if (options.includeContainer) {
    if (matches.call(el2, candidateSelector)) {
      candidates = Array.prototype.slice.apply(candidates);
      candidates.unshift(el2);
    }
  }
  var i, candidate, candidateTabindex;
  for (i = 0; i < candidates.length; i++) {
    candidate = candidates[i];
    if (!isNodeMatchingSelectorTabbable(candidate))
      continue;
    candidateTabindex = getTabindex(candidate);
    if (candidateTabindex === 0) {
      regularTabbables.push(candidate);
    } else {
      orderedTabbables.push({
        documentOrder: i,
        tabIndex: candidateTabindex,
        node: candidate
      });
    }
  }
  var tabbableNodes = orderedTabbables.sort(sortOrderedTabbables).map(function(a2) {
    return a2.node;
  }).concat(regularTabbables);
  return tabbableNodes;
}
__name(tabbable, "tabbable");
tabbable.isTabbable = isTabbable;
tabbable.isFocusable = isFocusable;
function isNodeMatchingSelectorTabbable(node) {
  if (!isNodeMatchingSelectorFocusable(node) || isNonTabbableRadio(node) || getTabindex(node) < 0) {
    return false;
  }
  return true;
}
__name(isNodeMatchingSelectorTabbable, "isNodeMatchingSelectorTabbable");
function isTabbable(node) {
  if (!node)
    throw new Error("No node provided");
  if (matches.call(node, candidateSelector) === false)
    return false;
  return isNodeMatchingSelectorTabbable(node);
}
__name(isTabbable, "isTabbable");
function isNodeMatchingSelectorFocusable(node) {
  if (node.disabled || isHiddenInput(node) || isHidden(node)) {
    return false;
  }
  return true;
}
__name(isNodeMatchingSelectorFocusable, "isNodeMatchingSelectorFocusable");
var focusableCandidateSelector = candidateSelectors.concat("iframe").join(",");
function isFocusable(node) {
  if (!node)
    throw new Error("No node provided");
  if (matches.call(node, focusableCandidateSelector) === false)
    return false;
  return isNodeMatchingSelectorFocusable(node);
}
__name(isFocusable, "isFocusable");
function getTabindex(node) {
  var tabindexAttr = parseInt(node.getAttribute("tabindex"), 10);
  if (!isNaN(tabindexAttr))
    return tabindexAttr;
  if (isContentEditable(node))
    return 0;
  return node.tabIndex;
}
__name(getTabindex, "getTabindex");
function sortOrderedTabbables(a2, b2) {
  return a2.tabIndex === b2.tabIndex ? a2.documentOrder - b2.documentOrder : a2.tabIndex - b2.tabIndex;
}
__name(sortOrderedTabbables, "sortOrderedTabbables");
function isContentEditable(node) {
  return node.contentEditable === "true";
}
__name(isContentEditable, "isContentEditable");
function isInput(node) {
  return node.tagName === "INPUT";
}
__name(isInput, "isInput");
function isHiddenInput(node) {
  return isInput(node) && node.type === "hidden";
}
__name(isHiddenInput, "isHiddenInput");
function isRadio(node) {
  return isInput(node) && node.type === "radio";
}
__name(isRadio, "isRadio");
function isNonTabbableRadio(node) {
  return isRadio(node) && !isTabbableRadio(node);
}
__name(isNonTabbableRadio, "isNonTabbableRadio");
function getCheckedRadio(nodes) {
  for (var i = 0; i < nodes.length; i++) {
    if (nodes[i].checked) {
      return nodes[i];
    }
  }
}
__name(getCheckedRadio, "getCheckedRadio");
function isTabbableRadio(node) {
  if (!node.name)
    return true;
  var radioSet = node.ownerDocument.querySelectorAll('input[type="radio"][name="' + node.name + '"]');
  var checked = getCheckedRadio(radioSet);
  return !checked || checked === node;
}
__name(isTabbableRadio, "isTabbableRadio");
function isHidden(node) {
  return node.offsetParent === null || getComputedStyle(node).visibility === "hidden";
}
__name(isHidden, "isHidden");
var tabbable_1 = tabbable;
function _extends$7() {
  _extends$7 = Object.assign || function(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends$7.apply(this, arguments);
}
__name(_extends$7, "_extends$7");
function _objectWithoutPropertiesLoose$7(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
__name(_objectWithoutPropertiesLoose$7, "_objectWithoutPropertiesLoose$7");
var _excluded$7 = ["unstable_skipInitialPortalRender"], _excluded2$4 = ["as", "targetRef", "position", "unstable_observableRefs"];
var Popover = /* @__PURE__ */ forwardRef(/* @__PURE__ */ __name(function Popover2(_ref2, ref) {
  var unstable_skipInitialPortalRender = _ref2.unstable_skipInitialPortalRender, props2 = _objectWithoutPropertiesLoose$7(_ref2, _excluded$7);
  return /* @__PURE__ */ createElement(Portal, {
    unstable_skipInitialRender: unstable_skipInitialPortalRender
  }, /* @__PURE__ */ createElement(PopoverImpl, _extends$7({
    ref
  }, props2)));
}, "Popover"));
var PopoverImpl = /* @__PURE__ */ forwardRef(/* @__PURE__ */ __name(function PopoverImpl2(_ref2, forwardedRef) {
  var _ref2$as = _ref2.as, Comp = _ref2$as === void 0 ? "div" : _ref2$as, targetRef = _ref2.targetRef, _ref2$position = _ref2.position, position = _ref2$position === void 0 ? positionDefault : _ref2$position, _ref2$unstable_observ = _ref2.unstable_observableRefs, unstable_observableRefs = _ref2$unstable_observ === void 0 ? [] : _ref2$unstable_observ, props2 = _objectWithoutPropertiesLoose$7(_ref2, _excluded2$4);
  var popoverRef = useRef(null);
  var popoverRect = useRect(popoverRef, {
    observe: !props2.hidden
  });
  var targetRect = useRect(targetRef, {
    observe: !props2.hidden
  });
  var ref = useComposedRefs(popoverRef, forwardedRef);
  useSimulateTabNavigationForReactTree(targetRef, popoverRef);
  return /* @__PURE__ */ createElement(Comp, _extends$7({
    "data-reach-popover": "",
    ref
  }, props2, {
    style: _extends$7({
      position: "absolute"
    }, getStyles$1.apply(void 0, [position, targetRect, popoverRect].concat(unstable_observableRefs)), props2.style)
  }));
}, "PopoverImpl"));
function getStyles$1(position, targetRect, popoverRect) {
  for (var _len = arguments.length, unstable_observableRefs = new Array(_len > 3 ? _len - 3 : 0), _key = 3; _key < _len; _key++) {
    unstable_observableRefs[_key - 3] = arguments[_key];
  }
  return popoverRect ? position.apply(void 0, [targetRect, popoverRect].concat(unstable_observableRefs.map(function(ref) {
    return ref.current;
  }))) : {
    visibility: "hidden"
  };
}
__name(getStyles$1, "getStyles$1");
function getTopPosition(targetRect, popoverRect, isDirectionUp) {
  return {
    top: isDirectionUp ? targetRect.top - popoverRect.height + window.pageYOffset + "px" : targetRect.top + targetRect.height + window.pageYOffset + "px"
  };
}
__name(getTopPosition, "getTopPosition");
var positionDefault = /* @__PURE__ */ __name(function positionDefault2(targetRect, popoverRect) {
  if (!targetRect || !popoverRect) {
    return {};
  }
  var _getCollisions = getCollisions(targetRect, popoverRect), directionRight = _getCollisions.directionRight, directionUp = _getCollisions.directionUp;
  return _extends$7({
    left: directionRight ? targetRect.right - popoverRect.width + window.pageXOffset + "px" : targetRect.left + window.pageXOffset + "px"
  }, getTopPosition(targetRect, popoverRect, directionUp));
}, "positionDefault");
var positionMatchWidth = /* @__PURE__ */ __name(function positionMatchWidth2(targetRect, popoverRect) {
  if (!targetRect || !popoverRect) {
    return {};
  }
  var _getCollisions3 = getCollisions(targetRect, popoverRect), directionUp = _getCollisions3.directionUp;
  return _extends$7({
    width: targetRect.width,
    left: targetRect.left
  }, getTopPosition(targetRect, popoverRect, directionUp));
}, "positionMatchWidth");
function getCollisions(targetRect, popoverRect, offsetLeft, offsetBottom) {
  if (offsetLeft === void 0) {
    offsetLeft = 0;
  }
  if (offsetBottom === void 0) {
    offsetBottom = 0;
  }
  var collisions = {
    top: targetRect.top - popoverRect.height < 0,
    right: window.innerWidth < targetRect.left + popoverRect.width - offsetLeft,
    bottom: window.innerHeight < targetRect.bottom + popoverRect.height - offsetBottom,
    left: targetRect.left + targetRect.width - popoverRect.width < 0
  };
  var directionRight = collisions.right && !collisions.left;
  var directionLeft = collisions.left && !collisions.right;
  var directionUp = collisions.bottom && !collisions.top;
  var directionDown = collisions.top && !collisions.bottom;
  return {
    directionRight,
    directionLeft,
    directionUp,
    directionDown
  };
}
__name(getCollisions, "getCollisions");
function useSimulateTabNavigationForReactTree(triggerRef, popoverRef) {
  var ownerDocument = getOwnerDocument(triggerRef.current);
  function handleKeyDown(event) {
    if (event.key === "Tab" && popoverRef.current && tabbable_1(popoverRef.current).length === 0) {
      return;
    }
    if (event.key === "Tab" && event.shiftKey) {
      if (shiftTabbedFromElementAfterTrigger(event)) {
        focusLastTabbableInPopover(event);
      } else if (shiftTabbedOutOfPopover(event)) {
        focusTriggerRef(event);
      } else if (shiftTabbedToBrowserChrome(event)) {
        disableTabbablesInPopover();
      }
    } else if (event.key === "Tab") {
      if (tabbedFromTriggerToPopover()) {
        focusFirstPopoverTabbable(event);
      } else if (tabbedOutOfPopover()) {
        focusTabbableAfterTrigger(event);
      } else if (tabbedToBrowserChrome(event)) {
        disableTabbablesInPopover();
      }
    }
  }
  __name(handleKeyDown, "handleKeyDown");
  useEffect(function() {
    ownerDocument.addEventListener("keydown", handleKeyDown);
    return function() {
      ownerDocument.removeEventListener("keydown", handleKeyDown);
    };
  }, []);
  function getElementAfterTrigger() {
    var elements = tabbable_1(ownerDocument);
    var targetIndex = elements && triggerRef.current ? elements.indexOf(triggerRef.current) : -1;
    var elementAfterTrigger = elements && elements[targetIndex + 1];
    return popoverRef.current && popoverRef.current.contains(elementAfterTrigger || null) ? false : elementAfterTrigger;
  }
  __name(getElementAfterTrigger, "getElementAfterTrigger");
  function tabbedFromTriggerToPopover() {
    return triggerRef.current ? triggerRef.current === ownerDocument.activeElement : false;
  }
  __name(tabbedFromTriggerToPopover, "tabbedFromTriggerToPopover");
  function focusFirstPopoverTabbable(event) {
    var elements = popoverRef.current && tabbable_1(popoverRef.current);
    if (elements && elements[0]) {
      event.preventDefault();
      elements[0].focus();
    }
  }
  __name(focusFirstPopoverTabbable, "focusFirstPopoverTabbable");
  function tabbedOutOfPopover() {
    var inPopover = popoverRef.current ? popoverRef.current.contains(ownerDocument.activeElement || null) : false;
    if (inPopover) {
      var elements = popoverRef.current && tabbable_1(popoverRef.current);
      return Boolean(elements && elements[elements.length - 1] === ownerDocument.activeElement);
    }
    return false;
  }
  __name(tabbedOutOfPopover, "tabbedOutOfPopover");
  function focusTabbableAfterTrigger(event) {
    var elementAfterTrigger = getElementAfterTrigger();
    if (elementAfterTrigger) {
      event.preventDefault();
      elementAfterTrigger.focus();
    }
  }
  __name(focusTabbableAfterTrigger, "focusTabbableAfterTrigger");
  function shiftTabbedFromElementAfterTrigger(event) {
    if (!event.shiftKey)
      return;
    var elementAfterTrigger = getElementAfterTrigger();
    return event.target === elementAfterTrigger;
  }
  __name(shiftTabbedFromElementAfterTrigger, "shiftTabbedFromElementAfterTrigger");
  function focusLastTabbableInPopover(event) {
    var elements = popoverRef.current && tabbable_1(popoverRef.current);
    var last = elements && elements[elements.length - 1];
    if (last) {
      event.preventDefault();
      last.focus();
    }
  }
  __name(focusLastTabbableInPopover, "focusLastTabbableInPopover");
  function shiftTabbedOutOfPopover(event) {
    var elements = popoverRef.current && tabbable_1(popoverRef.current);
    if (elements) {
      return elements.length === 0 ? false : event.target === elements[0];
    }
    return false;
  }
  __name(shiftTabbedOutOfPopover, "shiftTabbedOutOfPopover");
  function focusTriggerRef(event) {
    var _triggerRef$current;
    event.preventDefault();
    (_triggerRef$current = triggerRef.current) == null ? void 0 : _triggerRef$current.focus();
  }
  __name(focusTriggerRef, "focusTriggerRef");
  function tabbedToBrowserChrome(event) {
    var elements = popoverRef.current ? tabbable_1(ownerDocument).filter(function(element) {
      return !popoverRef.current.contains(element);
    }) : null;
    return elements ? event.target === elements[elements.length - 1] : false;
  }
  __name(tabbedToBrowserChrome, "tabbedToBrowserChrome");
  function shiftTabbedToBrowserChrome(event) {
    return event.target === tabbable_1(ownerDocument)[0];
  }
  __name(shiftTabbedToBrowserChrome, "shiftTabbedToBrowserChrome");
  var restoreTabIndexTupl\u00E9s = [];
  function disableTabbablesInPopover() {
    var elements = popoverRef.current && tabbable_1(popoverRef.current);
    if (elements) {
      elements.forEach(function(element) {
        restoreTabIndexTupl\u00E9s.push([element, element.tabIndex]);
        element.tabIndex = -1;
      });
      ownerDocument.addEventListener("focusin", enableTabbablesInPopover);
    }
  }
  __name(disableTabbablesInPopover, "disableTabbablesInPopover");
  function enableTabbablesInPopover() {
    ownerDocument.removeEventListener("focusin", enableTabbablesInPopover);
    restoreTabIndexTupl\u00E9s.forEach(function(_ref3) {
      var element = _ref3[0], tabIndex = _ref3[1];
      element.tabIndex = tabIndex;
    });
  }
  __name(enableTabbablesInPopover, "enableTabbablesInPopover");
}
__name(useSimulateTabNavigationForReactTree, "useSimulateTabNavigationForReactTree");
function _objectWithoutPropertiesLoose$6(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
__name(_objectWithoutPropertiesLoose$6, "_objectWithoutPropertiesLoose$6");
function _extends$6() {
  _extends$6 = Object.assign || function(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends$6.apply(this, arguments);
}
__name(_extends$6, "_extends$6");
var _excluded$6 = ["element", "index"];
function createDescendantContext(name2, initialValue) {
  if (initialValue === void 0) {
    initialValue = {};
  }
  var descendants = [];
  var ctx = /* @__PURE__ */ createContext$1(_extends$6({
    descendants,
    registerDescendant: noop,
    unregisterDescendant: noop
  }, initialValue));
  return ctx;
}
__name(createDescendantContext, "createDescendantContext");
function useDescendant(descendant, context, indexProp) {
  var forceUpdate = useForceUpdate();
  var _React$useContext = useContext(context), registerDescendant = _React$useContext.registerDescendant, unregisterDescendant = _React$useContext.unregisterDescendant, descendants = _React$useContext.descendants;
  var index = indexProp != null ? indexProp : descendants.findIndex(function(item) {
    return item.element === descendant.element;
  });
  useIsomorphicLayoutEffect(function() {
    if (!descendant.element)
      forceUpdate();
    registerDescendant(_extends$6({}, descendant, {
      index
    }));
    return function() {
      unregisterDescendant(descendant.element);
    };
  }, [descendant, forceUpdate, index, registerDescendant, unregisterDescendant].concat(Object.values(descendant)));
  return index;
}
__name(useDescendant, "useDescendant");
function useDescendantsInit() {
  return useState([]);
}
__name(useDescendantsInit, "useDescendantsInit");
function useDescendants(ctx) {
  return useContext(ctx).descendants;
}
__name(useDescendants, "useDescendants");
function DescendantProvider(_ref2) {
  var Ctx = _ref2.context, children = _ref2.children, items = _ref2.items, set2 = _ref2.set;
  var registerDescendant = useCallback(function(_ref22) {
    var element = _ref22.element, explicitIndex = _ref22.index, rest = _objectWithoutPropertiesLoose$6(_ref22, _excluded$6);
    if (!element) {
      return;
    }
    set2(function(items2) {
      var newItems;
      if (explicitIndex != null) {
        return [].concat(items2, [_extends$6({}, rest, {
          element,
          index: explicitIndex
        })]).sort(function(a2, b2) {
          return a2.index - b2.index;
        });
      } else if (items2.length === 0) {
        newItems = [_extends$6({}, rest, {
          element,
          index: 0
        })];
      } else if (items2.find(function(item) {
        return item.element === element;
      })) {
        newItems = items2;
      } else {
        var index = items2.findIndex(function(item) {
          if (!item.element || !element) {
            return false;
          }
          return Boolean(item.element.compareDocumentPosition(element) & Node.DOCUMENT_POSITION_PRECEDING);
        });
        var newItem = _extends$6({}, rest, {
          element,
          index
        });
        if (index === -1) {
          newItems = [].concat(items2, [newItem]);
        } else {
          newItems = [].concat(items2.slice(0, index), [newItem], items2.slice(index));
        }
      }
      return newItems.map(function(item, index2) {
        return _extends$6({}, item, {
          index: index2
        });
      });
    });
  }, []);
  var unregisterDescendant = useCallback(function(element) {
    if (!element) {
      return;
    }
    set2(function(items2) {
      return items2.filter(function(item) {
        return element !== item.element;
      });
    });
  }, []);
  return /* @__PURE__ */ createElement(Ctx.Provider, {
    value: useMemo(function() {
      return {
        descendants: items,
        registerDescendant,
        unregisterDescendant
      };
    }, [items, registerDescendant, unregisterDescendant])
  }, children);
}
__name(DescendantProvider, "DescendantProvider");
function useDescendantKeyDown(context, options) {
  var _React$useContext2 = useContext(context), descendants = _React$useContext2.descendants;
  var callback = options.callback, currentIndex = options.currentIndex, filter = options.filter, _options$key = options.key, key = _options$key === void 0 ? "index" : _options$key, _options$orientation = options.orientation, orientation = _options$orientation === void 0 ? "vertical" : _options$orientation, _options$rotate = options.rotate, rotate = _options$rotate === void 0 ? true : _options$rotate, _options$rtl = options.rtl, rtl = _options$rtl === void 0 ? false : _options$rtl;
  return /* @__PURE__ */ __name(function handleKeyDown(event) {
    if (!["ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight", "PageUp", "PageDown", "Home", "End"].includes(event.key)) {
      return;
    }
    var index = currentIndex != null ? currentIndex : -1;
    var selectableDescendants = filter ? descendants.filter(filter) : descendants;
    if (!selectableDescendants.length) {
      return;
    }
    var selectableIndex = selectableDescendants.findIndex(function(descendant) {
      return descendant.index === currentIndex;
    });
    function getNextOption() {
      var atBottom = index === getLastOption().index;
      return atBottom ? rotate ? getFirstOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex + 1) % selectableDescendants.length];
    }
    __name(getNextOption, "getNextOption");
    function getPreviousOption() {
      var atTop = index === getFirstOption().index;
      return atTop ? rotate ? getLastOption() : selectableDescendants[selectableIndex] : selectableDescendants[(selectableIndex - 1 + selectableDescendants.length) % selectableDescendants.length];
    }
    __name(getPreviousOption, "getPreviousOption");
    function getFirstOption() {
      return selectableDescendants[0];
    }
    __name(getFirstOption, "getFirstOption");
    function getLastOption() {
      return selectableDescendants[selectableDescendants.length - 1];
    }
    __name(getLastOption, "getLastOption");
    switch (event.key) {
      case "ArrowDown":
        if (orientation === "vertical" || orientation === "both") {
          event.preventDefault();
          var next = getNextOption();
          callback(key === "option" ? next : next[key]);
        }
        break;
      case "ArrowUp":
        if (orientation === "vertical" || orientation === "both") {
          event.preventDefault();
          var prev = getPreviousOption();
          callback(key === "option" ? prev : prev[key]);
        }
        break;
      case "ArrowLeft":
        if (orientation === "horizontal" || orientation === "both") {
          event.preventDefault();
          var nextOrPrev = (rtl ? getNextOption : getPreviousOption)();
          callback(key === "option" ? nextOrPrev : nextOrPrev[key]);
        }
        break;
      case "ArrowRight":
        if (orientation === "horizontal" || orientation === "both") {
          event.preventDefault();
          var prevOrNext = (rtl ? getPreviousOption : getNextOption)();
          callback(key === "option" ? prevOrNext : prevOrNext[key]);
        }
        break;
      case "PageUp":
        event.preventDefault();
        var prevOrFirst = (event.ctrlKey ? getPreviousOption : getFirstOption)();
        callback(key === "option" ? prevOrFirst : prevOrFirst[key]);
        break;
      case "Home":
        event.preventDefault();
        var first = getFirstOption();
        callback(key === "option" ? first : first[key]);
        break;
      case "PageDown":
        event.preventDefault();
        var nextOrLast = (event.ctrlKey ? getNextOption : getLastOption)();
        callback(key === "option" ? nextOrLast : nextOrLast[key]);
        break;
      case "End":
        event.preventDefault();
        var last = getLastOption();
        callback(key === "option" ? last : last[key]);
        break;
    }
  }, "handleKeyDown");
}
__name(useDescendantKeyDown, "useDescendantKeyDown");
function isRightClick(nativeEvent) {
  return "which" in nativeEvent ? nativeEvent.which === 3 : "button" in nativeEvent ? nativeEvent.button === 2 : false;
}
__name(isRightClick, "isRightClick");
function createStableCallbackHook(useEffectHook, callback) {
  var callbackRef = useRef(callback);
  useEffectHook(function() {
    callbackRef.current = callback;
  });
  return useCallback(function() {
    callbackRef.current && callbackRef.current.apply(callbackRef, arguments);
  }, []);
}
__name(createStableCallbackHook, "createStableCallbackHook");
function useStableCallback(callback) {
  return createStableCallbackHook(useEffect, callback);
}
__name(useStableCallback, "useStableCallback");
function _objectWithoutPropertiesLoose$5(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
__name(_objectWithoutPropertiesLoose$5, "_objectWithoutPropertiesLoose$5");
var _excluded$5 = ["children"];
function createNamedContext(name2, defaultValue2) {
  var Ctx = /* @__PURE__ */ createContext$1(defaultValue2);
  return Ctx;
}
__name(createNamedContext, "createNamedContext");
function createContext(rootName, defaultContext) {
  var Ctx = /* @__PURE__ */ createContext$1(defaultContext);
  function Provider(props2) {
    var children = props2.children, context = _objectWithoutPropertiesLoose$5(props2, _excluded$5);
    var value3 = useMemo(function() {
      return context;
    }, Object.values(context));
    return /* @__PURE__ */ createElement(Ctx.Provider, {
      value: value3
    }, children);
  }
  __name(Provider, "Provider");
  function useContext$1(childName) {
    var context = useContext(Ctx);
    if (context) {
      return context;
    }
    if (defaultContext) {
      return defaultContext;
    }
    throw Error(childName + " must be rendered inside of a " + rootName + " component.");
  }
  __name(useContext$1, "useContext$1");
  return [Provider, useContext$1];
}
__name(createContext, "createContext");
function makeId() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  return args.filter(function(val) {
    return val != null;
  }).join("--");
}
__name(makeId, "makeId");
function useStatefulRefValue(ref, initialState2) {
  var _useState = useState(initialState2), state2 = _useState[0], setState = _useState[1];
  var callbackRef = useCallback(function(refValue) {
    ref.current = refValue;
    setState(refValue);
  }, []);
  return [state2, callbackRef];
}
__name(useStatefulRefValue, "useStatefulRefValue");
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var t$1;
!function(t2) {
  t2[t2.NotStarted = 0] = "NotStarted", t2[t2.Running = 1] = "Running", t2[t2.Stopped = 2] = "Stopped";
}(t$1 || (t$1 = {}));
var n$1 = { type: "xstate.init" };
function e$1(t2) {
  return t2 === void 0 ? [] : [].concat(t2);
}
__name(e$1, "e$1");
function r$1(t2) {
  return { type: "xstate.assign", assignment: t2 };
}
__name(r$1, "r$1");
function i$1(t2, n2) {
  return typeof (t2 = typeof t2 == "string" && n2 && n2[t2] ? n2[t2] : t2) == "string" ? { type: t2 } : typeof t2 == "function" ? { type: t2.name, exec: t2 } : t2;
}
__name(i$1, "i$1");
function o(t2) {
  return function(n2) {
    return t2 === n2;
  };
}
__name(o, "o");
function a(t2) {
  return typeof t2 == "string" ? { type: t2 } : t2;
}
__name(a, "a");
function u(t2, n2) {
  return { value: t2, context: n2, actions: [], changed: false, matches: o(t2) };
}
__name(u, "u");
function c$1(t2, n2) {
  n2 === void 0 && (n2 = {});
  var r2 = { config: t2, _options: n2, initialState: { value: t2.initial, actions: e$1(t2.states[t2.initial].entry).map(function(t3) {
    return i$1(t3, n2.actions);
  }), context: t2.context, matches: o(t2.initial) }, transition: function(n3, c2) {
    var s2, f2, l2 = typeof n3 == "string" ? { value: n3, context: t2.context } : n3, v2 = l2.value, p2 = l2.context, g2 = a(c2), y2 = t2.states[v2];
    if (y2.on) {
      var d2 = e$1(y2.on[g2.type]), x2 = /* @__PURE__ */ __name(function(n4) {
        if (n4 === void 0)
          return { value: u(v2, p2) };
        var e2 = typeof n4 == "string" ? { target: n4 } : n4, a2 = e2.target, c3 = a2 === void 0 ? v2 : a2, s3 = e2.actions, f3 = s3 === void 0 ? [] : s3, l3 = e2.cond, d3 = p2;
        if ((l3 === void 0 ? function() {
          return true;
        } : l3)(p2, g2)) {
          var x3 = t2.states[c3], m3 = false, h3 = [].concat(y2.exit, f3, x3.entry).filter(function(t3) {
            return t3;
          }).map(function(t3) {
            return i$1(t3, r2._options.actions);
          }).filter(function(t3) {
            if (t3.type === "xstate.assign") {
              m3 = true;
              var n5 = Object.assign({}, d3);
              return typeof t3.assignment == "function" ? n5 = t3.assignment(d3, g2) : Object.keys(t3.assignment).forEach(function(e3) {
                n5[e3] = typeof t3.assignment[e3] == "function" ? t3.assignment[e3](d3, g2) : t3.assignment[e3];
              }), d3 = n5, false;
            }
            return true;
          });
          return { value: { value: c3, context: d3, actions: h3, changed: c3 !== v2 || h3.length > 0 || m3, matches: o(c3) } };
        }
      }, "x");
      try {
        for (var m2 = function(t3) {
          var n4 = typeof Symbol == "function" && t3[Symbol.iterator], e2 = 0;
          return n4 ? n4.call(t3) : { next: function() {
            return t3 && e2 >= t3.length && (t3 = void 0), { value: t3 && t3[e2++], done: !t3 };
          } };
        }(d2), h2 = m2.next(); !h2.done; h2 = m2.next()) {
          var S = x2(h2.value);
          if (typeof S == "object")
            return S.value;
        }
      } catch (t3) {
        s2 = { error: t3 };
      } finally {
        try {
          h2 && !h2.done && (f2 = m2.return) && f2.call(m2);
        } finally {
          if (s2)
            throw s2.error;
        }
      }
    }
    return u(v2, p2);
  } };
  return r2;
}
__name(c$1, "c$1");
var s = /* @__PURE__ */ __name(function(t2, n2) {
  return t2.actions.forEach(function(e2) {
    var r2 = e2.exec;
    return r2 && r2(t2.context, n2);
  });
}, "s");
function f$1(e2) {
  var r2 = e2.initialState, i = t$1.NotStarted, o2 = /* @__PURE__ */ new Set(), u2 = { _machine: e2, send: function(n2) {
    i === t$1.Running && (r2 = e2.transition(r2, n2), s(r2, a(n2)), o2.forEach(function(t2) {
      return t2(r2);
    }));
  }, subscribe: function(t2) {
    return o2.add(t2), t2(r2), { unsubscribe: function() {
      return o2.delete(t2);
    } };
  }, start: function() {
    return i = t$1.Running, s(r2, n$1), u2;
  }, stop: function() {
    return i = t$1.Stopped, o2.clear(), u2;
  }, get state() {
    return r2;
  }, get status() {
    return i;
  } };
  return u2;
}
__name(f$1, "f$1");
function useConstant(fn) {
  var ref = useRef();
  if (!ref.current) {
    ref.current = {
      v: fn()
    };
  }
  return ref.current.v;
}
__name(useConstant, "useConstant");
function _extends$5() {
  _extends$5 = Object.assign || function(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends$5.apply(this, arguments);
}
__name(_extends$5, "_extends$5");
var getServiceState = /* @__PURE__ */ __name(function getServiceState2(service) {
  var currentValue;
  service.subscribe(function(state2) {
    currentValue = state2;
  }).unsubscribe();
  return currentValue;
}, "getServiceState");
function useMachine(initialMachine, refs, DEBUG2) {
  var machineRef = useRef(initialMachine);
  var service = useConstant(function() {
    return f$1(machineRef.current).start();
  });
  var lastEventType = useRef(null);
  var _React$useState = useState(function() {
    return getServiceState(service);
  }), state2 = _React$useState[0], setState = _React$useState[1];
  var send2 = useCallback(function(rawEvent) {
    var event = isString$1(rawEvent) ? {
      type: rawEvent
    } : rawEvent;
    var refValues = unwrapRefs(refs);
    service.send(_extends$5({}, event, {
      lastEventType: lastEventType.current,
      refs: refValues
    }));
    lastEventType.current = event.type;
  }, [DEBUG2]);
  useEffect(function() {
    service.subscribe(/* @__PURE__ */ __name(function setStateIfChanged(newState) {
      if (newState.changed) {
        setState(newState);
      }
    }, "setStateIfChanged"));
    return function() {
      service.stop();
    };
  }, [service]);
  useEffect(function() {
  }, [DEBUG2, state2]);
  var memoizedState = useMemo(function() {
    return _extends$5({}, state2, {
      matches: /* @__PURE__ */ __name(function matches2(value3) {
        return value3 === state2.value;
      }, "matches")
    });
  }, [state2.changed, state2.context, state2.value]);
  return [memoizedState, send2, service];
}
__name(useMachine, "useMachine");
function unwrapRefs(refs) {
  return Object.entries(refs).reduce(function(value3, _ref2) {
    var name2 = _ref2[0], ref = _ref2[1];
    value3[name2] = ref.current;
    return value3;
  }, {});
}
__name(unwrapRefs, "unwrapRefs");
function useCreateMachine(machineDefinition, options) {
  return useConstant(function() {
    return c$1(machineDefinition, options);
  });
}
__name(useCreateMachine, "useCreateMachine");
function _extends$4() {
  _extends$4 = Object.assign || function(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends$4.apply(this, arguments);
}
__name(_extends$4, "_extends$4");
function _objectWithoutPropertiesLoose$4(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
__name(_objectWithoutPropertiesLoose$4, "_objectWithoutPropertiesLoose$4");
var _commonEvents;
var ListboxStates;
(function(ListboxStates2) {
  ListboxStates2["Idle"] = "IDLE";
  ListboxStates2["Open"] = "OPEN";
  ListboxStates2["Navigating"] = "NAVIGATING";
  ListboxStates2["Dragging"] = "DRAGGING";
  ListboxStates2["Interacting"] = "INTERACTING";
})(ListboxStates || (ListboxStates = {}));
var ListboxEvents;
(function(ListboxEvents2) {
  ListboxEvents2["ButtonMouseDown"] = "BUTTON_MOUSE_DOWN";
  ListboxEvents2["ButtonMouseUp"] = "BUTTON_MOUSE_UP";
  ListboxEvents2["Blur"] = "BLUR";
  ListboxEvents2["ClearNavSelection"] = "CLEAR_NAV_SELECTION";
  ListboxEvents2["ClearTypeahead"] = "CLEAR_TYPEAHEAD";
  ListboxEvents2["GetDerivedData"] = "GET_DERIVED_DATA";
  ListboxEvents2["KeyDownEscape"] = "KEY_DOWN_ESCAPE";
  ListboxEvents2["KeyDownEnter"] = "KEY_DOWN_ENTER";
  ListboxEvents2["KeyDownSpace"] = "KEY_DOWN_SPACE";
  ListboxEvents2["KeyDownNavigate"] = "KEY_DOWN_NAVIGATE";
  ListboxEvents2["KeyDownSearch"] = "KEY_DOWN_SEARCH";
  ListboxEvents2["KeyDownTab"] = "KEY_DOWN_TAB";
  ListboxEvents2["KeyDownShiftTab"] = "KEY_DOWN_SHIFT_TAB";
  ListboxEvents2["OptionTouchStart"] = "OPTION_TOUCH_START";
  ListboxEvents2["OptionMouseMove"] = "OPTION_MOUSE_MOVE";
  ListboxEvents2["OptionMouseEnter"] = "OPTION_MOUSE_ENTER";
  ListboxEvents2["OptionMouseDown"] = "OPTION_MOUSE_DOWN";
  ListboxEvents2["OptionMouseUp"] = "OPTION_MOUSE_UP";
  ListboxEvents2["OptionClick"] = "OPTION_CLICK";
  ListboxEvents2["ListMouseUp"] = "LIST_MOUSE_UP";
  ListboxEvents2["OptionPress"] = "OPTION_PRESS";
  ListboxEvents2["OutsideMouseDown"] = "OUTSIDE_MOUSE_DOWN";
  ListboxEvents2["OutsideMouseUp"] = "OUTSIDE_MOUSE_UP";
  ListboxEvents2["ValueChange"] = "VALUE_CHANGE";
  ListboxEvents2["PopoverPointerDown"] = "POPOVER_POINTER_DOWN";
  ListboxEvents2["PopoverPointerUp"] = "POPOVER_POINTER_UP";
  ListboxEvents2["UpdateAfterTypeahead"] = "UPDATE_AFTER_TYPEAHEAD";
})(ListboxEvents || (ListboxEvents = {}));
var clearNavigationValue = /* @__PURE__ */ r$1({
  navigationValue: null
});
var clearTypeahead = /* @__PURE__ */ r$1({
  typeaheadQuery: null
});
var assignValue = /* @__PURE__ */ r$1({
  value: /* @__PURE__ */ __name(function value(_, event) {
    return event.value;
  }, "value")
});
var navigate = /* @__PURE__ */ r$1({
  navigationValue: /* @__PURE__ */ __name(function navigationValue(data, event) {
    return event.value;
  }, "navigationValue")
});
var navigateFromCurrentValue = /* @__PURE__ */ r$1({
  navigationValue: /* @__PURE__ */ __name(function navigationValue2(data) {
    var selected = findOptionFromValue(data.value, data.options);
    if (selected && !selected.disabled) {
      return data.value;
    } else {
      var _data$options$find;
      return ((_data$options$find = data.options.find(function(option) {
        return !option.disabled;
      })) == null ? void 0 : _data$options$find.value) || null;
    }
  }, "navigationValue")
});
function listboxLostFocus(data, event) {
  if (event.type === ListboxEvents.Blur) {
    var _event$refs = event.refs, list3 = _event$refs.list, popover = _event$refs.popover;
    var relatedTarget = event.relatedTarget;
    var ownerDocument = getOwnerDocument(popover);
    return !!((ownerDocument == null ? void 0 : ownerDocument.activeElement) !== list3 && popover && !popover.contains(relatedTarget || (ownerDocument == null ? void 0 : ownerDocument.activeElement)));
  }
  return false;
}
__name(listboxLostFocus, "listboxLostFocus");
function clickedOutsideOfListbox(data, event) {
  if (event.type === ListboxEvents.OutsideMouseDown || event.type === ListboxEvents.OutsideMouseUp) {
    var _event$refs2 = event.refs, button2 = _event$refs2.button, popover = _event$refs2.popover;
    var relatedTarget = event.relatedTarget;
    return !!(relatedTarget !== button2 && button2 && !button2.contains(relatedTarget) && popover && !popover.contains(relatedTarget));
  }
  return false;
}
__name(clickedOutsideOfListbox, "clickedOutsideOfListbox");
function optionIsActive(data, event) {
  return !!data.options.find(function(option) {
    return option.value === data.navigationValue;
  });
}
__name(optionIsActive, "optionIsActive");
function shouldNavigate(data, event) {
  var _event$refs3 = event.refs, popover = _event$refs3.popover, list3 = _event$refs3.list;
  var relatedTarget = event.relatedTarget;
  if (popover && relatedTarget && popover.contains(relatedTarget) && relatedTarget !== list3) {
    return false;
  }
  return optionIsActive(data);
}
__name(shouldNavigate, "shouldNavigate");
function focusList(data, event) {
  requestAnimationFrame(function() {
    event.refs.list && event.refs.list.focus();
  });
}
__name(focusList, "focusList");
function focusButton(data, event) {
  event.refs.button && event.refs.button.focus();
}
__name(focusButton, "focusButton");
function listboxIsNotDisabled(data, event) {
  return !event.disabled;
}
__name(listboxIsNotDisabled, "listboxIsNotDisabled");
function optionIsNavigable(data, event) {
  if (event.type === ListboxEvents.OptionTouchStart) {
    if (event && event.disabled) {
      return false;
    }
  }
  return true;
}
__name(optionIsNavigable, "optionIsNavigable");
function optionIsSelectable(data, event) {
  if ("disabled" in event && event.disabled) {
    return false;
  }
  if ("value" in event) {
    return event.value != null;
  }
  return data.navigationValue != null;
}
__name(optionIsSelectable, "optionIsSelectable");
function selectOption(data, event) {
  event.callback && event.callback(event.value);
}
__name(selectOption, "selectOption");
function submitForm(data, event) {
  if (event.type !== ListboxEvents.KeyDownEnter) {
    return;
  }
  var hiddenInput = event.refs.hiddenInput;
  if (hiddenInput && hiddenInput.form) {
    var submitButton = hiddenInput.form.querySelector("button:not([type]),[type='submit']");
    submitButton && submitButton.click();
  }
}
__name(submitForm, "submitForm");
var setTypeahead = /* @__PURE__ */ r$1({
  typeaheadQuery: /* @__PURE__ */ __name(function typeaheadQuery(data, event) {
    return (data.typeaheadQuery || "") + event.query;
  }, "typeaheadQuery")
});
var setValueFromTypeahead = /* @__PURE__ */ r$1({
  value: /* @__PURE__ */ __name(function value2(data, event) {
    if (event.type === ListboxEvents.UpdateAfterTypeahead && event.query) {
      var match2 = findOptionFromTypeahead(data.options, event.query);
      if (match2 && !match2.disabled) {
        event.callback && event.callback(match2.value);
        return match2.value;
      }
    }
    return data.value;
  }, "value")
});
var setNavSelectionFromTypeahead = /* @__PURE__ */ r$1({
  navigationValue: /* @__PURE__ */ __name(function navigationValue3(data, event) {
    if (event.type === ListboxEvents.UpdateAfterTypeahead && event.query) {
      var match2 = findOptionFromTypeahead(data.options, event.query);
      if (match2 && !match2.disabled) {
        return match2.value;
      }
    }
    return data.navigationValue;
  }, "navigationValue")
});
var commonEvents = (_commonEvents = {}, _commonEvents[ListboxEvents.GetDerivedData] = {
  actions: /* @__PURE__ */ r$1(function(ctx, event) {
    return _extends$4({}, ctx, event.data);
  })
}, _commonEvents[ListboxEvents.ValueChange] = {
  actions: [assignValue, selectOption]
}, _commonEvents);
var createMachineDefinition = /* @__PURE__ */ __name(function createMachineDefinition2(_ref2) {
  var _extends2, _extends3, _extends4, _extends5, _extends6, _states2;
  var value3 = _ref2.value;
  return {
    id: "listbox",
    initial: ListboxStates.Idle,
    context: {
      value: value3,
      options: [],
      navigationValue: null,
      typeaheadQuery: null
    },
    states: (_states2 = {}, _states2[ListboxStates.Idle] = {
      on: _extends$4({}, commonEvents, (_extends2 = {}, _extends2[ListboxEvents.ButtonMouseDown] = {
        target: ListboxStates.Open,
        actions: [navigateFromCurrentValue],
        cond: listboxIsNotDisabled
      }, _extends2[ListboxEvents.KeyDownSpace] = {
        target: ListboxStates.Navigating,
        actions: [navigateFromCurrentValue, focusList],
        cond: listboxIsNotDisabled
      }, _extends2[ListboxEvents.KeyDownSearch] = {
        target: ListboxStates.Idle,
        actions: setTypeahead,
        cond: listboxIsNotDisabled
      }, _extends2[ListboxEvents.UpdateAfterTypeahead] = {
        target: ListboxStates.Idle,
        actions: [setValueFromTypeahead],
        cond: listboxIsNotDisabled
      }, _extends2[ListboxEvents.ClearTypeahead] = {
        target: ListboxStates.Idle,
        actions: clearTypeahead
      }, _extends2[ListboxEvents.KeyDownNavigate] = {
        target: ListboxStates.Navigating,
        actions: [navigateFromCurrentValue, clearTypeahead, focusList],
        cond: listboxIsNotDisabled
      }, _extends2[ListboxEvents.KeyDownEnter] = {
        actions: [submitForm],
        cond: listboxIsNotDisabled
      }, _extends2))
    }, _states2[ListboxStates.Interacting] = {
      entry: [clearNavigationValue],
      on: _extends$4({}, commonEvents, (_extends3 = {}, _extends3[ListboxEvents.ClearNavSelection] = {
        actions: [clearNavigationValue, focusList]
      }, _extends3[ListboxEvents.KeyDownEnter] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends3[ListboxEvents.KeyDownSpace] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends3[ListboxEvents.ButtonMouseDown] = {
        target: ListboxStates.Idle,
        actions: [focusButton]
      }, _extends3[ListboxEvents.KeyDownEscape] = {
        target: ListboxStates.Idle,
        actions: [focusButton]
      }, _extends3[ListboxEvents.OptionMouseDown] = {
        target: ListboxStates.Dragging
      }, _extends3[ListboxEvents.OutsideMouseDown] = [{
        target: ListboxStates.Idle,
        cond: clickedOutsideOfListbox,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Dragging,
        actions: clearTypeahead,
        cond: optionIsActive
      }], _extends3[ListboxEvents.OutsideMouseUp] = [{
        target: ListboxStates.Idle,
        cond: clickedOutsideOfListbox,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: optionIsActive
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends3[ListboxEvents.KeyDownEnter] = ListboxStates.Interacting, _extends3[ListboxEvents.Blur] = [{
        target: ListboxStates.Idle,
        cond: listboxLostFocus,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: shouldNavigate
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends3[ListboxEvents.OptionTouchStart] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead],
        cond: optionIsNavigable
      }, _extends3[ListboxEvents.OptionClick] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends3[ListboxEvents.OptionPress] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends3[ListboxEvents.OptionMouseEnter] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead],
        cond: optionIsNavigable
      }, _extends3[ListboxEvents.KeyDownNavigate] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead, focusList]
      }, _extends3))
    }, _states2[ListboxStates.Open] = {
      on: _extends$4({}, commonEvents, (_extends4 = {}, _extends4[ListboxEvents.ClearNavSelection] = {
        actions: [clearNavigationValue]
      }, _extends4[ListboxEvents.KeyDownEnter] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends4[ListboxEvents.KeyDownSpace] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends4[ListboxEvents.ButtonMouseDown] = {
        target: ListboxStates.Idle,
        actions: [focusButton]
      }, _extends4[ListboxEvents.KeyDownEscape] = {
        target: ListboxStates.Idle,
        actions: [focusButton]
      }, _extends4[ListboxEvents.OptionMouseDown] = {
        target: ListboxStates.Dragging
      }, _extends4[ListboxEvents.OutsideMouseDown] = [{
        target: ListboxStates.Idle,
        cond: clickedOutsideOfListbox,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Dragging,
        cond: optionIsActive
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends4[ListboxEvents.OutsideMouseUp] = [{
        target: ListboxStates.Idle,
        cond: clickedOutsideOfListbox,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: optionIsActive
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends4[ListboxEvents.Blur] = [{
        target: ListboxStates.Idle,
        cond: listboxLostFocus,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: shouldNavigate
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends4[ListboxEvents.ButtonMouseUp] = {
        target: ListboxStates.Navigating,
        actions: [navigateFromCurrentValue, focusList]
      }, _extends4[ListboxEvents.ListMouseUp] = {
        target: ListboxStates.Navigating,
        actions: [navigateFromCurrentValue, focusList]
      }, _extends4[ListboxEvents.OptionTouchStart] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead],
        cond: optionIsNavigable
      }, _extends4[ListboxEvents.OptionClick] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends4[ListboxEvents.OptionPress] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends4[ListboxEvents.KeyDownNavigate] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead, focusList]
      }, _extends4[ListboxEvents.KeyDownSearch] = {
        target: ListboxStates.Navigating,
        actions: setTypeahead
      }, _extends4[ListboxEvents.UpdateAfterTypeahead] = {
        actions: [setNavSelectionFromTypeahead]
      }, _extends4[ListboxEvents.ClearTypeahead] = {
        actions: clearTypeahead
      }, _extends4[ListboxEvents.OptionMouseMove] = [{
        target: ListboxStates.Dragging,
        actions: [navigate],
        cond: optionIsNavigable
      }, {
        target: ListboxStates.Dragging
      }], _extends4))
    }, _states2[ListboxStates.Dragging] = {
      on: _extends$4({}, commonEvents, (_extends5 = {}, _extends5[ListboxEvents.ClearNavSelection] = {
        actions: [clearNavigationValue]
      }, _extends5[ListboxEvents.KeyDownEnter] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends5[ListboxEvents.KeyDownSpace] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends5[ListboxEvents.ButtonMouseDown] = {
        target: ListboxStates.Idle,
        actions: [focusButton]
      }, _extends5[ListboxEvents.KeyDownEscape] = {
        target: ListboxStates.Idle,
        actions: [focusButton]
      }, _extends5[ListboxEvents.OptionMouseDown] = {
        target: ListboxStates.Dragging
      }, _extends5[ListboxEvents.OutsideMouseDown] = [{
        target: ListboxStates.Idle,
        cond: clickedOutsideOfListbox,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: optionIsActive
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends5[ListboxEvents.OutsideMouseUp] = [{
        target: ListboxStates.Idle,
        cond: clickedOutsideOfListbox,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: optionIsActive,
        actions: focusList
      }, {
        target: ListboxStates.Interacting,
        actions: [clearTypeahead, focusList]
      }], _extends5[ListboxEvents.Blur] = [{
        target: ListboxStates.Idle,
        cond: listboxLostFocus,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: shouldNavigate
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends5[ListboxEvents.ButtonMouseUp] = {
        target: ListboxStates.Navigating,
        actions: [navigateFromCurrentValue, focusList]
      }, _extends5[ListboxEvents.OptionTouchStart] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead],
        cond: optionIsNavigable
      }, _extends5[ListboxEvents.OptionClick] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends5[ListboxEvents.OptionPress] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends5[ListboxEvents.OptionMouseEnter] = {
        target: ListboxStates.Dragging,
        actions: [navigate, clearTypeahead],
        cond: optionIsNavigable
      }, _extends5[ListboxEvents.KeyDownNavigate] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead, focusList]
      }, _extends5[ListboxEvents.KeyDownSearch] = {
        target: ListboxStates.Navigating,
        actions: setTypeahead
      }, _extends5[ListboxEvents.UpdateAfterTypeahead] = {
        actions: [setNavSelectionFromTypeahead]
      }, _extends5[ListboxEvents.ClearTypeahead] = {
        actions: clearTypeahead
      }, _extends5[ListboxEvents.OptionMouseMove] = [{
        target: ListboxStates.Navigating,
        actions: [navigate],
        cond: optionIsNavigable
      }, {
        target: ListboxStates.Navigating
      }], _extends5[ListboxEvents.OptionMouseUp] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends5))
    }, _states2[ListboxStates.Navigating] = {
      on: _extends$4({}, commonEvents, (_extends6 = {}, _extends6[ListboxEvents.ClearNavSelection] = {
        actions: [clearNavigationValue, focusList]
      }, _extends6[ListboxEvents.KeyDownEnter] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends6[ListboxEvents.KeyDownSpace] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends6[ListboxEvents.ButtonMouseDown] = {
        target: ListboxStates.Idle,
        actions: [focusButton]
      }, _extends6[ListboxEvents.KeyDownEscape] = {
        target: ListboxStates.Idle,
        actions: [focusButton]
      }, _extends6[ListboxEvents.OptionMouseDown] = {
        target: ListboxStates.Dragging
      }, _extends6[ListboxEvents.OutsideMouseDown] = [{
        target: ListboxStates.Idle,
        cond: clickedOutsideOfListbox,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: optionIsActive
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends6[ListboxEvents.OutsideMouseUp] = [{
        target: ListboxStates.Idle,
        cond: clickedOutsideOfListbox,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: optionIsActive
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends6[ListboxEvents.Blur] = [{
        target: ListboxStates.Idle,
        cond: listboxLostFocus,
        actions: clearTypeahead
      }, {
        target: ListboxStates.Navigating,
        cond: shouldNavigate
      }, {
        target: ListboxStates.Interacting,
        actions: clearTypeahead
      }], _extends6[ListboxEvents.ButtonMouseUp] = {
        target: ListboxStates.Navigating,
        actions: [navigateFromCurrentValue, focusList]
      }, _extends6[ListboxEvents.OptionTouchStart] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead],
        cond: optionIsNavigable
      }, _extends6[ListboxEvents.OptionClick] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends6[ListboxEvents.OptionPress] = {
        target: ListboxStates.Idle,
        actions: [assignValue, clearTypeahead, focusButton, selectOption],
        cond: optionIsSelectable
      }, _extends6[ListboxEvents.OptionMouseEnter] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead],
        cond: optionIsNavigable
      }, _extends6[ListboxEvents.KeyDownNavigate] = {
        target: ListboxStates.Navigating,
        actions: [navigate, clearTypeahead, focusList]
      }, _extends6[ListboxEvents.KeyDownSearch] = {
        target: ListboxStates.Navigating,
        actions: setTypeahead
      }, _extends6[ListboxEvents.UpdateAfterTypeahead] = {
        actions: [setNavSelectionFromTypeahead]
      }, _extends6[ListboxEvents.ClearTypeahead] = {
        actions: clearTypeahead
      }, _extends6[ListboxEvents.OptionMouseMove] = [{
        target: ListboxStates.Navigating,
        actions: [navigate],
        cond: optionIsNavigable
      }, {
        target: ListboxStates.Navigating
      }], _extends6))
    }, _states2)
  };
}, "createMachineDefinition");
function findOptionFromTypeahead(options, string) {
  if (string === void 0) {
    string = "";
  }
  if (!string)
    return null;
  var found = options.find(function(option) {
    return !option.disabled && option.label && option.label.toLowerCase().startsWith(string.toLowerCase());
  });
  return found || null;
}
__name(findOptionFromTypeahead, "findOptionFromTypeahead");
function findOptionFromValue(value3, options) {
  return value3 ? options.find(function(option) {
    return option.value === value3;
  }) : void 0;
}
__name(findOptionFromValue, "findOptionFromValue");
var _excluded$4 = ["as", "aria-labelledby", "aria-label", "children", "defaultValue", "disabled", "form", "name", "onChange", "required", "value", "__componentName"], _excluded2$3 = ["arrow", "button", "children", "portal"], _excluded3$4 = ["aria-label", "arrow", "as", "children", "onKeyDown", "onMouseDown", "onMouseUp"], _excluded4$3 = ["as", "children"], _excluded5$3 = ["as", "position", "onBlur", "onKeyDown", "onMouseUp", "portal", "unstable_observableRefs"], _excluded6 = ["as"], _excluded7$2 = ["as", "children", "disabled", "index", "label", "onClick", "onMouseDown", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseUp", "onTouchStart", "value"];
var DEBUG = false;
var ListboxDescendantContext = /* @__PURE__ */ createDescendantContext();
var ListboxContext = /* @__PURE__ */ createNamedContext("ListboxContext", {});
var ListboxInput = /* @__PURE__ */ forwardRef(/* @__PURE__ */ __name(function ListboxInput2(_ref2, forwardedRef) {
  var _ref$as = _ref2.as, Comp = _ref$as === void 0 ? "div" : _ref$as, ariaLabelledBy = _ref2["aria-labelledby"], ariaLabel = _ref2["aria-label"], children = _ref2.children, defaultValue2 = _ref2.defaultValue, _ref$disabled = _ref2.disabled, disabled = _ref$disabled === void 0 ? false : _ref$disabled, form = _ref2.form, name2 = _ref2.name, onChange = _ref2.onChange, required = _ref2.required, valueProp = _ref2.value;
  _ref2.__componentName;
  var props2 = _objectWithoutPropertiesLoose$4(_ref2, _excluded$4);
  var isControlled = useRef(valueProp != null);
  var _useDescendantsInit = useDescendantsInit(), options = _useDescendantsInit[0], setOptions = _useDescendantsInit[1];
  var buttonRef = useRef(null);
  var hiddenInputRef = useRef(null);
  var highlightedOptionRef = useRef(null);
  var inputRef = useRef(null);
  var listRef = useRef(null);
  var popoverRef = useRef(null);
  var selectedOptionRef = useRef(null);
  var machine = useCreateMachine(createMachineDefinition({
    value: (isControlled.current ? valueProp : defaultValue2) || null
  }));
  var _useMachine = useMachine(machine, {
    button: buttonRef,
    hiddenInput: hiddenInputRef,
    highlightedOption: highlightedOptionRef,
    input: inputRef,
    list: listRef,
    popover: popoverRef,
    selectedOption: selectedOptionRef
  }, DEBUG), state2 = _useMachine[0], send2 = _useMachine[1];
  function handleValueChange(newValue) {
    if (newValue !== state2.context.value) {
      onChange == null ? void 0 : onChange(newValue);
    }
  }
  __name(handleValueChange, "handleValueChange");
  var _id = useId(props2.id);
  var id2 = props2.id || makeId("listbox-input", _id);
  var ref = useComposedRefs(inputRef, forwardedRef);
  var valueLabel = useMemo(function() {
    var selected = options.find(function(option) {
      return option.value === state2.context.value;
    });
    return selected ? selected.label : null;
  }, [options, state2.context.value]);
  var isExpanded = isListboxExpanded(state2.value);
  var context = {
    ariaLabel,
    ariaLabelledBy,
    buttonRef,
    disabled,
    highlightedOptionRef,
    isExpanded,
    listboxId: id2,
    listboxValueLabel: valueLabel,
    listRef,
    onValueChange: handleValueChange,
    popoverRef,
    selectedOptionRef,
    send: send2,
    state: state2.value,
    stateData: state2.context
  };
  var mounted = useRef(false);
  if (!isControlled.current && defaultValue2 == null && !mounted.current && options.length) {
    mounted.current = true;
    var first = options.find(function(option) {
      return !option.disabled;
    });
    if (first && first.value) {
      send2({
        type: ListboxEvents.ValueChange,
        value: first.value
      });
    }
  }
  useControlledStateSync(valueProp, state2.context.value, function() {
    send2({
      type: ListboxEvents.ValueChange,
      value: valueProp
    });
  });
  useIsomorphicLayoutEffect(function() {
    send2({
      type: ListboxEvents.GetDerivedData,
      data: {
        options
      }
    });
  }, [options, send2]);
  useEffect(function() {
    function handleMouseDown(event) {
      var target2 = event.target, relatedTarget = event.relatedTarget;
      if (!popoverContainsEventTarget$1(popoverRef.current, target2)) {
        send2({
          type: ListboxEvents.OutsideMouseDown,
          relatedTarget: relatedTarget || target2
        });
      }
    }
    __name(handleMouseDown, "handleMouseDown");
    if (isExpanded) {
      window.addEventListener("mousedown", handleMouseDown);
    }
    return function() {
      window.removeEventListener("mousedown", handleMouseDown);
    };
  }, [send2, isExpanded]);
  useEffect(function() {
    function handleMouseUp(event) {
      var target2 = event.target, relatedTarget = event.relatedTarget;
      if (!popoverContainsEventTarget$1(popoverRef.current, target2)) {
        send2({
          type: ListboxEvents.OutsideMouseUp,
          relatedTarget: relatedTarget || target2
        });
      }
    }
    __name(handleMouseUp, "handleMouseUp");
    if (isExpanded) {
      window.addEventListener("mouseup", handleMouseUp);
    }
    return function() {
      window.removeEventListener("mouseup", handleMouseUp);
    };
  }, [send2, isExpanded]);
  return /* @__PURE__ */ createElement(Comp, _extends$4({}, props2, {
    ref,
    "data-reach-listbox-input": "",
    "data-state": isExpanded ? "expanded" : "closed",
    "data-value": state2.context.value,
    id: id2
  }), /* @__PURE__ */ createElement(ListboxContext.Provider, {
    value: context
  }, /* @__PURE__ */ createElement(DescendantProvider, {
    context: ListboxDescendantContext,
    items: options,
    set: setOptions
  }, isFunction$1(children) ? children({
    id: id2,
    isExpanded,
    value: state2.context.value,
    selectedOptionRef,
    highlightedOptionRef,
    valueLabel,
    expanded: isExpanded
  }) : children, (form || name2 || required) && /* @__PURE__ */ createElement("input", {
    ref: hiddenInputRef,
    "data-reach-listbox-hidden-input": "",
    disabled,
    form,
    name: name2,
    readOnly: true,
    required,
    tabIndex: -1,
    type: "hidden",
    value: state2.context.value || ""
  }))));
}, "ListboxInput"));
var Listbox$1 = /* @__PURE__ */ forwardRef(/* @__PURE__ */ __name(function Listbox(_ref2, forwardedRef) {
  var _ref2$arrow = _ref2.arrow, arrow = _ref2$arrow === void 0 ? "\u25BC" : _ref2$arrow, button2 = _ref2.button, children = _ref2.children, _ref2$portal = _ref2.portal, portal = _ref2$portal === void 0 ? true : _ref2$portal, props2 = _objectWithoutPropertiesLoose$4(_ref2, _excluded2$3);
  return /* @__PURE__ */ createElement(ListboxInput, _extends$4({}, props2, {
    __componentName: "Listbox",
    ref: forwardedRef
  }), function(_ref3) {
    var value3 = _ref3.value, valueLabel = _ref3.valueLabel;
    return /* @__PURE__ */ createElement(Fragment$1, null, /* @__PURE__ */ createElement(ListboxButton$1, {
      arrow,
      children: button2 ? isFunction$1(button2) ? button2({
        value: value3,
        label: valueLabel
      }) : button2 : void 0
    }), /* @__PURE__ */ createElement(ListboxPopover2, {
      portal
    }, /* @__PURE__ */ createElement(ListboxList, null, children)));
  });
}, "Listbox"));
var ListboxButtonImpl = /* @__PURE__ */ forwardRef(/* @__PURE__ */ __name(function ListboxButton(_ref4, forwardedRef) {
  var ariaLabel = _ref4["aria-label"], _ref4$arrow = _ref4.arrow, arrow = _ref4$arrow === void 0 ? false : _ref4$arrow, _ref4$as = _ref4.as, Comp = _ref4$as === void 0 ? "span" : _ref4$as, children = _ref4.children, onKeyDown = _ref4.onKeyDown, onMouseDown = _ref4.onMouseDown, onMouseUp = _ref4.onMouseUp, props2 = _objectWithoutPropertiesLoose$4(_ref4, _excluded3$4);
  var _React$useContext = useContext(ListboxContext), buttonRef = _React$useContext.buttonRef, send2 = _React$useContext.send, ariaLabelledBy = _React$useContext.ariaLabelledBy, disabled = _React$useContext.disabled, isExpanded = _React$useContext.isExpanded, listboxId = _React$useContext.listboxId, stateData = _React$useContext.stateData, listboxValueLabel = _React$useContext.listboxValueLabel;
  var listboxValue = stateData.value;
  var ref = useComposedRefs(buttonRef, forwardedRef);
  var handleKeyDown = useKeyDown$1();
  function handleMouseDown(event) {
    if (!isRightClick(event.nativeEvent)) {
      event.preventDefault();
      event.stopPropagation();
      send2({
        type: ListboxEvents.ButtonMouseDown,
        disabled
      });
    }
  }
  __name(handleMouseDown, "handleMouseDown");
  function handleMouseUp(event) {
    if (!isRightClick(event.nativeEvent)) {
      event.preventDefault();
      event.stopPropagation();
      send2({
        type: ListboxEvents.ButtonMouseUp
      });
    }
  }
  __name(handleMouseUp, "handleMouseUp");
  var id2 = makeId("button", listboxId);
  var label = useMemo(function() {
    if (!children) {
      return listboxValueLabel;
    } else if (isFunction$1(children)) {
      return children({
        isExpanded,
        label: listboxValueLabel,
        value: listboxValue,
        expanded: isExpanded
      });
    }
    return children;
  }, [children, listboxValueLabel, isExpanded, listboxValue]);
  return /* @__PURE__ */ createElement(Comp, _extends$4({
    "aria-disabled": disabled || void 0,
    "aria-expanded": isExpanded || void 0,
    "aria-haspopup": "listbox",
    "aria-labelledby": ariaLabel ? void 0 : [ariaLabelledBy, id2].filter(Boolean).join(" "),
    "aria-label": ariaLabel,
    role: "button",
    tabIndex: disabled ? -1 : 0
  }, props2, {
    ref,
    "data-reach-listbox-button": "",
    id: id2,
    onKeyDown: composeEventHandlers(onKeyDown, handleKeyDown),
    onMouseDown: composeEventHandlers(onMouseDown, handleMouseDown),
    onMouseUp: composeEventHandlers(onMouseUp, handleMouseUp)
  }), label, arrow && /* @__PURE__ */ createElement(ListboxArrow2, null, isBoolean(arrow) ? null : arrow));
}, "ListboxButton"));
var ListboxButton$1 = /* @__PURE__ */ memo(ListboxButtonImpl);
var ListboxArrowImpl = /* @__PURE__ */ forwardRef(/* @__PURE__ */ __name(function ListboxArrow(_ref5, forwardedRef) {
  var _ref5$as = _ref5.as, Comp = _ref5$as === void 0 ? "span" : _ref5$as, children = _ref5.children, props2 = _objectWithoutPropertiesLoose$4(_ref5, _excluded4$3);
  var _React$useContext2 = useContext(ListboxContext), isExpanded = _React$useContext2.isExpanded;
  return /* @__PURE__ */ createElement(Comp, _extends$4({
    "aria-hidden": true
  }, props2, {
    ref: forwardedRef,
    "data-reach-listbox-arrow": "",
    "data-expanded": isExpanded ? "" : void 0
  }), isFunction$1(children) ? children({
    isExpanded,
    expanded: isExpanded
  }) : children || "\u25BC");
}, "ListboxArrow"));
var ListboxArrow2 = /* @__PURE__ */ memo(ListboxArrowImpl);
var ListboxPopoverImpl = /* @__PURE__ */ forwardRef(/* @__PURE__ */ __name(function ListboxPopover(_ref6, forwardedRef) {
  var _ref6$as = _ref6.as, Comp = _ref6$as === void 0 ? "div" : _ref6$as, _ref6$position = _ref6.position, position = _ref6$position === void 0 ? positionMatchWidth : _ref6$position, onBlur3 = _ref6.onBlur, onKeyDown = _ref6.onKeyDown, onMouseUp = _ref6.onMouseUp, _ref6$portal = _ref6.portal, portal = _ref6$portal === void 0 ? true : _ref6$portal, unstable_observableRefs = _ref6.unstable_observableRefs, props2 = _objectWithoutPropertiesLoose$4(_ref6, _excluded5$3);
  var _React$useContext3 = useContext(ListboxContext), isExpanded = _React$useContext3.isExpanded, buttonRef = _React$useContext3.buttonRef, popoverRef = _React$useContext3.popoverRef, send2 = _React$useContext3.send;
  var ref = useComposedRefs(popoverRef, forwardedRef);
  var handleKeyDown = useKeyDown$1();
  function handleMouseUp() {
    send2({
      type: ListboxEvents.ListMouseUp
    });
  }
  __name(handleMouseUp, "handleMouseUp");
  var commonProps = _extends$4({
    hidden: !isExpanded,
    tabIndex: -1
  }, props2, {
    ref,
    "data-reach-listbox-popover": "",
    onMouseUp: composeEventHandlers(onMouseUp, handleMouseUp),
    onBlur: composeEventHandlers(onBlur3, handleBlur),
    onKeyDown: composeEventHandlers(onKeyDown, handleKeyDown)
  });
  function handleBlur(event) {
    var nativeEvent = event.nativeEvent;
    requestAnimationFrame(function() {
      send2({
        type: ListboxEvents.Blur,
        relatedTarget: nativeEvent.relatedTarget || nativeEvent.target
      });
    });
  }
  __name(handleBlur, "handleBlur");
  return portal ? /* @__PURE__ */ createElement(Popover, _extends$4({}, commonProps, {
    as: Comp,
    targetRef: buttonRef,
    position,
    unstable_observableRefs,
    unstable_skipInitialPortalRender: true
  })) : /* @__PURE__ */ createElement(Comp, commonProps);
}, "ListboxPopover"));
var ListboxPopover2 = /* @__PURE__ */ memo(ListboxPopoverImpl);
var ListboxList = /* @__PURE__ */ forwardRef(/* @__PURE__ */ __name(function ListboxList2(_ref7, forwardedRef) {
  var _ref7$as = _ref7.as, Comp = _ref7$as === void 0 ? "ul" : _ref7$as, props2 = _objectWithoutPropertiesLoose$4(_ref7, _excluded6);
  var _React$useContext4 = useContext(ListboxContext), listRef = _React$useContext4.listRef, ariaLabel = _React$useContext4.ariaLabel, ariaLabelledBy = _React$useContext4.ariaLabelledBy, isExpanded = _React$useContext4.isExpanded, listboxId = _React$useContext4.listboxId, _React$useContext4$st = _React$useContext4.stateData, value3 = _React$useContext4$st.value, navigationValue4 = _React$useContext4$st.navigationValue;
  var ref = useComposedRefs(forwardedRef, listRef);
  return /* @__PURE__ */ createElement(Comp, _extends$4({
    "aria-activedescendant": useOptionId(isExpanded ? navigationValue4 : value3),
    "aria-labelledby": ariaLabel ? void 0 : ariaLabelledBy,
    "aria-label": ariaLabel,
    role: "listbox",
    tabIndex: -1
  }, props2, {
    ref,
    "data-reach-listbox-list": "",
    id: makeId("listbox", listboxId)
  }));
}, "ListboxList"));
var ListboxOption = /* @__PURE__ */ forwardRef(/* @__PURE__ */ __name(function ListboxOption2(_ref8, forwardedRef) {
  var _ref8$as = _ref8.as, Comp = _ref8$as === void 0 ? "li" : _ref8$as, children = _ref8.children, disabled = _ref8.disabled, indexProp = _ref8.index, labelProp = _ref8.label, onClick = _ref8.onClick, onMouseDown = _ref8.onMouseDown, onMouseEnter = _ref8.onMouseEnter, onMouseLeave = _ref8.onMouseLeave, onMouseMove = _ref8.onMouseMove, onMouseUp = _ref8.onMouseUp, onTouchStart = _ref8.onTouchStart, value3 = _ref8.value, props2 = _objectWithoutPropertiesLoose$4(_ref8, _excluded7$2);
  var _React$useContext5 = useContext(ListboxContext), highlightedOptionRef = _React$useContext5.highlightedOptionRef, selectedOptionRef = _React$useContext5.selectedOptionRef, send2 = _React$useContext5.send, isExpanded = _React$useContext5.isExpanded, onValueChange = _React$useContext5.onValueChange, state2 = _React$useContext5.state, _React$useContext5$st = _React$useContext5.stateData, listboxValue = _React$useContext5$st.value, navigationValue4 = _React$useContext5$st.navigationValue;
  var _React$useState = useState(labelProp), labelState = _React$useState[0], setLabel = _React$useState[1];
  var label = labelProp || labelState || "";
  var ownRef = useRef(null);
  var _useStatefulRefValue = useStatefulRefValue(ownRef, null), element = _useStatefulRefValue[0], handleRefSet = _useStatefulRefValue[1];
  var descendant = useMemo(function() {
    return {
      element,
      value: value3,
      label,
      disabled: !!disabled
    };
  }, [disabled, element, label, value3]);
  useDescendant(descendant, ListboxDescendantContext, indexProp);
  var getLabelFromDomNode = useCallback(function(node) {
    if (!labelProp && node) {
      setLabel(function(prevState) {
        if (node.textContent && prevState !== node.textContent) {
          return node.textContent;
        }
        return prevState || "";
      });
    }
  }, [labelProp]);
  var isHighlighted = navigationValue4 ? navigationValue4 === value3 : false;
  var isSelected = listboxValue === value3;
  var ref = useComposedRefs(getLabelFromDomNode, forwardedRef, handleRefSet, isSelected ? selectedOptionRef : null, isHighlighted ? highlightedOptionRef : null);
  function handleMouseEnter() {
    send2({
      type: ListboxEvents.OptionMouseEnter,
      value: value3,
      disabled: !!disabled
    });
  }
  __name(handleMouseEnter, "handleMouseEnter");
  function handleTouchStart() {
    send2({
      type: ListboxEvents.OptionTouchStart,
      value: value3,
      disabled: !!disabled
    });
  }
  __name(handleTouchStart, "handleTouchStart");
  function handleMouseLeave() {
    send2({
      type: ListboxEvents.ClearNavSelection
    });
  }
  __name(handleMouseLeave, "handleMouseLeave");
  function handleMouseDown(event) {
    if (!isRightClick(event.nativeEvent)) {
      event.preventDefault();
      send2({
        type: ListboxEvents.OptionMouseDown
      });
    }
  }
  __name(handleMouseDown, "handleMouseDown");
  function handleMouseUp(event) {
    if (!isRightClick(event.nativeEvent)) {
      send2({
        type: ListboxEvents.OptionMouseUp,
        value: value3,
        callback: onValueChange,
        disabled: !!disabled
      });
    }
  }
  __name(handleMouseUp, "handleMouseUp");
  function handleClick(event) {
    if (!isRightClick(event.nativeEvent)) {
      send2({
        type: ListboxEvents.OptionClick,
        value: value3,
        callback: onValueChange,
        disabled: !!disabled
      });
    }
  }
  __name(handleClick, "handleClick");
  function handleMouseMove() {
    if (state2 === ListboxStates.Open || navigationValue4 !== value3) {
      send2({
        type: ListboxEvents.OptionMouseMove,
        value: value3,
        disabled: !!disabled
      });
    }
  }
  __name(handleMouseMove, "handleMouseMove");
  return /* @__PURE__ */ createElement(Comp, _extends$4({
    "aria-selected": (isExpanded ? isHighlighted : isSelected) || void 0,
    "aria-disabled": disabled || void 0,
    role: "option"
  }, props2, {
    ref,
    id: useOptionId(value3),
    "data-reach-listbox-option": "",
    "data-current-nav": isHighlighted ? "" : void 0,
    "data-current-selected": isSelected ? "" : void 0,
    "data-label": label,
    "data-value": value3,
    onClick: composeEventHandlers(onClick, handleClick),
    onMouseDown: composeEventHandlers(onMouseDown, handleMouseDown),
    onMouseEnter: composeEventHandlers(onMouseEnter, handleMouseEnter),
    onMouseLeave: composeEventHandlers(onMouseLeave, handleMouseLeave),
    onMouseMove: composeEventHandlers(onMouseMove, handleMouseMove),
    onMouseUp: composeEventHandlers(onMouseUp, handleMouseUp),
    onTouchStart: composeEventHandlers(onTouchStart, handleTouchStart)
  }), children);
}, "ListboxOption"));
function isListboxExpanded(state2) {
  return [ListboxStates.Navigating, ListboxStates.Open, ListboxStates.Dragging, ListboxStates.Interacting].includes(state2);
}
__name(isListboxExpanded, "isListboxExpanded");
function useKeyDown$1() {
  var _React$useContext9 = useContext(ListboxContext), send2 = _React$useContext9.send, listboxDisabled = _React$useContext9.disabled, onValueChange = _React$useContext9.onValueChange, _React$useContext9$st = _React$useContext9.stateData, navigationValue4 = _React$useContext9$st.navigationValue, typeaheadQuery2 = _React$useContext9$st.typeaheadQuery;
  var options = useDescendants(ListboxDescendantContext);
  var stableOnValueChange = useStableCallback(onValueChange);
  useEffect(function() {
    if (typeaheadQuery2) {
      send2({
        type: ListboxEvents.UpdateAfterTypeahead,
        query: typeaheadQuery2,
        callback: stableOnValueChange
      });
    }
    var timeout = window.setTimeout(function() {
      if (typeaheadQuery2 != null) {
        send2({
          type: ListboxEvents.ClearTypeahead
        });
      }
    }, 1e3);
    return function() {
      window.clearTimeout(timeout);
    };
  }, [stableOnValueChange, send2, typeaheadQuery2]);
  var index = options.findIndex(function(_ref11) {
    var value3 = _ref11.value;
    return value3 === navigationValue4;
  });
  var handleKeyDown = composeEventHandlers(function(event) {
    var key = event.key;
    var isSearching = isString$1(key) && key.length === 1;
    var navOption = options.find(function(option) {
      return option.value === navigationValue4;
    });
    switch (key) {
      case "Enter":
        send2({
          type: ListboxEvents.KeyDownEnter,
          value: navigationValue4,
          callback: onValueChange,
          disabled: !!(navOption != null && navOption.disabled || listboxDisabled)
        });
        return;
      case " ":
        event.preventDefault();
        send2({
          type: ListboxEvents.KeyDownSpace,
          value: navigationValue4,
          callback: onValueChange,
          disabled: !!(navOption != null && navOption.disabled || listboxDisabled)
        });
        return;
      case "Escape":
        send2({
          type: ListboxEvents.KeyDownEscape
        });
        return;
      case "Tab":
        var eventType = event.shiftKey ? ListboxEvents.KeyDownShiftTab : ListboxEvents.KeyDownTab;
        send2({
          type: eventType
        });
        return;
      default:
        if (isSearching) {
          send2({
            type: ListboxEvents.KeyDownSearch,
            query: key,
            disabled: listboxDisabled
          });
        }
        return;
    }
  }, useDescendantKeyDown(ListboxDescendantContext, {
    currentIndex: index,
    orientation: "vertical",
    key: "index",
    rotate: true,
    filter: /* @__PURE__ */ __name(function filter(option) {
      return !option.disabled;
    }, "filter"),
    callback: /* @__PURE__ */ __name(function callback(nextIndex) {
      send2({
        type: ListboxEvents.KeyDownNavigate,
        value: options[nextIndex].value,
        disabled: listboxDisabled
      });
    }, "callback")
  }));
  return handleKeyDown;
}
__name(useKeyDown$1, "useKeyDown$1");
function useOptionId(value3) {
  var _React$useContext10 = useContext(ListboxContext), listboxId = _React$useContext10.listboxId;
  return value3 ? makeId("option-" + value3, listboxId) : void 0;
}
__name(useOptionId, "useOptionId");
function popoverContainsEventTarget$1(popover, target2) {
  return !!(popover && popover.contains(target2));
}
__name(popoverContainsEventTarget$1, "popoverContainsEventTarget$1");
function useControlledStateSync(controlPropValue, internalValue, send2) {
  var _React$useRef = useRef(controlPropValue != null), isControlled = _React$useRef.current;
  if (isControlled && controlPropValue !== internalValue) {
    send2();
  }
}
__name(useControlledStateSync, "useControlledStateSync");
function usePrevious(value3) {
  var ref = useRef(null);
  useEffect(function() {
    ref.current = value3;
  }, [value3]);
  return ref.current;
}
__name(usePrevious, "usePrevious");
function _objectWithoutPropertiesLoose$3(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
__name(_objectWithoutPropertiesLoose$3, "_objectWithoutPropertiesLoose$3");
function _extends$3() {
  _extends$3 = Object.assign || function(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends$3.apply(this, arguments);
}
__name(_extends$3, "_extends$3");
var _excluded$3 = ["onKeyDown", "onMouseDown", "id", "ref"], _excluded3$3 = ["index", "isLink", "onClick", "onDragStart", "onMouseDown", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseUp", "onSelect", "disabled", "onFocus", "valueText", "ref"], _excluded5$2 = ["id", "onKeyDown", "ref"], _excluded7$1 = ["onBlur", "portal", "position", "ref"];
var CLEAR_SELECTION_INDEX = "CLEAR_SELECTION_INDEX";
var CLICK_MENU_ITEM = "CLICK_MENU_ITEM";
var CLOSE_MENU = "CLOSE_MENU";
var OPEN_MENU_AT_FIRST_ITEM = "OPEN_MENU_AT_FIRST_ITEM";
var OPEN_MENU_AT_INDEX = "OPEN_MENU_AT_INDEX";
var OPEN_MENU_CLEARED = "OPEN_MENU_CLEARED";
var SEARCH_FOR_ITEM = "SEARCH_FOR_ITEM";
var SELECT_ITEM_AT_INDEX = "SELECT_ITEM_AT_INDEX";
var SET_BUTTON_ID = "SET_BUTTON_ID";
var DropdownDescendantContext = /* @__PURE__ */ createDescendantContext();
var _createContext = /* @__PURE__ */ createContext("Dropdown"), DropdownProvider = _createContext[0], useDropdownContext = _createContext[1];
var initialState = {
  triggerId: null,
  isExpanded: false,
  typeaheadQuery: "",
  selectionIndex: -1
};
var DropdownProvider_ = /* @__PURE__ */ __name(function DropdownProvider_2(_ref2) {
  var id2 = _ref2.id, children = _ref2.children;
  var triggerRef = useRef(null);
  var dropdownRef = useRef(null);
  var popoverRef = useRef(null);
  var _useDescendantsInit = useDescendantsInit(), descendants = _useDescendantsInit[0], setDescendants = _useDescendantsInit[1];
  var _id = useId(id2);
  var dropdownId = id2 || makeId("menu", _id);
  var triggerId = makeId("menu-button", dropdownId);
  var _React$useReducer = useReducer(reducer$1, _extends$3({}, initialState, {
    triggerId
  })), state2 = _React$useReducer[0], dispatch = _React$useReducer[1];
  var triggerClickedRef = useRef(false);
  var selectCallbacks = useRef([]);
  var readyToSelect = useRef(false);
  var mouseDownStartPosRef = useRef({
    x: 0,
    y: 0
  });
  useEffect(function() {
    if (state2.isExpanded) {
      window.__REACH_DISABLE_TOOLTIPS = true;
      window.requestAnimationFrame(function() {
        focus(dropdownRef.current);
      });
    } else {
      window.__REACH_DISABLE_TOOLTIPS = false;
    }
  }, [state2.isExpanded]);
  return /* @__PURE__ */ createElement(DescendantProvider, {
    context: DropdownDescendantContext,
    items: descendants,
    set: setDescendants
  }, /* @__PURE__ */ createElement(DropdownProvider, {
    dispatch,
    dropdownId,
    dropdownRef,
    mouseDownStartPosRef,
    popoverRef,
    readyToSelect,
    selectCallbacks,
    state: state2,
    triggerClickedRef,
    triggerRef
  }, isFunction$1(children) ? children({
    isExpanded: state2.isExpanded,
    isOpen: state2.isExpanded
  }) : children));
}, "DropdownProvider_");
function useDropdownTrigger(_ref2) {
  var onKeyDown = _ref2.onKeyDown, onMouseDown = _ref2.onMouseDown, id2 = _ref2.id, forwardedRef = _ref2.ref, props2 = _objectWithoutPropertiesLoose$3(_ref2, _excluded$3);
  var _useDropdownContext = useDropdownContext("useDropdownTrigger"), dispatch = _useDropdownContext.dispatch, dropdownId = _useDropdownContext.dropdownId, mouseDownStartPosRef = _useDropdownContext.mouseDownStartPosRef, triggerClickedRef = _useDropdownContext.triggerClickedRef, triggerRef = _useDropdownContext.triggerRef, _useDropdownContext$s = _useDropdownContext.state, triggerId = _useDropdownContext$s.triggerId, isExpanded = _useDropdownContext$s.isExpanded;
  var ref = useComposedRefs(triggerRef, forwardedRef);
  var items = useDropdownDescendants();
  var firstNonDisabledIndex = useMemo(function() {
    return items.findIndex(function(item) {
      return !item.disabled;
    });
  }, [items]);
  useEffect(function() {
    if (id2 != null && id2 !== triggerId) {
      dispatch({
        type: SET_BUTTON_ID,
        payload: id2
      });
    }
  }, [triggerId, dispatch, id2]);
  function handleKeyDown(event) {
    switch (event.key) {
      case "ArrowDown":
      case "ArrowUp":
        event.preventDefault();
        dispatch({
          type: OPEN_MENU_AT_INDEX,
          payload: {
            index: firstNonDisabledIndex
          }
        });
        break;
      case "Enter":
      case " ":
        dispatch({
          type: OPEN_MENU_AT_INDEX,
          payload: {
            index: firstNonDisabledIndex
          }
        });
        break;
    }
  }
  __name(handleKeyDown, "handleKeyDown");
  function handleMouseDown(event) {
    if (isRightClick(event.nativeEvent)) {
      return;
    }
    mouseDownStartPosRef.current = {
      x: event.clientX,
      y: event.clientY
    };
    if (!isExpanded) {
      triggerClickedRef.current = true;
    }
    if (isExpanded) {
      dispatch({
        type: CLOSE_MENU
      });
    } else {
      dispatch({
        type: OPEN_MENU_CLEARED
      });
    }
  }
  __name(handleMouseDown, "handleMouseDown");
  return {
    data: {
      isExpanded,
      controls: dropdownId
    },
    props: _extends$3({}, props2, {
      ref,
      id: triggerId || void 0,
      onKeyDown: composeEventHandlers(onKeyDown, handleKeyDown),
      onMouseDown: composeEventHandlers(onMouseDown, handleMouseDown),
      type: "button"
    })
  };
}
__name(useDropdownTrigger, "useDropdownTrigger");
function useDropdownItem(_ref4) {
  var indexProp = _ref4.index, _ref4$isLink = _ref4.isLink, isLink = _ref4$isLink === void 0 ? false : _ref4$isLink, onClick = _ref4.onClick, onDragStart = _ref4.onDragStart, onMouseDown = _ref4.onMouseDown, onMouseEnter = _ref4.onMouseEnter, onMouseLeave = _ref4.onMouseLeave, onMouseMove = _ref4.onMouseMove, onMouseUp = _ref4.onMouseUp, onSelect = _ref4.onSelect, disabled = _ref4.disabled, onFocus3 = _ref4.onFocus, valueTextProp = _ref4.valueText, forwardedRef = _ref4.ref, props2 = _objectWithoutPropertiesLoose$3(_ref4, _excluded3$3);
  var _useDropdownContext2 = useDropdownContext("useDropdownItem"), dispatch = _useDropdownContext2.dispatch, dropdownRef = _useDropdownContext2.dropdownRef, mouseDownStartPosRef = _useDropdownContext2.mouseDownStartPosRef, readyToSelect = _useDropdownContext2.readyToSelect, selectCallbacks = _useDropdownContext2.selectCallbacks, triggerRef = _useDropdownContext2.triggerRef, _useDropdownContext2$ = _useDropdownContext2.state, selectionIndex = _useDropdownContext2$.selectionIndex, isExpanded = _useDropdownContext2$.isExpanded;
  var ownRef = useRef(null);
  var _React$useState = useState(valueTextProp || ""), valueText = _React$useState[0], setValueText = _React$useState[1];
  var setValueTextFromDOM = useCallback(function(node) {
    if (!valueTextProp && node != null && node.textContent) {
      setValueText(node.textContent);
    }
  }, [valueTextProp]);
  var mouseEventStarted = useRef(false);
  var _useStatefulRefValue = useStatefulRefValue(ownRef, null), element = _useStatefulRefValue[0], handleRefSet = _useStatefulRefValue[1];
  var descendant = useMemo(function() {
    return {
      element,
      key: valueText,
      disabled,
      isLink
    };
  }, [disabled, element, isLink, valueText]);
  var index = useDescendant(descendant, DropdownDescendantContext, indexProp);
  var isSelected = index === selectionIndex && !disabled;
  var ref = useComposedRefs(forwardedRef, handleRefSet, setValueTextFromDOM);
  selectCallbacks.current[index] = onSelect;
  function select() {
    focus(triggerRef.current);
    onSelect && onSelect();
    dispatch({
      type: CLICK_MENU_ITEM
    });
  }
  __name(select, "select");
  function handleClick(event) {
    if (isRightClick(event.nativeEvent)) {
      return;
    }
    if (isLink) {
      if (disabled) {
        event.preventDefault();
      } else {
        select();
      }
    }
  }
  __name(handleClick, "handleClick");
  function handleDragStart(event) {
    if (isLink) {
      event.preventDefault();
    }
  }
  __name(handleDragStart, "handleDragStart");
  function handleMouseDown(event) {
    if (isRightClick(event.nativeEvent)) {
      return;
    }
    if (isLink) {
      mouseEventStarted.current = true;
    } else {
      event.preventDefault();
    }
  }
  __name(handleMouseDown, "handleMouseDown");
  function handleMouseEnter(event) {
    var doc = getOwnerDocument(dropdownRef.current);
    if (!isSelected && index != null && !disabled) {
      if (dropdownRef != null && dropdownRef.current && dropdownRef.current !== doc.activeElement && ownRef.current !== doc.activeElement) {
        dropdownRef.current.focus();
      }
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index
        }
      });
    }
  }
  __name(handleMouseEnter, "handleMouseEnter");
  function handleMouseLeave(event) {
    dispatch({
      type: CLEAR_SELECTION_INDEX
    });
  }
  __name(handleMouseLeave, "handleMouseLeave");
  function handleMouseMove(event) {
    if (!readyToSelect.current) {
      var threshold = 8;
      var deltaX = Math.abs(event.clientX - mouseDownStartPosRef.current.x);
      var deltaY = Math.abs(event.clientY - mouseDownStartPosRef.current.y);
      if (deltaX > threshold || deltaY > threshold) {
        readyToSelect.current = true;
      }
    }
    if (!isSelected && index != null && !disabled) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index,
          dropdownRef
        }
      });
    }
  }
  __name(handleMouseMove, "handleMouseMove");
  function handleFocus() {
    readyToSelect.current = true;
    if (!isSelected && index != null && !disabled) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index
        }
      });
    }
  }
  __name(handleFocus, "handleFocus");
  function handleMouseUp(event) {
    if (isRightClick(event.nativeEvent)) {
      return;
    }
    if (!readyToSelect.current) {
      readyToSelect.current = true;
      return;
    }
    if (isLink) {
      if (mouseEventStarted.current) {
        mouseEventStarted.current = false;
      } else if (ownRef.current) {
        ownRef.current.click();
      }
    } else {
      if (!disabled) {
        select();
      }
    }
  }
  __name(handleMouseUp, "handleMouseUp");
  useEffect(function() {
    if (isExpanded) {
      var id2 = window.setTimeout(function() {
        readyToSelect.current = true;
      }, 400);
      return function() {
        window.clearTimeout(id2);
      };
    } else {
      readyToSelect.current = false;
    }
  }, [isExpanded, readyToSelect]);
  useEffect(function() {
    var ownerDocument = getOwnerDocument(ownRef.current);
    ownerDocument.addEventListener("mouseup", listener);
    return function() {
      ownerDocument.removeEventListener("mouseup", listener);
    };
    function listener() {
      mouseEventStarted.current = false;
    }
    __name(listener, "listener");
  }, []);
  return {
    data: {
      disabled
    },
    props: _extends$3({
      id: useItemId(index),
      tabIndex: -1
    }, props2, {
      ref,
      "data-disabled": disabled ? "" : void 0,
      "data-selected": isSelected ? "" : void 0,
      "data-valuetext": valueText,
      onClick: composeEventHandlers(onClick, handleClick),
      onDragStart: composeEventHandlers(onDragStart, handleDragStart),
      onMouseDown: composeEventHandlers(onMouseDown, handleMouseDown),
      onMouseEnter: composeEventHandlers(onMouseEnter, handleMouseEnter),
      onMouseLeave: composeEventHandlers(onMouseLeave, handleMouseLeave),
      onMouseMove: composeEventHandlers(onMouseMove, handleMouseMove),
      onFocus: composeEventHandlers(onFocus3, handleFocus),
      onMouseUp: composeEventHandlers(onMouseUp, handleMouseUp)
    })
  };
}
__name(useDropdownItem, "useDropdownItem");
function useDropdownItems(_ref6) {
  _ref6.id;
  var onKeyDown = _ref6.onKeyDown, forwardedRef = _ref6.ref, props2 = _objectWithoutPropertiesLoose$3(_ref6, _excluded5$2);
  var _useDropdownContext3 = useDropdownContext("useDropdownItems"), dispatch = _useDropdownContext3.dispatch, triggerRef = _useDropdownContext3.triggerRef, dropdownRef = _useDropdownContext3.dropdownRef, selectCallbacks = _useDropdownContext3.selectCallbacks, dropdownId = _useDropdownContext3.dropdownId, _useDropdownContext3$ = _useDropdownContext3.state, isExpanded = _useDropdownContext3$.isExpanded, triggerId = _useDropdownContext3$.triggerId, selectionIndex = _useDropdownContext3$.selectionIndex, typeaheadQuery2 = _useDropdownContext3$.typeaheadQuery;
  var items = useDropdownDescendants();
  var ref = useComposedRefs(dropdownRef, forwardedRef);
  useEffect(function() {
    var match2 = findItemFromTypeahead(items, typeaheadQuery2);
    if (typeaheadQuery2 && match2 != null) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: match2,
          dropdownRef
        }
      });
    }
    var timeout = window.setTimeout(function() {
      return typeaheadQuery2 && dispatch({
        type: SEARCH_FOR_ITEM,
        payload: ""
      });
    }, 1e3);
    return function() {
      return window.clearTimeout(timeout);
    };
  }, [dispatch, items, typeaheadQuery2, dropdownRef]);
  var prevItemsLength = usePrevious(items.length);
  var prevSelected = usePrevious(items[selectionIndex]);
  var prevSelectionIndex = usePrevious(selectionIndex);
  useEffect(function() {
    if (selectionIndex > items.length - 1) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: items.length - 1,
          dropdownRef
        }
      });
    } else if (prevItemsLength !== items.length && selectionIndex > -1 && prevSelected && prevSelectionIndex === selectionIndex && items[selectionIndex] !== prevSelected) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index: items.findIndex(function(i) {
            return i.key === (prevSelected == null ? void 0 : prevSelected.key);
          }),
          dropdownRef
        }
      });
    }
  }, [dropdownRef, dispatch, items, prevItemsLength, prevSelected, prevSelectionIndex, selectionIndex]);
  var handleKeyDown = composeEventHandlers(/* @__PURE__ */ __name(function handleKeyDown2(event) {
    var key = event.key;
    if (!isExpanded) {
      return;
    }
    switch (key) {
      case "Enter":
      case " ":
        var selected = items.find(function(item) {
          return item.index === selectionIndex;
        });
        if (selected && !selected.disabled) {
          event.preventDefault();
          if (selected.isLink && selected.element) {
            selected.element.click();
          } else {
            focus(triggerRef.current);
            selectCallbacks.current[selected.index] && selectCallbacks.current[selected.index]();
            dispatch({
              type: CLICK_MENU_ITEM
            });
          }
        }
        break;
      case "Escape":
        focus(triggerRef.current);
        dispatch({
          type: CLOSE_MENU
        });
        break;
      case "Tab":
        event.preventDefault();
        break;
      default:
        if (isString$1(key) && key.length === 1) {
          var query = typeaheadQuery2 + key.toLowerCase();
          dispatch({
            type: SEARCH_FOR_ITEM,
            payload: query
          });
        }
        break;
    }
  }, "handleKeyDown"), useDescendantKeyDown(DropdownDescendantContext, {
    currentIndex: selectionIndex,
    orientation: "vertical",
    rotate: false,
    filter: /* @__PURE__ */ __name(function filter(item) {
      return !item.disabled;
    }, "filter"),
    callback: /* @__PURE__ */ __name(function callback(index) {
      dispatch({
        type: SELECT_ITEM_AT_INDEX,
        payload: {
          index,
          dropdownRef
        }
      });
    }, "callback"),
    key: "index"
  }));
  return {
    data: {
      activeDescendant: useItemId(selectionIndex) || void 0,
      triggerId
    },
    props: _extends$3({
      tabIndex: -1
    }, props2, {
      ref,
      id: dropdownId,
      onKeyDown: composeEventHandlers(onKeyDown, handleKeyDown)
    })
  };
}
__name(useDropdownItems, "useDropdownItems");
function useDropdownPopover(_ref8) {
  var onBlur3 = _ref8.onBlur, _ref8$portal = _ref8.portal, portal = _ref8$portal === void 0 ? true : _ref8$portal, position = _ref8.position, forwardedRef = _ref8.ref, props2 = _objectWithoutPropertiesLoose$3(_ref8, _excluded7$1);
  var _useDropdownContext4 = useDropdownContext("useDropdownPopover"), triggerRef = _useDropdownContext4.triggerRef, triggerClickedRef = _useDropdownContext4.triggerClickedRef, dispatch = _useDropdownContext4.dispatch, dropdownRef = _useDropdownContext4.dropdownRef, popoverRef = _useDropdownContext4.popoverRef, isExpanded = _useDropdownContext4.state.isExpanded;
  var ref = useComposedRefs(popoverRef, forwardedRef);
  useEffect(function() {
    if (!isExpanded) {
      return;
    }
    var ownerDocument = getOwnerDocument(popoverRef.current);
    function listener(event) {
      if (triggerClickedRef.current) {
        triggerClickedRef.current = false;
      } else if (!popoverContainsEventTarget(popoverRef.current, event.target)) {
        dispatch({
          type: CLOSE_MENU
        });
      }
    }
    __name(listener, "listener");
    ownerDocument.addEventListener("mousedown", listener);
    return function() {
      ownerDocument.removeEventListener("mousedown", listener);
    };
  }, [triggerClickedRef, triggerRef, dispatch, dropdownRef, popoverRef, isExpanded]);
  return {
    data: {
      portal,
      position,
      targetRef: triggerRef,
      isExpanded
    },
    props: _extends$3({
      ref,
      hidden: !isExpanded,
      onBlur: composeEventHandlers(onBlur3, function(event) {
        if (event.currentTarget.contains(event.relatedTarget)) {
          return;
        }
        dispatch({
          type: CLOSE_MENU
        });
      })
    }, props2)
  };
}
__name(useDropdownPopover, "useDropdownPopover");
function findItemFromTypeahead(items, string) {
  if (string === void 0) {
    string = "";
  }
  if (!string) {
    return null;
  }
  var found = items.find(function(item) {
    var _item$element, _item$element$dataset, _item$element$dataset2;
    return item.disabled ? false : (_item$element = item.element) == null ? void 0 : (_item$element$dataset = _item$element.dataset) == null ? void 0 : (_item$element$dataset2 = _item$element$dataset.valuetext) == null ? void 0 : _item$element$dataset2.toLowerCase().startsWith(string);
  });
  return found ? items.indexOf(found) : null;
}
__name(findItemFromTypeahead, "findItemFromTypeahead");
function useItemId(index) {
  var _useDropdownContext5 = useDropdownContext("useItemId"), dropdownId = _useDropdownContext5.dropdownId;
  return index != null && index > -1 ? makeId("option-" + index, dropdownId) : void 0;
}
__name(useItemId, "useItemId");
function focus(element) {
  element && element.focus();
}
__name(focus, "focus");
function popoverContainsEventTarget(popover, target2) {
  return !!(popover && popover.contains(target2));
}
__name(popoverContainsEventTarget, "popoverContainsEventTarget");
function reducer$1(state2, action) {
  if (action === void 0) {
    action = {};
  }
  switch (action.type) {
    case CLICK_MENU_ITEM:
      return _extends$3({}, state2, {
        isExpanded: false,
        selectionIndex: -1
      });
    case CLOSE_MENU:
      return _extends$3({}, state2, {
        isExpanded: false,
        selectionIndex: -1
      });
    case OPEN_MENU_AT_FIRST_ITEM:
      return _extends$3({}, state2, {
        isExpanded: true,
        selectionIndex: 0
      });
    case OPEN_MENU_AT_INDEX:
      return _extends$3({}, state2, {
        isExpanded: true,
        selectionIndex: action.payload.index
      });
    case OPEN_MENU_CLEARED:
      return _extends$3({}, state2, {
        isExpanded: true,
        selectionIndex: -1
      });
    case SELECT_ITEM_AT_INDEX: {
      var _action$payload$dropd = action.payload.dropdownRef, dropdownRef = _action$payload$dropd === void 0 ? {
        current: null
      } : _action$payload$dropd;
      if (action.payload.index >= 0 && action.payload.index !== state2.selectionIndex) {
        if (dropdownRef.current) {
          var doc = getOwnerDocument(dropdownRef.current);
          if (dropdownRef.current !== (doc == null ? void 0 : doc.activeElement)) {
            dropdownRef.current.focus();
          }
        }
        return _extends$3({}, state2, {
          selectionIndex: action.payload.max != null ? Math.min(Math.max(action.payload.index, 0), action.payload.max) : Math.max(action.payload.index, 0)
        });
      }
      return state2;
    }
    case CLEAR_SELECTION_INDEX:
      return _extends$3({}, state2, {
        selectionIndex: -1
      });
    case SET_BUTTON_ID:
      return _extends$3({}, state2, {
        triggerId: action.payload
      });
    case SEARCH_FOR_ITEM:
      if (typeof action.payload !== "undefined") {
        return _extends$3({}, state2, {
          typeaheadQuery: action.payload
        });
      }
      return state2;
    default:
      return state2;
  }
}
__name(reducer$1, "reducer$1");
function useDropdownDescendants() {
  return useDescendants(DropdownDescendantContext);
}
__name(useDropdownDescendants, "useDropdownDescendants");
var reactIs = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = typeof Symbol === "function" && Symbol.for, c = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x = b ? Symbol.for("react.responder") : 60118, y = b ? Symbol.for("react.scope") : 60119;
function z(a2) {
  if (typeof a2 === "object" && a2 !== null) {
    var u2 = a2.$$typeof;
    switch (u2) {
      case c:
        switch (a2 = a2.type, a2) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k:
              case n:
              case t:
              case r:
              case h:
                return a2;
              default:
                return u2;
            }
        }
      case d:
        return u2;
    }
  }
}
__name(z, "z");
function A(a2) {
  return z(a2) === m;
}
__name(A, "A");
reactIs_production_min.AsyncMode = l;
reactIs_production_min.ConcurrentMode = m;
reactIs_production_min.ContextConsumer = k;
reactIs_production_min.ContextProvider = h;
reactIs_production_min.Element = c;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e;
reactIs_production_min.Lazy = t;
reactIs_production_min.Memo = r;
reactIs_production_min.Portal = d;
reactIs_production_min.Profiler = g;
reactIs_production_min.StrictMode = f;
reactIs_production_min.Suspense = p;
reactIs_production_min.isAsyncMode = function(a2) {
  return A(a2) || z(a2) === l;
};
reactIs_production_min.isConcurrentMode = A;
reactIs_production_min.isContextConsumer = function(a2) {
  return z(a2) === k;
};
reactIs_production_min.isContextProvider = function(a2) {
  return z(a2) === h;
};
reactIs_production_min.isElement = function(a2) {
  return typeof a2 === "object" && a2 !== null && a2.$$typeof === c;
};
reactIs_production_min.isForwardRef = function(a2) {
  return z(a2) === n;
};
reactIs_production_min.isFragment = function(a2) {
  return z(a2) === e;
};
reactIs_production_min.isLazy = function(a2) {
  return z(a2) === t;
};
reactIs_production_min.isMemo = function(a2) {
  return z(a2) === r;
};
reactIs_production_min.isPortal = function(a2) {
  return z(a2) === d;
};
reactIs_production_min.isProfiler = function(a2) {
  return z(a2) === g;
};
reactIs_production_min.isStrictMode = function(a2) {
  return z(a2) === f;
};
reactIs_production_min.isSuspense = function(a2) {
  return z(a2) === p;
};
reactIs_production_min.isValidElementType = function(a2) {
  return typeof a2 === "string" || typeof a2 === "function" || a2 === e || a2 === m || a2 === g || a2 === f || a2 === p || a2 === q || typeof a2 === "object" && a2 !== null && (a2.$$typeof === t || a2.$$typeof === r || a2.$$typeof === h || a2.$$typeof === k || a2.$$typeof === n || a2.$$typeof === w || a2.$$typeof === x || a2.$$typeof === y || a2.$$typeof === v);
};
reactIs_production_min.typeOf = z;
{
  reactIs.exports = reactIs_production_min;
}
function _extends$2() {
  _extends$2 = Object.assign || function(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends$2.apply(this, arguments);
}
__name(_extends$2, "_extends$2");
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
__name(_objectWithoutPropertiesLoose$2, "_objectWithoutPropertiesLoose$2");
var _excluded$2 = ["as", "id", "children"], _excluded2$2 = ["as"], _excluded3$2 = ["as"], _excluded4$2 = ["as"], _excluded5$1 = ["as"], _excluded7 = ["portal"], _excluded8 = ["as"];
var Menu$1 = /* @__PURE__ */ forwardRef(function(_ref2, forwardedRef) {
  var _ref$as = _ref2.as, Comp = _ref$as === void 0 ? Fragment$1 : _ref$as, id2 = _ref2.id, children = _ref2.children, rest = _objectWithoutPropertiesLoose$2(_ref2, _excluded$2);
  var parentIsFragment = useMemo(function() {
    try {
      return reactIs.exports.isFragment(/* @__PURE__ */ createElement(Comp, null));
    } catch (err) {
      return false;
    }
  }, [Comp]);
  var props2 = parentIsFragment ? {} : _extends$2({
    ref: forwardedRef,
    id: id2,
    "data-reach-menu": ""
  }, rest);
  return /* @__PURE__ */ createElement(Comp, props2, /* @__PURE__ */ createElement(DropdownProvider_, {
    id: id2,
    children
  }));
});
var MenuButton$1 = /* @__PURE__ */ forwardRef(function(_ref2, forwardedRef) {
  var _ref2$as = _ref2.as, Comp = _ref2$as === void 0 ? "button" : _ref2$as, rest = _objectWithoutPropertiesLoose$2(_ref2, _excluded2$2);
  var _useDropdownTrigger = useDropdownTrigger(_extends$2({}, rest, {
    ref: forwardedRef
  })), _useDropdownTrigger$d = _useDropdownTrigger.data, isExpanded = _useDropdownTrigger$d.isExpanded, controls = _useDropdownTrigger$d.controls, props2 = _useDropdownTrigger.props;
  return /* @__PURE__ */ createElement(Comp, _extends$2({
    "aria-expanded": isExpanded ? true : void 0,
    "aria-haspopup": true,
    "aria-controls": controls
  }, props2, {
    "data-reach-menu-button": ""
  }));
});
var MenuItemImpl = /* @__PURE__ */ forwardRef(function(_ref3, forwardedRef) {
  var _ref3$as = _ref3.as, Comp = _ref3$as === void 0 ? "div" : _ref3$as, rest = _objectWithoutPropertiesLoose$2(_ref3, _excluded3$2);
  var _useDropdownItem = useDropdownItem(_extends$2({}, rest, {
    ref: forwardedRef
  })), disabled = _useDropdownItem.data.disabled, props2 = _useDropdownItem.props;
  return /* @__PURE__ */ createElement(Comp, _extends$2({
    role: "menuitem"
  }, props2, {
    "aria-disabled": disabled || void 0,
    "data-reach-menu-item": ""
  }));
});
var MenuItem = /* @__PURE__ */ forwardRef(function(_ref4, forwardedRef) {
  var _ref4$as = _ref4.as, as = _ref4$as === void 0 ? "div" : _ref4$as, props2 = _objectWithoutPropertiesLoose$2(_ref4, _excluded4$2);
  return /* @__PURE__ */ createElement(MenuItemImpl, _extends$2({}, props2, {
    ref: forwardedRef,
    as
  }));
});
var MenuItems = /* @__PURE__ */ forwardRef(function(_ref5, forwardedRef) {
  var _ref5$as = _ref5.as, Comp = _ref5$as === void 0 ? "div" : _ref5$as, rest = _objectWithoutPropertiesLoose$2(_ref5, _excluded5$1);
  var _useDropdownItems = useDropdownItems(_extends$2({}, rest, {
    ref: forwardedRef
  })), _useDropdownItems$dat = _useDropdownItems.data, activeDescendant = _useDropdownItems$dat.activeDescendant, triggerId = _useDropdownItems$dat.triggerId, props2 = _useDropdownItems.props;
  return /* @__PURE__ */ createElement(Comp, _extends$2({
    "aria-activedescendant": activeDescendant,
    "aria-labelledby": triggerId || void 0,
    role: "menu"
  }, props2, {
    "data-reach-menu-items": ""
  }));
});
var MenuList = /* @__PURE__ */ forwardRef(function(_ref7, forwardedRef) {
  var _ref7$portal = _ref7.portal, portal = _ref7$portal === void 0 ? true : _ref7$portal, props2 = _objectWithoutPropertiesLoose$2(_ref7, _excluded7);
  return /* @__PURE__ */ createElement(MenuPopover, {
    portal
  }, /* @__PURE__ */ createElement(MenuItems, _extends$2({}, props2, {
    ref: forwardedRef,
    "data-reach-menu-list": ""
  })));
});
var MenuPopover = /* @__PURE__ */ forwardRef(function(_ref8, forwardedRef) {
  var _ref8$as = _ref8.as, Comp = _ref8$as === void 0 ? "div" : _ref8$as, rest = _objectWithoutPropertiesLoose$2(_ref8, _excluded8);
  var _useDropdownPopover = useDropdownPopover(_extends$2({}, rest, {
    ref: forwardedRef
  })), _useDropdownPopover$d = _useDropdownPopover.data, portal = _useDropdownPopover$d.portal, targetRef = _useDropdownPopover$d.targetRef, position = _useDropdownPopover$d.position, props2 = _useDropdownPopover.props;
  var sharedProps = {
    "data-reach-menu-popover": ""
  };
  return portal ? /* @__PURE__ */ createElement(Popover, _extends$2({}, props2, sharedProps, {
    as: Comp,
    targetRef,
    position,
    unstable_skipInitialPortalRender: true
  })) : /* @__PURE__ */ createElement(Comp, _extends$2({}, props2, sharedProps));
});
var dropdown = /* @__PURE__ */ (() => ":root{--reach-listbox: 1}[data-reach-listbox-popover]{display:block;position:absolute;min-width:-moz-fit-content;min-width:-webkit-min-content;min-width:min-content;padding:.25rem 0;background:hsl(0,0%,100%);outline:none;border:solid 1px hsla(0,0%,0%,.25)}[data-reach-listbox-popover]:focus-within{box-shadow:0 0 4px Highlight;outline:-webkit-focus-ring-color auto 4px}[data-reach-listbox-popover][hidden]{display:none}[data-reach-listbox-list]{margin:0;padding:0;list-style:none}[data-reach-listbox-list]:focus{box-shadow:none;outline:none}[data-reach-listbox-option]{display:block;margin:0;padding:.25rem .5rem;white-space:nowrap;user-select:none}[data-reach-listbox-option][data-current-nav]{background:hsl(211,81%,46%);color:#fff}[data-reach-listbox-option][data-current-selected]{font-weight:bolder}[data-reach-listbox-option][data-current-selected][data-confirming]{animation:flash .1s;animation-iteration-count:1}[data-reach-listbox-option][aria-disabled=true]{opacity:.5}[data-reach-listbox-button]{display:inline-flex;align-items:center;justify-content:space-between;padding:1px 10px 2px;border:1px solid;border-color:rgb(216,216,216) rgb(209,209,209) rgb(186,186,186);cursor:default;user-select:none}[data-reach-listbox-button][aria-disabled=true]{opacity:.5}[data-reach-listbox-arrow]{margin-left:.5rem;display:block;font-size:.5em}[data-reach-listbox-group-label]{display:block;margin:0;padding:.25rem .5rem;white-space:nowrap;user-select:none;font-weight:bolder}@keyframes flash{0%{background:hsla(211,81%,36%,1);color:#fff;opacity:1}50%{opacity:.5;background:inherit;color:inherit}to{background:hsla(211,81%,36%,1);color:#fff;opacity:1}}:root{--reach-menu-button: 1}[data-reach-menu]{position:relative}[data-reach-menu-popover]{display:block;position:absolute}[data-reach-menu-popover][hidden]{display:none}[data-reach-menu-list],[data-reach-menu-items]{display:block;white-space:nowrap;border:solid 1px hsla(0,0%,0%,.25);background:hsla(0,100%,100%,.99);outline:none;padding:1rem 0;font-size:85%}[data-reach-menu-item]{display:block;user-select:none}[data-reach-menu-item]{cursor:pointer;display:block;color:inherit;font:inherit;text-decoration:initial;padding:5px 20px}[data-reach-menu-item][data-selected]{background:hsl(211,81%,36%);color:#fff;outline:none}[data-reach-menu-item][aria-disabled]{opacity:.5;cursor:not-allowed}[data-reach-listbox-popover],[data-reach-menu-list]{background-color:hsl(var(--color-base));border:var(--popover-border);border-radius:var(--border-radius-8);box-shadow:var(--popover-box-shadow);font-size:inherit;max-width:250px;padding:var(--px-4)}[data-reach-listbox-option],[data-reach-menu-item]{border-radius:var(--border-radius-4);font-size:inherit;margin:var(--px-4);overflow:hidden;padding:var(--px-6) var(--px-8);text-overflow:ellipsis;white-space:nowrap}[data-reach-listbox-option][data-selected],[data-reach-menu-item][data-selected],[data-reach-listbox-option][data-current-nav],[data-reach-menu-item][data-current-nav],[data-reach-listbox-option]:hover,[data-reach-menu-item]:hover{background-color:hsla(var(--color-neutral),var(--alpha-background-light));color:inherit}[data-reach-listbox-option]:not(:first-child),[data-reach-menu-item]:not(:first-child){margin-top:0}[data-reach-listbox-button]{border:none;cursor:pointer;padding:0}\n")();
const MenuButton = forwardRef((props2, ref) => /* @__PURE__ */ jsx(MenuButton$1, __spreadProps(__spreadValues({}, props2), {
  ref,
  className: clsx("graphiql-un-styled", props2.className)
})));
MenuButton.displayName = "MenuButton";
const Menu = createComponentGroup(Menu$1, {
  Button: MenuButton,
  Item: MenuItem,
  List: MenuList
});
const ListboxButton2 = forwardRef((props2, ref) => /* @__PURE__ */ jsx(ListboxButton$1, __spreadProps(__spreadValues({}, props2), {
  ref,
  className: clsx("graphiql-un-styled", props2.className)
})));
ListboxButton2.displayName = "ListboxButton";
const Listbox2 = createComponentGroup(Listbox$1, {
  Button: ListboxButton2,
  Input: ListboxInput,
  Option: ListboxOption,
  Popover: ListboxPopover2
});
var utils$1 = {};
const Aacute = "\xC1";
const aacute = "\xE1";
const Abreve = "\u0102";
const abreve = "\u0103";
const ac = "\u223E";
const acd = "\u223F";
const acE = "\u223E\u0333";
const Acirc = "\xC2";
const acirc = "\xE2";
const acute = "\xB4";
const Acy = "\u0410";
const acy = "\u0430";
const AElig = "\xC6";
const aelig = "\xE6";
const af = "\u2061";
const Afr = "\u{1D504}";
const afr = "\u{1D51E}";
const Agrave = "\xC0";
const agrave = "\xE0";
const alefsym = "\u2135";
const aleph = "\u2135";
const Alpha = "\u0391";
const alpha = "\u03B1";
const Amacr = "\u0100";
const amacr = "\u0101";
const amalg = "\u2A3F";
const amp = "&";
const AMP = "&";
const andand = "\u2A55";
const And = "\u2A53";
const and = "\u2227";
const andd = "\u2A5C";
const andslope = "\u2A58";
const andv = "\u2A5A";
const ang = "\u2220";
const ange = "\u29A4";
const angle = "\u2220";
const angmsdaa = "\u29A8";
const angmsdab = "\u29A9";
const angmsdac = "\u29AA";
const angmsdad = "\u29AB";
const angmsdae = "\u29AC";
const angmsdaf = "\u29AD";
const angmsdag = "\u29AE";
const angmsdah = "\u29AF";
const angmsd = "\u2221";
const angrt = "\u221F";
const angrtvb = "\u22BE";
const angrtvbd = "\u299D";
const angsph = "\u2222";
const angst = "\xC5";
const angzarr = "\u237C";
const Aogon = "\u0104";
const aogon = "\u0105";
const Aopf = "\u{1D538}";
const aopf = "\u{1D552}";
const apacir = "\u2A6F";
const ap = "\u2248";
const apE = "\u2A70";
const ape = "\u224A";
const apid = "\u224B";
const apos = "'";
const ApplyFunction = "\u2061";
const approx = "\u2248";
const approxeq = "\u224A";
const Aring = "\xC5";
const aring = "\xE5";
const Ascr = "\u{1D49C}";
const ascr = "\u{1D4B6}";
const Assign = "\u2254";
const ast = "*";
const asymp = "\u2248";
const asympeq = "\u224D";
const Atilde = "\xC3";
const atilde = "\xE3";
const Auml = "\xC4";
const auml = "\xE4";
const awconint = "\u2233";
const awint = "\u2A11";
const backcong = "\u224C";
const backepsilon = "\u03F6";
const backprime = "\u2035";
const backsim = "\u223D";
const backsimeq = "\u22CD";
const Backslash = "\u2216";
const Barv = "\u2AE7";
const barvee = "\u22BD";
const barwed = "\u2305";
const Barwed = "\u2306";
const barwedge = "\u2305";
const bbrk = "\u23B5";
const bbrktbrk = "\u23B6";
const bcong = "\u224C";
const Bcy = "\u0411";
const bcy = "\u0431";
const bdquo = "\u201E";
const becaus = "\u2235";
const because = "\u2235";
const Because = "\u2235";
const bemptyv = "\u29B0";
const bepsi = "\u03F6";
const bernou = "\u212C";
const Bernoullis = "\u212C";
const Beta = "\u0392";
const beta = "\u03B2";
const beth = "\u2136";
const between = "\u226C";
const Bfr = "\u{1D505}";
const bfr = "\u{1D51F}";
const bigcap = "\u22C2";
const bigcirc = "\u25EF";
const bigcup = "\u22C3";
const bigodot = "\u2A00";
const bigoplus = "\u2A01";
const bigotimes = "\u2A02";
const bigsqcup = "\u2A06";
const bigstar = "\u2605";
const bigtriangledown = "\u25BD";
const bigtriangleup = "\u25B3";
const biguplus = "\u2A04";
const bigvee = "\u22C1";
const bigwedge = "\u22C0";
const bkarow = "\u290D";
const blacklozenge = "\u29EB";
const blacksquare = "\u25AA";
const blacktriangle = "\u25B4";
const blacktriangledown = "\u25BE";
const blacktriangleleft = "\u25C2";
const blacktriangleright = "\u25B8";
const blank = "\u2423";
const blk12 = "\u2592";
const blk14 = "\u2591";
const blk34 = "\u2593";
const block$1 = "\u2588";
const bne = "=\u20E5";
const bnequiv = "\u2261\u20E5";
const bNot = "\u2AED";
const bnot = "\u2310";
const Bopf = "\u{1D539}";
const bopf = "\u{1D553}";
const bot = "\u22A5";
const bottom = "\u22A5";
const bowtie = "\u22C8";
const boxbox = "\u29C9";
const boxdl = "\u2510";
const boxdL = "\u2555";
const boxDl = "\u2556";
const boxDL = "\u2557";
const boxdr = "\u250C";
const boxdR = "\u2552";
const boxDr = "\u2553";
const boxDR = "\u2554";
const boxh = "\u2500";
const boxH = "\u2550";
const boxhd = "\u252C";
const boxHd = "\u2564";
const boxhD = "\u2565";
const boxHD = "\u2566";
const boxhu = "\u2534";
const boxHu = "\u2567";
const boxhU = "\u2568";
const boxHU = "\u2569";
const boxminus = "\u229F";
const boxplus = "\u229E";
const boxtimes = "\u22A0";
const boxul = "\u2518";
const boxuL = "\u255B";
const boxUl = "\u255C";
const boxUL = "\u255D";
const boxur = "\u2514";
const boxuR = "\u2558";
const boxUr = "\u2559";
const boxUR = "\u255A";
const boxv = "\u2502";
const boxV = "\u2551";
const boxvh = "\u253C";
const boxvH = "\u256A";
const boxVh = "\u256B";
const boxVH = "\u256C";
const boxvl = "\u2524";
const boxvL = "\u2561";
const boxVl = "\u2562";
const boxVL = "\u2563";
const boxvr = "\u251C";
const boxvR = "\u255E";
const boxVr = "\u255F";
const boxVR = "\u2560";
const bprime = "\u2035";
const breve = "\u02D8";
const Breve = "\u02D8";
const brvbar = "\xA6";
const bscr = "\u{1D4B7}";
const Bscr = "\u212C";
const bsemi = "\u204F";
const bsim = "\u223D";
const bsime = "\u22CD";
const bsolb = "\u29C5";
const bsol = "\\";
const bsolhsub = "\u27C8";
const bull = "\u2022";
const bullet = "\u2022";
const bump = "\u224E";
const bumpE = "\u2AAE";
const bumpe = "\u224F";
const Bumpeq = "\u224E";
const bumpeq = "\u224F";
const Cacute = "\u0106";
const cacute = "\u0107";
const capand = "\u2A44";
const capbrcup = "\u2A49";
const capcap = "\u2A4B";
const cap = "\u2229";
const Cap = "\u22D2";
const capcup = "\u2A47";
const capdot = "\u2A40";
const CapitalDifferentialD = "\u2145";
const caps = "\u2229\uFE00";
const caret = "\u2041";
const caron = "\u02C7";
const Cayleys = "\u212D";
const ccaps = "\u2A4D";
const Ccaron = "\u010C";
const ccaron = "\u010D";
const Ccedil = "\xC7";
const ccedil = "\xE7";
const Ccirc = "\u0108";
const ccirc = "\u0109";
const Cconint = "\u2230";
const ccups = "\u2A4C";
const ccupssm = "\u2A50";
const Cdot = "\u010A";
const cdot = "\u010B";
const cedil = "\xB8";
const Cedilla = "\xB8";
const cemptyv = "\u29B2";
const cent = "\xA2";
const centerdot = "\xB7";
const CenterDot = "\xB7";
const cfr = "\u{1D520}";
const Cfr = "\u212D";
const CHcy = "\u0427";
const chcy = "\u0447";
const check = "\u2713";
const checkmark = "\u2713";
const Chi = "\u03A7";
const chi = "\u03C7";
const circ = "\u02C6";
const circeq = "\u2257";
const circlearrowleft = "\u21BA";
const circlearrowright = "\u21BB";
const circledast = "\u229B";
const circledcirc = "\u229A";
const circleddash = "\u229D";
const CircleDot = "\u2299";
const circledR = "\xAE";
const circledS = "\u24C8";
const CircleMinus = "\u2296";
const CirclePlus = "\u2295";
const CircleTimes = "\u2297";
const cir = "\u25CB";
const cirE = "\u29C3";
const cire = "\u2257";
const cirfnint = "\u2A10";
const cirmid = "\u2AEF";
const cirscir = "\u29C2";
const ClockwiseContourIntegral = "\u2232";
const CloseCurlyDoubleQuote = "\u201D";
const CloseCurlyQuote = "\u2019";
const clubs = "\u2663";
const clubsuit = "\u2663";
const colon = ":";
const Colon = "\u2237";
const Colone = "\u2A74";
const colone = "\u2254";
const coloneq = "\u2254";
const comma = ",";
const commat = "@";
const comp = "\u2201";
const compfn = "\u2218";
const complement = "\u2201";
const complexes = "\u2102";
const cong = "\u2245";
const congdot = "\u2A6D";
const Congruent = "\u2261";
const conint = "\u222E";
const Conint = "\u222F";
const ContourIntegral = "\u222E";
const copf = "\u{1D554}";
const Copf = "\u2102";
const coprod = "\u2210";
const Coproduct = "\u2210";
const copy$1 = "\xA9";
const COPY = "\xA9";
const copysr = "\u2117";
const CounterClockwiseContourIntegral = "\u2233";
const crarr = "\u21B5";
const cross = "\u2717";
const Cross = "\u2A2F";
const Cscr = "\u{1D49E}";
const cscr = "\u{1D4B8}";
const csub = "\u2ACF";
const csube = "\u2AD1";
const csup = "\u2AD0";
const csupe = "\u2AD2";
const ctdot = "\u22EF";
const cudarrl = "\u2938";
const cudarrr = "\u2935";
const cuepr = "\u22DE";
const cuesc = "\u22DF";
const cularr = "\u21B6";
const cularrp = "\u293D";
const cupbrcap = "\u2A48";
const cupcap = "\u2A46";
const CupCap = "\u224D";
const cup = "\u222A";
const Cup = "\u22D3";
const cupcup = "\u2A4A";
const cupdot = "\u228D";
const cupor = "\u2A45";
const cups = "\u222A\uFE00";
const curarr = "\u21B7";
const curarrm = "\u293C";
const curlyeqprec = "\u22DE";
const curlyeqsucc = "\u22DF";
const curlyvee = "\u22CE";
const curlywedge = "\u22CF";
const curren = "\xA4";
const curvearrowleft = "\u21B6";
const curvearrowright = "\u21B7";
const cuvee = "\u22CE";
const cuwed = "\u22CF";
const cwconint = "\u2232";
const cwint = "\u2231";
const cylcty = "\u232D";
const dagger = "\u2020";
const Dagger = "\u2021";
const daleth = "\u2138";
const darr = "\u2193";
const Darr = "\u21A1";
const dArr = "\u21D3";
const dash = "\u2010";
const Dashv = "\u2AE4";
const dashv = "\u22A3";
const dbkarow = "\u290F";
const dblac = "\u02DD";
const Dcaron = "\u010E";
const dcaron = "\u010F";
const Dcy = "\u0414";
const dcy = "\u0434";
const ddagger = "\u2021";
const ddarr = "\u21CA";
const DD = "\u2145";
const dd = "\u2146";
const DDotrahd = "\u2911";
const ddotseq = "\u2A77";
const deg = "\xB0";
const Del = "\u2207";
const Delta = "\u0394";
const delta = "\u03B4";
const demptyv = "\u29B1";
const dfisht = "\u297F";
const Dfr = "\u{1D507}";
const dfr = "\u{1D521}";
const dHar = "\u2965";
const dharl = "\u21C3";
const dharr = "\u21C2";
const DiacriticalAcute = "\xB4";
const DiacriticalDot = "\u02D9";
const DiacriticalDoubleAcute = "\u02DD";
const DiacriticalGrave = "`";
const DiacriticalTilde = "\u02DC";
const diam = "\u22C4";
const diamond = "\u22C4";
const Diamond = "\u22C4";
const diamondsuit = "\u2666";
const diams = "\u2666";
const die = "\xA8";
const DifferentialD = "\u2146";
const digamma = "\u03DD";
const disin = "\u22F2";
const div = "\xF7";
const divide = "\xF7";
const divideontimes = "\u22C7";
const divonx = "\u22C7";
const DJcy = "\u0402";
const djcy = "\u0452";
const dlcorn = "\u231E";
const dlcrop = "\u230D";
const dollar = "$";
const Dopf = "\u{1D53B}";
const dopf = "\u{1D555}";
const Dot = "\xA8";
const dot = "\u02D9";
const DotDot = "\u20DC";
const doteq = "\u2250";
const doteqdot = "\u2251";
const DotEqual = "\u2250";
const dotminus = "\u2238";
const dotplus = "\u2214";
const dotsquare = "\u22A1";
const doublebarwedge = "\u2306";
const DoubleContourIntegral = "\u222F";
const DoubleDot = "\xA8";
const DoubleDownArrow = "\u21D3";
const DoubleLeftArrow = "\u21D0";
const DoubleLeftRightArrow = "\u21D4";
const DoubleLeftTee = "\u2AE4";
const DoubleLongLeftArrow = "\u27F8";
const DoubleLongLeftRightArrow = "\u27FA";
const DoubleLongRightArrow = "\u27F9";
const DoubleRightArrow = "\u21D2";
const DoubleRightTee = "\u22A8";
const DoubleUpArrow = "\u21D1";
const DoubleUpDownArrow = "\u21D5";
const DoubleVerticalBar = "\u2225";
const DownArrowBar = "\u2913";
const downarrow = "\u2193";
const DownArrow = "\u2193";
const Downarrow = "\u21D3";
const DownArrowUpArrow = "\u21F5";
const DownBreve = "\u0311";
const downdownarrows = "\u21CA";
const downharpoonleft = "\u21C3";
const downharpoonright = "\u21C2";
const DownLeftRightVector = "\u2950";
const DownLeftTeeVector = "\u295E";
const DownLeftVectorBar = "\u2956";
const DownLeftVector = "\u21BD";
const DownRightTeeVector = "\u295F";
const DownRightVectorBar = "\u2957";
const DownRightVector = "\u21C1";
const DownTeeArrow = "\u21A7";
const DownTee = "\u22A4";
const drbkarow = "\u2910";
const drcorn = "\u231F";
const drcrop = "\u230C";
const Dscr = "\u{1D49F}";
const dscr = "\u{1D4B9}";
const DScy = "\u0405";
const dscy = "\u0455";
const dsol = "\u29F6";
const Dstrok = "\u0110";
const dstrok = "\u0111";
const dtdot = "\u22F1";
const dtri = "\u25BF";
const dtrif = "\u25BE";
const duarr = "\u21F5";
const duhar = "\u296F";
const dwangle = "\u29A6";
const DZcy = "\u040F";
const dzcy = "\u045F";
const dzigrarr = "\u27FF";
const Eacute = "\xC9";
const eacute = "\xE9";
const easter = "\u2A6E";
const Ecaron = "\u011A";
const ecaron = "\u011B";
const Ecirc = "\xCA";
const ecirc = "\xEA";
const ecir = "\u2256";
const ecolon = "\u2255";
const Ecy = "\u042D";
const ecy = "\u044D";
const eDDot = "\u2A77";
const Edot = "\u0116";
const edot = "\u0117";
const eDot = "\u2251";
const ee = "\u2147";
const efDot = "\u2252";
const Efr = "\u{1D508}";
const efr = "\u{1D522}";
const eg = "\u2A9A";
const Egrave = "\xC8";
const egrave = "\xE8";
const egs = "\u2A96";
const egsdot = "\u2A98";
const el = "\u2A99";
const Element$1 = "\u2208";
const elinters = "\u23E7";
const ell = "\u2113";
const els = "\u2A95";
const elsdot = "\u2A97";
const Emacr = "\u0112";
const emacr = "\u0113";
const empty = "\u2205";
const emptyset = "\u2205";
const EmptySmallSquare = "\u25FB";
const emptyv = "\u2205";
const EmptyVerySmallSquare = "\u25AB";
const emsp13 = "\u2004";
const emsp14 = "\u2005";
const emsp = "\u2003";
const ENG = "\u014A";
const eng = "\u014B";
const ensp = "\u2002";
const Eogon = "\u0118";
const eogon = "\u0119";
const Eopf = "\u{1D53C}";
const eopf = "\u{1D556}";
const epar = "\u22D5";
const eparsl = "\u29E3";
const eplus = "\u2A71";
const epsi = "\u03B5";
const Epsilon = "\u0395";
const epsilon = "\u03B5";
const epsiv = "\u03F5";
const eqcirc = "\u2256";
const eqcolon = "\u2255";
const eqsim = "\u2242";
const eqslantgtr = "\u2A96";
const eqslantless = "\u2A95";
const Equal = "\u2A75";
const equals = "=";
const EqualTilde = "\u2242";
const equest = "\u225F";
const Equilibrium = "\u21CC";
const equiv = "\u2261";
const equivDD = "\u2A78";
const eqvparsl = "\u29E5";
const erarr = "\u2971";
const erDot = "\u2253";
const escr = "\u212F";
const Escr = "\u2130";
const esdot = "\u2250";
const Esim = "\u2A73";
const esim = "\u2242";
const Eta = "\u0397";
const eta = "\u03B7";
const ETH = "\xD0";
const eth = "\xF0";
const Euml = "\xCB";
const euml = "\xEB";
const euro = "\u20AC";
const excl = "!";
const exist = "\u2203";
const Exists = "\u2203";
const expectation = "\u2130";
const exponentiale = "\u2147";
const ExponentialE = "\u2147";
const fallingdotseq = "\u2252";
const Fcy = "\u0424";
const fcy = "\u0444";
const female = "\u2640";
const ffilig = "\uFB03";
const fflig = "\uFB00";
const ffllig = "\uFB04";
const Ffr = "\u{1D509}";
const ffr = "\u{1D523}";
const filig = "\uFB01";
const FilledSmallSquare = "\u25FC";
const FilledVerySmallSquare = "\u25AA";
const fjlig = "fj";
const flat = "\u266D";
const fllig = "\uFB02";
const fltns = "\u25B1";
const fnof = "\u0192";
const Fopf = "\u{1D53D}";
const fopf = "\u{1D557}";
const forall = "\u2200";
const ForAll = "\u2200";
const fork = "\u22D4";
const forkv = "\u2AD9";
const Fouriertrf = "\u2131";
const fpartint = "\u2A0D";
const frac12 = "\xBD";
const frac13 = "\u2153";
const frac14 = "\xBC";
const frac15 = "\u2155";
const frac16 = "\u2159";
const frac18 = "\u215B";
const frac23 = "\u2154";
const frac25 = "\u2156";
const frac34 = "\xBE";
const frac35 = "\u2157";
const frac38 = "\u215C";
const frac45 = "\u2158";
const frac56 = "\u215A";
const frac58 = "\u215D";
const frac78 = "\u215E";
const frasl = "\u2044";
const frown = "\u2322";
const fscr = "\u{1D4BB}";
const Fscr = "\u2131";
const gacute = "\u01F5";
const Gamma = "\u0393";
const gamma = "\u03B3";
const Gammad = "\u03DC";
const gammad = "\u03DD";
const gap = "\u2A86";
const Gbreve = "\u011E";
const gbreve = "\u011F";
const Gcedil = "\u0122";
const Gcirc = "\u011C";
const gcirc = "\u011D";
const Gcy = "\u0413";
const gcy = "\u0433";
const Gdot = "\u0120";
const gdot = "\u0121";
const ge = "\u2265";
const gE = "\u2267";
const gEl = "\u2A8C";
const gel = "\u22DB";
const geq = "\u2265";
const geqq = "\u2267";
const geqslant = "\u2A7E";
const gescc = "\u2AA9";
const ges = "\u2A7E";
const gesdot = "\u2A80";
const gesdoto = "\u2A82";
const gesdotol = "\u2A84";
const gesl = "\u22DB\uFE00";
const gesles = "\u2A94";
const Gfr = "\u{1D50A}";
const gfr = "\u{1D524}";
const gg = "\u226B";
const Gg = "\u22D9";
const ggg = "\u22D9";
const gimel = "\u2137";
const GJcy = "\u0403";
const gjcy = "\u0453";
const gla = "\u2AA5";
const gl = "\u2277";
const glE = "\u2A92";
const glj = "\u2AA4";
const gnap = "\u2A8A";
const gnapprox = "\u2A8A";
const gne = "\u2A88";
const gnE = "\u2269";
const gneq = "\u2A88";
const gneqq = "\u2269";
const gnsim = "\u22E7";
const Gopf = "\u{1D53E}";
const gopf = "\u{1D558}";
const grave = "`";
const GreaterEqual = "\u2265";
const GreaterEqualLess = "\u22DB";
const GreaterFullEqual = "\u2267";
const GreaterGreater = "\u2AA2";
const GreaterLess = "\u2277";
const GreaterSlantEqual = "\u2A7E";
const GreaterTilde = "\u2273";
const Gscr = "\u{1D4A2}";
const gscr = "\u210A";
const gsim = "\u2273";
const gsime = "\u2A8E";
const gsiml = "\u2A90";
const gtcc = "\u2AA7";
const gtcir = "\u2A7A";
const gt = ">";
const GT = ">";
const Gt = "\u226B";
const gtdot = "\u22D7";
const gtlPar = "\u2995";
const gtquest = "\u2A7C";
const gtrapprox = "\u2A86";
const gtrarr = "\u2978";
const gtrdot = "\u22D7";
const gtreqless = "\u22DB";
const gtreqqless = "\u2A8C";
const gtrless = "\u2277";
const gtrsim = "\u2273";
const gvertneqq = "\u2269\uFE00";
const gvnE = "\u2269\uFE00";
const Hacek = "\u02C7";
const hairsp = "\u200A";
const half = "\xBD";
const hamilt = "\u210B";
const HARDcy = "\u042A";
const hardcy = "\u044A";
const harrcir = "\u2948";
const harr = "\u2194";
const hArr = "\u21D4";
const harrw = "\u21AD";
const Hat = "^";
const hbar = "\u210F";
const Hcirc = "\u0124";
const hcirc = "\u0125";
const hearts = "\u2665";
const heartsuit = "\u2665";
const hellip = "\u2026";
const hercon = "\u22B9";
const hfr = "\u{1D525}";
const Hfr = "\u210C";
const HilbertSpace = "\u210B";
const hksearow = "\u2925";
const hkswarow = "\u2926";
const hoarr = "\u21FF";
const homtht = "\u223B";
const hookleftarrow = "\u21A9";
const hookrightarrow = "\u21AA";
const hopf = "\u{1D559}";
const Hopf = "\u210D";
const horbar = "\u2015";
const HorizontalLine = "\u2500";
const hscr = "\u{1D4BD}";
const Hscr = "\u210B";
const hslash = "\u210F";
const Hstrok = "\u0126";
const hstrok = "\u0127";
const HumpDownHump = "\u224E";
const HumpEqual = "\u224F";
const hybull = "\u2043";
const hyphen = "\u2010";
const Iacute = "\xCD";
const iacute = "\xED";
const ic = "\u2063";
const Icirc = "\xCE";
const icirc = "\xEE";
const Icy = "\u0418";
const icy = "\u0438";
const Idot = "\u0130";
const IEcy = "\u0415";
const iecy = "\u0435";
const iexcl = "\xA1";
const iff = "\u21D4";
const ifr = "\u{1D526}";
const Ifr = "\u2111";
const Igrave = "\xCC";
const igrave = "\xEC";
const ii = "\u2148";
const iiiint = "\u2A0C";
const iiint = "\u222D";
const iinfin = "\u29DC";
const iiota = "\u2129";
const IJlig = "\u0132";
const ijlig = "\u0133";
const Imacr = "\u012A";
const imacr = "\u012B";
const image$1 = "\u2111";
const ImaginaryI = "\u2148";
const imagline = "\u2110";
const imagpart = "\u2111";
const imath = "\u0131";
const Im = "\u2111";
const imof = "\u22B7";
const imped = "\u01B5";
const Implies = "\u21D2";
const incare = "\u2105";
const infin = "\u221E";
const infintie = "\u29DD";
const inodot = "\u0131";
const intcal = "\u22BA";
const int = "\u222B";
const Int = "\u222C";
const integers = "\u2124";
const Integral = "\u222B";
const intercal = "\u22BA";
const Intersection = "\u22C2";
const intlarhk = "\u2A17";
const intprod = "\u2A3C";
const InvisibleComma = "\u2063";
const InvisibleTimes = "\u2062";
const IOcy = "\u0401";
const iocy = "\u0451";
const Iogon = "\u012E";
const iogon = "\u012F";
const Iopf = "\u{1D540}";
const iopf = "\u{1D55A}";
const Iota = "\u0399";
const iota = "\u03B9";
const iprod = "\u2A3C";
const iquest = "\xBF";
const iscr = "\u{1D4BE}";
const Iscr = "\u2110";
const isin = "\u2208";
const isindot = "\u22F5";
const isinE = "\u22F9";
const isins = "\u22F4";
const isinsv = "\u22F3";
const isinv = "\u2208";
const it = "\u2062";
const Itilde = "\u0128";
const itilde = "\u0129";
const Iukcy = "\u0406";
const iukcy = "\u0456";
const Iuml = "\xCF";
const iuml = "\xEF";
const Jcirc = "\u0134";
const jcirc = "\u0135";
const Jcy = "\u0419";
const jcy = "\u0439";
const Jfr = "\u{1D50D}";
const jfr = "\u{1D527}";
const jmath = "\u0237";
const Jopf = "\u{1D541}";
const jopf = "\u{1D55B}";
const Jscr = "\u{1D4A5}";
const jscr = "\u{1D4BF}";
const Jsercy = "\u0408";
const jsercy = "\u0458";
const Jukcy = "\u0404";
const jukcy = "\u0454";
const Kappa = "\u039A";
const kappa = "\u03BA";
const kappav = "\u03F0";
const Kcedil = "\u0136";
const kcedil = "\u0137";
const Kcy = "\u041A";
const kcy = "\u043A";
const Kfr = "\u{1D50E}";
const kfr = "\u{1D528}";
const kgreen = "\u0138";
const KHcy = "\u0425";
const khcy = "\u0445";
const KJcy = "\u040C";
const kjcy = "\u045C";
const Kopf = "\u{1D542}";
const kopf = "\u{1D55C}";
const Kscr = "\u{1D4A6}";
const kscr = "\u{1D4C0}";
const lAarr = "\u21DA";
const Lacute = "\u0139";
const lacute = "\u013A";
const laemptyv = "\u29B4";
const lagran = "\u2112";
const Lambda = "\u039B";
const lambda = "\u03BB";
const lang = "\u27E8";
const Lang = "\u27EA";
const langd = "\u2991";
const langle = "\u27E8";
const lap = "\u2A85";
const Laplacetrf = "\u2112";
const laquo = "\xAB";
const larrb = "\u21E4";
const larrbfs = "\u291F";
const larr = "\u2190";
const Larr = "\u219E";
const lArr = "\u21D0";
const larrfs = "\u291D";
const larrhk = "\u21A9";
const larrlp = "\u21AB";
const larrpl = "\u2939";
const larrsim = "\u2973";
const larrtl = "\u21A2";
const latail = "\u2919";
const lAtail = "\u291B";
const lat = "\u2AAB";
const late = "\u2AAD";
const lates = "\u2AAD\uFE00";
const lbarr = "\u290C";
const lBarr = "\u290E";
const lbbrk = "\u2772";
const lbrace = "{";
const lbrack = "[";
const lbrke = "\u298B";
const lbrksld = "\u298F";
const lbrkslu = "\u298D";
const Lcaron = "\u013D";
const lcaron = "\u013E";
const Lcedil = "\u013B";
const lcedil = "\u013C";
const lceil = "\u2308";
const lcub = "{";
const Lcy = "\u041B";
const lcy = "\u043B";
const ldca = "\u2936";
const ldquo = "\u201C";
const ldquor = "\u201E";
const ldrdhar = "\u2967";
const ldrushar = "\u294B";
const ldsh = "\u21B2";
const le = "\u2264";
const lE = "\u2266";
const LeftAngleBracket = "\u27E8";
const LeftArrowBar = "\u21E4";
const leftarrow = "\u2190";
const LeftArrow = "\u2190";
const Leftarrow = "\u21D0";
const LeftArrowRightArrow = "\u21C6";
const leftarrowtail = "\u21A2";
const LeftCeiling = "\u2308";
const LeftDoubleBracket = "\u27E6";
const LeftDownTeeVector = "\u2961";
const LeftDownVectorBar = "\u2959";
const LeftDownVector = "\u21C3";
const LeftFloor = "\u230A";
const leftharpoondown = "\u21BD";
const leftharpoonup = "\u21BC";
const leftleftarrows = "\u21C7";
const leftrightarrow = "\u2194";
const LeftRightArrow = "\u2194";
const Leftrightarrow = "\u21D4";
const leftrightarrows = "\u21C6";
const leftrightharpoons = "\u21CB";
const leftrightsquigarrow = "\u21AD";
const LeftRightVector = "\u294E";
const LeftTeeArrow = "\u21A4";
const LeftTee = "\u22A3";
const LeftTeeVector = "\u295A";
const leftthreetimes = "\u22CB";
const LeftTriangleBar = "\u29CF";
const LeftTriangle = "\u22B2";
const LeftTriangleEqual = "\u22B4";
const LeftUpDownVector = "\u2951";
const LeftUpTeeVector = "\u2960";
const LeftUpVectorBar = "\u2958";
const LeftUpVector = "\u21BF";
const LeftVectorBar = "\u2952";
const LeftVector = "\u21BC";
const lEg = "\u2A8B";
const leg = "\u22DA";
const leq = "\u2264";
const leqq = "\u2266";
const leqslant = "\u2A7D";
const lescc = "\u2AA8";
const les = "\u2A7D";
const lesdot = "\u2A7F";
const lesdoto = "\u2A81";
const lesdotor = "\u2A83";
const lesg = "\u22DA\uFE00";
const lesges = "\u2A93";
const lessapprox = "\u2A85";
const lessdot = "\u22D6";
const lesseqgtr = "\u22DA";
const lesseqqgtr = "\u2A8B";
const LessEqualGreater = "\u22DA";
const LessFullEqual = "\u2266";
const LessGreater = "\u2276";
const lessgtr = "\u2276";
const LessLess = "\u2AA1";
const lesssim = "\u2272";
const LessSlantEqual = "\u2A7D";
const LessTilde = "\u2272";
const lfisht = "\u297C";
const lfloor = "\u230A";
const Lfr = "\u{1D50F}";
const lfr = "\u{1D529}";
const lg = "\u2276";
const lgE = "\u2A91";
const lHar = "\u2962";
const lhard = "\u21BD";
const lharu = "\u21BC";
const lharul = "\u296A";
const lhblk = "\u2584";
const LJcy = "\u0409";
const ljcy = "\u0459";
const llarr = "\u21C7";
const ll = "\u226A";
const Ll = "\u22D8";
const llcorner = "\u231E";
const Lleftarrow = "\u21DA";
const llhard = "\u296B";
const lltri = "\u25FA";
const Lmidot = "\u013F";
const lmidot = "\u0140";
const lmoustache = "\u23B0";
const lmoust = "\u23B0";
const lnap = "\u2A89";
const lnapprox = "\u2A89";
const lne = "\u2A87";
const lnE = "\u2268";
const lneq = "\u2A87";
const lneqq = "\u2268";
const lnsim = "\u22E6";
const loang = "\u27EC";
const loarr = "\u21FD";
const lobrk = "\u27E6";
const longleftarrow = "\u27F5";
const LongLeftArrow = "\u27F5";
const Longleftarrow = "\u27F8";
const longleftrightarrow = "\u27F7";
const LongLeftRightArrow = "\u27F7";
const Longleftrightarrow = "\u27FA";
const longmapsto = "\u27FC";
const longrightarrow = "\u27F6";
const LongRightArrow = "\u27F6";
const Longrightarrow = "\u27F9";
const looparrowleft = "\u21AB";
const looparrowright = "\u21AC";
const lopar = "\u2985";
const Lopf = "\u{1D543}";
const lopf = "\u{1D55D}";
const loplus = "\u2A2D";
const lotimes = "\u2A34";
const lowast = "\u2217";
const lowbar = "_";
const LowerLeftArrow = "\u2199";
const LowerRightArrow = "\u2198";
const loz = "\u25CA";
const lozenge = "\u25CA";
const lozf = "\u29EB";
const lpar = "(";
const lparlt = "\u2993";
const lrarr = "\u21C6";
const lrcorner = "\u231F";
const lrhar = "\u21CB";
const lrhard = "\u296D";
const lrm = "\u200E";
const lrtri = "\u22BF";
const lsaquo = "\u2039";
const lscr = "\u{1D4C1}";
const Lscr = "\u2112";
const lsh = "\u21B0";
const Lsh = "\u21B0";
const lsim = "\u2272";
const lsime = "\u2A8D";
const lsimg = "\u2A8F";
const lsqb = "[";
const lsquo = "\u2018";
const lsquor = "\u201A";
const Lstrok = "\u0141";
const lstrok = "\u0142";
const ltcc = "\u2AA6";
const ltcir = "\u2A79";
const lt = "<";
const LT = "<";
const Lt = "\u226A";
const ltdot = "\u22D6";
const lthree = "\u22CB";
const ltimes = "\u22C9";
const ltlarr = "\u2976";
const ltquest = "\u2A7B";
const ltri = "\u25C3";
const ltrie = "\u22B4";
const ltrif = "\u25C2";
const ltrPar = "\u2996";
const lurdshar = "\u294A";
const luruhar = "\u2966";
const lvertneqq = "\u2268\uFE00";
const lvnE = "\u2268\uFE00";
const macr = "\xAF";
const male = "\u2642";
const malt = "\u2720";
const maltese = "\u2720";
const map$1 = "\u21A6";
const mapsto = "\u21A6";
const mapstodown = "\u21A7";
const mapstoleft = "\u21A4";
const mapstoup = "\u21A5";
const marker = "\u25AE";
const mcomma = "\u2A29";
const Mcy = "\u041C";
const mcy = "\u043C";
const mdash = "\u2014";
const mDDot = "\u223A";
const measuredangle = "\u2221";
const MediumSpace = "\u205F";
const Mellintrf = "\u2133";
const Mfr = "\u{1D510}";
const mfr = "\u{1D52A}";
const mho = "\u2127";
const micro = "\xB5";
const midast = "*";
const midcir = "\u2AF0";
const mid = "\u2223";
const middot = "\xB7";
const minusb = "\u229F";
const minus = "\u2212";
const minusd = "\u2238";
const minusdu = "\u2A2A";
const MinusPlus = "\u2213";
const mlcp = "\u2ADB";
const mldr = "\u2026";
const mnplus = "\u2213";
const models = "\u22A7";
const Mopf = "\u{1D544}";
const mopf = "\u{1D55E}";
const mp = "\u2213";
const mscr = "\u{1D4C2}";
const Mscr = "\u2133";
const mstpos = "\u223E";
const Mu = "\u039C";
const mu = "\u03BC";
const multimap = "\u22B8";
const mumap = "\u22B8";
const nabla = "\u2207";
const Nacute = "\u0143";
const nacute = "\u0144";
const nang = "\u2220\u20D2";
const nap = "\u2249";
const napE = "\u2A70\u0338";
const napid = "\u224B\u0338";
const napos = "\u0149";
const napprox = "\u2249";
const natural = "\u266E";
const naturals = "\u2115";
const natur = "\u266E";
const nbsp = "\xA0";
const nbump = "\u224E\u0338";
const nbumpe = "\u224F\u0338";
const ncap = "\u2A43";
const Ncaron = "\u0147";
const ncaron = "\u0148";
const Ncedil = "\u0145";
const ncedil = "\u0146";
const ncong = "\u2247";
const ncongdot = "\u2A6D\u0338";
const ncup = "\u2A42";
const Ncy = "\u041D";
const ncy = "\u043D";
const ndash = "\u2013";
const nearhk = "\u2924";
const nearr = "\u2197";
const neArr = "\u21D7";
const nearrow = "\u2197";
const ne = "\u2260";
const nedot = "\u2250\u0338";
const NegativeMediumSpace = "\u200B";
const NegativeThickSpace = "\u200B";
const NegativeThinSpace = "\u200B";
const NegativeVeryThinSpace = "\u200B";
const nequiv = "\u2262";
const nesear = "\u2928";
const nesim = "\u2242\u0338";
const NestedGreaterGreater = "\u226B";
const NestedLessLess = "\u226A";
const NewLine = "\n";
const nexist = "\u2204";
const nexists = "\u2204";
const Nfr = "\u{1D511}";
const nfr = "\u{1D52B}";
const ngE = "\u2267\u0338";
const nge = "\u2271";
const ngeq = "\u2271";
const ngeqq = "\u2267\u0338";
const ngeqslant = "\u2A7E\u0338";
const nges = "\u2A7E\u0338";
const nGg = "\u22D9\u0338";
const ngsim = "\u2275";
const nGt = "\u226B\u20D2";
const ngt = "\u226F";
const ngtr = "\u226F";
const nGtv = "\u226B\u0338";
const nharr = "\u21AE";
const nhArr = "\u21CE";
const nhpar = "\u2AF2";
const ni = "\u220B";
const nis = "\u22FC";
const nisd = "\u22FA";
const niv = "\u220B";
const NJcy = "\u040A";
const njcy = "\u045A";
const nlarr = "\u219A";
const nlArr = "\u21CD";
const nldr = "\u2025";
const nlE = "\u2266\u0338";
const nle = "\u2270";
const nleftarrow = "\u219A";
const nLeftarrow = "\u21CD";
const nleftrightarrow = "\u21AE";
const nLeftrightarrow = "\u21CE";
const nleq = "\u2270";
const nleqq = "\u2266\u0338";
const nleqslant = "\u2A7D\u0338";
const nles = "\u2A7D\u0338";
const nless = "\u226E";
const nLl = "\u22D8\u0338";
const nlsim = "\u2274";
const nLt = "\u226A\u20D2";
const nlt = "\u226E";
const nltri = "\u22EA";
const nltrie = "\u22EC";
const nLtv = "\u226A\u0338";
const nmid = "\u2224";
const NoBreak = "\u2060";
const NonBreakingSpace = "\xA0";
const nopf = "\u{1D55F}";
const Nopf = "\u2115";
const Not = "\u2AEC";
const not = "\xAC";
const NotCongruent = "\u2262";
const NotCupCap = "\u226D";
const NotDoubleVerticalBar = "\u2226";
const NotElement = "\u2209";
const NotEqual = "\u2260";
const NotEqualTilde = "\u2242\u0338";
const NotExists = "\u2204";
const NotGreater = "\u226F";
const NotGreaterEqual = "\u2271";
const NotGreaterFullEqual = "\u2267\u0338";
const NotGreaterGreater = "\u226B\u0338";
const NotGreaterLess = "\u2279";
const NotGreaterSlantEqual = "\u2A7E\u0338";
const NotGreaterTilde = "\u2275";
const NotHumpDownHump = "\u224E\u0338";
const NotHumpEqual = "\u224F\u0338";
const notin = "\u2209";
const notindot = "\u22F5\u0338";
const notinE = "\u22F9\u0338";
const notinva = "\u2209";
const notinvb = "\u22F7";
const notinvc = "\u22F6";
const NotLeftTriangleBar = "\u29CF\u0338";
const NotLeftTriangle = "\u22EA";
const NotLeftTriangleEqual = "\u22EC";
const NotLess = "\u226E";
const NotLessEqual = "\u2270";
const NotLessGreater = "\u2278";
const NotLessLess = "\u226A\u0338";
const NotLessSlantEqual = "\u2A7D\u0338";
const NotLessTilde = "\u2274";
const NotNestedGreaterGreater = "\u2AA2\u0338";
const NotNestedLessLess = "\u2AA1\u0338";
const notni = "\u220C";
const notniva = "\u220C";
const notnivb = "\u22FE";
const notnivc = "\u22FD";
const NotPrecedes = "\u2280";
const NotPrecedesEqual = "\u2AAF\u0338";
const NotPrecedesSlantEqual = "\u22E0";
const NotReverseElement = "\u220C";
const NotRightTriangleBar = "\u29D0\u0338";
const NotRightTriangle = "\u22EB";
const NotRightTriangleEqual = "\u22ED";
const NotSquareSubset = "\u228F\u0338";
const NotSquareSubsetEqual = "\u22E2";
const NotSquareSuperset = "\u2290\u0338";
const NotSquareSupersetEqual = "\u22E3";
const NotSubset = "\u2282\u20D2";
const NotSubsetEqual = "\u2288";
const NotSucceeds = "\u2281";
const NotSucceedsEqual = "\u2AB0\u0338";
const NotSucceedsSlantEqual = "\u22E1";
const NotSucceedsTilde = "\u227F\u0338";
const NotSuperset = "\u2283\u20D2";
const NotSupersetEqual = "\u2289";
const NotTilde = "\u2241";
const NotTildeEqual = "\u2244";
const NotTildeFullEqual = "\u2247";
const NotTildeTilde = "\u2249";
const NotVerticalBar = "\u2224";
const nparallel = "\u2226";
const npar = "\u2226";
const nparsl = "\u2AFD\u20E5";
const npart = "\u2202\u0338";
const npolint = "\u2A14";
const npr = "\u2280";
const nprcue = "\u22E0";
const nprec = "\u2280";
const npreceq = "\u2AAF\u0338";
const npre = "\u2AAF\u0338";
const nrarrc = "\u2933\u0338";
const nrarr = "\u219B";
const nrArr = "\u21CF";
const nrarrw = "\u219D\u0338";
const nrightarrow = "\u219B";
const nRightarrow = "\u21CF";
const nrtri = "\u22EB";
const nrtrie = "\u22ED";
const nsc = "\u2281";
const nsccue = "\u22E1";
const nsce = "\u2AB0\u0338";
const Nscr = "\u{1D4A9}";
const nscr = "\u{1D4C3}";
const nshortmid = "\u2224";
const nshortparallel = "\u2226";
const nsim = "\u2241";
const nsime = "\u2244";
const nsimeq = "\u2244";
const nsmid = "\u2224";
const nspar = "\u2226";
const nsqsube = "\u22E2";
const nsqsupe = "\u22E3";
const nsub = "\u2284";
const nsubE = "\u2AC5\u0338";
const nsube = "\u2288";
const nsubset = "\u2282\u20D2";
const nsubseteq = "\u2288";
const nsubseteqq = "\u2AC5\u0338";
const nsucc = "\u2281";
const nsucceq = "\u2AB0\u0338";
const nsup = "\u2285";
const nsupE = "\u2AC6\u0338";
const nsupe = "\u2289";
const nsupset = "\u2283\u20D2";
const nsupseteq = "\u2289";
const nsupseteqq = "\u2AC6\u0338";
const ntgl = "\u2279";
const Ntilde = "\xD1";
const ntilde = "\xF1";
const ntlg = "\u2278";
const ntriangleleft = "\u22EA";
const ntrianglelefteq = "\u22EC";
const ntriangleright = "\u22EB";
const ntrianglerighteq = "\u22ED";
const Nu = "\u039D";
const nu = "\u03BD";
const num = "#";
const numero = "\u2116";
const numsp = "\u2007";
const nvap = "\u224D\u20D2";
const nvdash = "\u22AC";
const nvDash = "\u22AD";
const nVdash = "\u22AE";
const nVDash = "\u22AF";
const nvge = "\u2265\u20D2";
const nvgt = ">\u20D2";
const nvHarr = "\u2904";
const nvinfin = "\u29DE";
const nvlArr = "\u2902";
const nvle = "\u2264\u20D2";
const nvlt = "<\u20D2";
const nvltrie = "\u22B4\u20D2";
const nvrArr = "\u2903";
const nvrtrie = "\u22B5\u20D2";
const nvsim = "\u223C\u20D2";
const nwarhk = "\u2923";
const nwarr = "\u2196";
const nwArr = "\u21D6";
const nwarrow = "\u2196";
const nwnear = "\u2927";
const Oacute = "\xD3";
const oacute = "\xF3";
const oast = "\u229B";
const Ocirc = "\xD4";
const ocirc = "\xF4";
const ocir = "\u229A";
const Ocy = "\u041E";
const ocy = "\u043E";
const odash = "\u229D";
const Odblac = "\u0150";
const odblac = "\u0151";
const odiv = "\u2A38";
const odot = "\u2299";
const odsold = "\u29BC";
const OElig = "\u0152";
const oelig = "\u0153";
const ofcir = "\u29BF";
const Ofr = "\u{1D512}";
const ofr = "\u{1D52C}";
const ogon = "\u02DB";
const Ograve = "\xD2";
const ograve = "\xF2";
const ogt = "\u29C1";
const ohbar = "\u29B5";
const ohm = "\u03A9";
const oint = "\u222E";
const olarr = "\u21BA";
const olcir = "\u29BE";
const olcross = "\u29BB";
const oline = "\u203E";
const olt = "\u29C0";
const Omacr = "\u014C";
const omacr = "\u014D";
const Omega = "\u03A9";
const omega = "\u03C9";
const Omicron = "\u039F";
const omicron = "\u03BF";
const omid = "\u29B6";
const ominus = "\u2296";
const Oopf = "\u{1D546}";
const oopf = "\u{1D560}";
const opar = "\u29B7";
const OpenCurlyDoubleQuote = "\u201C";
const OpenCurlyQuote = "\u2018";
const operp = "\u29B9";
const oplus = "\u2295";
const orarr = "\u21BB";
const Or = "\u2A54";
const or = "\u2228";
const ord = "\u2A5D";
const order = "\u2134";
const orderof = "\u2134";
const ordf = "\xAA";
const ordm = "\xBA";
const origof = "\u22B6";
const oror = "\u2A56";
const orslope = "\u2A57";
const orv = "\u2A5B";
const oS = "\u24C8";
const Oscr = "\u{1D4AA}";
const oscr = "\u2134";
const Oslash = "\xD8";
const oslash = "\xF8";
const osol = "\u2298";
const Otilde = "\xD5";
const otilde = "\xF5";
const otimesas = "\u2A36";
const Otimes = "\u2A37";
const otimes = "\u2297";
const Ouml = "\xD6";
const ouml = "\xF6";
const ovbar = "\u233D";
const OverBar = "\u203E";
const OverBrace = "\u23DE";
const OverBracket = "\u23B4";
const OverParenthesis = "\u23DC";
const para = "\xB6";
const parallel = "\u2225";
const par = "\u2225";
const parsim = "\u2AF3";
const parsl = "\u2AFD";
const part = "\u2202";
const PartialD = "\u2202";
const Pcy = "\u041F";
const pcy = "\u043F";
const percnt = "%";
const period = ".";
const permil = "\u2030";
const perp = "\u22A5";
const pertenk = "\u2031";
const Pfr = "\u{1D513}";
const pfr = "\u{1D52D}";
const Phi = "\u03A6";
const phi = "\u03C6";
const phiv = "\u03D5";
const phmmat = "\u2133";
const phone = "\u260E";
const Pi = "\u03A0";
const pi = "\u03C0";
const pitchfork = "\u22D4";
const piv = "\u03D6";
const planck = "\u210F";
const planckh = "\u210E";
const plankv = "\u210F";
const plusacir = "\u2A23";
const plusb = "\u229E";
const pluscir = "\u2A22";
const plus = "+";
const plusdo = "\u2214";
const plusdu = "\u2A25";
const pluse = "\u2A72";
const PlusMinus = "\xB1";
const plusmn = "\xB1";
const plussim = "\u2A26";
const plustwo = "\u2A27";
const pm = "\xB1";
const Poincareplane = "\u210C";
const pointint = "\u2A15";
const popf = "\u{1D561}";
const Popf = "\u2119";
const pound = "\xA3";
const prap = "\u2AB7";
const Pr = "\u2ABB";
const pr = "\u227A";
const prcue = "\u227C";
const precapprox = "\u2AB7";
const prec = "\u227A";
const preccurlyeq = "\u227C";
const Precedes = "\u227A";
const PrecedesEqual = "\u2AAF";
const PrecedesSlantEqual = "\u227C";
const PrecedesTilde = "\u227E";
const preceq = "\u2AAF";
const precnapprox = "\u2AB9";
const precneqq = "\u2AB5";
const precnsim = "\u22E8";
const pre = "\u2AAF";
const prE = "\u2AB3";
const precsim = "\u227E";
const prime = "\u2032";
const Prime = "\u2033";
const primes = "\u2119";
const prnap = "\u2AB9";
const prnE = "\u2AB5";
const prnsim = "\u22E8";
const prod = "\u220F";
const Product = "\u220F";
const profalar = "\u232E";
const profline = "\u2312";
const profsurf = "\u2313";
const prop = "\u221D";
const Proportional = "\u221D";
const Proportion = "\u2237";
const propto = "\u221D";
const prsim = "\u227E";
const prurel = "\u22B0";
const Pscr = "\u{1D4AB}";
const pscr = "\u{1D4C5}";
const Psi = "\u03A8";
const psi = "\u03C8";
const puncsp = "\u2008";
const Qfr = "\u{1D514}";
const qfr = "\u{1D52E}";
const qint = "\u2A0C";
const qopf = "\u{1D562}";
const Qopf = "\u211A";
const qprime = "\u2057";
const Qscr = "\u{1D4AC}";
const qscr = "\u{1D4C6}";
const quaternions = "\u210D";
const quatint = "\u2A16";
const quest = "?";
const questeq = "\u225F";
const quot = '"';
const QUOT = '"';
const rAarr = "\u21DB";
const race = "\u223D\u0331";
const Racute = "\u0154";
const racute = "\u0155";
const radic = "\u221A";
const raemptyv = "\u29B3";
const rang = "\u27E9";
const Rang = "\u27EB";
const rangd = "\u2992";
const range = "\u29A5";
const rangle = "\u27E9";
const raquo = "\xBB";
const rarrap = "\u2975";
const rarrb = "\u21E5";
const rarrbfs = "\u2920";
const rarrc = "\u2933";
const rarr = "\u2192";
const Rarr = "\u21A0";
const rArr = "\u21D2";
const rarrfs = "\u291E";
const rarrhk = "\u21AA";
const rarrlp = "\u21AC";
const rarrpl = "\u2945";
const rarrsim = "\u2974";
const Rarrtl = "\u2916";
const rarrtl = "\u21A3";
const rarrw = "\u219D";
const ratail = "\u291A";
const rAtail = "\u291C";
const ratio = "\u2236";
const rationals = "\u211A";
const rbarr = "\u290D";
const rBarr = "\u290F";
const RBarr = "\u2910";
const rbbrk = "\u2773";
const rbrace = "}";
const rbrack = "]";
const rbrke = "\u298C";
const rbrksld = "\u298E";
const rbrkslu = "\u2990";
const Rcaron = "\u0158";
const rcaron = "\u0159";
const Rcedil = "\u0156";
const rcedil = "\u0157";
const rceil = "\u2309";
const rcub = "}";
const Rcy = "\u0420";
const rcy = "\u0440";
const rdca = "\u2937";
const rdldhar = "\u2969";
const rdquo = "\u201D";
const rdquor = "\u201D";
const rdsh = "\u21B3";
const real = "\u211C";
const realine = "\u211B";
const realpart = "\u211C";
const reals = "\u211D";
const Re = "\u211C";
const rect = "\u25AD";
const reg = "\xAE";
const REG = "\xAE";
const ReverseElement = "\u220B";
const ReverseEquilibrium = "\u21CB";
const ReverseUpEquilibrium = "\u296F";
const rfisht = "\u297D";
const rfloor = "\u230B";
const rfr = "\u{1D52F}";
const Rfr = "\u211C";
const rHar = "\u2964";
const rhard = "\u21C1";
const rharu = "\u21C0";
const rharul = "\u296C";
const Rho = "\u03A1";
const rho = "\u03C1";
const rhov = "\u03F1";
const RightAngleBracket = "\u27E9";
const RightArrowBar = "\u21E5";
const rightarrow = "\u2192";
const RightArrow = "\u2192";
const Rightarrow = "\u21D2";
const RightArrowLeftArrow = "\u21C4";
const rightarrowtail = "\u21A3";
const RightCeiling = "\u2309";
const RightDoubleBracket = "\u27E7";
const RightDownTeeVector = "\u295D";
const RightDownVectorBar = "\u2955";
const RightDownVector = "\u21C2";
const RightFloor = "\u230B";
const rightharpoondown = "\u21C1";
const rightharpoonup = "\u21C0";
const rightleftarrows = "\u21C4";
const rightleftharpoons = "\u21CC";
const rightrightarrows = "\u21C9";
const rightsquigarrow = "\u219D";
const RightTeeArrow = "\u21A6";
const RightTee = "\u22A2";
const RightTeeVector = "\u295B";
const rightthreetimes = "\u22CC";
const RightTriangleBar = "\u29D0";
const RightTriangle = "\u22B3";
const RightTriangleEqual = "\u22B5";
const RightUpDownVector = "\u294F";
const RightUpTeeVector = "\u295C";
const RightUpVectorBar = "\u2954";
const RightUpVector = "\u21BE";
const RightVectorBar = "\u2953";
const RightVector = "\u21C0";
const ring = "\u02DA";
const risingdotseq = "\u2253";
const rlarr = "\u21C4";
const rlhar = "\u21CC";
const rlm = "\u200F";
const rmoustache = "\u23B1";
const rmoust = "\u23B1";
const rnmid = "\u2AEE";
const roang = "\u27ED";
const roarr = "\u21FE";
const robrk = "\u27E7";
const ropar = "\u2986";
const ropf = "\u{1D563}";
const Ropf = "\u211D";
const roplus = "\u2A2E";
const rotimes = "\u2A35";
const RoundImplies = "\u2970";
const rpar = ")";
const rpargt = "\u2994";
const rppolint = "\u2A12";
const rrarr = "\u21C9";
const Rrightarrow = "\u21DB";
const rsaquo = "\u203A";
const rscr = "\u{1D4C7}";
const Rscr = "\u211B";
const rsh = "\u21B1";
const Rsh = "\u21B1";
const rsqb = "]";
const rsquo = "\u2019";
const rsquor = "\u2019";
const rthree = "\u22CC";
const rtimes = "\u22CA";
const rtri = "\u25B9";
const rtrie = "\u22B5";
const rtrif = "\u25B8";
const rtriltri = "\u29CE";
const RuleDelayed = "\u29F4";
const ruluhar = "\u2968";
const rx = "\u211E";
const Sacute = "\u015A";
const sacute = "\u015B";
const sbquo = "\u201A";
const scap = "\u2AB8";
const Scaron = "\u0160";
const scaron = "\u0161";
const Sc = "\u2ABC";
const sc = "\u227B";
const sccue = "\u227D";
const sce = "\u2AB0";
const scE = "\u2AB4";
const Scedil = "\u015E";
const scedil = "\u015F";
const Scirc = "\u015C";
const scirc = "\u015D";
const scnap = "\u2ABA";
const scnE = "\u2AB6";
const scnsim = "\u22E9";
const scpolint = "\u2A13";
const scsim = "\u227F";
const Scy = "\u0421";
const scy = "\u0441";
const sdotb = "\u22A1";
const sdot = "\u22C5";
const sdote = "\u2A66";
const searhk = "\u2925";
const searr = "\u2198";
const seArr = "\u21D8";
const searrow = "\u2198";
const sect = "\xA7";
const semi = ";";
const seswar = "\u2929";
const setminus = "\u2216";
const setmn = "\u2216";
const sext = "\u2736";
const Sfr = "\u{1D516}";
const sfr = "\u{1D530}";
const sfrown = "\u2322";
const sharp = "\u266F";
const SHCHcy = "\u0429";
const shchcy = "\u0449";
const SHcy = "\u0428";
const shcy = "\u0448";
const ShortDownArrow = "\u2193";
const ShortLeftArrow = "\u2190";
const shortmid = "\u2223";
const shortparallel = "\u2225";
const ShortRightArrow = "\u2192";
const ShortUpArrow = "\u2191";
const shy = "\xAD";
const Sigma = "\u03A3";
const sigma = "\u03C3";
const sigmaf = "\u03C2";
const sigmav = "\u03C2";
const sim = "\u223C";
const simdot = "\u2A6A";
const sime = "\u2243";
const simeq = "\u2243";
const simg = "\u2A9E";
const simgE = "\u2AA0";
const siml = "\u2A9D";
const simlE = "\u2A9F";
const simne = "\u2246";
const simplus = "\u2A24";
const simrarr = "\u2972";
const slarr = "\u2190";
const SmallCircle = "\u2218";
const smallsetminus = "\u2216";
const smashp = "\u2A33";
const smeparsl = "\u29E4";
const smid = "\u2223";
const smile = "\u2323";
const smt = "\u2AAA";
const smte = "\u2AAC";
const smtes = "\u2AAC\uFE00";
const SOFTcy = "\u042C";
const softcy = "\u044C";
const solbar = "\u233F";
const solb = "\u29C4";
const sol = "/";
const Sopf = "\u{1D54A}";
const sopf = "\u{1D564}";
const spades = "\u2660";
const spadesuit = "\u2660";
const spar = "\u2225";
const sqcap = "\u2293";
const sqcaps = "\u2293\uFE00";
const sqcup = "\u2294";
const sqcups = "\u2294\uFE00";
const Sqrt = "\u221A";
const sqsub = "\u228F";
const sqsube = "\u2291";
const sqsubset = "\u228F";
const sqsubseteq = "\u2291";
const sqsup = "\u2290";
const sqsupe = "\u2292";
const sqsupset = "\u2290";
const sqsupseteq = "\u2292";
const square = "\u25A1";
const Square = "\u25A1";
const SquareIntersection = "\u2293";
const SquareSubset = "\u228F";
const SquareSubsetEqual = "\u2291";
const SquareSuperset = "\u2290";
const SquareSupersetEqual = "\u2292";
const SquareUnion = "\u2294";
const squarf = "\u25AA";
const squ = "\u25A1";
const squf = "\u25AA";
const srarr = "\u2192";
const Sscr = "\u{1D4AE}";
const sscr = "\u{1D4C8}";
const ssetmn = "\u2216";
const ssmile = "\u2323";
const sstarf = "\u22C6";
const Star = "\u22C6";
const star = "\u2606";
const starf = "\u2605";
const straightepsilon = "\u03F5";
const straightphi = "\u03D5";
const strns = "\xAF";
const sub = "\u2282";
const Sub = "\u22D0";
const subdot = "\u2ABD";
const subE = "\u2AC5";
const sube = "\u2286";
const subedot = "\u2AC3";
const submult = "\u2AC1";
const subnE = "\u2ACB";
const subne = "\u228A";
const subplus = "\u2ABF";
const subrarr = "\u2979";
const subset = "\u2282";
const Subset = "\u22D0";
const subseteq = "\u2286";
const subseteqq = "\u2AC5";
const SubsetEqual = "\u2286";
const subsetneq = "\u228A";
const subsetneqq = "\u2ACB";
const subsim = "\u2AC7";
const subsub = "\u2AD5";
const subsup = "\u2AD3";
const succapprox = "\u2AB8";
const succ = "\u227B";
const succcurlyeq = "\u227D";
const Succeeds = "\u227B";
const SucceedsEqual = "\u2AB0";
const SucceedsSlantEqual = "\u227D";
const SucceedsTilde = "\u227F";
const succeq = "\u2AB0";
const succnapprox = "\u2ABA";
const succneqq = "\u2AB6";
const succnsim = "\u22E9";
const succsim = "\u227F";
const SuchThat = "\u220B";
const sum = "\u2211";
const Sum = "\u2211";
const sung = "\u266A";
const sup1 = "\xB9";
const sup2 = "\xB2";
const sup3 = "\xB3";
const sup = "\u2283";
const Sup = "\u22D1";
const supdot = "\u2ABE";
const supdsub = "\u2AD8";
const supE = "\u2AC6";
const supe = "\u2287";
const supedot = "\u2AC4";
const Superset = "\u2283";
const SupersetEqual = "\u2287";
const suphsol = "\u27C9";
const suphsub = "\u2AD7";
const suplarr = "\u297B";
const supmult = "\u2AC2";
const supnE = "\u2ACC";
const supne = "\u228B";
const supplus = "\u2AC0";
const supset = "\u2283";
const Supset = "\u22D1";
const supseteq = "\u2287";
const supseteqq = "\u2AC6";
const supsetneq = "\u228B";
const supsetneqq = "\u2ACC";
const supsim = "\u2AC8";
const supsub = "\u2AD4";
const supsup = "\u2AD6";
const swarhk = "\u2926";
const swarr = "\u2199";
const swArr = "\u21D9";
const swarrow = "\u2199";
const swnwar = "\u292A";
const szlig = "\xDF";
const Tab$1 = "	";
const target = "\u2316";
const Tau = "\u03A4";
const tau = "\u03C4";
const tbrk = "\u23B4";
const Tcaron = "\u0164";
const tcaron = "\u0165";
const Tcedil = "\u0162";
const tcedil = "\u0163";
const Tcy = "\u0422";
const tcy = "\u0442";
const tdot = "\u20DB";
const telrec = "\u2315";
const Tfr = "\u{1D517}";
const tfr = "\u{1D531}";
const there4 = "\u2234";
const therefore = "\u2234";
const Therefore = "\u2234";
const Theta = "\u0398";
const theta = "\u03B8";
const thetasym = "\u03D1";
const thetav = "\u03D1";
const thickapprox = "\u2248";
const thicksim = "\u223C";
const ThickSpace = "\u205F\u200A";
const ThinSpace = "\u2009";
const thinsp = "\u2009";
const thkap = "\u2248";
const thksim = "\u223C";
const THORN = "\xDE";
const thorn = "\xFE";
const tilde = "\u02DC";
const Tilde = "\u223C";
const TildeEqual = "\u2243";
const TildeFullEqual = "\u2245";
const TildeTilde = "\u2248";
const timesbar = "\u2A31";
const timesb = "\u22A0";
const times = "\xD7";
const timesd = "\u2A30";
const tint = "\u222D";
const toea = "\u2928";
const topbot = "\u2336";
const topcir = "\u2AF1";
const top = "\u22A4";
const Topf = "\u{1D54B}";
const topf = "\u{1D565}";
const topfork = "\u2ADA";
const tosa = "\u2929";
const tprime = "\u2034";
const trade = "\u2122";
const TRADE = "\u2122";
const triangle = "\u25B5";
const triangledown = "\u25BF";
const triangleleft = "\u25C3";
const trianglelefteq = "\u22B4";
const triangleq = "\u225C";
const triangleright = "\u25B9";
const trianglerighteq = "\u22B5";
const tridot = "\u25EC";
const trie = "\u225C";
const triminus = "\u2A3A";
const TripleDot = "\u20DB";
const triplus = "\u2A39";
const trisb = "\u29CD";
const tritime = "\u2A3B";
const trpezium = "\u23E2";
const Tscr = "\u{1D4AF}";
const tscr = "\u{1D4C9}";
const TScy = "\u0426";
const tscy = "\u0446";
const TSHcy = "\u040B";
const tshcy = "\u045B";
const Tstrok = "\u0166";
const tstrok = "\u0167";
const twixt = "\u226C";
const twoheadleftarrow = "\u219E";
const twoheadrightarrow = "\u21A0";
const Uacute = "\xDA";
const uacute = "\xFA";
const uarr = "\u2191";
const Uarr = "\u219F";
const uArr = "\u21D1";
const Uarrocir = "\u2949";
const Ubrcy = "\u040E";
const ubrcy = "\u045E";
const Ubreve = "\u016C";
const ubreve = "\u016D";
const Ucirc = "\xDB";
const ucirc = "\xFB";
const Ucy = "\u0423";
const ucy = "\u0443";
const udarr = "\u21C5";
const Udblac = "\u0170";
const udblac = "\u0171";
const udhar = "\u296E";
const ufisht = "\u297E";
const Ufr = "\u{1D518}";
const ufr = "\u{1D532}";
const Ugrave = "\xD9";
const ugrave = "\xF9";
const uHar = "\u2963";
const uharl = "\u21BF";
const uharr = "\u21BE";
const uhblk = "\u2580";
const ulcorn = "\u231C";
const ulcorner = "\u231C";
const ulcrop = "\u230F";
const ultri = "\u25F8";
const Umacr = "\u016A";
const umacr = "\u016B";
const uml = "\xA8";
const UnderBar = "_";
const UnderBrace = "\u23DF";
const UnderBracket = "\u23B5";
const UnderParenthesis = "\u23DD";
const Union = "\u22C3";
const UnionPlus = "\u228E";
const Uogon = "\u0172";
const uogon = "\u0173";
const Uopf = "\u{1D54C}";
const uopf = "\u{1D566}";
const UpArrowBar = "\u2912";
const uparrow = "\u2191";
const UpArrow = "\u2191";
const Uparrow = "\u21D1";
const UpArrowDownArrow = "\u21C5";
const updownarrow = "\u2195";
const UpDownArrow = "\u2195";
const Updownarrow = "\u21D5";
const UpEquilibrium = "\u296E";
const upharpoonleft = "\u21BF";
const upharpoonright = "\u21BE";
const uplus = "\u228E";
const UpperLeftArrow = "\u2196";
const UpperRightArrow = "\u2197";
const upsi = "\u03C5";
const Upsi = "\u03D2";
const upsih = "\u03D2";
const Upsilon = "\u03A5";
const upsilon = "\u03C5";
const UpTeeArrow = "\u21A5";
const UpTee = "\u22A5";
const upuparrows = "\u21C8";
const urcorn = "\u231D";
const urcorner = "\u231D";
const urcrop = "\u230E";
const Uring = "\u016E";
const uring = "\u016F";
const urtri = "\u25F9";
const Uscr = "\u{1D4B0}";
const uscr = "\u{1D4CA}";
const utdot = "\u22F0";
const Utilde = "\u0168";
const utilde = "\u0169";
const utri = "\u25B5";
const utrif = "\u25B4";
const uuarr = "\u21C8";
const Uuml = "\xDC";
const uuml = "\xFC";
const uwangle = "\u29A7";
const vangrt = "\u299C";
const varepsilon = "\u03F5";
const varkappa = "\u03F0";
const varnothing = "\u2205";
const varphi = "\u03D5";
const varpi = "\u03D6";
const varpropto = "\u221D";
const varr = "\u2195";
const vArr = "\u21D5";
const varrho = "\u03F1";
const varsigma = "\u03C2";
const varsubsetneq = "\u228A\uFE00";
const varsubsetneqq = "\u2ACB\uFE00";
const varsupsetneq = "\u228B\uFE00";
const varsupsetneqq = "\u2ACC\uFE00";
const vartheta = "\u03D1";
const vartriangleleft = "\u22B2";
const vartriangleright = "\u22B3";
const vBar = "\u2AE8";
const Vbar = "\u2AEB";
const vBarv = "\u2AE9";
const Vcy = "\u0412";
const vcy = "\u0432";
const vdash = "\u22A2";
const vDash = "\u22A8";
const Vdash = "\u22A9";
const VDash = "\u22AB";
const Vdashl = "\u2AE6";
const veebar = "\u22BB";
const vee = "\u2228";
const Vee = "\u22C1";
const veeeq = "\u225A";
const vellip = "\u22EE";
const verbar = "|";
const Verbar = "\u2016";
const vert = "|";
const Vert = "\u2016";
const VerticalBar = "\u2223";
const VerticalLine = "|";
const VerticalSeparator = "\u2758";
const VerticalTilde = "\u2240";
const VeryThinSpace = "\u200A";
const Vfr = "\u{1D519}";
const vfr = "\u{1D533}";
const vltri = "\u22B2";
const vnsub = "\u2282\u20D2";
const vnsup = "\u2283\u20D2";
const Vopf = "\u{1D54D}";
const vopf = "\u{1D567}";
const vprop = "\u221D";
const vrtri = "\u22B3";
const Vscr = "\u{1D4B1}";
const vscr = "\u{1D4CB}";
const vsubnE = "\u2ACB\uFE00";
const vsubne = "\u228A\uFE00";
const vsupnE = "\u2ACC\uFE00";
const vsupne = "\u228B\uFE00";
const Vvdash = "\u22AA";
const vzigzag = "\u299A";
const Wcirc = "\u0174";
const wcirc = "\u0175";
const wedbar = "\u2A5F";
const wedge = "\u2227";
const Wedge = "\u22C0";
const wedgeq = "\u2259";
const weierp = "\u2118";
const Wfr = "\u{1D51A}";
const wfr = "\u{1D534}";
const Wopf = "\u{1D54E}";
const wopf = "\u{1D568}";
const wp = "\u2118";
const wr = "\u2240";
const wreath = "\u2240";
const Wscr = "\u{1D4B2}";
const wscr = "\u{1D4CC}";
const xcap = "\u22C2";
const xcirc = "\u25EF";
const xcup = "\u22C3";
const xdtri = "\u25BD";
const Xfr = "\u{1D51B}";
const xfr = "\u{1D535}";
const xharr = "\u27F7";
const xhArr = "\u27FA";
const Xi = "\u039E";
const xi = "\u03BE";
const xlarr = "\u27F5";
const xlArr = "\u27F8";
const xmap = "\u27FC";
const xnis = "\u22FB";
const xodot = "\u2A00";
const Xopf = "\u{1D54F}";
const xopf = "\u{1D569}";
const xoplus = "\u2A01";
const xotime = "\u2A02";
const xrarr = "\u27F6";
const xrArr = "\u27F9";
const Xscr = "\u{1D4B3}";
const xscr = "\u{1D4CD}";
const xsqcup = "\u2A06";
const xuplus = "\u2A04";
const xutri = "\u25B3";
const xvee = "\u22C1";
const xwedge = "\u22C0";
const Yacute = "\xDD";
const yacute = "\xFD";
const YAcy = "\u042F";
const yacy = "\u044F";
const Ycirc = "\u0176";
const ycirc = "\u0177";
const Ycy = "\u042B";
const ycy = "\u044B";
const yen = "\xA5";
const Yfr = "\u{1D51C}";
const yfr = "\u{1D536}";
const YIcy = "\u0407";
const yicy = "\u0457";
const Yopf = "\u{1D550}";
const yopf = "\u{1D56A}";
const Yscr = "\u{1D4B4}";
const yscr = "\u{1D4CE}";
const YUcy = "\u042E";
const yucy = "\u044E";
const yuml = "\xFF";
const Yuml = "\u0178";
const Zacute = "\u0179";
const zacute = "\u017A";
const Zcaron = "\u017D";
const zcaron = "\u017E";
const Zcy = "\u0417";
const zcy = "\u0437";
const Zdot = "\u017B";
const zdot = "\u017C";
const zeetrf = "\u2128";
const ZeroWidthSpace = "\u200B";
const Zeta = "\u0396";
const zeta = "\u03B6";
const zfr = "\u{1D537}";
const Zfr = "\u2128";
const ZHcy = "\u0416";
const zhcy = "\u0436";
const zigrarr = "\u21DD";
const zopf = "\u{1D56B}";
const Zopf = "\u2124";
const Zscr = "\u{1D4B5}";
const zscr = "\u{1D4CF}";
const zwj = "\u200D";
const zwnj = "\u200C";
var require$$0 = {
  Aacute,
  aacute,
  Abreve,
  abreve,
  ac,
  acd,
  acE,
  Acirc,
  acirc,
  acute,
  Acy,
  acy,
  AElig,
  aelig,
  af,
  Afr,
  afr,
  Agrave,
  agrave,
  alefsym,
  aleph,
  Alpha,
  alpha,
  Amacr,
  amacr,
  amalg,
  amp,
  AMP,
  andand,
  And,
  and,
  andd,
  andslope,
  andv,
  ang,
  ange,
  angle,
  angmsdaa,
  angmsdab,
  angmsdac,
  angmsdad,
  angmsdae,
  angmsdaf,
  angmsdag,
  angmsdah,
  angmsd,
  angrt,
  angrtvb,
  angrtvbd,
  angsph,
  angst,
  angzarr,
  Aogon,
  aogon,
  Aopf,
  aopf,
  apacir,
  ap,
  apE,
  ape,
  apid,
  apos,
  ApplyFunction,
  approx,
  approxeq,
  Aring,
  aring,
  Ascr,
  ascr,
  Assign,
  ast,
  asymp,
  asympeq,
  Atilde,
  atilde,
  Auml,
  auml,
  awconint,
  awint,
  backcong,
  backepsilon,
  backprime,
  backsim,
  backsimeq,
  Backslash,
  Barv,
  barvee,
  barwed,
  Barwed,
  barwedge,
  bbrk,
  bbrktbrk,
  bcong,
  Bcy,
  bcy,
  bdquo,
  becaus,
  because,
  Because,
  bemptyv,
  bepsi,
  bernou,
  Bernoullis,
  Beta,
  beta,
  beth,
  between,
  Bfr,
  bfr,
  bigcap,
  bigcirc,
  bigcup,
  bigodot,
  bigoplus,
  bigotimes,
  bigsqcup,
  bigstar,
  bigtriangledown,
  bigtriangleup,
  biguplus,
  bigvee,
  bigwedge,
  bkarow,
  blacklozenge,
  blacksquare,
  blacktriangle,
  blacktriangledown,
  blacktriangleleft,
  blacktriangleright,
  blank,
  blk12,
  blk14,
  blk34,
  block: block$1,
  bne,
  bnequiv,
  bNot,
  bnot,
  Bopf,
  bopf,
  bot,
  bottom,
  bowtie,
  boxbox,
  boxdl,
  boxdL,
  boxDl,
  boxDL,
  boxdr,
  boxdR,
  boxDr,
  boxDR,
  boxh,
  boxH,
  boxhd,
  boxHd,
  boxhD,
  boxHD,
  boxhu,
  boxHu,
  boxhU,
  boxHU,
  boxminus,
  boxplus,
  boxtimes,
  boxul,
  boxuL,
  boxUl,
  boxUL,
  boxur,
  boxuR,
  boxUr,
  boxUR,
  boxv,
  boxV,
  boxvh,
  boxvH,
  boxVh,
  boxVH,
  boxvl,
  boxvL,
  boxVl,
  boxVL,
  boxvr,
  boxvR,
  boxVr,
  boxVR,
  bprime,
  breve,
  Breve,
  brvbar,
  bscr,
  Bscr,
  bsemi,
  bsim,
  bsime,
  bsolb,
  bsol,
  bsolhsub,
  bull,
  bullet,
  bump,
  bumpE,
  bumpe,
  Bumpeq,
  bumpeq,
  Cacute,
  cacute,
  capand,
  capbrcup,
  capcap,
  cap,
  Cap,
  capcup,
  capdot,
  CapitalDifferentialD,
  caps,
  caret,
  caron,
  Cayleys,
  ccaps,
  Ccaron,
  ccaron,
  Ccedil,
  ccedil,
  Ccirc,
  ccirc,
  Cconint,
  ccups,
  ccupssm,
  Cdot,
  cdot,
  cedil,
  Cedilla,
  cemptyv,
  cent,
  centerdot,
  CenterDot,
  cfr,
  Cfr,
  CHcy,
  chcy,
  check,
  checkmark,
  Chi,
  chi,
  circ,
  circeq,
  circlearrowleft,
  circlearrowright,
  circledast,
  circledcirc,
  circleddash,
  CircleDot,
  circledR,
  circledS,
  CircleMinus,
  CirclePlus,
  CircleTimes,
  cir,
  cirE,
  cire,
  cirfnint,
  cirmid,
  cirscir,
  ClockwiseContourIntegral,
  CloseCurlyDoubleQuote,
  CloseCurlyQuote,
  clubs,
  clubsuit,
  colon,
  Colon,
  Colone,
  colone,
  coloneq,
  comma,
  commat,
  comp,
  compfn,
  complement,
  complexes,
  cong,
  congdot,
  Congruent,
  conint,
  Conint,
  ContourIntegral,
  copf,
  Copf,
  coprod,
  Coproduct,
  copy: copy$1,
  COPY,
  copysr,
  CounterClockwiseContourIntegral,
  crarr,
  cross,
  Cross,
  Cscr,
  cscr,
  csub,
  csube,
  csup,
  csupe,
  ctdot,
  cudarrl,
  cudarrr,
  cuepr,
  cuesc,
  cularr,
  cularrp,
  cupbrcap,
  cupcap,
  CupCap,
  cup,
  Cup,
  cupcup,
  cupdot,
  cupor,
  cups,
  curarr,
  curarrm,
  curlyeqprec,
  curlyeqsucc,
  curlyvee,
  curlywedge,
  curren,
  curvearrowleft,
  curvearrowright,
  cuvee,
  cuwed,
  cwconint,
  cwint,
  cylcty,
  dagger,
  Dagger,
  daleth,
  darr,
  Darr,
  dArr,
  dash,
  Dashv,
  dashv,
  dbkarow,
  dblac,
  Dcaron,
  dcaron,
  Dcy,
  dcy,
  ddagger,
  ddarr,
  DD,
  dd,
  DDotrahd,
  ddotseq,
  deg,
  Del,
  Delta,
  delta,
  demptyv,
  dfisht,
  Dfr,
  dfr,
  dHar,
  dharl,
  dharr,
  DiacriticalAcute,
  DiacriticalDot,
  DiacriticalDoubleAcute,
  DiacriticalGrave,
  DiacriticalTilde,
  diam,
  diamond,
  Diamond,
  diamondsuit,
  diams,
  die,
  DifferentialD,
  digamma,
  disin,
  div,
  divide,
  divideontimes,
  divonx,
  DJcy,
  djcy,
  dlcorn,
  dlcrop,
  dollar,
  Dopf,
  dopf,
  Dot,
  dot,
  DotDot,
  doteq,
  doteqdot,
  DotEqual,
  dotminus,
  dotplus,
  dotsquare,
  doublebarwedge,
  DoubleContourIntegral,
  DoubleDot,
  DoubleDownArrow,
  DoubleLeftArrow,
  DoubleLeftRightArrow,
  DoubleLeftTee,
  DoubleLongLeftArrow,
  DoubleLongLeftRightArrow,
  DoubleLongRightArrow,
  DoubleRightArrow,
  DoubleRightTee,
  DoubleUpArrow,
  DoubleUpDownArrow,
  DoubleVerticalBar,
  DownArrowBar,
  downarrow,
  DownArrow,
  Downarrow,
  DownArrowUpArrow,
  DownBreve,
  downdownarrows,
  downharpoonleft,
  downharpoonright,
  DownLeftRightVector,
  DownLeftTeeVector,
  DownLeftVectorBar,
  DownLeftVector,
  DownRightTeeVector,
  DownRightVectorBar,
  DownRightVector,
  DownTeeArrow,
  DownTee,
  drbkarow,
  drcorn,
  drcrop,
  Dscr,
  dscr,
  DScy,
  dscy,
  dsol,
  Dstrok,
  dstrok,
  dtdot,
  dtri,
  dtrif,
  duarr,
  duhar,
  dwangle,
  DZcy,
  dzcy,
  dzigrarr,
  Eacute,
  eacute,
  easter,
  Ecaron,
  ecaron,
  Ecirc,
  ecirc,
  ecir,
  ecolon,
  Ecy,
  ecy,
  eDDot,
  Edot,
  edot,
  eDot,
  ee,
  efDot,
  Efr,
  efr,
  eg,
  Egrave,
  egrave,
  egs,
  egsdot,
  el,
  Element: Element$1,
  elinters,
  ell,
  els,
  elsdot,
  Emacr,
  emacr,
  empty,
  emptyset,
  EmptySmallSquare,
  emptyv,
  EmptyVerySmallSquare,
  emsp13,
  emsp14,
  emsp,
  ENG,
  eng,
  ensp,
  Eogon,
  eogon,
  Eopf,
  eopf,
  epar,
  eparsl,
  eplus,
  epsi,
  Epsilon,
  epsilon,
  epsiv,
  eqcirc,
  eqcolon,
  eqsim,
  eqslantgtr,
  eqslantless,
  Equal,
  equals,
  EqualTilde,
  equest,
  Equilibrium,
  equiv,
  equivDD,
  eqvparsl,
  erarr,
  erDot,
  escr,
  Escr,
  esdot,
  Esim,
  esim,
  Eta,
  eta,
  ETH,
  eth,
  Euml,
  euml,
  euro,
  excl,
  exist,
  Exists,
  expectation,
  exponentiale,
  ExponentialE,
  fallingdotseq,
  Fcy,
  fcy,
  female,
  ffilig,
  fflig,
  ffllig,
  Ffr,
  ffr,
  filig,
  FilledSmallSquare,
  FilledVerySmallSquare,
  fjlig,
  flat,
  fllig,
  fltns,
  fnof,
  Fopf,
  fopf,
  forall,
  ForAll,
  fork,
  forkv,
  Fouriertrf,
  fpartint,
  frac12,
  frac13,
  frac14,
  frac15,
  frac16,
  frac18,
  frac23,
  frac25,
  frac34,
  frac35,
  frac38,
  frac45,
  frac56,
  frac58,
  frac78,
  frasl,
  frown,
  fscr,
  Fscr,
  gacute,
  Gamma,
  gamma,
  Gammad,
  gammad,
  gap,
  Gbreve,
  gbreve,
  Gcedil,
  Gcirc,
  gcirc,
  Gcy,
  gcy,
  Gdot,
  gdot,
  ge,
  gE,
  gEl,
  gel,
  geq,
  geqq,
  geqslant,
  gescc,
  ges,
  gesdot,
  gesdoto,
  gesdotol,
  gesl,
  gesles,
  Gfr,
  gfr,
  gg,
  Gg,
  ggg,
  gimel,
  GJcy,
  gjcy,
  gla,
  gl,
  glE,
  glj,
  gnap,
  gnapprox,
  gne,
  gnE,
  gneq,
  gneqq,
  gnsim,
  Gopf,
  gopf,
  grave,
  GreaterEqual,
  GreaterEqualLess,
  GreaterFullEqual,
  GreaterGreater,
  GreaterLess,
  GreaterSlantEqual,
  GreaterTilde,
  Gscr,
  gscr,
  gsim,
  gsime,
  gsiml,
  gtcc,
  gtcir,
  gt,
  GT,
  Gt,
  gtdot,
  gtlPar,
  gtquest,
  gtrapprox,
  gtrarr,
  gtrdot,
  gtreqless,
  gtreqqless,
  gtrless,
  gtrsim,
  gvertneqq,
  gvnE,
  Hacek,
  hairsp,
  half,
  hamilt,
  HARDcy,
  hardcy,
  harrcir,
  harr,
  hArr,
  harrw,
  Hat,
  hbar,
  Hcirc,
  hcirc,
  hearts,
  heartsuit,
  hellip,
  hercon,
  hfr,
  Hfr,
  HilbertSpace,
  hksearow,
  hkswarow,
  hoarr,
  homtht,
  hookleftarrow,
  hookrightarrow,
  hopf,
  Hopf,
  horbar,
  HorizontalLine,
  hscr,
  Hscr,
  hslash,
  Hstrok,
  hstrok,
  HumpDownHump,
  HumpEqual,
  hybull,
  hyphen,
  Iacute,
  iacute,
  ic,
  Icirc,
  icirc,
  Icy,
  icy,
  Idot,
  IEcy,
  iecy,
  iexcl,
  iff,
  ifr,
  Ifr,
  Igrave,
  igrave,
  ii,
  iiiint,
  iiint,
  iinfin,
  iiota,
  IJlig,
  ijlig,
  Imacr,
  imacr,
  image: image$1,
  ImaginaryI,
  imagline,
  imagpart,
  imath,
  Im,
  imof,
  imped,
  Implies,
  incare,
  "in": "\u2208",
  infin,
  infintie,
  inodot,
  intcal,
  int,
  Int,
  integers,
  Integral,
  intercal,
  Intersection,
  intlarhk,
  intprod,
  InvisibleComma,
  InvisibleTimes,
  IOcy,
  iocy,
  Iogon,
  iogon,
  Iopf,
  iopf,
  Iota,
  iota,
  iprod,
  iquest,
  iscr,
  Iscr,
  isin,
  isindot,
  isinE,
  isins,
  isinsv,
  isinv,
  it,
  Itilde,
  itilde,
  Iukcy,
  iukcy,
  Iuml,
  iuml,
  Jcirc,
  jcirc,
  Jcy,
  jcy,
  Jfr,
  jfr,
  jmath,
  Jopf,
  jopf,
  Jscr,
  jscr,
  Jsercy,
  jsercy,
  Jukcy,
  jukcy,
  Kappa,
  kappa,
  kappav,
  Kcedil,
  kcedil,
  Kcy,
  kcy,
  Kfr,
  kfr,
  kgreen,
  KHcy,
  khcy,
  KJcy,
  kjcy,
  Kopf,
  kopf,
  Kscr,
  kscr,
  lAarr,
  Lacute,
  lacute,
  laemptyv,
  lagran,
  Lambda,
  lambda,
  lang,
  Lang,
  langd,
  langle,
  lap,
  Laplacetrf,
  laquo,
  larrb,
  larrbfs,
  larr,
  Larr,
  lArr,
  larrfs,
  larrhk,
  larrlp,
  larrpl,
  larrsim,
  larrtl,
  latail,
  lAtail,
  lat,
  late,
  lates,
  lbarr,
  lBarr,
  lbbrk,
  lbrace,
  lbrack,
  lbrke,
  lbrksld,
  lbrkslu,
  Lcaron,
  lcaron,
  Lcedil,
  lcedil,
  lceil,
  lcub,
  Lcy,
  lcy,
  ldca,
  ldquo,
  ldquor,
  ldrdhar,
  ldrushar,
  ldsh,
  le,
  lE,
  LeftAngleBracket,
  LeftArrowBar,
  leftarrow,
  LeftArrow,
  Leftarrow,
  LeftArrowRightArrow,
  leftarrowtail,
  LeftCeiling,
  LeftDoubleBracket,
  LeftDownTeeVector,
  LeftDownVectorBar,
  LeftDownVector,
  LeftFloor,
  leftharpoondown,
  leftharpoonup,
  leftleftarrows,
  leftrightarrow,
  LeftRightArrow,
  Leftrightarrow,
  leftrightarrows,
  leftrightharpoons,
  leftrightsquigarrow,
  LeftRightVector,
  LeftTeeArrow,
  LeftTee,
  LeftTeeVector,
  leftthreetimes,
  LeftTriangleBar,
  LeftTriangle,
  LeftTriangleEqual,
  LeftUpDownVector,
  LeftUpTeeVector,
  LeftUpVectorBar,
  LeftUpVector,
  LeftVectorBar,
  LeftVector,
  lEg,
  leg,
  leq,
  leqq,
  leqslant,
  lescc,
  les,
  lesdot,
  lesdoto,
  lesdotor,
  lesg,
  lesges,
  lessapprox,
  lessdot,
  lesseqgtr,
  lesseqqgtr,
  LessEqualGreater,
  LessFullEqual,
  LessGreater,
  lessgtr,
  LessLess,
  lesssim,
  LessSlantEqual,
  LessTilde,
  lfisht,
  lfloor,
  Lfr,
  lfr,
  lg,
  lgE,
  lHar,
  lhard,
  lharu,
  lharul,
  lhblk,
  LJcy,
  ljcy,
  llarr,
  ll,
  Ll,
  llcorner,
  Lleftarrow,
  llhard,
  lltri,
  Lmidot,
  lmidot,
  lmoustache,
  lmoust,
  lnap,
  lnapprox,
  lne,
  lnE,
  lneq,
  lneqq,
  lnsim,
  loang,
  loarr,
  lobrk,
  longleftarrow,
  LongLeftArrow,
  Longleftarrow,
  longleftrightarrow,
  LongLeftRightArrow,
  Longleftrightarrow,
  longmapsto,
  longrightarrow,
  LongRightArrow,
  Longrightarrow,
  looparrowleft,
  looparrowright,
  lopar,
  Lopf,
  lopf,
  loplus,
  lotimes,
  lowast,
  lowbar,
  LowerLeftArrow,
  LowerRightArrow,
  loz,
  lozenge,
  lozf,
  lpar,
  lparlt,
  lrarr,
  lrcorner,
  lrhar,
  lrhard,
  lrm,
  lrtri,
  lsaquo,
  lscr,
  Lscr,
  lsh,
  Lsh,
  lsim,
  lsime,
  lsimg,
  lsqb,
  lsquo,
  lsquor,
  Lstrok,
  lstrok,
  ltcc,
  ltcir,
  lt,
  LT,
  Lt,
  ltdot,
  lthree,
  ltimes,
  ltlarr,
  ltquest,
  ltri,
  ltrie,
  ltrif,
  ltrPar,
  lurdshar,
  luruhar,
  lvertneqq,
  lvnE,
  macr,
  male,
  malt,
  maltese,
  "Map": "\u2905",
  map: map$1,
  mapsto,
  mapstodown,
  mapstoleft,
  mapstoup,
  marker,
  mcomma,
  Mcy,
  mcy,
  mdash,
  mDDot,
  measuredangle,
  MediumSpace,
  Mellintrf,
  Mfr,
  mfr,
  mho,
  micro,
  midast,
  midcir,
  mid,
  middot,
  minusb,
  minus,
  minusd,
  minusdu,
  MinusPlus,
  mlcp,
  mldr,
  mnplus,
  models,
  Mopf,
  mopf,
  mp,
  mscr,
  Mscr,
  mstpos,
  Mu,
  mu,
  multimap,
  mumap,
  nabla,
  Nacute,
  nacute,
  nang,
  nap,
  napE,
  napid,
  napos,
  napprox,
  natural,
  naturals,
  natur,
  nbsp,
  nbump,
  nbumpe,
  ncap,
  Ncaron,
  ncaron,
  Ncedil,
  ncedil,
  ncong,
  ncongdot,
  ncup,
  Ncy,
  ncy,
  ndash,
  nearhk,
  nearr,
  neArr,
  nearrow,
  ne,
  nedot,
  NegativeMediumSpace,
  NegativeThickSpace,
  NegativeThinSpace,
  NegativeVeryThinSpace,
  nequiv,
  nesear,
  nesim,
  NestedGreaterGreater,
  NestedLessLess,
  NewLine,
  nexist,
  nexists,
  Nfr,
  nfr,
  ngE,
  nge,
  ngeq,
  ngeqq,
  ngeqslant,
  nges,
  nGg,
  ngsim,
  nGt,
  ngt,
  ngtr,
  nGtv,
  nharr,
  nhArr,
  nhpar,
  ni,
  nis,
  nisd,
  niv,
  NJcy,
  njcy,
  nlarr,
  nlArr,
  nldr,
  nlE,
  nle,
  nleftarrow,
  nLeftarrow,
  nleftrightarrow,
  nLeftrightarrow,
  nleq,
  nleqq,
  nleqslant,
  nles,
  nless,
  nLl,
  nlsim,
  nLt,
  nlt,
  nltri,
  nltrie,
  nLtv,
  nmid,
  NoBreak,
  NonBreakingSpace,
  nopf,
  Nopf,
  Not,
  not,
  NotCongruent,
  NotCupCap,
  NotDoubleVerticalBar,
  NotElement,
  NotEqual,
  NotEqualTilde,
  NotExists,
  NotGreater,
  NotGreaterEqual,
  NotGreaterFullEqual,
  NotGreaterGreater,
  NotGreaterLess,
  NotGreaterSlantEqual,
  NotGreaterTilde,
  NotHumpDownHump,
  NotHumpEqual,
  notin,
  notindot,
  notinE,
  notinva,
  notinvb,
  notinvc,
  NotLeftTriangleBar,
  NotLeftTriangle,
  NotLeftTriangleEqual,
  NotLess,
  NotLessEqual,
  NotLessGreater,
  NotLessLess,
  NotLessSlantEqual,
  NotLessTilde,
  NotNestedGreaterGreater,
  NotNestedLessLess,
  notni,
  notniva,
  notnivb,
  notnivc,
  NotPrecedes,
  NotPrecedesEqual,
  NotPrecedesSlantEqual,
  NotReverseElement,
  NotRightTriangleBar,
  NotRightTriangle,
  NotRightTriangleEqual,
  NotSquareSubset,
  NotSquareSubsetEqual,
  NotSquareSuperset,
  NotSquareSupersetEqual,
  NotSubset,
  NotSubsetEqual,
  NotSucceeds,
  NotSucceedsEqual,
  NotSucceedsSlantEqual,
  NotSucceedsTilde,
  NotSuperset,
  NotSupersetEqual,
  NotTilde,
  NotTildeEqual,
  NotTildeFullEqual,
  NotTildeTilde,
  NotVerticalBar,
  nparallel,
  npar,
  nparsl,
  npart,
  npolint,
  npr,
  nprcue,
  nprec,
  npreceq,
  npre,
  nrarrc,
  nrarr,
  nrArr,
  nrarrw,
  nrightarrow,
  nRightarrow,
  nrtri,
  nrtrie,
  nsc,
  nsccue,
  nsce,
  Nscr,
  nscr,
  nshortmid,
  nshortparallel,
  nsim,
  nsime,
  nsimeq,
  nsmid,
  nspar,
  nsqsube,
  nsqsupe,
  nsub,
  nsubE,
  nsube,
  nsubset,
  nsubseteq,
  nsubseteqq,
  nsucc,
  nsucceq,
  nsup,
  nsupE,
  nsupe,
  nsupset,
  nsupseteq,
  nsupseteqq,
  ntgl,
  Ntilde,
  ntilde,
  ntlg,
  ntriangleleft,
  ntrianglelefteq,
  ntriangleright,
  ntrianglerighteq,
  Nu,
  nu,
  num,
  numero,
  numsp,
  nvap,
  nvdash,
  nvDash,
  nVdash,
  nVDash,
  nvge,
  nvgt,
  nvHarr,
  nvinfin,
  nvlArr,
  nvle,
  nvlt,
  nvltrie,
  nvrArr,
  nvrtrie,
  nvsim,
  nwarhk,
  nwarr,
  nwArr,
  nwarrow,
  nwnear,
  Oacute,
  oacute,
  oast,
  Ocirc,
  ocirc,
  ocir,
  Ocy,
  ocy,
  odash,
  Odblac,
  odblac,
  odiv,
  odot,
  odsold,
  OElig,
  oelig,
  ofcir,
  Ofr,
  ofr,
  ogon,
  Ograve,
  ograve,
  ogt,
  ohbar,
  ohm,
  oint,
  olarr,
  olcir,
  olcross,
  oline,
  olt,
  Omacr,
  omacr,
  Omega,
  omega,
  Omicron,
  omicron,
  omid,
  ominus,
  Oopf,
  oopf,
  opar,
  OpenCurlyDoubleQuote,
  OpenCurlyQuote,
  operp,
  oplus,
  orarr,
  Or,
  or,
  ord,
  order,
  orderof,
  ordf,
  ordm,
  origof,
  oror,
  orslope,
  orv,
  oS,
  Oscr,
  oscr,
  Oslash,
  oslash,
  osol,
  Otilde,
  otilde,
  otimesas,
  Otimes,
  otimes,
  Ouml,
  ouml,
  ovbar,
  OverBar,
  OverBrace,
  OverBracket,
  OverParenthesis,
  para,
  parallel,
  par,
  parsim,
  parsl,
  part,
  PartialD,
  Pcy,
  pcy,
  percnt,
  period,
  permil,
  perp,
  pertenk,
  Pfr,
  pfr,
  Phi,
  phi,
  phiv,
  phmmat,
  phone,
  Pi,
  pi,
  pitchfork,
  piv,
  planck,
  planckh,
  plankv,
  plusacir,
  plusb,
  pluscir,
  plus,
  plusdo,
  plusdu,
  pluse,
  PlusMinus,
  plusmn,
  plussim,
  plustwo,
  pm,
  Poincareplane,
  pointint,
  popf,
  Popf,
  pound,
  prap,
  Pr,
  pr,
  prcue,
  precapprox,
  prec,
  preccurlyeq,
  Precedes,
  PrecedesEqual,
  PrecedesSlantEqual,
  PrecedesTilde,
  preceq,
  precnapprox,
  precneqq,
  precnsim,
  pre,
  prE,
  precsim,
  prime,
  Prime,
  primes,
  prnap,
  prnE,
  prnsim,
  prod,
  Product,
  profalar,
  profline,
  profsurf,
  prop,
  Proportional,
  Proportion,
  propto,
  prsim,
  prurel,
  Pscr,
  pscr,
  Psi,
  psi,
  puncsp,
  Qfr,
  qfr,
  qint,
  qopf,
  Qopf,
  qprime,
  Qscr,
  qscr,
  quaternions,
  quatint,
  quest,
  questeq,
  quot,
  QUOT,
  rAarr,
  race,
  Racute,
  racute,
  radic,
  raemptyv,
  rang,
  Rang,
  rangd,
  range,
  rangle,
  raquo,
  rarrap,
  rarrb,
  rarrbfs,
  rarrc,
  rarr,
  Rarr,
  rArr,
  rarrfs,
  rarrhk,
  rarrlp,
  rarrpl,
  rarrsim,
  Rarrtl,
  rarrtl,
  rarrw,
  ratail,
  rAtail,
  ratio,
  rationals,
  rbarr,
  rBarr,
  RBarr,
  rbbrk,
  rbrace,
  rbrack,
  rbrke,
  rbrksld,
  rbrkslu,
  Rcaron,
  rcaron,
  Rcedil,
  rcedil,
  rceil,
  rcub,
  Rcy,
  rcy,
  rdca,
  rdldhar,
  rdquo,
  rdquor,
  rdsh,
  real,
  realine,
  realpart,
  reals,
  Re,
  rect,
  reg,
  REG,
  ReverseElement,
  ReverseEquilibrium,
  ReverseUpEquilibrium,
  rfisht,
  rfloor,
  rfr,
  Rfr,
  rHar,
  rhard,
  rharu,
  rharul,
  Rho,
  rho,
  rhov,
  RightAngleBracket,
  RightArrowBar,
  rightarrow,
  RightArrow,
  Rightarrow,
  RightArrowLeftArrow,
  rightarrowtail,
  RightCeiling,
  RightDoubleBracket,
  RightDownTeeVector,
  RightDownVectorBar,
  RightDownVector,
  RightFloor,
  rightharpoondown,
  rightharpoonup,
  rightleftarrows,
  rightleftharpoons,
  rightrightarrows,
  rightsquigarrow,
  RightTeeArrow,
  RightTee,
  RightTeeVector,
  rightthreetimes,
  RightTriangleBar,
  RightTriangle,
  RightTriangleEqual,
  RightUpDownVector,
  RightUpTeeVector,
  RightUpVectorBar,
  RightUpVector,
  RightVectorBar,
  RightVector,
  ring,
  risingdotseq,
  rlarr,
  rlhar,
  rlm,
  rmoustache,
  rmoust,
  rnmid,
  roang,
  roarr,
  robrk,
  ropar,
  ropf,
  Ropf,
  roplus,
  rotimes,
  RoundImplies,
  rpar,
  rpargt,
  rppolint,
  rrarr,
  Rrightarrow,
  rsaquo,
  rscr,
  Rscr,
  rsh,
  Rsh,
  rsqb,
  rsquo,
  rsquor,
  rthree,
  rtimes,
  rtri,
  rtrie,
  rtrif,
  rtriltri,
  RuleDelayed,
  ruluhar,
  rx,
  Sacute,
  sacute,
  sbquo,
  scap,
  Scaron,
  scaron,
  Sc,
  sc,
  sccue,
  sce,
  scE,
  Scedil,
  scedil,
  Scirc,
  scirc,
  scnap,
  scnE,
  scnsim,
  scpolint,
  scsim,
  Scy,
  scy,
  sdotb,
  sdot,
  sdote,
  searhk,
  searr,
  seArr,
  searrow,
  sect,
  semi,
  seswar,
  setminus,
  setmn,
  sext,
  Sfr,
  sfr,
  sfrown,
  sharp,
  SHCHcy,
  shchcy,
  SHcy,
  shcy,
  ShortDownArrow,
  ShortLeftArrow,
  shortmid,
  shortparallel,
  ShortRightArrow,
  ShortUpArrow,
  shy,
  Sigma,
  sigma,
  sigmaf,
  sigmav,
  sim,
  simdot,
  sime,
  simeq,
  simg,
  simgE,
  siml,
  simlE,
  simne,
  simplus,
  simrarr,
  slarr,
  SmallCircle,
  smallsetminus,
  smashp,
  smeparsl,
  smid,
  smile,
  smt,
  smte,
  smtes,
  SOFTcy,
  softcy,
  solbar,
  solb,
  sol,
  Sopf,
  sopf,
  spades,
  spadesuit,
  spar,
  sqcap,
  sqcaps,
  sqcup,
  sqcups,
  Sqrt,
  sqsub,
  sqsube,
  sqsubset,
  sqsubseteq,
  sqsup,
  sqsupe,
  sqsupset,
  sqsupseteq,
  square,
  Square,
  SquareIntersection,
  SquareSubset,
  SquareSubsetEqual,
  SquareSuperset,
  SquareSupersetEqual,
  SquareUnion,
  squarf,
  squ,
  squf,
  srarr,
  Sscr,
  sscr,
  ssetmn,
  ssmile,
  sstarf,
  Star,
  star,
  starf,
  straightepsilon,
  straightphi,
  strns,
  sub,
  Sub,
  subdot,
  subE,
  sube,
  subedot,
  submult,
  subnE,
  subne,
  subplus,
  subrarr,
  subset,
  Subset,
  subseteq,
  subseteqq,
  SubsetEqual,
  subsetneq,
  subsetneqq,
  subsim,
  subsub,
  subsup,
  succapprox,
  succ,
  succcurlyeq,
  Succeeds,
  SucceedsEqual,
  SucceedsSlantEqual,
  SucceedsTilde,
  succeq,
  succnapprox,
  succneqq,
  succnsim,
  succsim,
  SuchThat,
  sum,
  Sum,
  sung,
  sup1,
  sup2,
  sup3,
  sup,
  Sup,
  supdot,
  supdsub,
  supE,
  supe,
  supedot,
  Superset,
  SupersetEqual,
  suphsol,
  suphsub,
  suplarr,
  supmult,
  supnE,
  supne,
  supplus,
  supset,
  Supset,
  supseteq,
  supseteqq,
  supsetneq,
  supsetneqq,
  supsim,
  supsub,
  supsup,
  swarhk,
  swarr,
  swArr,
  swarrow,
  swnwar,
  szlig,
  Tab: Tab$1,
  target,
  Tau,
  tau,
  tbrk,
  Tcaron,
  tcaron,
  Tcedil,
  tcedil,
  Tcy,
  tcy,
  tdot,
  telrec,
  Tfr,
  tfr,
  there4,
  therefore,
  Therefore,
  Theta,
  theta,
  thetasym,
  thetav,
  thickapprox,
  thicksim,
  ThickSpace,
  ThinSpace,
  thinsp,
  thkap,
  thksim,
  THORN,
  thorn,
  tilde,
  Tilde,
  TildeEqual,
  TildeFullEqual,
  TildeTilde,
  timesbar,
  timesb,
  times,
  timesd,
  tint,
  toea,
  topbot,
  topcir,
  top,
  Topf,
  topf,
  topfork,
  tosa,
  tprime,
  trade,
  TRADE,
  triangle,
  triangledown,
  triangleleft,
  trianglelefteq,
  triangleq,
  triangleright,
  trianglerighteq,
  tridot,
  trie,
  triminus,
  TripleDot,
  triplus,
  trisb,
  tritime,
  trpezium,
  Tscr,
  tscr,
  TScy,
  tscy,
  TSHcy,
  tshcy,
  Tstrok,
  tstrok,
  twixt,
  twoheadleftarrow,
  twoheadrightarrow,
  Uacute,
  uacute,
  uarr,
  Uarr,
  uArr,
  Uarrocir,
  Ubrcy,
  ubrcy,
  Ubreve,
  ubreve,
  Ucirc,
  ucirc,
  Ucy,
  ucy,
  udarr,
  Udblac,
  udblac,
  udhar,
  ufisht,
  Ufr,
  ufr,
  Ugrave,
  ugrave,
  uHar,
  uharl,
  uharr,
  uhblk,
  ulcorn,
  ulcorner,
  ulcrop,
  ultri,
  Umacr,
  umacr,
  uml,
  UnderBar,
  UnderBrace,
  UnderBracket,
  UnderParenthesis,
  Union,
  UnionPlus,
  Uogon,
  uogon,
  Uopf,
  uopf,
  UpArrowBar,
  uparrow,
  UpArrow,
  Uparrow,
  UpArrowDownArrow,
  updownarrow,
  UpDownArrow,
  Updownarrow,
  UpEquilibrium,
  upharpoonleft,
  upharpoonright,
  uplus,
  UpperLeftArrow,
  UpperRightArrow,
  upsi,
  Upsi,
  upsih,
  Upsilon,
  upsilon,
  UpTeeArrow,
  UpTee,
  upuparrows,
  urcorn,
  urcorner,
  urcrop,
  Uring,
  uring,
  urtri,
  Uscr,
  uscr,
  utdot,
  Utilde,
  utilde,
  utri,
  utrif,
  uuarr,
  Uuml,
  uuml,
  uwangle,
  vangrt,
  varepsilon,
  varkappa,
  varnothing,
  varphi,
  varpi,
  varpropto,
  varr,
  vArr,
  varrho,
  varsigma,
  varsubsetneq,
  varsubsetneqq,
  varsupsetneq,
  varsupsetneqq,
  vartheta,
  vartriangleleft,
  vartriangleright,
  vBar,
  Vbar,
  vBarv,
  Vcy,
  vcy,
  vdash,
  vDash,
  Vdash,
  VDash,
  Vdashl,
  veebar,
  vee,
  Vee,
  veeeq,
  vellip,
  verbar,
  Verbar,
  vert,
  Vert,
  VerticalBar,
  VerticalLine,
  VerticalSeparator,
  VerticalTilde,
  VeryThinSpace,
  Vfr,
  vfr,
  vltri,
  vnsub,
  vnsup,
  Vopf,
  vopf,
  vprop,
  vrtri,
  Vscr,
  vscr,
  vsubnE,
  vsubne,
  vsupnE,
  vsupne,
  Vvdash,
  vzigzag,
  Wcirc,
  wcirc,
  wedbar,
  wedge,
  Wedge,
  wedgeq,
  weierp,
  Wfr,
  wfr,
  Wopf,
  wopf,
  wp,
  wr,
  wreath,
  Wscr,
  wscr,
  xcap,
  xcirc,
  xcup,
  xdtri,
  Xfr,
  xfr,
  xharr,
  xhArr,
  Xi,
  xi,
  xlarr,
  xlArr,
  xmap,
  xnis,
  xodot,
  Xopf,
  xopf,
  xoplus,
  xotime,
  xrarr,
  xrArr,
  Xscr,
  xscr,
  xsqcup,
  xuplus,
  xutri,
  xvee,
  xwedge,
  Yacute,
  yacute,
  YAcy,
  yacy,
  Ycirc,
  ycirc,
  Ycy,
  ycy,
  yen,
  Yfr,
  yfr,
  YIcy,
  yicy,
  Yopf,
  yopf,
  Yscr,
  yscr,
  YUcy,
  yucy,
  yuml,
  Yuml,
  Zacute,
  zacute,
  Zcaron,
  zcaron,
  Zcy,
  zcy,
  Zdot,
  zdot,
  zeetrf,
  ZeroWidthSpace,
  Zeta,
  zeta,
  zfr,
  Zfr,
  ZHcy,
  zhcy,
  zigrarr,
  zopf,
  Zopf,
  Zscr,
  zscr,
  zwj,
  zwnj
};
var entities$1 = require$$0;
var regex$4 = /[!-#%-\*,-\/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4E\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD803[\uDF55-\uDF59]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC8\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD806[\uDC3B\uDE3F-\uDE46\uDE9A-\uDE9C\uDE9E-\uDEA2]|\uD807[\uDC41-\uDC45\uDC70\uDC71\uDEF7\uDEF8]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD81B[\uDE97-\uDE9A]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/;
var mdurl$1 = {};
var encodeCache = {};
function getEncodeCache(exclude) {
  var i, ch, cache = encodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = encodeCache[exclude] = [];
  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    if (/^[0-9a-z]$/i.test(ch)) {
      cache.push(ch);
    } else {
      cache.push("%" + ("0" + i.toString(16).toUpperCase()).slice(-2));
    }
  }
  for (i = 0; i < exclude.length; i++) {
    cache[exclude.charCodeAt(i)] = exclude[i];
  }
  return cache;
}
__name(getEncodeCache, "getEncodeCache");
function encode$1(string, exclude, keepEscaped) {
  var i, l2, code3, nextCode, cache, result = "";
  if (typeof exclude !== "string") {
    keepEscaped = exclude;
    exclude = encode$1.defaultChars;
  }
  if (typeof keepEscaped === "undefined") {
    keepEscaped = true;
  }
  cache = getEncodeCache(exclude);
  for (i = 0, l2 = string.length; i < l2; i++) {
    code3 = string.charCodeAt(i);
    if (keepEscaped && code3 === 37 && i + 2 < l2) {
      if (/^[0-9a-f]{2}$/i.test(string.slice(i + 1, i + 3))) {
        result += string.slice(i, i + 3);
        i += 2;
        continue;
      }
    }
    if (code3 < 128) {
      result += cache[code3];
      continue;
    }
    if (code3 >= 55296 && code3 <= 57343) {
      if (code3 >= 55296 && code3 <= 56319 && i + 1 < l2) {
        nextCode = string.charCodeAt(i + 1);
        if (nextCode >= 56320 && nextCode <= 57343) {
          result += encodeURIComponent(string[i] + string[i + 1]);
          i++;
          continue;
        }
      }
      result += "%EF%BF%BD";
      continue;
    }
    result += encodeURIComponent(string[i]);
  }
  return result;
}
__name(encode$1, "encode$1");
encode$1.defaultChars = ";/?:@&=+$,-_.!~*'()#";
encode$1.componentChars = "-_.!~*'()";
var encode_1 = encode$1;
var decodeCache = {};
function getDecodeCache(exclude) {
  var i, ch, cache = decodeCache[exclude];
  if (cache) {
    return cache;
  }
  cache = decodeCache[exclude] = [];
  for (i = 0; i < 128; i++) {
    ch = String.fromCharCode(i);
    cache.push(ch);
  }
  for (i = 0; i < exclude.length; i++) {
    ch = exclude.charCodeAt(i);
    cache[ch] = "%" + ("0" + ch.toString(16).toUpperCase()).slice(-2);
  }
  return cache;
}
__name(getDecodeCache, "getDecodeCache");
function decode$1(string, exclude) {
  var cache;
  if (typeof exclude !== "string") {
    exclude = decode$1.defaultChars;
  }
  cache = getDecodeCache(exclude);
  return string.replace(/(%[a-f0-9]{2})+/gi, function(seq) {
    var i, l2, b1, b2, b3, b4, chr, result = "";
    for (i = 0, l2 = seq.length; i < l2; i += 3) {
      b1 = parseInt(seq.slice(i + 1, i + 3), 16);
      if (b1 < 128) {
        result += cache[b1];
        continue;
      }
      if ((b1 & 224) === 192 && i + 3 < l2) {
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        if ((b2 & 192) === 128) {
          chr = b1 << 6 & 1984 | b2 & 63;
          if (chr < 128) {
            result += "\uFFFD\uFFFD";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 3;
          continue;
        }
      }
      if ((b1 & 240) === 224 && i + 6 < l2) {
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128) {
          chr = b1 << 12 & 61440 | b2 << 6 & 4032 | b3 & 63;
          if (chr < 2048 || chr >= 55296 && chr <= 57343) {
            result += "\uFFFD\uFFFD\uFFFD";
          } else {
            result += String.fromCharCode(chr);
          }
          i += 6;
          continue;
        }
      }
      if ((b1 & 248) === 240 && i + 9 < l2) {
        b2 = parseInt(seq.slice(i + 4, i + 6), 16);
        b3 = parseInt(seq.slice(i + 7, i + 9), 16);
        b4 = parseInt(seq.slice(i + 10, i + 12), 16);
        if ((b2 & 192) === 128 && (b3 & 192) === 128 && (b4 & 192) === 128) {
          chr = b1 << 18 & 1835008 | b2 << 12 & 258048 | b3 << 6 & 4032 | b4 & 63;
          if (chr < 65536 || chr > 1114111) {
            result += "\uFFFD\uFFFD\uFFFD\uFFFD";
          } else {
            chr -= 65536;
            result += String.fromCharCode(55296 + (chr >> 10), 56320 + (chr & 1023));
          }
          i += 9;
          continue;
        }
      }
      result += "\uFFFD";
    }
    return result;
  });
}
__name(decode$1, "decode$1");
decode$1.defaultChars = ";/?:@&=+$,#";
decode$1.componentChars = "";
var decode_1 = decode$1;
var format$1 = /* @__PURE__ */ __name(function format(url) {
  var result = "";
  result += url.protocol || "";
  result += url.slashes ? "//" : "";
  result += url.auth ? url.auth + "@" : "";
  if (url.hostname && url.hostname.indexOf(":") !== -1) {
    result += "[" + url.hostname + "]";
  } else {
    result += url.hostname || "";
  }
  result += url.port ? ":" + url.port : "";
  result += url.pathname || "";
  result += url.search || "";
  result += url.hash || "";
  return result;
}, "format");
function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.pathname = null;
}
__name(Url, "Url");
var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/, hostlessProtocol = {
  "javascript": true,
  "javascript:": true
}, slashedProtocol = {
  "http": true,
  "https": true,
  "ftp": true,
  "gopher": true,
  "file": true,
  "http:": true,
  "https:": true,
  "ftp:": true,
  "gopher:": true,
  "file:": true
};
function urlParse(url, slashesDenoteHost) {
  if (url && url instanceof Url) {
    return url;
  }
  var u2 = new Url();
  u2.parse(url, slashesDenoteHost);
  return u2;
}
__name(urlParse, "urlParse");
Url.prototype.parse = function(url, slashesDenoteHost) {
  var i, l2, lowerProto, hec, slashes, rest = url;
  rest = rest.trim();
  if (!slashesDenoteHost && url.split("#").length === 1) {
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
      }
      return this;
    }
  }
  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    lowerProto = proto.toLowerCase();
    this.protocol = proto;
    rest = rest.substr(proto.length);
  }
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    slashes = rest.substr(0, 2) === "//";
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }
  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    var hostEnd = -1;
    for (i = 0; i < hostEndingChars.length; i++) {
      hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    var auth, atSign;
    if (hostEnd === -1) {
      atSign = rest.lastIndexOf("@");
    } else {
      atSign = rest.lastIndexOf("@", hostEnd);
    }
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = auth;
    }
    hostEnd = -1;
    for (i = 0; i < nonHostChars.length; i++) {
      hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) {
        hostEnd = hec;
      }
    }
    if (hostEnd === -1) {
      hostEnd = rest.length;
    }
    if (rest[hostEnd - 1] === ":") {
      hostEnd--;
    }
    var host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);
    this.parseHost(host);
    this.hostname = this.hostname || "";
    var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (i = 0, l2 = hostparts.length; i < l2; i++) {
        var part2 = hostparts[i];
        if (!part2) {
          continue;
        }
        if (!part2.match(hostnamePartPattern)) {
          var newpart = "";
          for (var j = 0, k2 = part2.length; j < k2; j++) {
            if (part2.charCodeAt(j) > 127) {
              newpart += "x";
            } else {
              newpart += part2[j];
            }
          }
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part2.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = notHost.join(".") + rest;
            }
            this.hostname = validParts.join(".");
            break;
          }
        }
      }
    }
    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = "";
    }
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
    }
  }
  var hash = rest.indexOf("#");
  if (hash !== -1) {
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf("?");
  if (qm !== -1) {
    this.search = rest.substr(qm);
    rest = rest.slice(0, qm);
  }
  if (rest) {
    this.pathname = rest;
  }
  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = "";
  }
  return this;
};
Url.prototype.parseHost = function(host) {
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ":") {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) {
    this.hostname = host;
  }
};
var parse = urlParse;
mdurl$1.encode = encode_1;
mdurl$1.decode = decode_1;
mdurl$1.format = format$1;
mdurl$1.parse = parse;
var uc_micro = {};
var regex$3 = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var regex$2 = /[\0-\x1F\x7F-\x9F]/;
var regex$1 = /[\xAD\u0600-\u0605\u061C\u06DD\u070F\u08E2\u180E\u200B-\u200F\u202A-\u202E\u2060-\u2064\u2066-\u206F\uFEFF\uFFF9-\uFFFB]|\uD804[\uDCBD\uDCCD]|\uD82F[\uDCA0-\uDCA3]|\uD834[\uDD73-\uDD7A]|\uDB40[\uDC01\uDC20-\uDC7F]/;
var regex = /[ \xA0\u1680\u2000-\u200A\u2028\u2029\u202F\u205F\u3000]/;
uc_micro.Any = regex$3;
uc_micro.Cc = regex$2;
uc_micro.Cf = regex$1;
uc_micro.P = regex$4;
uc_micro.Z = regex;
(function(exports) {
  function _class2(obj) {
    return Object.prototype.toString.call(obj);
  }
  __name(_class2, "_class");
  function isString2(obj) {
    return _class2(obj) === "[object String]";
  }
  __name(isString2, "isString");
  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  function has2(object, key) {
    return _hasOwnProperty.call(object, key);
  }
  __name(has2, "has");
  function assign2(obj) {
    var sources = Array.prototype.slice.call(arguments, 1);
    sources.forEach(function(source) {
      if (!source) {
        return;
      }
      if (typeof source !== "object") {
        throw new TypeError(source + "must be object");
      }
      Object.keys(source).forEach(function(key) {
        obj[key] = source[key];
      });
    });
    return obj;
  }
  __name(assign2, "assign");
  function arrayReplaceAt2(src, pos, newElements) {
    return [].concat(src.slice(0, pos), newElements, src.slice(pos + 1));
  }
  __name(arrayReplaceAt2, "arrayReplaceAt");
  function isValidEntityCode2(c2) {
    if (c2 >= 55296 && c2 <= 57343) {
      return false;
    }
    if (c2 >= 64976 && c2 <= 65007) {
      return false;
    }
    if ((c2 & 65535) === 65535 || (c2 & 65535) === 65534) {
      return false;
    }
    if (c2 >= 0 && c2 <= 8) {
      return false;
    }
    if (c2 === 11) {
      return false;
    }
    if (c2 >= 14 && c2 <= 31) {
      return false;
    }
    if (c2 >= 127 && c2 <= 159) {
      return false;
    }
    if (c2 > 1114111) {
      return false;
    }
    return true;
  }
  __name(isValidEntityCode2, "isValidEntityCode");
  function fromCodePoint2(c2) {
    if (c2 > 65535) {
      c2 -= 65536;
      var surrogate1 = 55296 + (c2 >> 10), surrogate2 = 56320 + (c2 & 1023);
      return String.fromCharCode(surrogate1, surrogate2);
    }
    return String.fromCharCode(c2);
  }
  __name(fromCodePoint2, "fromCodePoint");
  var UNESCAPE_MD_RE = /\\([!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~])/g;
  var ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;
  var UNESCAPE_ALL_RE = new RegExp(UNESCAPE_MD_RE.source + "|" + ENTITY_RE.source, "gi");
  var DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;
  var entities2 = entities$1;
  function replaceEntityPattern(match2, name2) {
    var code3 = 0;
    if (has2(entities2, name2)) {
      return entities2[name2];
    }
    if (name2.charCodeAt(0) === 35 && DIGITAL_ENTITY_TEST_RE.test(name2)) {
      code3 = name2[1].toLowerCase() === "x" ? parseInt(name2.slice(2), 16) : parseInt(name2.slice(1), 10);
      if (isValidEntityCode2(code3)) {
        return fromCodePoint2(code3);
      }
    }
    return match2;
  }
  __name(replaceEntityPattern, "replaceEntityPattern");
  function unescapeMd(str) {
    if (str.indexOf("\\") < 0) {
      return str;
    }
    return str.replace(UNESCAPE_MD_RE, "$1");
  }
  __name(unescapeMd, "unescapeMd");
  function unescapeAll2(str) {
    if (str.indexOf("\\") < 0 && str.indexOf("&") < 0) {
      return str;
    }
    return str.replace(UNESCAPE_ALL_RE, function(match2, escaped, entity3) {
      if (escaped) {
        return escaped;
      }
      return replaceEntityPattern(match2, entity3);
    });
  }
  __name(unescapeAll2, "unescapeAll");
  var HTML_ESCAPE_TEST_RE = /[&<>"]/;
  var HTML_ESCAPE_REPLACE_RE = /[&<>"]/g;
  var HTML_REPLACEMENTS = {
    "&": "&amp;",
    "<": "&lt;",
    ">": "&gt;",
    '"': "&quot;"
  };
  function replaceUnsafeChar(ch) {
    return HTML_REPLACEMENTS[ch];
  }
  __name(replaceUnsafeChar, "replaceUnsafeChar");
  function escapeHtml2(str) {
    if (HTML_ESCAPE_TEST_RE.test(str)) {
      return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);
    }
    return str;
  }
  __name(escapeHtml2, "escapeHtml");
  var REGEXP_ESCAPE_RE = /[.?*+^$[\]\\(){}|-]/g;
  function escapeRE2(str) {
    return str.replace(REGEXP_ESCAPE_RE, "\\$&");
  }
  __name(escapeRE2, "escapeRE");
  function isSpace2(code3) {
    switch (code3) {
      case 9:
      case 32:
        return true;
    }
    return false;
  }
  __name(isSpace2, "isSpace");
  function isWhiteSpace2(code3) {
    if (code3 >= 8192 && code3 <= 8202) {
      return true;
    }
    switch (code3) {
      case 9:
      case 10:
      case 11:
      case 12:
      case 13:
      case 32:
      case 160:
      case 5760:
      case 8239:
      case 8287:
      case 12288:
        return true;
    }
    return false;
  }
  __name(isWhiteSpace2, "isWhiteSpace");
  var UNICODE_PUNCT_RE = regex$4;
  function isPunctChar2(ch) {
    return UNICODE_PUNCT_RE.test(ch);
  }
  __name(isPunctChar2, "isPunctChar");
  function isMdAsciiPunct2(ch) {
    switch (ch) {
      case 33:
      case 34:
      case 35:
      case 36:
      case 37:
      case 38:
      case 39:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
      case 45:
      case 46:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 94:
      case 95:
      case 96:
      case 123:
      case 124:
      case 125:
      case 126:
        return true;
      default:
        return false;
    }
  }
  __name(isMdAsciiPunct2, "isMdAsciiPunct");
  function normalizeReference2(str) {
    str = str.trim().replace(/\s+/g, " ");
    if ("\u1E9E".toLowerCase() === "\u1E7E") {
      str = str.replace(/ẞ/g, "\xDF");
    }
    return str.toLowerCase().toUpperCase();
  }
  __name(normalizeReference2, "normalizeReference");
  exports.lib = {};
  exports.lib.mdurl = mdurl$1;
  exports.lib.ucmicro = uc_micro;
  exports.assign = assign2;
  exports.isString = isString2;
  exports.has = has2;
  exports.unescapeMd = unescapeMd;
  exports.unescapeAll = unescapeAll2;
  exports.isValidEntityCode = isValidEntityCode2;
  exports.fromCodePoint = fromCodePoint2;
  exports.escapeHtml = escapeHtml2;
  exports.arrayReplaceAt = arrayReplaceAt2;
  exports.isSpace = isSpace2;
  exports.isWhiteSpace = isWhiteSpace2;
  exports.isMdAsciiPunct = isMdAsciiPunct2;
  exports.isPunctChar = isPunctChar2;
  exports.escapeRE = escapeRE2;
  exports.normalizeReference = normalizeReference2;
})(utils$1);
var helpers$1 = {};
var parse_link_label = /* @__PURE__ */ __name(function parseLinkLabel(state2, start, disableNested) {
  var level, found, marker2, prevPos, labelEnd = -1, max = state2.posMax, oldPos = state2.pos;
  state2.pos = start + 1;
  level = 1;
  while (state2.pos < max) {
    marker2 = state2.src.charCodeAt(state2.pos);
    if (marker2 === 93) {
      level--;
      if (level === 0) {
        found = true;
        break;
      }
    }
    prevPos = state2.pos;
    state2.md.inline.skipToken(state2);
    if (marker2 === 91) {
      if (prevPos === state2.pos - 1) {
        level++;
      } else if (disableNested) {
        state2.pos = oldPos;
        return -1;
      }
    }
  }
  if (found) {
    labelEnd = state2.pos;
  }
  state2.pos = oldPos;
  return labelEnd;
}, "parseLinkLabel");
var unescapeAll$2 = utils$1.unescapeAll;
var parse_link_destination = /* @__PURE__ */ __name(function parseLinkDestination(str, pos, max) {
  var code3, level, lines = 0, start = pos, result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (str.charCodeAt(pos) === 60) {
    pos++;
    while (pos < max) {
      code3 = str.charCodeAt(pos);
      if (code3 === 10) {
        return result;
      }
      if (code3 === 60) {
        return result;
      }
      if (code3 === 62) {
        result.pos = pos + 1;
        result.str = unescapeAll$2(str.slice(start + 1, pos));
        result.ok = true;
        return result;
      }
      if (code3 === 92 && pos + 1 < max) {
        pos += 2;
        continue;
      }
      pos++;
    }
    return result;
  }
  level = 0;
  while (pos < max) {
    code3 = str.charCodeAt(pos);
    if (code3 === 32) {
      break;
    }
    if (code3 < 32 || code3 === 127) {
      break;
    }
    if (code3 === 92 && pos + 1 < max) {
      if (str.charCodeAt(pos + 1) === 32) {
        break;
      }
      pos += 2;
      continue;
    }
    if (code3 === 40) {
      level++;
      if (level > 32) {
        return result;
      }
    }
    if (code3 === 41) {
      if (level === 0) {
        break;
      }
      level--;
    }
    pos++;
  }
  if (start === pos) {
    return result;
  }
  if (level !== 0) {
    return result;
  }
  result.str = unescapeAll$2(str.slice(start, pos));
  result.lines = lines;
  result.pos = pos;
  result.ok = true;
  return result;
}, "parseLinkDestination");
var unescapeAll$1 = utils$1.unescapeAll;
var parse_link_title = /* @__PURE__ */ __name(function parseLinkTitle(str, pos, max) {
  var code3, marker2, lines = 0, start = pos, result = {
    ok: false,
    pos: 0,
    lines: 0,
    str: ""
  };
  if (pos >= max) {
    return result;
  }
  marker2 = str.charCodeAt(pos);
  if (marker2 !== 34 && marker2 !== 39 && marker2 !== 40) {
    return result;
  }
  pos++;
  if (marker2 === 40) {
    marker2 = 41;
  }
  while (pos < max) {
    code3 = str.charCodeAt(pos);
    if (code3 === marker2) {
      result.pos = pos + 1;
      result.lines = lines;
      result.str = unescapeAll$1(str.slice(start + 1, pos));
      result.ok = true;
      return result;
    } else if (code3 === 40 && marker2 === 41) {
      return result;
    } else if (code3 === 10) {
      lines++;
    } else if (code3 === 92 && pos + 1 < max) {
      pos++;
      if (str.charCodeAt(pos) === 10) {
        lines++;
      }
    }
    pos++;
  }
  return result;
}, "parseLinkTitle");
helpers$1.parseLinkLabel = parse_link_label;
helpers$1.parseLinkDestination = parse_link_destination;
helpers$1.parseLinkTitle = parse_link_title;
var assign$1 = utils$1.assign;
var unescapeAll = utils$1.unescapeAll;
var escapeHtml = utils$1.escapeHtml;
var default_rules = {};
default_rules.code_inline = function(tokens, idx, options, env, slf) {
  var token2 = tokens[idx];
  return "<code" + slf.renderAttrs(token2) + ">" + escapeHtml(tokens[idx].content) + "</code>";
};
default_rules.code_block = function(tokens, idx, options, env, slf) {
  var token2 = tokens[idx];
  return "<pre" + slf.renderAttrs(token2) + "><code>" + escapeHtml(tokens[idx].content) + "</code></pre>\n";
};
default_rules.fence = function(tokens, idx, options, env, slf) {
  var token2 = tokens[idx], info2 = token2.info ? unescapeAll(token2.info).trim() : "", langName = "", langAttrs = "", highlighted, i, arr, tmpAttrs, tmpToken;
  if (info2) {
    arr = info2.split(/(\s+)/g);
    langName = arr[0];
    langAttrs = arr.slice(2).join("");
  }
  if (options.highlight) {
    highlighted = options.highlight(token2.content, langName, langAttrs) || escapeHtml(token2.content);
  } else {
    highlighted = escapeHtml(token2.content);
  }
  if (highlighted.indexOf("<pre") === 0) {
    return highlighted + "\n";
  }
  if (info2) {
    i = token2.attrIndex("class");
    tmpAttrs = token2.attrs ? token2.attrs.slice() : [];
    if (i < 0) {
      tmpAttrs.push(["class", options.langPrefix + langName]);
    } else {
      tmpAttrs[i] = tmpAttrs[i].slice();
      tmpAttrs[i][1] += " " + options.langPrefix + langName;
    }
    tmpToken = {
      attrs: tmpAttrs
    };
    return "<pre><code" + slf.renderAttrs(tmpToken) + ">" + highlighted + "</code></pre>\n";
  }
  return "<pre><code" + slf.renderAttrs(token2) + ">" + highlighted + "</code></pre>\n";
};
default_rules.image = function(tokens, idx, options, env, slf) {
  var token2 = tokens[idx];
  token2.attrs[token2.attrIndex("alt")][1] = slf.renderInlineAsText(token2.children, options, env);
  return slf.renderToken(tokens, idx, options);
};
default_rules.hardbreak = function(tokens, idx, options) {
  return options.xhtmlOut ? "<br />\n" : "<br>\n";
};
default_rules.softbreak = function(tokens, idx, options) {
  return options.breaks ? options.xhtmlOut ? "<br />\n" : "<br>\n" : "\n";
};
default_rules.text = function(tokens, idx) {
  return escapeHtml(tokens[idx].content);
};
default_rules.html_block = function(tokens, idx) {
  return tokens[idx].content;
};
default_rules.html_inline = function(tokens, idx) {
  return tokens[idx].content;
};
function Renderer$1() {
  this.rules = assign$1({}, default_rules);
}
__name(Renderer$1, "Renderer$1");
Renderer$1.prototype.renderAttrs = /* @__PURE__ */ __name(function renderAttrs(token2) {
  var i, l2, result;
  if (!token2.attrs) {
    return "";
  }
  result = "";
  for (i = 0, l2 = token2.attrs.length; i < l2; i++) {
    result += " " + escapeHtml(token2.attrs[i][0]) + '="' + escapeHtml(token2.attrs[i][1]) + '"';
  }
  return result;
}, "renderAttrs");
Renderer$1.prototype.renderToken = /* @__PURE__ */ __name(function renderToken(tokens, idx, options) {
  var nextToken, result = "", needLf = false, token2 = tokens[idx];
  if (token2.hidden) {
    return "";
  }
  if (token2.block && token2.nesting !== -1 && idx && tokens[idx - 1].hidden) {
    result += "\n";
  }
  result += (token2.nesting === -1 ? "</" : "<") + token2.tag;
  result += this.renderAttrs(token2);
  if (token2.nesting === 0 && options.xhtmlOut) {
    result += " /";
  }
  if (token2.block) {
    needLf = true;
    if (token2.nesting === 1) {
      if (idx + 1 < tokens.length) {
        nextToken = tokens[idx + 1];
        if (nextToken.type === "inline" || nextToken.hidden) {
          needLf = false;
        } else if (nextToken.nesting === -1 && nextToken.tag === token2.tag) {
          needLf = false;
        }
      }
    }
  }
  result += needLf ? ">\n" : ">";
  return result;
}, "renderToken");
Renderer$1.prototype.renderInline = function(tokens, options, env) {
  var type2, result = "", rules = this.rules;
  for (var i = 0, len = tokens.length; i < len; i++) {
    type2 = tokens[i].type;
    if (typeof rules[type2] !== "undefined") {
      result += rules[type2](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options);
    }
  }
  return result;
};
Renderer$1.prototype.renderInlineAsText = function(tokens, options, env) {
  var result = "";
  for (var i = 0, len = tokens.length; i < len; i++) {
    if (tokens[i].type === "text") {
      result += tokens[i].content;
    } else if (tokens[i].type === "image") {
      result += this.renderInlineAsText(tokens[i].children, options, env);
    } else if (tokens[i].type === "softbreak") {
      result += "\n";
    }
  }
  return result;
};
Renderer$1.prototype.render = function(tokens, options, env) {
  var i, len, type2, result = "", rules = this.rules;
  for (i = 0, len = tokens.length; i < len; i++) {
    type2 = tokens[i].type;
    if (type2 === "inline") {
      result += this.renderInline(tokens[i].children, options, env);
    } else if (typeof rules[type2] !== "undefined") {
      result += rules[tokens[i].type](tokens, i, options, env, this);
    } else {
      result += this.renderToken(tokens, i, options, env);
    }
  }
  return result;
};
var renderer = Renderer$1;
function Ruler$3() {
  this.__rules__ = [];
  this.__cache__ = null;
}
__name(Ruler$3, "Ruler$3");
Ruler$3.prototype.__find__ = function(name2) {
  for (var i = 0; i < this.__rules__.length; i++) {
    if (this.__rules__[i].name === name2) {
      return i;
    }
  }
  return -1;
};
Ruler$3.prototype.__compile__ = function() {
  var self2 = this;
  var chains = [""];
  self2.__rules__.forEach(function(rule) {
    if (!rule.enabled) {
      return;
    }
    rule.alt.forEach(function(altName) {
      if (chains.indexOf(altName) < 0) {
        chains.push(altName);
      }
    });
  });
  self2.__cache__ = {};
  chains.forEach(function(chain) {
    self2.__cache__[chain] = [];
    self2.__rules__.forEach(function(rule) {
      if (!rule.enabled) {
        return;
      }
      if (chain && rule.alt.indexOf(chain) < 0) {
        return;
      }
      self2.__cache__[chain].push(rule.fn);
    });
  });
};
Ruler$3.prototype.at = function(name2, fn, options) {
  var index = this.__find__(name2);
  var opt2 = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + name2);
  }
  this.__rules__[index].fn = fn;
  this.__rules__[index].alt = opt2.alt || [];
  this.__cache__ = null;
};
Ruler$3.prototype.before = function(beforeName, ruleName, fn, options) {
  var index = this.__find__(beforeName);
  var opt2 = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + beforeName);
  }
  this.__rules__.splice(index, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt2.alt || []
  });
  this.__cache__ = null;
};
Ruler$3.prototype.after = function(afterName, ruleName, fn, options) {
  var index = this.__find__(afterName);
  var opt2 = options || {};
  if (index === -1) {
    throw new Error("Parser rule not found: " + afterName);
  }
  this.__rules__.splice(index + 1, 0, {
    name: ruleName,
    enabled: true,
    fn,
    alt: opt2.alt || []
  });
  this.__cache__ = null;
};
Ruler$3.prototype.push = function(ruleName, fn, options) {
  var opt2 = options || {};
  this.__rules__.push({
    name: ruleName,
    enabled: true,
    fn,
    alt: opt2.alt || []
  });
  this.__cache__ = null;
};
Ruler$3.prototype.enable = function(list3, ignoreInvalid) {
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  var result = [];
  list3.forEach(function(name2) {
    var idx = this.__find__(name2);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name2);
    }
    this.__rules__[idx].enabled = true;
    result.push(name2);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler$3.prototype.enableOnly = function(list3, ignoreInvalid) {
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  this.__rules__.forEach(function(rule) {
    rule.enabled = false;
  });
  this.enable(list3, ignoreInvalid);
};
Ruler$3.prototype.disable = function(list3, ignoreInvalid) {
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  var result = [];
  list3.forEach(function(name2) {
    var idx = this.__find__(name2);
    if (idx < 0) {
      if (ignoreInvalid) {
        return;
      }
      throw new Error("Rules manager: invalid rule name " + name2);
    }
    this.__rules__[idx].enabled = false;
    result.push(name2);
  }, this);
  this.__cache__ = null;
  return result;
};
Ruler$3.prototype.getRules = function(chainName) {
  if (this.__cache__ === null) {
    this.__compile__();
  }
  return this.__cache__[chainName] || [];
};
var ruler = Ruler$3;
var NEWLINES_RE = /\r\n?|\n/g;
var NULL_RE = /\0/g;
var normalize = /* @__PURE__ */ __name(function normalize2(state2) {
  var str;
  str = state2.src.replace(NEWLINES_RE, "\n");
  str = str.replace(NULL_RE, "\uFFFD");
  state2.src = str;
}, "normalize");
var block = /* @__PURE__ */ __name(function block2(state2) {
  var token2;
  if (state2.inlineMode) {
    token2 = new state2.Token("inline", "", 0);
    token2.content = state2.src;
    token2.map = [0, 1];
    token2.children = [];
    state2.tokens.push(token2);
  } else {
    state2.md.block.parse(state2.src, state2.md, state2.env, state2.tokens);
  }
}, "block");
var inline = /* @__PURE__ */ __name(function inline2(state2) {
  var tokens = state2.tokens, tok, i, l2;
  for (i = 0, l2 = tokens.length; i < l2; i++) {
    tok = tokens[i];
    if (tok.type === "inline") {
      state2.md.inline.parse(tok.content, state2.md, state2.env, tok.children);
    }
  }
}, "inline");
var arrayReplaceAt = utils$1.arrayReplaceAt;
function isLinkOpen(str) {
  return /^<a[>\s]/i.test(str);
}
__name(isLinkOpen, "isLinkOpen");
function isLinkClose(str) {
  return /^<\/a\s*>/i.test(str);
}
__name(isLinkClose, "isLinkClose");
var linkify = /* @__PURE__ */ __name(function linkify2(state2) {
  var i, j, l2, tokens, token2, currentToken, nodes, ln, text3, pos, lastPos, level, htmlLinkLevel, url, fullUrl, urlText, blockTokens = state2.tokens, links;
  if (!state2.md.options.linkify) {
    return;
  }
  for (j = 0, l2 = blockTokens.length; j < l2; j++) {
    if (blockTokens[j].type !== "inline" || !state2.md.linkify.pretest(blockTokens[j].content)) {
      continue;
    }
    tokens = blockTokens[j].children;
    htmlLinkLevel = 0;
    for (i = tokens.length - 1; i >= 0; i--) {
      currentToken = tokens[i];
      if (currentToken.type === "link_close") {
        i--;
        while (tokens[i].level !== currentToken.level && tokens[i].type !== "link_open") {
          i--;
        }
        continue;
      }
      if (currentToken.type === "html_inline") {
        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {
          htmlLinkLevel--;
        }
        if (isLinkClose(currentToken.content)) {
          htmlLinkLevel++;
        }
      }
      if (htmlLinkLevel > 0) {
        continue;
      }
      if (currentToken.type === "text" && state2.md.linkify.test(currentToken.content)) {
        text3 = currentToken.content;
        links = state2.md.linkify.match(text3);
        nodes = [];
        level = currentToken.level;
        lastPos = 0;
        for (ln = 0; ln < links.length; ln++) {
          url = links[ln].url;
          fullUrl = state2.md.normalizeLink(url);
          if (!state2.md.validateLink(fullUrl)) {
            continue;
          }
          urlText = links[ln].text;
          if (!links[ln].schema) {
            urlText = state2.md.normalizeLinkText("http://" + urlText).replace(/^http:\/\//, "");
          } else if (links[ln].schema === "mailto:" && !/^mailto:/i.test(urlText)) {
            urlText = state2.md.normalizeLinkText("mailto:" + urlText).replace(/^mailto:/, "");
          } else {
            urlText = state2.md.normalizeLinkText(urlText);
          }
          pos = links[ln].index;
          if (pos > lastPos) {
            token2 = new state2.Token("text", "", 0);
            token2.content = text3.slice(lastPos, pos);
            token2.level = level;
            nodes.push(token2);
          }
          token2 = new state2.Token("link_open", "a", 1);
          token2.attrs = [["href", fullUrl]];
          token2.level = level++;
          token2.markup = "linkify";
          token2.info = "auto";
          nodes.push(token2);
          token2 = new state2.Token("text", "", 0);
          token2.content = urlText;
          token2.level = level;
          nodes.push(token2);
          token2 = new state2.Token("link_close", "a", -1);
          token2.level = --level;
          token2.markup = "linkify";
          token2.info = "auto";
          nodes.push(token2);
          lastPos = links[ln].lastIndex;
        }
        if (lastPos < text3.length) {
          token2 = new state2.Token("text", "", 0);
          token2.content = text3.slice(lastPos);
          token2.level = level;
          nodes.push(token2);
        }
        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);
      }
    }
  }
}, "linkify");
var RARE_RE = /\+-|\.\.|\?\?\?\?|!!!!|,,|--/;
var SCOPED_ABBR_TEST_RE = /\((c|tm|r|p)\)/i;
var SCOPED_ABBR_RE = /\((c|tm|r|p)\)/ig;
var SCOPED_ABBR = {
  c: "\xA9",
  r: "\xAE",
  p: "\xA7",
  tm: "\u2122"
};
function replaceFn(match2, name2) {
  return SCOPED_ABBR[name2.toLowerCase()];
}
__name(replaceFn, "replaceFn");
function replace_scoped(inlineTokens) {
  var i, token2, inside_autolink = 0;
  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token2 = inlineTokens[i];
    if (token2.type === "text" && !inside_autolink) {
      token2.content = token2.content.replace(SCOPED_ABBR_RE, replaceFn);
    }
    if (token2.type === "link_open" && token2.info === "auto") {
      inside_autolink--;
    }
    if (token2.type === "link_close" && token2.info === "auto") {
      inside_autolink++;
    }
  }
}
__name(replace_scoped, "replace_scoped");
function replace_rare(inlineTokens) {
  var i, token2, inside_autolink = 0;
  for (i = inlineTokens.length - 1; i >= 0; i--) {
    token2 = inlineTokens[i];
    if (token2.type === "text" && !inside_autolink) {
      if (RARE_RE.test(token2.content)) {
        token2.content = token2.content.replace(/\+-/g, "\xB1").replace(/\.{2,}/g, "\u2026").replace(/([?!])…/g, "$1..").replace(/([?!]){4,}/g, "$1$1$1").replace(/,{2,}/g, ",").replace(/(^|[^-])---(?=[^-]|$)/mg, "$1\u2014").replace(/(^|\s)--(?=\s|$)/mg, "$1\u2013").replace(/(^|[^-\s])--(?=[^-\s]|$)/mg, "$1\u2013");
      }
    }
    if (token2.type === "link_open" && token2.info === "auto") {
      inside_autolink--;
    }
    if (token2.type === "link_close" && token2.info === "auto") {
      inside_autolink++;
    }
  }
}
__name(replace_rare, "replace_rare");
var replacements = /* @__PURE__ */ __name(function replace(state2) {
  var blkIdx;
  if (!state2.md.options.typographer) {
    return;
  }
  for (blkIdx = state2.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state2.tokens[blkIdx].type !== "inline") {
      continue;
    }
    if (SCOPED_ABBR_TEST_RE.test(state2.tokens[blkIdx].content)) {
      replace_scoped(state2.tokens[blkIdx].children);
    }
    if (RARE_RE.test(state2.tokens[blkIdx].content)) {
      replace_rare(state2.tokens[blkIdx].children);
    }
  }
}, "replace");
var isWhiteSpace$1 = utils$1.isWhiteSpace;
var isPunctChar$1 = utils$1.isPunctChar;
var isMdAsciiPunct$1 = utils$1.isMdAsciiPunct;
var QUOTE_TEST_RE = /['"]/;
var QUOTE_RE = /['"]/g;
var APOSTROPHE = "\u2019";
function replaceAt(str, index, ch) {
  return str.substr(0, index) + ch + str.substr(index + 1);
}
__name(replaceAt, "replaceAt");
function process_inlines(tokens, state2) {
  var i, token2, text3, t2, pos, max, thisLevel, item, lastChar, nextChar, isLastPunctChar, isNextPunctChar, isLastWhiteSpace, isNextWhiteSpace, canOpen, canClose, j, isSingle, stack, openQuote, closeQuote;
  stack = [];
  for (i = 0; i < tokens.length; i++) {
    token2 = tokens[i];
    thisLevel = tokens[i].level;
    for (j = stack.length - 1; j >= 0; j--) {
      if (stack[j].level <= thisLevel) {
        break;
      }
    }
    stack.length = j + 1;
    if (token2.type !== "text") {
      continue;
    }
    text3 = token2.content;
    pos = 0;
    max = text3.length;
    OUTER:
      while (pos < max) {
        QUOTE_RE.lastIndex = pos;
        t2 = QUOTE_RE.exec(text3);
        if (!t2) {
          break;
        }
        canOpen = canClose = true;
        pos = t2.index + 1;
        isSingle = t2[0] === "'";
        lastChar = 32;
        if (t2.index - 1 >= 0) {
          lastChar = text3.charCodeAt(t2.index - 1);
        } else {
          for (j = i - 1; j >= 0; j--) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
              break;
            if (!tokens[j].content)
              continue;
            lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);
            break;
          }
        }
        nextChar = 32;
        if (pos < max) {
          nextChar = text3.charCodeAt(pos);
        } else {
          for (j = i + 1; j < tokens.length; j++) {
            if (tokens[j].type === "softbreak" || tokens[j].type === "hardbreak")
              break;
            if (!tokens[j].content)
              continue;
            nextChar = tokens[j].content.charCodeAt(0);
            break;
          }
        }
        isLastPunctChar = isMdAsciiPunct$1(lastChar) || isPunctChar$1(String.fromCharCode(lastChar));
        isNextPunctChar = isMdAsciiPunct$1(nextChar) || isPunctChar$1(String.fromCharCode(nextChar));
        isLastWhiteSpace = isWhiteSpace$1(lastChar);
        isNextWhiteSpace = isWhiteSpace$1(nextChar);
        if (isNextWhiteSpace) {
          canOpen = false;
        } else if (isNextPunctChar) {
          if (!(isLastWhiteSpace || isLastPunctChar)) {
            canOpen = false;
          }
        }
        if (isLastWhiteSpace) {
          canClose = false;
        } else if (isLastPunctChar) {
          if (!(isNextWhiteSpace || isNextPunctChar)) {
            canClose = false;
          }
        }
        if (nextChar === 34 && t2[0] === '"') {
          if (lastChar >= 48 && lastChar <= 57) {
            canClose = canOpen = false;
          }
        }
        if (canOpen && canClose) {
          canOpen = isLastPunctChar;
          canClose = isNextPunctChar;
        }
        if (!canOpen && !canClose) {
          if (isSingle) {
            token2.content = replaceAt(token2.content, t2.index, APOSTROPHE);
          }
          continue;
        }
        if (canClose) {
          for (j = stack.length - 1; j >= 0; j--) {
            item = stack[j];
            if (stack[j].level < thisLevel) {
              break;
            }
            if (item.single === isSingle && stack[j].level === thisLevel) {
              item = stack[j];
              if (isSingle) {
                openQuote = state2.md.options.quotes[2];
                closeQuote = state2.md.options.quotes[3];
              } else {
                openQuote = state2.md.options.quotes[0];
                closeQuote = state2.md.options.quotes[1];
              }
              token2.content = replaceAt(token2.content, t2.index, closeQuote);
              tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);
              pos += closeQuote.length - 1;
              if (item.token === i) {
                pos += openQuote.length - 1;
              }
              text3 = token2.content;
              max = text3.length;
              stack.length = j;
              continue OUTER;
            }
          }
        }
        if (canOpen) {
          stack.push({
            token: i,
            pos: t2.index,
            single: isSingle,
            level: thisLevel
          });
        } else if (canClose && isSingle) {
          token2.content = replaceAt(token2.content, t2.index, APOSTROPHE);
        }
      }
  }
}
__name(process_inlines, "process_inlines");
var smartquotes = /* @__PURE__ */ __name(function smartquotes2(state2) {
  var blkIdx;
  if (!state2.md.options.typographer) {
    return;
  }
  for (blkIdx = state2.tokens.length - 1; blkIdx >= 0; blkIdx--) {
    if (state2.tokens[blkIdx].type !== "inline" || !QUOTE_TEST_RE.test(state2.tokens[blkIdx].content)) {
      continue;
    }
    process_inlines(state2.tokens[blkIdx].children, state2);
  }
}, "smartquotes");
function Token$3(type2, tag, nesting) {
  this.type = type2;
  this.tag = tag;
  this.attrs = null;
  this.map = null;
  this.nesting = nesting;
  this.level = 0;
  this.children = null;
  this.content = "";
  this.markup = "";
  this.info = "";
  this.meta = null;
  this.block = false;
  this.hidden = false;
}
__name(Token$3, "Token$3");
Token$3.prototype.attrIndex = /* @__PURE__ */ __name(function attrIndex(name2) {
  var attrs, i, len;
  if (!this.attrs) {
    return -1;
  }
  attrs = this.attrs;
  for (i = 0, len = attrs.length; i < len; i++) {
    if (attrs[i][0] === name2) {
      return i;
    }
  }
  return -1;
}, "attrIndex");
Token$3.prototype.attrPush = /* @__PURE__ */ __name(function attrPush(attrData) {
  if (this.attrs) {
    this.attrs.push(attrData);
  } else {
    this.attrs = [attrData];
  }
}, "attrPush");
Token$3.prototype.attrSet = /* @__PURE__ */ __name(function attrSet(name2, value3) {
  var idx = this.attrIndex(name2), attrData = [name2, value3];
  if (idx < 0) {
    this.attrPush(attrData);
  } else {
    this.attrs[idx] = attrData;
  }
}, "attrSet");
Token$3.prototype.attrGet = /* @__PURE__ */ __name(function attrGet(name2) {
  var idx = this.attrIndex(name2), value3 = null;
  if (idx >= 0) {
    value3 = this.attrs[idx][1];
  }
  return value3;
}, "attrGet");
Token$3.prototype.attrJoin = /* @__PURE__ */ __name(function attrJoin(name2, value3) {
  var idx = this.attrIndex(name2);
  if (idx < 0) {
    this.attrPush([name2, value3]);
  } else {
    this.attrs[idx][1] = this.attrs[idx][1] + " " + value3;
  }
}, "attrJoin");
var token = Token$3;
var Token$2 = token;
function StateCore(src, md, env) {
  this.src = src;
  this.env = env;
  this.tokens = [];
  this.inlineMode = false;
  this.md = md;
}
__name(StateCore, "StateCore");
StateCore.prototype.Token = Token$2;
var state_core = StateCore;
var Ruler$2 = ruler;
var _rules$2 = [
  ["normalize", normalize],
  ["block", block],
  ["inline", inline],
  ["linkify", linkify],
  ["replacements", replacements],
  ["smartquotes", smartquotes]
];
function Core() {
  this.ruler = new Ruler$2();
  for (var i = 0; i < _rules$2.length; i++) {
    this.ruler.push(_rules$2[i][0], _rules$2[i][1]);
  }
}
__name(Core, "Core");
Core.prototype.process = function(state2) {
  var i, l2, rules;
  rules = this.ruler.getRules("");
  for (i = 0, l2 = rules.length; i < l2; i++) {
    rules[i](state2);
  }
};
Core.prototype.State = state_core;
var parser_core = Core;
var isSpace$a = utils$1.isSpace;
function getLine(state2, line) {
  var pos = state2.bMarks[line] + state2.tShift[line], max = state2.eMarks[line];
  return state2.src.substr(pos, max - pos);
}
__name(getLine, "getLine");
function escapedSplit(str) {
  var result = [], pos = 0, max = str.length, ch, isEscaped = false, lastPos = 0, current = "";
  ch = str.charCodeAt(pos);
  while (pos < max) {
    if (ch === 124) {
      if (!isEscaped) {
        result.push(current + str.substring(lastPos, pos));
        current = "";
        lastPos = pos + 1;
      } else {
        current += str.substring(lastPos, pos - 1);
        lastPos = pos;
      }
    }
    isEscaped = ch === 92;
    pos++;
    ch = str.charCodeAt(pos);
  }
  result.push(current + str.substring(lastPos));
  return result;
}
__name(escapedSplit, "escapedSplit");
var table = /* @__PURE__ */ __name(function table2(state2, startLine, endLine, silent) {
  var ch, lineText, pos, i, l2, nextLine, columns, columnCount, token2, aligns, t2, tableLines, tbodyLines, oldParentType, terminate, terminatorRules, firstCh, secondCh;
  if (startLine + 2 > endLine) {
    return false;
  }
  nextLine = startLine + 1;
  if (state2.sCount[nextLine] < state2.blkIndent) {
    return false;
  }
  if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
    return false;
  }
  pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
  if (pos >= state2.eMarks[nextLine]) {
    return false;
  }
  firstCh = state2.src.charCodeAt(pos++);
  if (firstCh !== 124 && firstCh !== 45 && firstCh !== 58) {
    return false;
  }
  if (pos >= state2.eMarks[nextLine]) {
    return false;
  }
  secondCh = state2.src.charCodeAt(pos++);
  if (secondCh !== 124 && secondCh !== 45 && secondCh !== 58 && !isSpace$a(secondCh)) {
    return false;
  }
  if (firstCh === 45 && isSpace$a(secondCh)) {
    return false;
  }
  while (pos < state2.eMarks[nextLine]) {
    ch = state2.src.charCodeAt(pos);
    if (ch !== 124 && ch !== 45 && ch !== 58 && !isSpace$a(ch)) {
      return false;
    }
    pos++;
  }
  lineText = getLine(state2, startLine + 1);
  columns = lineText.split("|");
  aligns = [];
  for (i = 0; i < columns.length; i++) {
    t2 = columns[i].trim();
    if (!t2) {
      if (i === 0 || i === columns.length - 1) {
        continue;
      } else {
        return false;
      }
    }
    if (!/^:?-+:?$/.test(t2)) {
      return false;
    }
    if (t2.charCodeAt(t2.length - 1) === 58) {
      aligns.push(t2.charCodeAt(0) === 58 ? "center" : "right");
    } else if (t2.charCodeAt(0) === 58) {
      aligns.push("left");
    } else {
      aligns.push("");
    }
  }
  lineText = getLine(state2, startLine).trim();
  if (lineText.indexOf("|") === -1) {
    return false;
  }
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  columns = escapedSplit(lineText);
  if (columns.length && columns[0] === "")
    columns.shift();
  if (columns.length && columns[columns.length - 1] === "")
    columns.pop();
  columnCount = columns.length;
  if (columnCount === 0 || columnCount !== aligns.length) {
    return false;
  }
  if (silent) {
    return true;
  }
  oldParentType = state2.parentType;
  state2.parentType = "table";
  terminatorRules = state2.md.block.ruler.getRules("blockquote");
  token2 = state2.push("table_open", "table", 1);
  token2.map = tableLines = [startLine, 0];
  token2 = state2.push("thead_open", "thead", 1);
  token2.map = [startLine, startLine + 1];
  token2 = state2.push("tr_open", "tr", 1);
  token2.map = [startLine, startLine + 1];
  for (i = 0; i < columns.length; i++) {
    token2 = state2.push("th_open", "th", 1);
    if (aligns[i]) {
      token2.attrs = [["style", "text-align:" + aligns[i]]];
    }
    token2 = state2.push("inline", "", 0);
    token2.content = columns[i].trim();
    token2.children = [];
    token2 = state2.push("th_close", "th", -1);
  }
  token2 = state2.push("tr_close", "tr", -1);
  token2 = state2.push("thead_close", "thead", -1);
  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {
    if (state2.sCount[nextLine] < state2.blkIndent) {
      break;
    }
    terminate = false;
    for (i = 0, l2 = terminatorRules.length; i < l2; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    lineText = getLine(state2, nextLine).trim();
    if (!lineText) {
      break;
    }
    if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
      break;
    }
    columns = escapedSplit(lineText);
    if (columns.length && columns[0] === "")
      columns.shift();
    if (columns.length && columns[columns.length - 1] === "")
      columns.pop();
    if (nextLine === startLine + 2) {
      token2 = state2.push("tbody_open", "tbody", 1);
      token2.map = tbodyLines = [startLine + 2, 0];
    }
    token2 = state2.push("tr_open", "tr", 1);
    token2.map = [nextLine, nextLine + 1];
    for (i = 0; i < columnCount; i++) {
      token2 = state2.push("td_open", "td", 1);
      if (aligns[i]) {
        token2.attrs = [["style", "text-align:" + aligns[i]]];
      }
      token2 = state2.push("inline", "", 0);
      token2.content = columns[i] ? columns[i].trim() : "";
      token2.children = [];
      token2 = state2.push("td_close", "td", -1);
    }
    token2 = state2.push("tr_close", "tr", -1);
  }
  if (tbodyLines) {
    token2 = state2.push("tbody_close", "tbody", -1);
    tbodyLines[1] = nextLine;
  }
  token2 = state2.push("table_close", "table", -1);
  tableLines[1] = nextLine;
  state2.parentType = oldParentType;
  state2.line = nextLine;
  return true;
}, "table");
var code = /* @__PURE__ */ __name(function code2(state2, startLine, endLine) {
  var nextLine, last, token2;
  if (state2.sCount[startLine] - state2.blkIndent < 4) {
    return false;
  }
  last = nextLine = startLine + 1;
  while (nextLine < endLine) {
    if (state2.isEmpty(nextLine)) {
      nextLine++;
      continue;
    }
    if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
      nextLine++;
      last = nextLine;
      continue;
    }
    break;
  }
  state2.line = last;
  token2 = state2.push("code_block", "code", 0);
  token2.content = state2.getLines(startLine, last, 4 + state2.blkIndent, false) + "\n";
  token2.map = [startLine, state2.line];
  return true;
}, "code");
var fence = /* @__PURE__ */ __name(function fence2(state2, startLine, endLine, silent) {
  var marker2, len, params, nextLine, mem, token2, markup, haveEndMarker = false, pos = state2.bMarks[startLine] + state2.tShift[startLine], max = state2.eMarks[startLine];
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (pos + 3 > max) {
    return false;
  }
  marker2 = state2.src.charCodeAt(pos);
  if (marker2 !== 126 && marker2 !== 96) {
    return false;
  }
  mem = pos;
  pos = state2.skipChars(pos, marker2);
  len = pos - mem;
  if (len < 3) {
    return false;
  }
  markup = state2.src.slice(mem, pos);
  params = state2.src.slice(pos, max);
  if (marker2 === 96) {
    if (params.indexOf(String.fromCharCode(marker2)) >= 0) {
      return false;
    }
  }
  if (silent) {
    return true;
  }
  nextLine = startLine;
  for (; ; ) {
    nextLine++;
    if (nextLine >= endLine) {
      break;
    }
    pos = mem = state2.bMarks[nextLine] + state2.tShift[nextLine];
    max = state2.eMarks[nextLine];
    if (pos < max && state2.sCount[nextLine] < state2.blkIndent) {
      break;
    }
    if (state2.src.charCodeAt(pos) !== marker2) {
      continue;
    }
    if (state2.sCount[nextLine] - state2.blkIndent >= 4) {
      continue;
    }
    pos = state2.skipChars(pos, marker2);
    if (pos - mem < len) {
      continue;
    }
    pos = state2.skipSpaces(pos);
    if (pos < max) {
      continue;
    }
    haveEndMarker = true;
    break;
  }
  len = state2.sCount[startLine];
  state2.line = nextLine + (haveEndMarker ? 1 : 0);
  token2 = state2.push("fence", "code", 0);
  token2.info = params;
  token2.content = state2.getLines(startLine + 1, nextLine, len, true);
  token2.markup = markup;
  token2.map = [startLine, state2.line];
  return true;
}, "fence");
var isSpace$9 = utils$1.isSpace;
var blockquote = /* @__PURE__ */ __name(function blockquote2(state2, startLine, endLine, silent) {
  var adjustTab, ch, i, initial, l2, lastLineEmpty, lines, nextLine, offset, oldBMarks, oldBSCount, oldIndent, oldParentType, oldSCount, oldTShift, spaceAfterMarker, terminate, terminatorRules, token2, isOutdented, oldLineMax = state2.lineMax, pos = state2.bMarks[startLine] + state2.tShift[startLine], max = state2.eMarks[startLine];
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (state2.src.charCodeAt(pos++) !== 62) {
    return false;
  }
  if (silent) {
    return true;
  }
  initial = offset = state2.sCount[startLine] + 1;
  if (state2.src.charCodeAt(pos) === 32) {
    pos++;
    initial++;
    offset++;
    adjustTab = false;
    spaceAfterMarker = true;
  } else if (state2.src.charCodeAt(pos) === 9) {
    spaceAfterMarker = true;
    if ((state2.bsCount[startLine] + offset) % 4 === 3) {
      pos++;
      initial++;
      offset++;
      adjustTab = false;
    } else {
      adjustTab = true;
    }
  } else {
    spaceAfterMarker = false;
  }
  oldBMarks = [state2.bMarks[startLine]];
  state2.bMarks[startLine] = pos;
  while (pos < max) {
    ch = state2.src.charCodeAt(pos);
    if (isSpace$9(ch)) {
      if (ch === 9) {
        offset += 4 - (offset + state2.bsCount[startLine] + (adjustTab ? 1 : 0)) % 4;
      } else {
        offset++;
      }
    } else {
      break;
    }
    pos++;
  }
  oldBSCount = [state2.bsCount[startLine]];
  state2.bsCount[startLine] = state2.sCount[startLine] + 1 + (spaceAfterMarker ? 1 : 0);
  lastLineEmpty = pos >= max;
  oldSCount = [state2.sCount[startLine]];
  state2.sCount[startLine] = offset - initial;
  oldTShift = [state2.tShift[startLine]];
  state2.tShift[startLine] = pos - state2.bMarks[startLine];
  terminatorRules = state2.md.block.ruler.getRules("blockquote");
  oldParentType = state2.parentType;
  state2.parentType = "blockquote";
  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {
    isOutdented = state2.sCount[nextLine] < state2.blkIndent;
    pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
    max = state2.eMarks[nextLine];
    if (pos >= max) {
      break;
    }
    if (state2.src.charCodeAt(pos++) === 62 && !isOutdented) {
      initial = offset = state2.sCount[nextLine] + 1;
      if (state2.src.charCodeAt(pos) === 32) {
        pos++;
        initial++;
        offset++;
        adjustTab = false;
        spaceAfterMarker = true;
      } else if (state2.src.charCodeAt(pos) === 9) {
        spaceAfterMarker = true;
        if ((state2.bsCount[nextLine] + offset) % 4 === 3) {
          pos++;
          initial++;
          offset++;
          adjustTab = false;
        } else {
          adjustTab = true;
        }
      } else {
        spaceAfterMarker = false;
      }
      oldBMarks.push(state2.bMarks[nextLine]);
      state2.bMarks[nextLine] = pos;
      while (pos < max) {
        ch = state2.src.charCodeAt(pos);
        if (isSpace$9(ch)) {
          if (ch === 9) {
            offset += 4 - (offset + state2.bsCount[nextLine] + (adjustTab ? 1 : 0)) % 4;
          } else {
            offset++;
          }
        } else {
          break;
        }
        pos++;
      }
      lastLineEmpty = pos >= max;
      oldBSCount.push(state2.bsCount[nextLine]);
      state2.bsCount[nextLine] = state2.sCount[nextLine] + 1 + (spaceAfterMarker ? 1 : 0);
      oldSCount.push(state2.sCount[nextLine]);
      state2.sCount[nextLine] = offset - initial;
      oldTShift.push(state2.tShift[nextLine]);
      state2.tShift[nextLine] = pos - state2.bMarks[nextLine];
      continue;
    }
    if (lastLineEmpty) {
      break;
    }
    terminate = false;
    for (i = 0, l2 = terminatorRules.length; i < l2; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      state2.lineMax = nextLine;
      if (state2.blkIndent !== 0) {
        oldBMarks.push(state2.bMarks[nextLine]);
        oldBSCount.push(state2.bsCount[nextLine]);
        oldTShift.push(state2.tShift[nextLine]);
        oldSCount.push(state2.sCount[nextLine]);
        state2.sCount[nextLine] -= state2.blkIndent;
      }
      break;
    }
    oldBMarks.push(state2.bMarks[nextLine]);
    oldBSCount.push(state2.bsCount[nextLine]);
    oldTShift.push(state2.tShift[nextLine]);
    oldSCount.push(state2.sCount[nextLine]);
    state2.sCount[nextLine] = -1;
  }
  oldIndent = state2.blkIndent;
  state2.blkIndent = 0;
  token2 = state2.push("blockquote_open", "blockquote", 1);
  token2.markup = ">";
  token2.map = lines = [startLine, 0];
  state2.md.block.tokenize(state2, startLine, nextLine);
  token2 = state2.push("blockquote_close", "blockquote", -1);
  token2.markup = ">";
  state2.lineMax = oldLineMax;
  state2.parentType = oldParentType;
  lines[1] = state2.line;
  for (i = 0; i < oldTShift.length; i++) {
    state2.bMarks[i + startLine] = oldBMarks[i];
    state2.tShift[i + startLine] = oldTShift[i];
    state2.sCount[i + startLine] = oldSCount[i];
    state2.bsCount[i + startLine] = oldBSCount[i];
  }
  state2.blkIndent = oldIndent;
  return true;
}, "blockquote");
var isSpace$8 = utils$1.isSpace;
var hr = /* @__PURE__ */ __name(function hr2(state2, startLine, endLine, silent) {
  var marker2, cnt, ch, token2, pos = state2.bMarks[startLine] + state2.tShift[startLine], max = state2.eMarks[startLine];
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  marker2 = state2.src.charCodeAt(pos++);
  if (marker2 !== 42 && marker2 !== 45 && marker2 !== 95) {
    return false;
  }
  cnt = 1;
  while (pos < max) {
    ch = state2.src.charCodeAt(pos++);
    if (ch !== marker2 && !isSpace$8(ch)) {
      return false;
    }
    if (ch === marker2) {
      cnt++;
    }
  }
  if (cnt < 3) {
    return false;
  }
  if (silent) {
    return true;
  }
  state2.line = startLine + 1;
  token2 = state2.push("hr", "hr", 0);
  token2.map = [startLine, state2.line];
  token2.markup = Array(cnt + 1).join(String.fromCharCode(marker2));
  return true;
}, "hr");
var isSpace$7 = utils$1.isSpace;
function skipBulletListMarker(state2, startLine) {
  var marker2, pos, max, ch;
  pos = state2.bMarks[startLine] + state2.tShift[startLine];
  max = state2.eMarks[startLine];
  marker2 = state2.src.charCodeAt(pos++);
  if (marker2 !== 42 && marker2 !== 45 && marker2 !== 43) {
    return -1;
  }
  if (pos < max) {
    ch = state2.src.charCodeAt(pos);
    if (!isSpace$7(ch)) {
      return -1;
    }
  }
  return pos;
}
__name(skipBulletListMarker, "skipBulletListMarker");
function skipOrderedListMarker(state2, startLine) {
  var ch, start = state2.bMarks[startLine] + state2.tShift[startLine], pos = start, max = state2.eMarks[startLine];
  if (pos + 1 >= max) {
    return -1;
  }
  ch = state2.src.charCodeAt(pos++);
  if (ch < 48 || ch > 57) {
    return -1;
  }
  for (; ; ) {
    if (pos >= max) {
      return -1;
    }
    ch = state2.src.charCodeAt(pos++);
    if (ch >= 48 && ch <= 57) {
      if (pos - start >= 10) {
        return -1;
      }
      continue;
    }
    if (ch === 41 || ch === 46) {
      break;
    }
    return -1;
  }
  if (pos < max) {
    ch = state2.src.charCodeAt(pos);
    if (!isSpace$7(ch)) {
      return -1;
    }
  }
  return pos;
}
__name(skipOrderedListMarker, "skipOrderedListMarker");
function markTightParagraphs(state2, idx) {
  var i, l2, level = state2.level + 2;
  for (i = idx + 2, l2 = state2.tokens.length - 2; i < l2; i++) {
    if (state2.tokens[i].level === level && state2.tokens[i].type === "paragraph_open") {
      state2.tokens[i + 2].hidden = true;
      state2.tokens[i].hidden = true;
      i += 2;
    }
  }
}
__name(markTightParagraphs, "markTightParagraphs");
var list = /* @__PURE__ */ __name(function list2(state2, startLine, endLine, silent) {
  var ch, contentStart, i, indent2, indentAfterMarker, initial, isOrdered, itemLines, l2, listLines, listTokIdx, markerCharCode, markerValue, max, nextLine, offset, oldListIndent, oldParentType, oldSCount, oldTShift, oldTight, pos, posAfterMarker, prevEmptyEnd, start, terminate, terminatorRules, token2, isTerminatingParagraph = false, tight = true;
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (state2.listIndent >= 0 && state2.sCount[startLine] - state2.listIndent >= 4 && state2.sCount[startLine] < state2.blkIndent) {
    return false;
  }
  if (silent && state2.parentType === "paragraph") {
    if (state2.tShift[startLine] >= state2.blkIndent) {
      isTerminatingParagraph = true;
    }
  }
  if ((posAfterMarker = skipOrderedListMarker(state2, startLine)) >= 0) {
    isOrdered = true;
    start = state2.bMarks[startLine] + state2.tShift[startLine];
    markerValue = Number(state2.src.slice(start, posAfterMarker - 1));
    if (isTerminatingParagraph && markerValue !== 1)
      return false;
  } else if ((posAfterMarker = skipBulletListMarker(state2, startLine)) >= 0) {
    isOrdered = false;
  } else {
    return false;
  }
  if (isTerminatingParagraph) {
    if (state2.skipSpaces(posAfterMarker) >= state2.eMarks[startLine])
      return false;
  }
  markerCharCode = state2.src.charCodeAt(posAfterMarker - 1);
  if (silent) {
    return true;
  }
  listTokIdx = state2.tokens.length;
  if (isOrdered) {
    token2 = state2.push("ordered_list_open", "ol", 1);
    if (markerValue !== 1) {
      token2.attrs = [["start", markerValue]];
    }
  } else {
    token2 = state2.push("bullet_list_open", "ul", 1);
  }
  token2.map = listLines = [startLine, 0];
  token2.markup = String.fromCharCode(markerCharCode);
  nextLine = startLine;
  prevEmptyEnd = false;
  terminatorRules = state2.md.block.ruler.getRules("list");
  oldParentType = state2.parentType;
  state2.parentType = "list";
  while (nextLine < endLine) {
    pos = posAfterMarker;
    max = state2.eMarks[nextLine];
    initial = offset = state2.sCount[nextLine] + posAfterMarker - (state2.bMarks[startLine] + state2.tShift[startLine]);
    while (pos < max) {
      ch = state2.src.charCodeAt(pos);
      if (ch === 9) {
        offset += 4 - (offset + state2.bsCount[nextLine]) % 4;
      } else if (ch === 32) {
        offset++;
      } else {
        break;
      }
      pos++;
    }
    contentStart = pos;
    if (contentStart >= max) {
      indentAfterMarker = 1;
    } else {
      indentAfterMarker = offset - initial;
    }
    if (indentAfterMarker > 4) {
      indentAfterMarker = 1;
    }
    indent2 = initial + indentAfterMarker;
    token2 = state2.push("list_item_open", "li", 1);
    token2.markup = String.fromCharCode(markerCharCode);
    token2.map = itemLines = [startLine, 0];
    if (isOrdered) {
      token2.info = state2.src.slice(start, posAfterMarker - 1);
    }
    oldTight = state2.tight;
    oldTShift = state2.tShift[startLine];
    oldSCount = state2.sCount[startLine];
    oldListIndent = state2.listIndent;
    state2.listIndent = state2.blkIndent;
    state2.blkIndent = indent2;
    state2.tight = true;
    state2.tShift[startLine] = contentStart - state2.bMarks[startLine];
    state2.sCount[startLine] = offset;
    if (contentStart >= max && state2.isEmpty(startLine + 1)) {
      state2.line = Math.min(state2.line + 2, endLine);
    } else {
      state2.md.block.tokenize(state2, startLine, endLine, true);
    }
    if (!state2.tight || prevEmptyEnd) {
      tight = false;
    }
    prevEmptyEnd = state2.line - startLine > 1 && state2.isEmpty(state2.line - 1);
    state2.blkIndent = state2.listIndent;
    state2.listIndent = oldListIndent;
    state2.tShift[startLine] = oldTShift;
    state2.sCount[startLine] = oldSCount;
    state2.tight = oldTight;
    token2 = state2.push("list_item_close", "li", -1);
    token2.markup = String.fromCharCode(markerCharCode);
    nextLine = startLine = state2.line;
    itemLines[1] = nextLine;
    contentStart = state2.bMarks[startLine];
    if (nextLine >= endLine) {
      break;
    }
    if (state2.sCount[nextLine] < state2.blkIndent) {
      break;
    }
    if (state2.sCount[startLine] - state2.blkIndent >= 4) {
      break;
    }
    terminate = false;
    for (i = 0, l2 = terminatorRules.length; i < l2; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
    if (isOrdered) {
      posAfterMarker = skipOrderedListMarker(state2, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
      start = state2.bMarks[nextLine] + state2.tShift[nextLine];
    } else {
      posAfterMarker = skipBulletListMarker(state2, nextLine);
      if (posAfterMarker < 0) {
        break;
      }
    }
    if (markerCharCode !== state2.src.charCodeAt(posAfterMarker - 1)) {
      break;
    }
  }
  if (isOrdered) {
    token2 = state2.push("ordered_list_close", "ol", -1);
  } else {
    token2 = state2.push("bullet_list_close", "ul", -1);
  }
  token2.markup = String.fromCharCode(markerCharCode);
  listLines[1] = nextLine;
  state2.line = nextLine;
  state2.parentType = oldParentType;
  if (tight) {
    markTightParagraphs(state2, listTokIdx);
  }
  return true;
}, "list");
var normalizeReference$2 = utils$1.normalizeReference;
var isSpace$6 = utils$1.isSpace;
var reference = /* @__PURE__ */ __name(function reference2(state2, startLine, _endLine, silent) {
  var ch, destEndPos, destEndLineNo, endLine, href, i, l2, label, labelEnd, oldParentType, res, start, str, terminate, terminatorRules, title, lines = 0, pos = state2.bMarks[startLine] + state2.tShift[startLine], max = state2.eMarks[startLine], nextLine = startLine + 1;
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (state2.src.charCodeAt(pos) !== 91) {
    return false;
  }
  while (++pos < max) {
    if (state2.src.charCodeAt(pos) === 93 && state2.src.charCodeAt(pos - 1) !== 92) {
      if (pos + 1 === max) {
        return false;
      }
      if (state2.src.charCodeAt(pos + 1) !== 58) {
        return false;
      }
      break;
    }
  }
  endLine = state2.lineMax;
  terminatorRules = state2.md.block.ruler.getRules("reference");
  oldParentType = state2.parentType;
  state2.parentType = "reference";
  for (; nextLine < endLine && !state2.isEmpty(nextLine); nextLine++) {
    if (state2.sCount[nextLine] - state2.blkIndent > 3) {
      continue;
    }
    if (state2.sCount[nextLine] < 0) {
      continue;
    }
    terminate = false;
    for (i = 0, l2 = terminatorRules.length; i < l2; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  str = state2.getLines(startLine, nextLine, state2.blkIndent, false).trim();
  max = str.length;
  for (pos = 1; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 91) {
      return false;
    } else if (ch === 93) {
      labelEnd = pos;
      break;
    } else if (ch === 10) {
      lines++;
    } else if (ch === 92) {
      pos++;
      if (pos < max && str.charCodeAt(pos) === 10) {
        lines++;
      }
    }
  }
  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 58) {
    return false;
  }
  for (pos = labelEnd + 2; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 10) {
      lines++;
    } else if (isSpace$6(ch))
      ;
    else {
      break;
    }
  }
  res = state2.md.helpers.parseLinkDestination(str, pos, max);
  if (!res.ok) {
    return false;
  }
  href = state2.md.normalizeLink(res.str);
  if (!state2.md.validateLink(href)) {
    return false;
  }
  pos = res.pos;
  lines += res.lines;
  destEndPos = pos;
  destEndLineNo = lines;
  start = pos;
  for (; pos < max; pos++) {
    ch = str.charCodeAt(pos);
    if (ch === 10) {
      lines++;
    } else if (isSpace$6(ch))
      ;
    else {
      break;
    }
  }
  res = state2.md.helpers.parseLinkTitle(str, pos, max);
  if (pos < max && start !== pos && res.ok) {
    title = res.str;
    pos = res.pos;
    lines += res.lines;
  } else {
    title = "";
    pos = destEndPos;
    lines = destEndLineNo;
  }
  while (pos < max) {
    ch = str.charCodeAt(pos);
    if (!isSpace$6(ch)) {
      break;
    }
    pos++;
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    if (title) {
      title = "";
      pos = destEndPos;
      lines = destEndLineNo;
      while (pos < max) {
        ch = str.charCodeAt(pos);
        if (!isSpace$6(ch)) {
          break;
        }
        pos++;
      }
    }
  }
  if (pos < max && str.charCodeAt(pos) !== 10) {
    return false;
  }
  label = normalizeReference$2(str.slice(1, labelEnd));
  if (!label) {
    return false;
  }
  if (silent) {
    return true;
  }
  if (typeof state2.env.references === "undefined") {
    state2.env.references = {};
  }
  if (typeof state2.env.references[label] === "undefined") {
    state2.env.references[label] = { title, href };
  }
  state2.parentType = oldParentType;
  state2.line = startLine + lines + 1;
  return true;
}, "reference");
var html_blocks = [
  "address",
  "article",
  "aside",
  "base",
  "basefont",
  "blockquote",
  "body",
  "caption",
  "center",
  "col",
  "colgroup",
  "dd",
  "details",
  "dialog",
  "dir",
  "div",
  "dl",
  "dt",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "frame",
  "frameset",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hr",
  "html",
  "iframe",
  "legend",
  "li",
  "link",
  "main",
  "menu",
  "menuitem",
  "nav",
  "noframes",
  "ol",
  "optgroup",
  "option",
  "p",
  "param",
  "section",
  "source",
  "summary",
  "table",
  "tbody",
  "td",
  "tfoot",
  "th",
  "thead",
  "title",
  "tr",
  "track",
  "ul"
];
var html_re = {};
var attr_name = "[a-zA-Z_:][a-zA-Z0-9:._-]*";
var unquoted = "[^\"'=<>`\\x00-\\x20]+";
var single_quoted = "'[^']*'";
var double_quoted = '"[^"]*"';
var attr_value = "(?:" + unquoted + "|" + single_quoted + "|" + double_quoted + ")";
var attribute = "(?:\\s+" + attr_name + "(?:\\s*=\\s*" + attr_value + ")?)";
var open_tag = "<[A-Za-z][A-Za-z0-9\\-]*" + attribute + "*\\s*\\/?>";
var close_tag = "<\\/[A-Za-z][A-Za-z0-9\\-]*\\s*>";
var comment = "<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->";
var processing = "<[?][\\s\\S]*?[?]>";
var declaration = "<![A-Z]+\\s+[^>]*>";
var cdata = "<!\\[CDATA\\[[\\s\\S]*?\\]\\]>";
var HTML_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + "|" + comment + "|" + processing + "|" + declaration + "|" + cdata + ")");
var HTML_OPEN_CLOSE_TAG_RE$1 = new RegExp("^(?:" + open_tag + "|" + close_tag + ")");
html_re.HTML_TAG_RE = HTML_TAG_RE$1;
html_re.HTML_OPEN_CLOSE_TAG_RE = HTML_OPEN_CLOSE_TAG_RE$1;
var block_names = html_blocks;
var HTML_OPEN_CLOSE_TAG_RE = html_re.HTML_OPEN_CLOSE_TAG_RE;
var HTML_SEQUENCES = [
  [/^<(script|pre|style|textarea)(?=(\s|>|$))/i, /<\/(script|pre|style|textarea)>/i, true],
  [/^<!--/, /-->/, true],
  [/^<\?/, /\?>/, true],
  [/^<![A-Z]/, />/, true],
  [/^<!\[CDATA\[/, /\]\]>/, true],
  [new RegExp("^</?(" + block_names.join("|") + ")(?=(\\s|/?>|$))", "i"), /^$/, true],
  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + "\\s*$"), /^$/, false]
];
var html_block = /* @__PURE__ */ __name(function html_block2(state2, startLine, endLine, silent) {
  var i, nextLine, token2, lineText, pos = state2.bMarks[startLine] + state2.tShift[startLine], max = state2.eMarks[startLine];
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  if (!state2.md.options.html) {
    return false;
  }
  if (state2.src.charCodeAt(pos) !== 60) {
    return false;
  }
  lineText = state2.src.slice(pos, max);
  for (i = 0; i < HTML_SEQUENCES.length; i++) {
    if (HTML_SEQUENCES[i][0].test(lineText)) {
      break;
    }
  }
  if (i === HTML_SEQUENCES.length) {
    return false;
  }
  if (silent) {
    return HTML_SEQUENCES[i][2];
  }
  nextLine = startLine + 1;
  if (!HTML_SEQUENCES[i][1].test(lineText)) {
    for (; nextLine < endLine; nextLine++) {
      if (state2.sCount[nextLine] < state2.blkIndent) {
        break;
      }
      pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
      max = state2.eMarks[nextLine];
      lineText = state2.src.slice(pos, max);
      if (HTML_SEQUENCES[i][1].test(lineText)) {
        if (lineText.length !== 0) {
          nextLine++;
        }
        break;
      }
    }
  }
  state2.line = nextLine;
  token2 = state2.push("html_block", "", 0);
  token2.map = [startLine, nextLine];
  token2.content = state2.getLines(startLine, nextLine, state2.blkIndent, true);
  return true;
}, "html_block");
var isSpace$5 = utils$1.isSpace;
var heading = /* @__PURE__ */ __name(function heading2(state2, startLine, endLine, silent) {
  var ch, level, tmp, token2, pos = state2.bMarks[startLine] + state2.tShift[startLine], max = state2.eMarks[startLine];
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  ch = state2.src.charCodeAt(pos);
  if (ch !== 35 || pos >= max) {
    return false;
  }
  level = 1;
  ch = state2.src.charCodeAt(++pos);
  while (ch === 35 && pos < max && level <= 6) {
    level++;
    ch = state2.src.charCodeAt(++pos);
  }
  if (level > 6 || pos < max && !isSpace$5(ch)) {
    return false;
  }
  if (silent) {
    return true;
  }
  max = state2.skipSpacesBack(max, pos);
  tmp = state2.skipCharsBack(max, 35, pos);
  if (tmp > pos && isSpace$5(state2.src.charCodeAt(tmp - 1))) {
    max = tmp;
  }
  state2.line = startLine + 1;
  token2 = state2.push("heading_open", "h" + String(level), 1);
  token2.markup = "########".slice(0, level);
  token2.map = [startLine, state2.line];
  token2 = state2.push("inline", "", 0);
  token2.content = state2.src.slice(pos, max).trim();
  token2.map = [startLine, state2.line];
  token2.children = [];
  token2 = state2.push("heading_close", "h" + String(level), -1);
  token2.markup = "########".slice(0, level);
  return true;
}, "heading");
var lheading = /* @__PURE__ */ __name(function lheading2(state2, startLine, endLine) {
  var content, terminate, i, l2, token2, pos, max, level, marker2, nextLine = startLine + 1, oldParentType, terminatorRules = state2.md.block.ruler.getRules("paragraph");
  if (state2.sCount[startLine] - state2.blkIndent >= 4) {
    return false;
  }
  oldParentType = state2.parentType;
  state2.parentType = "paragraph";
  for (; nextLine < endLine && !state2.isEmpty(nextLine); nextLine++) {
    if (state2.sCount[nextLine] - state2.blkIndent > 3) {
      continue;
    }
    if (state2.sCount[nextLine] >= state2.blkIndent) {
      pos = state2.bMarks[nextLine] + state2.tShift[nextLine];
      max = state2.eMarks[nextLine];
      if (pos < max) {
        marker2 = state2.src.charCodeAt(pos);
        if (marker2 === 45 || marker2 === 61) {
          pos = state2.skipChars(pos, marker2);
          pos = state2.skipSpaces(pos);
          if (pos >= max) {
            level = marker2 === 61 ? 1 : 2;
            break;
          }
        }
      }
    }
    if (state2.sCount[nextLine] < 0) {
      continue;
    }
    terminate = false;
    for (i = 0, l2 = terminatorRules.length; i < l2; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  if (!level) {
    return false;
  }
  content = state2.getLines(startLine, nextLine, state2.blkIndent, false).trim();
  state2.line = nextLine + 1;
  token2 = state2.push("heading_open", "h" + String(level), 1);
  token2.markup = String.fromCharCode(marker2);
  token2.map = [startLine, state2.line];
  token2 = state2.push("inline", "", 0);
  token2.content = content;
  token2.map = [startLine, state2.line - 1];
  token2.children = [];
  token2 = state2.push("heading_close", "h" + String(level), -1);
  token2.markup = String.fromCharCode(marker2);
  state2.parentType = oldParentType;
  return true;
}, "lheading");
var paragraph = /* @__PURE__ */ __name(function paragraph2(state2, startLine) {
  var content, terminate, i, l2, token2, oldParentType, nextLine = startLine + 1, terminatorRules = state2.md.block.ruler.getRules("paragraph"), endLine = state2.lineMax;
  oldParentType = state2.parentType;
  state2.parentType = "paragraph";
  for (; nextLine < endLine && !state2.isEmpty(nextLine); nextLine++) {
    if (state2.sCount[nextLine] - state2.blkIndent > 3) {
      continue;
    }
    if (state2.sCount[nextLine] < 0) {
      continue;
    }
    terminate = false;
    for (i = 0, l2 = terminatorRules.length; i < l2; i++) {
      if (terminatorRules[i](state2, nextLine, endLine, true)) {
        terminate = true;
        break;
      }
    }
    if (terminate) {
      break;
    }
  }
  content = state2.getLines(startLine, nextLine, state2.blkIndent, false).trim();
  state2.line = nextLine;
  token2 = state2.push("paragraph_open", "p", 1);
  token2.map = [startLine, state2.line];
  token2 = state2.push("inline", "", 0);
  token2.content = content;
  token2.map = [startLine, state2.line];
  token2.children = [];
  token2 = state2.push("paragraph_close", "p", -1);
  state2.parentType = oldParentType;
  return true;
}, "paragraph");
var Token$1 = token;
var isSpace$4 = utils$1.isSpace;
function StateBlock(src, md, env, tokens) {
  var ch, s2, start, pos, len, indent2, offset, indent_found;
  this.src = src;
  this.md = md;
  this.env = env;
  this.tokens = tokens;
  this.bMarks = [];
  this.eMarks = [];
  this.tShift = [];
  this.sCount = [];
  this.bsCount = [];
  this.blkIndent = 0;
  this.line = 0;
  this.lineMax = 0;
  this.tight = false;
  this.ddIndent = -1;
  this.listIndent = -1;
  this.parentType = "root";
  this.level = 0;
  this.result = "";
  s2 = this.src;
  indent_found = false;
  for (start = pos = indent2 = offset = 0, len = s2.length; pos < len; pos++) {
    ch = s2.charCodeAt(pos);
    if (!indent_found) {
      if (isSpace$4(ch)) {
        indent2++;
        if (ch === 9) {
          offset += 4 - offset % 4;
        } else {
          offset++;
        }
        continue;
      } else {
        indent_found = true;
      }
    }
    if (ch === 10 || pos === len - 1) {
      if (ch !== 10) {
        pos++;
      }
      this.bMarks.push(start);
      this.eMarks.push(pos);
      this.tShift.push(indent2);
      this.sCount.push(offset);
      this.bsCount.push(0);
      indent_found = false;
      indent2 = 0;
      offset = 0;
      start = pos + 1;
    }
  }
  this.bMarks.push(s2.length);
  this.eMarks.push(s2.length);
  this.tShift.push(0);
  this.sCount.push(0);
  this.bsCount.push(0);
  this.lineMax = this.bMarks.length - 1;
}
__name(StateBlock, "StateBlock");
StateBlock.prototype.push = function(type2, tag, nesting) {
  var token2 = new Token$1(type2, tag, nesting);
  token2.block = true;
  if (nesting < 0)
    this.level--;
  token2.level = this.level;
  if (nesting > 0)
    this.level++;
  this.tokens.push(token2);
  return token2;
};
StateBlock.prototype.isEmpty = /* @__PURE__ */ __name(function isEmpty(line) {
  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];
}, "isEmpty");
StateBlock.prototype.skipEmptyLines = /* @__PURE__ */ __name(function skipEmptyLines(from) {
  for (var max = this.lineMax; from < max; from++) {
    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {
      break;
    }
  }
  return from;
}, "skipEmptyLines");
StateBlock.prototype.skipSpaces = /* @__PURE__ */ __name(function skipSpaces(pos) {
  var ch;
  for (var max = this.src.length; pos < max; pos++) {
    ch = this.src.charCodeAt(pos);
    if (!isSpace$4(ch)) {
      break;
    }
  }
  return pos;
}, "skipSpaces");
StateBlock.prototype.skipSpacesBack = /* @__PURE__ */ __name(function skipSpacesBack(pos, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (!isSpace$4(this.src.charCodeAt(--pos))) {
      return pos + 1;
    }
  }
  return pos;
}, "skipSpacesBack");
StateBlock.prototype.skipChars = /* @__PURE__ */ __name(function skipChars(pos, code3) {
  for (var max = this.src.length; pos < max; pos++) {
    if (this.src.charCodeAt(pos) !== code3) {
      break;
    }
  }
  return pos;
}, "skipChars");
StateBlock.prototype.skipCharsBack = /* @__PURE__ */ __name(function skipCharsBack(pos, code3, min) {
  if (pos <= min) {
    return pos;
  }
  while (pos > min) {
    if (code3 !== this.src.charCodeAt(--pos)) {
      return pos + 1;
    }
  }
  return pos;
}, "skipCharsBack");
StateBlock.prototype.getLines = /* @__PURE__ */ __name(function getLines(begin, end, indent2, keepLastLF) {
  var i, lineIndent, ch, first, last, queue, lineStart, line = begin;
  if (begin >= end) {
    return "";
  }
  queue = new Array(end - begin);
  for (i = 0; line < end; line++, i++) {
    lineIndent = 0;
    lineStart = first = this.bMarks[line];
    if (line + 1 < end || keepLastLF) {
      last = this.eMarks[line] + 1;
    } else {
      last = this.eMarks[line];
    }
    while (first < last && lineIndent < indent2) {
      ch = this.src.charCodeAt(first);
      if (isSpace$4(ch)) {
        if (ch === 9) {
          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;
        } else {
          lineIndent++;
        }
      } else if (first - lineStart < this.tShift[line]) {
        lineIndent++;
      } else {
        break;
      }
      first++;
    }
    if (lineIndent > indent2) {
      queue[i] = new Array(lineIndent - indent2 + 1).join(" ") + this.src.slice(first, last);
    } else {
      queue[i] = this.src.slice(first, last);
    }
  }
  return queue.join("");
}, "getLines");
StateBlock.prototype.Token = Token$1;
var state_block = StateBlock;
var Ruler$1 = ruler;
var _rules$1 = [
  ["table", table, ["paragraph", "reference"]],
  ["code", code],
  ["fence", fence, ["paragraph", "reference", "blockquote", "list"]],
  ["blockquote", blockquote, ["paragraph", "reference", "blockquote", "list"]],
  ["hr", hr, ["paragraph", "reference", "blockquote", "list"]],
  ["list", list, ["paragraph", "reference", "blockquote"]],
  ["reference", reference],
  ["html_block", html_block, ["paragraph", "reference", "blockquote"]],
  ["heading", heading, ["paragraph", "reference", "blockquote"]],
  ["lheading", lheading],
  ["paragraph", paragraph]
];
function ParserBlock$1() {
  this.ruler = new Ruler$1();
  for (var i = 0; i < _rules$1.length; i++) {
    this.ruler.push(_rules$1[i][0], _rules$1[i][1], { alt: (_rules$1[i][2] || []).slice() });
  }
}
__name(ParserBlock$1, "ParserBlock$1");
ParserBlock$1.prototype.tokenize = function(state2, startLine, endLine) {
  var ok, i, rules = this.ruler.getRules(""), len = rules.length, line = startLine, hasEmptyLines = false, maxNesting = state2.md.options.maxNesting;
  while (line < endLine) {
    state2.line = line = state2.skipEmptyLines(line);
    if (line >= endLine) {
      break;
    }
    if (state2.sCount[line] < state2.blkIndent) {
      break;
    }
    if (state2.level >= maxNesting) {
      state2.line = endLine;
      break;
    }
    for (i = 0; i < len; i++) {
      ok = rules[i](state2, line, endLine, false);
      if (ok) {
        break;
      }
    }
    state2.tight = !hasEmptyLines;
    if (state2.isEmpty(state2.line - 1)) {
      hasEmptyLines = true;
    }
    line = state2.line;
    if (line < endLine && state2.isEmpty(line)) {
      hasEmptyLines = true;
      line++;
      state2.line = line;
    }
  }
};
ParserBlock$1.prototype.parse = function(src, md, env, outTokens) {
  var state2;
  if (!src) {
    return;
  }
  state2 = new this.State(src, md, env, outTokens);
  this.tokenize(state2, state2.line, state2.lineMax);
};
ParserBlock$1.prototype.State = state_block;
var parser_block = ParserBlock$1;
function isTerminatorChar(ch) {
  switch (ch) {
    case 10:
    case 33:
    case 35:
    case 36:
    case 37:
    case 38:
    case 42:
    case 43:
    case 45:
    case 58:
    case 60:
    case 61:
    case 62:
    case 64:
    case 91:
    case 92:
    case 93:
    case 94:
    case 95:
    case 96:
    case 123:
    case 125:
    case 126:
      return true;
    default:
      return false;
  }
}
__name(isTerminatorChar, "isTerminatorChar");
var text = /* @__PURE__ */ __name(function text2(state2, silent) {
  var pos = state2.pos;
  while (pos < state2.posMax && !isTerminatorChar(state2.src.charCodeAt(pos))) {
    pos++;
  }
  if (pos === state2.pos) {
    return false;
  }
  if (!silent) {
    state2.pending += state2.src.slice(state2.pos, pos);
  }
  state2.pos = pos;
  return true;
}, "text");
var isSpace$3 = utils$1.isSpace;
var newline = /* @__PURE__ */ __name(function newline2(state2, silent) {
  var pmax, max, pos = state2.pos;
  if (state2.src.charCodeAt(pos) !== 10) {
    return false;
  }
  pmax = state2.pending.length - 1;
  max = state2.posMax;
  if (!silent) {
    if (pmax >= 0 && state2.pending.charCodeAt(pmax) === 32) {
      if (pmax >= 1 && state2.pending.charCodeAt(pmax - 1) === 32) {
        state2.pending = state2.pending.replace(/ +$/, "");
        state2.push("hardbreak", "br", 0);
      } else {
        state2.pending = state2.pending.slice(0, -1);
        state2.push("softbreak", "br", 0);
      }
    } else {
      state2.push("softbreak", "br", 0);
    }
  }
  pos++;
  while (pos < max && isSpace$3(state2.src.charCodeAt(pos))) {
    pos++;
  }
  state2.pos = pos;
  return true;
}, "newline");
var isSpace$2 = utils$1.isSpace;
var ESCAPED = [];
for (var i = 0; i < 256; i++) {
  ESCAPED.push(0);
}
"\\!\"#$%&'()*+,./:;<=>?@[]^_`{|}~-".split("").forEach(function(ch) {
  ESCAPED[ch.charCodeAt(0)] = 1;
});
var _escape = /* @__PURE__ */ __name(function escape(state2, silent) {
  var ch, pos = state2.pos, max = state2.posMax;
  if (state2.src.charCodeAt(pos) !== 92) {
    return false;
  }
  pos++;
  if (pos < max) {
    ch = state2.src.charCodeAt(pos);
    if (ch < 256 && ESCAPED[ch] !== 0) {
      if (!silent) {
        state2.pending += state2.src[pos];
      }
      state2.pos += 2;
      return true;
    }
    if (ch === 10) {
      if (!silent) {
        state2.push("hardbreak", "br", 0);
      }
      pos++;
      while (pos < max) {
        ch = state2.src.charCodeAt(pos);
        if (!isSpace$2(ch)) {
          break;
        }
        pos++;
      }
      state2.pos = pos;
      return true;
    }
  }
  if (!silent) {
    state2.pending += "\\";
  }
  state2.pos++;
  return true;
}, "escape");
var backticks = /* @__PURE__ */ __name(function backtick(state2, silent) {
  var start, max, marker2, token2, matchStart, matchEnd, openerLength, closerLength, pos = state2.pos, ch = state2.src.charCodeAt(pos);
  if (ch !== 96) {
    return false;
  }
  start = pos;
  pos++;
  max = state2.posMax;
  while (pos < max && state2.src.charCodeAt(pos) === 96) {
    pos++;
  }
  marker2 = state2.src.slice(start, pos);
  openerLength = marker2.length;
  if (state2.backticksScanned && (state2.backticks[openerLength] || 0) <= start) {
    if (!silent)
      state2.pending += marker2;
    state2.pos += openerLength;
    return true;
  }
  matchStart = matchEnd = pos;
  while ((matchStart = state2.src.indexOf("`", matchEnd)) !== -1) {
    matchEnd = matchStart + 1;
    while (matchEnd < max && state2.src.charCodeAt(matchEnd) === 96) {
      matchEnd++;
    }
    closerLength = matchEnd - matchStart;
    if (closerLength === openerLength) {
      if (!silent) {
        token2 = state2.push("code_inline", "code", 0);
        token2.markup = marker2;
        token2.content = state2.src.slice(pos, matchStart).replace(/\n/g, " ").replace(/^ (.+) $/, "$1");
      }
      state2.pos = matchEnd;
      return true;
    }
    state2.backticks[closerLength] = matchStart;
  }
  state2.backticksScanned = true;
  if (!silent)
    state2.pending += marker2;
  state2.pos += openerLength;
  return true;
}, "backtick");
var strikethrough = {};
strikethrough.tokenize = /* @__PURE__ */ __name(function strikethrough2(state2, silent) {
  var i, scanned, token2, len, ch, start = state2.pos, marker2 = state2.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker2 !== 126) {
    return false;
  }
  scanned = state2.scanDelims(state2.pos, true);
  len = scanned.length;
  ch = String.fromCharCode(marker2);
  if (len < 2) {
    return false;
  }
  if (len % 2) {
    token2 = state2.push("text", "", 0);
    token2.content = ch;
    len--;
  }
  for (i = 0; i < len; i += 2) {
    token2 = state2.push("text", "", 0);
    token2.content = ch + ch;
    state2.delimiters.push({
      marker: marker2,
      length: 0,
      jump: i / 2,
      token: state2.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state2.pos += scanned.length;
  return true;
}, "strikethrough");
function postProcess$1(state2, delimiters) {
  var i, j, startDelim, endDelim, token2, loneMarkers = [], max = delimiters.length;
  for (i = 0; i < max; i++) {
    startDelim = delimiters[i];
    if (startDelim.marker !== 126) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    endDelim = delimiters[startDelim.end];
    token2 = state2.tokens[startDelim.token];
    token2.type = "s_open";
    token2.tag = "s";
    token2.nesting = 1;
    token2.markup = "~~";
    token2.content = "";
    token2 = state2.tokens[endDelim.token];
    token2.type = "s_close";
    token2.tag = "s";
    token2.nesting = -1;
    token2.markup = "~~";
    token2.content = "";
    if (state2.tokens[endDelim.token - 1].type === "text" && state2.tokens[endDelim.token - 1].content === "~") {
      loneMarkers.push(endDelim.token - 1);
    }
  }
  while (loneMarkers.length) {
    i = loneMarkers.pop();
    j = i + 1;
    while (j < state2.tokens.length && state2.tokens[j].type === "s_close") {
      j++;
    }
    j--;
    if (i !== j) {
      token2 = state2.tokens[j];
      state2.tokens[j] = state2.tokens[i];
      state2.tokens[i] = token2;
    }
  }
}
__name(postProcess$1, "postProcess$1");
strikethrough.postProcess = /* @__PURE__ */ __name(function strikethrough3(state2) {
  var curr, tokens_meta = state2.tokens_meta, max = state2.tokens_meta.length;
  postProcess$1(state2, state2.delimiters);
  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess$1(state2, tokens_meta[curr].delimiters);
    }
  }
}, "strikethrough");
var emphasis = {};
emphasis.tokenize = /* @__PURE__ */ __name(function emphasis2(state2, silent) {
  var i, scanned, token2, start = state2.pos, marker2 = state2.src.charCodeAt(start);
  if (silent) {
    return false;
  }
  if (marker2 !== 95 && marker2 !== 42) {
    return false;
  }
  scanned = state2.scanDelims(state2.pos, marker2 === 42);
  for (i = 0; i < scanned.length; i++) {
    token2 = state2.push("text", "", 0);
    token2.content = String.fromCharCode(marker2);
    state2.delimiters.push({
      marker: marker2,
      length: scanned.length,
      jump: i,
      token: state2.tokens.length - 1,
      end: -1,
      open: scanned.can_open,
      close: scanned.can_close
    });
  }
  state2.pos += scanned.length;
  return true;
}, "emphasis");
function postProcess(state2, delimiters) {
  var i, startDelim, endDelim, token2, ch, isStrong, max = delimiters.length;
  for (i = max - 1; i >= 0; i--) {
    startDelim = delimiters[i];
    if (startDelim.marker !== 95 && startDelim.marker !== 42) {
      continue;
    }
    if (startDelim.end === -1) {
      continue;
    }
    endDelim = delimiters[startDelim.end];
    isStrong = i > 0 && delimiters[i - 1].end === startDelim.end + 1 && delimiters[i - 1].token === startDelim.token - 1 && delimiters[startDelim.end + 1].token === endDelim.token + 1 && delimiters[i - 1].marker === startDelim.marker;
    ch = String.fromCharCode(startDelim.marker);
    token2 = state2.tokens[startDelim.token];
    token2.type = isStrong ? "strong_open" : "em_open";
    token2.tag = isStrong ? "strong" : "em";
    token2.nesting = 1;
    token2.markup = isStrong ? ch + ch : ch;
    token2.content = "";
    token2 = state2.tokens[endDelim.token];
    token2.type = isStrong ? "strong_close" : "em_close";
    token2.tag = isStrong ? "strong" : "em";
    token2.nesting = -1;
    token2.markup = isStrong ? ch + ch : ch;
    token2.content = "";
    if (isStrong) {
      state2.tokens[delimiters[i - 1].token].content = "";
      state2.tokens[delimiters[startDelim.end + 1].token].content = "";
      i--;
    }
  }
}
__name(postProcess, "postProcess");
emphasis.postProcess = /* @__PURE__ */ __name(function emphasis3(state2) {
  var curr, tokens_meta = state2.tokens_meta, max = state2.tokens_meta.length;
  postProcess(state2, state2.delimiters);
  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      postProcess(state2, tokens_meta[curr].delimiters);
    }
  }
}, "emphasis");
var normalizeReference$1 = utils$1.normalizeReference;
var isSpace$1 = utils$1.isSpace;
var link = /* @__PURE__ */ __name(function link2(state2, silent) {
  var attrs, code3, label, labelEnd, labelStart, pos, res, ref, token2, href = "", title = "", oldPos = state2.pos, max = state2.posMax, start = state2.pos, parseReference = true;
  if (state2.src.charCodeAt(state2.pos) !== 91) {
    return false;
  }
  labelStart = state2.pos + 1;
  labelEnd = state2.md.helpers.parseLinkLabel(state2, state2.pos, true);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max && state2.src.charCodeAt(pos) === 40) {
    parseReference = false;
    pos++;
    for (; pos < max; pos++) {
      code3 = state2.src.charCodeAt(pos);
      if (!isSpace$1(code3) && code3 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state2.md.helpers.parseLinkDestination(state2.src, pos, state2.posMax);
    if (res.ok) {
      href = state2.md.normalizeLink(res.str);
      if (state2.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
      start = pos;
      for (; pos < max; pos++) {
        code3 = state2.src.charCodeAt(pos);
        if (!isSpace$1(code3) && code3 !== 10) {
          break;
        }
      }
      res = state2.md.helpers.parseLinkTitle(state2.src, pos, state2.posMax);
      if (pos < max && start !== pos && res.ok) {
        title = res.str;
        pos = res.pos;
        for (; pos < max; pos++) {
          code3 = state2.src.charCodeAt(pos);
          if (!isSpace$1(code3) && code3 !== 10) {
            break;
          }
        }
      }
    }
    if (pos >= max || state2.src.charCodeAt(pos) !== 41) {
      parseReference = true;
    }
    pos++;
  }
  if (parseReference) {
    if (typeof state2.env.references === "undefined") {
      return false;
    }
    if (pos < max && state2.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state2.md.helpers.parseLinkLabel(state2, pos);
      if (pos >= 0) {
        label = state2.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state2.src.slice(labelStart, labelEnd);
    }
    ref = state2.env.references[normalizeReference$1(label)];
    if (!ref) {
      state2.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }
  if (!silent) {
    state2.pos = labelStart;
    state2.posMax = labelEnd;
    token2 = state2.push("link_open", "a", 1);
    token2.attrs = attrs = [["href", href]];
    if (title) {
      attrs.push(["title", title]);
    }
    state2.md.inline.tokenize(state2);
    token2 = state2.push("link_close", "a", -1);
  }
  state2.pos = pos;
  state2.posMax = max;
  return true;
}, "link");
var normalizeReference = utils$1.normalizeReference;
var isSpace = utils$1.isSpace;
var image = /* @__PURE__ */ __name(function image2(state2, silent) {
  var attrs, code3, content, label, labelEnd, labelStart, pos, ref, res, title, token2, tokens, start, href = "", oldPos = state2.pos, max = state2.posMax;
  if (state2.src.charCodeAt(state2.pos) !== 33) {
    return false;
  }
  if (state2.src.charCodeAt(state2.pos + 1) !== 91) {
    return false;
  }
  labelStart = state2.pos + 2;
  labelEnd = state2.md.helpers.parseLinkLabel(state2, state2.pos + 1, false);
  if (labelEnd < 0) {
    return false;
  }
  pos = labelEnd + 1;
  if (pos < max && state2.src.charCodeAt(pos) === 40) {
    pos++;
    for (; pos < max; pos++) {
      code3 = state2.src.charCodeAt(pos);
      if (!isSpace(code3) && code3 !== 10) {
        break;
      }
    }
    if (pos >= max) {
      return false;
    }
    start = pos;
    res = state2.md.helpers.parseLinkDestination(state2.src, pos, state2.posMax);
    if (res.ok) {
      href = state2.md.normalizeLink(res.str);
      if (state2.md.validateLink(href)) {
        pos = res.pos;
      } else {
        href = "";
      }
    }
    start = pos;
    for (; pos < max; pos++) {
      code3 = state2.src.charCodeAt(pos);
      if (!isSpace(code3) && code3 !== 10) {
        break;
      }
    }
    res = state2.md.helpers.parseLinkTitle(state2.src, pos, state2.posMax);
    if (pos < max && start !== pos && res.ok) {
      title = res.str;
      pos = res.pos;
      for (; pos < max; pos++) {
        code3 = state2.src.charCodeAt(pos);
        if (!isSpace(code3) && code3 !== 10) {
          break;
        }
      }
    } else {
      title = "";
    }
    if (pos >= max || state2.src.charCodeAt(pos) !== 41) {
      state2.pos = oldPos;
      return false;
    }
    pos++;
  } else {
    if (typeof state2.env.references === "undefined") {
      return false;
    }
    if (pos < max && state2.src.charCodeAt(pos) === 91) {
      start = pos + 1;
      pos = state2.md.helpers.parseLinkLabel(state2, pos);
      if (pos >= 0) {
        label = state2.src.slice(start, pos++);
      } else {
        pos = labelEnd + 1;
      }
    } else {
      pos = labelEnd + 1;
    }
    if (!label) {
      label = state2.src.slice(labelStart, labelEnd);
    }
    ref = state2.env.references[normalizeReference(label)];
    if (!ref) {
      state2.pos = oldPos;
      return false;
    }
    href = ref.href;
    title = ref.title;
  }
  if (!silent) {
    content = state2.src.slice(labelStart, labelEnd);
    state2.md.inline.parse(content, state2.md, state2.env, tokens = []);
    token2 = state2.push("image", "img", 0);
    token2.attrs = attrs = [["src", href], ["alt", ""]];
    token2.children = tokens;
    token2.content = content;
    if (title) {
      attrs.push(["title", title]);
    }
  }
  state2.pos = pos;
  state2.posMax = max;
  return true;
}, "image");
var EMAIL_RE = /^([a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)$/;
var AUTOLINK_RE = /^([a-zA-Z][a-zA-Z0-9+.\-]{1,31}):([^<>\x00-\x20]*)$/;
var autolink = /* @__PURE__ */ __name(function autolink2(state2, silent) {
  var url, fullUrl, token2, ch, start, max, pos = state2.pos;
  if (state2.src.charCodeAt(pos) !== 60) {
    return false;
  }
  start = state2.pos;
  max = state2.posMax;
  for (; ; ) {
    if (++pos >= max)
      return false;
    ch = state2.src.charCodeAt(pos);
    if (ch === 60)
      return false;
    if (ch === 62)
      break;
  }
  url = state2.src.slice(start + 1, pos);
  if (AUTOLINK_RE.test(url)) {
    fullUrl = state2.md.normalizeLink(url);
    if (!state2.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      token2 = state2.push("link_open", "a", 1);
      token2.attrs = [["href", fullUrl]];
      token2.markup = "autolink";
      token2.info = "auto";
      token2 = state2.push("text", "", 0);
      token2.content = state2.md.normalizeLinkText(url);
      token2 = state2.push("link_close", "a", -1);
      token2.markup = "autolink";
      token2.info = "auto";
    }
    state2.pos += url.length + 2;
    return true;
  }
  if (EMAIL_RE.test(url)) {
    fullUrl = state2.md.normalizeLink("mailto:" + url);
    if (!state2.md.validateLink(fullUrl)) {
      return false;
    }
    if (!silent) {
      token2 = state2.push("link_open", "a", 1);
      token2.attrs = [["href", fullUrl]];
      token2.markup = "autolink";
      token2.info = "auto";
      token2 = state2.push("text", "", 0);
      token2.content = state2.md.normalizeLinkText(url);
      token2 = state2.push("link_close", "a", -1);
      token2.markup = "autolink";
      token2.info = "auto";
    }
    state2.pos += url.length + 2;
    return true;
  }
  return false;
}, "autolink");
var HTML_TAG_RE = html_re.HTML_TAG_RE;
function isLetter(ch) {
  var lc = ch | 32;
  return lc >= 97 && lc <= 122;
}
__name(isLetter, "isLetter");
var html_inline = /* @__PURE__ */ __name(function html_inline2(state2, silent) {
  var ch, match2, max, token2, pos = state2.pos;
  if (!state2.md.options.html) {
    return false;
  }
  max = state2.posMax;
  if (state2.src.charCodeAt(pos) !== 60 || pos + 2 >= max) {
    return false;
  }
  ch = state2.src.charCodeAt(pos + 1);
  if (ch !== 33 && ch !== 63 && ch !== 47 && !isLetter(ch)) {
    return false;
  }
  match2 = state2.src.slice(pos).match(HTML_TAG_RE);
  if (!match2) {
    return false;
  }
  if (!silent) {
    token2 = state2.push("html_inline", "", 0);
    token2.content = state2.src.slice(pos, pos + match2[0].length);
  }
  state2.pos += match2[0].length;
  return true;
}, "html_inline");
var entities = entities$1;
var has = utils$1.has;
var isValidEntityCode = utils$1.isValidEntityCode;
var fromCodePoint = utils$1.fromCodePoint;
var DIGITAL_RE = /^&#((?:x[a-f0-9]{1,6}|[0-9]{1,7}));/i;
var NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;
var entity = /* @__PURE__ */ __name(function entity2(state2, silent) {
  var ch, code3, match2, pos = state2.pos, max = state2.posMax;
  if (state2.src.charCodeAt(pos) !== 38) {
    return false;
  }
  if (pos + 1 < max) {
    ch = state2.src.charCodeAt(pos + 1);
    if (ch === 35) {
      match2 = state2.src.slice(pos).match(DIGITAL_RE);
      if (match2) {
        if (!silent) {
          code3 = match2[1][0].toLowerCase() === "x" ? parseInt(match2[1].slice(1), 16) : parseInt(match2[1], 10);
          state2.pending += isValidEntityCode(code3) ? fromCodePoint(code3) : fromCodePoint(65533);
        }
        state2.pos += match2[0].length;
        return true;
      }
    } else {
      match2 = state2.src.slice(pos).match(NAMED_RE);
      if (match2) {
        if (has(entities, match2[1])) {
          if (!silent) {
            state2.pending += entities[match2[1]];
          }
          state2.pos += match2[0].length;
          return true;
        }
      }
    }
  }
  if (!silent) {
    state2.pending += "&";
  }
  state2.pos++;
  return true;
}, "entity");
function processDelimiters(state2, delimiters) {
  var closerIdx, openerIdx, closer, opener, minOpenerIdx, newMinOpenerIdx, isOddMatch, lastJump, openersBottom = {}, max = delimiters.length;
  for (closerIdx = 0; closerIdx < max; closerIdx++) {
    closer = delimiters[closerIdx];
    closer.length = closer.length || 0;
    if (!closer.close)
      continue;
    if (!openersBottom.hasOwnProperty(closer.marker)) {
      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];
    }
    minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];
    openerIdx = closerIdx - closer.jump - 1;
    if (openerIdx < -1)
      openerIdx = -1;
    newMinOpenerIdx = openerIdx;
    for (; openerIdx > minOpenerIdx; openerIdx -= opener.jump + 1) {
      opener = delimiters[openerIdx];
      if (opener.marker !== closer.marker)
        continue;
      if (opener.open && opener.end < 0) {
        isOddMatch = false;
        if (opener.close || closer.open) {
          if ((opener.length + closer.length) % 3 === 0) {
            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {
              isOddMatch = true;
            }
          }
        }
        if (!isOddMatch) {
          lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? delimiters[openerIdx - 1].jump + 1 : 0;
          closer.jump = closerIdx - openerIdx + lastJump;
          closer.open = false;
          opener.end = closerIdx;
          opener.jump = lastJump;
          opener.close = false;
          newMinOpenerIdx = -1;
          break;
        }
      }
    }
    if (newMinOpenerIdx !== -1) {
      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;
    }
  }
}
__name(processDelimiters, "processDelimiters");
var balance_pairs = /* @__PURE__ */ __name(function link_pairs(state2) {
  var curr, tokens_meta = state2.tokens_meta, max = state2.tokens_meta.length;
  processDelimiters(state2, state2.delimiters);
  for (curr = 0; curr < max; curr++) {
    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {
      processDelimiters(state2, tokens_meta[curr].delimiters);
    }
  }
}, "link_pairs");
var text_collapse = /* @__PURE__ */ __name(function text_collapse2(state2) {
  var curr, last, level = 0, tokens = state2.tokens, max = state2.tokens.length;
  for (curr = last = 0; curr < max; curr++) {
    if (tokens[curr].nesting < 0)
      level--;
    tokens[curr].level = level;
    if (tokens[curr].nesting > 0)
      level++;
    if (tokens[curr].type === "text" && curr + 1 < max && tokens[curr + 1].type === "text") {
      tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;
    } else {
      if (curr !== last) {
        tokens[last] = tokens[curr];
      }
      last++;
    }
  }
  if (curr !== last) {
    tokens.length = last;
  }
}, "text_collapse");
var Token = token;
var isWhiteSpace = utils$1.isWhiteSpace;
var isPunctChar = utils$1.isPunctChar;
var isMdAsciiPunct = utils$1.isMdAsciiPunct;
function StateInline(src, md, env, outTokens) {
  this.src = src;
  this.env = env;
  this.md = md;
  this.tokens = outTokens;
  this.tokens_meta = Array(outTokens.length);
  this.pos = 0;
  this.posMax = this.src.length;
  this.level = 0;
  this.pending = "";
  this.pendingLevel = 0;
  this.cache = {};
  this.delimiters = [];
  this._prev_delimiters = [];
  this.backticks = {};
  this.backticksScanned = false;
}
__name(StateInline, "StateInline");
StateInline.prototype.pushPending = function() {
  var token2 = new Token("text", "", 0);
  token2.content = this.pending;
  token2.level = this.pendingLevel;
  this.tokens.push(token2);
  this.pending = "";
  return token2;
};
StateInline.prototype.push = function(type2, tag, nesting) {
  if (this.pending) {
    this.pushPending();
  }
  var token2 = new Token(type2, tag, nesting);
  var token_meta = null;
  if (nesting < 0) {
    this.level--;
    this.delimiters = this._prev_delimiters.pop();
  }
  token2.level = this.level;
  if (nesting > 0) {
    this.level++;
    this._prev_delimiters.push(this.delimiters);
    this.delimiters = [];
    token_meta = { delimiters: this.delimiters };
  }
  this.pendingLevel = this.level;
  this.tokens.push(token2);
  this.tokens_meta.push(token_meta);
  return token2;
};
StateInline.prototype.scanDelims = function(start, canSplitWord) {
  var pos = start, lastChar, nextChar, count, can_open, can_close, isLastWhiteSpace, isLastPunctChar, isNextWhiteSpace, isNextPunctChar, left_flanking = true, right_flanking = true, max = this.posMax, marker2 = this.src.charCodeAt(start);
  lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 32;
  while (pos < max && this.src.charCodeAt(pos) === marker2) {
    pos++;
  }
  count = pos - start;
  nextChar = pos < max ? this.src.charCodeAt(pos) : 32;
  isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));
  isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));
  isLastWhiteSpace = isWhiteSpace(lastChar);
  isNextWhiteSpace = isWhiteSpace(nextChar);
  if (isNextWhiteSpace) {
    left_flanking = false;
  } else if (isNextPunctChar) {
    if (!(isLastWhiteSpace || isLastPunctChar)) {
      left_flanking = false;
    }
  }
  if (isLastWhiteSpace) {
    right_flanking = false;
  } else if (isLastPunctChar) {
    if (!(isNextWhiteSpace || isNextPunctChar)) {
      right_flanking = false;
    }
  }
  if (!canSplitWord) {
    can_open = left_flanking && (!right_flanking || isLastPunctChar);
    can_close = right_flanking && (!left_flanking || isNextPunctChar);
  } else {
    can_open = left_flanking;
    can_close = right_flanking;
  }
  return {
    can_open,
    can_close,
    length: count
  };
};
StateInline.prototype.Token = Token;
var state_inline = StateInline;
var Ruler = ruler;
var _rules = [
  ["text", text],
  ["newline", newline],
  ["escape", _escape],
  ["backticks", backticks],
  ["strikethrough", strikethrough.tokenize],
  ["emphasis", emphasis.tokenize],
  ["link", link],
  ["image", image],
  ["autolink", autolink],
  ["html_inline", html_inline],
  ["entity", entity]
];
var _rules2 = [
  ["balance_pairs", balance_pairs],
  ["strikethrough", strikethrough.postProcess],
  ["emphasis", emphasis.postProcess],
  ["text_collapse", text_collapse]
];
function ParserInline$1() {
  var i;
  this.ruler = new Ruler();
  for (i = 0; i < _rules.length; i++) {
    this.ruler.push(_rules[i][0], _rules[i][1]);
  }
  this.ruler2 = new Ruler();
  for (i = 0; i < _rules2.length; i++) {
    this.ruler2.push(_rules2[i][0], _rules2[i][1]);
  }
}
__name(ParserInline$1, "ParserInline$1");
ParserInline$1.prototype.skipToken = function(state2) {
  var ok, i, pos = state2.pos, rules = this.ruler.getRules(""), len = rules.length, maxNesting = state2.md.options.maxNesting, cache = state2.cache;
  if (typeof cache[pos] !== "undefined") {
    state2.pos = cache[pos];
    return;
  }
  if (state2.level < maxNesting) {
    for (i = 0; i < len; i++) {
      state2.level++;
      ok = rules[i](state2, true);
      state2.level--;
      if (ok) {
        break;
      }
    }
  } else {
    state2.pos = state2.posMax;
  }
  if (!ok) {
    state2.pos++;
  }
  cache[pos] = state2.pos;
};
ParserInline$1.prototype.tokenize = function(state2) {
  var ok, i, rules = this.ruler.getRules(""), len = rules.length, end = state2.posMax, maxNesting = state2.md.options.maxNesting;
  while (state2.pos < end) {
    if (state2.level < maxNesting) {
      for (i = 0; i < len; i++) {
        ok = rules[i](state2, false);
        if (ok) {
          break;
        }
      }
    }
    if (ok) {
      if (state2.pos >= end) {
        break;
      }
      continue;
    }
    state2.pending += state2.src[state2.pos++];
  }
  if (state2.pending) {
    state2.pushPending();
  }
};
ParserInline$1.prototype.parse = function(str, md, env, outTokens) {
  var i, rules, len;
  var state2 = new this.State(str, md, env, outTokens);
  this.tokenize(state2);
  rules = this.ruler2.getRules("");
  len = rules.length;
  for (i = 0; i < len; i++) {
    rules[i](state2);
  }
};
ParserInline$1.prototype.State = state_inline;
var parser_inline = ParserInline$1;
var re = /* @__PURE__ */ __name(function(opts) {
  var re2 = {};
  re2.src_Any = regex$3.source;
  re2.src_Cc = regex$2.source;
  re2.src_Z = regex.source;
  re2.src_P = regex$4.source;
  re2.src_ZPCc = [re2.src_Z, re2.src_P, re2.src_Cc].join("|");
  re2.src_ZCc = [re2.src_Z, re2.src_Cc].join("|");
  var text_separators = "[><\uFF5C]";
  re2.src_pseudo_letter = "(?:(?!" + text_separators + "|" + re2.src_ZPCc + ")" + re2.src_Any + ")";
  re2.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)";
  re2.src_auth = "(?:(?:(?!" + re2.src_ZCc + "|[@/\\[\\]()]).)+@)?";
  re2.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?";
  re2.src_host_terminator = "(?=$|" + text_separators + "|" + re2.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + re2.src_ZPCc + "))";
  re2.src_path = "(?:[/?#](?:(?!" + re2.src_ZCc + "|" + text_separators + `|[()[\\]{}.,"'?!\\-;]).|\\[(?:(?!` + re2.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + re2.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + re2.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + re2.src_ZCc + `|["]).)+\\"|\\'(?:(?!` + re2.src_ZCc + "|[']).)+\\'|\\'(?=" + re2.src_pseudo_letter + "|[-]).|\\.{2,}[a-zA-Z0-9%/&]|\\.(?!" + re2.src_ZCc + "|[.]).|" + (opts && opts["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + ",(?!" + re2.src_ZCc + ").|;(?!" + re2.src_ZCc + ").|\\!+(?!" + re2.src_ZCc + "|[!]).|\\?(?!" + re2.src_ZCc + "|[?]).)+|\\/)?";
  re2.src_email_name = '[\\-;:&=\\+\\$,\\.a-zA-Z0-9_][\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]*';
  re2.src_xn = "xn--[a-z0-9\\-]{1,59}";
  re2.src_domain_root = "(?:" + re2.src_xn + "|" + re2.src_pseudo_letter + "{1,63})";
  re2.src_domain = "(?:" + re2.src_xn + "|(?:" + re2.src_pseudo_letter + ")|(?:" + re2.src_pseudo_letter + "(?:-|" + re2.src_pseudo_letter + "){0,61}" + re2.src_pseudo_letter + "))";
  re2.src_host = "(?:(?:(?:(?:" + re2.src_domain + ")\\.)*" + re2.src_domain + "))";
  re2.tpl_host_fuzzy = "(?:" + re2.src_ip4 + "|(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%)))";
  re2.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + re2.src_domain + ")\\.)+(?:%TLDS%))";
  re2.src_host_strict = re2.src_host + re2.src_host_terminator;
  re2.tpl_host_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_host_terminator;
  re2.src_host_port_strict = re2.src_host + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_port_fuzzy_strict = re2.tpl_host_fuzzy + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_port_no_ip_fuzzy_strict = re2.tpl_host_no_ip_fuzzy + re2.src_port + re2.src_host_terminator;
  re2.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + re2.src_ZPCc + "|>|$))";
  re2.tpl_email_fuzzy = "(^|" + text_separators + '|"|\\(|' + re2.src_ZCc + ")(" + re2.src_email_name + "@" + re2.tpl_host_fuzzy_strict + ")";
  re2.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re2.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re2.tpl_host_port_fuzzy_strict + re2.src_path + ")";
  re2.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|\uFF5C]|" + re2.src_ZPCc + "))((?![$+<=>^`|\uFF5C])" + re2.tpl_host_port_no_ip_fuzzy_strict + re2.src_path + ")";
  return re2;
}, "re");
function assign(obj) {
  var sources = Array.prototype.slice.call(arguments, 1);
  sources.forEach(function(source) {
    if (!source) {
      return;
    }
    Object.keys(source).forEach(function(key) {
      obj[key] = source[key];
    });
  });
  return obj;
}
__name(assign, "assign");
function _class(obj) {
  return Object.prototype.toString.call(obj);
}
__name(_class, "_class");
function isString(obj) {
  return _class(obj) === "[object String]";
}
__name(isString, "isString");
function isObject2(obj) {
  return _class(obj) === "[object Object]";
}
__name(isObject2, "isObject");
function isRegExp(obj) {
  return _class(obj) === "[object RegExp]";
}
__name(isRegExp, "isRegExp");
function isFunction(obj) {
  return _class(obj) === "[object Function]";
}
__name(isFunction, "isFunction");
function escapeRE(str) {
  return str.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&");
}
__name(escapeRE, "escapeRE");
var defaultOptions = {
  fuzzyLink: true,
  fuzzyEmail: true,
  fuzzyIP: false
};
function isOptionsObj(obj) {
  return Object.keys(obj || {}).reduce(function(acc, k2) {
    return acc || defaultOptions.hasOwnProperty(k2);
  }, false);
}
__name(isOptionsObj, "isOptionsObj");
var defaultSchemas = {
  "http:": {
    validate: function(text3, pos, self2) {
      var tail = text3.slice(pos);
      if (!self2.re.http) {
        self2.re.http = new RegExp("^\\/\\/" + self2.re.src_auth + self2.re.src_host_port_strict + self2.re.src_path, "i");
      }
      if (self2.re.http.test(tail)) {
        return tail.match(self2.re.http)[0].length;
      }
      return 0;
    }
  },
  "https:": "http:",
  "ftp:": "http:",
  "//": {
    validate: function(text3, pos, self2) {
      var tail = text3.slice(pos);
      if (!self2.re.no_http) {
        self2.re.no_http = new RegExp("^" + self2.re.src_auth + "(?:localhost|(?:(?:" + self2.re.src_domain + ")\\.)+" + self2.re.src_domain_root + ")" + self2.re.src_port + self2.re.src_host_terminator + self2.re.src_path, "i");
      }
      if (self2.re.no_http.test(tail)) {
        if (pos >= 3 && text3[pos - 3] === ":") {
          return 0;
        }
        if (pos >= 3 && text3[pos - 3] === "/") {
          return 0;
        }
        return tail.match(self2.re.no_http)[0].length;
      }
      return 0;
    }
  },
  "mailto:": {
    validate: function(text3, pos, self2) {
      var tail = text3.slice(pos);
      if (!self2.re.mailto) {
        self2.re.mailto = new RegExp("^" + self2.re.src_email_name + "@" + self2.re.src_host_strict, "i");
      }
      if (self2.re.mailto.test(tail)) {
        return tail.match(self2.re.mailto)[0].length;
      }
      return 0;
    }
  }
};
var tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]";
var tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|\u0440\u0444".split("|");
function resetScanCache(self2) {
  self2.__index__ = -1;
  self2.__text_cache__ = "";
}
__name(resetScanCache, "resetScanCache");
function createValidator(re2) {
  return function(text3, pos) {
    var tail = text3.slice(pos);
    if (re2.test(tail)) {
      return tail.match(re2)[0].length;
    }
    return 0;
  };
}
__name(createValidator, "createValidator");
function createNormalizer() {
  return function(match2, self2) {
    self2.normalize(match2);
  };
}
__name(createNormalizer, "createNormalizer");
function compile(self2) {
  var re$1 = self2.re = re(self2.__opts__);
  var tlds2 = self2.__tlds__.slice();
  self2.onCompile();
  if (!self2.__tlds_replaced__) {
    tlds2.push(tlds_2ch_src_re);
  }
  tlds2.push(re$1.src_xn);
  re$1.src_tlds = tlds2.join("|");
  function untpl(tpl) {
    return tpl.replace("%TLDS%", re$1.src_tlds);
  }
  __name(untpl, "untpl");
  re$1.email_fuzzy = RegExp(untpl(re$1.tpl_email_fuzzy), "i");
  re$1.link_fuzzy = RegExp(untpl(re$1.tpl_link_fuzzy), "i");
  re$1.link_no_ip_fuzzy = RegExp(untpl(re$1.tpl_link_no_ip_fuzzy), "i");
  re$1.host_fuzzy_test = RegExp(untpl(re$1.tpl_host_fuzzy_test), "i");
  var aliases = [];
  self2.__compiled__ = {};
  function schemaError(name2, val) {
    throw new Error('(LinkifyIt) Invalid schema "' + name2 + '": ' + val);
  }
  __name(schemaError, "schemaError");
  Object.keys(self2.__schemas__).forEach(function(name2) {
    var val = self2.__schemas__[name2];
    if (val === null) {
      return;
    }
    var compiled = { validate: null, link: null };
    self2.__compiled__[name2] = compiled;
    if (isObject2(val)) {
      if (isRegExp(val.validate)) {
        compiled.validate = createValidator(val.validate);
      } else if (isFunction(val.validate)) {
        compiled.validate = val.validate;
      } else {
        schemaError(name2, val);
      }
      if (isFunction(val.normalize)) {
        compiled.normalize = val.normalize;
      } else if (!val.normalize) {
        compiled.normalize = createNormalizer();
      } else {
        schemaError(name2, val);
      }
      return;
    }
    if (isString(val)) {
      aliases.push(name2);
      return;
    }
    schemaError(name2, val);
  });
  aliases.forEach(function(alias) {
    if (!self2.__compiled__[self2.__schemas__[alias]]) {
      return;
    }
    self2.__compiled__[alias].validate = self2.__compiled__[self2.__schemas__[alias]].validate;
    self2.__compiled__[alias].normalize = self2.__compiled__[self2.__schemas__[alias]].normalize;
  });
  self2.__compiled__[""] = { validate: null, normalize: createNormalizer() };
  var slist = Object.keys(self2.__compiled__).filter(function(name2) {
    return name2.length > 0 && self2.__compiled__[name2];
  }).map(escapeRE).join("|");
  self2.re.schema_test = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re$1.src_ZPCc + "))(" + slist + ")", "i");
  self2.re.schema_search = RegExp("(^|(?!_)(?:[><\uFF5C]|" + re$1.src_ZPCc + "))(" + slist + ")", "ig");
  self2.re.pretest = RegExp("(" + self2.re.schema_test.source + ")|(" + self2.re.host_fuzzy_test.source + ")|@", "i");
  resetScanCache(self2);
}
__name(compile, "compile");
function Match(self2, shift) {
  var start = self2.__index__, end = self2.__last_index__, text3 = self2.__text_cache__.slice(start, end);
  this.schema = self2.__schema__.toLowerCase();
  this.index = start + shift;
  this.lastIndex = end + shift;
  this.raw = text3;
  this.text = text3;
  this.url = text3;
}
__name(Match, "Match");
function createMatch(self2, shift) {
  var match2 = new Match(self2, shift);
  self2.__compiled__[match2.schema].normalize(match2, self2);
  return match2;
}
__name(createMatch, "createMatch");
function LinkifyIt$1(schemas, options) {
  if (!(this instanceof LinkifyIt$1)) {
    return new LinkifyIt$1(schemas, options);
  }
  if (!options) {
    if (isOptionsObj(schemas)) {
      options = schemas;
      schemas = {};
    }
  }
  this.__opts__ = assign({}, defaultOptions, options);
  this.__index__ = -1;
  this.__last_index__ = -1;
  this.__schema__ = "";
  this.__text_cache__ = "";
  this.__schemas__ = assign({}, defaultSchemas, schemas);
  this.__compiled__ = {};
  this.__tlds__ = tlds_default;
  this.__tlds_replaced__ = false;
  this.re = {};
  compile(this);
}
__name(LinkifyIt$1, "LinkifyIt$1");
LinkifyIt$1.prototype.add = /* @__PURE__ */ __name(function add(schema, definition) {
  this.__schemas__[schema] = definition;
  compile(this);
  return this;
}, "add");
LinkifyIt$1.prototype.set = /* @__PURE__ */ __name(function set(options) {
  this.__opts__ = assign(this.__opts__, options);
  return this;
}, "set");
LinkifyIt$1.prototype.test = /* @__PURE__ */ __name(function test(text3) {
  this.__text_cache__ = text3;
  this.__index__ = -1;
  if (!text3.length) {
    return false;
  }
  var m2, ml, me, len, shift, next, re2, tld_pos, at_pos;
  if (this.re.schema_test.test(text3)) {
    re2 = this.re.schema_search;
    re2.lastIndex = 0;
    while ((m2 = re2.exec(text3)) !== null) {
      len = this.testSchemaAt(text3, m2[2], re2.lastIndex);
      if (len) {
        this.__schema__ = m2[2];
        this.__index__ = m2.index + m2[1].length;
        this.__last_index__ = m2.index + m2[0].length + len;
        break;
      }
    }
  }
  if (this.__opts__.fuzzyLink && this.__compiled__["http:"]) {
    tld_pos = text3.search(this.re.host_fuzzy_test);
    if (tld_pos >= 0) {
      if (this.__index__ < 0 || tld_pos < this.__index__) {
        if ((ml = text3.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) !== null) {
          shift = ml.index + ml[1].length;
          if (this.__index__ < 0 || shift < this.__index__) {
            this.__schema__ = "";
            this.__index__ = shift;
            this.__last_index__ = ml.index + ml[0].length;
          }
        }
      }
    }
  }
  if (this.__opts__.fuzzyEmail && this.__compiled__["mailto:"]) {
    at_pos = text3.indexOf("@");
    if (at_pos >= 0) {
      if ((me = text3.match(this.re.email_fuzzy)) !== null) {
        shift = me.index + me[1].length;
        next = me.index + me[0].length;
        if (this.__index__ < 0 || shift < this.__index__ || shift === this.__index__ && next > this.__last_index__) {
          this.__schema__ = "mailto:";
          this.__index__ = shift;
          this.__last_index__ = next;
        }
      }
    }
  }
  return this.__index__ >= 0;
}, "test");
LinkifyIt$1.prototype.pretest = /* @__PURE__ */ __name(function pretest(text3) {
  return this.re.pretest.test(text3);
}, "pretest");
LinkifyIt$1.prototype.testSchemaAt = /* @__PURE__ */ __name(function testSchemaAt(text3, schema, pos) {
  if (!this.__compiled__[schema.toLowerCase()]) {
    return 0;
  }
  return this.__compiled__[schema.toLowerCase()].validate(text3, pos, this);
}, "testSchemaAt");
LinkifyIt$1.prototype.match = /* @__PURE__ */ __name(function match(text3) {
  var shift = 0, result = [];
  if (this.__index__ >= 0 && this.__text_cache__ === text3) {
    result.push(createMatch(this, shift));
    shift = this.__last_index__;
  }
  var tail = shift ? text3.slice(shift) : text3;
  while (this.test(tail)) {
    result.push(createMatch(this, shift));
    tail = tail.slice(this.__last_index__);
    shift += this.__last_index__;
  }
  if (result.length) {
    return result;
  }
  return null;
}, "match");
LinkifyIt$1.prototype.tlds = /* @__PURE__ */ __name(function tlds(list3, keepOld) {
  list3 = Array.isArray(list3) ? list3 : [list3];
  if (!keepOld) {
    this.__tlds__ = list3.slice();
    this.__tlds_replaced__ = true;
    compile(this);
    return this;
  }
  this.__tlds__ = this.__tlds__.concat(list3).sort().filter(function(el2, idx, arr) {
    return el2 !== arr[idx - 1];
  }).reverse();
  compile(this);
  return this;
}, "tlds");
LinkifyIt$1.prototype.normalize = /* @__PURE__ */ __name(function normalize3(match2) {
  if (!match2.schema) {
    match2.url = "http://" + match2.url;
  }
  if (match2.schema === "mailto:" && !/^mailto:/i.test(match2.url)) {
    match2.url = "mailto:" + match2.url;
  }
}, "normalize");
LinkifyIt$1.prototype.onCompile = /* @__PURE__ */ __name(function onCompile() {
}, "onCompile");
var linkifyIt = LinkifyIt$1;
const maxInt = 2147483647;
const base = 36;
const tMin = 1;
const tMax = 26;
const skew = 38;
const damp = 700;
const initialBias = 72;
const initialN = 128;
const delimiter = "-";
const regexPunycode = /^xn--/;
const regexNonASCII = /[^\0-\x7E]/;
const regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g;
const errors = {
  "overflow": "Overflow: input needs wider integers to process",
  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
  "invalid-input": "Invalid input"
};
const baseMinusTMin = base - tMin;
const floor = Math.floor;
const stringFromCharCode = String.fromCharCode;
function error(type2) {
  throw new RangeError(errors[type2]);
}
__name(error, "error");
function map(array, fn) {
  const result = [];
  let length = array.length;
  while (length--) {
    result[length] = fn(array[length]);
  }
  return result;
}
__name(map, "map");
function mapDomain(string, fn) {
  const parts = string.split("@");
  let result = "";
  if (parts.length > 1) {
    result = parts[0] + "@";
    string = parts[1];
  }
  string = string.replace(regexSeparators, ".");
  const labels = string.split(".");
  const encoded = map(labels, fn).join(".");
  return result + encoded;
}
__name(mapDomain, "mapDomain");
function ucs2decode(string) {
  const output = [];
  let counter = 0;
  const length = string.length;
  while (counter < length) {
    const value3 = string.charCodeAt(counter++);
    if (value3 >= 55296 && value3 <= 56319 && counter < length) {
      const extra = string.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value3 & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value3);
        counter--;
      }
    } else {
      output.push(value3);
    }
  }
  return output;
}
__name(ucs2decode, "ucs2decode");
const ucs2encode = /* @__PURE__ */ __name((array) => String.fromCodePoint(...array), "ucs2encode");
const basicToDigit = /* @__PURE__ */ __name(function(codePoint) {
  if (codePoint - 48 < 10) {
    return codePoint - 22;
  }
  if (codePoint - 65 < 26) {
    return codePoint - 65;
  }
  if (codePoint - 97 < 26) {
    return codePoint - 97;
  }
  return base;
}, "basicToDigit");
const digitToBasic = /* @__PURE__ */ __name(function(digit, flag) {
  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
}, "digitToBasic");
const adapt = /* @__PURE__ */ __name(function(delta2, numPoints, firstTime) {
  let k2 = 0;
  delta2 = firstTime ? floor(delta2 / damp) : delta2 >> 1;
  delta2 += floor(delta2 / numPoints);
  for (; delta2 > baseMinusTMin * tMax >> 1; k2 += base) {
    delta2 = floor(delta2 / baseMinusTMin);
  }
  return floor(k2 + (baseMinusTMin + 1) * delta2 / (delta2 + skew));
}, "adapt");
const decode = /* @__PURE__ */ __name(function(input) {
  const output = [];
  const inputLength = input.length;
  let i = 0;
  let n2 = initialN;
  let bias = initialBias;
  let basic = input.lastIndexOf(delimiter);
  if (basic < 0) {
    basic = 0;
  }
  for (let j = 0; j < basic; ++j) {
    if (input.charCodeAt(j) >= 128) {
      error("not-basic");
    }
    output.push(input.charCodeAt(j));
  }
  for (let index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
    let oldi = i;
    for (let w2 = 1, k2 = base; ; k2 += base) {
      if (index >= inputLength) {
        error("invalid-input");
      }
      const digit = basicToDigit(input.charCodeAt(index++));
      if (digit >= base || digit > floor((maxInt - i) / w2)) {
        error("overflow");
      }
      i += digit * w2;
      const t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
      if (digit < t2) {
        break;
      }
      const baseMinusT = base - t2;
      if (w2 > floor(maxInt / baseMinusT)) {
        error("overflow");
      }
      w2 *= baseMinusT;
    }
    const out = output.length + 1;
    bias = adapt(i - oldi, out, oldi == 0);
    if (floor(i / out) > maxInt - n2) {
      error("overflow");
    }
    n2 += floor(i / out);
    i %= out;
    output.splice(i++, 0, n2);
  }
  return String.fromCodePoint(...output);
}, "decode");
const encode = /* @__PURE__ */ __name(function(input) {
  const output = [];
  input = ucs2decode(input);
  let inputLength = input.length;
  let n2 = initialN;
  let delta2 = 0;
  let bias = initialBias;
  for (const currentValue of input) {
    if (currentValue < 128) {
      output.push(stringFromCharCode(currentValue));
    }
  }
  let basicLength = output.length;
  let handledCPCount = basicLength;
  if (basicLength) {
    output.push(delimiter);
  }
  while (handledCPCount < inputLength) {
    let m2 = maxInt;
    for (const currentValue of input) {
      if (currentValue >= n2 && currentValue < m2) {
        m2 = currentValue;
      }
    }
    const handledCPCountPlusOne = handledCPCount + 1;
    if (m2 - n2 > floor((maxInt - delta2) / handledCPCountPlusOne)) {
      error("overflow");
    }
    delta2 += (m2 - n2) * handledCPCountPlusOne;
    n2 = m2;
    for (const currentValue of input) {
      if (currentValue < n2 && ++delta2 > maxInt) {
        error("overflow");
      }
      if (currentValue == n2) {
        let q2 = delta2;
        for (let k2 = base; ; k2 += base) {
          const t2 = k2 <= bias ? tMin : k2 >= bias + tMax ? tMax : k2 - bias;
          if (q2 < t2) {
            break;
          }
          const qMinusT = q2 - t2;
          const baseMinusT = base - t2;
          output.push(stringFromCharCode(digitToBasic(t2 + qMinusT % baseMinusT, 0)));
          q2 = floor(qMinusT / baseMinusT);
        }
        output.push(stringFromCharCode(digitToBasic(q2, 0)));
        bias = adapt(delta2, handledCPCountPlusOne, handledCPCount == basicLength);
        delta2 = 0;
        ++handledCPCount;
      }
    }
    ++delta2;
    ++n2;
  }
  return output.join("");
}, "encode");
const toUnicode = /* @__PURE__ */ __name(function(input) {
  return mapDomain(input, function(string) {
    return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
  });
}, "toUnicode");
const toASCII = /* @__PURE__ */ __name(function(input) {
  return mapDomain(input, function(string) {
    return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
  });
}, "toASCII");
const punycode$1 = {
  "version": "2.1.0",
  "ucs2": {
    "decode": ucs2decode,
    "encode": ucs2encode
  },
  "decode": decode,
  "encode": encode,
  "toASCII": toASCII,
  "toUnicode": toUnicode
};
var punycode_es6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ucs2decode,
  ucs2encode,
  decode,
  encode,
  toASCII,
  toUnicode,
  "default": punycode$1
}, Symbol.toStringTag, { value: "Module" }));
var require$$8 = /* @__PURE__ */ getAugmentedNamespace(punycode_es6);
var _default = {
  options: {
    html: false,
    xhtmlOut: false,
    breaks: false,
    langPrefix: "language-",
    linkify: false,
    typographer: false,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 100
  },
  components: {
    core: {},
    block: {},
    inline: {}
  }
};
var zero = {
  options: {
    html: false,
    xhtmlOut: false,
    breaks: false,
    langPrefix: "language-",
    linkify: false,
    typographer: false,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline"
      ]
    },
    block: {
      rules: [
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "text"
      ],
      rules2: [
        "balance_pairs",
        "text_collapse"
      ]
    }
  }
};
var commonmark = {
  options: {
    html: true,
    xhtmlOut: true,
    breaks: false,
    langPrefix: "language-",
    linkify: false,
    typographer: false,
    quotes: "\u201C\u201D\u2018\u2019",
    highlight: null,
    maxNesting: 20
  },
  components: {
    core: {
      rules: [
        "normalize",
        "block",
        "inline"
      ]
    },
    block: {
      rules: [
        "blockquote",
        "code",
        "fence",
        "heading",
        "hr",
        "html_block",
        "lheading",
        "list",
        "reference",
        "paragraph"
      ]
    },
    inline: {
      rules: [
        "autolink",
        "backticks",
        "emphasis",
        "entity",
        "escape",
        "html_inline",
        "image",
        "link",
        "newline",
        "text"
      ],
      rules2: [
        "balance_pairs",
        "emphasis",
        "text_collapse"
      ]
    }
  }
};
var utils = utils$1;
var helpers = helpers$1;
var Renderer = renderer;
var ParserCore = parser_core;
var ParserBlock = parser_block;
var ParserInline = parser_inline;
var LinkifyIt = linkifyIt;
var mdurl = mdurl$1;
var punycode = require$$8;
var config = {
  default: _default,
  zero,
  commonmark
};
var BAD_PROTO_RE = /^(vbscript|javascript|file|data):/;
var GOOD_DATA_RE = /^data:image\/(gif|png|jpeg|webp);/;
function validateLink(url) {
  var str = url.trim().toLowerCase();
  return BAD_PROTO_RE.test(str) ? GOOD_DATA_RE.test(str) ? true : false : true;
}
__name(validateLink, "validateLink");
var RECODE_HOSTNAME_FOR = ["http:", "https:", "mailto:"];
function normalizeLink(url) {
  var parsed = mdurl.parse(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toASCII(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return mdurl.encode(mdurl.format(parsed));
}
__name(normalizeLink, "normalizeLink");
function normalizeLinkText(url) {
  var parsed = mdurl.parse(url, true);
  if (parsed.hostname) {
    if (!parsed.protocol || RECODE_HOSTNAME_FOR.indexOf(parsed.protocol) >= 0) {
      try {
        parsed.hostname = punycode.toUnicode(parsed.hostname);
      } catch (er) {
      }
    }
  }
  return mdurl.decode(mdurl.format(parsed), mdurl.decode.defaultChars + "%");
}
__name(normalizeLinkText, "normalizeLinkText");
function MarkdownIt(presetName, options) {
  if (!(this instanceof MarkdownIt)) {
    return new MarkdownIt(presetName, options);
  }
  if (!options) {
    if (!utils.isString(presetName)) {
      options = presetName || {};
      presetName = "default";
    }
  }
  this.inline = new ParserInline();
  this.block = new ParserBlock();
  this.core = new ParserCore();
  this.renderer = new Renderer();
  this.linkify = new LinkifyIt();
  this.validateLink = validateLink;
  this.normalizeLink = normalizeLink;
  this.normalizeLinkText = normalizeLinkText;
  this.utils = utils;
  this.helpers = utils.assign({}, helpers);
  this.options = {};
  this.configure(presetName);
  if (options) {
    this.set(options);
  }
}
__name(MarkdownIt, "MarkdownIt");
MarkdownIt.prototype.set = function(options) {
  utils.assign(this.options, options);
  return this;
};
MarkdownIt.prototype.configure = function(presets) {
  var self2 = this, presetName;
  if (utils.isString(presets)) {
    presetName = presets;
    presets = config[presetName];
    if (!presets) {
      throw new Error('Wrong `markdown-it` preset "' + presetName + '", check name');
    }
  }
  if (!presets) {
    throw new Error("Wrong `markdown-it` preset, can't be empty");
  }
  if (presets.options) {
    self2.set(presets.options);
  }
  if (presets.components) {
    Object.keys(presets.components).forEach(function(name2) {
      if (presets.components[name2].rules) {
        self2[name2].ruler.enableOnly(presets.components[name2].rules);
      }
      if (presets.components[name2].rules2) {
        self2[name2].ruler2.enableOnly(presets.components[name2].rules2);
      }
    });
  }
  return this;
};
MarkdownIt.prototype.enable = function(list3, ignoreInvalid) {
  var result = [];
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.enable(list3, true));
  }, this);
  result = result.concat(this.inline.ruler2.enable(list3, true));
  var missed = list3.filter(function(name2) {
    return result.indexOf(name2) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to enable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.disable = function(list3, ignoreInvalid) {
  var result = [];
  if (!Array.isArray(list3)) {
    list3 = [list3];
  }
  ["core", "block", "inline"].forEach(function(chain) {
    result = result.concat(this[chain].ruler.disable(list3, true));
  }, this);
  result = result.concat(this.inline.ruler2.disable(list3, true));
  var missed = list3.filter(function(name2) {
    return result.indexOf(name2) < 0;
  });
  if (missed.length && !ignoreInvalid) {
    throw new Error("MarkdownIt. Failed to disable unknown rule(s): " + missed);
  }
  return this;
};
MarkdownIt.prototype.use = function(plugin) {
  var args = [this].concat(Array.prototype.slice.call(arguments, 1));
  plugin.apply(plugin, args);
  return this;
};
MarkdownIt.prototype.parse = function(src, env) {
  if (typeof src !== "string") {
    throw new Error("Input data should be a String");
  }
  var state2 = new this.core.State(src, this, env);
  this.core.process(state2);
  return state2.tokens;
};
MarkdownIt.prototype.render = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parse(src, env), this.options, env);
};
MarkdownIt.prototype.parseInline = function(src, env) {
  var state2 = new this.core.State(src, this, env);
  state2.inlineMode = true;
  this.core.process(state2);
  return state2.tokens;
};
MarkdownIt.prototype.renderInline = function(src, env) {
  env = env || {};
  return this.renderer.render(this.parseInline(src, env), this.options, env);
};
var lib = MarkdownIt;
var markdownIt = lib;
const markdown$1 = new markdownIt({
  breaks: true,
  linkify: true
});
var markdown = /* @__PURE__ */ (() => ":is(.graphiql-markdown-description,.graphiql-markdown-deprecation,.CodeMirror-hint-information-description,.CodeMirror-hint-information-deprecation-reason,.CodeMirror-info .info-description,.CodeMirror-info .info-deprecation) blockquote{margin-left:0;margin-right:0;padding-left:var(--px-8)}:is(.graphiql-markdown-description,.graphiql-markdown-deprecation,.CodeMirror-hint-information-description,.CodeMirror-hint-information-deprecation-reason,.CodeMirror-info .info-description,.CodeMirror-info .info-deprecation) code,:is(.graphiql-markdown-description,.graphiql-markdown-deprecation,.CodeMirror-hint-information-description,.CodeMirror-hint-information-deprecation-reason,.CodeMirror-info .info-description,.CodeMirror-info .info-deprecation) pre{border-radius:var(--border-radius-4);font-family:var(--font-family-mono);font-size:var(--font-size-inline-code)}:is(.graphiql-markdown-description,.graphiql-markdown-deprecation,.CodeMirror-hint-information-description,.CodeMirror-hint-information-deprecation-reason,.CodeMirror-info .info-description,.CodeMirror-info .info-deprecation) code{padding:var(--px-2)}:is(.graphiql-markdown-description,.graphiql-markdown-deprecation,.CodeMirror-hint-information-description,.CodeMirror-hint-information-deprecation-reason,.CodeMirror-info .info-description,.CodeMirror-info .info-deprecation) pre{overflow:auto;padding:var(--px-6) var(--px-8)}:is(.graphiql-markdown-description,.graphiql-markdown-deprecation,.CodeMirror-hint-information-description,.CodeMirror-hint-information-deprecation-reason,.CodeMirror-info .info-description,.CodeMirror-info .info-deprecation) pre code{background-color:initial;border-radius:0;padding:0}:is(.graphiql-markdown-description,.graphiql-markdown-deprecation,.CodeMirror-hint-information-description,.CodeMirror-hint-information-deprecation-reason,.CodeMirror-info .info-description,.CodeMirror-info .info-deprecation) ol,:is(.graphiql-markdown-description,.graphiql-markdown-deprecation,.CodeMirror-hint-information-description,.CodeMirror-hint-information-deprecation-reason,.CodeMirror-info .info-description,.CodeMirror-info .info-deprecation) ul{padding-left:var(--px-16)}:is(.graphiql-markdown-description,.graphiql-markdown-deprecation,.CodeMirror-hint-information-description,.CodeMirror-hint-information-deprecation-reason,.CodeMirror-info .info-description,.CodeMirror-info .info-deprecation) ol{list-style-type:decimal}:is(.graphiql-markdown-description,.graphiql-markdown-deprecation,.CodeMirror-hint-information-description,.CodeMirror-hint-information-deprecation-reason,.CodeMirror-info .info-description,.CodeMirror-info .info-deprecation) ul{list-style-type:disc}:is(.graphiql-markdown-description,.graphiql-markdown-deprecation,.CodeMirror-hint-information-description,.CodeMirror-hint-information-deprecation-reason,.CodeMirror-info .info-description,.CodeMirror-info .info-deprecation) img{border-radius:var(--border-radius-4);max-height:120px;max-width:100%}:is(.graphiql-markdown-description,.graphiql-markdown-deprecation,.CodeMirror-hint-information-description,.CodeMirror-hint-information-deprecation-reason,.CodeMirror-info .info-description,.CodeMirror-info .info-deprecation)>:first-child{margin-top:0}:is(.graphiql-markdown-description,.graphiql-markdown-deprecation,.CodeMirror-hint-information-description,.CodeMirror-hint-information-deprecation-reason,.CodeMirror-info .info-description,.CodeMirror-info .info-deprecation)>:last-child{margin-bottom:0}:is(.graphiql-markdown-description,.CodeMirror-hint-information-description,.CodeMirror-info .info-description) a{color:hsl(var(--color-primary));text-decoration:none}:is(.graphiql-markdown-description,.CodeMirror-hint-information-description,.CodeMirror-info .info-description) a:hover{text-decoration:underline}:is(.graphiql-markdown-description,.CodeMirror-hint-information-description,.CodeMirror-info .info-description) blockquote{border-left:1.5px solid hsla(var(--color-neutral),var(--alpha-tertiary))}:is(.graphiql-markdown-description,.CodeMirror-hint-information-description,.CodeMirror-info .info-description) code,:is(.graphiql-markdown-description,.CodeMirror-hint-information-description,.CodeMirror-info .info-description) pre{background-color:hsla(var(--color-neutral),var(--alpha-background-light));color:hsla(var(--color-neutral),1)}:is(.graphiql-markdown-description,.CodeMirror-hint-information-description,.CodeMirror-info .info-description)>*{margin:var(--px-12) 0}:is(.graphiql-markdown-deprecation,.CodeMirror-hint-information-deprecation-reason,.CodeMirror-info .info-deprecation) a{color:hsl(var(--color-warning));text-decoration:underline}:is(.graphiql-markdown-deprecation,.CodeMirror-hint-information-deprecation-reason,.CodeMirror-info .info-deprecation) blockquote{border-left:1.5px solid hsl(var(--color-warning))}:is(.graphiql-markdown-deprecation,.CodeMirror-hint-information-deprecation-reason,.CodeMirror-info .info-deprecation) code,:is(.graphiql-markdown-deprecation,.CodeMirror-hint-information-deprecation-reason,.CodeMirror-info .info-deprecation) pre{background-color:hsla(var(--color-warning),var(--alpha-background-heavy))}:is(.graphiql-markdown-deprecation,.CodeMirror-hint-information-deprecation-reason,.CodeMirror-info .info-deprecation)>*{margin:var(--px-8) 0}.graphiql-markdown-preview>:not(:first-child){display:none}.CodeMirror-hint-information-deprecation,.CodeMirror-info .info-deprecation{background-color:hsla(var(--color-warning),var(--alpha-background-light));border:1px solid hsl(var(--color-warning));border-radius:var(--border-radius-4);color:hsl(var(--color-warning));margin-top:var(--px-12);padding:var(--px-6) var(--px-8)}.CodeMirror-hint-information-deprecation-label,.CodeMirror-info .info-deprecation-label{font-size:var(--font-size-hint);font-weight:var(--font-weight-medium)}.CodeMirror-hint-information-deprecation-reason,.CodeMirror-info .info-deprecation-reason{margin-top:var(--px-6)}\n")();
const MarkdownContent = forwardRef((_ga, ref) => {
  var _ha = _ga, {
    children,
    onlyShowFirstChild,
    type: type2
  } = _ha, props2 = __objRest(_ha, [
    "children",
    "onlyShowFirstChild",
    "type"
  ]);
  return /* @__PURE__ */ jsx("div", __spreadProps(__spreadValues({}, props2), {
    ref,
    className: clsx(`graphiql-markdown-${type2}`, onlyShowFirstChild && "graphiql-markdown-preview", props2.className),
    dangerouslySetInnerHTML: {
      __html: markdown$1.render(children)
    }
  }));
});
MarkdownContent.displayName = "MarkdownContent";
var spinner = /* @__PURE__ */ (() => '.graphiql-spinner{height:56px;margin:auto;margin-top:var(--px-16);width:56px}.graphiql-spinner:after{animation:rotation .8s linear 0s infinite;border:4px solid transparent;border-radius:100%;border-top:4px solid hsla(var(--color-neutral),var(--alpha-tertiary));content:"";display:inline-block;height:46px;vertical-align:middle;width:46px}@keyframes rotation{0%{transform:rotate(0)}to{transform:rotate(360deg)}}\n')();
const Spinner = forwardRef((props2, ref) => /* @__PURE__ */ jsx("div", __spreadProps(__spreadValues({}, props2), {
  ref,
  className: clsx("graphiql-spinner", props2.className)
})));
Spinner.displayName = "Spinner";
var tooltip = /* @__PURE__ */ (() => ":root{--reach-tooltip: 1}[data-reach-tooltip]{z-index:1;pointer-events:none;position:absolute;padding:.25em .5em;box-shadow:2px 2px 10px #0000001a;white-space:nowrap;font-size:85%;background:#f0f0f0;color:#444;border:solid 1px #ccc}[data-reach-tooltip]{background:hsl(var(--color-base));border:var(--popover-border);border-radius:var(--border-radius-4);box-shadow:var(--popover-box-shadow);color:hsl(var(--color-neutral));font-size:inherit;padding:var(--px-4) var(--px-6)}\n")();
function getDocumentDimensions(element) {
  var _ownerDocument$docume, _ownerDocument$docume2;
  var ownerDocument = getOwnerDocument(element);
  var ownerWindow = ownerDocument.defaultView || window;
  if (!ownerDocument) {
    return {
      width: 0,
      height: 0
    };
  }
  return {
    width: (_ownerDocument$docume = ownerDocument.documentElement.clientWidth) != null ? _ownerDocument$docume : ownerWindow.innerWidth,
    height: (_ownerDocument$docume2 = ownerDocument.documentElement.clientHeight) != null ? _ownerDocument$docume2 : ownerWindow.innerHeight
  };
}
__name(getDocumentDimensions, "getDocumentDimensions");
function _extends$1() {
  _extends$1 = Object.assign || function(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends$1.apply(this, arguments);
}
__name(_extends$1, "_extends$1");
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
__name(_objectWithoutPropertiesLoose$1, "_objectWithoutPropertiesLoose$1");
var _excluded$1 = ["children", "label", "ariaLabel", "id", "DEBUG_STYLE"], _excluded2$1 = ["label", "ariaLabel", "isVisible", "id"], _excluded3$1 = ["ariaLabel", "aria-label", "as", "id", "isVisible", "label", "position", "style", "triggerRect"], _excluded4$1 = ["type"];
var _on$1, _on2$1, _on3$1, _on4$1, _on5, _states$1;
var MOUSE_REST_TIMEOUT = 100;
var LEAVE_TIMEOUT = 500;
var TooltipStates;
(function(TooltipStates2) {
  TooltipStates2["Idle"] = "IDLE";
  TooltipStates2["Focused"] = "FOCUSED";
  TooltipStates2["Visible"] = "VISIBLE";
  TooltipStates2["LeavingVisible"] = "LEAVING_VISIBLE";
  TooltipStates2["Dismissed"] = "DISMISSED";
})(TooltipStates || (TooltipStates = {}));
var TooltipEvents;
(function(TooltipEvents2) {
  TooltipEvents2["Blur"] = "BLUR";
  TooltipEvents2["Focus"] = "FOCUS";
  TooltipEvents2["GlobalMouseMove"] = "GLOBAL_MOUSE_MOVE";
  TooltipEvents2["MouseDown"] = "MOUSE_DOWN";
  TooltipEvents2["MouseEnter"] = "MOUSE_ENTER";
  TooltipEvents2["MouseLeave"] = "MOUSE_LEAVE";
  TooltipEvents2["MouseMove"] = "MOUSE_MOVE";
  TooltipEvents2["Rest"] = "REST";
  TooltipEvents2["SelectWithKeyboard"] = "SELECT_WITH_KEYBOARD";
  TooltipEvents2["TimeComplete"] = "TIME_COMPLETE";
})(TooltipEvents || (TooltipEvents = {}));
var chart = {
  initial: TooltipStates.Idle,
  states: (_states$1 = {}, _states$1[TooltipStates.Idle] = {
    enter: clearContextId,
    on: (_on$1 = {}, _on$1[TooltipEvents.MouseEnter] = TooltipStates.Focused, _on$1[TooltipEvents.Focus] = TooltipStates.Visible, _on$1)
  }, _states$1[TooltipStates.Focused] = {
    enter: startRestTimer,
    leave: clearRestTimer,
    on: (_on2$1 = {}, _on2$1[TooltipEvents.MouseMove] = TooltipStates.Focused, _on2$1[TooltipEvents.MouseLeave] = TooltipStates.Idle, _on2$1[TooltipEvents.MouseDown] = TooltipStates.Dismissed, _on2$1[TooltipEvents.Blur] = TooltipStates.Idle, _on2$1[TooltipEvents.Rest] = TooltipStates.Visible, _on2$1)
  }, _states$1[TooltipStates.Visible] = {
    on: (_on3$1 = {}, _on3$1[TooltipEvents.Focus] = TooltipStates.Focused, _on3$1[TooltipEvents.MouseEnter] = TooltipStates.Focused, _on3$1[TooltipEvents.MouseLeave] = TooltipStates.LeavingVisible, _on3$1[TooltipEvents.Blur] = TooltipStates.LeavingVisible, _on3$1[TooltipEvents.MouseDown] = TooltipStates.Dismissed, _on3$1[TooltipEvents.SelectWithKeyboard] = TooltipStates.Dismissed, _on3$1[TooltipEvents.GlobalMouseMove] = TooltipStates.LeavingVisible, _on3$1)
  }, _states$1[TooltipStates.LeavingVisible] = {
    enter: startLeavingVisibleTimer,
    leave: /* @__PURE__ */ __name(function leave() {
      clearLeavingVisibleTimer();
      clearContextId();
    }, "leave"),
    on: (_on4$1 = {}, _on4$1[TooltipEvents.MouseEnter] = TooltipStates.Visible, _on4$1[TooltipEvents.Focus] = TooltipStates.Visible, _on4$1[TooltipEvents.TimeComplete] = TooltipStates.Idle, _on4$1)
  }, _states$1[TooltipStates.Dismissed] = {
    leave: /* @__PURE__ */ __name(function leave2() {
      clearContextId();
    }, "leave"),
    on: (_on5 = {}, _on5[TooltipEvents.MouseLeave] = TooltipStates.Idle, _on5[TooltipEvents.Blur] = TooltipStates.Idle, _on5)
  }, _states$1)
};
var state = {
  value: chart.initial,
  context: {
    id: null
  }
};
var subscriptions = [];
function subscribe(fn) {
  subscriptions.push(fn);
  return function() {
    subscriptions.splice(subscriptions.indexOf(fn), 1);
  };
}
__name(subscribe, "subscribe");
function notify() {
  subscriptions.forEach(function(fn) {
    return fn(state);
  });
}
__name(notify, "notify");
var restTimeout;
function startRestTimer() {
  window.clearTimeout(restTimeout);
  restTimeout = window.setTimeout(function() {
    send({
      type: TooltipEvents.Rest
    });
  }, MOUSE_REST_TIMEOUT);
}
__name(startRestTimer, "startRestTimer");
function clearRestTimer() {
  window.clearTimeout(restTimeout);
}
__name(clearRestTimer, "clearRestTimer");
var leavingVisibleTimer;
function startLeavingVisibleTimer() {
  window.clearTimeout(leavingVisibleTimer);
  leavingVisibleTimer = window.setTimeout(function() {
    return send({
      type: TooltipEvents.TimeComplete
    });
  }, LEAVE_TIMEOUT);
}
__name(startLeavingVisibleTimer, "startLeavingVisibleTimer");
function clearLeavingVisibleTimer() {
  window.clearTimeout(leavingVisibleTimer);
}
__name(clearLeavingVisibleTimer, "clearLeavingVisibleTimer");
function clearContextId() {
  state.context.id = null;
}
__name(clearContextId, "clearContextId");
function useTooltip(_temp) {
  var _ref2 = _temp === void 0 ? {} : _temp, idProp = _ref2.id, onPointerEnter = _ref2.onPointerEnter, onPointerMove = _ref2.onPointerMove, onPointerLeave = _ref2.onPointerLeave, onPointerDown = _ref2.onPointerDown, onMouseEnter = _ref2.onMouseEnter, onMouseMove = _ref2.onMouseMove, onMouseLeave = _ref2.onMouseLeave, onMouseDown = _ref2.onMouseDown, onFocus3 = _ref2.onFocus, onBlur3 = _ref2.onBlur, onKeyDown = _ref2.onKeyDown, disabled = _ref2.disabled, forwardedRef = _ref2.ref, DEBUG_STYLE = _ref2.DEBUG_STYLE;
  var id2 = String(useId(idProp));
  var _React$useState = useState(DEBUG_STYLE ? true : isTooltipVisible(id2, true)), isVisible = _React$useState[0], setIsVisible = _React$useState[1];
  var ownRef = useRef(null);
  var ref = useComposedRefs(forwardedRef, ownRef);
  var triggerRect = useRect(ownRef, {
    observe: isVisible
  });
  useEffect(function() {
    return subscribe(function() {
      setIsVisible(isTooltipVisible(id2));
    });
  }, [id2]);
  useEffect(function() {
    var ownerDocument = getOwnerDocument(ownRef.current);
    function listener(event) {
      if ((event.key === "Escape" || event.key === "Esc") && state.value === TooltipStates.Visible) {
        send({
          type: TooltipEvents.SelectWithKeyboard
        });
      }
    }
    __name(listener, "listener");
    ownerDocument.addEventListener("keydown", listener);
    return function() {
      return ownerDocument.removeEventListener("keydown", listener);
    };
  }, []);
  useDisabledTriggerOnSafari({
    disabled,
    isVisible,
    ref: ownRef
  });
  function wrapMouseEvent(theirHandler, ourHandler) {
    if (typeof window !== "undefined" && "PointerEvent" in window) {
      return theirHandler;
    }
    return composeEventHandlers(theirHandler, ourHandler);
  }
  __name(wrapMouseEvent, "wrapMouseEvent");
  function wrapPointerEventHandler(handler) {
    return /* @__PURE__ */ __name(function onPointerEvent(event) {
      if (event.pointerType !== "mouse") {
        return;
      }
      handler(event);
    }, "onPointerEvent");
  }
  __name(wrapPointerEventHandler, "wrapPointerEventHandler");
  function handleMouseEnter() {
    send({
      type: TooltipEvents.MouseEnter,
      id: id2
    });
  }
  __name(handleMouseEnter, "handleMouseEnter");
  function handleMouseMove() {
    send({
      type: TooltipEvents.MouseMove,
      id: id2
    });
  }
  __name(handleMouseMove, "handleMouseMove");
  function handleMouseLeave() {
    send({
      type: TooltipEvents.MouseLeave
    });
  }
  __name(handleMouseLeave, "handleMouseLeave");
  function handleMouseDown() {
    if (state.context.id === id2) {
      send({
        type: TooltipEvents.MouseDown
      });
    }
  }
  __name(handleMouseDown, "handleMouseDown");
  function handleFocus() {
    if (window.__REACH_DISABLE_TOOLTIPS) {
      return;
    }
    send({
      type: TooltipEvents.Focus,
      id: id2
    });
  }
  __name(handleFocus, "handleFocus");
  function handleBlur() {
    if (state.context.id === id2) {
      send({
        type: TooltipEvents.Blur
      });
    }
  }
  __name(handleBlur, "handleBlur");
  function handleKeyDown(event) {
    if (event.key === "Enter" || event.key === " ") {
      send({
        type: TooltipEvents.SelectWithKeyboard
      });
    }
  }
  __name(handleKeyDown, "handleKeyDown");
  var trigger = {
    "aria-describedby": isVisible ? makeId("tooltip", id2) : void 0,
    "data-state": isVisible ? "tooltip-visible" : "tooltip-hidden",
    "data-reach-tooltip-trigger": "",
    ref,
    onPointerEnter: composeEventHandlers(onPointerEnter, wrapPointerEventHandler(handleMouseEnter)),
    onPointerMove: composeEventHandlers(onPointerMove, wrapPointerEventHandler(handleMouseMove)),
    onPointerLeave: composeEventHandlers(onPointerLeave, wrapPointerEventHandler(handleMouseLeave)),
    onPointerDown: composeEventHandlers(onPointerDown, wrapPointerEventHandler(handleMouseDown)),
    onMouseEnter: wrapMouseEvent(onMouseEnter, handleMouseEnter),
    onMouseMove: wrapMouseEvent(onMouseMove, handleMouseMove),
    onMouseLeave: wrapMouseEvent(onMouseLeave, handleMouseLeave),
    onMouseDown: wrapMouseEvent(onMouseDown, handleMouseDown),
    onFocus: composeEventHandlers(onFocus3, handleFocus),
    onBlur: composeEventHandlers(onBlur3, handleBlur),
    onKeyDown: composeEventHandlers(onKeyDown, handleKeyDown)
  };
  var tooltip2 = {
    id: id2,
    triggerRect,
    isVisible
  };
  return [trigger, tooltip2, isVisible];
}
__name(useTooltip, "useTooltip");
var Tooltip = /* @__PURE__ */ forwardRef(function(_ref2, forwardedRef) {
  var children = _ref2.children, label = _ref2.label, DEPRECATED_ariaLabel = _ref2.ariaLabel, id2 = _ref2.id, DEBUG_STYLE = _ref2.DEBUG_STYLE, props2 = _objectWithoutPropertiesLoose$1(_ref2, _excluded$1);
  var child = Children.only(children);
  var _useTooltip = useTooltip({
    id: id2,
    onPointerEnter: child.props.onPointerEnter,
    onPointerMove: child.props.onPointerMove,
    onPointerLeave: child.props.onPointerLeave,
    onPointerDown: child.props.onPointerDown,
    onMouseEnter: child.props.onMouseEnter,
    onMouseMove: child.props.onMouseMove,
    onMouseLeave: child.props.onMouseLeave,
    onMouseDown: child.props.onMouseDown,
    onFocus: child.props.onFocus,
    onBlur: child.props.onBlur,
    onKeyDown: child.props.onKeyDown,
    disabled: child.props.disabled,
    ref: child.ref,
    DEBUG_STYLE
  }), trigger = _useTooltip[0], tooltip2 = _useTooltip[1];
  return /* @__PURE__ */ createElement(Fragment$1, null, /* @__PURE__ */ cloneElement(child, trigger), /* @__PURE__ */ createElement(TooltipPopup, _extends$1({
    ref: forwardedRef,
    label,
    "aria-label": DEPRECATED_ariaLabel
  }, tooltip2, props2)));
});
var TooltipPopup = /* @__PURE__ */ forwardRef(/* @__PURE__ */ __name(function TooltipPopup2(_ref3, forwardRef2) {
  var label = _ref3.label, DEPRECATED_ariaLabel = _ref3.ariaLabel, isVisible = _ref3.isVisible, id2 = _ref3.id, props2 = _objectWithoutPropertiesLoose$1(_ref3, _excluded2$1);
  return isVisible ? /* @__PURE__ */ createElement(Portal, null, /* @__PURE__ */ createElement(TooltipContent, _extends$1({
    ref: forwardRef2,
    label,
    "aria-label": DEPRECATED_ariaLabel,
    isVisible
  }, props2, {
    id: makeId("tooltip", String(id2))
  }))) : null;
}, "TooltipPopup"));
var TooltipContent = /* @__PURE__ */ forwardRef(/* @__PURE__ */ __name(function TooltipContent2(_ref4, forwardedRef) {
  var ariaLabel = _ref4.ariaLabel, realAriaLabel = _ref4["aria-label"], _ref4$as = _ref4.as, Comp = _ref4$as === void 0 ? "div" : _ref4$as, id2 = _ref4.id, isVisible = _ref4.isVisible, label = _ref4.label, _ref4$position = _ref4.position, position = _ref4$position === void 0 ? positionTooltip : _ref4$position, style2 = _ref4.style, triggerRect = _ref4.triggerRect, props2 = _objectWithoutPropertiesLoose$1(_ref4, _excluded3$1);
  var hasAriaLabel = (realAriaLabel || ariaLabel) != null;
  var ownRef = useRef(null);
  var ref = useComposedRefs(forwardedRef, ownRef);
  var tooltipRect = useRect(ownRef, {
    observe: isVisible
  });
  return /* @__PURE__ */ createElement(Fragment$1, null, /* @__PURE__ */ createElement(Comp, _extends$1({
    role: hasAriaLabel ? void 0 : "tooltip"
  }, props2, {
    ref,
    "data-reach-tooltip": "",
    id: hasAriaLabel ? void 0 : id2,
    style: _extends$1({}, style2, getStyles(position, triggerRect, tooltipRect))
  }), label), hasAriaLabel && /* @__PURE__ */ createElement(VisuallyHidden, {
    role: "tooltip",
    id: id2
  }, realAriaLabel || ariaLabel));
}, "TooltipContent"));
function getStyles(position, triggerRect, tooltipRect) {
  var haventMeasuredTooltipYet = !tooltipRect;
  if (haventMeasuredTooltipYet) {
    return {
      visibility: "hidden"
    };
  }
  return position(triggerRect, tooltipRect);
}
__name(getStyles, "getStyles");
var OFFSET_DEFAULT = 8;
var positionTooltip = /* @__PURE__ */ __name(function positionTooltip2(triggerRect, tooltipRect, offset) {
  if (offset === void 0) {
    offset = OFFSET_DEFAULT;
  }
  var _getDocumentDimension = getDocumentDimensions(), windowWidth = _getDocumentDimension.width, windowHeight = _getDocumentDimension.height;
  if (!triggerRect || !tooltipRect) {
    return {};
  }
  var collisions = {
    top: triggerRect.top - tooltipRect.height < 0,
    right: windowWidth < triggerRect.left + tooltipRect.width,
    bottom: windowHeight < triggerRect.bottom + tooltipRect.height + offset,
    left: triggerRect.left - tooltipRect.width < 0
  };
  var directionRight = collisions.right && !collisions.left;
  var directionUp = collisions.bottom && !collisions.top;
  return {
    left: directionRight ? triggerRect.right - tooltipRect.width + window.pageXOffset + "px" : triggerRect.left + window.pageXOffset + "px",
    top: directionUp ? triggerRect.top - offset - tooltipRect.height + window.pageYOffset + "px" : triggerRect.top + offset + triggerRect.height + window.pageYOffset + "px"
  };
}, "positionTooltip");
function useDisabledTriggerOnSafari(_ref5) {
  var disabled = _ref5.disabled, isVisible = _ref5.isVisible, ref = _ref5.ref;
  useEffect(function() {
    if (!(typeof window !== "undefined" && "PointerEvent" in window) || !disabled || !isVisible) {
      return;
    }
    var ownerDocument = getOwnerDocument(ref.current);
    function handleMouseMove(event) {
      if (!isVisible) {
        return;
      }
      if (event.target instanceof Element && event.target.closest("[data-reach-tooltip-trigger][data-state='tooltip-visible']")) {
        return;
      }
      send({
        type: TooltipEvents.GlobalMouseMove
      });
    }
    __name(handleMouseMove, "handleMouseMove");
    ownerDocument.addEventListener("mousemove", handleMouseMove);
    return function() {
      ownerDocument.removeEventListener("mousemove", handleMouseMove);
    };
  }, [disabled, isVisible, ref]);
}
__name(useDisabledTriggerOnSafari, "useDisabledTriggerOnSafari");
function send(event) {
  var _transition = transition(state, event), value3 = _transition.value, context = _transition.context, changed = _transition.changed;
  if (changed) {
    state = {
      value: value3,
      context
    };
    notify();
  }
}
__name(send, "send");
function transition(currentState, event) {
  var stateDef = chart.states[currentState.value];
  var nextState = stateDef && stateDef.on && stateDef.on[event.type];
  if (!nextState) {
    return _extends$1({}, currentState, {
      changed: false
    });
  }
  if (stateDef && stateDef.leave) {
    stateDef.leave(currentState.context, event);
  }
  event.type;
  var payload = _objectWithoutPropertiesLoose$1(event, _excluded4$1);
  var context = _extends$1({}, state.context, payload);
  var nextStateValue = typeof nextState === "string" ? nextState : nextState.target;
  var nextDef = chart.states[nextStateValue];
  if (nextDef && nextDef.enter) {
    nextDef.enter(currentState.context, event);
  }
  return {
    value: nextStateValue,
    context,
    changed: true
  };
}
__name(transition, "transition");
function isTooltipVisible(id2, initial) {
  return state.context.id === id2 && (initial ? state.value === TooltipStates.Visible : state.value === TooltipStates.Visible || state.value === TooltipStates.LeavingVisible);
}
__name(isTooltipVisible, "isTooltipVisible");
var tabs = /* @__PURE__ */ (() => ".graphiql-tabs{display:flex;overflow-x:auto;padding:var(--px-12)}.graphiql-tabs>:not(:first-child){margin-left:var(--px-12)}.graphiql-tab{align-items:stretch;border-radius:var(--border-radius-8);color:hsla(var(--color-neutral),var(--alpha-secondary));display:flex}.graphiql-tab>button.graphiql-tab-close{visibility:hidden}.graphiql-tab.graphiql-tab-active>button.graphiql-tab-close,.graphiql-tab:hover>button.graphiql-tab-close,.graphiql-tab:focus-within>button.graphiql-tab-close{visibility:unset}.graphiql-tab.graphiql-tab-active{background-color:hsla(var(--color-neutral),var(--alpha-background-heavy));color:hsla(var(--color-neutral),1)}button.graphiql-tab-button{padding:var(--px-4) 0 var(--px-4) var(--px-8)}button.graphiql-tab-close{align-items:center;display:flex;padding:var(--px-4) var(--px-8)}button.graphiql-tab-close>svg{height:var(--px-8);width:var(--px-8)}\n")();
const TabRoot = forwardRef((_ia, ref) => {
  var _ja = _ia, {
    isActive
  } = _ja, props2 = __objRest(_ja, [
    "isActive"
  ]);
  return /* @__PURE__ */ jsx("div", __spreadProps(__spreadValues({}, props2), {
    ref,
    role: "tab",
    "aria-selected": isActive,
    className: clsx("graphiql-tab", isActive && "graphiql-tab-active", props2.className),
    children: props2.children
  }));
});
TabRoot.displayName = "Tab";
const TabButton = forwardRef((props2, ref) => /* @__PURE__ */ jsx(UnStyledButton, __spreadProps(__spreadValues({}, props2), {
  ref,
  type: "button",
  className: clsx("graphiql-tab-button", props2.className),
  children: props2.children
})));
TabButton.displayName = "Tab.Button";
const TabClose = forwardRef((props2, ref) => /* @__PURE__ */ jsx(Tooltip, {
  label: "Close Tab",
  children: /* @__PURE__ */ jsx(UnStyledButton, __spreadProps(__spreadValues({
    "aria-label": "Close Tab"
  }, props2), {
    ref,
    type: "button",
    className: clsx("graphiql-tab-close", props2.className),
    children: /* @__PURE__ */ jsx(CloseIcon, {})
  }))
}));
TabClose.displayName = "Tab.Close";
const Tab = createComponentGroup(TabRoot, {
  Button: TabButton,
  Close: TabClose
});
const Tabs = forwardRef((props2, ref) => /* @__PURE__ */ jsx("div", __spreadProps(__spreadValues({}, props2), {
  ref,
  role: "tablist",
  className: clsx("graphiql-tabs", props2.className),
  children: props2.children
})));
Tabs.displayName = "Tabs";
var __defProp$C = Object.defineProperty;
var __name$C = /* @__PURE__ */ __name((target2, value3) => __defProp$C(target2, "name", { value: value3, configurable: true }), "__name$C");
const HistoryContext = createNullableContext("HistoryContext");
function HistoryContextProvider(props2) {
  var _a;
  const storage = useStorageContext();
  const historyStore = useRef(new HistoryStore(storage || new StorageAPI(null), props2.maxHistoryLength || DEFAULT_HISTORY_LENGTH));
  const [items, setItems] = useState(((_a = historyStore.current) == null ? void 0 : _a.queries) || []);
  const addToHistory = useCallback(({
    query,
    variables,
    headers,
    operationName
  }) => {
    var _a2;
    (_a2 = historyStore.current) == null ? void 0 : _a2.updateHistory(query, variables, headers, operationName);
    setItems(historyStore.current.queries);
  }, []);
  const editLabel = useCallback(({
    query,
    variables,
    headers,
    operationName,
    label,
    favorite
  }) => {
    historyStore.current.editLabel(query, variables, headers, operationName, label, favorite);
    setItems(historyStore.current.queries);
  }, []);
  const toggleFavorite = useCallback(({
    query,
    variables,
    headers,
    operationName,
    label,
    favorite
  }) => {
    historyStore.current.toggleFavorite(query, variables, headers, operationName, label, favorite);
    setItems(historyStore.current.queries);
  }, []);
  const value3 = useMemo(() => ({
    addToHistory,
    editLabel,
    items,
    toggleFavorite
  }), [addToHistory, editLabel, items, toggleFavorite]);
  return /* @__PURE__ */ jsx(HistoryContext.Provider, {
    value: value3,
    children: props2.children
  });
}
__name(HistoryContextProvider, "HistoryContextProvider");
__name$C(HistoryContextProvider, "HistoryContextProvider");
const useHistoryContext = createContextHook(HistoryContext);
const DEFAULT_HISTORY_LENGTH = 20;
var style = /* @__PURE__ */ (() => ".graphiql-history-header{font-size:var(--font-size-h2);font-weight:var(--font-weight-medium)}.graphiql-history-items{margin:var(--px-16) 0 0;list-style:none;padding:0}.graphiql-history-item{border-radius:var(--border-radius-4);color:hsla(var(--color-neutral),var(--alpha-secondary));display:flex;font-size:var(--font-size-inline-code);font-family:var(--font-family-mono);height:34px}.graphiql-history-item:hover{color:hsla(var(--color-neutral),1);background-color:hsla(var(--color-neutral),var(--alpha-background-light))}.graphiql-history-item:not(:first-child){margin-top:var(--px-4)}.graphiql-history-item.editable{background-color:hsla(var(--color-primary),var(--alpha-background-medium))}.graphiql-history-item.editable>input{background:transparent;border:none;flex:1;margin:0;outline:none;padding:0 var(--px-10);width:100%}.graphiql-history-item.editable>input::placeholder{color:hsla(var(--color-neutral),var(--alpha-secondary))}.graphiql-history-item.editable>button{color:hsl(var(--color-primary));padding:0 var(--px-10)}.graphiql-history-item.editable>button:active{background-color:hsla(var(--color-primary),var(--alpha-background-heavy))}.graphiql-history-item.editable>button:focus{outline:hsl(var(--color-primary)) auto 1px}.graphiql-history-item.editable>button>svg{display:block}button.graphiql-history-item-label{flex:1;padding:var(--px-8) var(--px-10);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}button.graphiql-history-item-action{align-items:center;color:hsla(var(--color-neutral),var(--alpha-secondary));display:flex;padding:var(--px-8) var(--px-6)}button.graphiql-history-item-action:hover{color:hsla(var(--color-neutral),1)}button.graphiql-history-item-action>svg{height:14px;width:14px}.graphiql-history-item-spacer{height:var(--px-16)}\n")();
var __defProp$B = Object.defineProperty;
var __name$B = /* @__PURE__ */ __name((target2, value3) => __defProp$B(target2, "name", { value: value3, configurable: true }), "__name$B");
function History() {
  const {
    items
  } = useHistoryContext({
    nonNull: true
  });
  const reversedItems = items.slice().reverse();
  return /* @__PURE__ */ jsxs("section", {
    "aria-label": "History",
    className: "graphiql-history",
    children: [/* @__PURE__ */ jsx("div", {
      className: "graphiql-history-header",
      children: "History"
    }), /* @__PURE__ */ jsx("ul", {
      className: "graphiql-history-items",
      children: reversedItems.map((item, i) => {
        return /* @__PURE__ */ jsxs(Fragment$1, {
          children: [/* @__PURE__ */ jsx(HistoryItem, {
            item
          }), item.favorite && reversedItems[i + 1] && !reversedItems[i + 1].favorite ? /* @__PURE__ */ jsx("div", {
            className: "graphiql-history-item-spacer"
          }) : null]
        }, `${i}:${item.label || item.query}`);
      })
    })]
  });
}
__name(History, "History");
__name$B(History, "History");
function HistoryItem(props2) {
  const {
    editLabel,
    toggleFavorite
  } = useHistoryContext({
    nonNull: true,
    caller: HistoryItem
  });
  const {
    headerEditor,
    queryEditor,
    variableEditor
  } = useEditorContext({
    nonNull: true,
    caller: HistoryItem
  });
  const inputRef = useRef(null);
  const buttonRef = useRef(null);
  const [isEditable, setIsEditable] = useState(false);
  useEffect(() => {
    if (isEditable && inputRef.current) {
      inputRef.current.focus();
    }
  }, [isEditable]);
  const displayName = props2.item.label || props2.item.operationName || formatQuery(props2.item.query);
  return /* @__PURE__ */ jsx("li", {
    className: clsx("graphiql-history-item", isEditable && "editable"),
    children: isEditable ? /* @__PURE__ */ jsxs(Fragment, {
      children: [/* @__PURE__ */ jsx("input", {
        type: "text",
        defaultValue: props2.item.label,
        ref: inputRef,
        onKeyDown: (e2) => {
          if (e2.keyCode === 27) {
            setIsEditable(false);
          } else if (e2.keyCode === 13) {
            setIsEditable(false);
            editLabel(__spreadProps(__spreadValues({}, props2.item), {
              label: e2.currentTarget.value
            }));
          }
        },
        placeholder: "Type a label"
      }), /* @__PURE__ */ jsx(UnStyledButton, {
        type: "button",
        ref: buttonRef,
        onClick: () => {
          var _a;
          setIsEditable(false);
          editLabel(__spreadProps(__spreadValues({}, props2.item), {
            label: (_a = inputRef.current) == null ? void 0 : _a.value
          }));
        },
        children: "Save"
      }), /* @__PURE__ */ jsx(UnStyledButton, {
        type: "button",
        ref: buttonRef,
        onClick: () => {
          setIsEditable(false);
        },
        children: /* @__PURE__ */ jsx(CloseIcon, {})
      })]
    }) : /* @__PURE__ */ jsxs(Fragment, {
      children: [/* @__PURE__ */ jsx(UnStyledButton, {
        type: "button",
        className: "graphiql-history-item-label",
        onClick: () => {
          var _a, _b, _c;
          queryEditor == null ? void 0 : queryEditor.setValue((_a = props2.item.query) != null ? _a : "");
          variableEditor == null ? void 0 : variableEditor.setValue((_b = props2.item.variables) != null ? _b : "");
          headerEditor == null ? void 0 : headerEditor.setValue((_c = props2.item.headers) != null ? _c : "");
        },
        children: displayName
      }), /* @__PURE__ */ jsx(Tooltip, {
        label: "Edit label",
        children: /* @__PURE__ */ jsx(UnStyledButton, {
          type: "button",
          className: "graphiql-history-item-action",
          onClick: (e2) => {
            e2.stopPropagation();
            setIsEditable(true);
          },
          "aria-label": "Edit label",
          children: /* @__PURE__ */ jsx(PenIcon, {
            "aria-hidden": "true"
          })
        })
      }), /* @__PURE__ */ jsx(Tooltip, {
        label: props2.item.favorite ? "Remove favorite" : "Add favorite",
        children: /* @__PURE__ */ jsx(UnStyledButton, {
          type: "button",
          className: "graphiql-history-item-action",
          onClick: (e2) => {
            e2.stopPropagation();
            toggleFavorite(props2.item);
          },
          "aria-label": props2.item.favorite ? "Remove favorite" : "Add favorite",
          children: props2.item.favorite ? /* @__PURE__ */ jsx(StarFilledIcon, {
            "aria-hidden": "true"
          }) : /* @__PURE__ */ jsx(StarIcon, {
            "aria-hidden": "true"
          })
        })
      })]
    })
  });
}
__name(HistoryItem, "HistoryItem");
__name$B(HistoryItem, "HistoryItem");
function formatQuery(query) {
  return query == null ? void 0 : query.split("\n").map((line) => line.replace(/#(.*)/, "")).join(" ").replaceAll("{", " { ").replaceAll("}", " } ").replaceAll(/[\s]{2,}/g, " ");
}
__name(formatQuery, "formatQuery");
__name$B(formatQuery, "formatQuery");
var __defProp$A = Object.defineProperty;
var __name$A = /* @__PURE__ */ __name((target2, value3) => __defProp$A(target2, "name", { value: value3, configurable: true }), "__name$A");
const ExecutionContext = createNullableContext("ExecutionContext");
function ExecutionContextProvider({
  fetcher,
  getDefaultFieldNames,
  children,
  operationName
}) {
  if (!fetcher) {
    throw new TypeError("The `ExecutionContextProvider` component requires a `fetcher` function to be passed as prop.");
  }
  const {
    externalFragments,
    headerEditor,
    queryEditor,
    responseEditor,
    variableEditor,
    updateActiveTabValues
  } = useEditorContext({
    nonNull: true,
    caller: ExecutionContextProvider
  });
  const history = useHistoryContext();
  const autoCompleteLeafs = useAutoCompleteLeafs({
    getDefaultFieldNames,
    caller: ExecutionContextProvider
  });
  const [isFetching, setIsFetching] = useState(false);
  const [subscription, setSubscription] = useState(null);
  const queryIdRef = useRef(0);
  const stop = useCallback(() => {
    subscription == null ? void 0 : subscription.unsubscribe();
    setIsFetching(false);
    setSubscription(null);
  }, [subscription]);
  const run3 = useCallback(async () => {
    var _a, _b;
    if (!queryEditor || !responseEditor) {
      return;
    }
    if (subscription) {
      stop();
      return;
    }
    const setResponse = /* @__PURE__ */ __name$A((value22) => {
      responseEditor.setValue(value22);
      updateActiveTabValues({
        response: value22
      });
    }, "setResponse");
    queryIdRef.current += 1;
    const queryId = queryIdRef.current;
    let query = autoCompleteLeafs() || queryEditor.getValue();
    const variablesString = variableEditor == null ? void 0 : variableEditor.getValue();
    let variables;
    try {
      variables = tryParseJsonObject({
        json: variablesString,
        errorMessageParse: "Variables are invalid JSON",
        errorMessageType: "Variables are not a JSON object."
      });
    } catch (error2) {
      setResponse(error2 instanceof Error ? error2.message : `${error2}`);
      return;
    }
    const headersString = headerEditor == null ? void 0 : headerEditor.getValue();
    let headers;
    try {
      headers = tryParseJsonObject({
        json: headersString,
        errorMessageParse: "Headers are invalid JSON",
        errorMessageType: "Headers are not a JSON object."
      });
    } catch (error2) {
      setResponse(error2 instanceof Error ? error2.message : `${error2}`);
      return;
    }
    if (externalFragments) {
      const fragmentDependencies = queryEditor.documentAST ? getFragmentDependenciesForAST(queryEditor.documentAST, externalFragments) : [];
      if (fragmentDependencies.length > 0) {
        query += "\n" + fragmentDependencies.map((node) => print$1(node)).join("\n");
      }
    }
    setResponse("");
    setIsFetching(true);
    const opName = (_a = operationName != null ? operationName : queryEditor.operationName) != null ? _a : void 0;
    history == null ? void 0 : history.addToHistory({
      query,
      variables: variablesString,
      headers: headersString,
      operationName: opName
    });
    try {
      let fullResponse = {
        data: {}
      };
      const handleResponse = /* @__PURE__ */ __name$A((result) => {
        if (queryId !== queryIdRef.current) {
          return;
        }
        let maybeMultipart = Array.isArray(result) ? result : false;
        if (!maybeMultipart && typeof result === "object" && result !== null && "hasNext" in result) {
          maybeMultipart = [result];
        }
        if (maybeMultipart) {
          const payload = {
            data: fullResponse.data
          };
          const maybeErrors = [...(fullResponse == null ? void 0 : fullResponse.errors) || [], ...maybeMultipart.flatMap((i) => i.errors).filter(Boolean)];
          if (maybeErrors.length) {
            payload.errors = maybeErrors;
          }
          for (const part2 of maybeMultipart) {
            const _a2 = part2, {
              path,
              data,
              errors: errors2
            } = _a2, rest = __objRest(_a2, [
              "path",
              "data",
              "errors"
            ]);
            if (path) {
              if (!data) {
                throw new Error(`Expected part to contain a data property, but got ${part2}`);
              }
              setValue_1(payload.data, path, data, {
                merge: true
              });
            } else if (data) {
              payload.data = data;
            }
            fullResponse = __spreadValues(__spreadValues({}, payload), rest);
          }
          setIsFetching(false);
          setResponse(formatResult(fullResponse));
        } else {
          const response = formatResult(result);
          setIsFetching(false);
          setResponse(response);
        }
      }, "handleResponse");
      const fetch2 = fetcher({
        query,
        variables,
        operationName: opName
      }, {
        headers: headers != null ? headers : void 0,
        documentAST: (_b = queryEditor.documentAST) != null ? _b : void 0
      });
      const value22 = await Promise.resolve(fetch2);
      if (isObservable(value22)) {
        setSubscription(value22.subscribe({
          next(result) {
            handleResponse(result);
          },
          error(error2) {
            setIsFetching(false);
            if (error2) {
              setResponse(formatError(error2));
            }
            setSubscription(null);
          },
          complete() {
            setIsFetching(false);
            setSubscription(null);
          }
        }));
      } else if (isAsyncIterable(value22)) {
        setSubscription({
          unsubscribe: () => {
            var _a2, _b2;
            return (_b2 = (_a2 = value22[Symbol.asyncIterator]()).return) == null ? void 0 : _b2.call(_a2);
          }
        });
        for await (const result of value22) {
          handleResponse(result);
        }
        setIsFetching(false);
        setSubscription(null);
      } else {
        handleResponse(value22);
      }
    } catch (error2) {
      setIsFetching(false);
      setResponse(formatError(error2));
      setSubscription(null);
    }
  }, [autoCompleteLeafs, externalFragments, fetcher, headerEditor, history, operationName, queryEditor, responseEditor, stop, subscription, updateActiveTabValues, variableEditor]);
  const isSubscribed = Boolean(subscription);
  const value3 = useMemo(() => ({
    isFetching,
    isSubscribed,
    operationName: operationName != null ? operationName : null,
    run: run3,
    stop
  }), [isFetching, isSubscribed, operationName, run3, stop]);
  return /* @__PURE__ */ jsx(ExecutionContext.Provider, {
    value: value3,
    children
  });
}
__name(ExecutionContextProvider, "ExecutionContextProvider");
__name$A(ExecutionContextProvider, "ExecutionContextProvider");
const useExecutionContext = createContextHook(ExecutionContext);
function tryParseJsonObject({
  json,
  errorMessageParse,
  errorMessageType
}) {
  let parsed = void 0;
  try {
    parsed = json && json.trim() !== "" ? JSON.parse(json) : void 0;
  } catch (error2) {
    throw new Error(`${errorMessageParse}: ${error2 instanceof Error ? error2.message : error2}.`);
  }
  const isObject3 = typeof parsed === "object" && parsed !== null && !Array.isArray(parsed);
  if (parsed !== void 0 && !isObject3) {
    throw new Error(errorMessageType);
  }
  return parsed;
}
__name(tryParseJsonObject, "tryParseJsonObject");
__name$A(tryParseJsonObject, "tryParseJsonObject");
var __defProp$z = Object.defineProperty;
var __name$z = /* @__PURE__ */ __name((target2, value3) => __defProp$z(target2, "name", { value: value3, configurable: true }), "__name$z");
const DEFAULT_EDITOR_THEME = "graphiql";
const DEFAULT_KEY_MAP = "sublime";
let isMacOs = false;
if (typeof window === "object") {
  isMacOs = window.navigator.platform.toLowerCase().indexOf("mac") === 0;
}
const commonKeys = {
  [isMacOs ? "Cmd-F" : "Ctrl-F"]: "findPersistent",
  "Cmd-G": "findPersistent",
  "Ctrl-G": "findPersistent",
  "Ctrl-Left": "goSubwordLeft",
  "Ctrl-Right": "goSubwordRight",
  "Alt-Left": "goGroupLeft",
  "Alt-Right": "goGroupRight"
};
async function importCodeMirror(addons, options) {
  const CodeMirror = await import("./codemirror.es.js").then(function(n2) {
    return n2.c;
  }).then((c2) => typeof c2 === "function" ? c2 : c2.default);
  await Promise.all((options == null ? void 0 : options.useCommonAddons) === false ? addons : [
    import("./show-hint.es.js").then(function(n2) {
      return n2.s;
    }),
    import("./matchbrackets.es.js").then(function(n2) {
      return n2.m;
    }),
    import("./closebrackets.es.js").then(function(n2) {
      return n2.c;
    }),
    import("./brace-fold.es.js").then(function(n2) {
      return n2.b;
    }),
    import("./foldgutter.es.js").then(function(n2) {
      return n2.f;
    }),
    import("./lint.es3.js").then(function(n2) {
      return n2.l;
    }),
    import("./searchcursor.es.js").then(function(n2) {
      return n2.s;
    }),
    import("./jump-to-line.es.js").then(function(n2) {
      return n2.j;
    }),
    import("./dialog.es.js").then(function(n2) {
      return n2.d;
    }),
    import("./sublime.es.js").then(function(n2) {
      return n2.s;
    }),
    ...addons
  ]);
  return CodeMirror;
}
__name(importCodeMirror, "importCodeMirror");
__name$z(importCodeMirror, "importCodeMirror");
var toggleSelection = /* @__PURE__ */ __name(function() {
  var selection = document.getSelection();
  if (!selection.rangeCount) {
    return function() {
    };
  }
  var active = document.activeElement;
  var ranges = [];
  for (var i = 0; i < selection.rangeCount; i++) {
    ranges.push(selection.getRangeAt(i));
  }
  switch (active.tagName.toUpperCase()) {
    case "INPUT":
    case "TEXTAREA":
      active.blur();
      break;
    default:
      active = null;
      break;
  }
  selection.removeAllRanges();
  return function() {
    selection.type === "Caret" && selection.removeAllRanges();
    if (!selection.rangeCount) {
      ranges.forEach(function(range2) {
        selection.addRange(range2);
      });
    }
    active && active.focus();
  };
}, "toggleSelection");
var deselectCurrent = toggleSelection;
var clipboardToIE11Formatting = {
  "text/plain": "Text",
  "text/html": "Url",
  "default": "Text"
};
var defaultMessage = "Copy to clipboard: #{key}, Enter";
function format2(message) {
  var copyKey = (/mac os x/i.test(navigator.userAgent) ? "\u2318" : "Ctrl") + "+C";
  return message.replace(/#{\s*key\s*}/g, copyKey);
}
__name(format2, "format");
function copy(text3, options) {
  var debug, message, reselectPrevious, range2, selection, mark, success = false;
  if (!options) {
    options = {};
  }
  debug = options.debug || false;
  try {
    reselectPrevious = deselectCurrent();
    range2 = document.createRange();
    selection = document.getSelection();
    mark = document.createElement("span");
    mark.textContent = text3;
    mark.ariaHidden = "true";
    mark.style.all = "unset";
    mark.style.position = "fixed";
    mark.style.top = 0;
    mark.style.clip = "rect(0, 0, 0, 0)";
    mark.style.whiteSpace = "pre";
    mark.style.webkitUserSelect = "text";
    mark.style.MozUserSelect = "text";
    mark.style.msUserSelect = "text";
    mark.style.userSelect = "text";
    mark.addEventListener("copy", function(e2) {
      e2.stopPropagation();
      if (options.format) {
        e2.preventDefault();
        if (typeof e2.clipboardData === "undefined") {
          debug && console.warn("unable to use e.clipboardData");
          debug && console.warn("trying IE specific stuff");
          window.clipboardData.clearData();
          var format3 = clipboardToIE11Formatting[options.format] || clipboardToIE11Formatting["default"];
          window.clipboardData.setData(format3, text3);
        } else {
          e2.clipboardData.clearData();
          e2.clipboardData.setData(options.format, text3);
        }
      }
      if (options.onCopy) {
        e2.preventDefault();
        options.onCopy(e2.clipboardData);
      }
    });
    document.body.appendChild(mark);
    range2.selectNodeContents(mark);
    selection.addRange(range2);
    var successful = document.execCommand("copy");
    if (!successful) {
      throw new Error("copy command was unsuccessful");
    }
    success = true;
  } catch (err) {
    debug && console.error("unable to copy using execCommand: ", err);
    debug && console.warn("trying IE specific stuff");
    try {
      window.clipboardData.setData(options.format || "text", text3);
      options.onCopy && options.onCopy(window.clipboardData);
      success = true;
    } catch (err2) {
      debug && console.error("unable to copy using clipboardData: ", err2);
      debug && console.error("falling back to prompt");
      message = format2("message" in options ? options.message : defaultMessage);
      window.prompt(message, text3);
    }
  } finally {
    if (selection) {
      if (typeof selection.removeRange == "function") {
        selection.removeRange(range2);
      } else {
        selection.removeAllRanges();
      }
    }
    if (mark) {
      document.body.removeChild(mark);
    }
    reselectPrevious();
  }
  return success;
}
__name(copy, "copy");
var copyToClipboard = copy;
var defaultValue = /* @__PURE__ */ (() => ".graphiql-doc-explorer-default-value{color:hsl(var(--color-success))}\n")();
var __defProp$y = Object.defineProperty;
var __name$y = /* @__PURE__ */ __name((target2, value3) => __defProp$y(target2, "name", { value: value3, configurable: true }), "__name$y");
const printDefault = /* @__PURE__ */ __name$y((ast2) => {
  if (!ast2) {
    return "";
  }
  return print$1(ast2);
}, "printDefault");
function DefaultValue({
  field
}) {
  if (!("defaultValue" in field) || field.defaultValue === void 0) {
    return null;
  }
  const ast2 = astFromValue$1(field.defaultValue, field.type);
  if (!ast2) {
    return null;
  }
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [" = ", /* @__PURE__ */ jsx("span", {
      className: "graphiql-doc-explorer-default-value",
      children: printDefault(ast2)
    })]
  });
}
__name(DefaultValue, "DefaultValue");
__name$y(DefaultValue, "DefaultValue");
var __defProp$x = Object.defineProperty;
var __name$x = /* @__PURE__ */ __name((target2, value3) => __defProp$x(target2, "name", { value: value3, configurable: true }), "__name$x");
const SchemaContext = createNullableContext("SchemaContext");
function SchemaContextProvider(props2) {
  if (!props2.fetcher) {
    throw new TypeError("The `SchemaContextProvider` component requires a `fetcher` function to be passed as prop.");
  }
  const {
    initialHeaders,
    headerEditor
  } = useEditorContext({
    nonNull: true,
    caller: SchemaContextProvider
  });
  const [schema, setSchema] = useState();
  const [isFetching, setIsFetching] = useState(false);
  const [fetchError, setFetchError] = useState(null);
  const counterRef = useRef(0);
  useEffect(() => {
    setSchema(isSchema(props2.schema) || props2.schema === null || props2.schema === void 0 ? props2.schema : void 0);
    counterRef.current++;
  }, [props2.schema]);
  const headersRef = useRef(initialHeaders);
  useEffect(() => {
    if (headerEditor) {
      headersRef.current = headerEditor.getValue();
    }
  });
  const {
    introspectionQuery,
    introspectionQueryName,
    introspectionQuerySansSubscriptions
  } = useIntrospectionQuery({
    inputValueDeprecation: props2.inputValueDeprecation,
    introspectionQueryName: props2.introspectionQueryName,
    schemaDescription: props2.schemaDescription
  });
  const {
    fetcher,
    onSchemaChange,
    dangerouslyAssumeSchemaIsValid,
    children
  } = props2;
  const introspect = useCallback(() => {
    if (isSchema(props2.schema) || props2.schema === null) {
      return;
    }
    const counter = ++counterRef.current;
    const maybeIntrospectionData = props2.schema;
    async function fetchIntrospectionData() {
      if (maybeIntrospectionData) {
        return maybeIntrospectionData;
      }
      const parsedHeaders = parseHeaderString(headersRef.current);
      if (!parsedHeaders.isValidJSON) {
        setFetchError("Introspection failed as headers are invalid.");
        return;
      }
      const fetcherOpts = parsedHeaders.headers ? {
        headers: parsedHeaders.headers
      } : {};
      const fetch2 = fetcherReturnToPromise(fetcher({
        query: introspectionQuery,
        operationName: introspectionQueryName
      }, fetcherOpts));
      if (!isPromise(fetch2)) {
        setFetchError("Fetcher did not return a Promise for introspection.");
        return;
      }
      setIsFetching(true);
      setFetchError(null);
      let result = await fetch2;
      if (typeof result !== "object" || result === null || !("data" in result)) {
        const fetch22 = fetcherReturnToPromise(fetcher({
          query: introspectionQuerySansSubscriptions,
          operationName: introspectionQueryName
        }, fetcherOpts));
        if (!isPromise(fetch22)) {
          throw new Error("Fetcher did not return a Promise for introspection.");
        }
        result = await fetch22;
      }
      setIsFetching(false);
      if ((result == null ? void 0 : result.data) && "__schema" in result.data) {
        return result.data;
      }
      const responseString = typeof result === "string" ? result : formatResult(result);
      setFetchError(responseString);
    }
    __name(fetchIntrospectionData, "fetchIntrospectionData");
    __name$x(fetchIntrospectionData, "fetchIntrospectionData");
    fetchIntrospectionData().then((introspectionData) => {
      if (counter !== counterRef.current || !introspectionData) {
        return;
      }
      try {
        const newSchema = buildClientSchema(introspectionData);
        setSchema(newSchema);
        onSchemaChange == null ? void 0 : onSchemaChange(newSchema);
      } catch (error2) {
        setFetchError(formatError(error2));
      }
    }).catch((error2) => {
      if (counter !== counterRef.current) {
        return;
      }
      setFetchError(formatError(error2));
      setIsFetching(false);
    });
  }, [fetcher, introspectionQueryName, introspectionQuery, introspectionQuerySansSubscriptions, onSchemaChange, props2.schema]);
  useEffect(() => {
    introspect();
  }, [introspect]);
  useEffect(() => {
    function triggerIntrospection(event) {
      if (event.keyCode === 82 && event.shiftKey && event.ctrlKey) {
        introspect();
      }
    }
    __name(triggerIntrospection, "triggerIntrospection");
    __name$x(triggerIntrospection, "triggerIntrospection");
    window.addEventListener("keydown", triggerIntrospection);
    return () => window.removeEventListener("keydown", triggerIntrospection);
  });
  const validationErrors = useMemo(() => {
    if (!schema || dangerouslyAssumeSchemaIsValid) {
      return [];
    }
    return validateSchema(schema);
  }, [schema, dangerouslyAssumeSchemaIsValid]);
  const value3 = useMemo(() => ({
    fetchError,
    introspect,
    isFetching,
    schema,
    validationErrors
  }), [fetchError, introspect, isFetching, schema, validationErrors]);
  return /* @__PURE__ */ jsx(SchemaContext.Provider, {
    value: value3,
    children
  });
}
__name(SchemaContextProvider, "SchemaContextProvider");
__name$x(SchemaContextProvider, "SchemaContextProvider");
const useSchemaContext = createContextHook(SchemaContext);
function useIntrospectionQuery({
  inputValueDeprecation,
  introspectionQueryName,
  schemaDescription
}) {
  return useMemo(() => {
    const queryName = introspectionQueryName || "IntrospectionQuery";
    let query = getIntrospectionQuery({
      inputValueDeprecation,
      schemaDescription
    });
    if (introspectionQueryName) {
      query = query.replace("query IntrospectionQuery", `query ${queryName}`);
    }
    const querySansSubscriptions = query.replace("subscriptionType { name }", "");
    return {
      introspectionQueryName: queryName,
      introspectionQuery: query,
      introspectionQuerySansSubscriptions: querySansSubscriptions
    };
  }, [inputValueDeprecation, introspectionQueryName, schemaDescription]);
}
__name(useIntrospectionQuery, "useIntrospectionQuery");
__name$x(useIntrospectionQuery, "useIntrospectionQuery");
function parseHeaderString(headersString) {
  let headers = null;
  let isValidJSON = true;
  try {
    if (headersString) {
      headers = JSON.parse(headersString);
    }
  } catch {
    isValidJSON = false;
  }
  return {
    headers,
    isValidJSON
  };
}
__name(parseHeaderString, "parseHeaderString");
__name$x(parseHeaderString, "parseHeaderString");
var __defProp$w = Object.defineProperty;
var __name$w = /* @__PURE__ */ __name((target2, value3) => __defProp$w(target2, "name", { value: value3, configurable: true }), "__name$w");
const initialNavStackItem = {
  name: "Docs"
};
const ExplorerContext = createNullableContext("ExplorerContext");
function ExplorerContextProvider(props2) {
  const {
    schema,
    validationErrors
  } = useSchemaContext({
    nonNull: true,
    caller: ExplorerContextProvider
  });
  const [navStack, setNavStack] = useState([initialNavStackItem]);
  const push = useCallback((item) => {
    setNavStack((currentState) => {
      const lastItem = currentState.at(-1);
      return lastItem.def === item.def ? currentState : [...currentState, item];
    });
  }, []);
  const pop = useCallback(() => {
    setNavStack((currentState) => currentState.length > 1 ? currentState.slice(0, -1) : currentState);
  }, []);
  const reset = useCallback(() => {
    setNavStack((currentState) => currentState.length === 1 ? currentState : [initialNavStackItem]);
  }, []);
  useEffect(() => {
    if (schema == null || validationErrors.length > 0) {
      reset();
    } else {
      setNavStack((oldNavStack) => {
        if (oldNavStack.length === 1) {
          return oldNavStack;
        }
        const newNavStack = [initialNavStackItem];
        let lastEntity = null;
        for (const item of oldNavStack) {
          if (item === initialNavStackItem) {
            continue;
          }
          if (item.def) {
            if (isNamedType(item.def)) {
              const newType = schema.getType(item.def.name);
              if (newType) {
                newNavStack.push({
                  name: item.name,
                  def: newType
                });
                lastEntity = newType;
              } else {
                break;
              }
            } else if (lastEntity === null) {
              break;
            } else if (isObjectType$1(lastEntity) || isInputObjectType$1(lastEntity)) {
              const field = lastEntity.getFields()[item.name];
              if (field) {
                newNavStack.push({
                  name: item.name,
                  def: field
                });
              } else {
                break;
              }
            } else if (isScalarType$1(lastEntity) || isEnumType$1(lastEntity) || isInterfaceType$1(lastEntity) || isUnionType$1(lastEntity)) {
              break;
            } else {
              const field = lastEntity;
              const arg = field.args.find((a2) => a2.name === item.name);
              if (arg) {
                newNavStack.push({
                  name: item.name,
                  def: field
                });
              } else {
                break;
              }
            }
          } else {
            lastEntity = null;
            newNavStack.push(item);
          }
        }
        return newNavStack;
      });
    }
  }, [reset, schema, validationErrors]);
  const value3 = useMemo(() => ({
    explorerNavStack: navStack,
    push,
    pop,
    reset
  }), [navStack, push, pop, reset]);
  return /* @__PURE__ */ jsx(ExplorerContext.Provider, {
    value: value3,
    children: props2.children
  });
}
__name(ExplorerContextProvider, "ExplorerContextProvider");
__name$w(ExplorerContextProvider, "ExplorerContextProvider");
const useExplorerContext = createContextHook(ExplorerContext);
var __defProp$v = Object.defineProperty;
var __name$v = /* @__PURE__ */ __name((target2, value3) => __defProp$v(target2, "name", { value: value3, configurable: true }), "__name$v");
function renderType(type2, renderNamedType) {
  if (isNonNullType$1(type2)) {
    return /* @__PURE__ */ jsxs(Fragment, {
      children: [renderType(type2.ofType, renderNamedType), "!"]
    });
  }
  if (isListType$1(type2)) {
    return /* @__PURE__ */ jsxs(Fragment, {
      children: ["[", renderType(type2.ofType, renderNamedType), "]"]
    });
  }
  return renderNamedType(type2);
}
__name(renderType, "renderType");
__name$v(renderType, "renderType");
var typeLink = /* @__PURE__ */ (() => "a.graphiql-doc-explorer-type-name{color:hsl(var(--color-warning));text-decoration:none}a.graphiql-doc-explorer-type-name:hover{text-decoration:underline}a.graphiql-doc-explorer-type-name:focus{outline:hsl(var(--color-warning)) auto 1px}\n")();
var __defProp$u = Object.defineProperty;
var __name$u = /* @__PURE__ */ __name((target2, value3) => __defProp$u(target2, "name", { value: value3, configurable: true }), "__name$u");
function TypeLink(props2) {
  const {
    push
  } = useExplorerContext({
    nonNull: true,
    caller: TypeLink
  });
  if (!props2.type) {
    return null;
  }
  return renderType(props2.type, (namedType) => /* @__PURE__ */ jsx("a", {
    className: "graphiql-doc-explorer-type-name",
    onClick: (event) => {
      event.preventDefault();
      push({
        name: namedType.name,
        def: namedType
      });
    },
    href: "#",
    children: namedType.name
  }));
}
__name(TypeLink, "TypeLink");
__name$u(TypeLink, "TypeLink");
var argument = /* @__PURE__ */ (() => ".graphiql-doc-explorer-argument>*+*{margin-top:var(--px-12)}.graphiql-doc-explorer-argument-name{color:hsl(var(--color-secondary))}.graphiql-doc-explorer-argument-deprecation{background-color:hsla(var(--color-warning),var(--alpha-background-light));border:1px solid hsl(var(--color-warning));border-radius:var(--border-radius-4);color:hsl(var(--color-warning));padding:var(--px-8)}.graphiql-doc-explorer-argument-deprecation-label{font-size:var(--font-size-hint);font-weight:var(--font-weight-medium)}\n")();
var __defProp$t = Object.defineProperty;
var __name$t = /* @__PURE__ */ __name((target2, value3) => __defProp$t(target2, "name", { value: value3, configurable: true }), "__name$t");
function Argument({
  arg,
  showDefaultValue,
  inline: inline3
}) {
  const definition = /* @__PURE__ */ jsxs("span", {
    children: [/* @__PURE__ */ jsx("span", {
      className: "graphiql-doc-explorer-argument-name",
      children: arg.name
    }), ": ", /* @__PURE__ */ jsx(TypeLink, {
      type: arg.type
    }), showDefaultValue !== false && /* @__PURE__ */ jsx(DefaultValue, {
      field: arg
    })]
  });
  if (inline3) {
    return definition;
  }
  return /* @__PURE__ */ jsxs("div", {
    className: "graphiql-doc-explorer-argument",
    children: [definition, arg.description ? /* @__PURE__ */ jsx(MarkdownContent, {
      type: "description",
      children: arg.description
    }) : null, arg.deprecationReason ? /* @__PURE__ */ jsxs("div", {
      className: "graphiql-doc-explorer-argument-deprecation",
      children: [/* @__PURE__ */ jsx("div", {
        className: "graphiql-doc-explorer-argument-deprecation-label",
        children: "Deprecated"
      }), /* @__PURE__ */ jsx(MarkdownContent, {
        type: "deprecation",
        children: arg.deprecationReason
      })]
    }) : null]
  });
}
__name(Argument, "Argument");
__name$t(Argument, "Argument");
var deprecationReason = /* @__PURE__ */ (() => ".graphiql-doc-explorer-deprecation{background-color:hsla(var(--color-warning),var(--alpha-background-light));border:1px solid hsl(var(--color-warning));border-radius:var(--px-4);color:hsl(var(--color-warning));padding:var(--px-8)}.graphiql-doc-explorer-deprecation-label{font-size:var(--font-size-hint);font-weight:var(--font-weight-medium)}\n")();
var __defProp$s = Object.defineProperty;
var __name$s = /* @__PURE__ */ __name((target2, value3) => __defProp$s(target2, "name", { value: value3, configurable: true }), "__name$s");
function DeprecationReason(props2) {
  return props2.children ? /* @__PURE__ */ jsxs("div", {
    className: "graphiql-doc-explorer-deprecation",
    children: [/* @__PURE__ */ jsx("div", {
      className: "graphiql-doc-explorer-deprecation-label",
      children: "Deprecated"
    }), /* @__PURE__ */ jsx(MarkdownContent, {
      type: "deprecation",
      onlyShowFirstChild: true,
      children: props2.children
    })]
  }) : null;
}
__name(DeprecationReason, "DeprecationReason");
__name$s(DeprecationReason, "DeprecationReason");
var directive = /* @__PURE__ */ (() => ".graphiql-doc-explorer-directive{color:hsl(var(--color-secondary))}\n")();
var __defProp$r = Object.defineProperty;
var __name$r = /* @__PURE__ */ __name((target2, value3) => __defProp$r(target2, "name", { value: value3, configurable: true }), "__name$r");
function Directive({
  directive: directive2
}) {
  return /* @__PURE__ */ jsxs("span", {
    className: "graphiql-doc-explorer-directive",
    children: ["@", directive2.name.value]
  });
}
__name(Directive, "Directive");
__name$r(Directive, "Directive");
var section = /* @__PURE__ */ (() => ".graphiql-doc-explorer-section-title{align-items:center;display:flex;font-size:var(--font-size-hint);font-weight:var(--font-weight-medium);line-height:1}.graphiql-doc-explorer-section-title>svg{height:var(--px-16);margin-right:var(--px-8);width:var(--px-16)}.graphiql-doc-explorer-section-content{margin-left:var(--px-8);margin-top:var(--px-16)}.graphiql-doc-explorer-section-content>*+*{margin-top:var(--px-16)}\n")();
var __defProp$q = Object.defineProperty;
var __name$q = /* @__PURE__ */ __name((target2, value3) => __defProp$q(target2, "name", { value: value3, configurable: true }), "__name$q");
function ExplorerSection(props2) {
  const Icon2 = TYPE_TO_ICON[props2.title];
  return /* @__PURE__ */ jsxs("div", {
    children: [/* @__PURE__ */ jsxs("div", {
      className: "graphiql-doc-explorer-section-title",
      children: [/* @__PURE__ */ jsx(Icon2, {}), props2.title]
    }), /* @__PURE__ */ jsx("div", {
      className: "graphiql-doc-explorer-section-content",
      children: props2.children
    })]
  });
}
__name(ExplorerSection, "ExplorerSection");
__name$q(ExplorerSection, "ExplorerSection");
const TYPE_TO_ICON = {
  Arguments: ArgumentIcon,
  "Deprecated Arguments": DeprecatedArgumentIcon,
  "Deprecated Enum Values": DeprecatedEnumValueIcon,
  "Deprecated Fields": DeprecatedFieldIcon,
  Directives: DirectiveIcon,
  "Enum Values": EnumValueIcon,
  Fields: FieldIcon,
  Implements: ImplementsIcon,
  Implementations: TypeIcon,
  "Possible Types": TypeIcon,
  "Root Types": RootTypeIcon,
  Type: TypeIcon
};
var __defProp$p = Object.defineProperty;
var __name$p = /* @__PURE__ */ __name((target2, value3) => __defProp$p(target2, "name", { value: value3, configurable: true }), "__name$p");
function FieldDocumentation(props2) {
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [props2.field.description ? /* @__PURE__ */ jsx(MarkdownContent, {
      type: "description",
      children: props2.field.description
    }) : null, /* @__PURE__ */ jsx(DeprecationReason, {
      children: props2.field.deprecationReason
    }), /* @__PURE__ */ jsx(ExplorerSection, {
      title: "Type",
      children: /* @__PURE__ */ jsx(TypeLink, {
        type: props2.field.type
      })
    }), /* @__PURE__ */ jsx(Arguments, {
      field: props2.field
    }), /* @__PURE__ */ jsx(Directives, {
      field: props2.field
    })]
  });
}
__name(FieldDocumentation, "FieldDocumentation");
__name$p(FieldDocumentation, "FieldDocumentation");
function Arguments({
  field
}) {
  const [showDeprecated, setShowDeprecated] = useState(false);
  if (!("args" in field)) {
    return null;
  }
  const args = [];
  const deprecatedArgs = [];
  for (const argument2 of field.args) {
    if (argument2.deprecationReason) {
      deprecatedArgs.push(argument2);
    } else {
      args.push(argument2);
    }
  }
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [args.length > 0 ? /* @__PURE__ */ jsx(ExplorerSection, {
      title: "Arguments",
      children: args.map((arg) => /* @__PURE__ */ jsx(Argument, {
        arg
      }, arg.name))
    }) : null, deprecatedArgs.length > 0 ? showDeprecated || args.length === 0 ? /* @__PURE__ */ jsx(ExplorerSection, {
      title: "Deprecated Arguments",
      children: deprecatedArgs.map((arg) => /* @__PURE__ */ jsx(Argument, {
        arg
      }, arg.name))
    }) : /* @__PURE__ */ jsx(Button, {
      type: "button",
      onClick: () => {
        setShowDeprecated(true);
      },
      children: "Show Deprecated Arguments"
    }) : null]
  });
}
__name(Arguments, "Arguments");
__name$p(Arguments, "Arguments");
function Directives({
  field
}) {
  var _a;
  const directives = ((_a = field.astNode) == null ? void 0 : _a.directives) || [];
  if (!directives || directives.length === 0) {
    return null;
  }
  return /* @__PURE__ */ jsx(ExplorerSection, {
    title: "Directives",
    children: directives.map((directive2) => /* @__PURE__ */ jsx("div", {
      children: /* @__PURE__ */ jsx(Directive, {
        directive: directive2
      })
    }, directive2.name.value))
  });
}
__name(Directives, "Directives");
__name$p(Directives, "Directives");
var schemaDocumentation = /* @__PURE__ */ (() => ".graphiql-doc-explorer-root-type{color:hsl(var(--color-info))}\n")();
var __defProp$o = Object.defineProperty;
var __name$o = /* @__PURE__ */ __name((target2, value3) => __defProp$o(target2, "name", { value: value3, configurable: true }), "__name$o");
function SchemaDocumentation(props2) {
  var _a, _b, _c, _d;
  const queryType = props2.schema.getQueryType();
  const mutationType = (_b = (_a = props2.schema).getMutationType) == null ? void 0 : _b.call(_a);
  const subscriptionType = (_d = (_c = props2.schema).getSubscriptionType) == null ? void 0 : _d.call(_c);
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsx(MarkdownContent, {
      type: "description",
      children: props2.schema.description || "A GraphQL schema provides a root type for each kind of operation."
    }), /* @__PURE__ */ jsxs(ExplorerSection, {
      title: "Root Types",
      children: [queryType ? /* @__PURE__ */ jsxs("div", {
        children: [/* @__PURE__ */ jsx("span", {
          className: "graphiql-doc-explorer-root-type",
          children: "query"
        }), ": ", /* @__PURE__ */ jsx(TypeLink, {
          type: queryType
        })]
      }) : null, mutationType && /* @__PURE__ */ jsxs("div", {
        children: [/* @__PURE__ */ jsx("span", {
          className: "graphiql-doc-explorer-root-type",
          children: "mutation"
        }), ": ", /* @__PURE__ */ jsx(TypeLink, {
          type: mutationType
        })]
      }), subscriptionType && /* @__PURE__ */ jsxs("div", {
        children: [/* @__PURE__ */ jsx("span", {
          className: "graphiql-doc-explorer-root-type",
          children: "subscription"
        }), ": ", /* @__PURE__ */ jsx(TypeLink, {
          type: subscriptionType
        })]
      })]
    })]
  });
}
__name(SchemaDocumentation, "SchemaDocumentation");
__name$o(SchemaDocumentation, "SchemaDocumentation");
function useUpdateEffect(effect, deps) {
  var mounted = useRef(false);
  useEffect(function() {
    if (mounted.current) {
      effect();
    } else {
      mounted.current = true;
    }
  }, deps);
}
__name(useUpdateEffect, "useUpdateEffect");
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target2 = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target2[key] = source[key];
  }
  return target2;
}
__name(_objectWithoutPropertiesLoose, "_objectWithoutPropertiesLoose");
function _extends() {
  _extends = Object.assign || function(target2) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target2[key] = source[key];
        }
      }
    }
    return target2;
  };
  return _extends.apply(this, arguments);
}
__name(_extends, "_extends");
function findAll(_ref2) {
  var autoEscape2 = _ref2.autoEscape, _ref$caseSensitive = _ref2.caseSensitive, caseSensitive = _ref$caseSensitive === void 0 ? false : _ref$caseSensitive, _ref$findChunks = _ref2.findChunks, findChunks = _ref$findChunks === void 0 ? defaultFindChunks : _ref$findChunks, sanitize = _ref2.sanitize, searchWords = _ref2.searchWords, textToHighlight = _ref2.textToHighlight;
  return fillInChunks({
    chunksToHighlight: combineChunks({
      chunks: findChunks({
        autoEscape: autoEscape2,
        caseSensitive,
        sanitize,
        searchWords,
        textToHighlight
      })
    }),
    totalLength: textToHighlight ? textToHighlight.length : 0
  });
}
__name(findAll, "findAll");
function combineChunks(_ref2) {
  var chunks = _ref2.chunks;
  return chunks.sort(function(first, second) {
    return first.start - second.start;
  }).reduce(function(processedChunks, nextChunk) {
    if (processedChunks.length === 0) {
      return [nextChunk];
    } else {
      var prevChunk = processedChunks.pop();
      if (nextChunk.start <= prevChunk.end) {
        var endIndex = Math.max(prevChunk.end, nextChunk.end);
        processedChunks.push({
          highlight: false,
          start: prevChunk.start,
          end: endIndex
        });
      } else {
        processedChunks.push(prevChunk, nextChunk);
      }
      return processedChunks;
    }
  }, []);
}
__name(combineChunks, "combineChunks");
function defaultFindChunks(_ref3) {
  var autoEscape2 = _ref3.autoEscape, caseSensitive = _ref3.caseSensitive, _ref3$sanitize = _ref3.sanitize, sanitize = _ref3$sanitize === void 0 ? defaultSanitize : _ref3$sanitize, searchWords = _ref3.searchWords, textToHighlight = _ref3.textToHighlight;
  textToHighlight = sanitize(textToHighlight || "");
  return searchWords.filter(function(searchWord) {
    return searchWord;
  }).reduce(function(chunks, searchWord) {
    searchWord = sanitize(searchWord);
    if (autoEscape2) {
      searchWord = escapeRegExpFn(searchWord);
    }
    var regex2 = new RegExp(searchWord, caseSensitive ? "g" : "gi");
    var match2;
    while (match2 = regex2.exec(textToHighlight || "")) {
      var start = match2.index;
      var end = regex2.lastIndex;
      if (end > start) {
        chunks.push({
          highlight: false,
          start,
          end
        });
      }
      if (match2.index === regex2.lastIndex) {
        regex2.lastIndex++;
      }
    }
    return chunks;
  }, []);
}
__name(defaultFindChunks, "defaultFindChunks");
function fillInChunks(_ref4) {
  var chunksToHighlight = _ref4.chunksToHighlight, totalLength = _ref4.totalLength;
  var allChunks = [];
  if (chunksToHighlight.length === 0) {
    append(0, totalLength, false);
  } else {
    var lastIndex = 0;
    chunksToHighlight.forEach(function(chunk) {
      append(lastIndex, chunk.start, false);
      append(chunk.start, chunk.end, true);
      lastIndex = chunk.end;
    });
    append(lastIndex, totalLength, false);
  }
  return allChunks;
  function append(start, end, highlight) {
    if (end - start > 0) {
      allChunks.push({
        start,
        end,
        highlight
      });
    }
  }
  __name(append, "append");
}
__name(fillInChunks, "fillInChunks");
function defaultSanitize(string) {
  return string;
}
__name(defaultSanitize, "defaultSanitize");
function escapeRegExpFn(string) {
  return string.replace(/[-[\]/{}()*+?.\\^$|]/g, "\\$&");
}
__name(escapeRegExpFn, "escapeRegExpFn");
var HighlightWords = {
  combineChunks,
  fillInChunks,
  findAll,
  findChunks: defaultFindChunks
};
var _excluded = ["onSelect", "openOnFocus", "children", "as", "aria-label", "aria-labelledby"], _excluded2 = ["as", "selectOnClick", "autocomplete", "onClick", "onChange", "onKeyDown", "onBlur", "onFocus", "value"], _excluded3 = ["as", "children", "portal", "onKeyDown", "onBlur", "position"], _excluded4 = ["persistSelection", "as"], _excluded5 = ["as", "children", "index", "value", "onClick"];
var _on, _on2, _on3, _on4, _states;
var IDLE = "IDLE";
var SUGGESTING = "SUGGESTING";
var NAVIGATING = "NAVIGATING";
var INTERACTING = "INTERACTING";
var CLEAR = "CLEAR";
var CHANGE = "CHANGE";
var INITIAL_CHANGE = "INITIAL_CHANGE";
var NAVIGATE = "NAVIGATE";
var SELECT_WITH_KEYBOARD = "SELECT_WITH_KEYBOARD";
var SELECT_WITH_CLICK = "SELECT_WITH_CLICK";
var ESCAPE = "ESCAPE";
var BLUR = "BLUR";
var INTERACT = "INTERACT";
var FOCUS = "FOCUS";
var OPEN_WITH_BUTTON = "OPEN_WITH_BUTTON";
var OPEN_WITH_INPUT_CLICK = "OPEN_WITH_INPUT_CLICK";
var CLOSE_WITH_BUTTON = "CLOSE_WITH_BUTTON";
var stateChart = {
  initial: IDLE,
  states: (_states = {}, _states[IDLE] = {
    on: (_on = {}, _on[BLUR] = IDLE, _on[CLEAR] = IDLE, _on[CHANGE] = SUGGESTING, _on[INITIAL_CHANGE] = IDLE, _on[FOCUS] = SUGGESTING, _on[NAVIGATE] = NAVIGATING, _on[OPEN_WITH_BUTTON] = SUGGESTING, _on[OPEN_WITH_INPUT_CLICK] = SUGGESTING, _on)
  }, _states[SUGGESTING] = {
    on: (_on2 = {}, _on2[CHANGE] = SUGGESTING, _on2[FOCUS] = SUGGESTING, _on2[NAVIGATE] = NAVIGATING, _on2[CLEAR] = IDLE, _on2[ESCAPE] = IDLE, _on2[BLUR] = IDLE, _on2[SELECT_WITH_CLICK] = IDLE, _on2[INTERACT] = INTERACTING, _on2[CLOSE_WITH_BUTTON] = IDLE, _on2)
  }, _states[NAVIGATING] = {
    on: (_on3 = {}, _on3[CHANGE] = SUGGESTING, _on3[FOCUS] = SUGGESTING, _on3[CLEAR] = IDLE, _on3[BLUR] = IDLE, _on3[ESCAPE] = IDLE, _on3[NAVIGATE] = NAVIGATING, _on3[SELECT_WITH_CLICK] = IDLE, _on3[SELECT_WITH_KEYBOARD] = IDLE, _on3[CLOSE_WITH_BUTTON] = IDLE, _on3[INTERACT] = INTERACTING, _on3)
  }, _states[INTERACTING] = {
    on: (_on4 = {}, _on4[CLEAR] = IDLE, _on4[CHANGE] = SUGGESTING, _on4[FOCUS] = SUGGESTING, _on4[BLUR] = IDLE, _on4[ESCAPE] = IDLE, _on4[NAVIGATE] = NAVIGATING, _on4[CLOSE_WITH_BUTTON] = IDLE, _on4[SELECT_WITH_CLICK] = IDLE, _on4)
  }, _states)
};
var reducer = /* @__PURE__ */ __name(function reducer2(data, event) {
  var nextState = _extends({}, data, {
    lastEventType: event.type
  });
  switch (event.type) {
    case CHANGE:
    case INITIAL_CHANGE:
      return _extends({}, nextState, {
        navigationValue: null,
        value: event.value
      });
    case NAVIGATE:
    case OPEN_WITH_BUTTON:
    case OPEN_WITH_INPUT_CLICK:
      return _extends({}, nextState, {
        navigationValue: findNavigationValue(nextState, event)
      });
    case CLEAR:
      return _extends({}, nextState, {
        value: "",
        navigationValue: null
      });
    case BLUR:
    case ESCAPE:
      return _extends({}, nextState, {
        navigationValue: null
      });
    case SELECT_WITH_CLICK:
      return _extends({}, nextState, {
        value: event.isControlled ? data.value : event.value,
        navigationValue: null
      });
    case SELECT_WITH_KEYBOARD:
      return _extends({}, nextState, {
        value: event.isControlled ? data.value : data.navigationValue,
        navigationValue: null
      });
    case CLOSE_WITH_BUTTON:
      return _extends({}, nextState, {
        navigationValue: null
      });
    case INTERACT:
      return nextState;
    case FOCUS:
      return _extends({}, nextState, {
        navigationValue: findNavigationValue(nextState, event)
      });
    default:
      return nextState;
  }
}, "reducer");
function popoverIsExpanded(state2) {
  return [SUGGESTING, NAVIGATING, INTERACTING].includes(state2);
}
__name(popoverIsExpanded, "popoverIsExpanded");
function findNavigationValue(stateData, event) {
  if (event.value) {
    return event.value;
  } else if (event.persistSelection) {
    return stateData.value;
  } else {
    return null;
  }
}
__name(findNavigationValue, "findNavigationValue");
var ComboboxDescendantContext = /* @__PURE__ */ createDescendantContext();
var ComboboxContext = /* @__PURE__ */ createNamedContext("ComboboxContext", {});
var OptionContext = /* @__PURE__ */ createNamedContext("OptionContext", {});
var Combobox = /* @__PURE__ */ forwardRef(function(_ref2, forwardedRef) {
  var _data$navigationValue;
  var onSelect = _ref2.onSelect, _ref$openOnFocus = _ref2.openOnFocus, openOnFocus = _ref$openOnFocus === void 0 ? false : _ref$openOnFocus, children = _ref2.children, _ref$as = _ref2.as, Comp = _ref$as === void 0 ? "div" : _ref$as, ariaLabel = _ref2["aria-label"], ariaLabelledby = _ref2["aria-labelledby"], props2 = _objectWithoutPropertiesLoose(_ref2, _excluded);
  var _useDescendantsInit = useDescendantsInit(), options = _useDescendantsInit[0], setOptions = _useDescendantsInit[1];
  var inputRef = useRef();
  var popoverRef = useRef();
  var buttonRef = useRef();
  var autocompletePropRef = useRef(false);
  var persistSelectionRef = useRef(false);
  var defaultData = {
    value: "",
    navigationValue: null
  };
  var _useReducerMachine = useReducerMachine(stateChart, reducer, defaultData), state2 = _useReducerMachine[0], data = _useReducerMachine[1], transition2 = _useReducerMachine[2];
  useFocusManagement(data.lastEventType, inputRef);
  var id2 = useId(props2.id);
  var listboxId = id2 ? makeId("listbox", id2) : "listbox";
  var isControlledRef = useRef(false);
  var isExpanded = popoverIsExpanded(state2);
  var context = {
    ariaLabel,
    ariaLabelledby,
    autocompletePropRef,
    buttonRef,
    comboboxId: id2,
    data,
    inputRef,
    isExpanded,
    listboxId,
    onSelect: onSelect || noop,
    openOnFocus,
    persistSelectionRef,
    popoverRef,
    state: state2,
    transition: transition2,
    isControlledRef
  };
  return /* @__PURE__ */ createElement(DescendantProvider, {
    context: ComboboxDescendantContext,
    items: options,
    set: setOptions
  }, /* @__PURE__ */ createElement(ComboboxContext.Provider, {
    value: context
  }, /* @__PURE__ */ createElement(Comp, _extends({}, props2, {
    "data-reach-combobox": "",
    "data-state": getDataState(state2),
    "data-expanded": isExpanded || void 0,
    ref: forwardedRef
  }), isFunction$1(children) ? children({
    id: id2,
    isExpanded,
    navigationValue: (_data$navigationValue = data.navigationValue) != null ? _data$navigationValue : null,
    state: state2
  }) : children)));
});
var ComboboxInput = /* @__PURE__ */ forwardRef(function(_ref2, forwardedRef) {
  var _ref2$as = _ref2.as, Comp = _ref2$as === void 0 ? "input" : _ref2$as, _ref2$selectOnClick = _ref2.selectOnClick, selectOnClick = _ref2$selectOnClick === void 0 ? false : _ref2$selectOnClick, _ref2$autocomplete = _ref2.autocomplete, autocomplete = _ref2$autocomplete === void 0 ? true : _ref2$autocomplete, onClick = _ref2.onClick, onChange = _ref2.onChange, onKeyDown = _ref2.onKeyDown, onBlur3 = _ref2.onBlur, onFocus3 = _ref2.onFocus, controlledValue = _ref2.value, props2 = _objectWithoutPropertiesLoose(_ref2, _excluded2);
  var _React$useRef = useRef(controlledValue), initialControlledValue = _React$useRef.current;
  var controlledValueChangedRef = useRef(false);
  useUpdateEffect(function() {
    controlledValueChangedRef.current = true;
  }, [controlledValue]);
  var _React$useContext = useContext(ComboboxContext), _React$useContext$dat = _React$useContext.data, navigationValue4 = _React$useContext$dat.navigationValue, value3 = _React$useContext$dat.value, lastEventType = _React$useContext$dat.lastEventType, inputRef = _React$useContext.inputRef, state2 = _React$useContext.state, transition2 = _React$useContext.transition, listboxId = _React$useContext.listboxId, autocompletePropRef = _React$useContext.autocompletePropRef, openOnFocus = _React$useContext.openOnFocus, isExpanded = _React$useContext.isExpanded, ariaLabel = _React$useContext.ariaLabel, ariaLabelledby = _React$useContext.ariaLabelledby, persistSelectionRef = _React$useContext.persistSelectionRef, isControlledRef = _React$useContext.isControlledRef;
  var ref = useComposedRefs(inputRef, forwardedRef);
  var selectOnClickRef = useRef(false);
  var handleKeyDown = useKeyDown();
  var handleBlur = useBlur();
  var isControlled = typeof controlledValue !== "undefined";
  useEffect(function() {
    isControlledRef.current = isControlled;
  }, [isControlled]);
  useIsomorphicLayoutEffect(function() {
    autocompletePropRef.current = autocomplete;
  }, [autocomplete, autocompletePropRef]);
  var handleValueChange = useCallback(function(value4) {
    if (value4.trim() === "") {
      transition2(CLEAR, {
        isControlled
      });
    } else if (value4 === initialControlledValue && !controlledValueChangedRef.current) {
      transition2(INITIAL_CHANGE, {
        value: value4
      });
    } else {
      transition2(CHANGE, {
        value: value4
      });
    }
  }, [initialControlledValue, transition2, isControlled]);
  useEffect(function() {
    if (isControlled && controlledValue !== value3 && (controlledValue.trim() === "" ? (value3 || "").trim() !== "" : true)) {
      handleValueChange(controlledValue);
    }
  }, [controlledValue, handleValueChange, isControlled, value3]);
  function handleChange(event) {
    var value4 = event.target.value;
    if (!isControlled) {
      handleValueChange(value4);
    }
  }
  __name(handleChange, "handleChange");
  function handleFocus() {
    if (selectOnClick) {
      selectOnClickRef.current = true;
    }
    if (openOnFocus && lastEventType !== SELECT_WITH_CLICK) {
      transition2(FOCUS, {
        persistSelection: persistSelectionRef.current
      });
    }
  }
  __name(handleFocus, "handleFocus");
  function handleClick() {
    if (selectOnClickRef.current) {
      var _inputRef$current;
      selectOnClickRef.current = false;
      (_inputRef$current = inputRef.current) == null ? void 0 : _inputRef$current.select();
    }
    if (openOnFocus && state2 === IDLE) {
      transition2(OPEN_WITH_INPUT_CLICK);
    }
  }
  __name(handleClick, "handleClick");
  var inputValue = autocomplete && (state2 === NAVIGATING || state2 === INTERACTING) ? navigationValue4 || controlledValue || value3 : controlledValue || value3;
  return /* @__PURE__ */ createElement(Comp, _extends({
    "aria-activedescendant": navigationValue4 ? String(makeHash(navigationValue4)) : void 0,
    "aria-autocomplete": "both",
    "aria-controls": listboxId,
    "aria-expanded": isExpanded,
    "aria-haspopup": "listbox",
    "aria-label": ariaLabel,
    "aria-labelledby": ariaLabel ? void 0 : ariaLabelledby,
    role: "combobox"
  }, props2, {
    "data-reach-combobox-input": "",
    "data-state": getDataState(state2),
    ref,
    onBlur: composeEventHandlers(onBlur3, handleBlur),
    onChange: composeEventHandlers(onChange, handleChange),
    onClick: composeEventHandlers(onClick, handleClick),
    onFocus: composeEventHandlers(onFocus3, handleFocus),
    onKeyDown: composeEventHandlers(onKeyDown, handleKeyDown),
    value: inputValue || ""
  }));
});
var ComboboxPopover = /* @__PURE__ */ forwardRef(function(_ref3, forwardedRef) {
  var _ref3$as = _ref3.as, Comp = _ref3$as === void 0 ? "div" : _ref3$as, children = _ref3.children, _ref3$portal = _ref3.portal, portal = _ref3$portal === void 0 ? true : _ref3$portal, onKeyDown = _ref3.onKeyDown, onBlur3 = _ref3.onBlur, _ref3$position = _ref3.position, position = _ref3$position === void 0 ? positionMatchWidth : _ref3$position, props2 = _objectWithoutPropertiesLoose(_ref3, _excluded3);
  var _React$useContext2 = useContext(ComboboxContext), popoverRef = _React$useContext2.popoverRef, inputRef = _React$useContext2.inputRef, isExpanded = _React$useContext2.isExpanded, state2 = _React$useContext2.state;
  var ref = useComposedRefs(popoverRef, forwardedRef);
  var handleKeyDown = useKeyDown();
  var handleBlur = useBlur();
  var sharedProps = {
    "data-reach-combobox-popover": "",
    "data-state": getDataState(state2),
    onKeyDown: composeEventHandlers(onKeyDown, handleKeyDown),
    onBlur: composeEventHandlers(onBlur3, handleBlur),
    hidden: !isExpanded,
    tabIndex: -1,
    children
  };
  return portal ? /* @__PURE__ */ createElement(Popover, _extends({
    as: Comp
  }, props2, {
    ref,
    "data-expanded": isExpanded || void 0,
    position,
    targetRef: inputRef,
    unstable_skipInitialPortalRender: true
  }, sharedProps)) : /* @__PURE__ */ createElement(Comp, _extends({
    ref
  }, props2, sharedProps));
});
var ComboboxList = /* @__PURE__ */ forwardRef(function(_ref4, forwardedRef) {
  var _ref4$persistSelectio = _ref4.persistSelection, persistSelection = _ref4$persistSelectio === void 0 ? false : _ref4$persistSelectio, _ref4$as = _ref4.as, Comp = _ref4$as === void 0 ? "ul" : _ref4$as, props2 = _objectWithoutPropertiesLoose(_ref4, _excluded4);
  var _React$useContext3 = useContext(ComboboxContext), persistSelectionRef = _React$useContext3.persistSelectionRef, listboxId = _React$useContext3.listboxId;
  if (persistSelection) {
    persistSelectionRef.current = true;
  }
  return /* @__PURE__ */ createElement(Comp, _extends({
    role: "listbox"
  }, props2, {
    ref: forwardedRef,
    "data-reach-combobox-list": "",
    id: listboxId
  }));
});
var ComboboxOption = /* @__PURE__ */ forwardRef(function(_ref5, forwardedRef) {
  var _ref5$as = _ref5.as, Comp = _ref5$as === void 0 ? "li" : _ref5$as, children = _ref5.children, indexProp = _ref5.index, value3 = _ref5.value, onClick = _ref5.onClick, props2 = _objectWithoutPropertiesLoose(_ref5, _excluded5);
  var _React$useContext4 = useContext(ComboboxContext), onSelect = _React$useContext4.onSelect, navigationValue4 = _React$useContext4.data.navigationValue, transition2 = _React$useContext4.transition, isControlledRef = _React$useContext4.isControlledRef;
  var ownRef = useRef(null);
  var _useStatefulRefValue = useStatefulRefValue(ownRef, null), element = _useStatefulRefValue[0], handleRefSet = _useStatefulRefValue[1];
  var descendant = useMemo(function() {
    return {
      element,
      value: value3
    };
  }, [value3, element]);
  var index = useDescendant(descendant, ComboboxDescendantContext, indexProp);
  var ref = useComposedRefs(forwardedRef, handleRefSet);
  var isActive = navigationValue4 === value3;
  var handleClick = /* @__PURE__ */ __name(function handleClick2() {
    onSelect && onSelect(value3);
    transition2(SELECT_WITH_CLICK, {
      value: value3,
      isControlled: isControlledRef.current
    });
  }, "handleClick");
  return /* @__PURE__ */ createElement(OptionContext.Provider, {
    value: {
      value: value3,
      index
    }
  }, /* @__PURE__ */ createElement(Comp, _extends({
    "aria-selected": isActive,
    role: "option"
  }, props2, {
    "data-reach-combobox-option": "",
    ref,
    id: String(makeHash(value3)),
    "data-highlighted": isActive ? "" : void 0,
    tabIndex: -1,
    onClick: composeEventHandlers(onClick, handleClick)
  }), children ? isFunction$1(children) ? children({
    value: value3,
    index
  }) : children : /* @__PURE__ */ createElement(ComboboxOptionText, null)));
});
function ComboboxOptionText() {
  var _React$useContext5 = useContext(OptionContext), value3 = _React$useContext5.value;
  var _React$useContext6 = useContext(ComboboxContext), contextValue = _React$useContext6.data.value;
  var results = useMemo(function() {
    return HighlightWords.findAll({
      searchWords: escapeRegexp(contextValue || "").split(/\s+/),
      textToHighlight: value3
    });
  }, [contextValue, value3]);
  return /* @__PURE__ */ createElement(Fragment$1, null, results.length ? results.map(function(result, index) {
    var str = value3.slice(result.start, result.end);
    return /* @__PURE__ */ createElement("span", {
      key: index,
      "data-reach-combobox-option-text": "",
      "data-user-value": result.highlight ? true : void 0,
      "data-suggested-value": result.highlight ? void 0 : true
    }, str);
  }) : value3);
}
__name(ComboboxOptionText, "ComboboxOptionText");
function useFocusManagement(lastEventType, inputRef) {
  useIsomorphicLayoutEffect(function() {
    if (lastEventType === NAVIGATE || lastEventType === ESCAPE || lastEventType === SELECT_WITH_CLICK || lastEventType === OPEN_WITH_BUTTON) {
      var _inputRef$current2;
      (_inputRef$current2 = inputRef.current) == null ? void 0 : _inputRef$current2.focus();
    }
  }, [inputRef, lastEventType]);
}
__name(useFocusManagement, "useFocusManagement");
function useKeyDown() {
  var _React$useContext8 = useContext(ComboboxContext), navigationValue4 = _React$useContext8.data.navigationValue, onSelect = _React$useContext8.onSelect, state2 = _React$useContext8.state, transition2 = _React$useContext8.transition, autocompletePropRef = _React$useContext8.autocompletePropRef, persistSelectionRef = _React$useContext8.persistSelectionRef, isControlledRef = _React$useContext8.isControlledRef;
  var options = useDescendants(ComboboxDescendantContext);
  return /* @__PURE__ */ __name(function handleKeyDown(event) {
    var index = options.findIndex(function(_ref7) {
      var value3 = _ref7.value;
      return value3 === navigationValue4;
    });
    function getNextOption() {
      var atBottom = index === options.length - 1;
      if (atBottom) {
        if (autocompletePropRef.current) {
          return null;
        } else {
          return getFirstOption();
        }
      } else {
        return options[(index + 1) % options.length];
      }
    }
    __name(getNextOption, "getNextOption");
    function getPreviousOption() {
      var atTop = index === 0;
      if (atTop) {
        if (autocompletePropRef.current) {
          return null;
        } else {
          return getLastOption();
        }
      } else if (index === -1) {
        return getLastOption();
      } else {
        return options[(index - 1 + options.length) % options.length];
      }
    }
    __name(getPreviousOption, "getPreviousOption");
    function getFirstOption() {
      return options[0];
    }
    __name(getFirstOption, "getFirstOption");
    function getLastOption() {
      return options[options.length - 1];
    }
    __name(getLastOption, "getLastOption");
    switch (event.key) {
      case "ArrowDown":
        event.preventDefault();
        if (!options || !options.length) {
          return;
        }
        if (state2 === IDLE) {
          transition2(NAVIGATE, {
            persistSelection: persistSelectionRef.current
          });
        } else {
          var next = getNextOption();
          transition2(NAVIGATE, {
            value: next ? next.value : null
          });
        }
        break;
      case "ArrowUp":
        event.preventDefault();
        if (!options || options.length === 0) {
          return;
        }
        if (state2 === IDLE) {
          transition2(NAVIGATE);
        } else {
          var prev = getPreviousOption();
          transition2(NAVIGATE, {
            value: prev ? prev.value : null
          });
        }
        break;
      case "Home":
      case "PageUp":
        event.preventDefault();
        if (!options || options.length === 0) {
          return;
        }
        if (state2 === IDLE) {
          transition2(NAVIGATE);
        } else {
          transition2(NAVIGATE, {
            value: getFirstOption().value
          });
        }
        break;
      case "End":
      case "PageDown":
        event.preventDefault();
        if (!options || options.length === 0) {
          return;
        }
        if (state2 === IDLE) {
          transition2(NAVIGATE);
        } else {
          transition2(NAVIGATE, {
            value: getLastOption().value
          });
        }
        break;
      case "Escape":
        if (state2 !== IDLE) {
          transition2(ESCAPE);
        }
        break;
      case "Enter":
        if (state2 === NAVIGATING && navigationValue4 !== null) {
          event.preventDefault();
          onSelect && onSelect(navigationValue4);
          transition2(SELECT_WITH_KEYBOARD, {
            isControlled: isControlledRef.current
          });
        }
        break;
    }
  }, "handleKeyDown");
}
__name(useKeyDown, "useKeyDown");
function useBlur() {
  var _React$useContext9 = useContext(ComboboxContext), state2 = _React$useContext9.state, transition2 = _React$useContext9.transition, popoverRef = _React$useContext9.popoverRef, inputRef = _React$useContext9.inputRef, buttonRef = _React$useContext9.buttonRef;
  return /* @__PURE__ */ __name(function handleBlur(event) {
    var popover = popoverRef.current;
    var input = inputRef.current;
    var button2 = buttonRef.current;
    var activeElement = event.relatedTarget;
    if (activeElement !== input && activeElement !== button2 && popover) {
      if (popover.contains(activeElement)) {
        if (state2 !== INTERACTING) {
          transition2(INTERACT);
        }
      } else {
        transition2(BLUR);
      }
    }
  }, "handleBlur");
}
__name(useBlur, "useBlur");
function useReducerMachine(chart2, reducer3, initialData) {
  var _React$useState = useState(chart2.initial), state2 = _React$useState[0], setState = _React$useState[1];
  var _React$useReducer = useReducer(reducer3, initialData), data = _React$useReducer[0], dispatch = _React$useReducer[1];
  var transition2 = /* @__PURE__ */ __name(function transition3(event, payload) {
    if (payload === void 0) {
      payload = {};
    }
    var currentState = chart2.states[state2];
    var nextState = currentState && currentState.on[event];
    if (nextState) {
      dispatch(_extends({
        type: event,
        state: state2,
        nextState: state2
      }, payload));
      setState(nextState);
      return;
    }
  }, "transition");
  return [state2, data, transition2];
}
__name(useReducerMachine, "useReducerMachine");
function makeHash(str) {
  var hash = 0;
  if (str.length === 0) {
    return hash;
  }
  for (var i = 0; i < str.length; i++) {
    var _char = str.charCodeAt(i);
    hash = (hash << 5) - hash + _char;
    hash = hash & hash;
  }
  return hash;
}
__name(makeHash, "makeHash");
function getDataState(state2) {
  return state2.toLowerCase();
}
__name(getDataState, "getDataState");
function escapeRegexp(str) {
  return String(str).replace(/([.*+?=^!:${}()|[\]/\\])/g, "\\$1");
}
__name(escapeRegexp, "escapeRegexp");
var __defProp$n = Object.defineProperty;
var __name$n = /* @__PURE__ */ __name((target2, value3) => __defProp$n(target2, "name", { value: value3, configurable: true }), "__name$n");
function debounce(duration, fn) {
  let timeout;
  return function(...args) {
    if (timeout) {
      window.clearTimeout(timeout);
    }
    timeout = window.setTimeout(() => {
      timeout = null;
      fn(...args);
    }, duration);
  };
}
__name(debounce, "debounce");
__name$n(debounce, "debounce");
var search = /* @__PURE__ */ (() => ':root{--reach-combobox: 1}[data-reach-combobox-popover]{border:solid 1px hsla(0,0%,0%,.25);background:hsla(0,100%,100%,.99);font-size:85%}[data-reach-combobox-list]{list-style:none;margin:0;padding:0;user-select:none}[data-reach-combobox-option]{cursor:pointer;margin:0;padding:.25rem .5rem}[data-reach-combobox-option][aria-selected=true]{background:hsl(211,10%,95%)}[data-reach-combobox-option]:hover{background:hsl(211,10%,92%)}[data-reach-combobox-option][aria-selected=true]:hover{background:hsl(211,10%,90%)}[data-suggested-value]{font-weight:700}[data-reach-combobox]{color:hsla(var(--color-neutral),var(--alpha-secondary))}[data-reach-combobox]:not([data-state="idle"]){border:var(--popover-border);border-radius:var(--border-radius-4);box-shadow:var(--popover-box-shadow);color:hsla(var(--color-neutral),1)}[data-reach-combobox]:not([data-state="idle"]) .graphiql-doc-explorer-search-input{background:hsl(var(--color-base));border-bottom-left-radius:0;border-bottom-right-radius:0}.graphiql-doc-explorer-search-input{align-items:center;background-color:hsla(var(--color-neutral),var(--alpha-background-light));border-radius:var(--border-radius-4);display:flex;padding:var(--px-8) var(--px-12)}[data-reach-combobox-input]{border:none;background-color:transparent;margin-left:var(--px-4);width:100%}[data-reach-combobox-input]:focus{outline:none}[data-reach-combobox-popover]{background-color:hsl(var(--color-base));border:none;border-bottom-left-radius:var(--border-radius-4);border-bottom-right-radius:var(--border-radius-4);border-top:1px solid hsla(var(--color-neutral),var(--alpha-background-heavy));max-height:400px;overflow-y:auto;position:relative}[data-reach-combobox-list]{font-size:var(--font-size-body);padding:var(--px-4)}[data-reach-combobox-option]{border-radius:var(--border-radius-4);color:hsla(var(--color-neutral),var(--alpha-secondary));overflow-x:hidden;padding:var(--px-8) var(--px-12);text-overflow:ellipsis;white-space:nowrap}[data-reach-combobox-option][data-highlighted]{background-color:hsla(var(--color-neutral),var(--alpha-background-light))}[data-reach-combobox-option]:hover{background-color:hsla(var(--color-neutral),var(--alpha-background-medium))}[data-reach-combobox-option][data-highlighted]:hover{background-color:hsla(var(--color-neutral),var(--alpha-background-heavy))}[data-reach-combobox-option]+[data-reach-combobox-option]{margin-top:var(--px-4)}.graphiql-doc-explorer-search-type{color:hsl(var(--color-info))}.graphiql-doc-explorer-search-field{color:hsl(var(--color-warning))}.graphiql-doc-explorer-search-argument{color:hsl(var(--color-secondary))}.graphiql-doc-explorer-search-divider{color:hsla(var(--color-neutral),var(--alpha-secondary));font-size:var(--font-size-hint);font-weight:var(--font-weight-medium);margin-top:var(--px-8);padding:var(--px-8) var(--px-12)}.graphiql-doc-explorer-search-empty{color:hsla(var(--color-neutral),var(--alpha-secondary));padding:var(--px-8) var(--px-12)}\n')();
var __defProp$m = Object.defineProperty;
var __name$m = /* @__PURE__ */ __name((target2, value3) => __defProp$m(target2, "name", { value: value3, configurable: true }), "__name$m");
function Search() {
  const {
    explorerNavStack,
    push
  } = useExplorerContext({
    nonNull: true,
    caller: Search
  });
  const inputRef = useRef(null);
  const popoverRef = useRef(null);
  const getSearchResults = useSearchResults();
  const [searchValue, setSearchValue] = useState("");
  const [results, setResults] = useState(getSearchResults(searchValue));
  const debouncedGetSearchResults = useMemo(() => debounce(200, (search2) => {
    setResults(getSearchResults(search2));
  }), [getSearchResults]);
  useEffect(() => {
    debouncedGetSearchResults(searchValue);
  }, [debouncedGetSearchResults, searchValue]);
  useEffect(() => {
    function handleKeyDown(event) {
      if (event.metaKey && event.keyCode === 75 && inputRef.current) {
        inputRef.current.focus();
      }
    }
    __name(handleKeyDown, "handleKeyDown");
    __name$m(handleKeyDown, "handleKeyDown");
    window.addEventListener("keydown", handleKeyDown);
    return () => window.removeEventListener("keydown", handleKeyDown);
  }, []);
  const navItem = explorerNavStack.at(-1);
  const shouldSearchBoxAppear = explorerNavStack.length === 1 || isObjectType$1(navItem.def) || isInterfaceType$1(navItem.def) || isInputObjectType$1(navItem.def);
  return shouldSearchBoxAppear ? /* @__PURE__ */ jsxs(Combobox, {
    "aria-label": `Search ${navItem.name}...`,
    onSelect: (value3) => {
      const def = value3;
      push("field" in def ? {
        name: def.field.name,
        def: def.field
      } : {
        name: def.type.name,
        def: def.type
      });
    },
    children: [/* @__PURE__ */ jsxs("div", {
      className: "graphiql-doc-explorer-search-input",
      onClick: () => {
        if (inputRef.current) {
          inputRef.current.focus();
        }
      },
      children: [/* @__PURE__ */ jsx(MagnifyingGlassIcon, {}), /* @__PURE__ */ jsx(ComboboxInput, {
        autocomplete: false,
        onChange: (event) => {
          setSearchValue(event.target.value);
        },
        onKeyDown: (event) => {
          if (!event.isDefaultPrevented()) {
            const container = popoverRef.current;
            if (!container) {
              return;
            }
            window.requestAnimationFrame(() => {
              const element = container.querySelector("[aria-selected=true]");
              if (!(element instanceof HTMLElement)) {
                return;
              }
              const top2 = element.offsetTop - container.scrollTop;
              const bottom2 = container.scrollTop + container.clientHeight - (element.offsetTop + element.clientHeight);
              if (bottom2 < 0) {
                container.scrollTop -= bottom2;
              }
              if (top2 < 0) {
                container.scrollTop += top2;
              }
            });
          }
          event.stopPropagation();
        },
        placeholder: "\u2318 K",
        ref: inputRef,
        value: searchValue
      })]
    }), /* @__PURE__ */ jsx(ComboboxPopover, {
      portal: false,
      ref: popoverRef,
      children: /* @__PURE__ */ jsxs(ComboboxList, {
        children: [results.within.map((result, i) => /* @__PURE__ */ jsx(ComboboxOption, {
          index: i,
          value: result,
          children: /* @__PURE__ */ jsx(Field$1, {
            field: result.field,
            argument: result.argument
          })
        }, `within-${i}`)), results.within.length > 0 && results.types.length + results.fields.length > 0 ? /* @__PURE__ */ jsx("div", {
          className: "graphiql-doc-explorer-search-divider",
          children: "Other results"
        }) : null, results.types.map((result, i) => /* @__PURE__ */ jsx(ComboboxOption, {
          index: results.within.length + i,
          value: result,
          children: /* @__PURE__ */ jsx(Type, {
            type: result.type
          })
        }, `type-${i}`)), results.fields.map((result, i) => /* @__PURE__ */ jsxs(ComboboxOption, {
          index: results.within.length + results.types.length + i,
          value: result,
          children: [/* @__PURE__ */ jsx(Type, {
            type: result.type
          }), ".", /* @__PURE__ */ jsx(Field$1, {
            field: result.field,
            argument: result.argument
          })]
        }, `field-${i}`)), results.within.length + results.types.length + results.fields.length === 0 ? /* @__PURE__ */ jsx("div", {
          className: "graphiql-doc-explorer-search-empty",
          children: "No results found"
        }) : null]
      })
    })]
  }) : null;
}
__name(Search, "Search");
__name$m(Search, "Search");
function useSearchResults(caller) {
  const {
    explorerNavStack
  } = useExplorerContext({
    nonNull: true,
    caller: caller || useSearchResults
  });
  const {
    schema
  } = useSchemaContext({
    nonNull: true,
    caller: caller || useSearchResults
  });
  const navItem = explorerNavStack.at(-1);
  return useCallback((searchValue) => {
    const matches2 = {
      within: [],
      types: [],
      fields: []
    };
    if (!schema) {
      return matches2;
    }
    const withinType = navItem.def;
    const typeMap = schema.getTypeMap();
    let typeNames = Object.keys(typeMap);
    if (withinType) {
      typeNames = typeNames.filter((n2) => n2 !== withinType.name);
      typeNames.unshift(withinType.name);
    }
    for (const typeName of typeNames) {
      if (matches2.within.length + matches2.types.length + matches2.fields.length >= 100) {
        break;
      }
      const type2 = typeMap[typeName];
      if (withinType !== type2 && isMatch(typeName, searchValue)) {
        matches2.types.push({
          type: type2
        });
      }
      if (!isObjectType$1(type2) && !isInterfaceType$1(type2) && !isInputObjectType$1(type2)) {
        continue;
      }
      const fields = type2.getFields();
      for (const fieldName in fields) {
        const field = fields[fieldName];
        let matchingArgs;
        if (!isMatch(fieldName, searchValue)) {
          if ("args" in field) {
            matchingArgs = field.args.filter((arg) => isMatch(arg.name, searchValue));
            if (matchingArgs.length === 0) {
              continue;
            }
          } else {
            continue;
          }
        }
        matches2[withinType === type2 ? "within" : "fields"].push(...matchingArgs ? matchingArgs.map((argument2) => ({
          type: type2,
          field,
          argument: argument2
        })) : [{
          type: type2,
          field
        }]);
      }
    }
    return matches2;
  }, [navItem.def, schema]);
}
__name(useSearchResults, "useSearchResults");
__name$m(useSearchResults, "useSearchResults");
function isMatch(sourceText, searchValue) {
  try {
    const escaped = searchValue.replaceAll(/[^_0-9A-Za-z]/g, (ch) => "\\" + ch);
    return sourceText.search(new RegExp(escaped, "i")) !== -1;
  } catch {
    return sourceText.toLowerCase().includes(searchValue.toLowerCase());
  }
}
__name(isMatch, "isMatch");
__name$m(isMatch, "isMatch");
function Type(props2) {
  return /* @__PURE__ */ jsx("span", {
    className: "graphiql-doc-explorer-search-type",
    children: props2.type.name
  });
}
__name(Type, "Type");
__name$m(Type, "Type");
function Field$1(props2) {
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [/* @__PURE__ */ jsx("span", {
      className: "graphiql-doc-explorer-search-field",
      children: props2.field.name
    }), props2.argument ? /* @__PURE__ */ jsxs(Fragment, {
      children: ["(", /* @__PURE__ */ jsx("span", {
        className: "graphiql-doc-explorer-search-argument",
        children: props2.argument.name
      }), ":", " ", renderType(props2.argument.type, (namedType) => /* @__PURE__ */ jsx(Type, {
        type: namedType
      })), ")"]
    }) : null]
  });
}
__name(Field$1, "Field$1");
__name$m(Field$1, "Field");
var fieldLink = /* @__PURE__ */ (() => "a.graphiql-doc-explorer-field-name{color:hsl(var(--color-info));text-decoration:none}a.graphiql-doc-explorer-field-name:hover{text-decoration:underline}a.graphiql-doc-explorer-field-name:focus{outline:hsl(var(--color-info)) auto 1px}\n")();
var __defProp$l = Object.defineProperty;
var __name$l = /* @__PURE__ */ __name((target2, value3) => __defProp$l(target2, "name", { value: value3, configurable: true }), "__name$l");
function FieldLink(props2) {
  const {
    push
  } = useExplorerContext({
    nonNull: true
  });
  return /* @__PURE__ */ jsx("a", {
    className: "graphiql-doc-explorer-field-name",
    onClick: (event) => {
      event.preventDefault();
      push({
        name: props2.field.name,
        def: props2.field
      });
    },
    href: "#",
    children: props2.field.name
  });
}
__name(FieldLink, "FieldLink");
__name$l(FieldLink, "FieldLink");
var typeDocumentation = /* @__PURE__ */ (() => ".graphiql-doc-explorer-item>:not(:first-child){margin-top:var(--px-12)}.graphiql-doc-explorer-argument-multiple{margin-left:var(--px-8)}.graphiql-doc-explorer-enum-value{color:hsl(var(--color-info))}\n")();
var __defProp$k = Object.defineProperty;
var __name$k = /* @__PURE__ */ __name((target2, value3) => __defProp$k(target2, "name", { value: value3, configurable: true }), "__name$k");
function TypeDocumentation(props2) {
  return isNamedType(props2.type) ? /* @__PURE__ */ jsxs(Fragment, {
    children: [props2.type.description ? /* @__PURE__ */ jsx(MarkdownContent, {
      type: "description",
      children: props2.type.description
    }) : null, /* @__PURE__ */ jsx(ImplementsInterfaces, {
      type: props2.type
    }), /* @__PURE__ */ jsx(Fields, {
      type: props2.type
    }), /* @__PURE__ */ jsx(EnumValues, {
      type: props2.type
    }), /* @__PURE__ */ jsx(PossibleTypes, {
      type: props2.type
    })]
  }) : null;
}
__name(TypeDocumentation, "TypeDocumentation");
__name$k(TypeDocumentation, "TypeDocumentation");
function ImplementsInterfaces({
  type: type2
}) {
  if (!isObjectType$1(type2)) {
    return null;
  }
  const interfaces = type2.getInterfaces();
  return interfaces.length > 0 ? /* @__PURE__ */ jsx(ExplorerSection, {
    title: "Implements",
    children: type2.getInterfaces().map((implementedInterface) => /* @__PURE__ */ jsx("div", {
      children: /* @__PURE__ */ jsx(TypeLink, {
        type: implementedInterface
      })
    }, implementedInterface.name))
  }) : null;
}
__name(ImplementsInterfaces, "ImplementsInterfaces");
__name$k(ImplementsInterfaces, "ImplementsInterfaces");
function Fields({
  type: type2
}) {
  const [showDeprecated, setShowDeprecated] = useState(false);
  if (!isObjectType$1(type2) && !isInterfaceType$1(type2) && !isInputObjectType$1(type2)) {
    return null;
  }
  const fieldMap = type2.getFields();
  const fields = [];
  const deprecatedFields = [];
  for (const field of Object.keys(fieldMap).map((name2) => fieldMap[name2])) {
    if (field.deprecationReason) {
      deprecatedFields.push(field);
    } else {
      fields.push(field);
    }
  }
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [fields.length > 0 ? /* @__PURE__ */ jsx(ExplorerSection, {
      title: "Fields",
      children: fields.map((field) => /* @__PURE__ */ jsx(Field, {
        field
      }, field.name))
    }) : null, deprecatedFields.length > 0 ? showDeprecated || fields.length === 0 ? /* @__PURE__ */ jsx(ExplorerSection, {
      title: "Deprecated Fields",
      children: deprecatedFields.map((field) => /* @__PURE__ */ jsx(Field, {
        field
      }, field.name))
    }) : /* @__PURE__ */ jsx(Button, {
      type: "button",
      onClick: () => {
        setShowDeprecated(true);
      },
      children: "Show Deprecated Fields"
    }) : null]
  });
}
__name(Fields, "Fields");
__name$k(Fields, "Fields");
function Field({
  field
}) {
  const args = "args" in field ? field.args.filter((arg) => !arg.deprecationReason) : [];
  return /* @__PURE__ */ jsxs("div", {
    className: "graphiql-doc-explorer-item",
    children: [/* @__PURE__ */ jsxs("div", {
      children: [/* @__PURE__ */ jsx(FieldLink, {
        field
      }), args.length > 0 ? /* @__PURE__ */ jsxs(Fragment, {
        children: ["(", /* @__PURE__ */ jsx("span", {
          children: args.map((arg) => args.length === 1 ? /* @__PURE__ */ jsx(Argument, {
            arg,
            inline: true
          }, arg.name) : /* @__PURE__ */ jsx("div", {
            className: "graphiql-doc-explorer-argument-multiple",
            children: /* @__PURE__ */ jsx(Argument, {
              arg,
              inline: true
            })
          }, arg.name))
        }), ")"]
      }) : null, ": ", /* @__PURE__ */ jsx(TypeLink, {
        type: field.type
      }), /* @__PURE__ */ jsx(DefaultValue, {
        field
      })]
    }), field.description ? /* @__PURE__ */ jsx(MarkdownContent, {
      type: "description",
      onlyShowFirstChild: true,
      children: field.description
    }) : null, /* @__PURE__ */ jsx(DeprecationReason, {
      children: field.deprecationReason
    })]
  });
}
__name(Field, "Field");
__name$k(Field, "Field");
function EnumValues({
  type: type2
}) {
  const [showDeprecated, setShowDeprecated] = useState(false);
  if (!isEnumType$1(type2)) {
    return null;
  }
  const values = [];
  const deprecatedValues = [];
  for (const value3 of type2.getValues()) {
    if (value3.deprecationReason) {
      deprecatedValues.push(value3);
    } else {
      values.push(value3);
    }
  }
  return /* @__PURE__ */ jsxs(Fragment, {
    children: [values.length > 0 ? /* @__PURE__ */ jsx(ExplorerSection, {
      title: "Enum Values",
      children: values.map((value3) => /* @__PURE__ */ jsx(EnumValue, {
        value: value3
      }, value3.name))
    }) : null, deprecatedValues.length > 0 ? showDeprecated || values.length === 0 ? /* @__PURE__ */ jsx(ExplorerSection, {
      title: "Deprecated Enum Values",
      children: deprecatedValues.map((value3) => /* @__PURE__ */ jsx(EnumValue, {
        value: value3
      }, value3.name))
    }) : /* @__PURE__ */ jsx(Button, {
      type: "button",
      onClick: () => {
        setShowDeprecated(true);
      },
      children: "Show Deprecated Values"
    }) : null]
  });
}
__name(EnumValues, "EnumValues");
__name$k(EnumValues, "EnumValues");
function EnumValue({
  value: value3
}) {
  return /* @__PURE__ */ jsxs("div", {
    className: "graphiql-doc-explorer-item",
    children: [/* @__PURE__ */ jsx("div", {
      className: "graphiql-doc-explorer-enum-value",
      children: value3.name
    }), value3.description ? /* @__PURE__ */ jsx(MarkdownContent, {
      type: "description",
      children: value3.description
    }) : null, value3.deprecationReason ? /* @__PURE__ */ jsx(MarkdownContent, {
      type: "deprecation",
      children: value3.deprecationReason
    }) : null]
  });
}
__name(EnumValue, "EnumValue");
__name$k(EnumValue, "EnumValue");
function PossibleTypes({
  type: type2
}) {
  const {
    schema
  } = useSchemaContext({
    nonNull: true
  });
  if (!schema || !isAbstractType$1(type2)) {
    return null;
  }
  return /* @__PURE__ */ jsx(ExplorerSection, {
    title: isInterfaceType$1(type2) ? "Implementations" : "Possible Types",
    children: schema.getPossibleTypes(type2).map((possibleType) => /* @__PURE__ */ jsx("div", {
      children: /* @__PURE__ */ jsx(TypeLink, {
        type: possibleType
      })
    }, possibleType.name))
  });
}
__name(PossibleTypes, "PossibleTypes");
__name$k(PossibleTypes, "PossibleTypes");
var docExplorer = /* @__PURE__ */ (() => ".graphiql-doc-explorer-header{display:flex;justify-content:space-between;position:relative}.graphiql-doc-explorer-header:focus-within .graphiql-doc-explorer-title{visibility:hidden}.graphiql-doc-explorer-header:focus-within .graphiql-doc-explorer-back:not(:focus){color:transparent}.graphiql-doc-explorer-header-content{display:flex;flex-direction:column;min-width:0}.graphiql-doc-explorer-search{height:100%;position:absolute;right:0;top:0}.graphiql-doc-explorer-search:focus-within{left:0}.graphiql-doc-explorer-search [data-reach-combobox-input]{height:24px;width:4ch}.graphiql-doc-explorer-search [data-reach-combobox-input]:focus{width:100%}a.graphiql-doc-explorer-back{align-items:center;color:hsla(var(--color-neutral),var(--alpha-secondary));display:flex;text-decoration:none}a.graphiql-doc-explorer-back:hover{text-decoration:underline}a.graphiql-doc-explorer-back:focus{outline:hsla(var(--color-neutral),var(--alpha-secondary)) auto 1px}a.graphiql-doc-explorer-back:focus+.graphiql-doc-explorer-title{visibility:unset}a.graphiql-doc-explorer-back>svg{height:var(--px-8);margin-right:var(--px-8);width:var(--px-8)}.graphiql-doc-explorer-title{font-weight:var(--font-weight-medium);font-size:var(--font-size-h2);overflow-x:hidden;text-overflow:ellipsis;white-space:nowrap}.graphiql-doc-explorer-title:not(:first-child){font-size:var(--font-size-h3);margin-top:var(--px-8)}.graphiql-doc-explorer-content>*{color:hsla(var(--color-neutral),var(--alpha-secondary));margin-top:var(--px-20)}.graphiql-doc-explorer-error{background-color:hsla(var(--color-error),var(--alpha-background-heavy));border:1px solid hsl(var(--color-error));border-radius:var(--border-radius-8);color:hsl(var(--color-error));padding:var(--px-8) var(--px-12)}\n")();
var __defProp$j = Object.defineProperty;
var __name$j = /* @__PURE__ */ __name((target2, value3) => __defProp$j(target2, "name", { value: value3, configurable: true }), "__name$j");
function DocExplorer() {
  const {
    fetchError,
    isFetching,
    schema,
    validationErrors
  } = useSchemaContext({
    nonNull: true,
    caller: DocExplorer
  });
  const {
    explorerNavStack,
    pop
  } = useExplorerContext({
    nonNull: true,
    caller: DocExplorer
  });
  const navItem = explorerNavStack.at(-1);
  let content = null;
  if (fetchError) {
    content = /* @__PURE__ */ jsx("div", {
      className: "graphiql-doc-explorer-error",
      children: "Error fetching schema"
    });
  } else if (validationErrors.length > 0) {
    content = /* @__PURE__ */ jsxs("div", {
      className: "graphiql-doc-explorer-error",
      children: ["Schema is invalid: ", validationErrors[0].message]
    });
  } else if (isFetching) {
    content = /* @__PURE__ */ jsx(Spinner, {});
  } else if (!schema) {
    content = /* @__PURE__ */ jsx("div", {
      className: "graphiql-doc-explorer-error",
      children: "No GraphQL schema available"
    });
  } else if (explorerNavStack.length === 1) {
    content = /* @__PURE__ */ jsx(SchemaDocumentation, {
      schema
    });
  } else if (isType$1(navItem.def)) {
    content = /* @__PURE__ */ jsx(TypeDocumentation, {
      type: navItem.def
    });
  } else if (navItem.def) {
    content = /* @__PURE__ */ jsx(FieldDocumentation, {
      field: navItem.def
    });
  }
  let prevName;
  if (explorerNavStack.length > 1) {
    prevName = explorerNavStack.at(-2).name;
  }
  return /* @__PURE__ */ jsxs("section", {
    className: "graphiql-doc-explorer",
    "aria-label": "Documentation Explorer",
    children: [/* @__PURE__ */ jsxs("div", {
      className: "graphiql-doc-explorer-header",
      children: [/* @__PURE__ */ jsxs("div", {
        className: "graphiql-doc-explorer-header-content",
        children: [prevName && /* @__PURE__ */ jsxs("a", {
          href: "#",
          className: "graphiql-doc-explorer-back",
          onClick: (event) => {
            event.preventDefault();
            pop();
          },
          "aria-label": `Go back to ${prevName}`,
          children: [/* @__PURE__ */ jsx(ChevronLeftIcon, {}), prevName]
        }), /* @__PURE__ */ jsx("div", {
          className: "graphiql-doc-explorer-title",
          children: navItem.name
        })]
      }), /* @__PURE__ */ jsx("div", {
        className: "graphiql-doc-explorer-search",
        children: /* @__PURE__ */ jsx(Search, {}, navItem.name)
      })]
    }), /* @__PURE__ */ jsx("div", {
      className: "graphiql-doc-explorer-content",
      children: content
    })]
  });
}
__name(DocExplorer, "DocExplorer");
__name$j(DocExplorer, "DocExplorer");
var __defProp$i = Object.defineProperty;
var __name$i = /* @__PURE__ */ __name((target2, value3) => __defProp$i(target2, "name", { value: value3, configurable: true }), "__name$i");
const DOC_EXPLORER_PLUGIN = {
  title: "Documentation Explorer",
  icon: /* @__PURE__ */ __name$i(/* @__PURE__ */ __name(function Icon() {
    const pluginContext = usePluginContext();
    return (pluginContext == null ? void 0 : pluginContext.visiblePlugin) === DOC_EXPLORER_PLUGIN ? /* @__PURE__ */ jsx(DocsFilledIcon, {}) : /* @__PURE__ */ jsx(DocsIcon, {});
  }, "Icon"), "Icon"),
  content: DocExplorer
};
const HISTORY_PLUGIN = {
  title: "History",
  icon: HistoryIcon,
  content: History
};
const PluginContext = createNullableContext("PluginContext");
function PluginContextProvider(props2) {
  const storage = useStorageContext();
  const explorerContext = useExplorerContext();
  const historyContext = useHistoryContext();
  const hasExplorerContext = Boolean(explorerContext);
  const hasHistoryContext = Boolean(historyContext);
  const plugins = useMemo(() => {
    const pluginList = [];
    const pluginTitles = {};
    if (hasExplorerContext) {
      pluginList.push(DOC_EXPLORER_PLUGIN);
      pluginTitles[DOC_EXPLORER_PLUGIN.title] = true;
    }
    if (hasHistoryContext) {
      pluginList.push(HISTORY_PLUGIN);
      pluginTitles[HISTORY_PLUGIN.title] = true;
    }
    for (const plugin of props2.plugins || []) {
      if (typeof plugin.title !== "string" || !plugin.title) {
        throw new Error("All GraphiQL plugins must have a unique title");
      }
      if (pluginTitles[plugin.title]) {
        throw new Error(`All GraphiQL plugins must have a unique title, found two plugins with the title '${plugin.title}'`);
      } else {
        pluginList.push(plugin);
        pluginTitles[plugin.title] = true;
      }
    }
    return pluginList;
  }, [hasExplorerContext, hasHistoryContext, props2.plugins]);
  const [visiblePlugin, internalSetVisiblePlugin] = useState(() => {
    const storedValue = storage == null ? void 0 : storage.get(STORAGE_KEY$4);
    const pluginForStoredValue = plugins.find((plugin) => plugin.title === storedValue);
    if (pluginForStoredValue) {
      return pluginForStoredValue;
    }
    if (storedValue) {
      storage == null ? void 0 : storage.set(STORAGE_KEY$4, "");
    }
    if (!props2.visiblePlugin) {
      return null;
    }
    return plugins.find((plugin) => (typeof props2.visiblePlugin === "string" ? plugin.title : plugin) === props2.visiblePlugin) || null;
  });
  const {
    onTogglePluginVisibility,
    children
  } = props2;
  const setVisiblePlugin = useCallback((plugin) => {
    const newVisiblePlugin = plugin ? plugins.find((p2) => (typeof plugin === "string" ? p2.title : p2) === plugin) || null : null;
    internalSetVisiblePlugin((current) => {
      if (newVisiblePlugin === current) {
        return current;
      }
      onTogglePluginVisibility == null ? void 0 : onTogglePluginVisibility(newVisiblePlugin);
      return newVisiblePlugin;
    });
  }, [onTogglePluginVisibility, plugins]);
  useEffect(() => {
    if (props2.visiblePlugin) {
      setVisiblePlugin(props2.visiblePlugin);
    }
  }, [plugins, props2.visiblePlugin, setVisiblePlugin]);
  const value3 = useMemo(() => ({
    plugins,
    setVisiblePlugin,
    visiblePlugin
  }), [plugins, setVisiblePlugin, visiblePlugin]);
  return /* @__PURE__ */ jsx(PluginContext.Provider, {
    value: value3,
    children
  });
}
__name(PluginContextProvider, "PluginContextProvider");
__name$i(PluginContextProvider, "PluginContextProvider");
const usePluginContext = createContextHook(PluginContext);
const STORAGE_KEY$4 = "visiblePlugin";
var __defProp$h = Object.defineProperty;
var __name$h = /* @__PURE__ */ __name((target2, value3) => __defProp$h(target2, "name", { value: value3, configurable: true }), "__name$h");
function onHasCompletion(_cm, data, schema, explorer, plugin, callback) {
  importCodeMirror([], { useCommonAddons: false }).then((CodeMirror) => {
    let information;
    let fieldName;
    let typeNamePill;
    let typeNamePrefix;
    let typeName;
    let typeNameSuffix;
    let description;
    let deprecation;
    let deprecationReason2;
    CodeMirror.on(data, "select", (ctx, el2) => {
      if (!information) {
        const hintsUl = el2.parentNode;
        information = document.createElement("div");
        information.className = "CodeMirror-hint-information";
        hintsUl.appendChild(information);
        const header = document.createElement("header");
        header.className = "CodeMirror-hint-information-header";
        information.appendChild(header);
        fieldName = document.createElement("span");
        fieldName.className = "CodeMirror-hint-information-field-name";
        header.appendChild(fieldName);
        typeNamePill = document.createElement("span");
        typeNamePill.className = "CodeMirror-hint-information-type-name-pill";
        header.appendChild(typeNamePill);
        typeNamePrefix = document.createElement("span");
        typeNamePill.appendChild(typeNamePrefix);
        typeName = document.createElement("a");
        typeName.className = "CodeMirror-hint-information-type-name";
        typeName.href = "javascript:void 0";
        typeName.addEventListener("click", onClickHintInformation);
        typeNamePill.appendChild(typeName);
        typeNameSuffix = document.createElement("span");
        typeNamePill.appendChild(typeNameSuffix);
        description = document.createElement("div");
        description.className = "CodeMirror-hint-information-description";
        information.appendChild(description);
        deprecation = document.createElement("div");
        deprecation.className = "CodeMirror-hint-information-deprecation";
        information.appendChild(deprecation);
        const deprecationLabel = document.createElement("span");
        deprecationLabel.className = "CodeMirror-hint-information-deprecation-label";
        deprecationLabel.innerText = "Deprecated";
        deprecation.appendChild(deprecationLabel);
        deprecationReason2 = document.createElement("div");
        deprecationReason2.className = "CodeMirror-hint-information-deprecation-reason";
        deprecation.appendChild(deprecationReason2);
        const defaultInformationPadding = parseInt(window.getComputedStyle(information).paddingBottom.replace(/px$/, ""), 10) || 0;
        const defaultInformationMaxHeight = parseInt(window.getComputedStyle(information).maxHeight.replace(/px$/, ""), 10) || 0;
        const handleScroll2 = /* @__PURE__ */ __name$h(() => {
          if (information) {
            information.style.paddingTop = hintsUl.scrollTop + defaultInformationPadding + "px";
            information.style.maxHeight = hintsUl.scrollTop + defaultInformationMaxHeight + "px";
          }
        }, "handleScroll");
        hintsUl.addEventListener("scroll", handleScroll2);
        let onRemoveFn;
        hintsUl.addEventListener("DOMNodeRemoved", onRemoveFn = /* @__PURE__ */ __name$h((event) => {
          if (event.target === hintsUl) {
            hintsUl.removeEventListener("scroll", handleScroll2);
            hintsUl.removeEventListener("DOMNodeRemoved", onRemoveFn);
            if (information) {
              information.removeEventListener("click", onClickHintInformation);
            }
            information = null;
            fieldName = null;
            typeNamePill = null;
            typeNamePrefix = null;
            typeName = null;
            typeNameSuffix = null;
            description = null;
            deprecation = null;
            deprecationReason2 = null;
            onRemoveFn = null;
          }
        }, "onRemoveFn"));
      }
      if (fieldName) {
        fieldName.innerText = ctx.text;
      }
      if (typeNamePill && typeNamePrefix && typeName && typeNameSuffix) {
        if (ctx.type) {
          typeNamePill.style.display = "inline";
          const renderType2 = /* @__PURE__ */ __name$h((type2) => {
            if (isNonNullType$1(type2)) {
              typeNameSuffix.innerText = "!" + typeNameSuffix.innerText;
              renderType2(type2.ofType);
            } else if (isListType$1(type2)) {
              typeNamePrefix.innerText += "[";
              typeNameSuffix.innerText = "]" + typeNameSuffix.innerText;
              renderType2(type2.ofType);
            } else {
              typeName.innerText = type2.name;
            }
          }, "renderType");
          typeNamePrefix.innerText = "";
          typeNameSuffix.innerText = "";
          renderType2(ctx.type);
        } else {
          typeNamePrefix.innerText = "";
          typeName.innerText = "";
          typeNameSuffix.innerText = "";
          typeNamePill.style.display = "none";
        }
      }
      if (description) {
        if (ctx.description) {
          description.style.display = "block";
          description.innerHTML = markdown$1.render(ctx.description);
        } else {
          description.style.display = "none";
          description.innerHTML = "";
        }
      }
      if (deprecation && deprecationReason2) {
        if (ctx.deprecationReason) {
          deprecation.style.display = "block";
          deprecationReason2.innerHTML = markdown$1.render(ctx.deprecationReason);
        } else {
          deprecation.style.display = "none";
          deprecationReason2.innerHTML = "";
        }
      }
    });
  });
  function onClickHintInformation(event) {
    if (!schema || !explorer || !plugin || !(event.currentTarget instanceof HTMLElement)) {
      return;
    }
    const typeName = event.currentTarget.innerText;
    const type2 = schema.getType(typeName);
    if (type2) {
      plugin.setVisiblePlugin(DOC_EXPLORER_PLUGIN);
      explorer.push({ name: type2.name, def: type2 });
      callback == null ? void 0 : callback(type2);
    }
  }
  __name(onClickHintInformation, "onClickHintInformation");
  __name$h(onClickHintInformation, "onClickHintInformation");
}
__name(onHasCompletion, "onHasCompletion");
__name$h(onHasCompletion, "onHasCompletion");
var __defProp$g = Object.defineProperty;
var __name$g = /* @__PURE__ */ __name((target2, value3) => __defProp$g(target2, "name", { value: value3, configurable: true }), "__name$g");
function useSynchronizeValue(editor2, value3) {
  useEffect(() => {
    if (editor2 && typeof value3 === "string" && value3 !== editor2.getValue()) {
      editor2.setValue(value3);
    }
  }, [editor2, value3]);
}
__name(useSynchronizeValue, "useSynchronizeValue");
__name$g(useSynchronizeValue, "useSynchronizeValue");
function useSynchronizeOption(editor2, option, value3) {
  useEffect(() => {
    if (editor2) {
      editor2.setOption(option, value3);
    }
  }, [editor2, option, value3]);
}
__name(useSynchronizeOption, "useSynchronizeOption");
__name$g(useSynchronizeOption, "useSynchronizeOption");
function useChangeHandler(editor2, callback, storageKey, tabProperty, caller) {
  const { updateActiveTabValues } = useEditorContext({ nonNull: true, caller });
  const storage = useStorageContext();
  useEffect(() => {
    if (!editor2) {
      return;
    }
    const store = debounce(500, (value3) => {
      if (!storage || storageKey === null) {
        return;
      }
      storage.set(storageKey, value3);
    });
    const updateTab = debounce(100, (value3) => {
      updateActiveTabValues({ [tabProperty]: value3 });
    });
    const handleChange = /* @__PURE__ */ __name$g((editorInstance, changeObj) => {
      if (!changeObj) {
        return;
      }
      const newValue = editorInstance.getValue();
      store(newValue);
      updateTab(newValue);
      callback == null ? void 0 : callback(newValue);
    }, "handleChange");
    editor2.on("change", handleChange);
    return () => editor2.off("change", handleChange);
  }, [
    callback,
    editor2,
    storage,
    storageKey,
    tabProperty,
    updateActiveTabValues
  ]);
}
__name(useChangeHandler, "useChangeHandler");
__name$g(useChangeHandler, "useChangeHandler");
function useCompletion(editor2, callback, caller) {
  const { schema } = useSchemaContext({ nonNull: true, caller });
  const explorer = useExplorerContext();
  const plugin = usePluginContext();
  useEffect(() => {
    if (!editor2) {
      return;
    }
    const handleCompletion = /* @__PURE__ */ __name$g((instance, changeObj) => {
      onHasCompletion(instance, changeObj, schema, explorer, plugin, (type2) => {
        callback == null ? void 0 : callback({ kind: "Type", type: type2, schema: schema || void 0 });
      });
    }, "handleCompletion");
    editor2.on("hasCompletion", handleCompletion);
    return () => editor2.off("hasCompletion", handleCompletion);
  }, [callback, editor2, explorer, plugin, schema]);
}
__name(useCompletion, "useCompletion");
__name$g(useCompletion, "useCompletion");
function useKeyMap(editor2, keys, callback) {
  useEffect(() => {
    if (!editor2) {
      return;
    }
    for (const key of keys) {
      editor2.removeKeyMap(key);
    }
    if (callback) {
      const keyMap2 = {};
      for (const key of keys) {
        keyMap2[key] = () => callback();
      }
      editor2.addKeyMap(keyMap2);
    }
  }, [editor2, keys, callback]);
}
__name(useKeyMap, "useKeyMap");
__name$g(useKeyMap, "useKeyMap");
function useCopyQuery({ caller, onCopyQuery } = {}) {
  const { queryEditor } = useEditorContext({
    nonNull: true,
    caller: caller || useCopyQuery
  });
  return useCallback(() => {
    if (!queryEditor) {
      return;
    }
    const query = queryEditor.getValue();
    copyToClipboard(query);
    onCopyQuery == null ? void 0 : onCopyQuery(query);
  }, [queryEditor, onCopyQuery]);
}
__name(useCopyQuery, "useCopyQuery");
__name$g(useCopyQuery, "useCopyQuery");
function useMergeQuery({ caller } = {}) {
  const { queryEditor } = useEditorContext({
    nonNull: true,
    caller: caller || useMergeQuery
  });
  const { schema } = useSchemaContext({ nonNull: true, caller: useMergeQuery });
  return useCallback(() => {
    const documentAST = queryEditor == null ? void 0 : queryEditor.documentAST;
    const query = queryEditor == null ? void 0 : queryEditor.getValue();
    if (!documentAST || !query) {
      return;
    }
    queryEditor.setValue(print$1(mergeAst(documentAST, schema)));
  }, [queryEditor, schema]);
}
__name(useMergeQuery, "useMergeQuery");
__name$g(useMergeQuery, "useMergeQuery");
function usePrettifyEditors({ caller } = {}) {
  const { queryEditor, headerEditor, variableEditor } = useEditorContext({
    nonNull: true,
    caller: caller || usePrettifyEditors
  });
  return useCallback(() => {
    if (variableEditor) {
      const variableEditorContent = variableEditor.getValue();
      try {
        const prettifiedVariableEditorContent = JSON.stringify(JSON.parse(variableEditorContent), null, 2);
        if (prettifiedVariableEditorContent !== variableEditorContent) {
          variableEditor.setValue(prettifiedVariableEditorContent);
        }
      } catch {
      }
    }
    if (headerEditor) {
      const headerEditorContent = headerEditor.getValue();
      try {
        const prettifiedHeaderEditorContent = JSON.stringify(JSON.parse(headerEditorContent), null, 2);
        if (prettifiedHeaderEditorContent !== headerEditorContent) {
          headerEditor.setValue(prettifiedHeaderEditorContent);
        }
      } catch {
      }
    }
    if (queryEditor) {
      const editorContent = queryEditor.getValue();
      const prettifiedEditorContent = print$1(parse$2(editorContent));
      if (prettifiedEditorContent !== editorContent) {
        queryEditor.setValue(prettifiedEditorContent);
      }
    }
  }, [queryEditor, variableEditor, headerEditor]);
}
__name(usePrettifyEditors, "usePrettifyEditors");
__name$g(usePrettifyEditors, "usePrettifyEditors");
function useAutoCompleteLeafs({
  getDefaultFieldNames,
  caller
} = {}) {
  const { schema } = useSchemaContext({
    nonNull: true,
    caller: caller || useAutoCompleteLeafs
  });
  const { queryEditor } = useEditorContext({
    nonNull: true,
    caller: caller || useAutoCompleteLeafs
  });
  return useCallback(() => {
    if (!queryEditor) {
      return;
    }
    const query = queryEditor.getValue();
    const { insertions, result } = fillLeafs(schema, query, getDefaultFieldNames);
    if (insertions && insertions.length > 0) {
      queryEditor.operation(() => {
        const cursor = queryEditor.getCursor();
        const cursorIndex = queryEditor.indexFromPos(cursor);
        queryEditor.setValue(result || "");
        let added = 0;
        const markers = insertions.map(({ index, string }) => queryEditor.markText(queryEditor.posFromIndex(index + added), queryEditor.posFromIndex(index + (added += string.length)), {
          className: "auto-inserted-leaf",
          clearOnEnter: true,
          title: "Automatically added leaf fields"
        }));
        setTimeout(() => markers.forEach((marker2) => marker2.clear()), 7e3);
        let newCursorIndex = cursorIndex;
        insertions.forEach(({ index, string }) => {
          if (index < cursorIndex) {
            newCursorIndex += string.length;
          }
        });
        queryEditor.setCursor(queryEditor.posFromIndex(newCursorIndex));
      });
    }
    return result;
  }, [getDefaultFieldNames, queryEditor, schema]);
}
__name(useAutoCompleteLeafs, "useAutoCompleteLeafs");
__name$g(useAutoCompleteLeafs, "useAutoCompleteLeafs");
var __defProp$f = Object.defineProperty;
var __name$f = /* @__PURE__ */ __name((target2, value3) => __defProp$f(target2, "name", { value: value3, configurable: true }), "__name$f");
function useHeaderEditor({
  editorTheme = DEFAULT_EDITOR_THEME,
  keyMap: keyMap2 = DEFAULT_KEY_MAP,
  onEdit,
  readOnly = false
} = {}, caller) {
  const {
    initialHeaders,
    headerEditor,
    setHeaderEditor,
    shouldPersistHeaders
  } = useEditorContext({
    nonNull: true,
    caller: caller || useHeaderEditor
  });
  const executionContext = useExecutionContext();
  const merge = useMergeQuery({ caller: caller || useHeaderEditor });
  const prettify = usePrettifyEditors({ caller: caller || useHeaderEditor });
  const ref = useRef(null);
  useEffect(() => {
    let isActive = true;
    importCodeMirror([
      import("./javascript.es.js").then(function(n2) {
        return n2.j;
      })
    ]).then((CodeMirror) => {
      if (!isActive) {
        return;
      }
      const container = ref.current;
      if (!container) {
        return;
      }
      const newEditor = CodeMirror(container, {
        value: initialHeaders,
        lineNumbers: true,
        tabSize: 2,
        mode: { name: "javascript", json: true },
        theme: editorTheme,
        autoCloseBrackets: true,
        matchBrackets: true,
        showCursorWhenSelecting: true,
        readOnly: readOnly ? "nocursor" : false,
        foldGutter: true,
        gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
        extraKeys: commonKeys
      });
      newEditor.addKeyMap({
        "Cmd-Space"() {
          newEditor.showHint({ completeSingle: false, container });
        },
        "Ctrl-Space"() {
          newEditor.showHint({ completeSingle: false, container });
        },
        "Alt-Space"() {
          newEditor.showHint({ completeSingle: false, container });
        },
        "Shift-Space"() {
          newEditor.showHint({ completeSingle: false, container });
        }
      });
      newEditor.on("keyup", (editorInstance, event) => {
        const code3 = event.keyCode;
        if (code3 >= 65 && code3 <= 90 || !event.shiftKey && code3 >= 48 && code3 <= 57 || event.shiftKey && code3 === 189 || event.shiftKey && code3 === 222) {
          editorInstance.execCommand("autocomplete");
        }
      });
      setHeaderEditor(newEditor);
    });
    return () => {
      isActive = false;
    };
  }, [editorTheme, initialHeaders, readOnly, setHeaderEditor]);
  useSynchronizeOption(headerEditor, "keyMap", keyMap2);
  useChangeHandler(headerEditor, onEdit, shouldPersistHeaders ? STORAGE_KEY$3 : null, "headers", useHeaderEditor);
  useKeyMap(headerEditor, ["Cmd-Enter", "Ctrl-Enter"], executionContext == null ? void 0 : executionContext.run);
  useKeyMap(headerEditor, ["Shift-Ctrl-P"], prettify);
  useKeyMap(headerEditor, ["Shift-Ctrl-M"], merge);
  return ref;
}
__name(useHeaderEditor, "useHeaderEditor");
__name$f(useHeaderEditor, "useHeaderEditor");
const STORAGE_KEY$3 = "headers";
var __defProp$e = Object.defineProperty;
var __name$e = /* @__PURE__ */ __name((target2, value3) => __defProp$e(target2, "name", { value: value3, configurable: true }), "__name$e");
const invalidCharacters = Array.from({ length: 11 }, (_, i) => {
  return String.fromCharCode(8192 + i);
}).concat(["\u2028", "\u2029", "\u202F", "\xA0"]);
const sanitizeRegex = new RegExp("[" + invalidCharacters.join("") + "]", "g");
function normalizeWhitespace(line) {
  return line.replace(sanitizeRegex, " ");
}
__name(normalizeWhitespace, "normalizeWhitespace");
__name$e(normalizeWhitespace, "normalizeWhitespace");
var __defProp$d = Object.defineProperty;
var __name$d = /* @__PURE__ */ __name((target2, value3) => __defProp$d(target2, "name", { value: value3, configurable: true }), "__name$d");
function useQueryEditor({
  editorTheme = DEFAULT_EDITOR_THEME,
  keyMap: keyMap2 = DEFAULT_KEY_MAP,
  onClickReference,
  onCopyQuery,
  onEdit,
  readOnly = false
} = {}, caller) {
  const { schema } = useSchemaContext({
    nonNull: true,
    caller: caller || useQueryEditor
  });
  const {
    externalFragments,
    initialQuery,
    queryEditor,
    setOperationName,
    setQueryEditor,
    validationRules,
    variableEditor,
    updateActiveTabValues
  } = useEditorContext({
    nonNull: true,
    caller: caller || useQueryEditor
  });
  const executionContext = useExecutionContext();
  const storage = useStorageContext();
  const explorer = useExplorerContext();
  const plugin = usePluginContext();
  const copy2 = useCopyQuery({ caller: caller || useQueryEditor, onCopyQuery });
  const merge = useMergeQuery({ caller: caller || useQueryEditor });
  const prettify = usePrettifyEditors({ caller: caller || useQueryEditor });
  const ref = useRef(null);
  const codeMirrorRef = useRef();
  const onClickReferenceRef = useRef(() => {
  });
  useEffect(() => {
    onClickReferenceRef.current = (reference3) => {
      if (!explorer || !plugin) {
        return;
      }
      plugin.setVisiblePlugin(DOC_EXPLORER_PLUGIN);
      switch (reference3.kind) {
        case "Type": {
          explorer.push({ name: reference3.type.name, def: reference3.type });
          break;
        }
        case "Field": {
          explorer.push({ name: reference3.field.name, def: reference3.field });
          break;
        }
        case "Argument": {
          if (reference3.field) {
            explorer.push({ name: reference3.field.name, def: reference3.field });
          }
          break;
        }
        case "EnumValue": {
          if (reference3.type) {
            explorer.push({ name: reference3.type.name, def: reference3.type });
          }
          break;
        }
      }
      onClickReference == null ? void 0 : onClickReference(reference3);
    };
  }, [explorer, onClickReference, plugin]);
  useEffect(() => {
    let isActive = true;
    importCodeMirror([
      import("./comment.es.js").then(function(n2) {
        return n2.c;
      }),
      import("./search.es.js").then(function(n2) {
        return n2.s;
      }),
      import("./hint.es.js"),
      import("./lint.es.js"),
      import("./info.es.js"),
      import("./jump.es.js"),
      import("./mode.es.js")
    ]).then((CodeMirror) => {
      if (!isActive) {
        return;
      }
      codeMirrorRef.current = CodeMirror;
      const container = ref.current;
      if (!container) {
        return;
      }
      const newEditor = CodeMirror(container, {
        value: initialQuery,
        lineNumbers: true,
        tabSize: 2,
        foldGutter: true,
        mode: "graphql",
        theme: editorTheme,
        autoCloseBrackets: true,
        matchBrackets: true,
        showCursorWhenSelecting: true,
        readOnly: readOnly ? "nocursor" : false,
        lint: {
          schema: void 0,
          validationRules: null,
          externalFragments: void 0
        },
        hintOptions: {
          schema: void 0,
          closeOnUnfocus: false,
          completeSingle: false,
          container,
          externalFragments: void 0
        },
        info: {
          schema: void 0,
          renderDescription: (text3) => markdown$1.render(text3),
          onClick: (reference3) => {
            onClickReferenceRef.current(reference3);
          }
        },
        jump: {
          schema: void 0,
          onClick: (reference3) => {
            onClickReferenceRef.current(reference3);
          }
        },
        gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
        extraKeys: __spreadProps(__spreadValues({}, commonKeys), {
          "Cmd-S"() {
          },
          "Ctrl-S"() {
          }
        })
      });
      newEditor.addKeyMap({
        "Cmd-Space"() {
          newEditor.showHint({ completeSingle: true, container });
        },
        "Ctrl-Space"() {
          newEditor.showHint({ completeSingle: true, container });
        },
        "Alt-Space"() {
          newEditor.showHint({ completeSingle: true, container });
        },
        "Shift-Space"() {
          newEditor.showHint({ completeSingle: true, container });
        },
        "Shift-Alt-Space"() {
          newEditor.showHint({ completeSingle: true, container });
        }
      });
      newEditor.on("keyup", (editorInstance, event) => {
        if (AUTO_COMPLETE_AFTER_KEY.test(event.key)) {
          editorInstance.execCommand("autocomplete");
        }
      });
      let showingHints = false;
      newEditor.on("startCompletion", () => {
        showingHints = true;
      });
      newEditor.on("endCompletion", () => {
        showingHints = false;
      });
      newEditor.on("keydown", (editorInstance, event) => {
        if (event.key === "Escape" && showingHints) {
          event.stopPropagation();
        }
      });
      newEditor.on("beforeChange", (editorInstance, change) => {
        var _a;
        if (change.origin === "paste") {
          const text3 = change.text.map(normalizeWhitespace);
          (_a = change.update) == null ? void 0 : _a.call(change, change.from, change.to, text3);
        }
      });
      newEditor.documentAST = null;
      newEditor.operationName = null;
      newEditor.operations = null;
      newEditor.variableToType = null;
      setQueryEditor(newEditor);
    });
    return () => {
      isActive = false;
    };
  }, [editorTheme, initialQuery, readOnly, setQueryEditor]);
  useSynchronizeOption(queryEditor, "keyMap", keyMap2);
  useEffect(() => {
    if (!queryEditor) {
      return;
    }
    function getAndUpdateOperationFacts(editorInstance) {
      var _a, _b, _c, _d, _e;
      const operationFacts = getOperationFacts(schema, editorInstance.getValue());
      const operationName = getSelectedOperationName((_a = editorInstance.operations) != null ? _a : void 0, (_b = editorInstance.operationName) != null ? _b : void 0, operationFacts == null ? void 0 : operationFacts.operations);
      editorInstance.documentAST = (_c = operationFacts == null ? void 0 : operationFacts.documentAST) != null ? _c : null;
      editorInstance.operationName = operationName != null ? operationName : null;
      editorInstance.operations = (_d = operationFacts == null ? void 0 : operationFacts.operations) != null ? _d : null;
      if (variableEditor) {
        variableEditor.state.lint.linterOptions.variableToType = operationFacts == null ? void 0 : operationFacts.variableToType;
        variableEditor.options.lint.variableToType = operationFacts == null ? void 0 : operationFacts.variableToType;
        variableEditor.options.hintOptions.variableToType = operationFacts == null ? void 0 : operationFacts.variableToType;
        (_e = codeMirrorRef.current) == null ? void 0 : _e.signal(variableEditor, "change", variableEditor);
      }
      return operationFacts ? __spreadProps(__spreadValues({}, operationFacts), { operationName }) : null;
    }
    __name(getAndUpdateOperationFacts, "getAndUpdateOperationFacts");
    __name$d(getAndUpdateOperationFacts, "getAndUpdateOperationFacts");
    const handleChange = debounce(100, (editorInstance) => {
      var _a;
      const query = editorInstance.getValue();
      storage == null ? void 0 : storage.set(STORAGE_KEY_QUERY, query);
      const currentOperationName = editorInstance.operationName;
      const operationFacts = getAndUpdateOperationFacts(editorInstance);
      if ((operationFacts == null ? void 0 : operationFacts.operationName) !== void 0) {
        storage == null ? void 0 : storage.set(STORAGE_KEY_OPERATION_NAME, operationFacts.operationName);
      }
      onEdit == null ? void 0 : onEdit(query, operationFacts == null ? void 0 : operationFacts.documentAST);
      if ((operationFacts == null ? void 0 : operationFacts.operationName) && currentOperationName !== operationFacts.operationName) {
        setOperationName(operationFacts.operationName);
      }
      updateActiveTabValues({
        query,
        operationName: (_a = operationFacts == null ? void 0 : operationFacts.operationName) != null ? _a : null
      });
    });
    getAndUpdateOperationFacts(queryEditor);
    queryEditor.on("change", handleChange);
    return () => queryEditor.off("change", handleChange);
  }, [
    onEdit,
    queryEditor,
    schema,
    setOperationName,
    storage,
    variableEditor,
    updateActiveTabValues
  ]);
  useSynchronizeSchema(queryEditor, schema != null ? schema : null, codeMirrorRef);
  useSynchronizeValidationRules(queryEditor, validationRules != null ? validationRules : null, codeMirrorRef);
  useSynchronizeExternalFragments(queryEditor, externalFragments, codeMirrorRef);
  useCompletion(queryEditor, onClickReference || null, useQueryEditor);
  const run3 = executionContext == null ? void 0 : executionContext.run;
  const runAtCursor = useCallback(() => {
    var _a;
    if (!run3 || !queryEditor || !queryEditor.operations || !queryEditor.hasFocus()) {
      run3 == null ? void 0 : run3();
      return;
    }
    const cursorIndex = queryEditor.indexFromPos(queryEditor.getCursor());
    let operationName;
    for (const operation of queryEditor.operations) {
      if (operation.loc && operation.loc.start <= cursorIndex && operation.loc.end >= cursorIndex) {
        operationName = (_a = operation.name) == null ? void 0 : _a.value;
      }
    }
    if (operationName && operationName !== queryEditor.operationName) {
      setOperationName(operationName);
    }
    run3();
  }, [queryEditor, run3, setOperationName]);
  useKeyMap(queryEditor, ["Cmd-Enter", "Ctrl-Enter"], runAtCursor);
  useKeyMap(queryEditor, ["Shift-Ctrl-C"], copy2);
  useKeyMap(queryEditor, [
    "Shift-Ctrl-P",
    "Shift-Ctrl-F"
  ], prettify);
  useKeyMap(queryEditor, ["Shift-Ctrl-M"], merge);
  return ref;
}
__name(useQueryEditor, "useQueryEditor");
__name$d(useQueryEditor, "useQueryEditor");
function useSynchronizeSchema(editor2, schema, codeMirrorRef) {
  useEffect(() => {
    if (!editor2) {
      return;
    }
    const didChange = editor2.options.lint.schema !== schema;
    editor2.state.lint.linterOptions.schema = schema;
    editor2.options.lint.schema = schema;
    editor2.options.hintOptions.schema = schema;
    editor2.options.info.schema = schema;
    editor2.options.jump.schema = schema;
    if (didChange && codeMirrorRef.current) {
      codeMirrorRef.current.signal(editor2, "change", editor2);
    }
  }, [editor2, schema, codeMirrorRef]);
}
__name(useSynchronizeSchema, "useSynchronizeSchema");
__name$d(useSynchronizeSchema, "useSynchronizeSchema");
function useSynchronizeValidationRules(editor2, validationRules, codeMirrorRef) {
  useEffect(() => {
    if (!editor2) {
      return;
    }
    const didChange = editor2.options.lint.validationRules !== validationRules;
    editor2.state.lint.linterOptions.validationRules = validationRules;
    editor2.options.lint.validationRules = validationRules;
    if (didChange && codeMirrorRef.current) {
      codeMirrorRef.current.signal(editor2, "change", editor2);
    }
  }, [editor2, validationRules, codeMirrorRef]);
}
__name(useSynchronizeValidationRules, "useSynchronizeValidationRules");
__name$d(useSynchronizeValidationRules, "useSynchronizeValidationRules");
function useSynchronizeExternalFragments(editor2, externalFragments, codeMirrorRef) {
  const externalFragmentList = useMemo(() => [...externalFragments.values()], [externalFragments]);
  useEffect(() => {
    if (!editor2) {
      return;
    }
    const didChange = editor2.options.lint.externalFragments !== externalFragmentList;
    editor2.state.lint.linterOptions.externalFragments = externalFragmentList;
    editor2.options.lint.externalFragments = externalFragmentList;
    editor2.options.hintOptions.externalFragments = externalFragmentList;
    if (didChange && codeMirrorRef.current) {
      codeMirrorRef.current.signal(editor2, "change", editor2);
    }
  }, [editor2, externalFragmentList, codeMirrorRef]);
}
__name(useSynchronizeExternalFragments, "useSynchronizeExternalFragments");
__name$d(useSynchronizeExternalFragments, "useSynchronizeExternalFragments");
const AUTO_COMPLETE_AFTER_KEY = /^[a-zA-Z0-9_@(]$/;
const STORAGE_KEY_QUERY = "query";
const STORAGE_KEY_OPERATION_NAME = "operationName";
var __defProp$c = Object.defineProperty;
var __name$c = /* @__PURE__ */ __name((target2, value3) => __defProp$c(target2, "name", { value: value3, configurable: true }), "__name$c");
function getDefaultTabState({
  defaultQuery,
  defaultHeaders,
  headers,
  defaultTabs,
  query,
  variables,
  storage
}) {
  const storedState = storage == null ? void 0 : storage.get(STORAGE_KEY$2);
  try {
    if (!storedState) {
      throw new Error("Storage for tabs is empty");
    }
    const parsed = JSON.parse(storedState);
    if (isTabsState(parsed)) {
      const expectedHash = hashFromTabContents({ query, variables, headers });
      let matchingTabIndex = -1;
      for (let index = 0; index < parsed.tabs.length; index++) {
        const tab = parsed.tabs[index];
        tab.hash = hashFromTabContents({
          query: tab.query,
          variables: tab.variables,
          headers: tab.headers
        });
        if (tab.hash === expectedHash) {
          matchingTabIndex = index;
        }
      }
      if (matchingTabIndex >= 0) {
        parsed.activeTabIndex = matchingTabIndex;
      } else {
        const operationName = query ? fuzzyExtractOperationName(query) : null;
        parsed.tabs.push({
          id: guid(),
          hash: expectedHash,
          title: operationName || DEFAULT_TITLE,
          query,
          variables,
          headers,
          operationName,
          response: null
        });
        parsed.activeTabIndex = parsed.tabs.length - 1;
      }
      return parsed;
    }
    throw new Error("Storage for tabs is invalid");
  } catch {
    return {
      activeTabIndex: 0,
      tabs: (defaultTabs || [
        {
          query: query != null ? query : defaultQuery,
          variables,
          headers: headers != null ? headers : defaultHeaders
        }
      ]).map(createTab)
    };
  }
}
__name(getDefaultTabState, "getDefaultTabState");
__name$c(getDefaultTabState, "getDefaultTabState");
function isTabsState(obj) {
  return obj && typeof obj === "object" && !Array.isArray(obj) && hasNumberKey(obj, "activeTabIndex") && "tabs" in obj && Array.isArray(obj.tabs) && obj.tabs.every(isTabState);
}
__name(isTabsState, "isTabsState");
__name$c(isTabsState, "isTabsState");
function isTabState(obj) {
  return obj && typeof obj === "object" && !Array.isArray(obj) && hasStringKey(obj, "id") && hasStringKey(obj, "title") && hasStringOrNullKey(obj, "query") && hasStringOrNullKey(obj, "variables") && hasStringOrNullKey(obj, "headers") && hasStringOrNullKey(obj, "operationName") && hasStringOrNullKey(obj, "response");
}
__name(isTabState, "isTabState");
__name$c(isTabState, "isTabState");
function hasNumberKey(obj, key) {
  return key in obj && typeof obj[key] === "number";
}
__name(hasNumberKey, "hasNumberKey");
__name$c(hasNumberKey, "hasNumberKey");
function hasStringKey(obj, key) {
  return key in obj && typeof obj[key] === "string";
}
__name(hasStringKey, "hasStringKey");
__name$c(hasStringKey, "hasStringKey");
function hasStringOrNullKey(obj, key) {
  return key in obj && (typeof obj[key] === "string" || obj[key] === null);
}
__name(hasStringOrNullKey, "hasStringOrNullKey");
__name$c(hasStringOrNullKey, "hasStringOrNullKey");
function useSynchronizeActiveTabValues({
  queryEditor,
  variableEditor,
  headerEditor,
  responseEditor
}) {
  return useCallback((state2) => {
    var _a, _b, _c, _d, _e;
    const query = (_a = queryEditor == null ? void 0 : queryEditor.getValue()) != null ? _a : null;
    const variables = (_b = variableEditor == null ? void 0 : variableEditor.getValue()) != null ? _b : null;
    const headers = (_c = headerEditor == null ? void 0 : headerEditor.getValue()) != null ? _c : null;
    const operationName = (_d = queryEditor == null ? void 0 : queryEditor.operationName) != null ? _d : null;
    const response = (_e = responseEditor == null ? void 0 : responseEditor.getValue()) != null ? _e : null;
    return setPropertiesInActiveTab(state2, {
      query,
      variables,
      headers,
      response,
      operationName
    });
  }, [queryEditor, variableEditor, headerEditor, responseEditor]);
}
__name(useSynchronizeActiveTabValues, "useSynchronizeActiveTabValues");
__name$c(useSynchronizeActiveTabValues, "useSynchronizeActiveTabValues");
function serializeTabState(tabState, shouldPersistHeaders = false) {
  return JSON.stringify(tabState, (key, value3) => key === "hash" || key === "response" || !shouldPersistHeaders && key === "headers" ? null : value3);
}
__name(serializeTabState, "serializeTabState");
__name$c(serializeTabState, "serializeTabState");
function useStoreTabs({
  storage,
  shouldPersistHeaders
}) {
  const store = useMemo(() => debounce(500, (value3) => {
    storage == null ? void 0 : storage.set(STORAGE_KEY$2, value3);
  }), [storage]);
  return useCallback((currentState) => {
    store(serializeTabState(currentState, shouldPersistHeaders));
  }, [shouldPersistHeaders, store]);
}
__name(useStoreTabs, "useStoreTabs");
__name$c(useStoreTabs, "useStoreTabs");
function useSetEditorValues({
  queryEditor,
  variableEditor,
  headerEditor,
  responseEditor
}) {
  return useCallback(({
    query,
    variables,
    headers,
    response
  }) => {
    queryEditor == null ? void 0 : queryEditor.setValue(query != null ? query : "");
    variableEditor == null ? void 0 : variableEditor.setValue(variables != null ? variables : "");
    headerEditor == null ? void 0 : headerEditor.setValue(headers != null ? headers : "");
    responseEditor == null ? void 0 : responseEditor.setValue(response != null ? response : "");
  }, [headerEditor, queryEditor, responseEditor, variableEditor]);
}
__name(useSetEditorValues, "useSetEditorValues");
__name$c(useSetEditorValues, "useSetEditorValues");
function createTab({
  query = null,
  variables = null,
  headers = null
} = {}) {
  return {
    id: guid(),
    hash: hashFromTabContents({ query, variables, headers }),
    title: query && fuzzyExtractOperationName(query) || DEFAULT_TITLE,
    query,
    variables,
    headers,
    operationName: null,
    response: null
  };
}
__name(createTab, "createTab");
__name$c(createTab, "createTab");
function setPropertiesInActiveTab(state2, partialTab) {
  return __spreadProps(__spreadValues({}, state2), {
    tabs: state2.tabs.map((tab, index) => {
      if (index !== state2.activeTabIndex) {
        return tab;
      }
      const newTab = __spreadValues(__spreadValues({}, tab), partialTab);
      return __spreadProps(__spreadValues({}, newTab), {
        hash: hashFromTabContents(newTab),
        title: newTab.operationName || (newTab.query ? fuzzyExtractOperationName(newTab.query) : void 0) || DEFAULT_TITLE
      });
    })
  });
}
__name(setPropertiesInActiveTab, "setPropertiesInActiveTab");
__name$c(setPropertiesInActiveTab, "setPropertiesInActiveTab");
function guid() {
  const s4 = /* @__PURE__ */ __name$c(() => {
    return Math.floor((1 + Math.random()) * 65536).toString(16).slice(1);
  }, "s4");
  return `${s4()}${s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;
}
__name(guid, "guid");
__name$c(guid, "guid");
function hashFromTabContents(args) {
  var _a, _b, _c;
  return [(_a = args.query) != null ? _a : "", (_b = args.variables) != null ? _b : "", (_c = args.headers) != null ? _c : ""].join("|");
}
__name(hashFromTabContents, "hashFromTabContents");
__name$c(hashFromTabContents, "hashFromTabContents");
function fuzzyExtractOperationName(str) {
  var _a;
  const regex2 = /^(?!#).*(query|subscription|mutation)\s+([a-zA-Z0-9_]+)/m;
  const match2 = regex2.exec(str);
  return (_a = match2 == null ? void 0 : match2[2]) != null ? _a : null;
}
__name(fuzzyExtractOperationName, "fuzzyExtractOperationName");
__name$c(fuzzyExtractOperationName, "fuzzyExtractOperationName");
function clearHeadersFromTabs(storage) {
  const persistedTabs = storage == null ? void 0 : storage.get(STORAGE_KEY$2);
  if (persistedTabs) {
    const parsedTabs = JSON.parse(persistedTabs);
    storage == null ? void 0 : storage.set(STORAGE_KEY$2, JSON.stringify(parsedTabs, (key, value3) => key === "headers" ? null : value3));
  }
}
__name(clearHeadersFromTabs, "clearHeadersFromTabs");
__name$c(clearHeadersFromTabs, "clearHeadersFromTabs");
const DEFAULT_TITLE = "<untitled>";
const STORAGE_KEY$2 = "tabState";
var __defProp$b = Object.defineProperty;
var __name$b = /* @__PURE__ */ __name((target2, value3) => __defProp$b(target2, "name", { value: value3, configurable: true }), "__name$b");
function useVariableEditor({
  editorTheme = DEFAULT_EDITOR_THEME,
  keyMap: keyMap2 = DEFAULT_KEY_MAP,
  onClickReference,
  onEdit,
  readOnly = false
} = {}, caller) {
  const { initialVariables, variableEditor, setVariableEditor } = useEditorContext({
    nonNull: true,
    caller: caller || useVariableEditor
  });
  const executionContext = useExecutionContext();
  const merge = useMergeQuery({ caller: caller || useVariableEditor });
  const prettify = usePrettifyEditors({ caller: caller || useVariableEditor });
  const ref = useRef(null);
  const codeMirrorRef = useRef();
  useEffect(() => {
    let isActive = true;
    importCodeMirror([
      import("./hint.es2.js"),
      import("./lint.es2.js"),
      import("./mode.es3.js")
    ]).then((CodeMirror) => {
      if (!isActive) {
        return;
      }
      codeMirrorRef.current = CodeMirror;
      const container = ref.current;
      if (!container) {
        return;
      }
      const newEditor = CodeMirror(container, {
        value: initialVariables,
        lineNumbers: true,
        tabSize: 2,
        mode: "graphql-variables",
        theme: editorTheme,
        autoCloseBrackets: true,
        matchBrackets: true,
        showCursorWhenSelecting: true,
        readOnly: readOnly ? "nocursor" : false,
        foldGutter: true,
        lint: {
          variableToType: void 0
        },
        hintOptions: {
          closeOnUnfocus: false,
          completeSingle: false,
          container,
          variableToType: void 0
        },
        gutters: ["CodeMirror-linenumbers", "CodeMirror-foldgutter"],
        extraKeys: commonKeys
      });
      newEditor.addKeyMap({
        "Cmd-Space"() {
          newEditor.showHint({ completeSingle: false, container });
        },
        "Ctrl-Space"() {
          newEditor.showHint({ completeSingle: false, container });
        },
        "Alt-Space"() {
          newEditor.showHint({ completeSingle: false, container });
        },
        "Shift-Space"() {
          newEditor.showHint({ completeSingle: false, container });
        }
      });
      newEditor.on("keyup", (editorInstance, event) => {
        const code3 = event.keyCode;
        if (code3 >= 65 && code3 <= 90 || !event.shiftKey && code3 >= 48 && code3 <= 57 || event.shiftKey && code3 === 189 || event.shiftKey && code3 === 222) {
          editorInstance.execCommand("autocomplete");
        }
      });
      setVariableEditor(newEditor);
    });
    return () => {
      isActive = false;
    };
  }, [editorTheme, initialVariables, readOnly, setVariableEditor]);
  useSynchronizeOption(variableEditor, "keyMap", keyMap2);
  useChangeHandler(variableEditor, onEdit, STORAGE_KEY$1, "variables", useVariableEditor);
  useCompletion(variableEditor, onClickReference || null, useVariableEditor);
  useKeyMap(variableEditor, ["Cmd-Enter", "Ctrl-Enter"], executionContext == null ? void 0 : executionContext.run);
  useKeyMap(variableEditor, ["Shift-Ctrl-P"], prettify);
  useKeyMap(variableEditor, ["Shift-Ctrl-M"], merge);
  return ref;
}
__name(useVariableEditor, "useVariableEditor");
__name$b(useVariableEditor, "useVariableEditor");
const STORAGE_KEY$1 = "variables";
var __defProp$a = Object.defineProperty;
var __name$a = /* @__PURE__ */ __name((target2, value3) => __defProp$a(target2, "name", { value: value3, configurable: true }), "__name$a");
const EditorContext = createNullableContext("EditorContext");
function EditorContextProvider(props2) {
  const storage = useStorageContext();
  const [headerEditor, setHeaderEditor] = useState(null);
  const [queryEditor, setQueryEditor] = useState(null);
  const [responseEditor, setResponseEditor] = useState(null);
  const [variableEditor, setVariableEditor] = useState(null);
  const [shouldPersistHeaders, setShouldPersistHeadersInternal] = useState(() => {
    const isStored = (storage == null ? void 0 : storage.get(PERSIST_HEADERS_STORAGE_KEY)) !== null;
    return props2.shouldPersistHeaders !== false && isStored ? (storage == null ? void 0 : storage.get(PERSIST_HEADERS_STORAGE_KEY)) === "true" : Boolean(props2.shouldPersistHeaders);
  });
  useSynchronizeValue(headerEditor, props2.headers);
  useSynchronizeValue(queryEditor, props2.query);
  useSynchronizeValue(responseEditor, props2.response);
  useSynchronizeValue(variableEditor, props2.variables);
  const storeTabs = useStoreTabs({
    storage,
    shouldPersistHeaders
  });
  const [initialState2] = useState(() => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i;
    const query = (_b = (_a = props2.query) != null ? _a : storage == null ? void 0 : storage.get(STORAGE_KEY_QUERY)) != null ? _b : null;
    const variables = (_d = (_c = props2.variables) != null ? _c : storage == null ? void 0 : storage.get(STORAGE_KEY$1)) != null ? _d : null;
    const headers = (_f = (_e = props2.headers) != null ? _e : storage == null ? void 0 : storage.get(STORAGE_KEY$3)) != null ? _f : null;
    const response = (_g = props2.response) != null ? _g : "";
    const tabState2 = getDefaultTabState({
      query,
      variables,
      headers,
      defaultTabs: props2.defaultTabs || props2.initialTabs,
      defaultQuery: props2.defaultQuery || DEFAULT_QUERY,
      defaultHeaders: props2.defaultHeaders,
      storage
    });
    storeTabs(tabState2);
    return {
      query: (_h = query != null ? query : tabState2.activeTabIndex === 0 ? tabState2.tabs[0].query : null) != null ? _h : "",
      variables: variables != null ? variables : "",
      headers: (_i = headers != null ? headers : props2.defaultHeaders) != null ? _i : "",
      response,
      tabState: tabState2
    };
  });
  const [tabState, setTabState] = useState(initialState2.tabState);
  const setShouldPersistHeaders = useCallback((persist) => {
    var _a;
    if (persist) {
      storage == null ? void 0 : storage.set(STORAGE_KEY$3, (_a = headerEditor == null ? void 0 : headerEditor.getValue()) != null ? _a : "");
      const serializedTabs = serializeTabState(tabState, true);
      storage == null ? void 0 : storage.set(STORAGE_KEY$2, serializedTabs);
    } else {
      storage == null ? void 0 : storage.set(STORAGE_KEY$3, "");
      clearHeadersFromTabs(storage);
    }
    setShouldPersistHeadersInternal(persist);
    storage == null ? void 0 : storage.set(PERSIST_HEADERS_STORAGE_KEY, persist.toString());
  }, [storage, tabState, headerEditor]);
  const lastShouldPersistHeadersProp = useRef(void 0);
  useEffect(() => {
    const propValue = Boolean(props2.shouldPersistHeaders);
    if (lastShouldPersistHeadersProp.current !== propValue) {
      setShouldPersistHeaders(propValue);
      lastShouldPersistHeadersProp.current = propValue;
    }
  }, [props2.shouldPersistHeaders, setShouldPersistHeaders]);
  const synchronizeActiveTabValues = useSynchronizeActiveTabValues({
    queryEditor,
    variableEditor,
    headerEditor,
    responseEditor
  });
  const setEditorValues = useSetEditorValues({
    queryEditor,
    variableEditor,
    headerEditor,
    responseEditor
  });
  const {
    onTabChange,
    defaultHeaders,
    children
  } = props2;
  const addTab = useCallback(() => {
    setTabState((current) => {
      const updatedValues = synchronizeActiveTabValues(current);
      const updated = {
        tabs: [...updatedValues.tabs, createTab({
          headers: defaultHeaders
        })],
        activeTabIndex: updatedValues.tabs.length
      };
      storeTabs(updated);
      setEditorValues(updated.tabs[updated.activeTabIndex]);
      onTabChange == null ? void 0 : onTabChange(updated);
      return updated;
    });
  }, [defaultHeaders, onTabChange, setEditorValues, storeTabs, synchronizeActiveTabValues]);
  const changeTab = useCallback((index) => {
    setTabState((current) => {
      const updated = __spreadProps(__spreadValues({}, synchronizeActiveTabValues(current)), {
        activeTabIndex: index
      });
      storeTabs(updated);
      setEditorValues(updated.tabs[updated.activeTabIndex]);
      onTabChange == null ? void 0 : onTabChange(updated);
      return updated;
    });
  }, [onTabChange, setEditorValues, storeTabs, synchronizeActiveTabValues]);
  const closeTab = useCallback((index) => {
    setTabState((current) => {
      const updated = {
        tabs: current.tabs.filter((_tab, i) => index !== i),
        activeTabIndex: Math.max(current.activeTabIndex - 1, 0)
      };
      storeTabs(updated);
      setEditorValues(updated.tabs[updated.activeTabIndex]);
      onTabChange == null ? void 0 : onTabChange(updated);
      return updated;
    });
  }, [onTabChange, setEditorValues, storeTabs]);
  const updateActiveTabValues = useCallback((partialTab) => {
    setTabState((current) => {
      const updated = setPropertiesInActiveTab(current, partialTab);
      storeTabs(updated);
      onTabChange == null ? void 0 : onTabChange(updated);
      return updated;
    });
  }, [onTabChange, storeTabs]);
  const {
    onEditOperationName
  } = props2;
  const setOperationName = useCallback((operationName) => {
    if (!queryEditor) {
      return;
    }
    queryEditor.operationName = operationName;
    updateActiveTabValues({
      operationName
    });
    onEditOperationName == null ? void 0 : onEditOperationName(operationName);
  }, [onEditOperationName, queryEditor, updateActiveTabValues]);
  const externalFragments = useMemo(() => {
    const map2 = /* @__PURE__ */ new Map();
    if (Array.isArray(props2.externalFragments)) {
      for (const fragment of props2.externalFragments) {
        map2.set(fragment.name.value, fragment);
      }
    } else if (typeof props2.externalFragments === "string") {
      visit$1(parse$2(props2.externalFragments, {}), {
        FragmentDefinition(fragment) {
          map2.set(fragment.name.value, fragment);
        }
      });
    } else if (props2.externalFragments) {
      throw new Error("The `externalFragments` prop must either be a string that contains the fragment definitions in SDL or a list of FragmentDefinitionNode objects.");
    }
    return map2;
  }, [props2.externalFragments]);
  const validationRules = useMemo(() => props2.validationRules || [], [props2.validationRules]);
  const value3 = useMemo(() => __spreadProps(__spreadValues({}, tabState), {
    addTab,
    changeTab,
    closeTab,
    updateActiveTabValues,
    headerEditor,
    queryEditor,
    responseEditor,
    variableEditor,
    setHeaderEditor,
    setQueryEditor,
    setResponseEditor,
    setVariableEditor,
    setOperationName,
    initialQuery: initialState2.query,
    initialVariables: initialState2.variables,
    initialHeaders: initialState2.headers,
    initialResponse: initialState2.response,
    externalFragments,
    validationRules,
    shouldPersistHeaders,
    setShouldPersistHeaders
  }), [tabState, addTab, changeTab, closeTab, updateActiveTabValues, headerEditor, queryEditor, responseEditor, variableEditor, setOperationName, initialState2, externalFragments, validationRules, shouldPersistHeaders, setShouldPersistHeaders]);
  return /* @__PURE__ */ jsx(EditorContext.Provider, {
    value: value3,
    children
  });
}
__name(EditorContextProvider, "EditorContextProvider");
__name$a(EditorContextProvider, "EditorContextProvider");
const useEditorContext = createContextHook(EditorContext);
const PERSIST_HEADERS_STORAGE_KEY = "shouldPersistHeaders";
const DEFAULT_QUERY = `# Welcome to GraphiQL
#
# GraphiQL is an in-browser tool for writing, validating, and
# testing GraphQL queries.
#
# Type queries into this side of the screen, and you will see intelligent
# typeaheads aware of the current GraphQL type schema and live syntax and
# validation errors highlighted within the text.
#
# GraphQL queries typically start with a "{" character. Lines that start
# with a # are ignored.
#
# An example GraphQL query might look like:
#
#     {
#       field(arg: "value") {
#         subField
#       }
#     }
#
# Keyboard shortcuts:
#
#   Prettify query:  Shift-Ctrl-P (or press the prettify button)
#
#  Merge fragments:  Shift-Ctrl-M (or press the merge button)
#
#        Run Query:  Ctrl-Enter (or press the play button)
#
#    Auto Complete:  Ctrl-Space (or just start typing)
#

`;
var codemirror = /* @__PURE__ */ (() => '.CodeMirror{font-family:monospace;height:300px;color:#000;direction:ltr}.CodeMirror-lines{padding:4px 0}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like{padding:0 4px}.CodeMirror-scrollbar-filler,.CodeMirror-gutter-filler{background-color:#fff}.CodeMirror-gutters{border-right:1px solid #ddd;background-color:#f7f7f7;white-space:nowrap}.CodeMirror-linenumber{padding:0 3px 0 5px;min-width:20px;text-align:right;color:#999;white-space:nowrap}.CodeMirror-guttermarker{color:#000}.CodeMirror-guttermarker-subtle{color:#999}.CodeMirror-cursor{border-left:1px solid black;border-right:none;width:0}.CodeMirror div.CodeMirror-secondarycursor{border-left:1px solid silver}.cm-fat-cursor .CodeMirror-cursor{width:auto;border:0!important;background:#7e7}.cm-fat-cursor div.CodeMirror-cursors{z-index:1}.cm-fat-cursor .CodeMirror-line::selection,.cm-fat-cursor .CodeMirror-line>span::selection,.cm-fat-cursor .CodeMirror-line>span>span::selection{background:transparent}.cm-fat-cursor .CodeMirror-line::-moz-selection,.cm-fat-cursor .CodeMirror-line>span::-moz-selection,.cm-fat-cursor .CodeMirror-line>span>span::-moz-selection{background:transparent}.cm-fat-cursor{caret-color:transparent}@-moz-keyframes blink{50%{background-color:transparent}}@-webkit-keyframes blink{50%{background-color:transparent}}@keyframes blink{50%{background-color:transparent}}.cm-tab{display:inline-block;text-decoration:inherit}.CodeMirror-rulers{position:absolute;left:0;right:0;top:-50px;bottom:0;overflow:hidden}.CodeMirror-ruler{border-left:1px solid #ccc;top:0;bottom:0;position:absolute}.cm-s-default .cm-header{color:#00f}.cm-s-default .cm-quote{color:#090}.cm-negative{color:#d44}.cm-positive{color:#292}.cm-header,.cm-strong{font-weight:700}.cm-em{font-style:italic}.cm-link{text-decoration:underline}.cm-strikethrough{text-decoration:line-through}.cm-s-default .cm-keyword{color:#708}.cm-s-default .cm-atom{color:#219}.cm-s-default .cm-number{color:#164}.cm-s-default .cm-def{color:#00f}.cm-s-default .cm-variable-2{color:#05a}.cm-s-default .cm-variable-3,.cm-s-default .cm-type{color:#085}.cm-s-default .cm-comment{color:#a50}.cm-s-default .cm-string{color:#a11}.cm-s-default .cm-string-2{color:#f50}.cm-s-default .cm-meta,.cm-s-default .cm-qualifier{color:#555}.cm-s-default .cm-builtin{color:#30a}.cm-s-default .cm-bracket{color:#997}.cm-s-default .cm-tag{color:#170}.cm-s-default .cm-attribute{color:#00c}.cm-s-default .cm-hr{color:#999}.cm-s-default .cm-link{color:#00c}.cm-s-default .cm-error,.cm-invalidchar{color:red}.CodeMirror-composing{border-bottom:2px solid}div.CodeMirror span.CodeMirror-matchingbracket{color:#0b0}div.CodeMirror span.CodeMirror-nonmatchingbracket{color:#a22}.CodeMirror-matchingtag{background:rgba(255,150,0,.3)}.CodeMirror-activeline-background{background:#e8f2ff}.CodeMirror{position:relative;overflow:hidden;background:white}.CodeMirror-scroll{overflow:scroll!important;margin-bottom:-50px;margin-right:-50px;padding-bottom:50px;height:100%;outline:none;position:relative;z-index:0}.CodeMirror-sizer{position:relative;border-right:50px solid transparent}.CodeMirror-vscrollbar,.CodeMirror-hscrollbar,.CodeMirror-scrollbar-filler,.CodeMirror-gutter-filler{position:absolute;z-index:6;display:none;outline:none}.CodeMirror-vscrollbar{right:0;top:0;overflow-x:hidden;overflow-y:scroll}.CodeMirror-hscrollbar{bottom:0;left:0;overflow-y:hidden;overflow-x:scroll}.CodeMirror-scrollbar-filler{right:0;bottom:0}.CodeMirror-gutter-filler{left:0;bottom:0}.CodeMirror-gutters{position:absolute;left:0;top:0;min-height:100%;z-index:3}.CodeMirror-gutter{white-space:normal;height:100%;display:inline-block;vertical-align:top;margin-bottom:-50px}.CodeMirror-gutter-wrapper{position:absolute;z-index:4;background:none!important;border:none!important}.CodeMirror-gutter-background{position:absolute;top:0;bottom:0;z-index:4}.CodeMirror-gutter-elt{position:absolute;cursor:default;z-index:4}.CodeMirror-gutter-wrapper ::selection{background-color:transparent}.CodeMirror-gutter-wrapper ::-moz-selection{background-color:transparent}.CodeMirror-lines{cursor:text;min-height:1px}.CodeMirror pre.CodeMirror-line,.CodeMirror pre.CodeMirror-line-like{-moz-border-radius:0;-webkit-border-radius:0;border-radius:0;border-width:0;background:transparent;font-family:inherit;font-size:inherit;margin:0;white-space:pre;word-wrap:normal;line-height:inherit;color:inherit;z-index:2;position:relative;overflow:visible;-webkit-tap-highlight-color:transparent;-webkit-font-variant-ligatures:contextual;font-variant-ligatures:contextual}.CodeMirror-wrap pre.CodeMirror-line,.CodeMirror-wrap pre.CodeMirror-line-like{word-wrap:break-word;white-space:pre-wrap;word-break:normal}.CodeMirror-linebackground{position:absolute;left:0;right:0;top:0;bottom:0;z-index:0}.CodeMirror-linewidget{position:relative;z-index:2;padding:.1px}.CodeMirror-rtl pre{direction:rtl}.CodeMirror-code{outline:none}.CodeMirror-scroll,.CodeMirror-sizer,.CodeMirror-gutter,.CodeMirror-gutters,.CodeMirror-linenumber{-moz-box-sizing:content-box;box-sizing:content-box}.CodeMirror-measure{position:absolute;width:100%;height:0;overflow:hidden;visibility:hidden}.CodeMirror-cursor{position:absolute;pointer-events:none}.CodeMirror-measure pre{position:static}div.CodeMirror-cursors{visibility:hidden;position:relative;z-index:3}div.CodeMirror-dragcursors,.CodeMirror-focused div.CodeMirror-cursors{visibility:visible}.CodeMirror-selected{background:#d9d9d9}.CodeMirror-focused .CodeMirror-selected{background:#d7d4f0}.CodeMirror-crosshair{cursor:crosshair}.CodeMirror-line::selection,.CodeMirror-line>span::selection,.CodeMirror-line>span>span::selection{background:#d7d4f0}.CodeMirror-line::-moz-selection,.CodeMirror-line>span::-moz-selection,.CodeMirror-line>span>span::-moz-selection{background:#d7d4f0}.cm-searching{background-color:#ffa;background-color:#ff06}.cm-force-border{padding-right:.1px}@media print{.CodeMirror div.CodeMirror-cursors{visibility:hidden}}.cm-tab-wrap-hack:after{content:""}span.CodeMirror-selectedtext{background:none}.CodeMirror{height:100%;position:absolute;width:100%}.CodeMirror{font-family:var(--font-family-mono)}.CodeMirror,.CodeMirror-gutters{background:none;background-color:var(--editor-background, hsl(var(--color-base)))}.CodeMirror-linenumber{padding:0}.CodeMirror-gutters{border:none}.cm-s-graphiql{color:hsla(var(--color-neutral),var(--alpha-tertiary))}.cm-s-graphiql .cm-keyword{color:hsl(var(--color-primary))}.cm-s-graphiql .cm-def{color:hsl(var(--color-tertiary))}.cm-s-graphiql .cm-punctuation{color:hsla(var(--color-neutral),var(--alpha-tertiary))}.cm-s-graphiql .cm-variable{color:hsl(var(--color-secondary))}.cm-s-graphiql .cm-atom{color:hsl(var(--color-tertiary))}.cm-s-graphiql .cm-number{color:hsl(var(--color-success))}.cm-s-graphiql .cm-string{color:hsl(var(--color-warning))}.cm-s-graphiql .cm-builtin{color:hsl(var(--color-success))}.cm-s-graphiql .cm-string-2{color:hsl(var(--color-secondary))}.cm-s-graphiql .cm-attribute,.cm-s-graphiql .cm-meta{color:hsl(var(--color-tertiary))}.cm-s-graphiql .cm-property{color:hsl(var(--color-info))}.cm-s-graphiql .cm-qualifier{color:hsl(var(--color-secondary))}.cm-s-graphiql .cm-comment{color:hsla(var(--color-neutral),var(--alpha-secondary))}.cm-s-graphiql .cm-ws{color:hsla(var(--color-neutral),var(--alpha-tertiary))}.cm-s-graphiql .cm-invalidchar{color:hsl(var(--color-error))}.cm-s-graphiql .CodeMirror-cursor{border-left:2px solid hsla(var(--color-neutral),var(--alpha-secondary))}.cm-s-graphiql .CodeMirror-linenumber{color:hsla(var(--color-neutral),var(--alpha-tertiary))}div.CodeMirror span.CodeMirror-matchingbracket,div.CodeMirror span.CodeMirror-nonmatchingbracket{color:hsl(var(--color-warning))}.CodeMirror-selected,.CodeMirror-focused .CodeMirror-selected{background:hsla(var(--color-neutral),var(--alpha-background-heavy))}.CodeMirror-dialog{background:inherit;color:inherit;left:0;right:0;overflow:hidden;padding:var(--px-2) var(--px-6);position:absolute;z-index:6}.CodeMirror-dialog-top{border-bottom:1px solid hsla(var(--color-neutral),var(--alpha-background-heavy));padding-bottom:var(--px-12);top:0}.CodeMirror-dialog-bottom{border-top:1px solid hsla(var(--color-neutral),var(--alpha-background-heavy));bottom:0;padding-top:var(--px-12)}.CodeMirror-search-hint{display:none}.CodeMirror-dialog input{border:1px solid hsla(var(--color-neutral),var(--alpha-background-heavy));border-radius:var(--border-radius-4);padding:var(--px-4)}.CodeMirror-dialog input:focus{outline:hsl(var(--color-primary)) solid 2px}.cm-searching{background-color:hsla(var(--color-warning),var(--alpha-background-light));padding-bottom:1.5px;padding-top:.5px}\n')();
var fold = /* @__PURE__ */ (() => '.CodeMirror-foldmarker{color:#00f;text-shadow:#b9f 1px 1px 2px,#b9f -1px -1px 2px,#b9f 1px -1px 2px,#b9f -1px 1px 2px;font-family:arial;line-height:.3;cursor:pointer}.CodeMirror-foldgutter{width:.7em}.CodeMirror-foldgutter-open,.CodeMirror-foldgutter-folded{cursor:pointer}.CodeMirror-foldgutter-open:after{content:"\\25be"}.CodeMirror-foldgutter-folded:after{content:"\\25b8"}.CodeMirror-foldgutter{width:var(--px-12)}.CodeMirror-foldmarker{background-color:hsl(var(--color-info));border-radius:var(--border-radius-4);color:hsl(var(--color-base));font-family:inherit;margin:0 var(--px-4);padding:0 var(--px-8);text-shadow:none}.CodeMirror-foldgutter-open,.CodeMirror-foldgutter-folded{color:hsla(var(--color-neutral),var(--alpha-tertiary))}.CodeMirror-foldgutter-open:after,.CodeMirror-foldgutter-folded:after{margin:0 var(--px-2)}\n')();
var editor = /* @__PURE__ */ (() => ".graphiql-editor{height:100%;position:relative;width:100%}.graphiql-editor.hidden{left:-9999px;position:absolute;top:-9999px;visibility:hidden}\n")();
var __defProp$9 = Object.defineProperty;
var __name$9 = /* @__PURE__ */ __name((target2, value3) => __defProp$9(target2, "name", { value: value3, configurable: true }), "__name$9");
function HeaderEditor(_ka) {
  var _la = _ka, {
    isHidden: isHidden2
  } = _la, hookArgs = __objRest(_la, [
    "isHidden"
  ]);
  const {
    headerEditor
  } = useEditorContext({
    nonNull: true,
    caller: HeaderEditor
  });
  const ref = useHeaderEditor(hookArgs, HeaderEditor);
  useEffect(() => {
    if (headerEditor && !isHidden2) {
      headerEditor.refresh();
    }
  }, [headerEditor, isHidden2]);
  return /* @__PURE__ */ jsx("div", {
    className: clsx("graphiql-editor", isHidden2 && "hidden"),
    ref
  });
}
__name(HeaderEditor, "HeaderEditor");
__name$9(HeaderEditor, "HeaderEditor");
var __defProp$8 = Object.defineProperty;
var __name$8 = /* @__PURE__ */ __name((target2, value3) => __defProp$8(target2, "name", { value: value3, configurable: true }), "__name$8");
function ImagePreview(props2) {
  var _a;
  const [dimensions, setDimensions] = useState({
    width: null,
    height: null
  });
  const [mime, setMime] = useState(null);
  const ref = useRef(null);
  const src = (_a = tokenToURL(props2.token)) == null ? void 0 : _a.href;
  useEffect(() => {
    if (!ref.current) {
      return;
    }
    if (!src) {
      setDimensions({
        width: null,
        height: null
      });
      setMime(null);
      return;
    }
    fetch(src, {
      method: "HEAD"
    }).then((response) => {
      setMime(response.headers.get("Content-Type"));
    }).catch(() => {
      setMime(null);
    });
  }, [src]);
  const dims = dimensions.width !== null && dimensions.height !== null ? /* @__PURE__ */ jsxs("div", {
    children: [dimensions.width, "x", dimensions.height, mime === null ? null : " " + mime]
  }) : null;
  return /* @__PURE__ */ jsxs("div", {
    children: [/* @__PURE__ */ jsx("img", {
      onLoad: () => {
        var _a2, _b, _c, _d;
        setDimensions({
          width: (_b = (_a2 = ref.current) == null ? void 0 : _a2.naturalWidth) != null ? _b : null,
          height: (_d = (_c = ref.current) == null ? void 0 : _c.naturalHeight) != null ? _d : null
        });
      },
      ref,
      src
    }), dims]
  });
}
__name(ImagePreview, "ImagePreview");
__name$8(ImagePreview, "ImagePreview");
ImagePreview.shouldRender = /* @__PURE__ */ __name$8(/* @__PURE__ */ __name(function shouldRender(token2) {
  const url = tokenToURL(token2);
  return url ? isImageURL(url) : false;
}, "shouldRender"), "shouldRender");
function tokenToURL(token2) {
  if (token2.type !== "string") {
    return;
  }
  const value3 = token2.string.slice(1).slice(0, -1).trim();
  try {
    const {
      location
    } = window;
    return new URL(value3, location.protocol + "//" + location.host);
  } catch {
    return;
  }
}
__name(tokenToURL, "tokenToURL");
__name$8(tokenToURL, "tokenToURL");
function isImageURL(url) {
  return /(bmp|gif|jpeg|jpg|png|svg)$/.test(url.pathname);
}
__name(isImageURL, "isImageURL");
__name$8(isImageURL, "isImageURL");
var lint = /* @__PURE__ */ (() => ".CodeMirror-lint-markers{width:16px}.CodeMirror-lint-tooltip{background-color:#ffd;border:1px solid black;border-radius:4px;color:#000;font-family:monospace;font-size:10pt;overflow:hidden;padding:2px 5px;position:fixed;white-space:pre;white-space:pre-wrap;z-index:100;max-width:600px;opacity:0;transition:opacity .4s;-moz-transition:opacity .4s;-webkit-transition:opacity .4s;-o-transition:opacity .4s;-ms-transition:opacity .4s}.CodeMirror-lint-mark{background-position:left bottom;background-repeat:repeat-x}.CodeMirror-lint-mark-warning{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJFhQXEbhTg7YAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAMklEQVQI12NkgIIvJ3QXMjAwdDN+OaEbysDA4MPAwNDNwMCwiOHLCd1zX07o6kBVGQEAKBANtobskNMAAAAASUVORK5CYII=)}.CodeMirror-lint-mark-error{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAADCAYAAAC09K7GAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9sJDw4cOCW1/KIAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAHElEQVQI12NggIL/DAz/GdA5/xkY/qPKMDAwAADLZwf5rvm+LQAAAABJRU5ErkJggg==)}.CodeMirror-lint-marker{background-position:center center;background-repeat:no-repeat;cursor:pointer;display:inline-block;height:16px;width:16px;vertical-align:middle;position:relative}.CodeMirror-lint-message{padding-left:18px;background-position:top left;background-repeat:no-repeat}.CodeMirror-lint-marker-warning,.CodeMirror-lint-message-warning{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAANlBMVEX/uwDvrwD/uwD/uwD/uwD/uwD/uwD/uwD/uwD6twD/uwAAAADurwD2tQD7uAD+ugAAAAD/uwDhmeTRAAAADHRSTlMJ8mN1EYcbmiixgACm7WbuAAAAVklEQVR42n3PUQqAIBBFUU1LLc3u/jdbOJoW1P08DA9Gba8+YWJ6gNJoNYIBzAA2chBth5kLmG9YUoG0NHAUwFXwO9LuBQL1giCQb8gC9Oro2vp5rncCIY8L8uEx5ZkAAAAASUVORK5CYII=)}.CodeMirror-lint-marker-error,.CodeMirror-lint-message-error{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAHlBMVEW7AAC7AACxAAC7AAC7AAAAAAC4AAC5AAD///+7AAAUdclpAAAABnRSTlMXnORSiwCK0ZKSAAAATUlEQVR42mWPOQ7AQAgDuQLx/z8csYRmPRIFIwRGnosRrpamvkKi0FTIiMASR3hhKW+hAN6/tIWhu9PDWiTGNEkTtIOucA5Oyr9ckPgAWm0GPBog6v4AAAAASUVORK5CYII=)}.CodeMirror-lint-marker-multiple{background-image:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAcAAAAHCAMAAADzjKfhAAAACVBMVEUAAAAAAAC/v7914kyHAAAAAXRSTlMAQObYZgAAACNJREFUeNo1ioEJAAAIwmz/H90iFFSGJgFMe3gaLZ0od+9/AQZ0ADosbYraAAAAAElFTkSuQmCC);background-repeat:no-repeat;background-position:right bottom;width:100%;height:100%}.CodeMirror-lint-line-error{background-color:#b74c5114}.CodeMirror-lint-line-warning{background-color:#ffd3001a}.CodeMirror-lint-mark-error,.CodeMirror-lint-mark-warning{background-repeat:repeat-x;background-size:10px 3px;background-position:0 95%}.cm-s-graphiql .CodeMirror-lint-mark-error{color:hsl(var(--color-error))}.CodeMirror-lint-mark-error{background-image:linear-gradient(45deg,transparent 65%,hsl(var(--color-error)) 80%,transparent 90%),linear-gradient(135deg,transparent 5%,hsl(var(--color-error)) 15%,transparent 25%),linear-gradient(135deg,transparent 45%,hsl(var(--color-error)) 55%,transparent 65%),linear-gradient(45deg,transparent 25%,hsl(var(--color-error)) 35%,transparent 50%)}.cm-s-graphiql .CodeMirror-lint-mark-warning{color:hsl(var(--color-warning))}.CodeMirror-lint-mark-warning{background-image:linear-gradient(45deg,transparent 65%,hsl(var(--color-warning)) 80%,transparent 90%),linear-gradient(135deg,transparent 5%,hsl(var(--color-warning)) 15%,transparent 25%),linear-gradient(135deg,transparent 45%,hsl(var(--color-warning)) 55%,transparent 65%),linear-gradient(45deg,transparent 25%,hsl(var(--color-warning)) 35%,transparent 50%)}.CodeMirror-lint-tooltip{background-color:hsl(var(--color-base));border:var(--popover-border);border-radius:var(--border-radius-8);box-shadow:var(--popover-box-shadow);font-size:var(--font-size-body);font-family:var(--font-family);max-width:600px;overflow:hidden;padding:var(--px-12)}.CodeMirror-lint-message-error,.CodeMirror-lint-message-warning{background-image:none;padding:0}.CodeMirror-lint-message-error{color:hsl(var(--color-error))}.CodeMirror-lint-message-warning{color:hsl(var(--color-warning))}\n")();
var hint = /* @__PURE__ */ (() => ".CodeMirror-hints{position:absolute;z-index:10;overflow:hidden;list-style:none;margin:0;padding:2px;-webkit-box-shadow:2px 3px 5px rgba(0,0,0,.2);-moz-box-shadow:2px 3px 5px rgba(0,0,0,.2);box-shadow:2px 3px 5px #0003;border-radius:3px;border:1px solid silver;background:white;font-size:90%;font-family:monospace;max-height:20em;overflow-y:auto}.CodeMirror-hint{margin:0;padding:0 4px;border-radius:2px;white-space:pre;color:#000;cursor:pointer}li.CodeMirror-hint-active{background:#08f;color:#fff}.CodeMirror-hints{background:hsl(var(--color-base));border:var(--popover-border);border-radius:var(--border-radius-8);box-shadow:var(--popover-box-shadow);display:grid;font-family:var(--font-family);font-size:var(--font-size-body);grid-template-columns:auto fit-content(300px);max-height:264px;padding:0}.CodeMirror-hint{border-radius:var(--border-radius-4);color:hsla(var(--color-neutral),var(--alpha-secondary));grid-column:1 / 2;margin:var(--px-4);padding:var(--px-6) var(--px-8)!important}.CodeMirror-hint:not(:first-child){margin-top:0}li.CodeMirror-hint-active{background:hsla(var(--color-primary),var(--alpha-background-medium));color:hsl(var(--color-primary))}.CodeMirror-hint-information{border-left:1px solid hsla(var(--color-neutral),var(--alpha-background-heavy));grid-column:2 / 3;grid-row:1 / 99999;max-height:264px;overflow:auto;padding:var(--px-12)}.CodeMirror-hint-information-header{display:flex;align-items:baseline}.CodeMirror-hint-information-field-name{font-size:var(--font-size-h4);font-weight:var(--font-weight-medium)}.CodeMirror-hint-information-type-name-pill{border:1px solid hsla(var(--color-neutral),var(--alpha-tertiary));border-radius:var(--border-radius-4);color:hsla(var(--color-neutral),var(--alpha-secondary));margin-left:var(--px-6);padding:var(--px-4)}.CodeMirror-hint-information-type-name{color:inherit;text-decoration:none}.CodeMirror-hint-information-type-name:hover{text-decoration:underline dotted}.CodeMirror-hint-information-description{color:hsla(var(--color-neutral),var(--alpha-secondary));margin-top:var(--px-12)}\n")();
var info = /* @__PURE__ */ (() => ".CodeMirror-info{background-color:hsl(var(--color-base));border:var(--popover-border);border-radius:var(--border-radius-8);box-shadow:var(--popover-box-shadow);color:hsla(var(--color-neutral),1);max-height:300px;max-width:400px;opacity:0;overflow:auto;padding:var(--px-12);position:fixed;transition:opacity .15s;z-index:10}.CodeMirror-info a{color:inherit;text-decoration:none}.CodeMirror-info a:hover{text-decoration:underline dotted}.CodeMirror-info .CodeMirror-info-header{display:flex;align-items:baseline}.CodeMirror-info .CodeMirror-info-header>.type-name,.CodeMirror-info .CodeMirror-info-header>.field-name,.CodeMirror-info .CodeMirror-info-header>.arg-name,.CodeMirror-info .CodeMirror-info-header>.directive-name,.CodeMirror-info .CodeMirror-info-header>.enum-value{font-size:var(--font-size-h4);font-weight:var(--font-weight-medium)}.CodeMirror-info .type-name-pill{border:1px solid hsla(var(--color-neutral),var(--alpha-tertiary));border-radius:var(--border-radius-4);color:hsla(var(--color-neutral),var(--alpha-secondary));margin-left:var(--px-6);padding:var(--px-4)}.CodeMirror-info .info-description{color:hsla(var(--color-neutral),var(--alpha-secondary));margin-top:var(--px-12);overflow:hidden}\n")();
var jump = /* @__PURE__ */ (() => ".CodeMirror-jump-token{text-decoration:underline dotted;cursor:pointer}\n")();
var autoInsertion = /* @__PURE__ */ (() => ".auto-inserted-leaf.cm-property{animation-duration:6s;animation-name:insertionFade;border-radius:var(--border-radius-4);padding:var(--px-2)}@keyframes insertionFade{0%,to{background-color:none}15%,85%{background-color:hsla(var(--color-warning),var(--alpha-background-light))}}\n")();
var __defProp$7 = Object.defineProperty;
var __name$7 = /* @__PURE__ */ __name((target2, value3) => __defProp$7(target2, "name", { value: value3, configurable: true }), "__name$7");
function QueryEditor(props2) {
  const ref = useQueryEditor(props2, QueryEditor);
  return /* @__PURE__ */ jsx("div", {
    className: "graphiql-editor",
    ref
  });
}
__name(QueryEditor, "QueryEditor");
__name$7(QueryEditor, "QueryEditor");
var __defProp$6 = Object.defineProperty;
var __name$6 = /* @__PURE__ */ __name((target2, value3) => __defProp$6(target2, "name", { value: value3, configurable: true }), "__name$6");
function useResponseEditor({
  responseTooltip,
  editorTheme = DEFAULT_EDITOR_THEME,
  keyMap: keyMap2 = DEFAULT_KEY_MAP
} = {}, caller) {
  const {
    fetchError,
    validationErrors
  } = useSchemaContext({
    nonNull: true,
    caller: caller || useResponseEditor
  });
  const {
    initialResponse,
    responseEditor,
    setResponseEditor
  } = useEditorContext({
    nonNull: true,
    caller: caller || useResponseEditor
  });
  const ref = useRef(null);
  const responseTooltipRef = useRef(responseTooltip);
  useEffect(() => {
    responseTooltipRef.current = responseTooltip;
  }, [responseTooltip]);
  useEffect(() => {
    let isActive = true;
    importCodeMirror([
      import("./foldgutter.es.js").then(function(n2) {
        return n2.f;
      }),
      import("./brace-fold.es.js").then(function(n2) {
        return n2.b;
      }),
      import("./dialog.es.js").then(function(n2) {
        return n2.d;
      }),
      import("./search.es.js").then(function(n2) {
        return n2.s;
      }),
      import("./searchcursor.es.js").then(function(n2) {
        return n2.s;
      }),
      import("./jump-to-line.es.js").then(function(n2) {
        return n2.j;
      }),
      import("./sublime.es.js").then(function(n2) {
        return n2.s;
      }),
      import("./mode.es2.js"),
      import("./info-addon.es.js")
    ], {
      useCommonAddons: false
    }).then((CodeMirror) => {
      if (!isActive) {
        return;
      }
      const tooltipDiv = document.createElement("div");
      CodeMirror.registerHelper("info", "graphql-results", (token2, _options, _cm, pos) => {
        const infoElements = [];
        const ResponseTooltipComponent = responseTooltipRef.current;
        if (ResponseTooltipComponent) {
          infoElements.push(/* @__PURE__ */ jsx(ResponseTooltipComponent, {
            pos,
            token: token2
          }));
        }
        if (ImagePreview.shouldRender(token2)) {
          infoElements.push(/* @__PURE__ */ jsx(ImagePreview, {
            token: token2
          }, "image-preview"));
        }
        if (!infoElements.length) {
          ReactDOM.unmountComponentAtNode(tooltipDiv);
          return null;
        }
        ReactDOM.render(infoElements, tooltipDiv);
        return tooltipDiv;
      });
      const container = ref.current;
      if (!container) {
        return;
      }
      const newEditor = CodeMirror(container, {
        value: initialResponse,
        lineWrapping: true,
        readOnly: true,
        theme: editorTheme,
        mode: "graphql-results",
        foldGutter: true,
        gutters: ["CodeMirror-foldgutter"],
        info: true,
        extraKeys: commonKeys
      });
      setResponseEditor(newEditor);
    });
    return () => {
      isActive = false;
    };
  }, [editorTheme, initialResponse, setResponseEditor]);
  useSynchronizeOption(responseEditor, "keyMap", keyMap2);
  useEffect(() => {
    if (fetchError) {
      responseEditor == null ? void 0 : responseEditor.setValue(fetchError);
    }
    if (validationErrors.length > 0) {
      responseEditor == null ? void 0 : responseEditor.setValue(formatError(validationErrors));
    }
  }, [responseEditor, fetchError, validationErrors]);
  return ref;
}
__name(useResponseEditor, "useResponseEditor");
__name$6(useResponseEditor, "useResponseEditor");
var __defProp$5 = Object.defineProperty;
var __name$5 = /* @__PURE__ */ __name((target2, value3) => __defProp$5(target2, "name", { value: value3, configurable: true }), "__name$5");
function ResponseEditor(props2) {
  const ref = useResponseEditor(props2, ResponseEditor);
  return /* @__PURE__ */ jsx("section", {
    className: "result-window",
    "aria-label": "Result Window",
    "aria-live": "polite",
    "aria-atomic": "true",
    ref
  });
}
__name(ResponseEditor, "ResponseEditor");
__name$5(ResponseEditor, "ResponseEditor");
var __defProp$4 = Object.defineProperty;
var __name$4 = /* @__PURE__ */ __name((target2, value3) => __defProp$4(target2, "name", { value: value3, configurable: true }), "__name$4");
function VariableEditor(_ma) {
  var _na = _ma, {
    isHidden: isHidden2
  } = _na, hookArgs = __objRest(_na, [
    "isHidden"
  ]);
  const {
    variableEditor
  } = useEditorContext({
    nonNull: true,
    caller: VariableEditor
  });
  const ref = useVariableEditor(hookArgs, VariableEditor);
  useEffect(() => {
    if (variableEditor && !isHidden2) {
      variableEditor.refresh();
    }
  }, [variableEditor, isHidden2]);
  return /* @__PURE__ */ jsx("div", {
    className: clsx("graphiql-editor", isHidden2 && "hidden"),
    ref
  });
}
__name(VariableEditor, "VariableEditor");
__name$4(VariableEditor, "VariableEditor");
var __defProp$3 = Object.defineProperty;
var __name$3 = /* @__PURE__ */ __name((target2, value3) => __defProp$3(target2, "name", { value: value3, configurable: true }), "__name$3");
function GraphiQLProvider({
  children,
  dangerouslyAssumeSchemaIsValid,
  defaultQuery,
  defaultHeaders,
  defaultTabs,
  externalFragments,
  fetcher,
  getDefaultFieldNames,
  headers,
  initialTabs,
  inputValueDeprecation,
  introspectionQueryName,
  maxHistoryLength,
  onEditOperationName,
  onSchemaChange,
  onTabChange,
  onTogglePluginVisibility,
  operationName,
  plugins,
  query,
  response,
  schema,
  schemaDescription,
  shouldPersistHeaders,
  storage,
  validationRules,
  variables,
  visiblePlugin
}) {
  return /* @__PURE__ */ jsx(StorageContextProvider, {
    storage,
    children: /* @__PURE__ */ jsx(HistoryContextProvider, {
      maxHistoryLength,
      children: /* @__PURE__ */ jsx(EditorContextProvider, {
        defaultQuery,
        defaultHeaders,
        defaultTabs,
        externalFragments,
        headers,
        initialTabs,
        onEditOperationName,
        onTabChange,
        query,
        response,
        shouldPersistHeaders,
        validationRules,
        variables,
        children: /* @__PURE__ */ jsx(SchemaContextProvider, {
          dangerouslyAssumeSchemaIsValid,
          fetcher,
          inputValueDeprecation,
          introspectionQueryName,
          onSchemaChange,
          schema,
          schemaDescription,
          children: /* @__PURE__ */ jsx(ExecutionContextProvider, {
            getDefaultFieldNames,
            fetcher,
            operationName,
            children: /* @__PURE__ */ jsx(ExplorerContextProvider, {
              children: /* @__PURE__ */ jsx(PluginContextProvider, {
                onTogglePluginVisibility,
                plugins,
                visiblePlugin,
                children
              })
            })
          })
        })
      })
    })
  });
}
__name(GraphiQLProvider, "GraphiQLProvider");
__name$3(GraphiQLProvider, "GraphiQLProvider");
var __defProp$2 = Object.defineProperty;
var __name$2 = /* @__PURE__ */ __name((target2, value3) => __defProp$2(target2, "name", { value: value3, configurable: true }), "__name$2");
function useTheme() {
  const storageContext = useStorageContext();
  const [theme, setThemeInternal] = useState(() => {
    if (!storageContext) {
      return null;
    }
    const stored = storageContext.get(STORAGE_KEY);
    switch (stored) {
      case "light":
        return "light";
      case "dark":
        return "dark";
      default:
        if (typeof stored === "string") {
          storageContext.set(STORAGE_KEY, "");
        }
        return null;
    }
  });
  useLayoutEffect(() => {
    if (typeof window === "undefined") {
      return;
    }
    document.body.classList.remove("graphiql-light", "graphiql-dark");
    if (theme) {
      document.body.classList.add(`graphiql-${theme}`);
    }
  }, [theme]);
  const setTheme = useCallback((newTheme) => {
    storageContext == null ? void 0 : storageContext.set(STORAGE_KEY, newTheme || "");
    setThemeInternal(newTheme);
  }, [storageContext]);
  return useMemo(() => ({ theme, setTheme }), [theme, setTheme]);
}
__name(useTheme, "useTheme");
__name$2(useTheme, "useTheme");
const STORAGE_KEY = "theme";
var __defProp$1 = Object.defineProperty;
var __name$1 = /* @__PURE__ */ __name((target2, value3) => __defProp$1(target2, "name", { value: value3, configurable: true }), "__name$1");
function useDragResize({
  defaultSizeRelation = DEFAULT_FLEX,
  direction,
  initiallyHidden,
  onHiddenElementChange,
  sizeThresholdFirst = 100,
  sizeThresholdSecond = 100,
  storageKey
}) {
  const storage = useStorageContext();
  const store = useMemo(() => debounce(500, (value3) => {
    if (storage && storageKey) {
      storage.set(storageKey, value3);
    }
  }), [storage, storageKey]);
  const [hiddenElement, setHiddenElement] = useState(() => {
    const storedValue = storage && storageKey ? storage.get(storageKey) : null;
    if (storedValue === HIDE_FIRST || initiallyHidden === "first") {
      return "first";
    }
    if (storedValue === HIDE_SECOND || initiallyHidden === "second") {
      return "second";
    }
    return null;
  });
  const setHiddenElementWithCallback = useCallback((element) => {
    if (element !== hiddenElement) {
      setHiddenElement(element);
      onHiddenElementChange == null ? void 0 : onHiddenElementChange(element);
    }
  }, [hiddenElement, onHiddenElementChange]);
  const firstRef = useRef(null);
  const dragBarRef = useRef(null);
  const secondRef = useRef(null);
  const defaultFlexRef = useRef(`${defaultSizeRelation}`);
  useLayoutEffect(() => {
    const storedValue = storage && storageKey ? storage.get(storageKey) || defaultFlexRef.current : defaultFlexRef.current;
    const flexDirection = direction === "horizontal" ? "row" : "column";
    if (firstRef.current) {
      firstRef.current.style.display = "flex";
      firstRef.current.style.flexDirection = flexDirection;
      firstRef.current.style.flex = storedValue === HIDE_FIRST || storedValue === HIDE_SECOND ? defaultFlexRef.current : storedValue;
    }
    if (secondRef.current) {
      secondRef.current.style.display = "flex";
      secondRef.current.style.flexDirection = flexDirection;
      secondRef.current.style.flex = "1";
    }
    if (dragBarRef.current) {
      dragBarRef.current.style.display = "flex";
      dragBarRef.current.style.flexDirection = flexDirection;
    }
  }, [direction, storage, storageKey]);
  const hide = useCallback((resizableElement) => {
    const element = resizableElement === "first" ? firstRef.current : secondRef.current;
    if (!element) {
      return;
    }
    element.style.left = "-1000px";
    element.style.position = "absolute";
    element.style.opacity = "0";
    element.style.height = "500px";
    element.style.width = "500px";
    if (firstRef.current) {
      const flex = parseFloat(firstRef.current.style.flex);
      if (!Number.isFinite(flex) || flex < 1) {
        firstRef.current.style.flex = "1";
      }
    }
  }, []);
  const show = useCallback((resizableElement) => {
    const element = resizableElement === "first" ? firstRef.current : secondRef.current;
    if (!element) {
      return;
    }
    element.style.width = "";
    element.style.height = "";
    element.style.opacity = "";
    element.style.position = "";
    element.style.left = "";
    if (firstRef.current && storage && storageKey) {
      const storedValue = storage == null ? void 0 : storage.get(storageKey);
      if (storedValue !== HIDE_FIRST && storedValue !== HIDE_SECOND) {
        firstRef.current.style.flex = storedValue || defaultFlexRef.current;
      }
    }
  }, [storage, storageKey]);
  useLayoutEffect(() => {
    if (hiddenElement === "first") {
      hide("first");
    } else {
      show("first");
    }
    if (hiddenElement === "second") {
      hide("second");
    } else {
      show("second");
    }
  }, [hiddenElement, hide, show]);
  useEffect(() => {
    if (!dragBarRef.current || !firstRef.current || !secondRef.current) {
      return;
    }
    const dragBarContainer = dragBarRef.current;
    const firstContainer = firstRef.current;
    const wrapper = firstContainer.parentElement;
    const eventProperty = direction === "horizontal" ? "clientX" : "clientY";
    const rectProperty = direction === "horizontal" ? "left" : "top";
    const adjacentRectProperty = direction === "horizontal" ? "right" : "bottom";
    const sizeProperty = direction === "horizontal" ? "clientWidth" : "clientHeight";
    function handleMouseDown(downEvent) {
      downEvent.preventDefault();
      const offset = downEvent[eventProperty] - dragBarContainer.getBoundingClientRect()[rectProperty];
      function handleMouseMove(moveEvent) {
        if (moveEvent.buttons === 0) {
          return handleMouseUp();
        }
        const firstSize = moveEvent[eventProperty] - wrapper.getBoundingClientRect()[rectProperty] - offset;
        const secondSize = wrapper.getBoundingClientRect()[adjacentRectProperty] - moveEvent[eventProperty] + offset - dragBarContainer[sizeProperty];
        if (firstSize < sizeThresholdFirst) {
          setHiddenElementWithCallback("first");
          store(HIDE_FIRST);
        } else if (secondSize < sizeThresholdSecond) {
          setHiddenElementWithCallback("second");
          store(HIDE_SECOND);
        } else {
          setHiddenElementWithCallback(null);
          const newFlex = `${firstSize / secondSize}`;
          firstContainer.style.flex = newFlex;
          store(newFlex);
        }
      }
      __name(handleMouseMove, "handleMouseMove");
      __name$1(handleMouseMove, "handleMouseMove");
      function handleMouseUp() {
        document.removeEventListener("mousemove", handleMouseMove);
        document.removeEventListener("mouseup", handleMouseUp);
      }
      __name(handleMouseUp, "handleMouseUp");
      __name$1(handleMouseUp, "handleMouseUp");
      document.addEventListener("mousemove", handleMouseMove);
      document.addEventListener("mouseup", handleMouseUp);
    }
    __name(handleMouseDown, "handleMouseDown");
    __name$1(handleMouseDown, "handleMouseDown");
    dragBarContainer.addEventListener("mousedown", handleMouseDown);
    function reset() {
      if (firstRef.current) {
        firstRef.current.style.flex = defaultFlexRef.current;
      }
      store(defaultFlexRef.current);
      setHiddenElementWithCallback(null);
    }
    __name(reset, "reset");
    __name$1(reset, "reset");
    dragBarContainer.addEventListener("dblclick", reset);
    return () => {
      dragBarContainer.removeEventListener("mousedown", handleMouseDown);
      dragBarContainer.removeEventListener("dblclick", reset);
    };
  }, [
    direction,
    setHiddenElementWithCallback,
    sizeThresholdFirst,
    sizeThresholdSecond,
    store
  ]);
  return useMemo(() => ({
    dragBarRef,
    hiddenElement,
    firstRef,
    setHiddenElement,
    secondRef
  }), [hiddenElement, setHiddenElement]);
}
__name(useDragResize, "useDragResize");
__name$1(useDragResize, "useDragResize");
const DEFAULT_FLEX = 1;
const HIDE_FIRST = "hide-first";
const HIDE_SECOND = "hide-second";
var button = /* @__PURE__ */ (() => "button.graphiql-toolbar-button{display:flex;align-items:center;justify-content:center;height:var(--toolbar-width);width:var(--toolbar-width)}button.graphiql-toolbar-button.error{background:hsla(var(--color-error),var(--alpha-background-heavy))}\n")();
const ToolbarButton = forwardRef((_oa, ref) => {
  var _pa = _oa, {
    label
  } = _pa, props2 = __objRest(_pa, [
    "label"
  ]);
  const [error2, setError] = useState(null);
  return /* @__PURE__ */ jsx(Tooltip, {
    label,
    children: /* @__PURE__ */ jsx(UnStyledButton, __spreadProps(__spreadValues({}, props2), {
      ref,
      type: "button",
      className: clsx("graphiql-toolbar-button", error2 && "error", props2.className),
      onClick: (event) => {
        var _a;
        try {
          (_a = props2.onClick) == null ? void 0 : _a.call(props2, event);
          setError(null);
        } catch (err) {
          setError(err instanceof Error ? err : new Error(`Toolbar button click failed: ${err}`));
        }
      },
      "aria-label": error2 ? error2.message : label,
      "aria-invalid": error2 ? "true" : props2["aria-invalid"]
    }))
  });
});
ToolbarButton.displayName = "ToolbarButton";
var execute = /* @__PURE__ */ (() => ".graphiql-execute-button-wrapper{position:relative}button.graphiql-execute-button{background-color:hsl(var(--color-primary));border:none;border-radius:var(--border-radius-8);cursor:pointer;height:var(--toolbar-width);padding:0;width:var(--toolbar-width)}button.graphiql-execute-button:hover{background-color:hsla(var(--color-primary),.9)}button.graphiql-execute-button:active{background-color:hsla(var(--color-primary),.8)}button.graphiql-execute-button:focus{outline:hsla(var(--color-primary),.8) auto 1px}button.graphiql-execute-button>svg{color:#fff;display:block;height:var(--px-16);margin:auto;width:var(--px-16)}\n")();
var __defProp2 = Object.defineProperty;
var __name2 = /* @__PURE__ */ __name((target2, value3) => __defProp2(target2, "name", { value: value3, configurable: true }), "__name");
function ExecuteButton() {
  const {
    queryEditor,
    setOperationName
  } = useEditorContext({
    nonNull: true,
    caller: ExecuteButton
  });
  const {
    isFetching,
    isSubscribed,
    operationName,
    run: run3,
    stop
  } = useExecutionContext({
    nonNull: true,
    caller: ExecuteButton
  });
  const operations = (queryEditor == null ? void 0 : queryEditor.operations) || [];
  const hasOptions = operations.length > 1 && typeof operationName !== "string";
  const isRunning = isFetching || isSubscribed;
  const label = `${isRunning ? "Stop" : "Execute"} query (Ctrl-Enter)`;
  const buttonProps = {
    type: "button",
    className: "graphiql-execute-button",
    children: isRunning ? /* @__PURE__ */ jsx(StopIcon, {}) : /* @__PURE__ */ jsx(PlayIcon, {}),
    "aria-label": label
  };
  return hasOptions && !isRunning ? /* @__PURE__ */ jsxs(Menu, {
    children: [/* @__PURE__ */ jsx(Tooltip, {
      label,
      children: /* @__PURE__ */ jsx(Menu.Button, __spreadValues({}, buttonProps))
    }), /* @__PURE__ */ jsx(Menu.List, {
      children: operations.map((operation, i) => {
        const opName = operation.name ? operation.name.value : `<Unnamed ${operation.operation}>`;
        return /* @__PURE__ */ jsx(Menu.Item, {
          onSelect: () => {
            var _a;
            const selectedOperationName = (_a = operation.name) == null ? void 0 : _a.value;
            if (queryEditor && selectedOperationName && selectedOperationName !== queryEditor.operationName) {
              setOperationName(selectedOperationName);
            }
            run3();
          },
          children: opName
        }, `${opName}-${i}`);
      })
    })]
  }) : /* @__PURE__ */ jsx(Tooltip, {
    label,
    children: /* @__PURE__ */ jsx("button", __spreadProps(__spreadValues({}, buttonProps), {
      onClick: () => {
        if (isRunning) {
          stop();
        } else {
          run3();
        }
      }
    }))
  });
}
__name(ExecuteButton, "ExecuteButton");
__name2(ExecuteButton, "ExecuteButton");
var listbox = /* @__PURE__ */ (() => ".graphiql-toolbar-listbox{display:block;height:var(--toolbar-width);width:var(--toolbar-width)}\n")();
const ToolbarListboxRoot = forwardRef((_qa, ref) => {
  var _ra = _qa, {
    button: button2,
    children,
    label
  } = _ra, props2 = __objRest(_ra, [
    "button",
    "children",
    "label"
  ]);
  const labelWithValue = `${label}${props2.value ? `: ${props2.value}` : ""}`;
  return /* @__PURE__ */ jsxs(Listbox2.Input, __spreadProps(__spreadValues({}, props2), {
    ref,
    className: clsx("graphiql-toolbar-listbox", props2.className),
    "aria-label": labelWithValue,
    children: [/* @__PURE__ */ jsx(Tooltip, {
      label: labelWithValue,
      children: /* @__PURE__ */ jsx(Listbox2.Button, {
        children: button2
      })
    }), /* @__PURE__ */ jsx(Listbox2.Popover, {
      children
    })]
  }));
});
ToolbarListboxRoot.displayName = "ToolbarListbox";
const ToolbarListbox = createComponentGroup(ToolbarListboxRoot, {
  Option: Listbox2.Option
});
var menu = /* @__PURE__ */ (() => "button.graphiql-toolbar-menu{display:block;height:var(--toolbar-width);width:var(--toolbar-width)}\n")();
const ToolbarMenuRoot = forwardRef((_sa, ref) => {
  var _ta = _sa, {
    button: button2,
    children,
    label
  } = _ta, props2 = __objRest(_ta, [
    "button",
    "children",
    "label"
  ]);
  return /* @__PURE__ */ jsxs(Menu, __spreadProps(__spreadValues({}, props2), {
    ref,
    children: [/* @__PURE__ */ jsx(Tooltip, {
      label,
      children: /* @__PURE__ */ jsx(Menu.Button, {
        className: clsx("graphiql-un-styled graphiql-toolbar-menu", props2.className),
        "aria-label": label,
        children: button2
      })
    }), /* @__PURE__ */ jsx(Menu.List, {
      children
    })]
  }));
});
ToolbarMenuRoot.displayName = "ToolbarMenu";
const ToolbarMenu = createComponentGroup(ToolbarMenuRoot, {
  Item: Menu.Item
});
export { HISTORY_PLUGIN as $, Argument as A, ExplorerContextProvider as B, CharacterStream as C, DefaultValue as D, EditorContext as E, ExplorerSection as F, FieldDocumentation as G, HeaderEditor as H, ImagePreview as I, FieldLink as J, SchemaDocumentation as K, LexRules as L, Search as M, TypeDocumentation as N, TypeLink as O, ParseRules as P, QueryEditor as Q, ResponseEditor as R, SchemaMetaFieldDef as S, TypeMetaFieldDef as T, useExplorerContext as U, VariableEditor as V, History as W, HistoryContext as X, HistoryContextProvider as Y, useHistoryContext as Z, DOC_EXPLORER_PLUGIN as _, TypeNameMetaFieldDef as a, PluginContext as a0, PluginContextProvider as a1, usePluginContext as a2, GraphiQLProvider as a3, SchemaContext as a4, SchemaContextProvider as a5, useSchemaContext as a6, StorageContext as a7, StorageContextProvider as a8, useStorageContext as a9, RootTypeIcon as aA, SettingsIcon as aB, StarFilledIcon as aC, StarIcon as aD, StopIcon as aE, TypeIcon as aF, UnStyledButton as aG, Button as aH, ButtonGroup as aI, Dialog2 as aJ, Menu as aK, Listbox2 as aL, MarkdownContent as aM, Spinner as aN, Tab as aO, Tabs as aP, Tooltip as aQ, ToolbarButton as aR, ExecuteButton as aS, ToolbarListbox as aT, ToolbarMenu as aU, useTheme as aa, useDragResize as ab, ArgumentIcon as ac, ChevronDownIcon as ad, ChevronLeftIcon as ae, ChevronUpIcon as af, CloseIcon as ag, CopyIcon as ah, DeprecatedArgumentIcon as ai, DeprecatedEnumValueIcon as aj, DeprecatedFieldIcon as ak, DirectiveIcon as al, DocsFilledIcon as am, DocsIcon as an, EnumValueIcon as ao, FieldIcon as ap, HistoryIcon as aq, ImplementsIcon as ar, KeyboardShortcutIcon as as, MagnifyingGlassIcon as at, MergeIcon as au, PenIcon as av, PlayIcon as aw, PlusIcon as ax, PrettifyIcon as ay, ReloadIcon as az, opt as b, commonjsGlobal as c, EditorContextProvider as d, useCopyQuery as e, useEditorContext as f, getAutocompleteSuggestions as g, useHeaderEditor as h, isIgnored as i, useMergeQuery as j, usePrettifyEditors as k, list$1 as l, useQueryEditor as m, useResponseEditor as n, onlineParser as o, p$1 as p, useVariableEditor as q, ExecutionContext as r, ExecutionContextProvider as s, t$2 as t, useAutoCompleteLeafs as u, useExecutionContext as v, DeprecationReason as w, Directive as x, DocExplorer as y, ExplorerContext as z };
//# sourceMappingURL=index.es.js.map
